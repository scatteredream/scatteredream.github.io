<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Arvo:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scatteredream.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="在之前介绍的分代垃圾回收算法中，我们一直有一个永久代存在，叫 PermGen，内存上它是挨着堆的。为了垃圾回收方便，HotSpot 在永久代上一直是使用老年代的垃圾回收算法。 永久代主要存放以下数据：  JVM internal representation of classes and their metadata Class statics Interned strings  从 JDK7 开">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解堆外内存 Metaspace">
<meta property="og:url" content="http://scatteredream.github.io/2019/12/24/jvm-metaspace/index.html">
<meta property="og:site_name" content="scatteredream&#39;s blog">
<meta property="og:description" content="在之前介绍的分代垃圾回收算法中，我们一直有一个永久代存在，叫 PermGen，内存上它是挨着堆的。为了垃圾回收方便，HotSpot 在永久代上一直是使用老年代的垃圾回收算法。 永久代主要存放以下数据：  JVM internal representation of classes and their metadata Class statics Interned strings  从 JDK7 开">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-lifecycle-allocation.png">
<meta property="og:image" content="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-lifecycle-deallocation.png">
<meta property="og:image" content="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-vslist.png">
<meta property="og:image" content="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-vsnode-multiple-loaders.png">
<meta property="og:image" content="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-vsnode-multiple-loaders-one-dies.png">
<meta property="og:image" content="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-vsnode-multiple-loaders-chunk-reused.png">
<meta property="og:image" content="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-metachunk.png">
<meta property="og:image" content="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-classloadermetaspace.png">
<meta property="og:image" content="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-vsnode-purged.png">
<meta property="og:image" content="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-uncompressed-class-ptr.png">
<meta property="og:image" content="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-compressed-class-ptr.png">
<meta property="og:image" content="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-classspace-duality.png">
<meta property="og:image" content="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-sizing-params.png">
<meta property="og:image" content="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-class-metadata.png">
<meta property="article:published_time" content="2019-12-23T16:00:00.000Z">
<meta property="article:modified_time" content="2025-05-08T05:32:41.141Z">
<meta property="article:author" content="碎梦">
<meta property="article:tag" content="内存qu&#39;yu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-lifecycle-allocation.png">


<link rel="canonical" href="http://scatteredream.github.io/2019/12/24/jvm-metaspace/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://scatteredream.github.io/2019/12/24/jvm-metaspace/","path":"2019/12/24/jvm-metaspace/","title":"深入理解堆外内存 Metaspace"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>深入理解堆外内存 Metaspace | scatteredream's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">scatteredream's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-Metaspace"><span class="nav-number">1.</span> <span class="nav-text">1、什么是 Metaspace</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%86%E9%85%8D-Metaspace-%E7%A9%BA%E9%97%B4"><span class="nav-number">1.1.</span> <span class="nav-text">什么时候分配 Metaspace 空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%9B%9E%E6%94%B6-Metaspace-%E7%A9%BA%E9%97%B4"><span class="nav-number">1.2.</span> <span class="nav-text">什么时候回收 Metaspace 空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%80%9A%E5%B8%B8%E4%BC%9A%E8%A2%AB%E4%BF%9D%E7%95%99"><span class="nav-number">1.3.</span> <span class="nav-text">内存通常会被保留</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE-Metaspace-%E7%A9%BA%E9%97%B4"><span class="nav-number">1.4.</span> <span class="nav-text">配置 Metaspace 空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Metaspace-%E5%92%8C-GC"><span class="nav-number">1.5.</span> <span class="nav-text">Metaspace 和 GC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81Metaspace-%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">2、Metaspace 的架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%BA%95%E5%B1%82%EF%BC%9Athe-space-list"><span class="nav-number">2.1.</span> <span class="nav-text">最底层：the space list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E5%B1%82%EF%BC%9AMetachunk"><span class="nav-number">2.2.</span> <span class="nav-text">中间层：Metachunk</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%A1%B6%E5%B1%82%EF%BC%9AMetablock"><span class="nav-number">2.3.</span> <span class="nav-text">最顶层：Metablock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ClassloaderData-and-ClassLoaderMetaspace"><span class="nav-number">2.4.</span> <span class="nav-text">ClassloaderData and ClassLoaderMetaspace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB"><span class="nav-number">2.5.</span> <span class="nav-text">匿名类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%BF%98%E7%BB%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.6.</span> <span class="nav-text">内存什么时候会还给操作系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E8%8A%82%E5%B0%8F%E7%BB%93"><span class="nav-number">2.7.</span> <span class="nav-text">本节小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-Compressed-Class-Space"><span class="nav-number">3.</span> <span class="nav-text">3、什么是 Compressed Class Space</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.1.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%85%B3-UseCompressedClassPointers-UseCompressedOops"><span class="nav-number">3.2.</span> <span class="nav-text">开关: UseCompressedClassPointers, UseCompressedOops</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%BA%A6%E9%87%8F-Metaspace"><span class="nav-number">4.</span> <span class="nav-text">4、度量 Metaspace</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%80%E4%BB%A5%E8%BF%99%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">所以这意味着什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%A4%A7%E6%A6%82%E9%9C%80%E8%A6%81%E5%A4%9A%E5%A4%A7%E7%9A%84-Metaspace-%E7%A9%BA%E9%97%B4"><span class="nav-number">4.2.</span> <span class="nav-text">一个类大概需要多大的 Metaspace 空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5-Class-Space%EF%BC%9A"><span class="nav-number">4.2.1.</span> <span class="nav-text">深入 Class Space：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5-Non-Class-Space"><span class="nav-number">4.2.2.</span> <span class="nav-text">深入 Non-Class Space</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class-space-%E5%92%8C-Non-Class-Space-%E6%AF%94%E4%BE%8B"><span class="nav-number">4.2.3.</span> <span class="nav-text">Class space 和 Non-Class Space 比例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Metaspace-%E9%BB%98%E8%AE%A4%E5%A4%A7%E5%B0%8F"><span class="nav-number">4.3.</span> <span class="nav-text">Metaspace 默认大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%90%E5%88%B6-Metaspace-%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F"><span class="nav-number">4.4.</span> <span class="nav-text">限制 Metaspace 空间大小</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">小结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="碎梦"
      src="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
  <p class="site-author-name" itemprop="name">碎梦</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">75</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">120</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2019/12/24/jvm-metaspace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="深入理解堆外内存 Metaspace | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入理解堆外内存 Metaspace
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-24 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-24T00:00:00+08:00">2019-12-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-08 13:32:41" itemprop="dateModified" datetime="2025-05-08T13:32:41+08:00">2025-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>在之前介绍的分代垃圾回收算法中，我们一直有一个<strong>永久代</strong>存在，叫 PermGen，内存上它是挨着堆的。为了垃圾回收方便，HotSpot 在永久代上一直是使用老年代的垃圾回收算法。</p>
<p>永久代主要存放以下数据：</p>
<ul>
<li>JVM internal representation of classes and their metadata</li>
<li>Class statics</li>
<li>Interned strings</li>
</ul>
<p>从 JDK7 开始，JDK 开发者们就有消灭永久代的打算了。有部分数据移到永久代之外了：</p>
<ul>
<li>Symbols =&gt; native memory</li>
<li>Interned strings =&gt; Java Heap </li>
<li>Class statics =&gt; Java Heap</li>
</ul>
<p>到了 JDK8，这个工作终于完成了，彻底废弃了 PermGen，Metaspace 取而代之。</p>
<p>本文的内容主要是翻译 Thomas Stüfe 的 <a target="_blank" rel="noopener" href="https://stuefe.de/posts/metaspace/what-is-metaspace/">Metaspace 系列文章</a>，他是 OpenJDK Committer/Reviewer. JVM developer at SAP，一看 Title 就很靠谱，因为他是 JVM 开发者，当然主要是内容也写得非常棒。</p>
<p>当然了，我不是一字一句翻译，文中会删掉部分累赘的内容，讲清楚就可以了。同时，原文第五篇是介绍使用 jcmd 工具观察 Metaspace 的空间使用情况，这一节我觉得没有必要介绍，所以没有加进来。</p>
<h2 id="1、什么是-Metaspace"><a href="#1、什么是-Metaspace" class="headerlink" title="1、什么是 Metaspace"></a>1、什么是 Metaspace</h2><p>Metaspace 区域位于堆外，所以它的最大内存大小取决于系统内存，而不是堆大小，我们可以指定 MaxMetaspaceSize 参数来限定它的最大内存。</p>
<p>Metaspace 是用来存放 class metadata 的，class metadata 用于记录一个 Java 类在 JVM 中的信息，包括但不限于 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">JVM class file format</a> 的运行时数据： </p>
<p>1、Klass 结构，这个非常重要，把它理解为一个 Java 类在虚拟机内部的表示吧；</p>
<p>2、method metadata，包括方法的字节码、局部变量表、异常表、参数信息等；</p>
<p>3、常量池；</p>
<p>4、注解；</p>
<p>5、方法计数器，记录方法被执行的次数，用来辅助 JIT 决策；</p>
<p>6、 其他</p>
<p>虽然每个 Java 类都关联了一个 <code>java.lang.Class</code> 的实例，而且它是一个贮存在堆中的 Java 对象。但是类的 class metadata 不是一个 Java 对象，它不在堆中，而是在 Metaspace 中。</p>
<h3 id="什么时候分配-Metaspace-空间"><a href="#什么时候分配-Metaspace-空间" class="headerlink" title="什么时候分配 Metaspace 空间"></a>什么时候分配 Metaspace 空间</h3><p>当一个类被加载时，它的类加载器会负责在 Metaspace 中分配空间用于存放这个类的元数据。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-lifecycle-allocation.png" alt="Metadata lifecycle - Allocation"></p>
<p>上面这个示意图非常简单，可以看到在 <code>Id</code> 这个类加载器第一次加载类 <code>X</code> 和 <code>Y</code> 的时候，在 Metaspace 中为它们开辟空间存放元信息。</p>
<h3 id="什么时候回收-Metaspace-空间"><a href="#什么时候回收-Metaspace-空间" class="headerlink" title="什么时候回收 Metaspace 空间"></a>什么时候回收 Metaspace 空间</h3><p>分配给一个类的空间，是归属于这个类的类加载器的，只有当这个类加载器卸载的时候，这个空间才会被释放。</p>
<p>所以，只有当这个类加载器加载的所有类都没有存活的对象，并且没有到达这些类和类加载器的引用时，相应的 Metaspace 空间才会被 GC 释放。看下图：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-lifecycle-deallocation.png" alt="Metadata lifecycle - Deallocation"></p>
<p>所以，一个 Java 类在 Metaspace 中占用的空间，它是否释放，取决于这个类的类加载器是否被卸载。</p>
<h3 id="内存通常会被保留"><a href="#内存通常会被保留" class="headerlink" title="内存通常会被保留"></a>内存通常会被保留</h3><p>释放 Metaspace 的空间，并不意味着将这部分空间还给系统内存，这部分空间通常会被 JVM 保留下来。</p>
<p>这部分被保留的空间有多大，取决于 Metaspace 的碎片化程度。另外，Metaspace 中有一部分区域 Compressed Class Space 是一定不会还给操作系统的。</p>
<blockquote>
<p>这里先了解概念，后面都会展开来说。</p>
</blockquote>
<h3 id="配置-Metaspace-空间"><a href="#配置-Metaspace-空间" class="headerlink" title="配置 Metaspace 空间"></a>配置 Metaspace 空间</h3><p>我们只需要关心两个配置参数：</p>
<ul>
<li><p><code>-XX:MaxMetaspaceSize</code>：Metaspace 总空间的最大允许使用内存，默认是不限制。</p>
</li>
<li><p><code>-XX:CompressedClassSpaceSize</code>：Metaspace 中的 Compressed Class Space 的最大允许内存，默认值是 1G，这部分会在 JVM 启动的时候向操作系统申请 1G 的虚拟地址映射，但不是真的就用了操作系统的 1G 内存。</p>
</li>
</ul>
<h3 id="Metaspace-和-GC"><a href="#Metaspace-和-GC" class="headerlink" title="Metaspace 和 GC"></a>Metaspace 和 GC</h3><p>Metaspace 只在 GC 运行并且卸载类加载器的时候才会释放空间。当然，在某些时候，需要主动触发 GC 来回收一些没用的 class metadata，即使这个时候对于堆空间来说，还达不到 GC 的条件。</p>
<p>Metaspace 可能在两种情况下触发 GC：</p>
<p>1、分配空间时：虚拟机维护了一个阈值，如果 Metaspace 的空间大小超过了这个阈值，那么在新的空间分配申请时，虚拟机首先会通过收集可以卸载的类加载器来达到复用空间的目的，而不是扩大 Metaspace 的空间，这个时候会触发 GC。这个阈值会上下调整，和 Metaspace 已经占用的操作系统内存保持一个距离。</p>
<p>2、碰到 Metaspace OOM：Metaspace 的总使用空间达到了 MaxMetaspaceSize 设置的阈值，或者 Compressed Class Space 被使用光了，如果这次 GC 真的通过卸载类加载器腾出了很多的空间，这很好，否则的话，我们会进入一个糟糕的 GC 周期，即使我们有足够的堆内存。</p>
<blockquote>
<p>所以大家千万不要把 MaxMetaspaceSize 设置得太小。</p>
</blockquote>
<h2 id="2、Metaspace-的架构"><a href="#2、Metaspace-的架构" class="headerlink" title="2、Metaspace 的架构"></a>2、Metaspace 的架构</h2><p>这一节将深入到 Metaspace 的架构实现，将描述它的每一层和每一个组件，以及它们是怎么工作的。</p>
<p>对于开发者来说，这一定是非常有趣的一件事情，我们大部分开发者都不可能去开发 JDK，但是了解这些总是充满着乐趣。</p>
<p>Metaspace 在实现上分为多层。最底层，负责向操作系统申请大块的内存；中间的一层，负责分出一小块一小块给每个类加载器；最顶层，类加载器负责把这些申请到的内存块用来存放 class metadata。</p>
<h3 id="最底层：the-space-list"><a href="#最底层：the-space-list" class="headerlink" title="最底层：the space list"></a>最底层：the space list</h3><p>在最底层，JVM 通过 <code>mmap(3)</code> 接口向操作系统申请内存映射，在 64 位平台上，每次申请 <strong>2MB</strong> 空间。</p>
<blockquote>
<p>当然，这里的 2MB 不是真的就消耗了主存的 2MB，只有之后在使用的时候才会真的消耗内存。这里是虚拟内存映射。</p>
</blockquote>
<p>每次申请过来的内存区域，放到一个链表中 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/share/memory/metaspace/virtualSpaceList.hpp#l39"><em>VirtualSpaceList</em></a>，作为其中的一个 Node。看下图。</p>
<p>一个 Node 是 2MB 的空间，前面说了在使用的时候再向操作系统申请实际的内存，但是频繁的系统调用会降低性能，所以 Node 内部需要维护一个水位线，当 Node 内已使用内存快达到水位线的时候，向操作系统要新的内存页。并且相应地提高水位线。</p>
<p>直到一个 Node 被完全用完，会分配一个新的 Node，并且将其加入到链表中，老的 Node 就 “退休” 了。下图中，前面的三个 Node 就是退休状态了。</p>
<p>从一个 Node 中分配内存，每一块称为 MetaChunk，chunk 有三种规格，在 64 位系统中分别为 1K、4K、64K。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-vslist.png" alt="alt text"></p>
<p>链表 VirtualSpaceList 和每个节点 Node 是全局的，而 Node 内部的一个个 MetaChunk 是分配给每个类加载器的。所以一个 Node 通常由分配给多个类加载器的 chunks 组成。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-vsnode-multiple-loaders.png" alt="alt text"></p>
<p>当一个类加载器和它加载的所有的类都卸载的时候，它占用的 chunks 就会加入到一个全局的空闲列表中：<a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/share/memory/metaspace/chunkManager.hpp#l44"><em>ChunkManager</em></a>，看下图：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-vsnode-multiple-loaders-one-dies.png" alt="alt text"></p>
<p>这些 chunks 会被复用：如果其他的类加载器加载新的类，它可能就会得到一个空闲列表中的 chunk，而不是去 Node 中申请一个新的 chunk。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-vsnode-multiple-loaders-chunk-reused.png" alt="alt text"></p>
<blockquote>
<p>后面会说到，如果刚好把整个 Node 都清空了，那么这整个 Node 的内存会直接还给操作系统。</p>
<p>当然，由这个 Node 进入到空闲列表的节点也要删除。</p>
</blockquote>
<h3 id="中间层：Metachunk"><a href="#中间层：Metachunk" class="headerlink" title="中间层：Metachunk"></a>中间层：Metachunk</h3><p>通常一个类加载器在申请 Metaspace 空间用来存放 metadata 的时候，也就需要几十到几百个字节，但是它会得到一个 Metachunk，一个比要求的内存大得多的内存块。</p>
<p>为什么？因为前面说了，要从全局的 <code>VirtualSpaceList</code> 链表的 Node 中分配内存是昂贵的操作，需要加锁。我们不希望这个操作太频繁，所以一次性给一个大的 MetaChunk，以便于这个类加载器之后加载其他的类，这样就可以做到多个类加载器并发分配了。只有当这个 chunk 用完了，类加载器才需要又去 <code>VirtualSpaceList</code> 申请新的 chunk。</p>
<p>前面说了，chunk 有三种规格，那 Metaspace 的分配器怎么知道一个类加载器每次要多大的 chunk 呢？这当然是基于猜测的：</p>
<ul>
<li>通常，一个标准的类加载器在第一次申请空间时，会得到一个 4K 的 chunk，直到它达到了一个随意设置的阈值（4），此时分配器失去了耐心，之后会一次性给它一个 64K 的大 chunk。</li>
<li>bootstrap classloader 是一个公认的会加载大量的类的加载器，所以分配器会给它一个巨大的 chunk，一开始就会给它 4M。可以通过 InitialBootClassLoaderMetaspaceSize 进行调优。</li>
<li>反射类类加载器 (<code>jdk.internal.reflect.DelegatingClassLoader</code>) 和匿名类类加载器只会加载一个类，所以一开始只会给它们一个非常小的 chunk（1K），因为给它们太多就是一种浪费。</li>
</ul>
<p>类加载器申请空间的时候，每次都给类加载器一个 chunk，这种优化，是建立在假设它们立马就会需要新的空间的基础上的。这种假设可能正确也可能错误，可能在拿到一个很大的 chunk 后，这个类加载器恰巧就不再需要加载新的类了。</p>
<blockquote>
<p>对于这部分可能的空间浪费，可以在后面介绍的系统工具中观察到。</p>
</blockquote>
<h3 id="最顶层：Metablock"><a href="#最顶层：Metablock" class="headerlink" title="最顶层：Metablock"></a>最顶层：Metablock</h3><p>在 Metachunk 上，我们有一个二级分配器（class-loader-local allocator），它将一个 Metachunk 分割成一个个小的单元，这些小的单元称为 Metablock，它们是实际分配给每个调用者的。</p>
<p>这个二级分配器非常原始，它的速度也非常快：</p>
<p>前面说过，class metadata 的生命周期是和类加载器绑定的，所以在类加载器卸载的时候，JVM 可以大块大块地释放这些空间。</p>
<p>下面展示一个 Metachunk 的结构：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-metachunk.png" alt="alt text"></p>
<p>这个 chunk 诞生的时候，它只有一个 header，之后的分配都只要在顶部进行分配就行。</p>
<p>由于这个 chunk 是归属于一个类加载器的，所以如果它不再加载新的类，那么 unused 空间就将真的浪费掉。</p>
<h3 id="ClassloaderData-and-ClassLoaderMetaspace"><a href="#ClassloaderData-and-ClassLoaderMetaspace" class="headerlink" title="ClassloaderData and ClassLoaderMetaspace"></a>ClassloaderData and ClassLoaderMetaspace</h3><p>在 JVM 内部，一个类加载器以一个 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/share/classfile/classLoaderData.hpp#l176"><em>ClassLoaderData</em></a> 结构标识，这个结构引用了一个 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/share/memory/metaspace.hpp#l230"><em>ClassLoaderMetaspace</em></a> 结构，它维护了该加载器使用的所有的 Metachunk。</p>
<p>当这个类加载器被卸载的时候，这个 <code>ClassLoaderData</code> 和 <code>ClassLoaderMetaspace</code> 会被删除。并且会将所有的这个加载器用到的 chunks 归还到空闲列表中。这部分内存是否可以直接归还给操作系统取决于是否满足其他条件，后面会介绍。</p>
<blockquote>
<p>就是前面提过的，如果恰好把整个 Node 都清空了，那么这个 Node 的内存直接还给操作系统</p>
</blockquote>
<h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h3><p><code>ClassloaderData != ClassLoaderMetaspace</code></p>
<p>注意，我们前面说，“Metaspace 内存是属于类加载器的”，但是，这里其实撒了一个小谎，如果将匿名类考虑进去，那就更加复杂了：</p>
<p>当类加载器加载一个匿名类时，这个类有自己独立的 <code>ClassLoaderData</code>，它的生命周期是跟随着这个匿名类的，而不是这个类加载器（所以，和它相关的空间可以在类加载器卸载前得到释放）。所以，一个类加载器有一个主要的 ClassLoaderData 结构用来服务所有的正常的类，对于每一个匿名类，还有一个二级的 ClassLoaderData 结构来维护。</p>
<p>这样做的目的之一，其实就是没有必要扩大大量的 Lambdas 和 method  handlers 在 Metaspace 中的空间的生命周期。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-classloadermetaspace.png" alt="alt text"></p>
<h3 id="内存什么时候会还给操作系统"><a href="#内存什么时候会还给操作系统" class="headerlink" title="内存什么时候会还给操作系统"></a>内存什么时候会还给操作系统</h3><p>当一个 VirtualSpaceListNode 中的所有 chunk 都是空闲的时候，这个 Node 就会从链表 VirtualSpaceList 中移除，它的 chunks 也会从空闲列表中移除，这个 Node 就没有被使用了，会将其内存归还给操作系统。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-vsnode-purged.png" alt="alt text"></p>
<p>对于一个空闲的 Node 来说，拥有其上面的 chunks 的所有的类加载器必然都是被卸载了的。</p>
<p>至于这个情况是否可能发生，主要就是取决于碎片化：</p>
<p>一个 Node 是 2M，chunks 的大小为 1K, 4K 或 64K，所以通常一个 Node 上有约 150-200 个 chunks，如果这些 chunks 全部由同一个类加载器拥有，回收这个类加载器就可以一次性回收这个 Node，并且把它的空间还给操作系统。</p>
<p>但是，如果这些 chunks 分配给不同的类加载器，每个类加载器都有不同的生命周期，那么什么都不会被释放。这也许就是在告诉我们，要小心对待大量的小的类加载器，如那些负责加载匿名类或反射类的加载器。</p>
<p>同时也要清楚，Metaspace 中的 <em>Compressed Class Space</em> 是永远不会将内存还给操作系统的。我们马上就要介绍这部分内容了。</p>
<h3 id="本节小结"><a href="#本节小结" class="headerlink" title="本节小结"></a>本节小结</h3><ul>
<li>每次向操作系统申请 2M 的虚拟空间映射，放置到全局链表中，待需要使用的时候申请内存。</li>
<li>一个 Node 会分割为一个个的 chunks，分配给类加载器，一个 chunk 属于一个类加载器。</li>
<li>chunk 再细分为一个个 Metablock，这是分配给调用者的最小单元。</li>
<li>当一个类加载器被卸载，它占有的 chunks 会进入到空闲列表，以便复用，如果运气好的话，有可能会直接把内存归还给操作系统。</li>
</ul>
<h2 id="3、什么是-Compressed-Class-Space"><a href="#3、什么是-Compressed-Class-Space" class="headerlink" title="3、什么是 Compressed Class Space"></a>3、什么是 Compressed Class Space</h2><p>在 64 位平台上，HotSpot 使用了两个压缩优化技术，<strong>Compressed Object Pointers</strong> (<em>“CompressedOops”</em>) 和 <strong>Compressed Class Pointers</strong>。</p>
<p>压缩指针，指的是在 64 位的机器上，使用 32 位的指针来访问数据（堆中的对象或 Metaspace 中的元数据）的一种方式。</p>
<p>这样有很多的好处，比如 32 位的指针占用更小的内存，可以更好地使用缓存，在有些平台，还可以使用到更多的寄存器。</p>
<p>当然，在 64 位的机器中，最终还是需要一个 64 位的地址来访问数据的，所以这个 32 位的值是相对于一个基准地址的值。</p>
<blockquote>
<p>CompressedOops 说的是对象引用的压缩，它不在本文的讨论范围内。</p>
<p>在 64 位平台上，本质上还是需要使用 64 位地址来引用每一个对象的，但是这项技术使得可以只使用 32 位地址来实现引用。大家可以参考一下评论区的讨论，这里就不展开了。</p>
</blockquote>
<p>由于本文在描述的是 Metaspace，所以我们这里不关心 <strong>Compressed Object Pointers</strong>，下面将描述 <strong>Compressed Class Pointers</strong>：</p>
<p>每个 Java 对象，在它的头部，有一个引用指向 Metaspace 中的 Klass 结构。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-uncompressed-class-ptr.png" alt="alt text"></p>
<p>当使用了 compressed class pointers，这个引用是 32 位的值，为了找到真正的 64 位地址，需要加上一个 base 值：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-compressed-class-ptr.png" alt="alt text"></p>
<p>上面的内容应该很好理解，这项技术对 Klass 的分配带来的问题是：由于 32 位地址只能访问到 4G 的空间，所以<strong>最大只允许 4G</strong> 的 Klass 地址。这项限制也意味着，JVM 需要向 Metaspace 分配一个<strong>连续的地址空间</strong>。</p>
<p>当从系统申请内存时，通过调用系统接口 malloc(3) 或 mmap(3)，操作系统可能返回任意一个地址值，所以在 64位系统中，它并不能保证在 4G 的范围内。</p>
<p>所以，我们只能用一个 mmap() 来申请一个区域单独用来存放 Klass 对象。我们需要提前知道这个区域的大小，而且不能超过 4G。显然，这种方式是不能扩展的，因为这个地址后面的内存可能是被占用的。</p>
<p>只有 Klass 结构有这个限制，对于其他的 class metadata 没有这个必要: 因为只有 Klass 实例是通过 Java 对象 header  中的压缩指针访问的。其他的 metadata 都是通过 64 位的地址进行访问的，所以它们可以被放到任意的地址上。</p>
<p>所以，我们决定将 Metaspace 分为两个区域：non-class part 和 class part。</p>
<ul>
<li>class part：存放 Klass 对象，需要一个连续的不超过 4G 的内存</li>
<li>non-class part：包含其他的所有 metadata</li>
</ul>
<blockquote>
<p>class part 被称作 <strong>Compressed Class Space</strong>，这个名字会有点怪，因为 Klass 本身其实没有使用压缩技术，而是引用它们的指针被压缩了。</p>
</blockquote>
<p>compressed class space 空间的大小，是通过 -XX:CompressedClassSpaceSize 指定的。</p>
<p>我们需要提前知道自己需要多少内存，它的<strong>默认值是 1G</strong>。当然这个 1G 并不是真的使用了操作系统的 1G，而是虚拟地址映射。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>为了复用已有的 Metaspace 空间，使用了一个小技巧：</p>
<p>在 Class Space 和 Non-Class Space 中，分别都有 VirtualSpaceList 和 ChunkManager 两个结构。</p>
<p>但是对于 Class Space，既然我们需要一个连续的空间我们不能使用一个链表来存放所有的 Node，所以这个链表退化为只有一个节点，并且不能扩展。这个 Node 就是 compressed class space，和 Non-Class Space 中的 Node 相比，它可是巨大无比。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-classspace-duality.png" alt="alt text"></p>
<p>ClassLoaderMetaspace（记录当前类加载器持有哪些 chunks）需要两个链表，一个用于记录 Class Space 中的 chunks，一个用于记录 Non-Class Space 中的 chunks。</p>
<blockquote>
<p>到这里应该也很好理解，就是对于一个类加载器来说，它需要知道自己使用了 non-class part 中的哪些 chunks 和 class part 中的哪些 chunks。</p>
</blockquote>
<h3 id="开关-UseCompressedClassPointers-UseCompressedOops"><a href="#开关-UseCompressedClassPointers-UseCompressedOops" class="headerlink" title="开关: UseCompressedClassPointers, UseCompressedOops"></a>开关: UseCompressedClassPointers, UseCompressedOops</h3><p><code>-XX:+UseCompressedOops</code> 允许对象指针压缩。</p>
<p><code>-XX:+UseCompressedClassPointers</code>  允许类指针压缩。</p>
<p>它们默认都是开启的，可以手动关闭它们。</p>
<p>如果不允许类指针压缩，那么将没有 compressed class space 这个空间，并且<code>-XX:CompressedClassSpaceSize</code> 这个参数无效。</p>
<p><code>-XX:-UseCompressedClassPointers</code> 需要搭配 <code>-XX:+UseCompressedOops</code>，但是反过来不是: 我们可以只压缩对象指针，不压缩类指针。</p>
<blockquote>
<p>这里面为什么这么规定我也不懂，但是从直觉上来说，压缩对象指针显然是比较重要的，能获得较大的收益。也许就是基于这种考量吧：你连对象指针都不压缩，类指针压缩不压缩又有什么关系呢？</p>
</blockquote>
<p>注意，对象指针压缩要求堆小于 32G，所以如果堆大于等于 32G，那么对象指针压缩和类指针压缩都会被关闭。</p>
<blockquote>
<p>32G 可不是一个掐指一算随便指定的数字，看下评论区就知道原因了。</p>
</blockquote>
<h2 id="4、度量-Metaspace"><a href="#4、度量-Metaspace" class="headerlink" title="4、度量 Metaspace"></a>4、度量 Metaspace</h2><p>前面我们介绍过，<strong>MaxMetaspaceSize</strong> 和 <strong>CompressedClassSpaceSize</strong> 是控制 Metaspace 的两个配置。</p>
<p>回顾一下：</p>
<ul>
<li><p><strong>MaxMetaspaceSize</strong></p>
<p>最大允许 Metaspace 使用的内存，包括 Class Space 和 Non-Class Space，默认是不限制。</p>
</li>
<li><p><strong>CompressedClassSpaceSize</strong></p>
<p>在启动的时候就限制 Class Space 的大小，默认值是 1G，启动后不可以修改。再说一遍，它是 reserved 不是 committed 的内存。</p>
</li>
</ul>
<p>下图展示了它们是怎么工作的：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-sizing-params.png" alt="MaxMetaspaceSize and CompressedClassSpaceSize"></p>
<p>红色部分是 Metaspace 中已使用的系统内存，包括 Non-Class Space 链表中的红色部分和 Class Space 中大 Node 的红色部分。这个总和受到 <code>-XX:MaxMetaspaceSize</code> 的限制，超出将抛出 **OutOfMemoryError(“Metaspace”)**。</p>
<p><code>-XX:CompressedClassSpaceSize</code> 限制了下方的 Class Space 中，这个大 Node 的大小，包括了红色已使用的内存和蓝色未使用的内存。如果这个 Node 被用完了，会抛出 **OutOfMemoryError(“Compressed Class Space”)**。</p>
<h3 id="所以这意味着什么？"><a href="#所以这意味着什么？" class="headerlink" title="所以这意味着什么？"></a>所以这意味着什么？</h3><p>当一个 Java 类被加载后，它需要 Non-Class Space 和 Class Space 的空间，而且后者通常都是被限制的(默认 1G)，所以我们总是有那么一个上限存在，即使 -XX:MaxMetaspaceSize 没有配置。</p>
<p>所以，是否会触及到这个上限，取决于 Non-Class Space 和 Class Space 的使用比例。</p>
<p>对于每个类，我们假设这个比例是 1: 5 （class:non-class） 。</p>
<p>这意味着，对于 -XX:CompressedClassSpaceSize 的 1G 的默认值，我们的上限约 6G，1G 的 Class Space 再加约 5G 的 Non-Class Space。</p>
<h3 id="一个类大概需要多大的-Metaspace-空间"><a href="#一个类大概需要多大的-Metaspace-空间" class="headerlink" title="一个类大概需要多大的 Metaspace 空间"></a>一个类大概需要多大的 Metaspace 空间</h3><p>对于一个被加载到虚拟机中的类，Metaspace 需要分配 class 和 non-class 空间，那么这些空间花在哪里了呢？看下图：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-class-metadata.png" alt="How much space does a Java class need?"></p>
<h4 id="深入-Class-Space："><a href="#深入-Class-Space：" class="headerlink" title="深入 Class Space："></a>深入 Class Space：</h4><p>最大的一部分是 Klass 结构，它是固定大小的。</p>
<p>然后紧跟着两个可变大小的 vtable 和 itable，前者由类中方法的数量决定，后者由这个类所实现接口的方法数量决定。</p>
<p>随后是一个 map，记录了类中引用的 Java 对象的地址，尽管该结构一般都很小，不过也是可变的。</p>
<p>vtable 和 itable 通常也很小，但是对于一些巨大的类，它们也可以很大，一个有 30000 个方法的类，vtable 的大小会达到 240k，如果类派生自一个拥有 30000 个方法的接口，也是同理。但是这些都是测试案例，除了自动生成代码，你从来不会看到这样的类。</p>
<h4 id="深入-Non-Class-Space"><a href="#深入-Non-Class-Space" class="headerlink" title="深入 Non-Class Space"></a>深入 Non-Class Space</h4><p>这个区域有很多的东西，下面这些占用了最多的空间：</p>
<ul>
<li><p>常量池，可变大小；</p>
</li>
<li><p>每个成员方法的 metadata：ConstMethod 结构，包含了好几个可变大小的内部结构，如方法字节码、局部变量表、异常表、参数信息、方法签名等；</p>
</li>
<li><p>运行时数据，用来控制 JIT 的行为；</p>
</li>
<li><p>注解</p>
</li>
</ul>
<blockquote>
<p>Metaspace 中的结构都继承自 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/share/memory/allocation.hpp#l239">MetaspaceObj</a>，所以查看它的类继承结构能了解更详细的信息。</p>
</blockquote>
<h4 id="Class-space-和-Non-Class-Space-比例"><a href="#Class-space-和-Non-Class-Space-比例" class="headerlink" title="Class space 和 Non-Class Space 比例"></a>Class space 和 Non-Class Space 比例</h4><p>下面看一下在一些典型的应用中，它们之间的大小比例数据。</p>
<p>下面是 WildFly 应用服务器，16.0.0，运行在 SAPMachine 11 平台上，没有加载任何应用。我们检查下总共需要多少 Metaspace 空间，然后计算平均每个类所需要的空间。我们使用  <code>jcmd VM.metaspace</code> 进行度量。</p>
<table>
<thead>
<tr>
<th>loader</th>
<th>#classes</th>
<th>non-class space <em>(avg per class)</em></th>
<th>class space <em>(/avg per class)</em></th>
<th>ratio non-class/class</th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td>11503</td>
<td>60381k <em>(5.25k)</em></td>
<td>9957k <em>(0.86k)</em></td>
<td>6.0 : 1</td>
</tr>
<tr>
<td>bootstrap</td>
<td>2819</td>
<td>16720k <em>(5.93k)</em></td>
<td>1768k <em>(0.62k)</em></td>
<td>9.5 : 1</td>
</tr>
<tr>
<td>app</td>
<td>185</td>
<td>1320k <em>(7.13k)</em></td>
<td>136k <em>(0.74k)</em></td>
<td>9.7 : 1</td>
</tr>
<tr>
<td>anonymous</td>
<td>869</td>
<td>1013k <em>(1.16k)</em></td>
<td>475k <em>(0.55k)</em></td>
<td>2.1 : 1</td>
</tr>
</tbody></table>
<p>这个表告诉我们：</p>
<ul>
<li>对于正常的类（我们假设通过 bootstrap 和 app 加载的类是正常的），我可以得到平均每个类需要约 5-7k 的 Non-Class Space 和 600-900 bytes 的 Class Space。</li>
<li>匿名类要小得多，但是也有一个有趣的事情，Class 和 Non-Class Space 之间的比例，相对的，我们需要更多的 Class Space。这也不奇怪，因为诸如 Lambda 类都是很小的，但是它的 Klass 结构不可能小于 sizeof(Klass)。所以，我们得到 1k Non-Class Space 和 0.5k Class Space。</li>
</ul>
<p>注意，在我们的案例中，匿名类的数据可能没有代表性，需要收集更多的匿名类，才能得到更准确的数据。</p>
<h3 id="Metaspace-默认大小"><a href="#Metaspace-默认大小" class="headerlink" title="Metaspace 默认大小"></a>Metaspace 默认大小</h3><p>如果我们完全不设置限制 Metaspace 的大小，那么 Metaspace 可以容纳多少类呢？</p>
<p>MaxMetaspaceSize 默认是没有限制的，CompressedClassSpaceSize 默认是 1G，所以我们唯一会触碰到的是 Class Space 空间的上限。</p>
<p>使用上面的数据，每个类约 5-7k 的 Non-Class Space 和 600-900 bytes 的 Class Space，我们可以估算出大约 1-1.5 百万的类（假设没有碎片、没有浪费）以后会触碰到 Class Space 的 OOM。这是一个很大的数值了。</p>
<h3 id="限制-Metaspace-空间大小"><a href="#限制-Metaspace-空间大小" class="headerlink" title="限制 Metaspace 空间大小"></a>限制 Metaspace 空间大小</h3><p><strong>免责声明：不要盲目使用你在网络上找到的规则，尤其是这些数据并非来自生产数据。</strong></p>
<p>其实我们没有什么选择，你确实可以限制 Metaspace 的空间增长，但是如果你的程序需要更多的空间用来存放 class metadata，那么你就会碰到 OOM，除了让你的代码加载更少的类，否则，你几乎是无能为力。</p>
<p>和堆进行比较：你可以增加和减少堆的大小，而不必影响代码功能，所以堆的配置是比较灵活的，而 Metaspace 不具备这个特性。</p>
<p>那么你为什么要限制 Metaspace 的大小呢？</p>
<ul>
<li>告警系统需要知道，为什么 Metaspace 空间以一个异常的速度在消耗，需要有人去看一下发生了什么。</li>
<li>有时候需要限制虚拟内存地址的大小。通常我们感兴趣的是实际消耗内存，但是虚拟内存大小可能会导致虚拟机进程达到系统限制。</li>
</ul>
<blockquote>
<p>注意：JDK 版本依赖：与 JDK 11或更高版本相比，JDK 8 中的元空间受到碎片的影响更大。所以在 JDK 8 环境下分配的时候，需要设置更多的缓冲。</p>
</blockquote>
<p>如果要限制 Metaspace 大小使得系统更容易被监控，同时不用在乎虚拟地址空间的大小，那么最好只设置 MaxMetaspaceSize 而不用设置 CompressedClassSpaceSize。如果要单独设置，那么最好设置 CompressedClassSpaceSize 为 MaxMetaspaceSize 的 80% 左右。</p>
<p>除了 MaxMetaspaceSize 之外，<strong>减小 CompressedClassSpaceSize 的唯一原因是减小虚拟机进程的虚拟内存大小</strong>。 但是，如果将 CompressedClassSpaceSize 设置得太低，则可能在用完 MaxMetaspaceSize 之前先用完了 Compressed Class Space。 在大多数情况下，比率为1：2（CompressedClassSpaceSize = MaxMetaspaceSize / 2）应该是安全的。</p>
<p>那么，你应该将 MaxMetaspaceSize 设置为多大呢？ 首先应该是计算预期的 Metaspace 使用量。你可以使用上面给出的数字，然后给每个类约 1K 的 Class Space 和 3~8K 的 Non-Class Space 作为缓冲。</p>
<p>因此，如果你的应用程序计划加载10000个类，那么从理论上讲，你只需要 10M 的 Class Space 和 80M Non-Class Space。</p>
<p>然后，你需要考虑安全系数。在大多数情况下，因子 2 是比较安全的。你当然也可以碰运气，设置低一点，但是要做好在碰到 OOM 后调大 Metaspace 空间的准备。</p>
<p>如果设置安全因子为 2，那么需要 20M 的 Class Space 和 160M 的 Non-Class Space，也就是总大小为 180M。因此，在这里 <code>-XX:MaxMetaspaceSize=180M</code> 是一个很好的选择。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这是一篇快速写完的文章，不过我仔细检查过了几遍，应该不会有太多的出入。</p>
<p>如果你发现有些地方看得不是很懂，希望你可以先对比一下 <a target="_blank" rel="noopener" href="https://stuefe.de/posts/metaspace/what-is-metaspace/">原文</a>，如果是我的翻译问题，烦请告知。</p>
<p>虽然只是一篇翻译的文章，甚至对于你来说可能还不如看原文来得舒适，不过也同样欢迎大家留言探讨或吐槽。</p>
<p>（全文完）</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%86%85%E5%AD%98qu-yu/" rel="tag"># 内存qu'yu</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/11/03/netty-source-code-1/" rel="prev" title="认真的 Netty 源码解析（一）(转自JavaDoop)">
                  <i class="fa fa-angle-left"></i> 认真的 Netty 源码解析（一）(转自JavaDoop)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/01/09/jvm-string-constant-pool/" rel="next" title="Java 字符串常量池介绍">
                  Java 字符串常量池介绍 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">碎梦</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/scatteredream" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
