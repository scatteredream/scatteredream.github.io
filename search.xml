<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一行一行源码分析清楚AbstractQueuedSynchronizer(转自Javadoop)</title>
    <url>/2017/10/19/AQS%20%E8%8E%B7%E5%8F%96%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h1 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h1><p>在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础。</p>
<p>Google 一下 AbstractQueuedSynchronizer，我们可以找到很多关于 AQS 的介绍，但是很多都没有介绍清楚，因为大部分文章没有把其中的一些关键的细节说清楚。</p>
<p>本文将从 ReentrantLock 的公平锁源码出发，分析下 AbstractQueuedSynchronizer 这个类是怎么工作的，希望能给大家提供一些简单的帮助。</p>
<span id="more"></span>

<p>申明以下几点：</p>
<ol>
<li>本文有点长，但还是挺简单，主要面向读者对象为并发编程的初学者，或者想要阅读 Java 并发包源码的开发者。对于新手来说，可能需要花好几个小时才能完全看懂，但是这时间肯定是值得的。</li>
<li>源码环境 JDK1.7（1.8没啥变化），看到不懂或有疑惑的部分，最好能自己打开源码看看。Doug Lea 大神的代码写得真心不错。</li>
<li>本文不分析共享模式，这样可以给读者减少很多负担，<a href="/post/AbstractQueuedSynchronizer-3">第三篇文章</a>对共享模式进行了分析。而且也不分析 condition 部分，所以应该说很容易就可以看懂了。</li>
<li>本文大量使用我们平时用得最多的 ReentrantLock 的概念，本质上来说是不正确的，读者应该清楚，AQS 不仅仅用来实现可重入锁，只是希望读者可以用锁来联想 AQS 的使用场景，降低阅读压力。</li>
<li>ReentrantLock 的公平锁和非公平锁只有一点点区别，<a href="/post/AbstractQueuedSynchronizer-2">第二篇文章</a>做了介绍。</li>
<li>评论区有读者反馈本文直接用代码说不友好，应该多配点流程图，这篇文章确实有这个问题。但是作为过来人，我想告诉大家，对于 AQS 来说，形式真的不重要，重要的是把细节说清楚。</li>
</ol>
<h2 id="AQS-结构"><a href="#AQS-结构" class="headerlink" title="AQS 结构"></a>AQS 结构</h2><p>先来看看 AQS 有哪些属性，搞清楚这些基本就知道 AQS 是什么套路了，毕竟可以猜嘛！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span></span><br><span class="line"><span class="comment">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span></span><br><span class="line"><span class="comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span></span><br><span class="line"><span class="comment">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread; <span class="comment">//继承自AbstractOwnableSynchronizer</span></span><br></pre></td></tr></table></figure>

<p>怎么样，看样子应该是很简单的吧，毕竟也就四个属性啊。</p>
<p>AbstractQueuedSynchronizer 的等待队列示意如下所示，注意了，之后分析过程中所说的 queue，也就是阻塞队列<strong>不包含 head，不包含 head，不包含 head</strong>。</p>
<p><img src="https://assets.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-0.png" alt="aqs-0"></p>
<p>等待队列中每个线程被包装成一个 Node 实例，数据结构是链表，一起看看源码吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 标识节点当前在共享模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="comment">// 标识节点当前在独占模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ======== 下面的几个int常量是给waitStatus用的 ===========</span></span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">    <span class="comment">// 代码此线程取消了争抢这个锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span></span><br><span class="line">    <span class="comment">// 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">    <span class="comment">// 本文不分析condition，所以略过吧，下一篇文章会介绍这个</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">     * unconditionally propagate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 同样的不分析，略过吧</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">    <span class="comment">// =====================================================</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 取值为上面的1、-1、-2、-3，或者0(以后会讲到)</span></span><br><span class="line">    <span class="comment">// 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，</span></span><br><span class="line">    <span class="comment">//    ps: 半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// 后继节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">// 这个就是线程本尊</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已，大家先要有这个概念在心里。</p>
<p>上面的是基础知识，后面会多次用到，心里要时刻记着它们，心里想着这个结构图就可以了。下面，我们开始说 ReentrantLock 的公平锁。再次强调，我说的阻塞队列不包含 head 节点。</p>
<p><img src="https://assets.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-0.png" alt="aqs-0"></p>
<p>首先，我们先看下 ReentrantLock 的使用方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我用个web开发中的service概念吧</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="comment">// 使用static，这样每个线程拿到的是同一把锁，当然，spring mvc中service默认就是单例，别纠结这个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 比如我们同一时间，只允许一个线程创建订单</span></span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        <span class="comment">// 通常，lock 之后紧跟着 try 语句</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这块代码同一时间只能有一个线程进来(获取到锁的线程)，</span></span><br><span class="line">            <span class="comment">// 其他的线程在lock()方法上阻塞，等待获取到锁，再进来</span></span><br><span class="line">            <span class="comment">// 执行代码...</span></span><br><span class="line">            <span class="comment">// 执行代码...</span></span><br><span class="line">            <span class="comment">// 执行代码...</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 在内部用了内部类 Sync 来管理锁，所以真正的获取锁和释放锁是由 Sync 的实现类来控制的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sync 有两个实现，分别为 NonfairSync（非公平锁）和 FairSync（公平锁），我们看 FairSync 部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程抢锁"><a href="#线程抢锁" class="headerlink" title="线程抢锁"></a>线程抢锁</h2><p>很多人肯定开始嫌弃上面废话太多了，下面跟着代码走，我就不废话了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line">  	<span class="comment">// 争锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 来自父类AQS，我直接贴过来这边，下面分析的时候同样会这样做，不会给读者带来阅读压力</span></span><br><span class="line">    <span class="comment">// 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。</span></span><br><span class="line">    <span class="comment">// 否则，acquireQueued方法会将线程压到队列中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123; <span class="comment">// 此时 arg == 1</span></span><br><span class="line">        <span class="comment">// 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试</span></span><br><span class="line">        <span class="comment">// 因为有可能直接就成功了呢，也就不需要进队列排队了，</span></span><br><span class="line">        <span class="comment">// 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的)</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">              selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span></span><br><span class="line">    <span class="comment">// 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// state == 0 此时此刻没有线程持有锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span></span><br><span class="line">            <span class="comment">// 看看有没有别人在队列中等了半天了</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                <span class="comment">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span></span><br><span class="line">                <span class="comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span></span><br><span class="line">                <span class="comment">// 因为刚刚还没人的，我判断过了</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">              </span><br><span class="line">                <span class="comment">// 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span></span><br><span class="line">        <span class="comment">// 这里不存在并发问题</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span></span><br><span class="line">        <span class="comment">// 回到上面一个外层调用方法继续看:</span></span><br><span class="line">        <span class="comment">// if (!tryAcquire(arg) </span></span><br><span class="line">        <span class="comment">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span></span><br><span class="line">        <span class="comment">//     selfInterrupt();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 假设tryAcquire(arg) 返回false，那么代码将执行：</span></span><br><span class="line">  	<span class="comment">//		acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，</span></span><br><span class="line">    <span class="comment">// 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE)</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 此方法的作用是把线程包装成node，同时进入到队列中</span></span><br><span class="line">    <span class="comment">// 参数mode此时是Node.EXCLUSIVE，代表独占模式</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="comment">// 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 将当前的队尾节点，设置为自己的前驱 </span></span><br><span class="line">            node.prev = pred; </span><br><span class="line">            <span class="comment">// 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; </span><br><span class="line">                <span class="comment">// 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，</span></span><br><span class="line">                <span class="comment">// 上面已经有 node.prev = pred，加上下面这句，也就实现了和之前的尾节点双向连接了</span></span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="comment">// 线程入队了，可以返回了</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 仔细看看上面的代码，如果会到这里，</span></span><br><span class="line">        <span class="comment">// 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)</span></span><br><span class="line">        <span class="comment">// 读者一定要跟上思路，如果没有跟上，建议先不要往下读了，往回仔细看，否则会浪费时间的</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 采用自旋的方式入队</span></span><br><span class="line">    <span class="comment">// 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，</span></span><br><span class="line">    <span class="comment">// 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="comment">// 之前说过，队列为空也会进来这里</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="comment">// 初始化head节点</span></span><br><span class="line">                <span class="comment">// 细心的读者会知道原来 head 和 tail 初始化的时候都是 null 的</span></span><br><span class="line">                <span class="comment">// 还是一步CAS，你懂的，现在可能是很多线程同时进来呢</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                    <span class="comment">// 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了</span></span><br><span class="line">                  </span><br><span class="line">                    <span class="comment">// 这个时候有了head，但是tail还是null，设置一下，</span></span><br><span class="line">                    <span class="comment">// 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了</span></span><br><span class="line">                    <span class="comment">// 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return</span></span><br><span class="line">                    <span class="comment">// 所以，设置完了以后，继续for循环，下次就到下面的else分支了</span></span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下面几行，和上一个方法 addWaiter 是一样的，</span></span><br><span class="line">                <span class="comment">// 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 现在，又回到这段代码了</span></span><br><span class="line">    <span class="comment">// if (!tryAcquire(arg) </span></span><br><span class="line">    <span class="comment">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span></span><br><span class="line">    <span class="comment">//     selfInterrupt();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列</span></span><br><span class="line">    <span class="comment">// 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，</span></span><br><span class="line">    <span class="comment">// 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false</span></span><br><span class="line">    <span class="comment">// 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="comment">// p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head</span></span><br><span class="line">                <span class="comment">// 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列</span></span><br><span class="line">                <span class="comment">// 所以当前节点可以去试抢一下锁</span></span><br><span class="line">                <span class="comment">// 这里我们说一下，为什么可以去试试：</span></span><br><span class="line">                <span class="comment">// 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，</span></span><br><span class="line">                <span class="comment">// enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程</span></span><br><span class="line">                <span class="comment">// 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，</span></span><br><span class="line">                <span class="comment">// tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，</span></span><br><span class="line">                <span class="comment">// 要么就是tryAcquire(arg)没有抢赢别人，继续往下看</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 什么时候 failed 会为 true???</span></span><br><span class="line">            <span class="comment">// tryAcquire() 方法抛异常的情况</span></span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment">     * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment">     * control in all acquire loops.  Requires that pred == node.prev</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pred node&#x27;s predecessor holding status</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是：&quot;当前线程没有抢到锁，是否需要挂起当前线程？&quot;</span></span><br><span class="line">    <span class="comment">// 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">        <span class="comment">// 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。</span></span><br><span class="line">        <span class="comment">// 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span></span><br><span class="line">        <span class="comment">// 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span></span><br><span class="line">        <span class="comment">// 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，</span></span><br><span class="line">        <span class="comment">// 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 仔细想想，如果进入到这个分支意味着什么</span></span><br><span class="line">            <span class="comment">// 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span></span><br><span class="line">            <span class="comment">// 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span></span><br><span class="line">            <span class="comment">// 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0</span></span><br><span class="line">            <span class="comment">// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个方法返回 false，那么会再走一次 for 循序，</span></span><br><span class="line">        <span class="comment">//     然后再次进来此方法，此时会从第一个分支返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)</span></span><br><span class="line">    <span class="comment">// 这个方法结束根据返回值我们简单分析下：</span></span><br><span class="line">    <span class="comment">// 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒</span></span><br><span class="line">    <span class="comment">//		我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了</span></span><br><span class="line">    <span class="comment">// 如果返回false, 说明当前不需要被挂起，为什么呢？往后看</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 跳回到前面是这个方法</span></span><br><span class="line">    <span class="comment">// if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span></span><br><span class="line">    <span class="comment">//                parkAndCheckInterrupt())</span></span><br><span class="line">    <span class="comment">//                interrupted = true;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 如果shouldParkAfterFailedAcquire(p, node)返回true，</span></span><br><span class="line">    <span class="comment">// 那么需要执行parkAndCheckInterrupt():</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的</span></span><br><span class="line">    <span class="comment">// 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 2. 接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：</span></span><br><span class="line">    <span class="comment">// =&gt; 是为了应对在经过这个方法后，node已经是head的直接后继节点了。剩下的读者自己想想吧。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说到这里，也就明白了，多看几遍 <code>final boolean acquireQueued(final Node node, int arg)</code> 这个方法吧。自己推演下各个分支怎么走，哪种情况下会发生什么，走到哪里。</p>
<h2 id="解锁操作"><a href="#解锁操作" class="headerlink" title="解锁操作"></a>解锁操作</h2><p>最后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被 <code>LockSupport.park(this);</code> 挂起停止，等待被唤醒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 往后看吧</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回到ReentrantLock看tryRelease方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="comment">// 是否完全释放锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up node&#x27;s successor, if one exists.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 唤醒后继节点</span></span><br><span class="line"><span class="comment">// 从上面调用处知道，参数node是head头结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果head节点当前waitStatus&lt;0, 将其修改为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）</span></span><br><span class="line">    <span class="comment">// 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 唤醒线程</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唤醒线程以后，被唤醒的线程将从以下代码中继续往前走：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>); <span class="comment">// 刚刚线程被挂起在这里了</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</span></span><br></pre></td></tr></table></figure>

<p>好了，后面就不分析源码了，剩下的还有问题自己去仔细看看代码吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下吧。</p>
<p>在并发环境下，加锁和解锁需要以下三个部件的协调：</p>
<ol>
<li>锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行 +1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock() 和 unlock() 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。</li>
<li>线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park(thread) 来挂起线程，用 unpark 来唤醒线程。</li>
<li>阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS 采用了 CLH 锁的变体来实现，感兴趣的读者可以参考这篇文章<a href="http://coderbee.net/index.php/concurrent/20131115/577">关于CLH的介绍</a>，写得简单明了。</li>
</ol>
<h2 id="示例图解析"><a href="#示例图解析" class="headerlink" title="示例图解析"></a>示例图解析</h2><p>下面属于回顾环节，用简单的示例来说一遍，如果上面的有些东西没看懂，这里还有一次帮助你理解的机会。</p>
<p>首先，第一个线程调用 reentrantLock.lock()，翻到最前面可以发现，tryAcquire(1) 直接就返回 true 了，结束。只是设置了 state=1，连 head 都没有初始化，更谈不上什么阻塞队列了。要是线程 1 调用 unlock() 了，才有线程 2 来，那世界就太太太平了，完全没有交集嘛，那我还要 AQS 干嘛。</p>
<p>如果线程 1 没有调用 unlock() 之前，线程 2 调用了 lock(), 想想会发生什么？</p>
<p>线程 2 会初始化 head【new Node()】，同时线程 2 也会插入到阻塞队列并挂起 (注意看这里是一个 for 循环，而且设置 head 和 tail 的部分是不 return 的，只有入队成功才会跳出循环)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，是线程 2 初始化 head 节点，此时 head==tail, waitStatus==0</p>
<p><img src="https://assets.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-1.png" alt="aqs-1"></p>
<p>然后线程 2 入队：</p>
<p><img src="https://assets.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-2.png" alt="aqs-2"></p>
<p>同时我们也要看此时节点的 waitStatus，我们知道 head 节点是线程 2 初始化的，此时的 waitStatus 没有设置， java 默认会设置为 0，但是到 shouldParkAfterFailedAcquire 这个方法的时候，线程 2 会把前驱节点，也就是 head 的waitStatus设置为 -1。</p>
<p>那线程 2 节点此时的 waitStatus 是多少呢，由于没有设置，所以是 0；</p>
<p>如果线程 3 此时再进来，直接插到线程 2 的后面就可以了，此时线程 3 的 waitStatus 是 0，到 shouldParkAfterFailedAcquire 方法的时候把前驱节点线程 2 的 waitStatus 设置为 -1。</p>
<p><img src="https://assets.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-3.png" alt="aqs-3"></p>
<p>这里可以简单说下 waitStatus 中 SIGNAL(-1) 状态的意思，Doug Lea 注释的是：代表后继节点需要被唤醒。也就是说这个 waitStatus 其实代表的不是自己的状态，而是后继节点的状态，我们知道，每个 node 在入队的时候，都会把前驱节点的状态改为 SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，读者也可以顺着 “waitStatus代表后继节点的状态” 这种思路去看一遍源码。</p>
<p>（全文完）</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>AQS</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>一行一行源码分析清楚 AbstractQueuedSynchronizer (二)(转自Javadoop)</title>
    <url>/2017/10/20/AQS%20Fair%20Condition%20%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<h1 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h1><p>文章比较长，信息量比较大，建议在 pc 上阅读。文章标题是为了呼应前文，其实可以单独成文的，主要是希望读者看文章能系统看。</p>
<p>本文关注以下几点内容：</p>
<ol>
<li>深入理解 ReentrantLock 公平锁和非公平锁的区别</li>
<li>深入分析 AbstractQueuedSynchronizer 中的 ConditionObject</li>
<li>深入理解 Java 线程中断和 InterruptedException 异常</li>
</ol>
<p>基本上本文把以上几点都说清楚了，我假设读者看过<a href="/post/AbstractQueuedSynchronizer">上一篇文章中对 AbstractQueuedSynchronizer 的介绍 </a>，当然如果你已经熟悉 AQS 中的独占锁了，那也可以直接看这篇。各小节之间基本上没什么关系，大家可以只关注自己感兴趣的部分。</p>
<p>其实这篇文章的信息量很大，初学者估计<strong>至少要 1 小时</strong>才能看完，希望本文对得起大家的时间。</p>
<span id="more"></span>

<!-- toc -->

<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>ReentrantLock 默认采用非公平锁，除非你在构造方法中传入参数 true 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公平锁的 lock 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非公平锁的 lock 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里没有对阻塞队列进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：公平锁和非公平锁只有两处不同：</p>
<ol>
<li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>
<li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li>
</ol>
<p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p>
<p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>Tips: 这里重申一下，要看懂这个，必须要先看懂上一篇关于 <a href="/post/AbstractQueuedSynchronizer">AbstractQueuedSynchronizer</a> 的介绍，或者你已经有相关的知识了，否则这节肯定是看不懂的。</p>
<p>我们先来看看 Condition 的使用场景，Condition 经常可以用在<strong>生产者-消费者</strong>的场景中，请看 Doug Lea 给出的这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BoundedBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// condition 依赖于 lock 来产生</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();  <span class="comment">// 队列已满，等待，直到 not full 才能继续生产</span></span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal(); <span class="comment">// 生产成功，队列已经 not empty 了，发个通知出去</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await(); <span class="comment">// 队列为空，等待，直到队列 not empty，才能继续消费</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> items[takeptr];</span><br><span class="line">            <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal(); <span class="comment">// 被我消费掉一个，队列 not full 了，发个通知出去</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1、我们可以看到，在使用 condition 时，必须先持有相应的锁。这个和 Object 类中的方法有相似的语义，需要先持有某个对象的监视器锁才可以执行 wait(), notify() 或 notifyAll() 方法。</p>
<p>2、ArrayBlockingQueue 采用这种方式实现了生产者-消费者，所以请只把这个例子当做学习例子，实际生产中可以直接使用 ArrayBlockingQueue</p>
</blockquote>
<p>我们常用 obj.wait()，obj.notify() 或 obj.notifyAll() 来实现相似的功能，但是，它们是基于对象的监视器锁的。需要深入了解这几个方法的读者，可以参考我的另一篇文章《<a href="/post/Threads-And-Locks-md">深入分析 java 8 编程语言规范：Threads and Locks</a>》。而这里说的 Condition 是基于 ReentrantLock 实现的，而 ReentrantLock 是依赖于 AbstractQueuedSynchronizer 实现的。</p>
<p>在往下看之前，读者心里要有一个整体的概念。condition 是依赖于 ReentrantLock  的，不管是调用 await 进入等待还是 signal 唤醒，<strong>都必须获取到锁才能进行操作</strong>。</p>
<p>每个 ReentrantLock  实例可以通过调用多次 newCondition 产生多个 ConditionObject 的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ConditionObject <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 实例化一个 ConditionObject</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先来看下我们关注的 Condition 的实现类 <code>AbstractQueuedSynchronizer</code> 类中的 <code>ConditionObject</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1173984872572414699L</span>;</span><br><span class="line">        <span class="comment">// 条件队列的第一个节点</span></span><br><span class="line">  		<span class="comment">// 不要管这里的关键字 transient，是不参与序列化的意思</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">// 条件队列的最后一个节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure>

<p>在上一篇介绍 AQS 的时候，我们有一个<strong>阻塞队列</strong>，用于保存等待获取锁的线程的队列。这里我们引入另一个概念，叫<strong>条件队列</strong>（condition queue），我画了一张简单的图用来说明这个。</p>
<blockquote>
<p>这里的阻塞队列如果叫做同步队列（sync queue）其实比较贴切，不过为了和前篇呼应，我就继续使用阻塞队列了。记住这里的两个概念，<strong>阻塞队列</strong>和<strong>条件队列</strong>。</p>
</blockquote>
<p><img src="https://assets.javadoop.com/blogimages/AbstractQueuedSynchronizer-2/aqs2-2.png" alt="condition-2"></p>
<blockquote>
<p>这里，我们简单回顾下 Node 的属性：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> waitStatus; <span class="comment">// 可取值 0、CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)、PROPAGATE(-3)</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;</span><br><span class="line"><span class="keyword">volatile</span> Node next;</span><br><span class="line"><span class="keyword">volatile</span> Thread thread;</span><br><span class="line">Node nextWaiter;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>prev 和 next 用于实现阻塞队列的双向链表，这里的 nextWaiter 用于实现条件队列的单向链表</p>
</blockquote>
<p>基本上，把这张图看懂，你也就知道 condition 的处理流程了。所以，我先简单解释下这图，然后再具体地解释代码实现。</p>
<ol>
<li>条件队列和阻塞队列的节点，都是 Node 的实例，因为条件队列的节点是需要转移到阻塞队列中去的；</li>
<li>我们知道一个 ReentrantLock 实例可以通过多次调用 newCondition() 来产生多个 Condition 实例，这里对应 condition1 和 condition2。注意，ConditionObject 只有两个属性 firstWaiter 和 lastWaiter；</li>
<li>每个 condition 有一个关联的<strong>条件队列</strong>，如线程 1 调用 <code>condition1.await()</code> 方法即可将当前线程 1 包装成 Node 后加入到条件队列中，然后阻塞在这里，不继续往下执行，条件队列是一个单向链表；</li>
<li>调用<code> condition1.signal()</code> 触发一次唤醒，此时唤醒的是队头，会将condition1 对应的<strong>条件队列</strong>的 firstWaiter（队头） 移到<strong>阻塞队列的队尾</strong>，等待获取锁，获取锁后 await 方法才能返回，继续往下执行。</li>
</ol>
<p>上面的 2-&gt;3-&gt;4 描述了一个最简单的流程，没有考虑中断、signalAll、还有带有超时参数的 await 方法等，不过把这里弄懂是这节的主要目的。</p>
<p>同时，从图中也可以很直观地看出，哪些操作是线程安全的，哪些操作是线程不安全的。 </p>
<p>这个图看懂后，下面的代码分析就简单了。</p>
<p>接下来，我们一步步按照流程来走代码分析，我们先来看看 wait 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先，这个方法是可被中断的，不可被中断的是另一个方法 awaitUninterruptibly()</span></span><br><span class="line"><span class="comment">// 这个方法会阻塞，直到调用 signal 方法（指 signal() 和 signalAll()，下同），或被中断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 老规矩，既然该方法要响应中断，那么在最开始就判断中断状态</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加到 condition 的条件队列中</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放锁，返回值是释放锁之前的 state 值</span></span><br><span class="line">    <span class="comment">// await() 之前，当前线程是必须持有锁的，这里肯定要释放掉</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里退出循环有两种情况，之后再仔细分析</span></span><br><span class="line">    <span class="comment">// 1. isOnSyncQueue(node) 返回 true，即当前 node 已经转移到阻塞队列了</span></span><br><span class="line">    <span class="comment">// 2. checkInterruptWhileWaiting(node) != 0 会到 break，然后退出循环，代表的是线程中断</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被唤醒后，将进入阻塞队列，等待获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，我大体上也把整个 await 过程说得十之八九了，下面我们分步把上面的几个点用源码说清楚。</p>
<h3 id="将节点加入到条件队列"><a href="#将节点加入到条件队列" class="headerlink" title="将节点加入到条件队列"></a>将节点加入到条件队列</h3><p>addConditionWaiter() 是将当前节点加入到条件队列，看图我们知道，这种条件队列内的操作是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将当前线程对应的节点入队，插入队尾</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">    <span class="comment">// 如果条件队列的最后一个节点取消了，将其清除出去</span></span><br><span class="line">    <span class="comment">// 为什么这里把 waitStatus 不等于 Node.CONDITION，就判定为该节点发生了取消排队？</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">// 这个方法会遍历整个条件队列，然后会将已取消的所有节点清除出队列</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// node 在初始化的时候，指定 waitStatus 为 Node.CONDITION</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// t 此时是 lastWaiter，队尾</span></span><br><span class="line">    <span class="comment">// 如果队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的这块代码很简单，就是将当前线程进入到条件队列的队尾。</p>
<p>在addWaiter 方法中，有一个 unlinkCancelledWaiters() 方法，该方法用于清除队列中已经取消等待的节点。</p>
<p>当 await 的时候如果发生了取消操作（这点之后会说），或者是在节点入队的时候，发现最后一个节点是被取消的，会调用一次这个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待队列是一个单向链表，遍历链表将已经取消等待的节点清除出去</span></span><br><span class="line"><span class="comment">// 纯属链表操作，很好理解，看不懂多看几遍就可以了</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">trail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> t.nextWaiter;</span><br><span class="line">        <span class="comment">// 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的</span></span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            t.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="literal">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完全释放独占锁"><a href="#完全释放独占锁" class="headerlink" title="完全释放独占锁"></a>完全释放独占锁</h3><p>回到 wait 方法，节点入队了以后，会调用 <code>    int savedState = fullyRelease(node);</code> 方法释放锁，注意，这里是完全释放独占锁（fully release），因为 ReentrantLock 是可以重入的。</p>
<blockquote>
<p>考虑一下这里的 savedState。如果在 condition1.await() 之前，假设线程先执行了 2 次 lock() 操作，那么 state 为 2，我们理解为该线程持有 2 把锁，这里 await() 方法必须将 state 设置为 0，然后再进入挂起状态，这样其他线程才能持有锁。当它被唤醒的时候，它需要重新持有 2 把锁，才能继续下去。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先，我们要先观察到返回值 savedState 代表 release 之前的 state 值</span></span><br><span class="line"><span class="comment">// 对于最简单的操作：先 lock.lock()，然后 condition1.await()。</span></span><br><span class="line"><span class="comment">// 		那么 state 经过这个方法由 1 变为 0，锁释放，此方法返回 1</span></span><br><span class="line"><span class="comment">// 		相应的，如果 lock 重入了 n 次，savedState == n</span></span><br><span class="line"><span class="comment">// 如果这个方法失败，会将节点设置为&quot;取消&quot;状态，并抛出异常 IllegalMonitorStateException</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 这里使用了当前的 state 作为 release 的参数，也就是完全释放掉锁，将 state 置为 0</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>考虑一下，如果一个线程在不持有 lock 的基础上，就去调用 condition1.await() 方法，它能进入条件队列，但是在上面的这个方法中，由于它不持有锁，release(savedState) 这个方法肯定要返回 false，进入到异常分支，然后进入 finally 块设置 <code>node.waitStatus = Node.CANCELLED</code>，这个已经入队的节点之后会被后继的节点”请出去“。</p>
</blockquote>
<h3 id="等待进入阻塞队列"><a href="#等待进入阻塞队列" class="headerlink" title="等待进入阻塞队列"></a>等待进入阻塞队列</h3><p>释放掉锁以后，接下来是这段，这边会自旋，如果发现自己还没到阻塞队列，那么挂起，等待被转移到阻塞队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 如果不在阻塞队列中，注意了，是阻塞队列</span></span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">// 线程挂起</span></span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里可以先不用看了，等看到它什么时候被 unpark 再说</span></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>isOnSyncQueue(Node node) 用于判断节点是否已经转移到阻塞队列了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在节点入条件队列的时候，初始化时设置了 waitStatus = Node.CONDITION</span></span><br><span class="line"><span class="comment">// 前面我提到，signal 的时候需要将节点从条件队列移到阻塞队列，</span></span><br><span class="line"><span class="comment">// 这个方法就是判断 node 是否已经移动到阻塞队列了</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOnSyncQueue</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动过去的时候，node 的 waitStatus 会置为 0，这个之后在说 signal 方法的时候会说到</span></span><br><span class="line">    <span class="comment">// 如果 waitStatus 还是 Node.CONDITION，也就是 -2，那肯定就是还在条件队列中</span></span><br><span class="line">    <span class="comment">// 如果 node 的前驱 prev 指向还是 null，说明肯定没有在 阻塞队列(prev是阻塞队列链表中使用的)</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 如果 node 已经有后继节点 next 的时候，那肯定是在阻塞队列了</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面这个方法从阻塞队列的队尾开始从后往前遍历找，如果找到相等的，说明在阻塞队列，否则就是不在阻塞队列</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 可以通过判断 node.prev() != null 来推断出 node 在阻塞队列吗？答案是：不能。</span></span><br><span class="line">    <span class="comment">// 这个可以看上篇 AQS 的入队方法，首先设置的是 node.prev 指向 tail，</span></span><br><span class="line">    <span class="comment">// 然后是 CAS 操作将自己设置为新的 tail，可是这次的 CAS 是可能失败的。</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从阻塞队列的队尾往前遍历，如果找到，返回 true</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">findNodeFromTail</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到前面的循环，isOnSyncQueue(node) 返回 false 的话，那么进到 <code>LockSupport.park(this); </code> 这里线程挂起。</p>
<h3 id="signal-唤醒线程，转移到阻塞队列"><a href="#signal-唤醒线程，转移到阻塞队列" class="headerlink" title="signal 唤醒线程，转移到阻塞队列"></a>signal 唤醒线程，转移到阻塞队列</h3><p>为了大家理解，这里我们先看唤醒操作，因为刚刚到 <code>LockSupport.park(this);</code> 把线程挂起了，等待唤醒。</p>
<p>唤醒操作通常由另一个线程来操作，就像生产者-消费者模式中，如果线程因为等待消费而挂起，那么当生产者生产了一个东西后，会调用 signal 唤醒正在等待的线程来消费。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唤醒等待了最久的线程</span></span><br><span class="line"><span class="comment">// 其实就是，将这个线程对应的 node 从条件队列转移到阻塞队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 signal 方法的线程必须持有当前的独占锁</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从条件队列队头往后遍历，找出第一个需要转移的 node</span></span><br><span class="line"><span class="comment">// 因为前面我们说过，有些线程会取消排队，但是可能还在队列中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      	<span class="comment">// 将 firstWaiter 指向 first 节点后面的第一个，因为 first 节点马上要离开了</span></span><br><span class="line">        <span class="comment">// 如果将 first 移除后，后面没有节点在等待了，那么需要将 lastWaiter 置为 null</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 因为 first 马上要被移到阻塞队列了，和条件队列的链接关系在这里断掉</span></span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">      <span class="comment">// 这里 while 循环，如果 first 转移不成功，那么选择 first 后面的第一个节点进行转移，依此类推</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点从条件队列转移到阻塞队列</span></span><br><span class="line"><span class="comment">// true 代表成功转移</span></span><br><span class="line"><span class="comment">// false 代表在 signal 之前，节点已经取消了</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CAS 如果失败，说明此 node 的 waitStatus 已不是 Node.CONDITION，说明节点已经取消，</span></span><br><span class="line">    <span class="comment">// 既然已经取消，也就不需要转移了，方法返回，转移后面一个节点</span></span><br><span class="line">    <span class="comment">// 否则，将 waitStatus 置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// enq(node): 自旋进入阻塞队列的队尾</span></span><br><span class="line">    <span class="comment">// 注意，这里的返回值 p 是 node 在阻塞队列的前驱节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">    <span class="comment">// ws &gt; 0 说明 node 在阻塞队列中的前驱节点取消了等待锁，直接唤醒 node 对应的线程。唤醒之后会怎么样，后面再解释</span></span><br><span class="line">    <span class="comment">// 如果 ws &lt;= 0, 那么 compareAndSetWaitStatus 将会被调用，上篇介绍的时候说过，节点入队后，需要把前驱节点的状态设为 Node.SIGNAL(-1)</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        <span class="comment">// 如果前驱节点取消或者 CAS 失败，会进到这里唤醒线程，之后的操作看下一节</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下，<code>ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)</code> 这句中，ws &lt;= 0，而且 <code>compareAndSetWaitStatus(p, ws, Node.SIGNAL)</code> 会返回 true，所以一般也不会进去 if 语句块中唤醒 node 对应的线程。然后这个方法返回 true，也就意味着 signal 方法结束了，节点进入了阻塞队列。</p>
<p>假设发生了阻塞队列中的前驱节点取消等待，或者 CAS 失败，只要唤醒线程，让其进到下一步即可。</p>
<h3 id="唤醒后检查中断状态"><a href="#唤醒后检查中断状态" class="headerlink" title="唤醒后检查中断状态"></a>唤醒后检查中断状态</h3><p>上一步 signal 之后，我们的线程由条件队列转移到了阻塞队列，之后就准备获取锁了。只要重新获取到锁了以后，继续往下执行。</p>
<p>等线程从挂起中恢复过来，继续往下看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">// 线程挂起</span></span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先解释下 interruptMode。interruptMode 可以取值为 REINTERRUPT（1），THROW_IE（-1），0</p>
<ul>
<li>REINTERRUPT： 代表 await 返回的时候，需要重新设置中断状态</li>
<li>THROW_IE： 代表 await 返回的时候，需要抛出 InterruptedException 异常</li>
<li>0 ：说明在 await 期间，没有发生中断</li>
</ul>
<p>有以下三种情况会让 LockSupport.park(this); 这句返回继续往下执行：</p>
<ol>
<li>常规路径。signal -&gt; 转移节点到阻塞队列 -&gt; 获取了锁（unpark）</li>
<li>线程中断。在 park 的时候，另外一个线程对这个线程进行了中断</li>
<li>signal 的时候我们说过，转移以后的前驱节点取消了，或者对前驱节点的CAS操作失败了</li>
<li>假唤醒。这个也是存在的，和 Object.wait() 类似，都有这个问题</li>
</ol>
<p>线程唤醒后第一步是调用 checkInterruptWhileWaiting(node) 这个方法，此方法用于判断是否在线程挂起期间发生了中断，如果发生了中断，是 signal 调用之前中断的，还是 signal 之后发生的中断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 如果在 signal 之前已经中断，返回 THROW_IE</span></span><br><span class="line"><span class="comment">// 2. 如果是 signal 之后中断，返回 REINTERRUPT</span></span><br><span class="line"><span class="comment">// 3. 没有发生中断，返回 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Thread.interrupted()：如果当前线程已经处于中断状态，那么该方法返回 true，同时将中断状态重置为 false，所以，才有后续的 <code>重新中断（REINTERRUPT）</code> 的使用。</p>
</blockquote>
<p>看看怎么判断是 signal 之前还是之后发生的中断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只有线程处于中断状态，才会调用此方法</span></span><br><span class="line"><span class="comment">// 如果需要的话，将这个已经取消等待的节点转移到阻塞队列</span></span><br><span class="line"><span class="comment">// 返回 true：如果此线程在 signal 之前被取消，</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferAfterCancelledWait</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 用 CAS 将节点状态设置为 0 </span></span><br><span class="line">    <span class="comment">// 如果这步 CAS 成功，说明是 signal 方法之前发生的中断，因为如果 signal 先发生的话，signal 中会将 waitStatus 设置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 将节点放入阻塞队列</span></span><br><span class="line">        <span class="comment">// 这里我们看到，即使中断了，依然会转移到阻塞队列</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里是因为 CAS 失败，肯定是因为 signal 方法已经将 waitStatus 设置为了 0</span></span><br><span class="line">    <span class="comment">// signal 方法会将节点转移到阻塞队列，但是可能还没完成，这边自旋等待其完成</span></span><br><span class="line">    <span class="comment">// 当然，这种事情还是比较少的吧：signal 调用之后，没完成转移之前，发生了中断</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.<span class="keyword">yield</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里再说一遍，即使发生了中断，节点依然会转移到阻塞队列。</p>
</blockquote>
<p>到这里，大家应该都知道这个 while 循环怎么退出了吧。要么中断，要么转移成功。</p>
<p>这里描绘了一个场景，本来有个线程，它是排在条件队列的后面的，但是因为它被中断了，那么它会被唤醒，然后它发现自己不是被 signal 的那个，但是它会自己主动去进入到阻塞队列。</p>
<h3 id="获取独占锁"><a href="#获取独占锁" class="headerlink" title="获取独占锁"></a>获取独占锁</h3><p>while 循环出来以后，下面是这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">    interruptMode = REINTERRUPT;</span><br></pre></td></tr></table></figure>

<p>由于 while 出来后，我们确定节点已经进入了阻塞队列，准备获取锁。</p>
<p>这里的 acquireQueued(node, savedState) 的第一个参数 node 之前已经经过 enq(node) 进入了队列，参数 savedState 是之前释放锁前的 state，这个方法返回的时候，代表当前线程获取了锁，而且 state == savedState了。</p>
<p>注意，前面我们说过，不管有没有发生中断，都会进入到阻塞队列，而 acquireQueued(node, savedState) 的返回值就是代表线程是否被中断。如果返回 true，说明被中断了，而且 interruptMode != THROW_IE，说明在 signal 之前就发生中断了，这里将 interruptMode 设置为 REINTERRUPT，用于待会重新中断。</p>
<p>继续往下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">    unlinkCancelledWaiters();</span><br><span class="line"><span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">    reportInterruptAfterWait(interruptMode);</span><br></pre></td></tr></table></figure>

<p>本着一丝不苟的精神，这边说说 <code>node.nextWaiter != null</code> 怎么满足。我前面也说了 signal 的时候会将节点转移到阻塞队列，有一步是 node.nextWaiter = null，将断开节点和条件队列的联系。</p>
<p>可是，<code>在判断发生中断的情况下，是 signal 之前还是之后发生的？</code> 这部分的时候，我也介绍了，如果 signal 之前就中断了，也需要将节点进行转移到阻塞队列，这部分转移的时候，是没有设置 node.nextWaiter = null 的。</p>
<p>之前我们说过，如果有节点取消，也会调用 unlinkCancelledWaiters 这个方法，就是这里了。</p>
<h3 id="处理中断状态"><a href="#处理中断状态" class="headerlink" title="处理中断状态"></a>处理中断状态</h3><p>到这里，我们终于可以好好说下这个 interruptMode 干嘛用了。</p>
<ul>
<li>0：什么都不做，没有被中断过；</li>
<li>THROW_IE：await 方法抛出 InterruptedException 异常，因为它代表在 await() 期间发生了中断；</li>
<li>REINTERRUPT：重新中断当前线程，因为它代表 await() 期间没有被中断，而是 signal() 以后发生的中断</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reportInterruptAfterWait</span><span class="params">(<span class="type">int</span> interruptMode)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个中断状态这部分内容，大家应该都理解了吧，不理解的话，多看几遍就是了。</p>
</blockquote>
<h3 id="带超时机制的-await"><a href="#带超时机制的-await" class="headerlink" title="* 带超时机制的 await"></a>* 带超时机制的 await</h3><p>经过前面的 7 步，整个 ConditionObject 类基本上都分析完了，接下来简单分析下带超时机制的 await 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> </span><br><span class="line">  				<span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span></span><br><span class="line">                <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span></span><br><span class="line">                <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure>

<p>这三个方法都差不多，我们就挑一个出来看看吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 等待这么多纳秒</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">nanosTimeout</span> <span class="operator">=</span> unit.toNanos(time);</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="comment">// 当前时间 + 等待时长 = 过期时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">// 用于返回 await 是否超时</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 时间到啦</span></span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里因为要 break 取消等待了。取消等待的话一定要调用 transferAfterCancelledWait(node) 这个方法</span></span><br><span class="line">            <span class="comment">// 如果这个方法返回 true，在这个方法内，将节点转移到阻塞队列成功</span></span><br><span class="line">            <span class="comment">// 返回 false 的话，说明 signal 已经发生，signal 方法将节点转移了。也就是说没有超时嘛</span></span><br><span class="line">            timedout = transferAfterCancelledWait(node);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// spinForTimeoutThreshold 的值是 1000 纳秒，也就是 1 毫秒</span></span><br><span class="line">        <span class="comment">// 也就是说，如果不到 1 毫秒了，那就不要选择 parkNanos 了，自旋的性能反而更好</span></span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 得到剩余时间</span></span><br><span class="line">        nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">    <span class="keyword">return</span> !timedout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>超时的思路还是很简单的，不带超时参数的 await 是 park，然后等待别人唤醒。而现在就是调用 parkNanos 方法来休眠指定的时间，醒来后判断是否 signal 调用了，调用了就是没有超时，否则就是超时了。超时的话，自己来进行转移到阻塞队列，然后抢锁。</p>
<h3 id="不抛出-InterruptedException-的-await"><a href="#不抛出-InterruptedException-的-await" class="headerlink" title="* 不抛出 InterruptedException 的 await"></a>* 不抛出 InterruptedException 的 await</h3><p>关于 Condition 最后一小节了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            interrupted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，贴一下代码大家就都懂了，我就不废话了。</p>
<h2 id="AbstractQueuedSynchronizer-独占锁的取消排队"><a href="#AbstractQueuedSynchronizer-独占锁的取消排队" class="headerlink" title="AbstractQueuedSynchronizer 独占锁的取消排队"></a>AbstractQueuedSynchronizer 独占锁的取消排队</h2><p>这篇文章说的是 AbstractQueuedSynchronizer，只不过好像 Condition 说太多了，赶紧把思路拉回来。</p>
<p>接下来，我想说说怎么取消对锁的竞争？</p>
<p>上篇文章提到过，最重要的方法是这个，我们要在这里面找答案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，到这个方法的时候，节点一定是入队成功的。</p>
<p>我把 parkAndCheckInterrupt() 代码贴过来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两段代码联系起来看，是不是就清楚了。</p>
<p>如果我们要取消一个线程的排队，我们需要在另外一个线程中对其进行中断。比如某线程调用 lock() 老久不返回，我想中断它。一旦对其进行中断，此线程会从 <code>LockSupport.park(this);</code> 中唤醒，然后 <code>Thread.interrupted();</code> 返回 true。</p>
<p>我们发现一个问题，即使是中断唤醒了这个线程，也就只是设置了 <code>interrupted = true</code> 然后继续下一次循环。而且，由于 <code>Thread.interrupted();</code>  会清除中断状态，第二次进 parkAndCheckInterrupt 的时候，返回会是 false。</p>
<p>所以，我们要看到，在这个方法中，interrupted 只是用来记录是否发生了中断，然后用于方法返回值，其他没有做任何相关事情。</p>
<p>所以，我们看外层方法怎么处理 acquireQueued 返回 false 的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说，lock() 方法处理中断的方法就是，你中断归中断，我抢锁还是照样抢锁，几乎没关系，只是我抢到锁了以后，设置线程的中断状态而已，也不抛出任何异常出来。调用者获取锁后，可以去检查是否发生过中断，也可以不理会。</p>
<hr>
<p>来条分割线。有没有被骗的感觉，我说了一大堆，可是和取消没有任何关系啊。</p>
<p>我们来看 ReentrantLock 的另一个 lock 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法上多了个 <code>throws InterruptedException</code> ，经过前面那么多知识的铺垫，这里我就不再啰里啰嗦了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续往里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 就是这里了，一旦异常，马上结束这个方法，抛出异常。</span></span><br><span class="line">                <span class="comment">// 这里不再只是标记这个方法的返回值代表中断状态</span></span><br><span class="line">                <span class="comment">// 而是直接抛出异常，而且外层也不捕获，一直往外抛到 lockInterruptibly</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果通过 InterruptedException 异常出去，那么 failed 就是 true 了</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然到这里了，顺便说说 cancelAcquire 这个方法吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn&#x27;t exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    node.thread = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">    <span class="comment">// 找一个合适的前驱。其实就是将它前面的队列中已经取消的节点都”请出去“</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">    <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">predNext</span> <span class="operator">=</span> pred.next;</span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred&#x27;s next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="type">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这个方法没什么好说的，一行行看下去就是了，节点取消，只要把 waitStatus 设置为 Node.CANCELLED，会有非常多的情况被从阻塞队列中请出去，主动或被动。</p>
<h2 id="再说-java-线程中断和-InterruptedException-异常"><a href="#再说-java-线程中断和-InterruptedException-异常" class="headerlink" title="再说 java 线程中断和 InterruptedException 异常"></a>再说 java 线程中断和 InterruptedException 异常</h2><p>在之前的文章中，我们接触了大量的中断，这边算是个总结吧。如果你完全熟悉中断了，没有必要再看这节，本节为新手而写。</p>
<h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>首先，我们要明白，中断不是类似 linux 里面的命令 kill -9 pid，不是说我们中断某个线程，这个线程就停止运行了。中断代表线程状态，每个线程都关联了一个中断状态，是一个 true 或 false 的 boolean 值，初始值为 false。</p>
<blockquote>
<p>Java 中的中断和操作系统的中断还不一样，这里就按照<strong>状态</strong>来理解吧，不要和操作系统的中断联系在一起</p>
</blockquote>
<p>关于中断状态，我们需要重点关注 Thread 类中的以下几个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Thread 类中的实例方法，持有线程实例引用即可检测线程中断状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 中的静态方法，检测调用这个方法的线程是否已经中断</span></span><br><span class="line"><span class="comment">// 注意：这个方法返回中断状态的同时，会将此线程的中断状态重置为 false</span></span><br><span class="line"><span class="comment">// 所以，如果我们连续调用两次这个方法的话，第二次的返回值肯定就是 false 了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 类中的实例方法，用于设置一个线程的中断状态为 true</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们说中断一个线程，其实就是设置了线程的 interrupted status 为 true，至于说被中断的线程怎么处理这个状态，那是那个线程自己的事。如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">   doWork();</span><br><span class="line">   System.out.println(<span class="string">&quot;我做完一件事了，准备做下一件，如果没有其他线程中断我的话&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种代码就是会响应中断的，它会在干活的时候先判断下中断状态，不过，除了 JDK 源码外，其他用中断的场景还是比较少的，毕竟 JDK 源码非常讲究。</p>
</blockquote>
<p>当然，中断除了是线程状态外，还有其他含义，否则也不需要专门搞一个这个概念出来了。</p>
<p>如果线程处于以下三种情况，那么当线程被中断的时候，能自动感知到：</p>
<ol>
<li><p>来自 Object 类的 wait()、wait(long)、wait(long, int)，</p>
<p>来自 Thread 类的 join()、join(long)、join(long, int)、sleep(long)、sleep(long, int)</p>
<blockquote>
<p>这几个方法的相同之处是，方法上都有: throws InterruptedException </p>
<p>如果线程阻塞在这些方法上（我们知道，这些方法会让当前线程阻塞），这个时候如果其他线程对这个线程进行了中断，那么这个线程会从这些方法中立即返回，抛出 InterruptedException 异常，同时重置中断状态为 false。</p>
</blockquote>
</li>
<li><p>实现了 InterruptibleChannel 接口的类中的一些 I/O 阻塞操作，如 DatagramChannel 中的 connect 方法和 receive 方法等</p>
<blockquote>
<p>如果线程阻塞在这里，中断线程会导致这些方法抛出 ClosedByInterruptException 并重置中断状态。</p>
</blockquote>
</li>
<li><p>Selector 中的 select 方法，参考下我写的 NIO 的文章</p>
<blockquote>
<p>一旦中断，方法立即返回</p>
</blockquote>
</li>
</ol>
<p>对于以上 3 种情况是最特殊的，因为他们能自动感知到中断（这里说自动，当然也是基于底层实现），<strong>并且在做出相应的操作后都会重置中断状态为 false</strong>。</p>
<p>那是不是只有以上 3 种方法能自动感知到中断呢？不是的，如果线程阻塞在 LockSupport.park(Object obj) 方法，也叫挂起，这个时候的中断也会导致线程唤醒，但是唤醒后不会重置中断状态，所以唤醒后去检测中断状态将是 true。</p>
<h3 id="InterruptedException-概述"><a href="#InterruptedException-概述" class="headerlink" title="InterruptedException 概述"></a>InterruptedException 概述</h3><p>它是一个特殊的异常，不是说 JVM 对其有特殊的处理，而是它的使用场景比较特殊。通常，我们可以看到，像 Object 中的 wait() 方法，ReentrantLock 中的 lockInterruptibly() 方法，Thread 中的 sleep() 方法等等，这些方法都带有 <code>throws InterruptedException</code>，我们通常称这些方法为阻塞方法（blocking method）。</p>
<p>阻塞方法一个很明显的特征是，它们需要花费比较长的时间（不是绝对的，只是说明时间不可控），还有它们的方法结束返回往往依赖于外部条件，如 wait 方法依赖于其他线程的 notify，lock 方法依赖于其他线程的 unlock等等。</p>
<p>当我们看到方法上带有 <code>throws InterruptedException</code> 时，我们就要知道，这个方法应该是阻塞方法，我们如果希望它能早点返回的话，我们往往可以通过中断来实现。 </p>
<p>除了几个特殊类（如 Object，Thread等）外，感知中断并提前返回是通过轮询中断状态来实现的。我们自己需要写可中断的方法的时候，就是通过在合适的时机（通常在循环的开始处）去判断线程的中断状态，然后做相应的操作（通常是方法直接返回或者抛出异常）。当然，我们也要看到，如果我们一次循环花的时间比较长的话，那么就需要比较长的时间才能<strong>感知</strong>到线程中断了。</p>
<h3 id="处理中断"><a href="#处理中断" class="headerlink" title="处理中断"></a>处理中断</h3><p>一旦中断发生，我们接收到了这个信息，然后怎么去处理中断呢？本小节将简单分析这个问题。</p>
<p>我们经常会这么写代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// ignore</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// go on </span></span><br></pre></td></tr></table></figure>

<p>当 sleep 结束继续往下执行的时候，我们往往都不知道这块代码是真的 sleep 了 10 秒，还是只休眠了 1 秒就被中断了。这个代码的问题在于，我们将这个异常信息吞掉了。（对于 sleep 方法，我相信大部分情况下，我们都不在意是否是中断了，这里是举例）</p>
<p>AQS 的做法很值得我们借鉴，我们知道 ReentrantLock 有两种 lock 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们提到过，lock() 方法不响应中断。如果 thread1 调用了 lock() 方法，过了很久还没抢到锁，这个时候 thread2 对其进行了中断，thread1 是不响应这个请求的，它会继续抢锁，当然它不会把“被中断”这个信息扔掉。我们可以看以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">// 我们看到，这里也没做任何特殊处理，就是记录下来中断状态。</span></span><br><span class="line">        <span class="comment">// 这样，如果外层方法需要去检测的时候，至少我们没有把这个信息丢了</span></span><br><span class="line">        selfInterrupt();<span class="comment">// Thread.currentThread().interrupt();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于 lockInterruptibly() 方法，因为其方法上面有 <code>throws InterruptedException</code> ，这个信号告诉我们，如果我们要取消线程抢锁，直接中断这个线程即可，它会立即返回，抛出 InterruptedException 异常。</p>
<p>在并发包中，有非常多的这种处理中断的例子，提供两个方法，分别为响应中断和不响应中断，对于不响应中断的方法，记录中断而不是丢失这个信息。如 Condition 中的两个方法就是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通常，如果方法会抛出 InterruptedException 异常，往往方法体的第一句就是：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line"> 	...... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>熟练使用中断，对于我们写出优雅的代码是有帮助的，也有助于我们分析别人的源码。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章的信息量真的很大，如果你花了时间，还是没有看懂，那是我的错了。</p>
<p>欢迎大家向我提问，我不一定能每次都及时出现，我出现也不一定能解决大家的问题，欢迎探讨。</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>AQS</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析(转自Javadoop)</title>
    <url>/2018/02/24/(Concurrent)HashMap/</url>
    <content><![CDATA[<p>今天发一篇”水文”，可能很多读者都会表示不理解，不过我想把它作为并发序列文章中不可缺少的一块来介绍。本来以为花不了多少时间的，不过最终还是投入了挺多时间来完成这篇文章的。</p>
<p>网上关于 HashMap 和 ConcurrentHashMap 的文章确实不少，不过缺斤少两的文章比较多，所以才想自己也写一篇，把细节说清楚说透，尤其像 Java8 中的 ConcurrentHashMap，大部分文章都说不清楚。终归是希望能降低大家学习的成本，不希望大家到处找各种不是很靠谱的文章，看完一篇又一篇，可是还是模模糊糊。</p>
<p>阅读建议：四节基本上可以进行独立阅读，建议初学者可按照 Java7 HashMap -&gt; Java7 ConcurrentHashMap -&gt; Java8 HashMap -&gt; Java8 ConcurrentHashMap 顺序进行阅读，可适当降低阅读门槛。</p>
<p>阅读前提：本文分析的是源码，所以至少读者要熟悉它们的接口使用，同时，对于并发，读者至少要知道 CAS、ReentrantLock、UNSAFE 操作这几个基本的知识，文中不会对这些知识进行介绍。Java8 用到了红黑树，不过本文不会进行展开，感兴趣的读者请自行查找相关资料。</p>
<!-- toc -->

<h2 id="Java7-HashMap"><a href="#Java7-HashMap" class="headerlink" title="Java7 HashMap"></a>Java7 HashMap</h2><p>HashMap 是最简单的，一来我们非常熟悉，二来就是它不支持并发操作，所以源码也非常简单。</p>
<p>首先，我们用下面这张图来介绍 HashMap 的结构。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/map/1.png" alt="1"></p>
<blockquote>
<p>这个仅仅是示意图，因为没有考虑到数组要扩容的情况，具体的后面再说。</p>
</blockquote>
<p>大方向上，HashMap 里面是一个<strong>数组</strong>，然后数组中每个元素是一个<strong>单向链表</strong>。</p>
<p>上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。</p>
<p>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</p>
<p>loadFactor：负载因子，默认为 0.75。</p>
<p>threshold：扩容的阈值，等于 capacity * loadFactor</p>
<h3 id="put-过程分析"><a href="#put-过程分析" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><p>还是比较简单的，跟着代码走一遍吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// 当插入第一个元素的时候，需要先初始化数组大小</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 key 为 null，感兴趣的可以往里看，最终会将这个 entry 放到 table[0] 中</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">// 1. 求 key 的 hash 值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">// 2. 找到对应的数组下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 3. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在，</span></span><br><span class="line">    <span class="comment">//    如果有，直接覆盖，put 方法返回旧值就结束了</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 4. 不存在重复的 key，将此 entry 添加到链表中，细节后面说</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h4><p>在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inflateTable</span><span class="params">(<span class="type">int</span> toSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 保证数组大小一定是 2 的 n 次方。</span></span><br><span class="line">    <span class="comment">// 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> roundUpToPowerOf2(toSize);</span><br><span class="line">    <span class="comment">// 计算扩容阈值：capacity * loadFactor</span></span><br><span class="line">    threshold = (<span class="type">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 算是初始化数组吧</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity); <span class="comment">//ignore</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个将数组大小保持为 2 的 n 次方的做法，Java7 和 Java8 的 HashMap 和 ConcurrentHashMap 都有相应的要求，只不过实现的代码稍微有些不同，后面再看到的时候就知道了。</p>
<h4 id="计算具体数组位置"><a href="#计算具体数组位置" class="headerlink" title="计算具体数组位置"></a>计算具体数组位置</h4><p>这个简单，我们自己也能 YY 一个：使用 key 的 hash 值对数组长度进行取模就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> hash, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> hash &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。</p>
<h4 id="添加节点到链表中"><a href="#添加节点到链表中" class="headerlink" title="添加节点到链表中"></a>添加节点到链表中</h4><p>找到数组下标后，会先进行 key 判重，如果没有重复，就准备将新值放入到链表的<strong>表头</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">// 扩容，后面会介绍一下</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        <span class="comment">// 扩容以后，重新计算 hash 值</span></span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 重新计算扩容后的新的下标</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往下看</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个很简单，其实就是将新值放到链表的表头，然后 size++</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。</p>
<h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>前面我们看到，在插入新值的时候，如果<strong>当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素</strong>，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">    <span class="comment">// 将原来数组中的值迁移到新的更大的数组中</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</p>
<p>由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。代码比较简单，这里就不展开了。</p>
<h3 id="get-过程分析"><a href="#get-过程分析" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>相对于 put 过程，get 过程是非常简单的。</p>
<ol>
<li>根据 key 计算 hash 值。</li>
<li>找到相应的数组下标：hash &amp; (length - 1)。</li>
<li>遍历该数组位置处的链表，直到找到相等(==或equals)的 key。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// 之前说过，key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span> == entry ? <span class="literal">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getEntry(key):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="comment">// 确定数组下标，然后从头开始遍历链表，直到找到为止</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java7-ConcurrentHashMap"><a href="#Java7-ConcurrentHashMap" class="headerlink" title="Java7 ConcurrentHashMap"></a>Java7 ConcurrentHashMap</h2><p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。</p>
<p>整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为<strong>分段锁</strong>。注意，行文中，我很多地方用了“<strong>槽</strong>”来代表一个 segment。</p>
<p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/map/3.png" alt="3"></p>
<p><strong>concurrencyLevel</strong>：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</p>
<p>再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>initialCapacity：初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。</p>
<p>loadFactor：负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                         <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sshift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ssize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4</span></span><br><span class="line">    <span class="comment">// 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值</span></span><br><span class="line">    <span class="built_in">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="built_in">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// initialCapacity 是设置整个 map 初始的大小，</span></span><br><span class="line">    <span class="comment">// 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小</span></span><br><span class="line">    <span class="comment">// 如 initialCapacity 为 64，那么每个 Segment 或称之为&quot;槽&quot;可以分到 4 个</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="comment">// 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，</span></span><br><span class="line">    <span class="comment">// 插入一个元素不至于扩容，插入第二个的时候才会扩容</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> MIN_SEGMENT_TABLE_CAPACITY; </span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Segment 数组，</span></span><br><span class="line">    <span class="comment">// 并创建数组的第一个元素 segment[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Segment</span>&lt;K,V&gt;(loadFactor, (<span class="type">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">HashEntry</span>[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Segment</span>[ssize];</span><br><span class="line">    <span class="comment">// 往数组写入 segment[0]</span></span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="built_in">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化完成，我们得到了一个 Segment 数组。</p>
<p>我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后：</p>
<ul>
<li>Segment 数组长度为 16，不可以扩容</li>
<li>Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容</li>
<li>这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍</li>
<li>当前 segmentShift 的值为 32 - 4 = 28，segmentMask 为 16 - 1 = 15，姑且把它们简单翻译为<strong>移位数</strong>和<strong>掩码</strong>，这两个值马上就会用到</li>
</ul>
<h3 id="put-过程分析-1"><a href="#put-过程分析-1" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><p>我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 1. 计算 key 的 hash 值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">// 2. 根据 hash 值找到 Segment 数组中的位置 j</span></span><br><span class="line">    <span class="comment">//    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下高 4 位，</span></span><br><span class="line">    <span class="comment">//    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的高 4 位，也就是槽的数组下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="comment">// 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，</span></span><br><span class="line">    <span class="comment">// ensureSegment(j) 对 segment[j] 进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="comment">// 3. 插入新值到 槽 s 中</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。</p>
<p>Segment 内部是由 <strong>数组+链表</strong> 组成的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// 在往该 segment 写入前，需要先获取该 segment 的独占锁</span></span><br><span class="line">    <span class="comment">//    先看主流程，后面还会具体介绍这部分内容</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这个是 segment 内部的数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 再利用 hash 值，求应该放置的数组下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// first 是数组该位置处的链表的表头</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        <span class="comment">// 覆盖旧值</span></span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 继续顺着链表走</span></span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。</span></span><br><span class="line">                <span class="comment">// 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                </span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果超过了该 segment 的阈值，这个 segment 需要扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node); <span class="comment">// 扩容后面也会具体分析</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 没有达到阈值，将 node 放到数组 tab 的 index 位置，</span></span><br><span class="line">                    <span class="comment">// 其实就是将新的节点设置成原链表的表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。</p>
<p>到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。</p>
<h4 id="初始化槽-ensureSegment"><a href="#初始化槽-ensureSegment" class="headerlink" title="初始化槽: ensureSegment"></a>初始化槽: ensureSegment</h4><p>ConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。</p>
<p>这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title function_">ensureSegment</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="built_in">this</span>.segments;</span><br><span class="line">    <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里看到为什么之前要初始化 segment[0] 了，</span></span><br><span class="line">        <span class="comment">// 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]</span></span><br><span class="line">        <span class="comment">// 为什么要用“当前”，因为 segment[0] 可能早就扩容过了</span></span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> proto.table.length;</span><br><span class="line">        <span class="type">float</span> <span class="variable">lf</span> <span class="operator">=</span> proto.loadFactor;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> (<span class="type">int</span>)(cap * lf);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化 segment[k] 内部的数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">HashEntry</span>[cap];</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">            == <span class="literal">null</span>) &#123; <span class="comment">// 再次检查一遍该槽是否被其他线程初始化了。</span></span><br><span class="line">          </span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> <span class="title class_">Segment</span>&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">// 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="literal">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。</p>
<blockquote>
<p>我没搞懂这里为什么要搞一个 while 循环，CAS 失败不就代表有其他线程成功了吗，为什么要再进行判断？</p>
<p>感谢评论区的<strong>李子木</strong>，如果当前线程 CAS 失败，这里的 while 循环是为了将 seg 赋值返回。</p>
</blockquote>
<h4 id="获取写入锁-scanAndLockForPut"><a href="#获取写入锁-scanAndLockForPut" class="headerlink" title="获取写入锁: scanAndLockForPut"></a>获取写入锁: scanAndLockForPut</h4><p>前面我们看到，在往某个 segment 中 put 的时候，首先会调用  node = tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。</p>
<p>下面我们来具体分析这个方法中是怎么控制加锁的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title function_">scanAndLockForPut</span><span class="params">(K key, <span class="type">int</span> hash, V value)</span> &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="built_in">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">retries</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环获取锁</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    <span class="comment">// 进到这里说明数组该位置的链表是空的，没有任何元素</span></span><br><span class="line">                    <span class="comment">// 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置</span></span><br><span class="line">                    node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 顺着链表往下走</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重试次数如果超过 MAX_SCAN_RETRIES（单核1多核64），那么不抢了，进入到阻塞队列等待锁</span></span><br><span class="line">        <span class="comment">//    lock() 是阻塞方法，直到获取锁后返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 <span class="comment">// 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头</span></span><br><span class="line">                 <span class="comment">//     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法</span></span><br><span class="line">                 (f = entryForHash(<span class="built_in">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。</p>
<p>这个方法就是看似复杂，但是其实就是做了一件事，那就是<strong>获取该 segment 的独占锁</strong>，如果需要的话顺便实例化了一下 node。</p>
<h4 id="扩容-rehash"><a href="#扩容-rehash" class="headerlink" title="扩容: rehash"></a>扩容: rehash</h4><p>重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry&lt;K,V&gt;[] 进行扩容，扩容后，容量为原来的 2 倍。</p>
<p>首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。</p>
<p>该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="comment">// 2 倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> <span class="title class_">HashEntry</span>[newCapacity];</span><br><span class="line">    <span class="comment">// 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sizeMask</span> <span class="operator">=</span> newCapacity - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// e 是链表的第一个元素</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算应该放置在新数组中的位置，</span></span><br><span class="line">            <span class="comment">// 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>)   <span class="comment">// 该位置处只有一个元素，那比较好办</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                <span class="comment">// e 是链表表头</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="comment">// idx 是当前链表的头结点 e 的新位置</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">lastIdx</span> <span class="operator">=</span> idx;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="literal">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// 下面的操作是处理 lastRun 之前的节点，</span></span><br><span class="line">                <span class="comment">//    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> p.value;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> p.hash;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nodeIndex</span> <span class="operator">=</span> node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢？</p>
<p>仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。</p>
<p>我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。<strong>不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1/6 的节点需要克隆</strong>。</p>
<h3 id="get-过程分析-1"><a href="#get-过程分析-1" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>相对于 put 来说，get 真的不要太简单。</p>
<ol>
<li>计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”</li>
<li>槽中也是一个数组，根据 hash 找到数组中具体的位置</li>
<li>到这里是链表了，顺着链表进行查找即可</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// 1. hash 值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// 2. 根据 hash 找到对应的 segment</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. 找到segment 内部数组相应位置的链表，遍历</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="type">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并发问题分析"><a href="#并发问题分析" class="headerlink" title="并发问题分析"></a>并发问题分析</h3><p>现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。</p>
<p>添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。</p>
<ol>
<li><p>put 操作的线程安全性。</p>
<ol>
<li>初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。</li>
<li>添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。</li>
<li>扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。</li>
</ol>
</li>
<li><p>remove 操作的线程安全性。</p>
<p>remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。</p>
<p>get 操作需要遍历链表，但是 remove 操作会”破坏”链表。</p>
<p>如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。</p>
<p>如果 remove 先破坏了一个节点，分两种情况考虑。  1、如果此节点是头结点，那么需要将头结点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。2、如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。</p>
</li>
</ol>
<h2 id="Java8-HashMap"><a href="#Java8-HashMap" class="headerlink" title="Java8 HashMap"></a>Java8 HashMap</h2><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 <strong>数组+链表+红黑树</strong> 组成。</p>
<p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 **O(n)**。</p>
<p>为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 **O(logN)**。</p>
<p>来一张图简单示意一下吧：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/map/2.png" alt="2"></p>
<blockquote>
<p>注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。</p>
</blockquote>
<p>下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。</p>
<p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 <strong>Node</strong>，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 <strong>TreeNode</strong>。</p>
<p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。</p>
<h3 id="put-过程分析-2"><a href="#put-过程分析-2" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span></span><br><span class="line"><span class="comment">// 第五个参数 evict 我们这里不关心</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度</span></span><br><span class="line">    <span class="comment">// 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 数组该位置有数据</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 到这里，说明数组该位置上是一个链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 插入到链表的最后面(Java7 是插入到链表的最前面)</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个</span></span><br><span class="line">                    <span class="comment">// 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果在该链表中找到了&quot;相等&quot;的 key(== 或 equals)</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e!=null 说明存在旧值的key与要插入的key&quot;相等&quot;</span></span><br><span class="line">        <span class="comment">// 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。</p>
<h4 id="数组扩容-1"><a href="#数组扩容-1" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>resize() 方法用于<strong>初始化数组</strong>或<strong>数组扩容</strong>，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 对应数组扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将数组大小扩大一倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 将阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 对应使用 new HashMap() 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用新的数组大小初始化新的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab; <span class="comment">// 如果是初始化数组，到这里就结束了，返回 newTab 即可</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始遍历原数组，进行数据迁移。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果是红黑树，具体我们就不展开了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">// 这块是处理链表的情况，</span></span><br><span class="line">                    <span class="comment">// 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span></span><br><span class="line">                    <span class="comment">// loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 第一条链表</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 第二条链表的新的位置是 j + oldCap，这个很好理解</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get-过程分析-2"><a href="#get-过程分析-2" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>相对于 put 来说，get 真的太简单了。</p>
<ol>
<li>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</li>
<li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</li>
<li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</li>
<li>遍历链表，直到找到相等(==或equals)的 key</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个节点是不是就是需要的</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 链表遍历</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java8-ConcurrentHashMap"><a href="#Java8-ConcurrentHashMap" class="headerlink" title="Java8 ConcurrentHashMap"></a>Java8 ConcurrentHashMap</h2><p>Java7 中实现的 ConcurrentHashMap 说实话还是比较复杂的，Java8 对 ConcurrentHashMap 进行了比较大的改动。建议读者可以参考 Java8 中 HashMap 相对于 Java7 HashMap 的改动，对于 ConcurrentHashMap，Java8 也引入了红黑树。</p>
<p><strong>说实话，Java8 ConcurrentHashMap 源码真心不简单，最难的在于扩容，数据迁移操作不容易看懂。</strong></p>
<p>我们先用一个示意图来描述下其结构：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/map/4.png" alt="4"></p>
<p>结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。</p>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这构造函数里，什么都不干</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl = 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。</p>
<p>sizeCtl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。</p>
<p>如果你爱折腾，也可以看下另一个有三个参数的构造方法，这里我就不说了，大部分时候，我们会使用无参构造函数进行实例化，我们也按照这个思路来进行源码分析吧。</p>
<h3 id="put-过程分析-3"><a href="#put-过程分析-3" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><p>仔细地一行一行代码看下去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 得到 hash 值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 用于记录相应链表的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 如果数组&quot;空&quot;，进行数组初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 初始化数组，后面会详细介绍</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找该 hash 值对应的数组下标，得到第一个节点 f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果数组该位置为空，</span></span><br><span class="line">            <span class="comment">//    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了</span></span><br><span class="line">            <span class="comment">// 		 如果 CAS 失败，那就是有并发操作，进到下一个循环就好了</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 到这里就是说，f 是该位置的头结点，而且不为空</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 获取数组该位置的头结点的监视器锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 头结点的 hash 值大于 0，说明是链表</span></span><br><span class="line">                        <span class="comment">// 用于累加，记录链表的长度</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 到了链表的最末端，将这个新值放到链表的最后面</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 红黑树</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 调用红黑树的插值方法插入新节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，</span></span><br><span class="line">                    <span class="comment">// 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span></span><br><span class="line">                    <span class="comment">//    具体源码我们就不看了，扩容部分后面说</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put 的主流程看完了，但是至少留下了几个问题，第一个是初始化，第二个是扩容，第三个是帮助数据迁移，这些我们都会在后面进行一一介绍。</p>
<h4 id="初始化数组：initTable"><a href="#初始化数组：initTable" class="headerlink" title="初始化数组：initTable"></a>初始化数组：initTable</h4><p>这个比较简单，主要就是初始化一个<strong>合适大小</strong>的数组，然后会设置 sizeCtl。</p>
<p>初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化的&quot;功劳&quot;被其他线程&quot;抢去&quot;了</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// DEFAULT_CAPACITY 默认初始容量是 16</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">					<span class="comment">// 初始化数组，长度为 16 或初始化时提供的长度</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">// 将这个数组赋值给 table，table 是 volatile 的</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 如果 n 为 16 的话，那么这里 sc = 12</span></span><br><span class="line">                    <span class="comment">// 其实就是 0.75 * n</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 设置 sizeCtl 为 sc，我们就当是 12 吧</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链表转红黑树-treeifyBin"><a href="#链表转红黑树-treeifyBin" class="headerlink" title="链表转红黑树: treeifyBin"></a>链表转红黑树: treeifyBin</h4><p>前面我们在 put 源码分析也说过，treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="type">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// MIN_TREEIFY_CAPACITY 为 64</span></span><br><span class="line">        <span class="comment">// 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            <span class="comment">// 后面我们再详细分析这个方法</span></span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// b 是头结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="literal">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    <span class="comment">// 下面就是遍历链表，建立一颗红黑树</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="literal">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将红黑树设置到数组相应位置中</span></span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容：tryPresize"><a href="#扩容：tryPresize" class="headerlink" title="扩容：tryPresize"></a>扩容：tryPresize</h3><p>如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。</p>
<p>这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。</p>
<p>这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryPresize</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="comment">// c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="type">int</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">// 0.75 * n</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="comment">// 我没看懂 rs 的真正含义是什么，不过也关系不大</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法</span></span><br><span class="line">                <span class="comment">//    此时 nextTab 不为 null</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span></span><br><span class="line">            <span class="comment">//     我是没看懂这个值真正的意义是什么？不过可以计算出来的是，结果是一个比较大的负数</span></span><br><span class="line">            <span class="comment">//  调用 transfer 方法，此时 nextTab 参数为 null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。</p>
<p>所以，可能的操作就是执行 **1 次 transfer(tab, null) + 多次 transfer(tab, nt)**，这里怎么结束循环的需要看完 transfer 源码才清楚。</p>
<h4 id="数据迁移：transfer"><a href="#数据迁移：transfer" class="headerlink" title="数据迁移：transfer"></a>数据迁移：transfer</h4><p>下面这个方法有点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。</p>
<p>虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。</p>
<p>此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。</p>
<p>阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 stride，简单理解就是<strong>步长</strong>，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。</p>
<p>第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后<strong>从后往前</strong>的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// stride 在单核下直接等于 n，多核模式下为 (n&gt;&gt;&gt;3)/NCPU，最小值是 16</span></span><br><span class="line">    <span class="comment">// stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，</span></span><br><span class="line">    <span class="comment">//   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 nextTab 为 null，先进行一次初始化</span></span><br><span class="line">    <span class="comment">//    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null</span></span><br><span class="line">    <span class="comment">// 	  之后参与迁移的线程调用此方法时，nextTab 不会为 null</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 容量翻倍</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nextTable 是 ConcurrentHashMap 中的属性</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">// transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ForwardingNode 翻译过来就是正在被迁移的 Node</span></span><br><span class="line">    <span class="comment">// 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED</span></span><br><span class="line">    <span class="comment">// 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，</span></span><br><span class="line">    <span class="comment">//    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了</span></span><br><span class="line">    <span class="comment">//    所以它其实相当于是一个标志。</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// i 是位置索引，bound 是边界，注意是从后往前</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下面这个 while 真的是不好理解</span></span><br><span class="line">        <span class="comment">// advance 为 true 表示可以进行下一个位置的迁移了</span></span><br><span class="line">        <span class="comment">//   简单理解结局：i 指向了 transferIndex，bound 指向了 transferIndex-stride</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将 transferIndex 值赋给 nextIndex</span></span><br><span class="line">            <span class="comment">// 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">// 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前</span></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="type">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                <span class="comment">// 所有的迁移操作已经完成</span></span><br><span class="line">                nextTable = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 将新的 nextTab 赋值给 table 属性，完成迁移</span></span><br><span class="line">                table = nextTab;</span><br><span class="line">                <span class="comment">// 重新计算 sizeCtl：n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 之前我们说过，sizeCtl 在迁移前会设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</span></span><br><span class="line">            <span class="comment">// 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，</span></span><br><span class="line">            <span class="comment">// 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 任务结束，方法退出</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 到这里，说明 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，</span></span><br><span class="line">                <span class="comment">// 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing)&#123;&#125; 分支了</span></span><br><span class="line">                finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">        <span class="comment">// 该位置处是一个 ForwardingNode，代表该位置已经迁移过了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">// 头结点的 hash 大于 0，说明是链表的 Node 节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，</span></span><br><span class="line">                        <span class="comment">// 需要将链表一分为二，</span></span><br><span class="line">                        <span class="comment">//   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的</span></span><br><span class="line">                        <span class="comment">//   lastRun 之前的节点需要进行克隆，然后分到两个链表中</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 其中的一个链表放在新数组的位置 i</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 另一个链表放在新数组的位置 i+n</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span></span><br><span class="line">                        <span class="comment">//    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// advance 设置为 true，代表该位置已经迁移完毕</span></span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 红黑树的迁移</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果一分为二后，节点数少于 8，那么将红黑树转换回链表</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 将 ln 放置在新数组的位置 i</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 将 hn 放置在新数组的位置 i+n</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span></span><br><span class="line">                        <span class="comment">//    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// advance 设置为 true，代表该位置已经迁移完毕</span></span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。</p>
<p>这个时候，再回去仔细看 tryPresize 方法可能就会更加清晰一些了。</p>
<h3 id="get-过程分析-3"><a href="#get-过程分析-3" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>get 方法从来都是最简单的，这里也不例外：</p>
<ol>
<li>计算 hash 值</li>
<li>根据 hash 值找到数组对应位置: (n - 1) &amp; h</li>
<li>根据该位置处结点性质进行相应查找<ul>
<li>如果该位置为 null，那么直接返回 null 就可以了</li>
<li>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</li>
<li>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法</li>
<li>如果以上 3 条都不满足，那就是链表，进行遍历比对即可</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断头结点是否就是我们需要的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，ForwardingNode.find(int h, Object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了，所以限于篇幅这里也不展开说了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实也不是很难嘛，虽然没有像之前的 AQS 和线程池一样一行一行源码进行分析，但还是把所有初学者可能会糊涂的地方都进行了深入的介绍，只要是稍微有点基础的读者，应该是很容易就能看懂 HashMap 和 ConcurrentHashMap 源码了。</p>
<p>看源码不算是目的吧，深入地了解 Doug Lea 的设计思路，我觉得还挺有趣的，大师就是大师，代码写得真的是好啊。</p>
<p>我发现很多人都以为我写博客主要是源码分析，说真的，我对于源码分析没有那么大热情，主要都是为了用源码说事罢了，可能之后的文章还是会有比较多的源码分析成分。</p>
<p>不要脸地自以为本文的质量还是挺高的，信息量比较大，如果你觉得有写得不好的地方，或者说看完本文你还是没看懂它们，那么请提出来~~~</p>
<p>（全文完）</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>一行一行源码分析清楚 AbstractQueuedSynchronizer (三)(转自Javadoop)</title>
    <url>/2017/10/21/AQS-Tools/</url>
    <content><![CDATA[<h1 id="AQS-Tools"><a href="#AQS-Tools" class="headerlink" title="AQS-Tools"></a>AQS-Tools</h1><p>这篇文章是 AQS 系列的最后一篇，第一篇，我们通过 ReentrantLock 公平锁分析了 AQS 的核心，第二篇的重点是把 Condition 说明白，同时也说清楚了对于线程中断的使用。</p>
<p>这篇，我们的关注点是 AQS 最后的部分，<strong>AQS 共享模式</strong>的使用。有前两篇文章的铺垫，剩下的源码分析将会简单很多。</p>
<p>本文先用 CountDownLatch 将共享模式说清楚，然后顺着把其他 AQS 相关的类 CyclicBarrier、Semaphore 的源码一起过一下。</p>
<p>相对来说，如果读者有前面两篇文章的基础，这篇文章是简单很多，不过对于初学者来说，1 小时估计也是免不了的。</p>
<span id="more"></span>

<!-- toc -->

<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch 这个类是比较典型的 AQS 的共享模式的使用，这是一个高频使用的类。latch 的中文意思是<strong>门栓、栅栏</strong>，具体怎么解释我就不废话了，大家随意，看两个例子就知道在哪里用、怎么用了。</p>
<h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><p>我们看下 Doug Lea 在 java doc 中给出的例子，这个例子非常实用，我经常会写到这个代码。</p>
<p>假设我们有 N ( N &gt; 0 ) 个任务，那么我们会用 N 来初始化一个 CountDownLatch，然后将这个 latch 的引用传递到各个线程中，在每个线程完成了任务后，调用 latch.countDown() 代表完成了一个任务。</p>
<p>调用 latch.await() 的方法的线程会阻塞，直到所有的任务完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Driver2</span> &#123; <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">doneSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(N);</span><br><span class="line">        <span class="type">Executor</span> <span class="variable">e</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 N 个任务，提交给线程池来执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">            e.execute(<span class="keyword">new</span> <span class="title class_">WorkerRunnable</span>(doneSignal, i));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有的任务完成，这个方法才会返回</span></span><br><span class="line">        doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkerRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    WorkerRunnable(CountDownLatch doneSignal, <span class="type">int</span> i) &#123;</span><br><span class="line">        <span class="built_in">this</span>.doneSignal = doneSignal;</span><br><span class="line">        <span class="built_in">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doWork(i);</span><br><span class="line">            <span class="comment">// 这个线程的任务完成了，调用 countDown 方法</span></span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">        &#125; <span class="comment">// return;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123; ...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说 CountDownLatch 非常实用，我们常常会将一个比较大的任务进行拆分，然后开启多个线程来执行，等所有线程都执行完了以后，再往下执行其他操作。这里例子中，<strong>只有 main 线程调用了 await 方法</strong>。</p>
<p>我们再来看另一个例子，这个例子很典型，用了两个 CountDownLatch：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Driver</span> &#123; <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">startSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">doneSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(N);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Worker</span>(startSignal, doneSignal)).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这边插入一些代码，确保上面的每个线程先启动起来，才执行下面的代码。</span></span><br><span class="line">        doSomethingElse();            <span class="comment">// don&#x27;t let run yet</span></span><br><span class="line">        <span class="comment">// 因为这里 N == 1，所以，只要调用一次，那么所有的 await 方法都可以通过</span></span><br><span class="line">        startSignal.countDown();      <span class="comment">// let all threads proceed</span></span><br><span class="line">        doSomethingElse();</span><br><span class="line">        <span class="comment">// 等待所有任务结束</span></span><br><span class="line">        doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line"></span><br><span class="line">    Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">        <span class="built_in">this</span>.startSignal = startSignal;</span><br><span class="line">        <span class="built_in">this</span>.doneSignal = doneSignal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 为了让所有线程同时开始任务，我们让所有线程先阻塞在这里</span></span><br><span class="line">            <span class="comment">// 等大家都准备好了，再打开这个门栓</span></span><br><span class="line">            startSignal.await();</span><br><span class="line">            doWork();</span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">        &#125; <span class="comment">// return;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123; ...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，doneSignal 同第一个例子的使用，我们说说这里的 startSignal。N 个新开启的线程都调用了startSignal.await() 进行阻塞等待，它们阻塞在<strong>栅栏</strong>上，只有当条件满足的时候（startSignal.countDown()），它们才能同时通过这个栅栏，目的是让所有的线程站在一个起跑线上。</p>
<p><img src="https://assets.javadoop.com/blogimages/AbstractQueuedSynchronizer-3/5.png" alt="5"></p>
<p>如果始终只有一个线程调用 await 方法等待任务完成，那么 CountDownLatch 就会简单很多，所以之后的源码分析读者一定要在脑海中构建出这么一个场景：有 m 个线程是做任务的，有 n 个线程在某个栅栏上等待这 m 个线程做完任务，直到所有 m 个任务完成后，n 个线程同时通过栅栏。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>Talk is cheap, show me the code.</p>
<p>构造方法，需要传入一个不小于 0 的整数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 老套路了，内部封装一个 Sync 类继承自 AQS</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    Sync(<span class="type">int</span> count) &#123;</span><br><span class="line">        <span class="comment">// 这样就 state == count 了</span></span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码都是套路，先分析套路：AQS 里面的 state 是一个整数值，这边用一个 int count 参数其实初始化就是设置了这个值，所有调用了 await 方法的等待线程会挂起，然后有其他一些线程会做 state = state - 1 操作，当 state 减到 0 的同时，那个将 state 减为 0 的线程会负责唤醒 所有调用了 await 方法的线程。都是套路啊，只是 Doug Lea 的套路很深，代码很巧妙，不然我们也没有要分析源码的必要。</p>
</blockquote>
<p>对于 CountDownLatch，我们仅仅需要关心两个方法，一个是 countDown() 方法，另一个是 await() 方法。</p>
<p>countDown() 方法每次调用都会将 state 减 1，直到 state 的值为 0；而 await 是一个阻塞方法，当 state 减为 0 的时候，await 方法才会返回。await 可以被多个线程调用，读者这个时候脑子里要有个图：所有调用了 await 方法的线程阻塞在 AQS 的阻塞队列中，等待条件满足（state == 0），将线程从队列中一个个唤醒过来。</p>
<p>我们用以下程序来分析源码，t1 和 t2 负责调用 countDown() 方法，t3 和 t4 调用 await 方法阻塞：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 休息 5 秒后(模拟线程工作了 5 秒)，调用 countDown()</span></span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 休息 10 秒后(模拟线程工作了 10 秒)，调用 countDown()</span></span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 阻塞，等待 state 减为 0</span></span><br><span class="line">                    latch.await();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 t3 从 await 中返回了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 t3 await 被中断&quot;</span>);</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 阻塞，等待 state 减为 0</span></span><br><span class="line">                    latch.await();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 t4 从 await 中返回了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 t4 await 被中断&quot;</span>);</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t4&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序，大概在过了 10 秒左右的时候，会输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">线程 t3 从 await 中返回了</span><br><span class="line">线程 t4 从 await 中返回了</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这两条输出，顺序不是绝对的</p>
<p>后面的分析，我们假设 t3 先进入阻塞队列</p>
</blockquote>
<p>接下来，我们按照流程一步一步走：先 await 等待，然后被唤醒，await 方法返回。</p>
<p>首先，我们来看 await() 方法，它代表线程阻塞，等待 state 的值减为 0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 这也是老套路了，我在第二篇的中断那一节说过了</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// t3 和 t4 调用 await 的时候，state 都大于 0（state 此时为 2）。</span></span><br><span class="line">    <span class="comment">// 也就是说，这个 if 返回 true，然后往里看</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只有当 state == 0 的时候，这个方法才会返回 1</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从方法名我们就可以看出，这个方法是获取共享锁，并且此方法是可中断的（中断的时候抛出 InterruptedException 退出这个方法）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 1. 入队</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 同上，只要 state 不等于 0，那么这个方法返回 -1</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来仔细分析这个方法，线程 t3 经过第 1 步 addWaiter 入队以后，我们应该可以得到这个：</p>
<p><img src="https://assets.javadoop.com/blogimages/AbstractQueuedSynchronizer-3/2.png" alt="2"></p>
<p>由于 tryAcquireShared 这个方法会返回 -1，所以 if (r &gt;= 0) 这个分支不会进去。到 shouldParkAfterFailedAcquire 的时候，t3 将 head 的 waitStatus 值设置为 -1，如下：</p>
<p><img src="https://assets.javadoop.com/blogimages/AbstractQueuedSynchronizer-3/3.png" alt="3"></p>
<p>然后进入到 parkAndCheckInterrupt 的时候，t3 挂起。</p>
<p>我们再分析 t4 入队，t4 会将前驱节点 t3 所在节点的 waitStatus 设置为 -1，t4 入队后，应该是这样的：</p>
<p><img src="https://assets.javadoop.com/blogimages/AbstractQueuedSynchronizer-3/4.png" alt="4"></p>
<p>然后，t4 也挂起。接下来，t3 和 t4 就等待唤醒了。</p>
<p>接下来，我们来看唤醒的流程。为了让下面的示意图更丰富些，我们假设用 10 初始化 CountDownLatch。</p>
<p><img src="https://assets.javadoop.com/blogimages/AbstractQueuedSynchronizer-3/1.png" alt="1"></p>
<p>当然，我们的例子中，其实没有 10 个线程，只有 2 个线程 t1 和 t2，只是为了让图好看些罢了。</p>
<p>我们再一步步看具体的流程。首先，我们看 countDown() 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 只有当 state 减为 0 的时候，tryReleaseShared 才返回 true</span></span><br><span class="line">    <span class="comment">// 否则只是简单的 state = state - 1 那么 countDown() 方法就结束了</span></span><br><span class="line">    <span class="comment">//    将 state 减到 0 的那个操作才是最复杂的，继续往下吧</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 唤醒 await 的线程</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个方法很简单，用自旋的方法实现 state 减 1</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>countDown 方法就是每次调用都将 state 值减 1，如果 state 减到 0 了，那么就调用下面的方法进行唤醒阻塞队列中的线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用这个方法的时候，state == 0</span></span><br><span class="line"><span class="comment">// 这个方法先不要看所有的代码，按照思路往下到我写注释的地方，我们先跑通一个流程，其他的之后还会仔细分析</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="comment">// t3 入队的时候，已经将头节点的 waitStatus 设置为 Node.SIGNAL（-1） 了</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 将 head 的 waitStatue 设置为 0</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点</span></span><br><span class="line">                <span class="comment">// 在这里，也就是唤醒 t3</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) <span class="comment">// todo</span></span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦 t3 被唤醒后，我们继续回到 await 的这段代码，parkAndCheckInterrupt 返回，我们先不考虑中断的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r); <span class="comment">// 2. 这里是下一步</span></span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">// 1. 唤醒后这个方法返回</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，t3 会进到 setHeadAndPropagate(node, r) 这个方法，先把 head 给占了，然后唤醒队列中其他的线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 下面说的是，唤醒当前 node 之后的节点，即 t3 已经醒了，马上唤醒 t4</span></span><br><span class="line">    <span class="comment">// 类似的，如果 t4 后面还有 t5，那么 t4 醒了以后，马上将 t5 给唤醒了</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            <span class="comment">// 又是这个方法，只是现在的 head 已经不是原来的空节点了，是 t3 的节点了</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又回到这个方法了，那么接下来，我们好好分析 doReleaseShared 这个方法，我们根据流程，头节点 head 此时是 t3 节点了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用这个方法的时候，state == 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 1. h == null: 说明阻塞队列为空</span></span><br><span class="line">        <span class="comment">// 2. h == tail: 说明头结点可能是刚刚初始化的头节点，</span></span><br><span class="line">        <span class="comment">//   或者是普通线程节点，但是此节点既然是头节点了，那么代表已经被唤醒了，阻塞队列没有其他节点了</span></span><br><span class="line">        <span class="comment">// 所以这两种情况不需要进行唤醒后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="comment">// t4 将头节点(此时是 t3)的 waitStatus 设置为 Node.SIGNAL（-1） 了</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 这里 CAS 失败的场景请看下面的解读</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点</span></span><br><span class="line">                <span class="comment">// 在这里，也就是唤醒 t4</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     <span class="comment">// 这个 CAS 失败的场景是：执行到这里的时候，刚好有一个节点入队，入队会将这个 ws 设置为 -1</span></span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果到这里的时候，前面唤醒的线程已经占领了 head，那么再循环</span></span><br><span class="line">        <span class="comment">// 否则，就是 head 没变，那么退出循环，</span></span><br><span class="line">        <span class="comment">// 退出循环是不是意味着阻塞队列中的其他节点就不唤醒了？当然不是，唤醒的线程之后还是会调用这个方法的</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们分析下最后一个 if 语句，然后才能解释第一个 CAS 为什么可能会失败：</p>
<ol>
<li>h == head：说明头节点还没有被刚刚用 unparkSuccessor 唤醒的线程（这里可以理解为 t4）占有，此时 break 退出循环。</li>
<li>h != head：头节点被刚刚唤醒的线程（这里可以理解为 t4）占有，那么这里重新进入下一轮循环，唤醒下一个节点（这里是 t4 ）。我们知道，等到 t4 被唤醒后，其实是会主动唤醒 t5、t6、t7…，那为什么这里要进行下一个循环来唤醒 t5 呢？我觉得是出于吞吐量的考虑。</li>
</ol>
<p>满足上面的 2 的场景，那么我们就能知道为什么上面的 CAS 操作 compareAndSetWaitStatus(h, Node.SIGNAL, 0) 会失败了？</p>
<p>因为当前进行 for 循环的线程到这里的时候，可能刚刚唤醒的线程 t4 也刚刚好到这里了，那么就有可能 CAS 失败了。</p>
<p>for 循环第一轮的时候会唤醒 t4，t4 醒后会将自己设置为头节点，如果在 t4 设置头节点后，for 循环才跑到 if (h == head)，那么此时会返回 false，for 循环会进入下一轮。t4 唤醒后也会进入到这个方法里面，那么 for 循环第二轮和 t4 就有可能在这个 CAS 相遇，那么就只会有一个成功了。</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>字面意思是“可重复使用的栅栏”或“周期性的栅栏”，总之不是用了一次就没用了的，CyclicBarrier 相比 CountDownLatch 来说，要简单很多，其源码没有什么高深的地方，它是 ReentrantLock 和 Condition 的组合使用。看如下示意图，CyclicBarrier 和 CountDownLatch 是不是很像，只是 CyclicBarrier 可以有不止一个栅栏，因为它的栅栏（Barrier）可以重复使用（Cyclic）。</p>
<p><img src="https://assets.javadoop.com/blogimages/AbstractQueuedSynchronizer-3/cyclicbarrier-2.png" alt="cyclicbarrier-2"></p>
<p>首先，CyclicBarrier 的源码实现和 CountDownLatch 大相径庭，CountDownLatch 基于 AQS 的共享模式的使用，而 CyclicBarrier 基于 Condition 来实现。</p>
<p>因为 CyclicBarrier 的源码相对来说简单许多，读者只要熟悉了前面关于 Condition 的分析，那么这里的源码是毫无压力的，就是几个特殊概念罢了。</p>
<p>先用一张图来描绘下 CyclicBarrier 里面的一些概念，和它的基本使用流程：</p>
<p><img src="https://assets.javadoop.com/blogimages/AbstractQueuedSynchronizer-3/cyclicbarrier-3.png" alt="cyclicbarrier-3"></p>
<blockquote>
<p>看图我们也知道了，CyclicBarrier 的源码最重要的就是 await() 方法了。</p>
</blockquote>
<p>大家先把图看完，然后我们开始源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrier</span> &#123;</span><br><span class="line">    <span class="comment">// 我们说了，CyclicBarrier 是可以重复使用的，我们把每次从开始使用到穿过栅栏当做&quot;一代&quot;，或者&quot;一个周期&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Generation</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">broken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CyclicBarrier 是基于 Condition 的</span></span><br><span class="line">    <span class="comment">// Condition 是“条件”的意思，CyclicBarrier 的等待线程通过 barrier 的“条件”是大家都到了栅栏上</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">trip</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参与的线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> parties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了这个，代表越过栅栏之前，要执行相应的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前所处的“代”</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Generation</span> <span class="variable">generation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还没有到栅栏的线程数，这个值初始为 parties，然后递减</span></span><br><span class="line">    <span class="comment">// 还没有到栅栏的线程数 = parties - 已经到栅栏的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="built_in">this</span>.parties = parties;</span><br><span class="line">        <span class="built_in">this</span>.count = parties;</span><br><span class="line">        <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(parties, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先，先看怎么开启新的一代：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启新的一代，当最后一个线程到达栅栏上的时候，调用这个方法来唤醒其他线程，同时初始化“下一代”</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">nextGeneration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 首先，需要唤醒所有的在栅栏上等待的线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// 更新 count 的值</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 重新生成“新一代”</span></span><br><span class="line">    generation = <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>开启新的一代，类似于重新实例化一个 CyclicBarrier 实例</p>
</blockquote>
<p>看看怎么打破一个栅栏：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">breakBarrier</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置状态 broken 为 true</span></span><br><span class="line">    generation.broken = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 重置 count 为初始值 parties</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 唤醒所有已经在等待的线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个方法之后用得到，现在开始分析最重要的等待通过栅栏方法 await 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不带超时机制</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 带超时机制，如果超时抛出 TimeoutException 异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException,</span><br><span class="line">           BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="literal">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续往里看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="line">               TimeoutException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 先要获取到锁，然后在 finally 中要记得释放锁</span></span><br><span class="line">    <span class="comment">// 如果记得 Condition 部分的话，我们知道 condition 的 await() 会释放锁，被 signal() 唤醒的时候需要重新获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line">        <span class="comment">// 检查栅栏是否被打破，如果被打破，抛出 BrokenBarrierException 异常</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line">        <span class="comment">// 检查中断状态，如果中断了，抛出 InterruptedException 异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// index 是这个 await 方法的返回值</span></span><br><span class="line">        <span class="comment">// 注意到这里，这个是从 count 递减后得到的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果等于 0，说明所有的线程都到栅栏上了，准备通过</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果在初始化的时候，指定了通过栅栏前需要执行的操作，在这里会得到执行</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                <span class="comment">// 如果 ranAction 为 true，说明执行 command.run() 的时候，没有发生异常退出的情况</span></span><br><span class="line">                ranAction = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒等待的线程，然后开启新的一代</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    <span class="comment">// 进到这里，说明执行指定操作的时候，发生了异常，那么需要打破栅栏</span></span><br><span class="line">                    <span class="comment">// 之前我们说了，打破栅栏意味着唤醒所有等待的线程，设置 broken 为 true，重置 count 为 parties</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="comment">// 如果是最后一个线程调用 await，那么上面就返回了</span></span><br><span class="line">        <span class="comment">// 下面的操作是给那些不是最后一个到达栅栏的线程执行的</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果带有超时机制，调用带超时的 Condition 的 await 方法等待，直到最后一个线程调用 await</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">// 如果到这里，说明等待的线程在 await（是 Condition 的 await）的时候被中断</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    <span class="comment">// 打破栅栏</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="comment">// 打破栅栏后，重新抛出这个 InterruptedException 异常给外层调用的方法</span></span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 到这里，说明 g != generation, 说明新的一代已经产生，即最后一个线程 await 执行完成，</span></span><br><span class="line">                    <span class="comment">// 那么此时没有必要再抛出 InterruptedException 异常，记录下来这个中断信息即可</span></span><br><span class="line">                    <span class="comment">// 或者是栅栏已经被打破了，那么也不应该抛出 InterruptedException 异常，</span></span><br><span class="line">                    <span class="comment">// 而是之后抛出 BrokenBarrierException 异常</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          	<span class="comment">// 唤醒后，检查栅栏是否是“破的”</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这个 for 循环除了异常，就是要从这里退出了</span></span><br><span class="line">            <span class="comment">// 我们要清楚，最后一个线程在执行完指定任务(如果有的话)，会调用 nextGeneration 来开启一个新的代</span></span><br><span class="line">            <span class="comment">// 然后释放掉锁，其他线程从 Condition 的 await 方法中得到锁并返回，然后到这里的时候，其实就会满足 g != generation 的</span></span><br><span class="line">            <span class="comment">// 那什么时候不满足呢？barrierCommand 执行过程中抛出了异常，那么会执行打破栅栏操作，</span></span><br><span class="line">            <span class="comment">// 设置 broken 为true，然后唤醒这些线程。这些线程会从上面的 if (g.broken) 这个分支抛 BrokenBarrierException 异常返回</span></span><br><span class="line">            <span class="comment">// 当然，还有最后一种可能，那就是 await 超时，此种情况不会从上面的 if 分支异常返回，也不会从这里返回，会执行后面的代码</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果醒来发现超时了，打破栅栏，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，我想我应该讲清楚了吧，我好像几乎没有漏掉任何一行代码吧？</p>
<p>下面开始收尾工作。</p>
<p>首先，我们看看怎么得到有多少个线程到了栅栏上，处于等待状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumberWaiting</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parties - count;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断一个栅栏是否被打破了，这个很简单，直接看 broken 的值即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBroken</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> generation.broken;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们在说 await 的时候也几乎说清楚了，什么时候栅栏会被打破，总结如下：</p>
<ol>
<li>中断，我们说了，如果某个等待的线程发生了中断，那么会打破栅栏，同时抛出 InterruptedException 异常；</li>
<li>超时，打破栅栏，同时抛出 TimeoutException 异常；</li>
<li>指定执行的操作抛出了异常，这个我们前面也说过。</li>
</ol>
<p>最后，我们来看看怎么重置一个栅栏：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们设想一下，如果初始化时，指定了线程 parties = 4，前面有 3 个线程调用了 await 等待，在第 4 个线程调用 await 之前，我们调用 reset 方法，那么会发生什么？</p>
<p>首先，打破栅栏，那意味着所有等待的线程（3个等待的线程）会唤醒，await 方法会通过抛出 BrokenBarrierException 异常返回。然后开启新的一代，重置了 count 和 generation，相当于一切归零了。</p>
<p>怎么样，CyclicBarrier 源码很简单吧。</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>有了 CountDownLatch 的基础后，分析 Semaphore 会简单很多。Semaphore 是什么呢？它类似一个资源池（读者可以类比线程池），每个线程需要调用 acquire() 方法获取资源，然后才能执行，执行完后，需要 release 资源，让给其他的线程用。</p>
<p>大概大家也可以猜到，Semaphore 其实也是 AQS 中共享锁的使用，因为每个线程共享一个池嘛。</p>
<p>套路解读：创建 Semaphore 实例的时候，需要一个参数 permits，这个基本上可以确定是设置给 AQS 的 state 的，然后每个线程调用 acquire 的时候，执行 state = state - 1，release 的时候执行 state = state + 1，当然，acquire  的时候，如果 state = 0，说明没有资源了，需要等待其他线程 release。</p>
<p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(<span class="keyword">permits</span>) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里和 ReentrantLock 类似，用了公平策略和非公平策略。</p>
<p>看 acquire 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquireUninterruptibly</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">permits</span> &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquireUninterruptibly</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">permits</span> &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    sync.acquireShared(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这几个方法也是老套路了，大家基本都懂了吧，这边多了两个可以传参的 acquire 方法，不过大家也都懂的吧，如果我们需要一次获取超过一个的资源，会用得着这个的。</p>
<p>我们接下来看不抛出 InterruptedException 异常的 acquireUninterruptibly() 方法吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquireUninterruptibly</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面说了，Semaphore 分公平策略和非公平策略，我们对比一下两个 tryAcquireShared 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 公平策略：</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 区别就在于是不是会先判断是否有线程在排队，然后才进行 CAS 减操作</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非公平策略：</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也是老套路了，所以从源码分析角度的话，我们其实不太需要关心是不是公平策略还是非公平策略，它们的区别往往就那么一两行。</p>
<p>我们再回到 acquireShared 方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 tryAcquireShared(arg) 返回小于 0 的时候，说明 state 已经小于 0 了（没资源了），此时 acquire 不能立马拿到资源，需要进入到阻塞队列等待，虽然贴了很多代码，不在乎多这点了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法我就不介绍了，线程挂起后等待有资源被 release 出来。接下来，我们就要看 release 的方法了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 任务介绍，释放一个资源</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">        <span class="comment">// 溢出，当然，我们一般也不会用这么大的数</span></span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryReleaseShared 方法总是会返回 true，然后是 doReleaseShared，这个也是我们熟悉的方法了，我就贴下代码，不分析了，这个方法用于唤醒所有的等待线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Semphore 的源码确实很简单，基本上都是分析过的老代码的组合使用了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写到这里，终于把 AbstractQueuedSynchronizer 基本上说完了，对于 Java 并发，Doug Lea 真的是神一样的存在。日后我们还会接触到很多 Doug Lea 的代码，希望我们大家都可以朝着大神的方向不断打磨自己的技术，少一些高大上的架构，多一些实实在在的优秀代码吧。</p>
<p>（全文完）</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>AQS</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>G1 垃圾收集器介绍(转自Javadoop)</title>
    <url>/2018/09/12/G1/</url>
    <content><![CDATA[<h1 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h1><p>之前根据 Sun 的内存管理白皮书介绍了在 HotSpot JVM 分代算法中的几个垃圾收集器，本文将介绍 G1 垃圾收集器。</p>
<p>G1 的主要关注点在于达到<strong>可控的停顿时间</strong>，在这个基础上尽可能提高吞吐量，这一点非常重要。</p>
<p>G1 被设计用来长期取代 CMS 收集器，和 CMS 相同的地方在于，它们都属于并发收集器，在大部分的收集阶段都不需要挂起应用程序。区别在于，G1 没有 CMS 的碎片化问题（或者说不那么严重），同时提供了更加可控的停顿时间。</p>
<p>如果你的应用使用了较大的堆（如 6GB 及以上）而且还要求有较低的垃圾收集停顿时间（如 0.5 秒），那么 G1 是你绝佳的选择，是时候放弃 CMS 了。</p>
<p><strong>阅读建议</strong>：本文力求用简单的话介绍清楚 G1 收集器，但是并不会重复介绍每一个细节，所以希望读者了解其他几个收集器的工作过程，尤其是 CMS 收集器。</p>
<span id="more"></span>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3-1742964906329-3.png" alt="G1 收集器"></p>
<h2 id="G1-总览"><a href="#G1-总览" class="headerlink" title="G1 总览"></a>G1 总览</h2><p>首先是内存划分上，之前介绍的分代收集器将整个堆分为年轻代、老年代和永久代，每个代的空间是确定的。</p>
<p>而 G1 将整个堆划分为一个个大小相等的小块（每一块称为一个 region），每一块的内存是连续的。和分代算法一样，G1 中每个块也会充当 Eden、Survivor、Old 三种角色，但是它们不是固定的，这使得内存使用更加地灵活。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3-1742964906329-3.png" alt="内存划分"></p>
<p>执行垃圾收集时，和 CMS 一样，G1 收集线程在标记阶段和应用程序线程<strong>并发</strong>执行，标记结束后，G1 也就知道哪些区块基本上是垃圾，存活对象极少，G1 会先从这些区块下手，因为从这些区块能很快释放得到很大的可用空间，<strong>这也是为什么 G1 被取名为 Garbage-First 的原因</strong>。</p>
<blockquote>
<p>这里只不过是先介绍些概念，没看懂没关系，往下看</p>
</blockquote>
<p>在 G1 中，目标停顿时间非常非常重要，用 -XX:MaxGCPauseMillis=200 指定期望的停顿时间。</p>
<p>G1 使用了<strong>停顿预测模型</strong>来满足用户指定的停顿时间目标，并基于目标来选择进行垃圾回收的区块数量。G1 采用增量回收的方式，每次回收一些区块，而不是整堆回收。</p>
<p>我们要知道 G1 不是一个实时收集器，它会尽力满足我们的停顿时间要求，但也不是绝对的，它基于之前垃圾收集的数据统计，估计出在用户指定的停顿时间内能收集多少个区块。</p>
<p><strong>注意：</strong>G1 有和应用程序一起运行的并发阶段，也有 stop-the-world 的并行阶段。但是，<strong>Full GC 的时候还是单线程运行的</strong>，所以我们应该尽量避免发生 Full GC，后面我们也会介绍什么时候会触发 Full GC。</p>
<p><strong>G1 内存占用</strong></p>
<p>G1 比 ParallelOld 和 CMS 会需要更多的内存消耗，那是因为有部分内存消耗于簿记（accounting）上，如以下两个数据结构：</p>
<ul>
<li><strong>Remembered Sets</strong>：每个区块都有一个 RSet，用于记录进入该区块的对象引用（如区块 A 中的对象引用了区块 B，区块 B 的 Rset 需要记录这个信息），它用于实现收集过程的并行化以及使得区块能进行独立收集。总体上 Remembered Sets 消耗的内存小于 5%。</li>
<li><strong>Collection Sets</strong>：将要被回收的区块集合。GC 时，在这些区块中的对象会被复制到其他区块中，总体上 Collection Sets 消耗的内存小于 1%。</li>
</ul>
<h2 id="G1-工作流程"><a href="#G1-工作流程" class="headerlink" title="G1 工作流程"></a>G1 工作流程</h2><p>前面啰里啰嗦说了挺多的，唯一要记住的就是，G1 的设计目标就是尽力满足我们的目标停顿时间上的要求。</p>
<p>本节介绍 G1 的收集过程，G1 收集器主要包括了以下 4 种操作：</p>
<ul>
<li>1、年轻代收集</li>
<li>2、并发收集，和应用线程同时执行</li>
<li>3、混合式垃圾收集</li>
<li>*、必要时的 Full GC</li>
</ul>
<p>接下来，我们进行一一介绍。</p>
<h3 id="年轻代收集"><a href="#年轻代收集" class="headerlink" title="年轻代收集"></a>年轻代收集</h3><p>首先，我们来看下 G1 的堆结构：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/8ca16868.png" alt="G1 GC 内存布局"></p>
<p>年轻代中的垃圾收集流程（Young GC）：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2.png" alt="Young GC"></p>
<p>我们可以看到，年轻代收集概念上和之前介绍的其他分代收集器大差不差的，但是它的年轻代会动态调整。</p>
<h3 id="Old-GC-并发标记周期"><a href="#Old-GC-并发标记周期" class="headerlink" title="Old GC / 并发标记周期"></a>Old GC / 并发标记周期</h3><p>接下来是 Old GC 的流程（含 Young GC 阶段），其实把 Old GC  理解为<strong>并发周期</strong>是比较合理的，不要单纯地认为是清理老年代的区块，因为这一步和年轻代收集也是相关的。下面我们介绍主要流程：</p>
<ol>
<li><p>初始标记：stop-the-world，它伴随着一次普通的 Young GC 发生，然后对 Survivor 区（root region）进行标记，因为该区可能存在对老年代的引用。</p>
<blockquote>
<p>因为 Young GC 是需要 stop-the-world 的，所以并发周期直接重用这个阶段，虽然会增加 CPU 开销，但是停顿时间只是增加了一小部分。</p>
</blockquote>
</li>
<li><p>扫描根引用区：因为先进行了一次 YGC，所以当前年轻代只有 Survivor 区有存活对象，它被称为根引用区。扫描 Survivor 到老年代的引用，该阶段必须在下一次 Young GC 发生前结束。</p>
<blockquote>
<p>这个阶段不能发生年轻代收集，如果中途 Eden 区真的满了，也要等待这个阶段结束才能进行 Young GC。</p>
</blockquote>
</li>
<li><p>并发标记：寻找整个堆的存活对象，该阶段可以被 Young GC 中断。</p>
<blockquote>
<p>这个阶段是并发执行的，中间可以发生多次 Young GC，Young GC 会中断标记过程</p>
</blockquote>
</li>
<li><p>重新标记：stop-the-world，完成最后的存活对象标记。使用了比 CMS 收集器更加高效的 snapshot-at-the-beginning (SATB) 算法。</p>
<blockquote>
<p>Oracle 的资料显示，这个阶段会回收完全空闲的区块</p>
</blockquote>
</li>
<li><p>清理：清理阶段真正回收的内存很少。</p>
</li>
</ol>
<p>到这里，G1 的一个并发周期就算结束了，其实就是主要完成了垃圾定位的工作，定位出了哪些分区是垃圾最多的。因为整堆一般比较大，所以这个周期应该会比较长，中间可能会被多次 stop-the-world 的 Young GC 打断。</p>
<h3 id="混合垃圾回收周期"><a href="#混合垃圾回收周期" class="headerlink" title="混合垃圾回收周期"></a>混合垃圾回收周期</h3><p>并发周期结束后是混合垃圾回收周期，不仅进行年轻代垃圾收集，而且回收之前标记出来的老年代的垃圾最多的部分区块。</p>
<p>混合垃圾回收周期会持续进行，直到几乎所有的被标记出来的分区（垃圾占比大的分区）都得到回收，然后恢复到常规的年轻代垃圾收集，最终再次启动并发周期。</p>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>到这里我们已经说了年轻代收集、并发周期、混合回收周期了，大家要熟悉这几个阶段的工作。</p>
<p>下面我们来介绍特殊情况，那就是会导致 <strong>Full GC</strong> 的情况，也是我们需要极力避免的：</p>
<ol>
<li><p>concurrent mode failure：并发模式失败，CMS 收集器也有同样的概念。G1 并发标记期间，如果在标记结束前，老年代被填满，G1 会放弃标记。</p>
<blockquote>
<p>这个时候说明</p>
<ul>
<li>堆需要增加了，</li>
<li>或者需要调整并发周期，如增加并发标记的线程数量，让并发标记尽快结束</li>
<li>或者就是更早地进行并发周期，默认是整堆内存的 45% 被占用就开始进行并发周期。</li>
</ul>
</blockquote>
</li>
<li><p>晋升失败：并发周期结束后，是混合垃圾回收周期，伴随着年轻代垃圾收集，进行清理老年代空间，如果这个时候清理的速度小于消耗的速度，导致老年代不够用，那么会发生晋升失败。</p>
<blockquote>
<p>说明混合垃圾回收需要更迅速完成垃圾收集，也就是说在混合回收阶段，每次年轻代的收集应该处理更多的老年代已标记区块。</p>
</blockquote>
</li>
<li><p>疏散失败：年轻代垃圾收集的时候，如果 Survivor 和 Old 区没有足够的空间容纳所有的存活对象。这种情况肯定是非常致命的，因为基本上已经没有多少空间可以用了，这个时候会触发 Full GC 也是很合理的。</p>
<blockquote>
<p>最简单的就是增加堆大小</p>
</blockquote>
</li>
<li><p>大对象分配失败，我们应该尽可能地不创建大对象，尤其是大于一个区块大小的那种对象。</p>
</li>
</ol>
<h3 id="简单小结"><a href="#简单小结" class="headerlink" title="简单小结"></a>简单小结</h3><p>看完上面的 Young GC 和 Old GC 等，很多读者可能还是很懵的，这里说几句不严谨的白话文帮助读者进行理解：</p>
<p>首先，最好不要把上面的 Old GC 当做是一次 GC 来看，而应该当做<strong>并发标记周期</strong>来理解，虽然它确实会释放出一些内存。</p>
<p>并发标记结束后，G1 也就知道了哪些区块是最适合被回收的，那些完全空闲的区块会在这这个阶段被回收。如果这个阶段释放了足够的内存出来，其实也就可以认为结束了一次 GC。</p>
<p>我们假设并发标记结束了，那么下次 GC 的时候，还是会先回收年轻代，如果从年轻代中得到了足够的内存，那么结束；过了几次后，年轻代垃圾收集不能满足需要了，那么就需要利用之前并发标记的结果，选择一些活跃度最低的老年代区块进行回收。直到最后，老年代会进入下一个并发周期。</p>
<p>那么什么时候会启动并发标记周期呢？这个是通过参数控制的，下面马上要介绍这个参数了，此参数默认值是 45，也就是说当堆空间使用了 45% 后，G1 就会进入并发标记周期。</p>
<h2 id="G1-参数配置和最佳实践"><a href="#G1-参数配置和最佳实践" class="headerlink" title="G1 参数配置和最佳实践"></a>G1 参数配置和最佳实践</h2><p>G1 调优的目标是尽量避免出现 Full GC，其实就是给老年代足够的空间，或相对更多的空间。</p>
<p>有以下几点我们可以进行调整的方向：</p>
<ul>
<li>增加堆大小，或调整老年代和年轻代的比例，这个很好理解</li>
<li>增加并发周期的线程数量，其实就是为了加快并发周期快点结束</li>
<li>让并发周期尽早开始，这个是通过设置堆使用占比来调整的（默认 45%）</li>
<li>在混合垃圾回收周期中回收更多的老年代区块</li>
</ul>
<p>G1 的很重要的目标是达到可控的停顿时间，所以很多的行为都以这个目标为出发点开展的。</p>
<p>我们通过设置 -XX:MaxGCPauseMillis=N 来指定停顿时间（单位 ms，默认 200ms），如果没有达到这个目标，G1 会通过各种方式来补救：调整年轻代和老年代的比例，调整堆大小，调整晋升的年龄阈值，调整混合垃圾回收周期中处理的老年代的区块数量等等。</p>
<p>当然了，调整每个参数满足了一个条件的同时往往也会引入另一个问题，比如为了降低停顿时间，我们可以减小年轻代的大小，可是这样的话就会增加年轻代垃圾收集的频率。如果我们减少混合垃圾回收周期处理的老年代区块数量，虽然可以更容易满足停顿时间要求，可是这样就会增加 Full GC 的风险等等。</p>
<p>下面介绍最常用也是最基础的一些参数的设置，涉及到更高级的调优参数设置，请读者自行参阅其他资料。</p>
<p><strong>参数介绍</strong>：</p>
<ul>
<li><p><strong>-XX:+UseG1GC</strong></p>
<p>使用 G1 收集器</p>
</li>
<li><p><strong>-XX:MaxGCPauseMillis=200</strong></p>
<p>指定目标停顿时间，默认值 200 毫秒。</p>
<blockquote>
<p>在设置 -XX:MaxGCPauseMillis 值的时候，不要指定为平均时间，而应该指定为满足 90% 的停顿在这个时间之内。记住，停顿时间目标是我们的目标，不是每次都一定能满足的。</p>
</blockquote>
</li>
<li><p><strong>-XX:InitiatingHeapOccupancyPercent=45</strong></p>
<p>整堆使用达到这个比例后，触发并发 GC 周期，默认 45%。</p>
<blockquote>
<p>如果要降低晋升失败的话，通常可以调整这个数值，使得并发周期提前进行</p>
</blockquote>
</li>
<li><p><strong>-XX:NewRatio=n</strong></p>
<p>老年代/年轻代，默认值 2，即 1/3 的年轻代，2/3 的老年代</p>
<blockquote>
<p>不要设置年轻代为固定大小，否则：</p>
<ul>
<li>G1 不再需要满足我们的停顿时间目标</li>
<li>不能再按需扩容或缩容年轻代大小</li>
</ul>
</blockquote>
</li>
<li><p><strong>-XX:SurvivorRatio=n</strong></p>
<p>Eden/Survivor，默认值 8，这个和其他分代收集器是一样的</p>
</li>
<li><p><strong>-XX:MaxTenuringThreshold =n</strong></p>
<p>从年轻代晋升到老年代的年龄阈值，也是和其他分代收集器一样的</p>
</li>
<li><p><strong>-XX:ParallelGCThreads=n</strong></p>
<p>并行收集时候的垃圾收集线程数</p>
</li>
<li><p><strong>-XX:ConcGCThreads=n</strong></p>
<p>并发标记阶段的垃圾收集线程数</p>
<blockquote>
<p>增加这个值可以让并发标记更快完成，如果没有指定这个值，JVM 会通过以下公式计算得到：</p>
<p>ConcGCThreads=(ParallelGCThreads + 2) / 4^3</p>
</blockquote>
</li>
<li><p><strong>-XX:G1ReservePercent=n</strong></p>
<p>堆内存的预留空间百分比，默认 10，用于降低晋升失败的风险，即默认地会将 10% 的堆内存预留下来。</p>
</li>
<li><p><strong>-XX:G1HeapRegionSize=n</strong></p>
<p>每一个 region 的大小，默认值为根据堆大小计算出来，取值 1MB~32MB，这个我们通常指定整堆大小就好了。</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我自己仔细检查了几遍，主要内容都囊括了，我也不知道读者看完本文会不会是一脸懵逼。</p>
<p>如果有什么问题，可以在留言板上给我留言，<strong>我是 GC 的门外汉</strong>，如果有些问题我觉得自己能解答，我会尽力帮助大家。</p>
<p>最后，在这里推荐一些资料给感兴趣的读者：</p>
<p>Oracle 官方出品，本文的很多内容是翻译并解读这篇文章的：</p>
<p><a href="http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html">Getting Started with the G1 Garbage Collector</a></p>
<p>帮助大家理解 G1 的日志：</p>
<p><a href="https://blogs.oracle.com/poonam/understanding-g1-gc-logs">Understanding G1 GC Logs</a></p>
<p>这里介绍 GC 的内容非常好：</p>
<p><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#g1">https://plumbr.io/handbook/garbage-collection-algorithms-implementations#g1</a></p>
<p>《Java 性能权威指南》：非常好的一本书，建议读者有时间可以看看这本书中关于 GC 的介绍。</p>
<p>（全文完）</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>GC</tag>
        <tag>G1</tag>
      </tags>
  </entry>
  <entry>
    <title>解读 java 并发队列 BlockingQueue(转自Javadoop)</title>
    <url>/2018/07/23/BlockingQueue/</url>
    <content><![CDATA[<p>最近得空，想写篇文章好好说说 java 线程池问题，我相信很多人都一知半解的，包括我自己在仔仔细细看源码之前，也有许多的不解，甚至有些地方我一直都没有理解到位。</p>
<p>说到线程池实现，那么就不得不涉及到各种 BlockingQueue 的实现，那么我想就 BlockingQueue 的问题和大家分享分享我了解的一些知识。</p>
<p>本文没有像之前分析 AQS 那样一行一行源码分析了，不过还是把其中最重要和最难理解的代码说了一遍，所以不免篇幅略长。本文涉及到比较多的 Doug Lea 对 BlockingQueue 的设计思想，希望有心的读者真的可以有一些收获，我觉得自己还是写了一些干货的。</p>
<p>本文直接参考 Doug Lea 写的 Java doc 和注释，这也是我们在学习 java 并发包时最好的材料了。希望大家能有所思、有所悟，学习 Doug Lea 的代码风格，并将其优雅、严谨的作风应用到我们写的每一行代码中。</p>
<span id="more"></span>

<p><strong>目录：</strong></p>
<!-- toc -->

<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><blockquote>
<p>开篇先介绍下 BlockingQueue 这个接口的规则，后面再看其实现。</p>
</blockquote>
<p>首先，最基本的来说， BlockingQueue 是一个<strong>先进先出</strong>的队列（Queue），为什么说是阻塞（Blocking）的呢？是因为 BlockingQueue 支持当获取队列元素但是队列为空时，会阻塞等待队列中有元素再返回；也支持添加元素时，如果队列已满，那么等到队列可以放入新元素时再放入。</p>
<p>BlockingQueue 是一个接口，继承自 Queue，所以其实现类也可以作为 Queue 的实现来使用，而 Queue 又继承自 Collection 接口。</p>
<p>BlockingQueue 对插入操作、移除操作、获取元素操作提供了四种不同的方法用于不同的场景中使用：1、抛出异常；2、返回特殊值（null 或 true/false，取决于具体的操作）；3、阻塞等待此操作，直到这个操作成功；4、阻塞等待此操作，直到成功或者超时指定时间。总结如下：</p>
<table>
<thead>
<tr>
<th></th>
<th><em>Throws exception</em></th>
<th><em>Special value</em></th>
<th><em>Blocks</em></th>
<th><em>Times out</em></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Insert</strong></td>
<td>add(e)</td>
<td>offer(e)</td>
<td><strong>put(e)</strong></td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td><strong>Remove</strong></td>
<td>remove()</td>
<td>poll()</td>
<td><strong>take()</strong></td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td><strong>Examine</strong></td>
<td>element()</td>
<td>peek()</td>
<td><em>not applicable</em></td>
<td><em>not applicable</em></td>
</tr>
</tbody></table>
<p>BlockingQueue 的各个实现都遵循了这些规则，当然我们也不用死记这个表格，知道有这么回事，然后写代码的时候根据自己的需要去看方法的注释来选取合适的方法即可。</p>
<blockquote>
<p>对于 BlockingQueue，我们的关注点应该在 put(e) 和 take() 这两个方法，因为这两个方法是带阻塞的。</p>
</blockquote>
<p>BlockingQueue 不接受 null 值的插入，相应的方法在碰到 null 的插入时会抛出 NullPointerException 异常。null 值在这里通常用于作为特殊值返回（表格中的第三列），代表 poll 失败。所以，如果允许插入 null 值的话，那获取的时候，就不能很好地用 null 来判断到底是代表失败，还是获取的值就是 null 值。</p>
<p>一个 BlockingQueue 可能是有界的，如果在插入的时候，发现队列满了，那么 put 操作将会阻塞。通常，在这里我们说的无界队列也不是说真正的无界，而是它的容量是 Integer.MAX_VALUE（21亿多）。</p>
<p>BlockingQueue 是设计用来实现生产者-消费者队列的，当然，你也可以将它当做普通的 Collection 来用，前面说了，它实现了 java.util.Collection 接口。例如，我们可以用 remove(x) 来删除任意一个元素，但是，这类操作通常并不高效，所以尽量只在少数的场合使用，比如一条消息已经入队，但是需要做取消操作的时候。</p>
<p>BlockingQueue 的实现都是线程安全的，但是批量的集合操作如 <code>addAll</code>, <code>containsAll</code>, <code>retainAll</code> 和 <code>removeAll</code>  不一定是原子操作。如 addAll(c) 有可能在添加了一些元素后中途抛出异常，此时 BlockingQueue 中已经添加了部分元素，这个是允许的，取决于具体的实现。</p>
<p>BlockingQueue 不支持 close 或 shutdown 等<strong>关闭</strong>操作，因为开发者可能希望不会有新的元素添加进去，此特性取决于具体的实现，不做强制约束。</p>
<p>最后，BlockingQueue 在生产者-消费者的场景中，是支持多消费者和多生产者的，说的其实就是线程安全问题。</p>
<p>相信上面说的每一句都很清楚了，BlockingQueue 是一个比较简单的线程安全容器，下面我会分析其具体的在 JDK 中的实现，这里又到了 Doug Lea 表演时间了。</p>
<h2 id="BlockingQueue-实现之-ArrayBlockingQueue"><a href="#BlockingQueue-实现之-ArrayBlockingQueue" class="headerlink" title="BlockingQueue 实现之 ArrayBlockingQueue"></a>BlockingQueue 实现之 ArrayBlockingQueue</h2><p>ArrayBlockingQueue 是 BlockingQueue 接口的有界队列实现类，底层采用数组来实现。</p>
<p>其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。</p>
<p>如果读者看过我之前写的《<a href="/post/AbstractQueuedSynchronizer-2">一行一行源码分析清楚 AbstractQueuedSynchronizer（二）</a>》 的关于 Condition 的文章的话，那么你一定能很容易看懂 ArrayBlockingQueue  的源码，它采用一个 ReentrantLock 和相应的两个 Condition 来实现。</p>
<p>ArrayBlockingQueue 共有以下几个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于存放元素的数组</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"><span class="comment">// 下一次读取操作的位置</span></span><br><span class="line"><span class="type">int</span> takeIndex;</span><br><span class="line"><span class="comment">// 下一次写入操作的位置</span></span><br><span class="line"><span class="type">int</span> putIndex;</span><br><span class="line"><span class="comment">// 队列中的元素数量</span></span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下几个就是控制并发用的同步器</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure>

<p>我们用个示意图来描述其同步机制：</p>
<p><img src="https://assets.javadoop.com/blogimages/java-concurrent-queue/array-blocking-queue.png" alt="array-blocking-queue"></p>
<p>ArrayBlockingQueue 实现并发同步的原理就是，读操作和写操作都需要获取到 AQS 独占锁才能进行操作。如果队列为空，这个时候读操作的线程进入到<strong>读线程队列</strong>排队，等待写线程写入新的元素，然后唤醒读线程队列的第一个等待线程。如果队列已满，这个时候写操作的线程进入到<strong>写线程队列</strong>排队，等待读线程将队列元素移除腾出空间，然后唤醒写线程队列的第一个等待线程。</p>
<p>对于 ArrayBlockingQueue，我们可以在构造的时候指定以下三个参数：</p>
<ol>
<li>队列容量，其限制了队列中最多允许的元素个数；</li>
<li>指定独占锁是公平锁还是非公平锁。非公平锁的吞吐量比较高，公平锁可以保证每次都是等待最久的线程获取到锁；</li>
<li>可以指定用一个集合来初始化，将此集合中的元素在构造方法期间就先添加到队列中。</li>
</ol>
<p>更具体的源码我就不进行分析了，因为它就是 AbstractQueuedSynchronizer 中 Condition 的使用，感兴趣的读者请看我写的《<a href="/post/AbstractQueuedSynchronizer-2/">一行一行源码分析清楚 AbstractQueuedSynchronizer（二）</a>》，因为只要看懂了那篇文章，ArrayBlockingQueue 的代码就没有分析的必要了，当然，如果你完全不懂 Condition，那么基本上也就可以说看不懂 ArrayBlockingQueue 的源码了。</p>
<h2 id="BlockingQueue-实现之-LinkedBlockingQueue"><a href="#BlockingQueue-实现之-LinkedBlockingQueue" class="headerlink" title="BlockingQueue 实现之 LinkedBlockingQueue"></a>BlockingQueue 实现之 LinkedBlockingQueue</h2><p>底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用。看构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传说中的无界队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传说中的有界队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看看这个类有哪些属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 队列容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列中的元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// take, poll, peek 等读操作的方法需要获取到这个锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果读操作的时候队列是空的，那么等待 notEmpty 条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">// put, offer 等写操作的方法需要获取到这个锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果写操作的时候队列是满的，那么等待 notFull 条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> putLock.newCondition();</span><br></pre></td></tr></table></figure>

<p>这里用了两个锁，两个 Condition，简单介绍如下：</p>
<p><strong>takeLock 和 notEmpty 怎么搭配：</strong>如果要获取（take）一个元素，需要获取 takeLock 锁，但是获取了锁还不够，如果队列此时为空，还需要队列不为空（notEmpty）这个条件（Condition）。</p>
<p><strong>putLock 需要和 notFull 搭配：</strong>如果要插入（put）一个元素，需要获取 putLock 锁，但是获取了锁还不够，如果队列此时已满，还需要队列不是满的（notFull）这个条件（Condition）。</p>
<p>首先，这里用一个示意图来看看 LinkedBlockingQueue 的并发读写控制，然后再开始分析源码：</p>
<p><img src="https://assets.javadoop.com/blogimages/java-concurrent-queue/linked-blocking-queue.png" alt="linked-blocking-queue"></p>
<p>看懂这个示意图，源码也就简单了，读操作是排好队的，写操作也是排好队的，唯一的并发问题在于一个写操作和一个读操作同时进行，只要控制好这个就可以了。</p>
<p>先上构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里会初始化一个空的头结点，那么第一个元素入队的时候，队列中就会有两个元素。读取元素时，也总是获取头节点后面的一个节点。count 的计数值不包括这个头节点。</p>
<p>我们来看下 put 方法是怎么将元素插入到队尾的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 如果你纠结这里为什么是 -1，可以看看 offer 方法。这就是个标识成功、失败的标志而已。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="comment">// 必须要获取到 putLock 才可以进行插入操作</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列满，等待 notFull 的条件满足。</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">// count 原子加 1，c 还是加 1 前的值</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// 如果这个元素入队后，还有至少一个槽可以使用，调用 notFull.signal() 唤醒等待线程。</span></span><br><span class="line">        <span class="comment">// 哪些线程会等待在 notFull 这个 Condition 上呢？</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 入队后，释放掉 putLock</span></span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 c == 0，那么代表队列在这个元素入队前是空的（不包括head空节点），</span></span><br><span class="line">    <span class="comment">// 那么所有的读线程都在等待 notEmpty 这个条件，等待唤醒，这里做一次唤醒操作</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队的代码非常简单，就是将 last 属性指向这个新元素，并且让原队尾的 next 指向这个元素</span></span><br><span class="line"><span class="comment">// 这里入队没有并发问题，因为只有获取到 putLock 独占锁以后，才可以进行此操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> &#123;</span><br><span class="line">    <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert last.next == null;</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素入队后，如果需要，调用这个方法唤醒读线程来读</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">signalNotEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再看看 take 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    <span class="comment">// 首先，需要获取到 takeLock 才能进行出队操作</span></span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列为空，等待 notEmpty 这个条件满足再继续执行</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出队</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">        <span class="comment">// count 进行原子减 1</span></span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="comment">// 如果这次出队后，队列中至少还有一个元素，那么调用 notEmpty.signal() 唤醒其他的读线程</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 出队后释放掉 takeLock</span></span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 c == capacity，那么说明在这个 take 方法发生的时候，队列是满的</span></span><br><span class="line">    <span class="comment">// 既然出队了一个，那么意味着队列不满了，唤醒写线程去写</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取队头，出队</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert head.item == null;</span></span><br><span class="line">    <span class="comment">// 之前说了，头结点是空的</span></span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">// 设置这个为新的头结点</span></span><br><span class="line">    head = first;</span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> first.item;</span><br><span class="line">    first.item = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 元素出队后，如果需要，调用这个方法唤醒写线程来写</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">signalNotFull</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码分析就到这里结束了吧，毕竟还是比较简单的源码，基本上只要读者认真点都看得懂。</p>
<h2 id="BlockingQueue-实现之-SynchronousQueue"><a href="#BlockingQueue-实现之-SynchronousQueue" class="headerlink" title="BlockingQueue 实现之 SynchronousQueue"></a>BlockingQueue 实现之 SynchronousQueue</h2><p>它是一个特殊的队列，它的名字其实就蕴含了它的特征 - - 同步的队列。为什么说是同步的呢？这里说的并不是多线程的并发问题，而是因为当一个线程往队列中写入一个元素时，写入操作不会立即返回，需要等待另一个线程来将这个元素拿走；同理，当一个读线程做读操作的时候，同样需要一个相匹配的写线程的写操作。这里的 Synchronous 指的就是读线程和写线程需要同步，一个读线程匹配一个写线程。</p>
<p>我们比较少使用到 SynchronousQueue 这个类，不过它在线程池的实现类 ThreadPoolExecutor 中得到了应用，感兴趣的读者可以在看完这个后去看看相应的使用。</p>
<p>虽然上面我说了队列，但是 SynchronousQueue 的队列其实是虚的，其不提供任何空间（一个都没有）来存储元素。数据必须从某个写线程交给某个读线程，而不是写到某个队列中等待被消费。</p>
<p>你不能在 SynchronousQueue 中使用 peek 方法（在这里这个方法直接返回 null），peek 方法的语义是只读取不移除，显然，这个方法的语义是不符合 SynchronousQueue 的特征的。SynchronousQueue 也不能被迭代，因为根本就没有元素可以拿来迭代的。虽然 SynchronousQueue 间接地实现了 Collection 接口，但是如果你将其当做 Collection 来用的话，那么集合是空的。当然，这个类也是不允许传递 null 值的（并发包中的容器类好像都不支持插入 null 值，因为 null 值往往用作其他用途，比如用于方法的返回值代表操作失败）。</p>
<p>接下来，我们来看看具体的源码实现吧，它的源码不是很简单的那种，我们需要先搞清楚它的设计思想。</p>
<p>源码加注释大概有 1200 行，我们先看大框架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造时，我们可以指定公平模式还是非公平模式，区别之后再说</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SynchronousQueue</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> <span class="title class_">TransferQueue</span>() : <span class="keyword">new</span> <span class="title class_">TransferStack</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Transferer</span> &#123;</span><br><span class="line">    <span class="comment">// 从方法名上大概就知道，这个方法用于转移元素，从生产者手上转到消费者手上</span></span><br><span class="line">    <span class="comment">// 也可以被动地，消费者调用这个方法来从生产者手上取元素</span></span><br><span class="line">    <span class="comment">// 第一个参数 e 如果不是 null，代表场景为：将元素从生产者转移给消费者</span></span><br><span class="line">    <span class="comment">// 如果是 null，代表消费者等待生产者提供元素，然后返回值就是相应的生产者提供的元素</span></span><br><span class="line">    <span class="comment">// 第二个参数代表是否设置超时，如果设置超时，超时时间是第三个参数的值</span></span><br><span class="line">    <span class="comment">// 返回值如果是 null，代表超时，或者中断。具体是哪个，可以通过检测中断状态得到。</span></span><br><span class="line">    <span class="keyword">abstract</span> Object <span class="title function_">transfer</span><span class="params">(Object e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Transferer 有两个内部实现类，是因为构造 SynchronousQueue 的时候，我们可以指定公平策略。公平模式意味着，所有的读写线程都遵守先来后到，FIFO 嘛，对应 TransferQueue。而非公平模式则对应 TransferStack。</p>
<p><img src="https://assets.javadoop.com/blogimages/java-concurrent-queue/synchronous-queue.png" alt="synchronous-queue"></p>
<p>我们先采用公平模式分析源码，然后再说说公平模式和非公平模式的区别。</p>
<p>接下来，我们看看 put 方法和 take 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E o)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(o, <span class="literal">false</span>, <span class="number">0</span>) == <span class="literal">null</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">        Thread.interrupted();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取值并移除</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> transferer.transfer(<span class="literal">null</span>, <span class="literal">false</span>, <span class="number">0</span>); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> (E)e;</span><br><span class="line">    Thread.interrupted();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，写操作 put(E o) 和读操作 take() 都是调用 Transferer.transfer(…) 方法，区别在于第一个参数是否为 null 值。</p>
<p>我们来看看 transfer 的设计思路，其基本算法如下：</p>
<ol>
<li>当调用这个方法时，如果队列是空的，或者队列中的节点和当前的线程操作类型一致（如当前操作是 put 操作，而队列中的元素也都是写线程）。这种情况下，将当前线程加入到等待队列即可。</li>
<li>如果队列中有等待节点，而且与当前操作可以匹配（如队列中都是读操作线程，当前线程是写操作线程，反之亦然）。这种情况下，匹配等待队列的队头，出队，返回相应数据。</li>
</ol>
<p>其实这里有个隐含的条件被满足了，队列如果不为空，肯定都是同种类型的节点，要么都是读操作，要么都是写操作。这个就要看到底是读线程积压了，还是写线程积压了。</p>
<p>我们可以假设出一个男女配对的场景：一个男的过来，如果一个人都没有，那么他需要等待；如果发现有一堆男的在等待，那么他需要排到队列后面；如果发现是一堆女的在排队，那么他直接牵走队头的那个女的。</p>
<p>既然这里说到了等待队列，我们先看看其实现，也就是 QNode:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">QNode</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> QNode next;          <span class="comment">// 可以看出来，等待队列是单向链表</span></span><br><span class="line">    <span class="keyword">volatile</span> Object item;         <span class="comment">// CAS&#x27;ed to or from null</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;       <span class="comment">// 将线程对象保存在这里，用于挂起和唤醒</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> isData;         <span class="comment">// 用于判断是写线程节点(isData == true)，还是读线程节点</span></span><br><span class="line"></span><br><span class="line">    QNode(Object item, <span class="type">boolean</span> isData) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = item;</span><br><span class="line">        <span class="built_in">this</span>.isData = isData;</span><br><span class="line">    &#125;</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>

<p>相信说了这么多以后，我们再来看 transfer 方法的代码就轻松多了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Puts or takes an item.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Object <span class="title function_">transfer</span><span class="params">(Object e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">QNode</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isData</span> <span class="operator">=</span> (e != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span> || h == <span class="literal">null</span>)         <span class="comment">// saw uninitialized value</span></span><br><span class="line">            <span class="keyword">continue</span>;                       <span class="comment">// spin</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列空，或队列中节点类型和当前节点一致，</span></span><br><span class="line">        <span class="comment">// 即我们说的第一种情况，将节点入队即可。读者要想着这块 if 里面方法其实就是入队</span></span><br><span class="line">        <span class="keyword">if</span> (h == t || t.isData == isData) &#123; <span class="comment">// empty or same-mode</span></span><br><span class="line">            <span class="type">QNode</span> <span class="variable">tn</span> <span class="operator">=</span> t.next;</span><br><span class="line">            <span class="comment">// t != tail 说明刚刚有节点入队，continue 即可</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail)                  <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 有其他节点入队，但是 tail 还是指向原来的，此时设置 tail 即可</span></span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="literal">null</span>) &#123;               <span class="comment">// lagging tail</span></span><br><span class="line">                <span class="comment">// 这个方法就是：如果 tail 此时为 t 的话，设置为 tn</span></span><br><span class="line">                advanceTail(t, tn);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)        <span class="comment">// can&#x27;t wait</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">null</span>)</span><br><span class="line">                s = <span class="keyword">new</span> <span class="title class_">QNode</span>(e, isData);</span><br><span class="line">            <span class="comment">// 将当前节点，插入到 tail 的后面</span></span><br><span class="line">            <span class="keyword">if</span> (!t.casNext(<span class="literal">null</span>, s))        <span class="comment">// failed to link in</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前节点设置为新的 tail</span></span><br><span class="line">            advanceTail(t, s);              <span class="comment">// swing tail and wait</span></span><br><span class="line">            <span class="comment">// 看到这里，请读者先往下滑到这个方法，看完了以后再回来这里，思路也就不会断了</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> awaitFulfill(s, e, timed, nanos);</span><br><span class="line">            <span class="comment">// 到这里，说明之前入队的线程被唤醒了，准备往下执行</span></span><br><span class="line">            <span class="keyword">if</span> (x == s) &#123;                   <span class="comment">// wait was cancelled</span></span><br><span class="line">                clean(t, s);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!s.isOffList()) &#123;           <span class="comment">// not already unlinked</span></span><br><span class="line">                advanceHead(t, s);          <span class="comment">// unlink if head</span></span><br><span class="line">                <span class="keyword">if</span> (x != <span class="literal">null</span>)              <span class="comment">// and forget fields</span></span><br><span class="line">                    s.item = s;</span><br><span class="line">                s.waiter = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="literal">null</span>) ? x : e;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里的 else 分支就是上面说的第二种情况，有相应的读或写相匹配的情况</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// complementary-mode</span></span><br><span class="line">            <span class="type">QNode</span> <span class="variable">m</span> <span class="operator">=</span> h.next;               <span class="comment">// node to fulfill</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail || m == <span class="literal">null</span> || h != head)</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// inconsistent read</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> m.item;</span><br><span class="line">            <span class="keyword">if</span> (isData == (x != <span class="literal">null</span>) ||    <span class="comment">// m already fulfilled</span></span><br><span class="line">                x == m ||                   <span class="comment">// m cancelled</span></span><br><span class="line">                !m.casItem(x, e)) &#123;         <span class="comment">// lost CAS</span></span><br><span class="line">                advanceHead(h, m);          <span class="comment">// dequeue and retry</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            advanceHead(h, m);              <span class="comment">// successfully fulfilled</span></span><br><span class="line">            LockSupport.unpark(m.waiter);</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="literal">null</span>) ? x : e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">advanceTail</span><span class="params">(QNode t, QNode nt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tail == t)</span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, tailOffset, t, nt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自旋或阻塞，直到满足条件，这个方法返回</span></span><br><span class="line">Object <span class="title function_">awaitFulfill</span><span class="params">(QNode s, Object e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">lastTime</span> <span class="operator">=</span> timed ? System.nanoTime() : <span class="number">0</span>;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">w</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 判断需要自旋的次数，</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> ((head.next == s) ?</span><br><span class="line">                 (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 如果被中断了，那么取消这个节点</span></span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">            <span class="comment">// 就是将当前节点 s 中的 item 属性设置为 this</span></span><br><span class="line">            s.tryCancel(e);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> s.item;</span><br><span class="line">        <span class="comment">// 这里是这个方法的唯一的出口</span></span><br><span class="line">        <span class="keyword">if</span> (x != e)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="comment">// 如果需要，检测是否超时</span></span><br><span class="line">        <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            nanos -= now - lastTime;</span><br><span class="line">            lastTime = now;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                s.tryCancel(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">            --spins;</span><br><span class="line">        <span class="comment">// 如果自旋达到了最大的次数，那么检测</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="literal">null</span>)</span><br><span class="line">            s.waiter = w;</span><br><span class="line">        <span class="comment">// 如果自旋到了最大的次数，那么线程挂起，等待唤醒</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// spinForTimeoutThreshold 这个之前讲 AQS 的时候其实也说过，剩余时间小于这个阈值的时候，就</span></span><br><span class="line">        <span class="comment">// 不要进行挂起了，自旋的性能会比较好</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="built_in">this</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Doug Lea 的巧妙之处在于，将各个代码凑在了一起，使得代码非常简洁，当然也同时增加了我们的阅读负担，看代码的时候，还是得仔细想想各种可能的情况。</p>
<p>下面，再说说前面说的公平模式和非公平模式的区别。</p>
<p>相信大家心里面已经有了公平模式的工作流程的概念了，我就简单说说 TransferStack 的算法，就不分析源码了。</p>
<ol>
<li>当调用这个方法时，如果队列是空的，或者队列中的节点和当前的线程操作类型一致（如当前操作是 put 操作，而栈中的元素也都是写线程）。这种情况下，将当前线程加入到等待栈中，等待配对。然后返回相应的元素，或者如果被取消了的话，返回 null。</li>
<li>如果栈中有等待节点，而且与当前操作可以匹配（如栈里面都是读操作线程，当前线程是写操作线程，反之亦然）。将当前节点压入栈顶，和栈中的节点进行匹配，然后将这两个节点出栈。配对和出栈的动作其实也不是必须的，因为下面的一条会执行同样的事情。</li>
<li>如果栈顶是进行匹配而入栈的节点，帮助其进行匹配并出栈，然后再继续操作。</li>
</ol>
<p>应该说，TransferStack 的源码要比 TransferQueue 的复杂一些，如果读者感兴趣，请自行进行源码阅读。</p>
<h2 id="BlockingQueue-实现之-PriorityBlockingQueue"><a href="#BlockingQueue-实现之-PriorityBlockingQueue" class="headerlink" title="BlockingQueue 实现之 PriorityBlockingQueue"></a>BlockingQueue 实现之 PriorityBlockingQueue</h2><p>带排序的 BlockingQueue 实现，其并发控制采用的是 ReentrantLock，队列为无界队列（ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 也可以通过在构造函数中传入 capacity 指定队列最大的容量，但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容）。</p>
<p>简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。</p>
<p>它的源码相对比较简单，本节将介绍其核心源码部分。</p>
<p>我们来看看它有哪些属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造方法中，如果不指定大小的话，默认大小为 11</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 数组的最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个就是存放数据的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列当前大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大小比较器，如果按照自然序排序，那么此属性可设置为 null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="built_in">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发控制所用的锁，所有的 public 且涉及到线程安全的方法，都必须先获取到这个锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个很好理解，其实例由上面的 lock 属性创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个也是用于锁，用于数组扩容的时候，需要先获取到这个锁，才能进行扩容操作</span></span><br><span class="line"><span class="comment">// 其使用 CAS 操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> allocationSpinLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于序列化和反序列化的时候用，对于 PriorityBlockingQueue 我们应该比较少使用到序列化</span></span><br><span class="line"><span class="keyword">private</span> PriorityQueue q;</span><br></pre></td></tr></table></figure>

<p>此类实现了 Collection 和 Iterator 接口中的所有接口方法，对其对象进行迭代并遍历时，不能保证有序性。如果你想要实现有序遍历，建议采用 Arrays.sort(queue.toArray()) 进行处理。PriorityBlockingQueue 提供了 drainTo 方法用于将部分或全部元素有序地填充（准确说是转移，会删除原队列中的元素）到另一个集合中。还有一个需要说明的是，如果两个对象的优先级相同（compare 方法返回 0），此队列并不保证它们之间的顺序。</p>
<p>PriorityBlockingQueue 使用了基于数组的<strong>二叉堆</strong>来存放元素，所有的 public 方法采用同一个 lock 进行并发控制。</p>
<p>二叉堆：一颗完全二叉树，它非常适合用数组进行存储，对于数组中的元素 <code>a[i]</code>，其左子节点为 <code>a[2*i+1]</code>，其右子节点为 <code>a[2*i + 2]</code>，其父节点为 <code>a[(i-1)/2]</code>，其堆序性质为，每个节点的值都小于其左右子节点的值。二叉堆中最小的值就是根节点，但是删除根节点是比较麻烦的，因为需要调整树。</p>
<p>简单用个图解释一下二叉堆，我就不说太多专业的严谨的术语了，这种数据结构的优点是一目了然的，最小的元素一定是根元素，它是一棵满的树，除了最后一层，最后一层的节点从左到右紧密排列。</p>
<p><img src="https://assets.javadoop.com/blogimages/java-concurrent-queue/priority-blocking-queue-1.png" alt="priority-blocking-queue-1"></p>
<p>下面开始 PriorityBlockingQueue 的源码分析，首先我们来看看构造方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造方法，采用默认值(11)来进行初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityBlockingQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定数组的初始大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityBlockingQueue</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定比较器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityBlockingQueue</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                             Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="built_in">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">    <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">    <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在构造方法中就先填充指定的集合中的元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="built_in">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">heapify</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// true if not known to be in heap order</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">screen</span> <span class="operator">=</span> <span class="literal">true</span>;  <span class="comment">// true if must screen for nulls</span></span><br><span class="line">    <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class="line">        SortedSet&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; ss = (SortedSet&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt;) c;</span><br><span class="line">        <span class="built_in">this</span>.comparator = (Comparator&lt;? <span class="built_in">super</span> E&gt;) ss.comparator();</span><br><span class="line">        heapify = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityBlockingQueue&lt;?&gt;) &#123;</span><br><span class="line">        PriorityBlockingQueue&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; pq =</span><br><span class="line">            (PriorityBlockingQueue&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt;) c;</span><br><span class="line">        <span class="built_in">this</span>.comparator = (Comparator&lt;? <span class="built_in">super</span> E&gt;) pq.comparator();</span><br><span class="line">        screen = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pq.getClass() == PriorityBlockingQueue.class) <span class="comment">// exact match</span></span><br><span class="line">            heapify = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="comment">// If c.toArray incorrectly doesn&#x27;t return Object[], copy it.</span></span><br><span class="line">    <span class="keyword">if</span> (a.getClass() != Object[].class)</span><br><span class="line">        a = Arrays.copyOf(a, n, Object[].class);</span><br><span class="line">    <span class="keyword">if</span> (screen &amp;&amp; (n == <span class="number">1</span> || <span class="built_in">this</span>.comparator != <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (a[i] == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.queue = a;</span><br><span class="line">    <span class="built_in">this</span>.size = n;</span><br><span class="line">    <span class="keyword">if</span> (heapify)</span><br><span class="line">        heapify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们来看看其内部的自动扩容实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">tryGrow</span><span class="params">(Object[] array, <span class="type">int</span> oldCap)</span> &#123;</span><br><span class="line">    <span class="comment">// 这边做了释放锁的操作</span></span><br><span class="line">    lock.unlock(); <span class="comment">// must release and then re-acquire main lock</span></span><br><span class="line">    Object[] newArray = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 用 CAS 操作将 allocationSpinLock 由 0 变为 1，也算是获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (allocationSpinLock == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, allocationSpinLockOffset,</span><br><span class="line">                                 <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果节点个数小于 64，那么增加的 oldCap + 2 的容量</span></span><br><span class="line">            <span class="comment">// 如果节点数大于等于 64，那么增加 oldCap 的一半</span></span><br><span class="line">            <span class="comment">// 所以节点数较小时，增长得快一些</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">newCap</span> <span class="operator">=</span> oldCap + ((oldCap &lt; <span class="number">64</span>) ?</span><br><span class="line">                                   (oldCap + <span class="number">2</span>) :</span><br><span class="line">                                   (oldCap &gt;&gt; <span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 这里有可能溢出</span></span><br><span class="line">            <span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;    <span class="comment">// possible overflow</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">minCap</span> <span class="operator">=</span> oldCap + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (minCap &lt; <span class="number">0</span> || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">                newCap = MAX_ARRAY_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 queue != array，那么说明有其他线程给 queue 分配了其他的空间</span></span><br><span class="line">            <span class="keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line">                <span class="comment">// 分配一个新的大数组</span></span><br><span class="line">                newArray = <span class="keyword">new</span> <span class="title class_">Object</span>[newCap];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 重置，也就是释放锁</span></span><br><span class="line">            allocationSpinLock = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有其他的线程也在做扩容的操作</span></span><br><span class="line">    <span class="keyword">if</span> (newArray == <span class="literal">null</span>) <span class="comment">// back off if another thread is allocating</span></span><br><span class="line">        Thread.<span class="keyword">yield</span>();</span><br><span class="line">    <span class="comment">// 重新获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="comment">// 将原来数组中的元素复制到新分配的大数组中</span></span><br><span class="line">    <span class="keyword">if</span> (newArray != <span class="literal">null</span> &amp;&amp; queue == array) &#123;</span><br><span class="line">        queue = newArray;</span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, oldCap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容方法对并发的控制也非常的巧妙，释放了原来的独占锁 lock，这样的话，扩容操作和读操作可以同时进行，提高吞吐量。</p>
<p>下面，我们来分析下写操作 put 方法和读操作 take 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 直接调用 offer 方法，因为前面我们也说了，在这里，put 方法不会阻塞</span></span><br><span class="line">    offer(e); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 首先获取到独占锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">int</span> n, cap;</span><br><span class="line">    Object[] array;</span><br><span class="line">    <span class="comment">// 如果当前队列中的元素个数 &gt;= 数组的大小，那么需要扩容了</span></span><br><span class="line">    <span class="keyword">while</span> ((n = size) &gt;= (cap = (array = queue).length))</span><br><span class="line">        tryGrow(array, cap);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Comparator&lt;? <span class="built_in">super</span> E&gt; cmp = comparator;</span><br><span class="line">        <span class="comment">// 节点添加到二叉堆中</span></span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="literal">null</span>)</span><br><span class="line">            siftUpComparable(n, e, array);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUpUsingComparator(n, e, array, cmp);</span><br><span class="line">        <span class="comment">// 更新 size</span></span><br><span class="line">        size = n + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 唤醒等待的读线程</span></span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于二叉堆而言，插入一个节点是简单的，插入的节点如果比父节点小，交换它们，然后继续和父节点比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个方法就是将数据 x 插入到数组 array 的位置 k 处，然后再调整树</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">siftUpComparable</span><span class="params">(<span class="type">int</span> k, T x, Object[] array)</span> &#123;</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> T&gt; key = (Comparable&lt;? <span class="built_in">super</span> T&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 二叉堆中 a[k] 节点的父节点位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> array[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        array[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    array[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们用图来示意一下，我们接下来要将 <strong>11</strong> 插入到队列中，看看 siftUp 是怎么操作的。</p>
<p><img src="https://assets.javadoop.com/blogimages/java-concurrent-queue/priority-blocking-queue-2.png" alt="priority-blocking-queue-2"></p>
<p>我们再看看 take 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 独占锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    E result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// dequeue 出队</span></span><br><span class="line">        <span class="keyword">while</span> ( (result = dequeue()) == <span class="literal">null</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Object[] array = queue;</span><br><span class="line">        <span class="comment">// 队头，用于返回</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> (E) array[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 队尾元素先取出</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) array[n];</span><br><span class="line">        <span class="comment">// 队尾置空</span></span><br><span class="line">        array[n] = <span class="literal">null</span>;</span><br><span class="line">        Comparator&lt;? <span class="built_in">super</span> E&gt; cmp = comparator;</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="literal">null</span>)</span><br><span class="line">            siftDownComparable(<span class="number">0</span>, x, array, n);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownUsingComparator(<span class="number">0</span>, x, array, n, cmp);</span><br><span class="line">        size = n;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dequeue 方法返回队头，并调整二叉堆的树，调用这个方法必须先获取独占锁。</p>
<p>废话不多说，出队是非常简单的，因为队头就是最小的元素，对应的是数组的第一个元素。难点是队头出队后，需要调整树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">siftDownComparable</span><span class="params">(<span class="type">int</span> k, T x, Object[] array,</span></span><br><span class="line"><span class="params">                                           <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> T&gt; key = (Comparable&lt;? <span class="built_in">super</span> T&gt;)x;</span><br><span class="line">        <span class="comment">// 这里得到的 half 肯定是非叶节点</span></span><br><span class="line">        <span class="comment">// a[n] 是最后一个元素，其父节点是 a[(n-1)/2]。所以 n &gt;&gt;&gt; 1 代表的节点肯定不是叶子节点</span></span><br><span class="line">        <span class="comment">// 下面，我们结合图来一行行分析，这样比较直观简单</span></span><br><span class="line">        <span class="comment">// 此时 k 为 0, x 为 17，n 为 9</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> n &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 得到 half = 4</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="comment">// 先取左子节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 得到 child = 1</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> array[child];  <span class="comment">// c = 12</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;  <span class="comment">// right = 2</span></span><br><span class="line">            <span class="comment">// 如果右子节点存在，而且比左子节点小</span></span><br><span class="line">            <span class="comment">// 此时 array[right] = 20，所以条件不满足</span></span><br><span class="line">            <span class="keyword">if</span> (right &lt; n &amp;&amp;</span><br><span class="line">                ((Comparable&lt;? <span class="built_in">super</span> T&gt;) c).compareTo((T) array[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = array[child = right];</span><br><span class="line">            <span class="comment">// key = 17, c = 12，所以条件不满足</span></span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((T) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 把 12 填充到根节点</span></span><br><span class="line">            array[k] = c;</span><br><span class="line">            <span class="comment">// k 赋值后为 1</span></span><br><span class="line">            k = child;</span><br><span class="line">            <span class="comment">// 一轮过后，我们发现，12 左边的子树和刚刚的差不多，都是缺少根节点，接下来处理就简单了</span></span><br><span class="line">        &#125;</span><br><span class="line">        array[k] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.javadoop.com/blogimages/java-concurrent-queue/priority-blocking-queue-3.png" alt="priority-blocking-queue-3"></p>
<p>记住二叉堆是一棵完全二叉树，那么根节点 10 拿掉后，最后面的元素 17 必须找到合适的地方放置。首先，17 和 10 不能直接交换，那么先将根节点 10 的左右子节点中较小的节点往上滑，即 12 往上滑，然后原来 12 留下了一个空节点，然后再把这个空节点的较小的子节点往上滑，即 13 往上滑，最后，留出了位子，17 补上即可。</p>
<p>我稍微调整下这个树，以便读者能更明白：</p>
<p><img src="https://assets.javadoop.com/blogimages/java-concurrent-queue/priority-blocking-queue-4.png" alt="priority-blocking-queue-4"></p>
<p>好了， PriorityBlockingQueue 我们也说完了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我知道本文过长，相信一字不漏看完的读者肯定是少数。</p>
<p>ArrayBlockingQueue 底层是数组，有界队列，如果我们要使用生产者-消费者模式，这是非常好的选择。</p>
<p>LinkedBlockingQueue 底层是链表，可以当做无界和有界队列来使用，所以大家不要以为它就是无界队列。</p>
<p>SynchronousQueue 本身不带有空间来存储任何元素，使用上可以选择公平模式和非公平模式。</p>
<p>PriorityBlockingQueue 是无界队列，基于数组，数据结构为二叉堆，数组第一个也是树的根节点总是最小值。</p>
<p>（全文完）</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>深入分析 java 8 编程语言规范：Threads and Locks(转自Javadoop)</title>
    <url>/2017/07/05/JDK8-Specification-Threads-And-Locks/</url>
    <content><![CDATA[<blockquote>
<p><strong>2018-02-27</strong></p>
<p>评论区的 <strong>xupeng.zhang</strong> 提出了一个我之前没碰到过的情况，推翻了我之前的一个错误理解，修改了相应的内容。</p>
<p><strong>2017-11-28</strong></p>
<p>更新了 17.1、17.2、17.3，更正一些不合理的描述，修改一些话术，使读者理解起来更容易，这遍更新下来，这三节应该说已经很严谨了，读者如果还有不懂，请在评论区留言。</p>
<p><strong>2017-11-29</strong></p>
<p>更新 17.4 内存模型一节，修改了一些容易引起歧义的描述</p>
<p><strong>2017-12-11</strong></p>
<p>更新 17.5 及其后面的内容，对于 final 的语义介绍还是不够精彩，字分裂和 double、long 值的非原子处理也基本上不需要关心，所以整体来说，吃力不讨好。</p>
</blockquote>
<p>在 java 并发编程中，线程和锁永远是最重要的概念。语言规范虽然是规范描述，但是其中也有非常多的知识和最佳实践是值得学习的，相信这篇文章还是可以给很多读者提供学习参考的。</p>
<p>本文主要是<strong>翻译 + 解释</strong> Oracle《<a href="https://docs.oracle.com/javase/specs/index.html">The Java Language Specification, Java SE 8 Edition</a>》的第17章《<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">Threads and Locks</a>》，原文大概30页pdf，我加入了很多自己的理解，希望能帮大家把规范看懂，并且从中得到很多你一直想要知道但是还不知道的知识。</p>
<p>注意，本文在说 Java 语言规范，不是 JVM 规范，JVM 的实现需要满足语言规范中定义的内容，但是具体的实现细节由各 JVM 厂商自己来决定。所以，语言规范要尽可能严谨全面，但是也不能限制过多，不然会限制 JVM 厂商对很多细节进行性能优化。</p>
<p>我能力有限，虽然已经很用心了，但有些地方我真的不懂，我已经在文中标记出来了。</p>
<p>建议分 3 部分阅读。</p>
<ol>
<li>将 17.1、17.2、17.3 一起阅读，这里关于线程中的 wait、notify、中断有很多的知识；</li>
<li>17.4 的内存模型比较长，重排序和 happens-before 关系是重点；</li>
<li>剩下的 final、字分裂、double和long的非原子问题，这些都是相对独立的 topic。</li>
</ol>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><span id="more"></span>

<div style="text-align: center; font-size: 24px; font-weight: bold">Chapter 17. Threads and Locks</div>

<!-- toc -->


<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 java 中，线程由 Thread 类表示，用户创建线程的<strong>唯一方式</strong>是创建 Thread 类的一个实例，每一个线程都和这样的一个实例关联。在相应的 Thread 实例上调用 start() 方法将启动一个线程。</p>
<p>如果没有正确使用同步，线程表现出来的现象将会是令人疑惑的、违反直觉的。这个章节将描述多线程编程的语义问题，包括一系列的规则，这些规则定义了<strong>在多线程环境中线程对共享内存中值的修改是否对其他线程立即可见</strong>。java编程语言内存模型定义了统一的内存模型用于屏蔽不同的硬件架构，在没有歧义的情况下，下面将用<strong>内存模型</strong>表示这个概念。</p>
<p>这些语义没有规定多线程的程序在 JVM 的实现上应该怎么执行，而是限定了一系列规则，由 JVM 厂商来满足这些规则，即不管 JVM 的执行策略是什么，表现出来的行为必须是可被接受的。</p>
<blockquote>
<p>操作系统有自己的内存模型，C/C++ 这些语言直接使用的就是操作系统的内存模型，而 Java 为了屏蔽各个系统的差异，定义了自己的统一的内存模型。</p>
<p>简单说，Java 开发者不再关心每个 CPU 核心有自己的内存，然后共享主内存。而是把关注点转移到：每个线程都有自己的工作内存，所有线程共享主内存。</p>
</blockquote>
<h3 id="17-1-同步（synchronization）"><a href="#17-1-同步（synchronization）" class="headerlink" title="17.1 同步（synchronization）"></a>17.1 同步（synchronization）</h3><p>Java 提供了多种线程之间通信的机制，其中最基本的就是使用同步 (synchronization)，其使用监视器 (monitor) 来实现。java中的<strong>每个对象都关联了一个监视器</strong>，线程可以对其进行加锁和解锁操作。在同一时间，只有一个线程可以拿到对象上的监视器锁。如果其他线程在锁被占用期间试图去获取锁，那么将会被阻塞直到成功获取到锁。同时，监视器锁可以重入，也就是说如果线程 t 拿到了锁，那么线程 t 可以在解锁之前重复获取锁；每次解锁操作会反转一次加锁产生的效果。</p>
<p>synchronized 有以下两种使用方式：</p>
<ol>
<li><p>synchronized 代码块。synchronized(object) 在对某个对象上执行加锁时，会尝试在该对象的监视器上进行加锁操作，只有成功获取锁之后，线程才会继续往下执行。线程获取到了监视器锁后，将继续执行 synchronized 代码块中的代码，如果代码块执行完成，或者抛出了异常，线程将会自动对该对象上的监视器执行解锁操作。</p>
</li>
<li><p>synchronized 作用于方法，称为同步方法。同步方法被调用时，会自动执行加锁操作，只有加锁成功，方法体才会得到执行。如果被 synchronized 修饰的方法是实例方法，那么<strong>这个实例的监视器</strong>会被锁定。如果是 static 方法，线程会锁住相应的 <strong>Class 对象的监视器</strong>。方法体执行完成或者异常退出后，会自动执行解锁操作。</p>
</li>
</ol>
<p>Java语言规范既不要求阻止死锁的发生，也不要求检测到死锁的发生。如果线程要在多个对象上执行加锁操作，那么就应该使用传统的方法来避免死锁的发生，如果有必要的话，需要创建更高层次的不会产生死锁的加锁原语。（原文：Programs where threads hold (directly or indirectly) locks on multiple objects should use conventional techniques for deadlock avoidance, creating higher-level locking primitives that do not deadlock, if necessary.）</p>
<p>java 还提供了其他的一些同步机制，比如对 volatile 变量的读写、使用 java.util.concurrent 包中的同步工具类等。</p>
<blockquote>
<p><strong>同步</strong>这一节说了 Java 并发编程中最基础的 synchronized 这个关键字，大家一定要理解 synchronize 的锁是什么，它的锁是基于 Java 对象的监视器 monitor，所以任何对象都可以用来做锁。有兴趣的读者可以去了解相关知识，包括偏向锁、轻量级锁、重量级锁等。</p>
<p>小知识点：<strong>对 Class 对象加锁、对对象加锁，它们之间不构成同步</strong>。synchronized 作用于静态方法时是对 <strong>Class 对象</strong>加锁，作用于实例方法时是对实例加锁。</p>
<p>面试中经常会问到一个类中的两个 synchronized static 方法之间是否构成同步？构成同步。</p>
</blockquote>
<h3 id="17-2-等待集合-和-唤醒（Wait-Sets-and-Notification）"><a href="#17-2-等待集合-和-唤醒（Wait-Sets-and-Notification）" class="headerlink" title="17.2 等待集合 和 唤醒（Wait Sets and Notification）"></a>17.2 等待集合 和 唤醒（Wait Sets and Notification）</h3><p>每个 java 对象，都关联了一个监视器，也关联了一个<strong>等待集合</strong>。等待集合是一个线程集合。</p>
<p>当对象被创建出来时，它的等待集合是空的，对于向等待集合中添加或者移除线程的操作都是原子的，以下几个操作可以操纵这个等待集合：Object.wait, Object.notify, Object.notifyAll。</p>
<p>等待集合也可能受到线程的中断状态的影响，也受到线程中处理中断的方法的影响。另外，sleep 方法和 join 方法可以感知到线程的 wait 和 notify。</p>
<blockquote>
<p>这里概括得比较简略，没看懂的读者没关系，继续往下看就是了。</p>
<p>这节要讲Java线程的相关知识，主要包括：</p>
<ul>
<li>Thread 中的 sleep、join、interrupt</li>
<li>继承自 Object 的 wait、notify、notifyAll</li>
<li>还有 Java 的中断，这个概念也很重要</li>
</ul>
</blockquote>
<h4 id="17-2-1-等待-（Wait）"><a href="#17-2-1-等待-（Wait）" class="headerlink" title="17.2.1 等待 （Wait）"></a>17.2.1 等待 （Wait）</h4><p> 等待操作由以下几个方法引发：wait()，wait(long millisecs)，wait(long millisecs, int nanosecs)。在后面两个重载方法中，如果参数为 0，即 wait(0)、wait(0, 0) 和 wait() 是等效的。</p>
<p>如果调用 wait 方法时没有抛出 InterruptedException 异常，则表示正常返回。</p>
<blockquote>
<p>前方高能，请读者保持高度精神集中。</p>
</blockquote>
<p>我们在线程 t 中对对象 m 调用 m.wait() 方法，n 代表加锁编号，同时还没有相匹配的解锁操作，则下面的其中之一会发生：</p>
<ul>
<li><p>如果 n 等于 0（如线程 t 没有持有对象 m 的锁），那么会抛出 IllegalMonitorStateException 异常。</p>
<blockquote>
<p>注意，如果没有获取到监视器锁，wait 方法是会抛异常的，而且注意这个异常是IllegalMonitorStateException 异常。这是重要知识点，要考。</p>
</blockquote>
</li>
<li><p>如果线程 t 调用的是 m.wait(millisecs) 或m.wait(millisecs, nanosecs)，形参 millisecs 不能为负数，nanosecs 取值应为 [0, 999999]，否则会抛出 IllegalArgumentException 异常。</p>
</li>
<li><p>如果线程 t 被中断，此时中断状态为 true，则 wait 方法将抛出 InterruptedException 异常，并将中断状态设置为 false。</p>
<blockquote>
<p>中断，如果读者不了解这个概念，可以参考我在 <a href="/post/AbstractQueuedSynchronizer-2">AQS(二)</a> 中的介绍，这是非常重要的知识。</p>
</blockquote>
</li>
<li><p>否则，下面的操作会顺序发生：</p>
<blockquote>
<p>注意：到这里的时候，wait 参数是正常的，同时 t 没有被中断，并且线程 t 已经拿到了 m 的监视器锁。</p>
</blockquote>
<p>1.线程 t 会加入到对象 m 的<strong>等待集合</strong>中，执行 <strong>加锁编号 n 对应的解锁操作</strong></p>
<blockquote>
<p>这里也非常关键，前面说了，wait 方法的调用必须是线程获取到了对象的监视器锁，而到这里会进行解锁操作。切记切记。。。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">thread1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object) &#123; <span class="comment">// 获取监视器锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            object.wait(); <span class="comment">// 这里会解锁，这里会解锁，这里会解锁</span></span><br><span class="line">            <span class="comment">// 顺便提一下，只是解了object上的监视器锁，如果这个线程还持有其他对象的监视器锁，这个时候是不会释放的。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// do somethings</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>2.线程 t 不会执行任何进一步的指令，直到它从 m 的等待集合中移出（也就是等待唤醒）。在发生以下操作的时候，线程 t 会从 m 的等待集合中移出，然后在之后的某个时间点恢复，并继续执行之后的指令。</p>
<blockquote>
<p>并不是说线程移出等待队列就马上往下执行，这个线程还需要重新获取锁才行，这里也很关键，请往后看17.2.4中我写的两个简单的例子。</p>
</blockquote>
<ul>
<li><p>在 m上执行了 notify 操作，而且线程 t 被选中从等待集合中移除。</p>
</li>
<li><p>在 m 上执行了 notifyAll 操作，那么线程 t 会从等待集合中移除。</p>
</li>
<li><p>线程 t 发生了 interrupt 操作。</p>
</li>
<li><p>如果线程 t 是调用 wait(millisecs) 或者 wait(millisecs, nanosecs) 方法进入等待集合的，那么过了millisecs 毫秒或者 (millisecs*1000000+nanosecs) 纳秒后，线程 t 也会从等待集合中移出。</p>
</li>
<li><p>JVM 的“假唤醒”，虽然这是不鼓励的，但是这种操作是被允许的，这样 JVM 能实现将线程从等待集合中移出，而不必等待具体的移出指令。</p>
<p>注意，良好的 Java 编码习惯是，只在循环中使用 wait 方法，这个循环等待某些条件来退出循环。</p>
<blockquote>
<p>个人理解wait方法是这么用的：</p>
</blockquote>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">    <span class="keyword">while</span>(!canExit) &#123;</span><br><span class="line">      m.wait(<span class="number">10</span>); <span class="comment">// 等待10ms; 当然中断也是常用的</span></span><br><span class="line">      canExit = something();  <span class="comment">// 判断是否可以退出循环</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 个知识点：</span></span><br><span class="line"><span class="comment">// 1. 必须先获取到对象上的监视器锁</span></span><br><span class="line"><span class="comment">// 2. wait 有可能被假唤醒</span></span><br></pre></td></tr></table></figure>

<p>每个线程在一系列 <strong>可能导致它从等待集合中移出的事件</strong> 中必须决定一个顺序。这个顺序不必要和其他顺序一致，但是线程必须表现为它是按照那个顺序发生的。</p>
<p>例如，线程 t 现在在 m 的等待集合中，不管是线程 t 中断还是 m 的 notify 方法被调用，这些操作事件肯定存在一个顺序。如果线程 t 的中断先发生，那么 t 会因为 InterruptedException 异常而从 wait 方法中返回，同时 m 的等待集合中的其他线程（如果有的话）会收到这个通知。如果 m 的 notify 先发生，那么 t 会正常从 wait 方法返回，且不会改变中断状态。</p>
<blockquote>
<p>我们考虑这个场景：</p>
<p>线程 1 和线程 2 此时都 wait 了，线程 3 调用了 ：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">	thread1.interrupt(); <span class="comment">//1</span></span><br><span class="line">	object.notify();  <span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本来我以为上面的情况 线程1 一定是抛出 InterruptedException，线程2 是正常返回的。</p>
<p>感谢评论留言的 <strong>xupeng.zhang</strong>，我的这个想法是错误的，完全有可能线程1正常返回(即使其中断状态是true)，线程2 一直 wait。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>3.线程 t 执行编号为 n 的加锁操作</p>
<blockquote>
<p>回去看 2  说了什么，线程刚刚从等待集合中移出，然后这里需要重新获取监视器锁才能继续往下执行。</p>
</blockquote>
<p>4.如果线程 t 在 2 的时候由于中断而从 m 的等待集合中移出，那么它的中断状态会重置为 false，同时 wait 方法会抛出 InterruptedException 异常。</p>
<blockquote>
<p>这一节主要在讲线程进出等待集合的各种情况，同时，最好要知道中断是怎么用的，中断的状态重置发生于什么时候。</p>
<p>这里的 1，2，3，4 的发生顺序非常关键，大家可以仔细再看看是不是完全理解了，之后的几个小节还会更具体地阐述这个，参考代码请看 17.2.4 小节我写的简单的例子。</p>
</blockquote>
<h4 id="17-2-2-通知（Notification）"><a href="#17-2-2-通知（Notification）" class="headerlink" title="17.2.2 通知（Notification）"></a>17.2.2 通知（Notification）</h4><p>通知操作发生于调用 notify 和 notifyAll 方法。</p>
<p>我们在线程 t 中对对象 m 调用 m.notify() 或 m.notifyAll() 方法，n 代表加锁编号，同时对应的解锁操作没有执行，则下面的其中之一会发生：</p>
<ul>
<li><p>如果 n 等于 0，抛出 IllegalMonitorStateException 异常，因为线程 t 还没有获取到对象 m 上的锁。</p>
<blockquote>
<p>这一点很关键，只有获取到了对象上的监视器锁的线程才可以正常调用 notify，前面我们也说过，调用 wait 方法的时候也要先获取锁</p>
</blockquote>
</li>
<li><p>如果 n 大于 0，而且这是一个 notify 操作，如果 m 的等待集合不为空，那么等待集合中的线程 u 被选中从等待集合中移出。</p>
<p>对于哪个线程会被选中而被移出，虚拟机没有提供任何保证，从等待集合中将线程 u 移出，可以让线程 u 得以恢复。注意，恢复之后的线程 u 如果对 m 进行加锁操作将不会成功，直到线程 t 完全释放锁之后。</p>
<blockquote>
<p>因为线程 t 这个时候还持有 m 的锁。这个知识点在 17.2.4 节我还会重点说。这里记住，被 notify 的线程在唤醒后是需要重新获取监视器锁的。</p>
</blockquote>
</li>
<li><p>如果 n 大于 0，而且这是一个 notifyAll 操作，那么等待集合中的所有线程都将从等待集合中移出，然后恢复。</p>
<p>注意，这些线程恢复后，只有一个线程可以锁住监视器。</p>
</li>
</ul>
<blockquote>
<p>本小节结束，通知操作相对来说还是很简单的吧。</p>
</blockquote>
<h4 id="17-2-3-中断（Interruptions）"><a href="#17-2-3-中断（Interruptions）" class="headerlink" title="17.2.3 中断（Interruptions）"></a>17.2.3 中断（Interruptions）</h4><p>中断发生于 Thread.interrupt 方法的调用。</p>
<p>令线程 t 调用线程 u 上的方法 u.interrupt()，其中 t 和 u 可以是同一个线程，这个操作会将 u 的中断状态设置为 true。</p>
<blockquote>
<p>顺便说说中断状态吧，初学者肯定以为 thread.interrupt() 方法是用来暂停线程的，主要是和它对应中文翻译的“中断”有关。中断在并发中是常用的手段，请大家一定好好掌握。可以将中断理解为线程的状态，它的特殊之处在于设置了中断状态为 true 后，这几个方法会感知到：</p>
<ol>
<li> wait(), wait(long), wait(long, int), join(), join(long), join(long, int), sleep(long), sleep(long, int)</li>
</ol>
<p>   这些方法都有一个共同之处，方法签名上都有<code>throws InterruptedException</code>，这个就是用来响应中断状态修改的。</p>
<ol start="2">
<li><p>如果线程阻塞在 InterruptibleChannel 类的 IO 操作中，那么这个 channel 会被关闭。</p>
</li>
<li><p>如果线程阻塞在一个 Selector 中，那么 select 方法会立即返回。</p>
</li>
</ol>
<p>如果线程阻塞在以上3种情况中，那么当线程感知到中断状态后（此线程的 interrupt() 方法被调用），会将中断状态<strong>重新设置为 false</strong>，然后执行相应的操作（通常就是跳到 catch 异常处）。</p>
<p>如果不是以上3种情况，那么，线程的 interrupt() 方法被调用，会将线程的中断状态设置为 true。</p>
<p>当然，除了这几个方法，我知道的是 LockSupport 中的 park 方法也能自动感知到线程被中断，当然，它不会重置中断状态为 false。我们说了，只有上面的几种情况会在感知到中断后先重置中断状态为 false，然后再继续执行。</p>
</blockquote>
<p>另外，如果有一个对象 m，而且线程 u 此时在 m 的等待集合中，那么 u 将会从 m 的等待集合中移出。这会让 u 从 wait 操作中恢复过来，u 此时需要获取 m 的监视器锁，获取完锁以后，发现线程 u 处于中断状态，此时会抛出 InterruptedException 异常。</p>
<blockquote>
<p>这里的流程：t 设置 u 的中断状态 =&gt; u 线程恢复 =&gt; u 获取 m 的监视器锁 =&gt; 获取锁以后，抛出 InterruptedException 异常。</p>
<p>这个流程在前面 <strong>wait</strong> 的小节已经讲过了，这也是很多人都不了解的知识点。如果还不懂，可以看下一小节的结束，我的两个简单的例子。</p>
<p>一个小细节：u 被中断，wait 方法返回，并不会立即抛出 InterruptedException 异常，而是在重新获取监视器锁之后才会抛出异常。</p>
</blockquote>
<p>实例方法 thread.isInterrupted() 可以知道线程的中断状态。</p>
<p>调用静态方法 Thread.interrupted() 可以返回当前线程的中断状态，同时将中断状态设置为false。</p>
<blockquote>
<p>所以说，如果是这个方法调用两次，那么第二次一定会返回 false，因为第一次会重置状态。当然了，前提是两次调用的中间没有发生设置线程中断状态的其他语句。</p>
</blockquote>
<h4 id="17-2-4-等待、通知和中断-的交互（Interactions-of-Waits-Notification-and-Interruption）"><a href="#17-2-4-等待、通知和中断-的交互（Interactions-of-Waits-Notification-and-Interruption）" class="headerlink" title="17.2.4 等待、通知和中断 的交互（Interactions of Waits, Notification, and Interruption）"></a>17.2.4 等待、通知和中断 的交互（Interactions of Waits, Notification, and Interruption）</h4><p>以上的一系列规范能让我们确定 在等待、通知、中断的交互中 有关的几个属性。</p>
<p>如果一个线程在等待期间，<strong>同时发生了通知和中断</strong>，它将发生：</p>
<ul>
<li><p>从 wait 方法中正常返回，同时不改变中断状态（也就是说，调用 Thread.interrupted 方法将会返回 true）</p>
</li>
<li><p>由于抛出了 InterruptedException 异常而从 wait 方法中返回，中断状态设置为 false</p>
</li>
</ul>
<p>线程可能没有重置它的中断状态，同时从 wait 方法中正常返回，即第一种情况。</p>
<blockquote>
<p>也就是说，线程是从 notify 被唤醒的，由于发生了中断，所以中断状态为 true</p>
</blockquote>
<p>同样的，通知也不能由于中断而丢失。</p>
<blockquote>
<p>这个要说的是，线程其实是从中断唤醒的，那么线程醒过来，同时中断状态会被重置为 false。</p>
</blockquote>
<p>假设 m 的等待集合为 线程集合 s，并且在另一个线程中调用了 m.notify(), 那么将发生：</p>
<ul>
<li>至少有集合 s 中的一个线程正常从 wait 方法返回，或者</li>
<li>集合 s 中的所有线程由抛出 InterruptedException 异常而返回。</li>
</ul>
<blockquote>
<p>考虑是否有这个场景：x 被设置了中断状态，notify 选中了集合中的线程 x，那么这次 notify 将唤醒线程 x，其他线程（我们假设还有其他线程在等待）不会有变化。</p>
<p>答案：存在这种场景。因为这种场景是满足上述条件的，而且此时 x 的中断状态是 true。</p>
</blockquote>
<p>注意，如果一个线程同时被中断和通知唤醒，同时这个线程通过抛出 InterruptedException 异常从 wait 中返回，那么等待集合中的某个其他线程一定会被通知。</p>
<blockquote>
<p>下面我们通过 3 个例子简单分析下 <strong>wait、notify、中断</strong> 它们的组合使用。</p>
<p>第一个例子展示了 wait 和 notify 操作过程中的监视器锁的 持有、释放 的问题。考虑以下操作：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotify</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1 获取到监视器锁&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        object.wait();</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1 恢复啦。我为什么这么久才恢复，因为notify方法虽然早就发生了，可是我还要获取锁才能继续执行。&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1 wait方法抛出了InterruptedException异常&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2 拿到了监视器锁。为什么呢，因为线程1 在 wait 方法的时候会自动释放锁&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2 执行 notify 操作&quot;</span>);</span><br><span class="line">                    object.notify();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2 执行完了 notify，先休息3秒再说。&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程2 休息完啦。注意了，调sleep方法和wait方法不一样，不会释放监视器锁&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2 休息够了，结束操作&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line">线程<span class="number">1</span> 获取到监视器锁</span><br><span class="line">线程<span class="number">2</span> 拿到了监视器锁。为什么呢，因为线程<span class="number">1</span> 在 wait 方法的时候会自动释放锁</span><br><span class="line">线程<span class="number">2</span> 执行 notify 操作</span><br><span class="line">线程<span class="number">2</span> 执行完了 notify，先休息<span class="number">3</span>秒再说。</span><br><span class="line">线程<span class="number">2</span> 休息完啦。注意了，调sleep方法和wait方法不一样，不会释放监视器锁</span><br><span class="line">线程<span class="number">2</span> 休息够了，结束操作</span><br><span class="line">线程<span class="number">1</span> 恢复啦。我为什么这么久才恢复，因为notify方法虽然早就发生了，可是我还要获取锁才能继续执行。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的例子展示了，wait 方法返回后，需要重新获取监视器锁，才可以继续往下执行。</p>
<p>同理，我们稍微修改下以上的程序，看下中断和 wait 之间的交互：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotify</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1 获取到监视器锁&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        object.wait();</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1 恢复啦。我为什么这么久才恢复，因为notify方法虽然早就发生了，可是我还要获取锁才能继续执行。&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1 wait方法抛出了InterruptedException异常，即使是异常，我也是要获取到监视器锁了才会抛出&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2 拿到了监视器锁。为什么呢，因为线程1 在 wait 方法的时候会自动释放锁&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2 设置线程1 中断&quot;</span>);</span><br><span class="line">                    thread1.interrupt();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2 执行完了 中断，先休息3秒再说。&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程2 休息完啦。注意了，调sleep方法和wait方法不一样，不会释放监视器锁&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2 休息够了，结束操作&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">线程<span class="number">1</span> 获取到监视器锁</span><br><span class="line">线程<span class="number">2</span> 拿到了监视器锁。为什么呢，因为线程<span class="number">1</span> 在 wait 方法的时候会自动释放锁</span><br><span class="line">线程<span class="number">2</span> 设置线程<span class="number">1</span> 中断</span><br><span class="line">线程<span class="number">2</span> 执行完了 中断，先休息<span class="number">3</span>秒再说。</span><br><span class="line">线程<span class="number">2</span> 休息完啦。注意了，调sleep方法和wait方法不一样，不会释放监视器锁</span><br><span class="line">线程<span class="number">2</span> 休息够了，结束操作</span><br><span class="line">线程<span class="number">1</span> wait方法抛出了InterruptedException异常，即使是异常，我也是要获取到监视器锁了才会抛出</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的这个例子也很清楚，如果线程调用 wait 方法，当此线程被中断的时候，wait 方法会返回，然后重新获取监视器锁，然后抛出 InterruptedException 异常。</p>
<p>我们再来考虑下，之前说的 notify 和中断：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javadoop.learning;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hongjie on 2017/7/7.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotify</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">WaitNotify</span> <span class="variable">waitNotify</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitNotify</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1 获取到监视器锁&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        object.wait();</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1 正常恢复啦。&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1 wait方法抛出了InterruptedException异常&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2 获取到监视器锁&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        object.wait();</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程2 正常恢复啦。&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程2 wait方法抛出了InterruptedException异常&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 这里让 thread1 和 thread2 先起来，然后再起后面的 thread3</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程3 拿到了监视器锁。&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程3 设置线程1中断&quot;</span>);</span><br><span class="line">                    thread1.interrupt(); <span class="comment">// 1</span></span><br><span class="line">                    waitNotify.a = <span class="number">1</span>; <span class="comment">// 这行是为了禁止上下的两行中断和notify代码重排序</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程3 调用notify&quot;</span>);</span><br><span class="line">                    object.notify(); <span class="comment">//2</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程3 调用完notify后，休息一会&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程3 休息够了，结束同步代码块&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程3&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最常见的output:</span></span><br><span class="line">线程<span class="number">1</span> 获取到监视器锁</span><br><span class="line">线程<span class="number">2</span> 获取到监视器锁</span><br><span class="line">线程<span class="number">3</span> 拿到了监视器锁。</span><br><span class="line">线程<span class="number">3</span> 设置线程<span class="number">1</span>中断</span><br><span class="line">线程<span class="number">3</span> 调用notify</span><br><span class="line">线程<span class="number">3</span> 调用完notify后，休息一会</span><br><span class="line">线程<span class="number">3</span> 休息够了，结束同步代码块</span><br><span class="line">线程<span class="number">2</span> 正常恢复啦。</span><br><span class="line">线程<span class="number">1</span> wait方法抛出了InterruptedException异常</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述输出不是绝对的，再次感谢 <strong>xupeng.zhang</strong>。</p>
<p>有可能发生 线程1 是正常恢复的，虽然发生了中断，它的中断状态也确实是 true，但是它没有抛出 InterruptedException，而是正常返回。此时，thread2 将得不到唤醒，一直 wait。</p>
</blockquote>
<h3 id="17-3-休眠和礼让（Sleep-and-Yield）"><a href="#17-3-休眠和礼让（Sleep-and-Yield）" class="headerlink" title="17.3. 休眠和礼让（Sleep and Yield）"></a>17.3. 休眠和礼让（Sleep and Yield）</h3><p>Thread.sleep(millisecs) 使当前正在执行的线程休眠指定的一段时间（暂时停止执行任何指令），时间取决于参数值，精度受制于系统的定时器。<strong>休眠期间，线程不会释放任何的监视器锁</strong>。线程的恢复取决于定时器和处理器的可用性，即有可用的处理器来唤醒线程。</p>
<p>需要注意的是，Thread.sleep 和 Thread.yield 都不具有同步的语义。在 Thread.sleep 和 Thread.yield 方法调用之前，不要求虚拟机将寄存器中的缓存刷出到共享内存中，同时也不要求虚拟机在这两个方法调用之后，重新从共享内存中读取数据到缓存。</p>
<p><em>例如，我们有如下代码块，this.done 定义为一个 non-volatile 的属性，初始值为 false。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">this</span>.done)</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p><em>编译器可以只读取一次 this.done 到缓存中，然后一直使用缓存中的值，也就是说，这个循环可能永远不会结束，即使是有其他线程将 this.done 的值修改为 true。</em></p>
<blockquote>
<p>yield 是告诉操作系统的调度器：我的cpu可以先让给其他线程。注意，调度器可以不理会这个信息。</p>
<p>这个方法太鸡肋，几乎没用。</p>
</blockquote>
<h3 id="17-4-内存模型（Memory-Model）"><a href="#17-4-内存模型（Memory-Model）" class="headerlink" title="17.4 内存模型（Memory Model）"></a>17.4 内存模型（Memory Model）</h3><blockquote>
<p>内存模型这一节比较长，请耐心阅读</p>
</blockquote>
<p>内存模型描述的是程序在 JVM 的执行过程中对数据的读写是否是按照程序的规则正确执行的。Java 内存模型定义了一系列规则，这些规则定义了对共享内存的写操作对于读操作的可见性。</p>
<blockquote>
<p>简单地说，定义内存模型，主要就是为了规范多线程程序中修改或者访问同一个值的时候的行为。对于那些本身就是线程安全的问题，这里不做讨论。</p>
</blockquote>
<p>内存模型描述了程序执行时的可能的表现行为。只要执行的结果是满足 java 内存模型的所有规则，那么虚拟机对于具体的实现可以自由发挥。</p>
<blockquote>
<p>从侧面说，不管虚拟机的实现是怎么样的，多线程程序的执行结果都应该是<strong>可预测的</strong>。</p>
</blockquote>
<p><em>虚拟机实现者可以自由地执行大量的代码转换，包括重排序操作和删除一些不必要的同步。</em></p>
<blockquote>
<p>这里我画了一条线，从这条线到下一条线之间是两个重排序的例子，如果你没接触过，可以看一下，如果你已经熟悉了或者在其他地方看过了，请直接往下滑。</p>
</blockquote>
<hr>
<p><strong>示例 17.4-1 不正确的同步可能导致奇怪的结果</strong></p>
<p>java语言允许 compilers 和 CPU 对执行指令进行重排序，导致我们会经常看到似是而非的现象。</p>
<blockquote>
<p>这里没有翻译 compiler 为编译器，因为它不仅仅代表编译器，后续它会代表所有会导致指令重排序的机制。</p>
</blockquote>
<p>如表 17.4-A 中所示，A 和 B 是共享属性，r1 和 r2 是局部变量。初始时，令 A == B == 0。</p>
<p><strong>表17.4-A. 重排序导致奇怪的结果 - 原始代码</strong></p>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody><tr>
<td>1: <code>r2 = A;</code></td>
<td>3: <code>r1 = B;</code></td>
</tr>
<tr>
<td>2: <code>B = 1;</code></td>
<td>4: <code>A = 2;</code></td>
</tr>
</tbody></table>
<p>按照我们的直觉来说，r2 == 2 同时 r1 == 1 应该是不可能的。直观地说，指令 1 和 3 应该是最先执行的。如果指令 1 最先执行，那么它应该不会看到指令 4 对 A 的写入操作。如果指令 3 最先执行，那么它应该不会看到执行 2 对 B 的写入操作。</p>
<p>如果真的表现出了 r2==2 和 r1==1，那么我们应该知道，指令 4 先于指令 1 执行了。</p>
<p>如果在执行过程出表现出这种行为（ r2==2 和r1==1），那么我们可以推断出以下指令依次执行：指令 4 =&gt; 指令 1=&gt; 指令 2 =&gt; 指令 3。看上去，这种顺序是荒谬的。</p>
<p>但是，Java 是允许 compilers 对指令进行重排序的，只要保证在单线程的情况下，能保证程序是按照我们想要的结果进行执行，即 compilers 可以对<strong>单线程内不产生数据依赖的语句之间</strong>进行重排序。如果指令 1 和指令 2 发生了重排序，如按照表17.4-B 所示的顺序进行执行，那么我们就很容易看到，r2==2 和 r1==1 是可能发生的。</p>
<p><strong>表 17.4-B. 重排序导致奇怪的结果 - 允许的编译器转换</strong></p>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody><tr>
<td><code>B = 1;</code></td>
<td><code>r1 = B;</code></td>
</tr>
<tr>
<td><code>r2 = A;</code></td>
<td><code>A = 2;</code></td>
</tr>
</tbody></table>
<blockquote>
<p>B = 1;  <strong>=&gt;</strong>  r1 = B;  <strong>=&gt;</strong>  A = 2;  <strong>=&gt;</strong>  r2 = A;</p>
</blockquote>
<p>对于很多程序员来说，这个结果看上去是 broken 的，但是这段代码是没有正确的同步导致的：</p>
<ul>
<li>其中有一个线程执行了写操作</li>
<li>另一个线程对同一个属性执行了读操作</li>
<li>同时，读操作和写操作没有使用同步来确定它们之间的执行顺序</li>
</ul>
<blockquote>
<p>简单地说，之后要讲的一大堆东西主要就是为了确定共享内存读写的执行顺序，不正确或者说非法的代码就是因为读写同一内存地址没有使用同步（这里不仅仅只是说synchronized），从而导致执行的结果具有不确定性。</p>
</blockquote>
<p>这个是**数据竞争(data race)**的一个例子。当代码包含数据竞争时，经常会发生违反我们直觉的结果。</p>
<p>有几个机制会导致表 17.4-B 中的指令重排序。java 的 JIT 编译器实现可能会重排序代码，或者处理器也会做重排序操作。此外，java 虚拟机实现中的内存层次结构也会使代码像重排序一样。在本章中，我们将所有这些会导致代码重排序的东西统称为 compiler。</p>
<blockquote>
<p>所以，后续我们不要再简单地将 compiler 翻译为编译器，不要狭隘地理解为 Java 编译器。而是代表了所有可能会<strong>制造</strong>重排序的机制，包括 JVM 优化、CPU 优化等。</p>
</blockquote>
<p>另一个可能产生奇怪的结果的示例如表 17.4-C，初始时 p == q 同时 p.x == 0。这个代码也是没有正确使用同步的；在这些写入共享内存的写操作中，没有进行强制的先后排序。</p>
<p><strong>Table 17.4-C</strong></p>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody><tr>
<td><code>r1 = p;</code></td>
<td><code>r6 = p;</code></td>
</tr>
<tr>
<td><code>r2 = r1.x;</code></td>
<td><code>r6.x = 3;</code></td>
</tr>
<tr>
<td><code>r3 = q;</code></td>
<td></td>
</tr>
<tr>
<td><code>r4 = r3.x;</code></td>
<td></td>
</tr>
<tr>
<td><code>r5 = r1.x;</code></td>
<td></td>
</tr>
</tbody></table>
<p>一个简单的编译器优化操作是会复用 r2 的结果给 r5，因为它们都是读取 r1.x，而且在单线程语义中，r2 到 r5之间没有其他的相关的写入操作，这种情况如表 17.4-D 所示。</p>
<p><strong>Table 17.4-D</strong></p>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody><tr>
<td><code>r1 = p;</code></td>
<td><code>r6 = p;</code></td>
</tr>
<tr>
<td><code>r2 = r1.x;</code></td>
<td><code>r6.x = 3;</code></td>
</tr>
<tr>
<td><code>r3 = q;</code></td>
<td></td>
</tr>
<tr>
<td><code>r4 = r3.x;</code></td>
<td></td>
</tr>
<tr>
<td><span style="color: red">r5 = r2;</span></td>
<td></td>
</tr>
</tbody></table>
<p>现在，我们来考虑一种情况，在线程1第一次读取 r1.x 和 r3.x 之间，线程 2 执行 r6=p; r6.x=3; 编译器进行了 r5复用 r2 结果的优化操作，那么 r2==r5==0，r4 == 3，从程序员的角度来看，p.x 的值由 0 变为 3，然后又变为 0。</p>
<blockquote>
<p>我简单整理了一下：</p>
</blockquote>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>r1 = p;</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>r2 = r1.x;</code></td>
<td></td>
<td>r2 == 0</td>
</tr>
<tr>
<td></td>
<td><code>r6 = p;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>r6.x = 3;</code></td>
<td></td>
</tr>
<tr>
<td><code>r3 = q;</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>r4 = r3.x;</code></td>
<td></td>
<td>r4 == 3</td>
</tr>
<tr>
<td><code>r5 = r2;</code></td>
<td></td>
<td>r5 == r2 == 0</td>
</tr>
</tbody></table>
<hr>
<blockquote>
<p>例子结束，回到正题</p>
</blockquote>
<p>Java 内存模型定义了在程序的每一步，哪些值是内存可见的。对于隔离的每个线程来说，其操作是由我们线程中的语义来决定的，但是线程中读取到的值是由内存模型来控制的。当我们提到这点时，我们说程序遵守<code>线程内语义</code>，线程内语义说的是单线程内的语义，它允许我们基于线程内读操作看到的值完全预测线程的行为。如果我们要确定线程 t 中的操作是否是合法的，我们只要评估当线程 t 在单线程环境中运行时是否是合法的就可以，该规范的其余部分也在定义这个问题。</p>
<blockquote>
<p>这段话不太好理解，首先记住“线程内语义”这个概念，之后还会用到。我对这段话的理解是，在单线程中，我们是可以通过一行一行看代码来预测执行结果的，只不过，代码中使用到的读取内存的值我们是不能确定的，这取决于在内存模型这个大框架下，我们的程序会读到的值。也许是最新的值，也许是过时的值。</p>
</blockquote>
<p>此节描述除了 final 关键字外的<code>java内存模型</code>的规范，final将在之后的17.5节介绍。</p>
<p><em>这里描述的内存模型并不是基于  Java 编程语言的面向对象。为了简洁起见，我们经常展示没有类或方法定义的代码片段。 大多数示例包含两个或多个线程，其中包含局部变量，共享全局变量或对象的实例字段的语句。 我们通常使用诸如 r1 或 r2 之类的变量名来表示方法或线程本地的变量。 其他线程无法访问此类变量。</em></p>
<h4 id="17-4-1-共享变量（Shared-Variables）"><a href="#17-4-1-共享变量（Shared-Variables）" class="headerlink" title="17.4.1. 共享变量（Shared Variables）"></a>17.4.1. 共享变量（Shared Variables）</h4><p>所有线程都可以访问到的内存称为<code>共享内存</code>或<code>堆内存</code>。</p>
<p>所有的实例属性，静态属性，还有数组的元素都存储在堆内存中。在本章中，我们用术语<code>变量</code>来表示这些元素。</p>
<p>局部变量、方法参数、异常对象，它们不会在线程间共享，也不会受到内存模型定义的任何影响。</p>
<p>两个线程对同一个变量同时进行<code>读-写操作</code>或<code>写-写操作</code>，我们称之为“冲突”。</p>
<blockquote>
<p>好，这一节都是废话，愉快地进入到下一节</p>
</blockquote>
<h4 id="17-4-2-操作（Actions）"><a href="#17-4-2-操作（Actions）" class="headerlink" title="17.4.2. 操作（Actions）"></a>17.4.2. 操作（Actions）</h4><blockquote>
<p>这一节主要是讲解理论，主要就是严谨地定义<strong>操作</strong>。</p>
</blockquote>
<p><code>线程间操作</code>是指由一个线程执行的动作，可以被另一个线程检测到或直接影响到。以下是几种可能发生的<code>线程间操作</code>：</p>
<ul>
<li><p>读 （普通变量，非 volatile）。读一个变量。</p>
</li>
<li><p>写 （普通变量，非 volatile）。写一个变量。</p>
</li>
<li><p>同步操作，如下：</p>
<ul>
<li><p>volatile 读。读一个 volatile 变量</p>
</li>
<li><p>volatile 写。写入一个 volatile 变量</p>
</li>
<li><p>加锁。对一个对象的监视器加锁。</p>
</li>
<li><p>解锁。解除对某个对象的监视器锁。</p>
</li>
<li><p>线程的第一个和最后一个操作。</p>
</li>
<li><p>开启线程操作，或检测一个线程是否已经结束。</p>
</li>
</ul>
</li>
<li><p><code>外部操作</code>。一个外部操作指的是可能被观察到的在外部执行的操作，同时它的执行结果受外部环境控制。</p>
<blockquote>
<p>简单说，外部操作的外部指的是在 JVM 之外，如 native 操作。</p>
</blockquote>
</li>
<li><p><code>线程分歧操作(§17.4.9)</code>。此操作只由处于无限循环的线程执行，在该循环中不执行任何内存操作、同步操作、或外部操作。如果一个线程执行了分歧操作，那么其后将跟着无数的线程分歧操作。</p>
<p><em>分歧操作的引入是为了用来说明，线程可能会导致其他所有线程停顿而不能继续执行。</em></p>
</li>
</ul>
<p>此规范仅关心线程间操作，我们不关心线程内部的操作（比如将两个局部变量的值相加存到第三个局部变量中）。如前文所说，所有的线程都需要遵守线程内语义。对于线程间操作，我们经常会简单地称为<strong>操作</strong>。</p>
<p>我们用元祖&lt; *t*, *k*, *v*, *u* &gt;来描述一个操作：</p>
<ul>
<li><p><strong>t</strong> - 执行操作的线程</p>
</li>
<li><p><strong>k</strong> - 操作的类型。</p>
</li>
<li><p><strong>v</strong> - 操作涉及的变量或监视器</p>
<p>对于加锁操作，v 是被锁住的监视器；对于解锁操作，v 是被解锁的监视器。</p>
<p>如果是一个读操作（ volatile 读或非 volatile 读），v 是读操作对应的变量</p>
<p>如果是一个写操作( volatile 写或非 volatile 写)，v 是写操作对应的变量</p>
</li>
<li><p><strong>u</strong> - 唯一的标识符标识此操作</p>
</li>
</ul>
<p>外部动作元组还包含一个附加组件，其中包含由执行操作的线程感知的外部操作的结果。 这可能是关于操作的成败的信息，以及操作中所读的任何值。</p>
<p>外部操作的参数（如哪些字节写入哪个 socket）不是外部操作元祖的一部分。这些参数是通过线程中的其他操作进行设置的，并可以通过检查线程内语义进行确定。它们在内存模型中没有被明确讨论。</p>
<p>在非终结执行中，不是所有的外部操作都是可观察的。17.4.9小节讨论非终结执行和可观察操作。</p>
<blockquote>
<p>大家看完这节最懵逼的应该是<code>外部操作</code>和<code>线程分歧操作</code>，我简单解释下。</p>
<p>外部操作大家可以理解为 Java 调用了一个 native 的方法，Java 可以得到这个 native 方法的返回值，但是对于具体的执行其实不感知的，意味着 Java 其实不能对这种语句进行重排序，因为 Java 无法知道方法体会执行哪些指令。</p>
<p>引用 stackoverflow 中的一个例子：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// method()方法中jni()是外部操作，不会和 &quot;foo = 42;&quot; 这条语句进行重排序。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Externalization</span> &#123; </span><br><span class="line">  <span class="type">int</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123; </span><br><span class="line">    jni(); <span class="comment">// 外部操作</span></span><br><span class="line">    foo = <span class="number">42</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">jni</span><span class="params">()</span>; <span class="comment">/* &#123; </span></span><br><span class="line"><span class="comment">    assert foo == 0; //我们假设外部操作执行的是这个。</span></span><br><span class="line"><span class="comment">  &#125; */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上面这个例子中，显然，<code>jni()</code> 与 <code>foo = 42</code> 之间不能进行重排序。</p>
<p>再来个线程分歧操作的例子：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程分歧操作阻止了重排序，所以 &quot;foo = 42;&quot; 这条语句不会先执行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadDivergence</span> &#123; </span><br><span class="line">  <span class="type">int</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">thread1</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;&#125; <span class="comment">// 线程分歧操作</span></span><br><span class="line">    foo = <span class="number">42</span>; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">thread2</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">assert</span> foo == <span class="number">0</span>; <span class="comment">// 这里永远不会失败</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="17-4-3-程序和程序顺序（Programs-and-Program-Order）"><a href="#17-4-3-程序和程序顺序（Programs-and-Program-Order）" class="headerlink" title="17.4.3. 程序和程序顺序（Programs and Program Order）"></a>17.4.3. 程序和程序顺序（Programs and Program Order）</h4><p>在每个线程 t 执行的所有线程间动作中，t 的程序顺序是反映 <strong>根据 t 的线程内语义执行这些动作的顺序</strong> 的总顺序。</p>
<p><strong>如果所有操作的执行顺序 和 代码中的顺序一致，那么一组操作就是<code>连续一致</code>的</strong>，并且，对变量 v 的每个读操作 r 会看到写操作 w 写入的值，也就是：</p>
<ul>
<li><p>写操作 w 先于 读操作 r 完成，并且</p>
</li>
<li><p>没有其他的写操作 w’ 使得 w’ 在 w 之后 r 之前发生。</p>
</li>
</ul>
<p><code>连续一致性</code>对于可见性和程序执行顺序是一个非常强的保证。在这种场景下，所有的单个操作（比如读和写）构成一个统一的执行顺序，这个执行顺序和代码出现的顺序是一致的，同时每个单个操作都是原子的，且对所有线程来说立即可见。</p>
<p>如果程序没有任何的数据竞争，那么程序的所有执行操作将表现为连续一致。</p>
<p>Sequential consistency and/or freedom from data races still allows errors arising from groups of operations that need to be perceived atomically and are not.</p>
<p><code>连续一致性</code> 和/或 数据竞争的自由仍然允许错误从一组操作中产生。</p>
<blockquote>
<p>完全不知道这句话是什么意思</p>
</blockquote>
<p><em>如果我们用连续一致性作为我们的内存模型，那我们讨论的许多关于编译器优化和处理器优化就是非法的。比如在17.4-C中，一旦执行 p.x=3，那么后续对于该位置的读操作应该是立即可以读到最新值的。</em></p>
<blockquote>
<p><strong>连续一致性</strong>的核心在于每一步的操作都是原子的，同时对于所有线程都是可见的，而且不存在重排序。所以，Java 语言定义的内存模型肯定不会采用这种策略，因为它直接限制了编译器和 JVM 的各种优化措施。</p>
<p>注意：很多地方所说的<strong>顺序一致性</strong>就是这里的<strong>连续一致性</strong>，英文是 <strong>Sequential consistency</strong></p>
</blockquote>
<h4 id="17-4-4-同步顺序（Synchronization-Order）"><a href="#17-4-4-同步顺序（Synchronization-Order）" class="headerlink" title="17.4.4. 同步顺序（Synchronization Order）"></a>17.4.4. 同步顺序（Synchronization Order）</h4><p>每个执行都有一个同步顺序。同步顺序是由执行过程中的每个同步操作组成的顺序。对于每个线程 t，同步操作组成的同步顺序是和线程 t 中的代码顺序一致的。</p>
<blockquote>
<p>虽然拗口，但毕竟说的是同步，我们都不陌生。</p>
</blockquote>
<p>同步操作包括了如下同步关系：</p>
<ul>
<li><p>对于监视器 m 的解锁与所有后续操作对于 m 的加锁同步</p>
</li>
<li><p>对 volatile 变量 v 的写入，与所有其他线程后续对 v 的读同步</p>
</li>
<li><p>启动线程的操作与线程中的第一个操作同步。</p>
</li>
<li><p>对于每个属性写入默认值（0， false，null）与每个线程对其进行的操作同步。</p>
<p>尽管在创建对象完成之前对对象属性写入默认值有点奇怪，但从概念上来说，每个对象都是在程序启动时用默认值初始化来创建的。</p>
</li>
<li><p>线程 T1 的最后操作与线程 T2 发现线程 T1 已经结束同步。</p>
<p>线程 T2 可以通过 T1.isAlive() 或 T1.join() 方法来判断 T1 是否已经终结。</p>
</li>
<li><p>如果线程 T1 中断了 T2，那么线程 T1 的中断操作与其他所有线程发现 T2 被中断了同步（通过抛出 InterruptedException 异常，或者调用 Thread.interrupted 或 Thread.isInterrupted ）</p>
</li>
</ul>
<p>以上同步顺序可以理解为对于某资源的释放先于其他操作对同一资源的获取。</p>
<blockquote>
<p>好，这节相对 easy，说的就是关于 <strong>A synchronizes-with B</strong> 的一系列规则。</p>
</blockquote>
<h4 id="17-4-5-Happens-before顺序（Happens-before-Order）"><a href="#17-4-5-Happens-before顺序（Happens-before-Order）" class="headerlink" title="17.4.5. Happens-before顺序（Happens-before Order）"></a>17.4.5. Happens-before顺序（Happens-before Order）</h4><blockquote>
<p>Happens-before 是非常重要的知识，有些地方我没有很理解，我尽量将原文直译过来。想要了解更深的东西，你可能还需要查询更多的其他资料。</p>
</blockquote>
<p>两个操作可以用 happens-before 来确定它们的执行顺序，如果一个操作 happens-before 于另一个操作，那么我们说第一个操作对于第二个操作是可见的。</p>
<blockquote>
<p>注意：happens-before 强调的是可见性问题</p>
</blockquote>
<p>如果我们分别有操作 x 和操作 y，我们写成 <strong>hb(x, y)</strong> 来表示 <strong>x happens-before y</strong>。</p>
<ul>
<li><p>如果操作 x 和操作 y 是同一个线程的两个操作，并且在代码上操作 x 先于操作 y 出现，那么有 hb(x, y)</p>
<blockquote>
<p>请注意，这里不代表不可以重排序，只要没有数据依赖关系，重排序就是可能的。</p>
</blockquote>
</li>
<li><p>对象构造方法的最后一行指令 happens-before 于 finalize() 方法的第一行指令。</p>
</li>
<li><p>如果操作 x 与随后的操作 y 构成同步，那么 hb(x, y)。</p>
<blockquote>
<p>这里说的就是上一小节的同步顺序</p>
</blockquote>
</li>
<li><p>hb(x, y) 和 hb(y, z)，那么可以推断出 hb(x, z)</p>
</li>
</ul>
<p>对象的 wait 方法关联了加锁和解锁的操作，它们的 happens-before 关系即是加锁 happens-before 解锁。</p>
<p>我们应该注意到，两个操作之间的 happens-before 的关系并不一定表示它们在 JVM 的具体实现上必须是这个顺序，如果重排序后的操作结果和合法的执行结果是一致的，那么这种实现就不是非法的。</p>
<p>比如说，在线程中对对象的每个属性写入初始默认值并不需要先于线程的开始，只要这个事实没有被读到就可以了。</p>
<blockquote>
<p>我们可以发现，happens-before 规则主要还是上一节 <strong>同步顺序</strong> 中的规则，加上额外的几条</p>
</blockquote>
<p>更具体地说，如果两个操作是 happens-before 的关系，但是在代码中它们并没有这种顺序，那么就没有必要表现出 happens-before 关系。如线程 1 对变量进行写入，线程 2 随后对变量进行读操作，那么这两个操作是没有 happens-before 关系的。</p>
<p>happens-before 关系用于定义当发生数据竞争的时候。</p>
<p>将上面所有的规则简化成以下列表：</p>
<ul>
<li><p>对一个监视器的解锁操作 happens-before 于后续的对这个监视器的加锁操作。</p>
</li>
<li><p>对 volatile 属性的写操作先于后续对这个属性的读操作。</p>
<blockquote>
<p>也就是一旦写操作完成，那么后续的读操作一定能读到最新的值</p>
</blockquote>
</li>
<li><p>线程的 start() 先于任何在线程中定义的语句。</p>
</li>
<li><p>如果 A 线程中调用了 B.join()，那么 B 线程中的操作先于 A 线程 join() 返回之后的任何语句。</p>
<blockquote>
<p>因为 join() 本身就是让其他线程先执行完的意思。</p>
</blockquote>
</li>
<li><p>对象的默认初始值 happens-before 于程序中对它的其他操作。</p>
<blockquote>
<p>也就是说不管我们要对这个对象干什么，这个对象即使没有创建完成，它的各个属性也一定有初始零值。</p>
</blockquote>
</li>
</ul>
<p>当程序出现两个没有 happens-before 关系的操作对同一数据进行访问时，我们称之为程序中有数据竞争。</p>
<p>除了线程间操作，数据竞争不直接影响其他操作的语义，如读取数组的长度、检查转换的执行、虚拟方法的调用。</p>
<p><em>因此，数据竞争不会导致错误的行为，例如为数组返回错误的长度。</em></p>
<p>当且仅当所有连续一致的操作都没有数据争用时，程序就是<strong>正确同步</strong>的。</p>
<p>如果一个程序是正确同步的，那么程序中的所有操作就会表现出连续一致性。</p>
<p><em>这是一个对于程序员来说强有力的保证，程序员不需要知道重排序的原因，就可以确定他们的代码是否包含数据争用。因此，他们不需要知道重排序的原因，来确定他们的代码是否是正确同步的。一旦确定了代码是正确同步的，程序员也就不需要担心重排序对于代码的影响。</em></p>
<blockquote>
<p>其实就是正确同步的代码不存在数据竞争问题，这个时候程序员不需要关心重排序是否会影响我们的代码，我们的代码执行一定会<strong>表现出</strong>连续一致。</p>
</blockquote>
<p><em>程序必须正确同步，以避免当出现重排序时，会出现一系列的奇怪的行为。正确同步的使用，不能保证程序的全部行为都是正确的。但是，它的使用可以让程序员以很简单的方式就能知道可能发生的行为。正确同步的程序表现出来的行为更不会依赖于可能的重排序。没有使用正确同步，非常奇怪、令人疑惑、违反直觉的任何行为都是可能的。</em></p>
<p>我们说，对变量 v 的读操作 r 能看到对 v 的写操作 w，如果: </p>
<ul>
<li>读操作 r 不是先于 w 发生（比如不是 hb(r, w) ），同时</li>
<li>没有写操作 w’ 穿插在 w 和 r 中间（如不存在 hb(w, w’) 和 hb(w’, r)）。</li>
</ul>
<p>非正式地，如果没有 happens-before 关系阻止读操作 r，那么读操作 r 就能看到写操作 w 的结果。</p>
<blockquote>
<p>后面的部分是关于 <em>happens-before consistency</em> 的，我也不是很理解，感兴趣的读者请自行参阅其他资料。</p>
</blockquote>
<p>A set of actions <em>A</em> is <em>happens-before consistent</em> if for all reads <em>r</em> in <em>A</em>, where <em>W(r)</em> is the write action seen by <em>r</em>, it is not the case that either <em>hb(r, W(r))</em> or that there exists a write <em>w</em> in <em>A</em> such that <em>w.v</em> = <em>r.v</em> and <em>hb(W(r), w)</em> and <em>hb(w, r)</em>.</p>
<p>In a <em>happens-before consistent</em> set of actions, each read sees a write that it is allowed to see by the <em>happens-before</em> ordering.</p>
<hr>
<p><strong>Example 17.4.5-1. Happens-before Consistency</strong></p>
<p>For the trace in <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5-A">Table 17.4.5-A</a>, initially <code>A == B == 0</code>. The trace can observe <code>r2 == 0</code> and <code>r1 == 0</code> and still be <em>happens-before consistent</em>, since there are execution orders that allow each read to see the appropriate write.</p>
<p><strong>Table 17.4.5-A. Behavior allowed by happens-before consistency, but not sequential consistency.</strong></p>
<table>
<thead>
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
</thead>
<tbody><tr>
<td><code>B = 1;</code></td>
<td><code>A = 2;</code></td>
</tr>
<tr>
<td><code>r2 = A;</code></td>
<td><code>r1 = B;</code></td>
</tr>
</tbody></table>
<p>Since there is no synchronization, each read can see either the write of the initial value or the write by the other thread. An execution order that displays this behavior is:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1: B = 1;</span><br><span class="line">3: A = 2;</span><br><span class="line">2: r2 = A;  // sees initial write of 0</span><br><span class="line">4: r1 = B;  // sees initial write of 0</span><br></pre></td></tr></table></figure>

<p>Another execution order that is happens-before consistent is:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1: r2 = A;  // sees write of A = 2</span><br><span class="line">3: r1 = B;  // sees write of B = 1</span><br><span class="line">2: B = 1;</span><br><span class="line">4: A = 2;</span><br></pre></td></tr></table></figure>

<p>In this execution, the reads see writes that occur later in the execution order. This may seem counterintuitive, but is allowed by <em>happens-before</em> consistency. Allowing reads to see later writes can sometimes produce unacceptable behaviors.</p>
<hr>
<blockquote>
<p>关于后面的几个小节，我自己对其理解不够，也不希望误导大家，如果大家感兴趣的话，请参阅其他资料。</p>
</blockquote>
<h4 id="17-4-6-Executions"><a href="#17-4-6-Executions" class="headerlink" title="17.4.6. Executions"></a>17.4.6. Executions</h4><blockquote>
<p>未完成</p>
</blockquote>
<h4 id="17-4-7-Well-Formed-Executions"><a href="#17-4-7-Well-Formed-Executions" class="headerlink" title="17.4.7. Well-Formed Executions"></a>17.4.7. Well-Formed Executions</h4><blockquote>
<p>未完成</p>
</blockquote>
<h4 id="17-4-8-Executions-and-Causality-Requirements"><a href="#17-4-8-Executions-and-Causality-Requirements" class="headerlink" title="17.4.8. Executions and Causality Requirements"></a>17.4.8. Executions and Causality Requirements</h4><blockquote>
<p>未完成</p>
</blockquote>
<h4 id="17-4-9-Observable-Behavior-and-Nonterminating-Executions"><a href="#17-4-9-Observable-Behavior-and-Nonterminating-Executions" class="headerlink" title="17.4.9. Observable Behavior and Nonterminating Executions"></a>17.4.9. Observable Behavior and Nonterminating Executions</h4><blockquote>
<p>未完成</p>
</blockquote>
<h3 id="17-5-final-属性的语义（final-Field-Semantics）"><a href="#17-5-final-属性的语义（final-Field-Semantics）" class="headerlink" title="17.5. final 属性的语义（final Field Semantics）"></a>17.5. final 属性的语义（final Field Semantics）</h3><blockquote>
<p>我们经常使用 final，关于它最基础的知识是：用 final 修饰的类不可以被继承，用 final 修饰的方法不可以被覆写，用 final 修饰的属性一旦初始化以后不可以被修改。</p>
<p>当然，这节说的不是这些，这里将阐述 final 关键字的深层次含义。</p>
</blockquote>
<p>用 final 声明的属性正常情况下初始化一次后，就不会被改变。final 属性的语义与普通属性的语义有一些不一样。尤其是，对于 final 属性的读操作，compilers 可以自由地去除不必要的同步。相应地，compilers 可以将 final 属性的值缓存在寄存器中，而不用像普通属性一样从内存中重新读取。</p>
<p>final 属性同时也允许程序员不需要使用同步就可以实现<strong>线程安全</strong>的<strong>不可变对象</strong>。一个线程安全的不可变对象对于所有线程来说都是不可变的，即使传递这个对象的引用存在数据竞争。这可以提供安全的保证，即使是错误的或者恶意的对于这个不可变对象的使用。如果需要保证对象不可变，需要正确地使用 final 属性域。</p>
<p>对象只有在构造方法结束了才被认为<code>完全初始化</code>了。如果一个对象<strong>完全初始化</strong>以后，一个线程持有该对象的引用，那么这个线程一定可以看到正确初始化的 final 属性的值。</p>
<blockquote>
<p>这个隐含了，如果属性值不是 final 的，那就不能保证一定可以看到正确初始化的值，可能看到初始零值。</p>
</blockquote>
<p>final 属性的使用是非常简单的：在对象的构造方法中设置 final 属性；同时在对象初始化完成前，不要将此对象的引用写入到其他线程可以访问到的地方。如果这个条件满足，当其他线程看到这个对象的时候，那个线程始终可以看到正确初始化后的对象的 final 属性。It will also see versions of any object or array referenced by those <code>final</code> fields that are at least as up-to-date as the <code>final</code> fields are.</p>
<blockquote>
<p>这里面说到了一个<strong>正确初始化</strong>的问题，看过《Java并发编程实战》的可能对这个会有印象，不要在构造方法中将 this 发布出去。</p>
</blockquote>
<hr>
<p><strong>Example 17.5-1. final Fields In The Java Memory Model</strong></p>
<p>这段代码把final属性和普通属性进行对比。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FinalFieldExample</span> &#123; </span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y; </span><br><span class="line">    <span class="keyword">static</span> FinalFieldExample f;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalFieldExample</span><span class="params">()</span> &#123;</span><br><span class="line">        x = <span class="number">3</span>; </span><br><span class="line">        y = <span class="number">4</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        f = <span class="keyword">new</span> <span class="title class_">FinalFieldExample</span>();</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> f.x;  <span class="comment">// 程序一定能得到 3  </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> f.y;  <span class="comment">// 也许会看到 0</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类<code>FinalFieldExample</code>有一个 final 属性 x 和一个普通属性 y。我们假定有一个线程执行 writer() 方法，另一个线程再执行 reader() 方法。</p>
<p>因为 writer() 方法在对象完全构造后将引用写入 f，那么 reader() 方法将一定可以看到初始化后的 f.x : 将读到一个 int 值 3。然而， f.y 不是 final 的，所以程序不能保证可以看到 4，可能会得到 0。</p>
<hr>
<hr>
<p><strong>Example 17.5-2. final Fields For Security</strong></p>
<p>final 属性被设计成用来保障很多操作的安全性。</p>
<p>考虑以下代码，线程 1 执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Global.s = <span class="string">&quot;/tmp/usr&quot;</span>.substring(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>同时，线程 2 执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">myS</span> <span class="operator">=</span> Global.s; </span><br><span class="line"><span class="keyword">if</span> (myS.equals(<span class="string">&quot;/tmp&quot;</span>)) System.out.println(myS);</span><br></pre></td></tr></table></figure>

<p><strong>String</strong> 对象是不可变对象，同时 String 操作不需要使用同步。虽然 String 的实现没有任何的数据竞争，但是其他使用到 String 对象的代码可能是存在数据竞争的，内存模型没有对存在数据竞争的代码提供安全性保证。特别是，如果 String 类中的属性不是 final 的，那么有可能（虽然不太可能）线程 2 会看到这个 string 对象的 offset 为初始值 0，那么就会出现 myS.equals(“/tmp”)。之后的一个操作可能会看到这个 String 对象的正确的 offset 值 4，那么会得到 “/usr”。Java 中的许多安全特性都依赖于 String 对象的不可变性，即使是恶意代码在数据竞争的环境中在线程之间传递 String 对象的引用。</p>
<blockquote>
<p>大家看这段的时候，如果要看代码，请注意，这里说的是  JDK6 及以前的 String 类：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span>  </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> offset;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> count;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0  </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为到 JDK7 和 JDK8 的时候，代码已经变为：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6849794470754667710L</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="17-5-1-final属性的语义（Semantics-of-final-Fields）"><a href="#17-5-1-final属性的语义（Semantics-of-final-Fields）" class="headerlink" title="17.5.1. final属性的语义（Semantics of final Fields）"></a>17.5.1. final属性的语义（Semantics of final Fields）</h4><p>令 o 为一个对象，c 为 o 的构造方法，构造方法中对 final 的属性 f 进行写入值。当构造方法 c 退出的时候，会在final 属性 f 上执行一个 freeze 操作。</p>
<p>注意，如果一个构造方法调用了另一个构造方法，在被调用的构造方法中设置 final 属性，那么对于 final 属性的 freeze 操作发生于被调用的构造方法结束的时候。</p>
<blockquote>
<p>我没懂这边的 freeze 操作是什么。</p>
</blockquote>
<p>对于每一个执行，读操作的行为被其他的两个偏序影响，解引用链 <em>dereferences()</em> 和内存链 *mc()*，它们被认为是执行的一部分。这些偏序必须满足下面的约束：</p>
<blockquote>
<p>我对于解引用链和内存链完全不熟悉，所以下面这段我就不翻译了。</p>
</blockquote>
<ul>
<li><p>Dereference Chain: If an action <em>a</em> is a read or write of a field or element of an object <em>o</em> by a thread <em>t</em> that did not initialize <em>o</em>, then there must exist some read <em>r</em> by thread <em>t</em> that sees the address of <em>o</em> such that <em>r</em> <em>dereferences(r, a)</em>.</p>
</li>
<li><p>Memory Chain: There are several constraints on the memory chain ordering:</p>
<ul>
<li>If <em>r</em> is a read that sees a write <em>w</em>, then it must be the case that <em>mc(w, r)</em>.</li>
<li>If <em>r</em> and <em>a</em> are actions such that <em>dereferences(r, a)</em>, then it must be the case that <em>mc(r, a)</em>.</li>
<li>If <em>w</em> is a write of the address of an object <em>o</em> by a thread <em>t</em> that did not initialize <em>o</em>, then there must exist some read <em>r</em> by thread <em>t</em> that sees the address of <em>o</em> such that <em>mc(r, w)</em>.</li>
</ul>
</li>
</ul>
<p>Given a write <em>w</em>, a freeze <em>f</em>, an action <em>a</em> (that is not a read of a <code>final</code> field), a read <em>r1</em> of the <code>final</code> field frozen by <em>f</em>, and a read <em>r2</em> such that <em>hb(w, f)</em>, <em>hb(f, a)</em>, <em>mc(a, r1)</em>, and <em>dereferences(r1, r2)</em>, then when determining which values can be seen by <em>r2</em>, we consider <em>hb(w, r2)</em>. (This <em>happens-before</em> ordering does not transitively close with other <em>happens-before</em> orderings.)</p>
<p>Note that the <em>dereferences</em> order is reflexive, and <em>r1</em> can be the same as <em>r2</em>.</p>
<p>For reads of <code>final</code> fields, the only writes that are deemed to come before the read of the <code>final</code> field are the ones derived through the <code>final</code> field semantics.</p>
<h4 id="17-5-2-在构造期间读-final-属性（Reading-final-Fields-During-Construction）"><a href="#17-5-2-在构造期间读-final-属性（Reading-final-Fields-During-Construction）" class="headerlink" title="17.5.2. 在构造期间读 final 属性（Reading final Fields During Construction）"></a>17.5.2. 在构造期间读 final 属性（Reading final Fields During Construction）</h4><p>在构造对象的线程中，对该对象的 final 属性的读操作，遵守正常的 happens-before 规则。如果在构造方法内，读某个 final 属性晚于对这个属性的写操作，那么这个读操作可以看到这个 final 属性已经被定义的值，否则就会看到默认值。</p>
<h4 id="17-5-3-final-属性的修改（Subsequent-Modification-of-final-Fields）"><a href="#17-5-3-final-属性的修改（Subsequent-Modification-of-final-Fields）" class="headerlink" title="17.5.3. final 属性的修改（Subsequent Modification of final Fields）"></a>17.5.3. final 属性的修改（Subsequent Modification of final Fields）</h4><p>在许多场景下，如反序列化，系统需要在对象构造之后改变 final 属性的值。final 属性可以通过反射和其他方法来改变。唯一的具有合理语义的模式是：对象被构造出来，然后对象中的 final 属性被更新。在这个对象的所有 final 属性更新操作完成之前，此对象不应该对其他线程可见，也不应该对 final 属性进行读操作。对于 final 属性的 freeze 操作发生于<strong>构造方法的结束，这个时候 final 属性已经被设值</strong>，还有<strong>通过反射或其他方式对于 final 属性的更新之后</strong>。</p>
<p>即使是这样，依然存在几个难点。如果一个 final 属性在属性声明的时候初始化为一个常量表达式，对于这个 final 属性值的变化过程也许是不可见的，因为对于这个 final 属性的使用是在编译时用常量表达式来替换的。</p>
<p>另一个问题是，该规范允许 JVM 实现对 final 属性进行强制优化。在一个线程内，允许<strong>对于 final 属性的读操作</strong>与<strong>构造方法之外的对于这个 final 属性的修改</strong>进行重排序。</p>
<hr>
<p><strong>Example 17.5.3-1. 对于 final 属性的强制优化（Aggressive Optimization of final Fields</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">    A() &#123; </span><br><span class="line">        x = <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> d(<span class="built_in">this</span>,<span class="built_in">this</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">d</span><span class="params">(A a1, A a2)</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a1.x; </span><br><span class="line">        g(a1); </span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> a2.x; </span><br><span class="line">        <span class="keyword">return</span> j - i; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">(A a)</span> &#123; </span><br><span class="line">    	<span class="comment">// 利用反射将 a.x 的值修改为 2</span></span><br><span class="line">        <span class="comment">// uses reflection to change a.x to 2 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法 d 中，编译器允许对 x 的读操作和方法 g 进行重排序，这样的话，<code>new A().f()</code>可能会返回 -1, 0, 或 1。</p>
<blockquote>
<p>我在我的 MBP 上试了好多办法，真的没法重现出来，不过并发问题就是这样，我们不能重现不代表不存在。StackOverflow 上有网友说在 Sparc 上运行，可惜我没有 Sparc 机器。</p>
</blockquote>
<hr>
<blockquote>
<p>下文将说到一个比较少见的 <strong>final-field-safe context</strong></p>
</blockquote>
<p>JVM 实现可以提供一种方式在 <strong>final 属性安全</strong>上下文（final-field-safe context）中执行代码块。如果一个对象是在 <em>final 属性安全上下文</em>中构造出来的，那么在这个 *final 属性安全上下文 *中对于 final 属性的读操作不会和相应的对于 final 属性的修改进行重排序。</p>
<p><em>final 属性安全上下文</em>还提供了额外的保障。如果一个线程已经看到一个不正确发布的一个对象的引用，那么此线程可以看到了 final 属性的默认值，然后，在 <em>final 属性安全上下文</em>中读取该对象的正确发布的引用，这可以保证看到正确的 final 属性的值。在形式上，在<em>final 属性安全上下文</em>中执行的代码被认为是一个独立的线程（仅用于满足 final 属性的语义）。</p>
<p>在实现中，compiler 不应该将对 final 属性的访问移入或移出<em>final 属性安全上下文</em>（尽管它可以在这个执行上下文的周边移动，只要这个对象没有在这个上下文中进行构造）。</p>
<p>对于 <em>final 属性安全上下文</em>的使用，一个恰当的地方是执行器或者线程池。在每个独立的 <em>final 属性安全上下文</em>中执行每一个 <code>Runnable</code>，执行器可以保证在一个 <code>Runnable</code> 中对对象 o 的不正确的访问不会影响同一执行器内的其他 <code>Runnable</code> 中的 final 带来的安全保障。</p>
<h4 id="17-5-4-写保护属性（Write-Protected-Fields）"><a href="#17-5-4-写保护属性（Write-Protected-Fields）" class="headerlink" title="17.5.4. 写保护属性（Write-Protected Fields）"></a>17.5.4. 写保护属性（Write-Protected Fields）</h4><p>通常，如果一个属性是 <code>final</code> 的和 <code>static</code> 的，那么这个属性是不会被改变的。但是， <code>System.in</code>, <code>System.out</code>, 和 <code>System.err</code> 是 <code>static final</code> 的，出于遗留的历史原因，它们必须允许被 <code>System.setIn</code>, <code>System.setOut</code>, 和 <code>System.setErr</code> 这几个方法改变。我们称这些属性是<strong>写保护</strong>的，用以区分普通的 final 属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">PrintStream</span> <span class="variable">err</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>编译器需要将这些属性与 final 属性区别对待。例如，普通 final 属性的读操作对于同步是“免疫的”：锁或 volatile 读操作中的内存屏障并不会影响到对于 final 属性的读操作读到的值。因为写保护属性的值是可以被改变的，所以同步事件应该对它们有影响。因此，语义规定这些属性被当做普通属性，不能被用户的代码改变，除非是 <code>System</code>类中的代码。</p>
<h3 id="17-6-字分裂（Word-Tearing）"><a href="#17-6-字分裂（Word-Tearing）" class="headerlink" title="17.6. 字分裂（Word Tearing）"></a>17.6. 字分裂（Word Tearing）</h3><p>实现 Java 虚拟机需要考虑的一件事情是，每个对象属性以及数组元素之间是独立的，更新一个属性或元素不能影响其他属性或元素的读取与更新。尤其是，两个线程在分别更新 byte 数组相邻的元素时，不能互相影响与干扰，且不需要同步来保证连续一致性。</p>
<p>一些处理器不提供写入单个字节的能力。 通过简单地读取整个字，更新相应的字节，然后将整个字写入内存，用这种方式在这种处理器上实现字节数组更新是非法的。 这个问题有时被称为字分裂（word tearing），在这种不能单独更新单个字节的处理器上，将需要寻求其他的方法。</p>
<blockquote>
<p>请注意，对于大部分处理器来说，都没有这个问题</p>
</blockquote>
<hr>
<p><strong>Example 17.6-1. Detection of Word Tearing</strong></p>
<p>以下程序用于测试是否存在字分裂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordTearing</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LENGTH</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ITERS</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] counts = <span class="keyword">new</span> <span class="title class_">byte</span>[LENGTH];</span><br><span class="line">    <span class="keyword">static</span> Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[LENGTH];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    WordTearing(<span class="type">int</span> i) &#123;</span><br><span class="line">        id = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ITERS; i++) &#123;</span><br><span class="line">            <span class="type">byte</span> <span class="variable">v2</span> <span class="operator">=</span> counts[id];</span><br><span class="line">            <span class="keyword">if</span> (v != v2) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Word-Tearing found: &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;counts[&quot;</span> + id + <span class="string">&quot;] = &quot;</span> + v2 +</span><br><span class="line">                        <span class="string">&quot;, should be &quot;</span> + v);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v++;</span><br><span class="line">            counts[id] = v;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; LENGTH; ++i)</span><br><span class="line">            (threads[i] = <span class="keyword">new</span> <span class="title class_">WordTearing</span>(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这表明写入字节时不得覆写相邻的字节。</p>
<hr>
<h3 id="17-7-double-和-long-的非原子处理-（Non-Atomic-Treatment-of-double-and-long）"><a href="#17-7-double-和-long-的非原子处理-（Non-Atomic-Treatment-of-double-and-long）" class="headerlink" title="17.7. double 和 long 的非原子处理 （Non-Atomic Treatment of double and long）"></a>17.7. double 和 long 的非原子处理 （Non-Atomic Treatment of double and long）</h3><p>在Java内存模型中，对于 non-volatile 的 long 或 double 值的写入是通过两个单独的写操作完成的：long 和 double 是 64 位的，被分为两个 32 位来进行写入。那么可能就会导致一个线程看到了某个操作的低 32 位的写入和另一个操作的高 32 位的写入。</p>
<p>写入或者读取 volatile 的 long 和 double 值是原子的。</p>
<p>写入和读取对象引用一定是原子的，不管具体实现是32位还是64位。</p>
<p>将一个 64 位的 long 或 double 值的写入分为相邻的两个 32 位的写入对于 JVM 的实现来说是很方便的。为了性能上的考虑，JVM 的实现是可以决定采用原子写入还是分为两个部分写入的。</p>
<p>如果可能的话，我们鼓励 JVM 的实现避开将 64 位值的写入分拆成两个操作。我们也希望程序员将共享的 64 位值操作设置为 volatile 或者使用正确的同步，这样可以提供更好的兼容性。</p>
<blockquote>
<p>目前来看，64 位虚拟机对于 long 和 double 的写入都是原子的，没必要加 volatile 来保证原子性。</p>
</blockquote>
<p>（全文完）</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><strong>官方原文</strong>：<a href="https://docs.oracle.com/javase/specs/">https://docs.oracle.com/javase/specs/</a></p>
<p><strong>JSR 133 (Java Memory Model) FAQ</strong>: <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html">http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html</a></p>
<p><strong>The JSR-133 Cookbook for Compiler Writers</strong>： <a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html">http://gee.cs.oswego.edu/dl/jmm/cookbook.html</a></p>
<blockquote>
<p>这是 Doug Lea 大神写的，属于更深层次的实现上的解读了，如果大家有需要的话，我后续也许可以整理整理。</p>
</blockquote>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>路还很长，如果有机会，我会在其中挑出一些 topic 出来和大家分享我自己的理解。</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 运维篇</title>
    <url>/2024/10/04/MySQL%20%E8%BF%90%E7%BB%B4%E7%AF%87/</url>
    <content><![CDATA[<h2 id="MySQL-客户端管理"><a href="#MySQL-客户端管理" class="headerlink" title="MySQL 客户端管理"></a>MySQL 客户端管理</h2><h3 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a>系统数据库</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018231950720-1730191893980-1.png" alt="image-20241018231950720"></p>
<h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018231940461-1730191893981-2.png" alt="image-20241018231940461"></p>
<p>import只能导入dump加-T参数导出的txt文本，source用来执行.sql文件</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>记录了当 mysqld 启动和停止时，以及<a href="https://so.csdn.net/so/search?q=%E6%9C%8D%E5%8A%A1%E5%99%A8&spm=1001.2101.3001.7020">服务器</a>在运行过程中<strong>发生任何严重错误时的相关信息</strong>。当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。</p>
<p>该日志是默认开启的，默认存放目录 /var/log/，默认的日志文件名为 mysqld.log 。查看日志位置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#先登录mysql</span><br><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p1234</span><br><span class="line"></span><br><span class="line">#通过此系统变量查看日志文件的位置</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_error%&#x27;</span>;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><p>记录 MySQL 上的所有<strong>变化</strong>并<strong>以二进制形式</strong>保存在磁盘上。包括所有的DDL和DML语句，但不包括DQL语句。主要用于<mark>主从复制<mark>、<mark>灾难时的数据库恢复<mark>。</p>
<p>binlog由server层的执行器生成，历史比redolog和undolog都早，和存储引擎没有关系。</p>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><h5 id="STATEMENT"><a href="#STATEMENT" class="headerlink" title="STATEMENT"></a>STATEMENT</h5><p>记录SQL语句，如果有动态函数会恢复不准确，这里就属于逻辑日志</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029171133144.png" alt="image-20241029171133144"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029191323110.png" alt="image-20241029191323110"></p>
<h5 id="ROW"><a href="#ROW" class="headerlink" title="ROW"></a>ROW</h5><p>记录行数据修改之前和之后的数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029171203288.png" alt="image-20241029171203288"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029191145845.png" alt="image-20241029191145845"></p>
<h5 id="MIXED"><a href="#MIXED" class="headerlink" title="MIXED"></a>MIXED</h5><h4 id="写入过程"><a href="#写入过程" class="headerlink" title="写入过程"></a>写入过程</h4><p>事务开始以后的执行过程都写到内存中的binlog cache，事务提交后会write写入 page cache，仍然在内存中，需要通过刷盘操作fsync才能持久化到磁盘。</p>
<ul>
<li><code>sync_binlog</code> = <code>1(default)</code> 表示每次提交事务都要在写入page cache的同时刷盘，性能较低但安全；</li>
<li><code>sync_binlog</code> = <code>0</code> 表示每次提交事务以后只写入page cache，刷盘时机交给系统确定，性能高但是不安全，会导致宕机以后page cache的binlog全部丢失；</li>
<li><code>sync_binlog</code> = <code>N</code> 表示累计N个事务才write，折中方案。 </li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029174232239.png" alt="image-20241029174232239"></p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><h5 id="手动删除"><a href="#手动删除" class="headerlink" title="手动删除"></a>手动删除</h5><p><a href="https://blog.csdn.net/aa35434/article/details/133524177">MySql运维篇—008：日志：错误日志、二进制日志、查询日志、慢查询日志，主从复制：概述 虚拟机更改ip注意事项、原理、搭建步骤_mysql 错误日志-CSDN博客</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029191529628.png" alt="image-20241029191529628"></p>
<h5 id="自动删除"><a href="#自动删除" class="headerlink" title="自动删除"></a>自动删除</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029191602409.png" alt="image-20241029191602409"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029191632832.png" alt="image-20241029191632832"></p>
<h4 id="和其他日志的异同"><a href="#和其他日志的异同" class="headerlink" title="和其他日志的异同"></a>和其他日志的异同</h4><p><a href="https://blog.csdn.net/pengweid/article/details/136887291">彻底讲透：MySQL中的三种日志（Undo Log、Redo Log和Binlog）_undolog日志类型-CSDN博客</a></p>
<h5 id="RedoLog-amp-BinLog"><a href="#RedoLog-amp-BinLog" class="headerlink" title="RedoLog &amp; BinLog"></a>RedoLog &amp; BinLog</h5><h6 id="持久化粒度不同"><a href="#持久化粒度不同" class="headerlink" title="持久化粒度不同"></a>持久化粒度不同</h6><ul>
<li>redolog让InnoDB有了事务崩溃恢复能力，保证了<strong>事务</strong>中的持久性，确保事务已经提交的修改能正确写入磁盘中。</li>
<li>binlog则是保证整个MySQL<strong>数据库</strong>集群架构的数据一致性。</li>
</ul>
<h6 id="写入时机不同—两阶段写入"><a href="#写入时机不同—两阶段写入" class="headerlink" title="写入时机不同—两阶段写入"></a>写入时机不同—两阶段写入</h6><ul>
<li>redolog在事务执行过程中可以不断写入，依赖于存储引擎：</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029174344508.png" alt="image-20241029174344508"></p>
<ul>
<li>binlog只有在事务提交时才写入，依赖于执行器（调用完存储引擎API）。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029175255030.png" alt="image-20241029175255030"></p>
<ul>
<li>这就导致虽然两个都能保证持久化能力，但两个是相对独立的，如果其中一个出现错误，就会出现数据不一致的情况，因此需要分阶段写入：将redolog的状态分成两个阶段：prepare和commit，在提交事务时，先写入binlog，再进行redolog commit。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029175500294.png" alt="image-20241029175500294"></p>
<ul>
<li>遇到事故时停机重启，根据redolog恢复数据，redolog处于commit阶段，表明binlog正常写入；redolog处于prepare阶段，binlog正常写入，这时也是完整的，也会提交；redolog处于prepare阶段，找不到对应binlog，此次更改作废。</li>
</ul>
<h6 id="顺序写入但方式不同"><a href="#顺序写入但方式不同" class="headerlink" title="顺序写入但方式不同"></a>顺序写入但方式不同</h6><ul>
<li>redolog是一个日志文件组循环写，当数据成功刷到磁盘就会擦除日志</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029173203896.png" alt="image-20241029173203896"></p>
<p>binlog一直追加写，写满一个文件就创建新文件继续写，保存的是全量日志。事务更改提交以后刷盘失败的恢复能用redolog，如果是整个数据库层级的操作，比如主从复制或者数据备份，就必须用全量日志binlog。</p>
<h5 id="UndoLog-amp-BinLog"><a href="#UndoLog-amp-BinLog" class="headerlink" title="UndoLog &amp; BinLog"></a>UndoLog &amp; BinLog</h5><h6 id="逻辑日志，粒度与方向不同"><a href="#逻辑日志，粒度与方向不同" class="headerlink" title="逻辑日志，粒度与方向不同"></a>逻辑日志，粒度与方向不同</h6><ul>
<li><p>UndoLog属于底层的InnoDB，记录反向操作，粒度更细，用于<strong>事务</strong>的回滚和MVCC（避免锁竞争，提高并发性能）</p>
</li>
<li><p>Binlog属于Server层的执行器，记录正向操作，用于<strong>数据库</strong>备份和复制</p>
</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>Undo Log和Redo Log是为了实现ACID特性中的A（原子性）、C（一致性）和D（持久性）。Undo Log保证了事务内部的一致性以及事务失败后的回滚能力；而Redo Log则是为了保证即使在意外情况下也能恢复已提交事务的更改。</li>
<li>Binlog的设计则更多地关注于高可用性、数据冗余以及分布式环境下的数据同步。它提供了跨节点间的数据复制功能，同时也为数据库管理员提供了审计跟踪和数据恢复手段。</li>
</ul>
<p>类比实际生活：</p>
<ul>
<li><p>首先，Undo Log这位“传令兵”，负责记录每一步操作的反向指令，一旦有差池，便能瞬间执行“撤退”命令，让事务回滚至初始状态，确保了原子性与一致性，就如同战场上的兵马未动粮草先行，进退有序。</p>
<p>其次，Redo Log这位“记事官”，专司记录每一次<strong>物理操作</strong>的详细步骤，即便遭遇突袭或断电，也能根据记录重新搭建战局，恢复已提交事务的影响，确保数据持久不灭，犹如战场上刀光剑影过后，总能找到重整旗鼓的依据。</p>
<p>最后，Binlog这位“信使”，肩负着跨营地同步信息的重要使命，无论主从服务器之间还是备份恢复之时，只需将它传递的信息忠实执行，就能保证所有营地的数据步调一致，仿佛军令如山，一呼百应，千里之外亦可响应无误。</p>
</li>
</ul>
<h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029191825721.png" alt="image-20241029191825721"></p>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>所有查询时间，扫描记录数超过阈值的SQL语句</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029191835513.png" alt="image-20241029191835513"></p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>主库出现问题，快速切换服务</li>
<li>读写分离降低主库压力</li>
<li>从库执行备份，避免主库被全局锁定</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029192549256.png" alt="image-20241029192549256"></p>
<p>从上图来看，复制分成三步:<br>1.Master 主库在事务提交时，会把数据变更记录（DDL.DML）在二进制日志文件 Binlog 中。</p>
<p>2.Slave 从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</p>
<p>3.Slave 从库重做中继日志中的事件，将改变反映它自己的数据</p>
<h2 id="读写分离-分库分表"><a href="#读写分离-分库分表" class="headerlink" title="读写分离 分库分表"></a><a href="https://javaguide.cn/high-performance/read-and-write-separation-and-library-subtable.html">读写分离 分库分表</a></h2><h2 id="冷热数据分离"><a href="#冷热数据分离" class="headerlink" title="冷热数据分离"></a><a href="https://javaguide.cn/high-performance/data-cold-hot-separation.html">冷热数据分离</a></h2>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>binlog</tag>
        <tag>日志</tag>
        <tag>分布式</tag>
        <tag>主从</tag>
        <tag>分片</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 基础</title>
    <url>/2024/09/30/MySQL%20%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>DB</strong>: organized data</p>
<p><strong>DBMS</strong>: manage system</p>
<p><strong>RDBMS</strong>: SQLite PostgreSQL MySQL Oracle Microsoft SQL Server (relational)</p>
<p><strong>SQL</strong>: programming language</p>
<p><strong>数据模型</strong>：管理系统：数据库：表：数据</p>
<p><strong>RDBMS</strong>: 表结构格式统一</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920142153024.png" alt="image-20240920142153024"></p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923202742353.png" alt="image-20240923202742353"></p>
<p>auto_increment 从零开始自动增长 (列是数字的类型，并且是UNIQUE约束)</p>
<p> 这一列不指定id，或者id赋值null 不影响自增</p>
<h3 id="非空，唯一，主键，默认，检查约束"><a href="#非空，唯一，主键，默认，检查约束" class="headerlink" title="非空，唯一，主键，默认，检查约束"></a>非空，唯一，主键，默认，检查约束</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923220639875.png" alt="image-20240923220639875"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923220734860.png" alt="image-20240923220734860"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923220750052.png" alt="image-20240923220750052"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923220711866.png" alt="image-20240923220711866"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005154832392.png" alt="image-20241005154832392"></p>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>数据一致性 完整性</p>
<p>外键：连接两个表的数据</p>
<ul>
<li>（<strong>constraint</strong> foreKeyCons）<strong>foreign key</strong>(dept_id) <strong>references</strong> dept(id) 建表时</li>
<li>给当前表中的dept_id列定义了一个 名为 foreKeyCons 的外键约束，外键引用dept表的id列，dept_id就是外键</li>
<li>dept就是主表，必须存在，并且id是主键</li>
<li>因为有外键约束，所以不能直接删除主表的内容，</li>
</ul>
<p>建表以后对外键的操作：添加和删除。外键属于表的属性</p>
<ul>
<li><strong>alter table</strong> emp <strong>drop foreign key</strong> foreKeyCons</li>
<li><strong>alter table</strong> emp <strong>add constraint</strong> foreKeyCons <strong>foreign key</strong>(dept_id) <strong>references</strong> dept(id)</li>
</ul>
<h4 id="外键的删除、更新行为"><a href="#外键的删除、更新行为" class="headerlink" title="外键的删除、更新行为"></a>外键的删除、更新行为</h4><p>on update 更新   on delete 删除</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005155438576.png" alt="image-20241005155438576"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005155543394.png" alt="image-20241005155543394"></p>
<p>NOACTION RESTRICT 默认</p>
<p>CASCADE 主表变了，子表跟着变，主表删了，子表跟着没</p>
<p><strong>ON DELETE</strong> SET NULL 主表删了，子表把对应的值设为null，只支持删除操作，并且要求外键可以为null</p>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923224354382.png" alt="image-20240923224354382"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923224409160.png" alt="image-20240923224409160"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923224759437.png" alt="image-20240923224759437"></p>
<p>1-M 多的一方建立外键，少的一方作为主表，连接起来</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923225452261.png" alt="image-20240923225452261"></p>
<p>M-N 一起连到一张中间表，中间表做从表，建立外键，连到两张表的主键上</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923225514320.png" alt="image-20240923225514320"></p>
<p>一个商品可能属于不同订单，一个订单也可能有不同商品，所以用类似坐标的方式</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>管理DML语句，InnoDB引擎才支持事务</p>
<p>MySQL默认设置事务自动提交，也就是执行完自动COMMIT.</p>
<p>如果要显式开启事务要SET AUTOCOMMIT = 0;（以后的事务都需要手动提交）</p>
<p>或者 START Transaction /  BEGIN （临时开启一条事务）</p>
<p>COMMIT 提交事务 如果没有问题就提交</p>
<p>ROLLBACK 回滚事务 出现异常就要回滚事务到BEGIN处，即更改前</p>
<h3 id="四大特征-acid"><a href="#四大特征-acid" class="headerlink" title="四大特征 acid"></a>四大特征 acid</h3><p>一致性依赖于应用层，开发者。</p>
<p><strong>A</strong>tomic <strong>C</strong>onsistency <strong>I</strong>solation <strong>D</strong>urability</p>
<p>最小操作单位，不可分割；</p>
<p>完成时必须让所有数据都前后一致，由开发者指定，比如转账，金钱总额不能变化；</p>
<p>多个事务是互相隔离的，排除其他事务对本事务的影响（解决并发问题）；</p>
<p>事务对数据库的修改是持久的；</p>
<p>一什么是隔离性？</p>
<p>隔离性是数据库事务的四个基本属性之一，即 <strong>ACID</strong> 特性中的 “I”（Isolation）。隔离性保证了一个事务在未完成之前，它的操作对其他事务是不可见的，或者说部分可见（取决于隔离级别）。这样可以防止因并发执行而导致的数据问题。</p>
<h3 id="高并发下可能遇到的问题："><a href="#高并发下可能遇到的问题：" class="headerlink" title="高并发下可能遇到的问题："></a>高并发下可能遇到的问题：</h3><ol>
<li><p><strong>脏读</strong>（Dirty Read）：一个事务读取了另一个事务<strong>开始了但未提交</strong>的数据。如果另一个事务回滚或者提交，这些数据将无效，导致第一个事务读取了错误数据。</p>
<ol>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005213034469.png" alt="image-20241005213034469"></li>
</ol>
</li>
<li><p><strong>不可重复读</strong>（Non-repeatable Read）：在同一个事务中，前后两次读取相同的数据时，数据值发生了变化，因为另一个事务在两次读取之间<strong>修改并提交了该数据</strong>。</p>
<ol>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005213018573.png" alt="image-20241005213018573"></li>
</ol>
</li>
<li><p><strong>幻读</strong>（Phantom Read）：一个事务内，连续两次执行相同的查询（select）时，再次进行查询的时候真实的数据集已经发生了变化，但是A却查询不出来这种变化，因此产生了幻读。</p>
<ol>
<li>如果已经解决了12，将会发现：第一次查询没有结果，随后另一个事务插入数据并进行了提交，试图插入数据，会报错，提示不能有重复的主键，但是在第二次查询仍然没有结果，读不到别人已经提交的数据（repeatable read）但是别人提交的数据还在影响。</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005214729161.png" alt="image-20241005214729161"></li>
</ol>
</li>
</ol>
<h3 id="通过隔离性解决高并发问题："><a href="#通过隔离性解决高并发问题：" class="headerlink" title="通过隔离性解决高并发问题："></a>通过隔离性解决高并发问题：</h3><p>数据库系统通常提供多种<strong>事务隔离级别</strong>，每个级别可以解决一部分或全部并发问题。这些隔离级别定义了事务之间可见性规则，数据库可以根据应用场景选择适当的隔离级别来权衡性能与数据一致性。</p>
<p><code>select @@transaction_isolation</code> 查看当前的隔离级别</p>
<p><code>set session transaction isolation level read uncommitted</code>设置当前会话的隔离级别，</p>
<h3 id="SQL-标准定义的四种隔离级别"><a href="#SQL-标准定义的四种隔离级别" class="headerlink" title="SQL 标准定义的四种隔离级别"></a>SQL 标准定义的四种隔离级别</h3><ol>
<li><strong>读未提交（Read Uncommitted）</strong>：<ul>
<li><strong>脏读</strong>、<strong>不可重复读</strong> 和 <strong>幻读</strong> 都可能发生。</li>
<li>最低的隔离级别，事务可以读取未提交的数据。</li>
<li>使用场景：极高并发要求且对数据一致性要求不高的场景。</li>
</ul>
</li>
<li><strong>读已提交（Read Committed）</strong>：Oracle 默认<ul>
<li>解决脏读问题，但仍然可能出现不可重复读和幻读。</li>
<li>一个事务只能读取已提交的数据，保证不会读取到未提交的修改。</li>
<li>使用场景：大多数数据库系统的默认隔离级别，较好的性能和数据一致性的平衡。</li>
</ul>
</li>
<li><strong>可重复读（Repeatable Read）</strong>：MySQL 默认<ul>
<li>解决脏读和不可重复读问题，但幻读仍然可能发生。</li>
<li>在同一事务中，事务两次读取相同的数据，保证两次读取的结果一定相同。不会读取其他事务已经提交的数据，但是仍然无法避免其他事务的影响（比如重复插入相同主键失败但是查不到这条主键的数据）</li>
<li>使用场景：需要保证数据一致性、避免更新数据不一致的场景。</li>
<li>普通的select快照读不会受到其他事务update、insert的影响，但是自己执行update时会进行当前读，会把其他事务update、insert的数据更新成自己的版本号，下一次读取就会读到了。</li>
<li>幻读：尽管B事务在A事务还未结束的时候，增加了表中的数据，但是为了维护可重复读，A事务中不管怎么查询，是查询不到新增的数据的。但是对于真实的表而言，表中的数据是的的确确增加了，所以插入重复的主键会报错。</li>
</ul>
</li>
<li><strong>串行化（Serializable）</strong>：<ul>
<li>解决脏读、不可重复读和幻读问题。</li>
<li>最高的隔离级别，所有事务串行执行，完全避免并发导致的数据问题。要等先开始的事务执行完提交或者回滚，后开始的事务才能开始执行，完全放弃并发性。</li>
<li>使用场景：极端数据一致性要求的场景，但代价是性能较低，容易出现锁等待甚至死锁。</li>
</ul>
</li>
</ol>
<h3 id="隔离性和并发控制的关系"><a href="#隔离性和并发控制的关系" class="headerlink" title="隔离性和并发控制的关系"></a>隔离性和并发控制的关系</h3><ul>
<li><strong>锁机制</strong>：隔离性通常通过锁机制（例如行锁、表锁）实现。在高隔离级别下（如可串行化），数据库会使用更严格的锁定策略，确保其他事务在未提交前不能读取或修改被锁定的数据。</li>
<li>**多版本并发控制 (MVCC)**：有些数据库（如 PostgreSQL、MySQL 的 InnoDB 存储引擎）采用了多版本并发控制，允许在较高隔离级别下提高性能。MVCC 通过保存数据的多个版本，允许读取操作无需阻塞写入操作，从而在高并发下仍然能够提供一致的数据读取。</li>
</ul>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="通用语法"><a href="#通用语法" class="headerlink" title="通用语法"></a>通用语法</h3><ul>
<li>可以多行书写，分号结尾</li>
<li>可用空格和缩进增强可读性</li>
<li>MySQL的SQL语句不区分大小写，关键字建议大写</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>DDL definition 定义数据库对象(表、db，字段)</p>
<p>DML manipulation 操作数据，增删改</p>
<p>DQL query 查询</p>
<p>DCL control 创建用户，控制访问权限</p>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>control 控制数据库访问权限和管理数据库用户</p>
<h4 id="DCL-用户管理"><a href="#DCL-用户管理" class="headerlink" title="DCL-用户管理"></a>DCL-用户管理</h4><p>use mysql;</p>
<p>select * from user;</p>
<ul>
<li><p>创建用户 <strong>create user</strong> ‘itcast‘<strong>@</strong>‘localhost’ <strong>identified by</strong> ‘123456’ 密码123456用户名itcast 主机localhost</p>
</li>
<li><p>创建用户 <strong>create user</strong> ‘heima‘<strong>@</strong>‘%’ <strong>identified by</strong> ‘123456’ 密码123456用户名heima  任意主机均可访问</p>
</li>
<li><p>改密码 alter user ‘heima‘<strong>@</strong>‘%’ <strong>identified with</strong> mysql_native_password by ‘1234’ 改成1234</p>
</li>
<li><p>drop user ‘heima‘<strong>@</strong>‘%’  删除用户</p>
</li>
</ul>
<h4 id="DCL-控制权限"><a href="#DCL-控制权限" class="headerlink" title="DCL - 控制权限"></a>DCL - 控制权限</h4><ul>
<li>查询有什么权限：SHOW GRANTS FOR 用户@主机</li>
<li>授予用户权限：grant all on 数据库名.表名 to 用户@主机</li>
<li>撤销用户权限：revoke all on 数据库名.表名 from 用户@主机</li>
</ul>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><h4 id="数据库操作-database"><a href="#数据库操作-database" class="headerlink" title="数据库操作-database"></a>数据库操作-database</h4><ul>
<li><code>SHOW DATABASES;</code> 查询所有数据库（展示）</li>
<li><code>SELECT DATABASE();</code> 查询当前数据库（展示）</li>
<li><code>CREATE DATABASE if not exists name;</code>如果不存在则创建一个名为 name 的数据库，后面可以加<code>default charset + 字符集</code> <code>COLLATE 排序规则</code></li>
<li><code>DROP DATABASE IF EXISTS;</code> 如果存在则删除</li>
<li><code>USE name;</code> 使用名为name的数据库</li>
</ul>
<h4 id="表操作-查询-table"><a href="#表操作-查询-table" class="headerlink" title="表操作-查询 table"></a>表操作-查询 table</h4><ul>
<li><code>SHOW TABLES; </code> </li>
<li><code>DESC 表名;</code> 查询表结构</li>
<li><code>SHOW CREATE TABLE 表名;</code> 查询建表时候的信息</li>
</ul>
<h4 id="表操作-创建-table"><a href="#表操作-创建-table" class="headerlink" title="表操作-创建 table"></a>表操作-创建 table</h4><ul>
<li><p>```sql<br>use itcast;<br>create table tb_user(</p>
<pre><code>id int comment &#39;编号&#39;,
name varchar(50) comment &#39;姓名&#39;,
age int comment &#39;年龄&#39;,
gender varchar(1) comment &#39;性别&#39;
) comment &#39;用户表&#39;;
</code></pre>
<p>desc tb_user;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 表操作- 数据类型</span><br><span class="line"></span><br><span class="line">##### 数值类型：</span><br><span class="line"></span><br><span class="line">TINYINT-byte   SMALLINT-short MEDIUMINT-3 bytes INT/INTEGER-int </span><br><span class="line"></span><br><span class="line">BIGINT-long  FLOAT DOUBLE DECIMAL </span><br><span class="line"></span><br><span class="line">TINYINT UNSIGNED(0-255) 无符号的tinyint</span><br><span class="line"></span><br><span class="line">DOUBLE(4,1)4代表总位数 1代表小数部分的位数 </span><br><span class="line"></span><br><span class="line">##### 字符串类型：</span><br><span class="line"></span><br><span class="line">![image-20240920183842122](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920183842122.png)</span><br><span class="line"></span><br><span class="line">|          | char(10)     | varchar(10) |</span><br><span class="line">| -------- | ------------ | ----------- |</span><br><span class="line">| 最小长度 | 10           | 0           |</span><br><span class="line">| 最大长度 | 10           | 10          |</span><br><span class="line">| eg       | 性别、手机号 | 用户名      |</span><br><span class="line"></span><br><span class="line">##### 日期类型</span><br><span class="line"></span><br><span class="line">![image-20240920184425055](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920184425055.png)</span><br><span class="line"></span><br><span class="line">![image-20240926153912988](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926153912988.png)</span><br><span class="line"></span><br><span class="line">![image-20240926153925471](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926153925471.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 表操作-修改表属性</span><br><span class="line"></span><br><span class="line">**alter table** employee **add** nickname varchar(20) [comment] [约束]; **添加属性**</span><br><span class="line"></span><br><span class="line">**alter table** employee **modify** nickname char(20); **修改数据类型**</span><br><span class="line"></span><br><span class="line">**alter table** employee **change** nickname idCard char(18) [comment] [约束]; **改名字+数据类型** </span><br><span class="line"></span><br><span class="line">**alter table** employee **drop** nickname; **删除** </span><br><span class="line"></span><br><span class="line">**alter table** employee **rename to** emp; **改表名**  </span><br><span class="line"></span><br><span class="line">#### 表操作-删除</span><br><span class="line"></span><br><span class="line">**drop table** [if exists] 表名;   **删除整个表**</span><br><span class="line"></span><br><span class="line">**truncate table** 表名; **删除数据不删表结构**</span><br><span class="line"></span><br><span class="line">#### MySQL GUI</span><br><span class="line"></span><br><span class="line">SQLyog Navicat DataGrip</span><br><span class="line"></span><br><span class="line">### DML</span><br><span class="line"></span><br><span class="line">INSERT UPDATE DELETE </span><br><span class="line"></span><br><span class="line">#### 添加数据</span><br><span class="line"></span><br><span class="line">**insert into** 表名(属性1，属性2....) **values**（v1,v2...）指定属性</span><br><span class="line"></span><br><span class="line">**insert into** 表名 **values**（v1,v2...）所有</span><br><span class="line"></span><br><span class="line">字段和值一一对应，字符串和日期在单引号中</span><br><span class="line"></span><br><span class="line">**多条数据**: **values**</span><br><span class="line"></span><br><span class="line">​		（v1,v2...）,</span><br><span class="line"></span><br><span class="line">​		(v1,v2....) 不同条数据用逗号隔开</span><br><span class="line"></span><br><span class="line">#### 修改数据</span><br><span class="line"></span><br><span class="line">**update** employee **set** name = &#x27;itheima&#x27; **where** id=1;</span><br><span class="line"></span><br><span class="line">#### 删除数据</span><br><span class="line"></span><br><span class="line">**delete from** 表名 [where 条件] 无条件会删除整张表格的数据</span><br><span class="line"></span><br><span class="line">### DQL</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line"></span><br><span class="line">#### 基本查询</span><br><span class="line"></span><br><span class="line">##### 查询多个字段 </span><br><span class="line"></span><br><span class="line">**select** 字段1，字段2........ **from** 表名</span><br><span class="line"></span><br><span class="line">**select * from** 表名       通配符</span><br><span class="line"></span><br><span class="line">##### 设置别名</span><br><span class="line"></span><br><span class="line">**select** 字段1[**as** 别名1]，字段2[**as** 别名2].... **from** 表名 as可省略</span><br><span class="line"></span><br><span class="line">##### 去重</span><br><span class="line"></span><br><span class="line"> **select distinct** ........</span><br><span class="line"></span><br><span class="line">#### 条件查询 WHERE</span><br><span class="line"></span><br><span class="line">![image-20240920211218098](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920211218098.png)</span><br><span class="line"></span><br><span class="line">**select * from** employ where age **in**(12,45,43);</span><br><span class="line"></span><br><span class="line">**select * from** employ where name **like &#x27;__&#x27;**; 名字是两个字符  模糊查询 模糊匹配</span><br><span class="line"></span><br><span class="line">##### sql 模糊查询</span><br><span class="line"></span><br><span class="line">通配符：</span><br><span class="line"></span><br><span class="line">- %: %网% 查询含有网字的数据</span><br><span class="line"></span><br><span class="line">  ​     %网    查询以网字结尾的数据</span><br><span class="line"></span><br><span class="line">  ​      %网%车    查询含有 网 和 车的数据 有先后顺序</span><br><span class="line"></span><br><span class="line">- _ :   网_ 网开头 长度为2个字</span><br><span class="line"></span><br><span class="line">  ​	_ _ 网 长度为3个字 最后一个字是网</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">between and </span><br><span class="line"></span><br><span class="line">in </span><br><span class="line"></span><br><span class="line">is null </span><br><span class="line"></span><br><span class="line">#### 聚合函数 </span><br><span class="line"></span><br><span class="line">![image-20240920212134476](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920212134476.png)</span><br><span class="line"></span><br><span class="line">count(*)所有行 count(age)age非空的行数</span><br><span class="line"></span><br><span class="line">作用在列数据，**null不参与运算~**</span><br><span class="line"></span><br><span class="line">select count(age) from emp where workAddress = &#x27;西安&#x27;; </span><br><span class="line"></span><br><span class="line">位于select关键字之后 可以加where条件</span><br><span class="line"></span><br><span class="line">#### 分组查询 GROUP BY &amp; HAVING</span><br><span class="line"></span><br><span class="line">group by xxx 将具有相同xxx值的行归为一组，每一组执行聚合count  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**select** gender, count(*) **from** emp **&lt;u&gt;group by&lt;/u&gt;** gender;  计算行的数量，并按照gender分组</span><br><span class="line"></span><br><span class="line">- where 分组之前过滤 </span><br><span class="line">- **having** 对分组之后的结果进行过滤</span><br><span class="line">- where 不能对聚合函数判断， having可以，要判断聚合函数就要分完组</span><br><span class="line">- 执行顺序：where&gt;聚合函数&gt;having</span><br><span class="line">- 先用where筛选个体，然后分组，再对组内执行聚合函数，执行的结果可以再用having筛选</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 排序查询 ORDER BY</span><br><span class="line"></span><br><span class="line">ASC:ascending 默认</span><br><span class="line"></span><br><span class="line">DESC:descending</span><br><span class="line"></span><br><span class="line">- 语句的最后，添加 **order by** age **asc**;</span><br><span class="line">- **order by** age **desc** , entryDate; 先按照age降序，如果age相同在按照entryDate升序</span><br><span class="line"></span><br><span class="line">#### 分页查询 LIMIT</span><br><span class="line"></span><br><span class="line">查询xx页码</span><br><span class="line"></span><br><span class="line">LIMIT 起始索引，查询记录数</span><br><span class="line"></span><br><span class="line">每页是20条，第一页的起始数据是0，第二页的20</span><br><span class="line"></span><br><span class="line">limit 0,5 第一页，一页5条记录</span><br><span class="line"></span><br><span class="line">**limit** 5 **offset** 0 第一页 limit 5 offset 20 第五页</span><br><span class="line"></span><br><span class="line">#### 执行顺序</span><br><span class="line"></span><br><span class="line">先执行from 再用where过滤，然后用group by和having指定分组以及过滤，然后执行字段的select，接着是排序，最后分页</span><br><span class="line"></span><br><span class="line">在字段名，表名后加别名，看是否报错，验证上述顺序</span><br><span class="line"></span><br><span class="line">### [多表查询](C:\Users\Lenovo\OneDrive\本学期\数据库原理\多表查询练习.md)</span><br><span class="line"></span><br><span class="line">#### 表关系</span><br><span class="line"></span><br><span class="line">多对多：同一个学生可以选择多门课程，同一个课程也可以被多名学生选择，如果要描述他们之间的关系，添加一张中间表，里面的外键分别对应两张表的主键。</span><br><span class="line"></span><br><span class="line">一对多：多的一方建立外键，关联到少的主键。</span><br><span class="line"></span><br><span class="line">一对一：任意一方建立外键（UNIQUE），关联到另外的主键。</span><br><span class="line"></span><br><span class="line">![image-20241005161911780](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005161911780.png)</span><br><span class="line"></span><br><span class="line">#### 链接查询 JOIN</span><br><span class="line"></span><br><span class="line">##### 消除笛卡尔积</span><br><span class="line"></span><br><span class="line">![image-20241005162327168](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005162327168.png)</span><br><span class="line"></span><br><span class="line">##### 内连接</span><br><span class="line"></span><br><span class="line">只查询A和B相交的部分</span><br><span class="line"></span><br><span class="line">**select** *e*.name,*e*.gender,*d*.dname **from** *emp e*,*dept d* ... **where**    条件 (隐式) </span><br><span class="line"></span><br><span class="line">**select** * **from** *emp* **join** *dept* on     条件（显式）</span><br><span class="line"></span><br><span class="line">##### 外连接</span><br><span class="line"></span><br><span class="line">![image-20241005163112728](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005163112728.png)</span><br><span class="line"></span><br><span class="line">e.* emp的全部数据 </span><br><span class="line"></span><br><span class="line">from *A* left join B 查询*A* ∪ (A∩B)</span><br><span class="line"></span><br><span class="line">from *A* right join B 查询*B* ∪ (A∩B)</span><br><span class="line"></span><br><span class="line">##### 自链接</span><br><span class="line"></span><br><span class="line">一定要起别名</span><br><span class="line"></span><br><span class="line">![image-20241005163553452](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005163553452.png)</span><br><span class="line"></span><br><span class="line">没有必要专门搞一张领导表出来，如果要实现需求就要把一张表分成两张看，a的经理id等于b的id</span><br><span class="line"></span><br><span class="line">![image-20241005163805094](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005163805094.png)</span><br><span class="line"></span><br><span class="line">##### 外键？连接查询？</span><br><span class="line"></span><br><span class="line">在多表查询中，**连接查询**（JOIN）并不强制要求外键的存在。外键的作用是维护表之间的**参照完整性**，确保一张表中的某些值对应另一张表中的有效值。但在进行连接查询时，只要有可以用于关联两个表的字段（如主键和某个相应的列），就可以进行查询，而不需要一定设置外键。</span><br><span class="line"></span><br><span class="line">#### 联合查询</span><br><span class="line"></span><br><span class="line">把两条单表查询结果联合起来，字段数量必须一致</span><br><span class="line"></span><br><span class="line">UNION：自动根据主键去重</span><br><span class="line"></span><br><span class="line">UNION ALL: 不去重</span><br><span class="line"></span><br><span class="line">#### 子查询 按返回值分类</span><br><span class="line"></span><br><span class="line">##### **单行单列**：只返回一个**值** </span><br><span class="line"></span><br><span class="line">- ![image-20241005165024271](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005165024271.png)</span><br><span class="line"></span><br><span class="line">##### **单行多列**：返回的是一行数据</span><br><span class="line"></span><br><span class="line">- ![image-20241005S171121759](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005171121759.png)![image-20241005171132602](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005171132602.png)</span><br><span class="line"></span><br><span class="line">- 第一步返回的是**一行两列**的数据（salary，managerid），第二步的条件可以用where (salary, managerid) = 第一行的结果</span><br><span class="line"></span><br><span class="line">- &lt;a href=&quot;#extension&quot;&gt;多行多列扩展&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### **多行单列**：子查询返回的是多行单列的数据</span><br><span class="line"></span><br><span class="line">也就是同一个字段的值的集合，用括号括起来，最后查询可以如下操作符（操作对象是同一字段的值的集合）</span><br><span class="line"></span><br><span class="line">- in **等于**集合内部的某一个值</span><br><span class="line"></span><br><span class="line">- any/some **大于** any 只需大于最小值 小于any只需小于最大值**相当于存在量词∃** </span><br><span class="line">- all **相当于全称量词∀**</span><br><span class="line"></span><br><span class="line">- ![image-20241005165513314](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005165513314.png)</span><br><span class="line">- ![image-20241005165204726](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005165204726.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### **多行多列**： 虚拟表</span><br><span class="line"></span><br><span class="line">子查询返回的是多行多列数据，也就是虚拟表，从这张虚拟表中再和其他表进行连接查询。</span><br><span class="line"></span><br><span class="line">- **虚拟表**: 查询入职日期 在2011-11-11之后的员工信息和部门信息：先查入职在2011-11-11之后的员工信息，根据这些信息（虚拟表,也叫临时表）和部门表 连接查询</span><br><span class="line"></span><br><span class="line">  - ```sql</span><br><span class="line">    SELECT * FROM (select * from emp where join_date&gt;&#x27;2011-11-11&#x27;)e JOIN dept on e.dep_id = dept.id</span><br></pre></td></tr></table></figure></li>
<li><p><span id="extension"><strong>也可以作为单行多列的扩展</strong></span> in 关键字</p>
<ul>
<li>查询第一步返回的是<strong>多行多列</strong>的数据（salary，managerid），第二步的条件可以用where (salary, managerid) in 第一行的结果</li>
</ul>
</li>
</ul>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>可以直接被另一段程序调用的程序或代码——-常见MySQL内置函数</p>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>concat substring TRIM upper </p>
<p>LPAD(STR, 6, ‘0’) 左对齐，6位补0</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005154345722.png" alt="image-20241005154345722"></p>
<h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><p>ceil floor round rand（0-1随机数）mod</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005154156390.png" alt="image-20241005154156390"></p>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>date_add now curdate curtime datediff</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005154146380.png" alt="image-20241005154146380"></p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005153559225.png" alt="image-20241005153559225"></p>
<p><code>if(expr, caseTrue, caseFalse) expr = true</code> 返回caseTrue</p>
<p><code>ifnull(v1,v2)</code> v1=null 返回v2 空字符串不是null，null必须是什么都没有，v1不为null，则返回v1</p>
<p>case when</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005153230584.png" alt="image-20241005153230584"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005153515232.png" alt="image-20241005153515232"></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>sql</tag>
        <tag>事务</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 进阶篇</title>
    <url>/2024/10/02/MySQL%20%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
    <content><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p>度数：一个节点上面最大的指针数</p>
<p>度数为5，最多5个指针，4个key</p>
<p>当一个节点上面key数超过4，中间节点向上分裂，其余两段分成两个节点，连到上面</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008185901845-1728392950452-1.png" alt="image-20241008185901845"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008185828031-1728392950452-2.png" alt="image-20241008185828031"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008185947095-1728392950452-4.png" alt="image-20241008185947095"></p>
<h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>只有叶子节点存储数据。非叶子节点只有索引的作用</p>
<p>中间节点向上分裂，并且中间节点保留在叶子节点，其余两段分成两个节点连到上面，节点与节点之间通过链表进行连接</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008191613613-1728392950452-3.png" alt="image-20241008191613613"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008191730054-1728392950453-5.png" alt="image-20241008191730054"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008191755751-1728392950453-7.png" alt="image-20241008191755751"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008191802276-1728392950454-9.png" alt="image-20241008191802276"></p>
<p>两个索引中间的指针指向的节点位于这两个索引之间</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008192952009-1728392950453-6.png" alt="image-20241008192952009"></p>
<p>MySQL优化B+Tree<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008193116742-1728392950453-8.png" alt="image-20241008193116742"></p>
<p>段-区-页-行</p>
<h4 id="B-Tree-vs-B-Tree"><a href="#B-Tree-vs-B-Tree" class="headerlink" title="B+Tree vs. B-Tree"></a>B+Tree vs. B-Tree</h4><ul>
<li>都比二叉树层级更少，搜索效率高</li>
<li>B+树因为只有叶子节点能够存储数据，所以非叶子节点能够储存的key和指针数量更多，key和指针数量增多，指向的节点数目也会更多，相同数据量的情况下，需要的层数就比较少，节点数目少了，磁盘IO减少</li>
<li>B树 因为一个节点中存储的指针数目少，所以一个节点只能指向很少的一个节点，相同数据量下需要更多的节点储存指针，层级较深</li>
<li>B+树搜索效率很稳定（数据全在叶子节点上）相比Hash索引，支持了范围匹配和排序操作</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><strong>聚集索引</strong>（key是主键or唯一键or自动隐式生成的rowid）通常键的值以升序排列 底部存储一整行的数据（对应的键值）</p>
<p><strong>二级索引</strong> 通常键的值以字典序排列 底部存储行号（聚集索引的键值 也就是主键值）</p>
<p>select * from tb_user where name = ‘Arm’;</p>
<p>查询时先根据<strong>二级索引</strong>找到对应的行的索引key（主键/唯一键/rowid），然后再根据聚集索引拿到行数据（回<strong>表查询</strong>）</p>
<p>主键查询不需要回表.</p>
<p>InnoDB主键索引的B+树高度：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241011162420695.png" alt="image-20241011162420695"></p>
<p>根据一页数据的大小能够得出一页中能储存几个指针，树高度为2，指向1171个节点，1171个节点一共有1171*16行数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241011162503825.png" alt="image-20241011162503825"></p>
<p>create index on</p>
<p>show index from</p>
<p>drop index on</p>
<h3 id="SQL优化-性能指标"><a href="#SQL优化-性能指标" class="headerlink" title="SQL优化 性能指标"></a>SQL优化 性能指标</h3><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>可以设置 <code>long_query_time</code> 参数，定义什么算作“慢查询”。</p>
<p>输出到文件或者表中</p>
<h4 id="profiles"><a href="#profiles" class="headerlink" title="profiles"></a>profiles</h4><p>通过启用 <code>PROFILE</code>，可以获取查询的执行时间和资源消耗，包括 CPU 使用、锁等待、IO 等信息。</p>
<h4 id="explain-语句-执行计划"><a href="#explain-语句-执行计划" class="headerlink" title="explain +语句 执行计划"></a>explain +语句 执行计划</h4><ul>
<li>const：主键或者唯一索引查询</li>
<li>ref：非唯一索引查询</li>
<li>index，all 性能差</li>
</ul>
<h3 id="索引使用规则"><a href="#索引使用规则" class="headerlink" title="索引使用规则"></a>索引使用规则</h3><h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><ol>
<li><strong>联合索引</strong>：跳过某个，后边的全部失效，使用&gt;=否则后边的失效</li>
<li><strong>函数</strong>：不要对索引的字段用字符串，否则失效</li>
<li><strong>字符串要括起来</strong>：否则失效</li>
<li><strong>模糊</strong>：前面不能模糊，否则失效</li>
<li><strong>OR</strong>：其中一个没索引，剩下的都失效</li>
<li><strong>数据库自行判断：</strong>如果走全表查询比走索引还快，优化器会直接走全表索引</li>
</ol>
<h4 id="覆盖查询（联合索引）"><a href="#覆盖查询（联合索引）" class="headerlink" title="覆盖查询（联合索引）"></a>覆盖查询（联合索引）</h4><p>覆盖查询，联合索引查到了对应的键，也能查到对应的主键值，只查这几列不需要回表，如果多查其他的列就需要到聚集索引处回表查询，性能较慢</p>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>搜索文本时对一些长字符数据没有必要把他们全部都创建索引，而只是截取一部分</p>
<p>算出他们的选择性数据，方法：对email截取不同的长度，去重count再除以总数count</p>
<p>前缀索引，查询字符串先截取前缀，根据前缀进行辅助查询，查到主键id就回表查询拿到整行数据，拿到整行数据以后再进行核实，看字段后半部分是否匹配。一定需要回表查询</p>
<h4 id="单列or联合索引"><a href="#单列or联合索引" class="headerlink" title="单列or联合索引"></a>单列or联合索引</h4><p>or 其中一个没有索引，肯定全都不走索引</p>
<p>都有索引，但是全是单列查询，则只会选择其中一个效率最高进行查询</p>
<p>所以多条件的查询用联合索引，减少回表</p>
<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><ul>
<li>什么样的表要建立索引：数据量超过百万，且查询很频繁</li>
<li>哪些字段建立索引：where group by order by  并且尽量是唯一的，区分度要高</li>
<li>尽量使用联合索引，联合索引很多时候能够覆盖索引，避免回表查询</li>
<li>控制索引数量</li>
<li>如果索引列不能存null，要用非空约束字段</li>
</ul>
<h2 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h2><h3 id="SQL-优化-插入"><a href="#SQL-优化-插入" class="headerlink" title="SQL 优化 - 插入"></a>SQL 优化 - 插入</h3><ol>
<li>一条insert插入多条（insert）<ol>
<li>手动控制事务（事务较为耗费资源）</li>
<li>主键顺序插入</li>
</ol>
</li>
<li>load</li>
</ol>
<h3 id="SQL-优化-主键"><a href="#SQL-优化-主键" class="headerlink" title="SQL 优化 - 主键"></a>SQL 优化 - 主键</h3><ol>
<li>主键顺序插入</li>
<li>主键自增</li>
<li>主键长度尽量小一些，不要用uuid或者身份证号</li>
<li>避免在业务操作时修改主键</li>
</ol>
<h3 id="SQL-优化-order-by"><a href="#SQL-优化-order-by" class="headerlink" title="SQL 优化 - order by"></a>SQL 优化 - order by</h3><ol>
<li>多个条件，使用联合索引，最左前缀</li>
<li>一升一降，需要额外创建独立的索引</li>
<li>覆盖查询，不然仍回表</li>
<li>增大sort_buffer_size(256k default)（不可避免使用filesort时，大数据量）</li>
</ol>
<h3 id="SQL-优化-group-by"><a href="#SQL-优化-group-by" class="headerlink" title="SQL 优化 - group by"></a>SQL 优化 - group by</h3><ol>
<li>多个条件，使用联合索引，最左前缀，需要都出现</li>
<li>肯定是覆盖查询，不然报错</li>
</ol>
<h3 id="SQL-优化-limit"><a href="#SQL-优化-limit" class="headerlink" title="SQL 优化 - limit"></a>SQL 优化 - limit</h3><ol>
<li>覆盖索引加子查询，先覆盖查询主键，根据返回的数据进行select *  </li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241015190857506.png" alt="image-20241015190857506"></p>
<p>不支持in后加limit，就可以联合两张表查询，只返回满足id相同条件的数据</p>
<ol>
<li><strong>延迟关联 (INNER JOIN)</strong>: 使用 <code>INNER JOIN</code> 将分页操作转移到主键索引上，减少回表次数。相比子查询，延迟关联的性能更优，适合大数据量的分页查询。</li>
<li><strong>覆盖索引</strong>: 通过索引直接获取所需字段，避免回表操作，减少 IO 开销，适合查询特定字段的场景。但当结果集较大时，MySQL 可能会选择全表扫描。</li>
</ol>
<h3 id="SQL-优化-count-优化"><a href="#SQL-优化-count-优化" class="headerlink" title="SQL 优化 - count 优化"></a>SQL 优化 - count 优化</h3><ul>
<li><p>MyISAM：可以直接读取</p>
</li>
<li><p>InnoDB：只能逐行读取，只能借助Redis等</p>
</li>
</ul>
<ul>
<li><p>count(字段)会判断是否为非空，如果没有非空约束，会把每一行的字段值都取出来，服务器判断是否为null，不为null计数累加。如果有非空约束，不用判断null直接累加。如果是主键，直接累加</p>
</li>
<li><p>count(1) count(*) 都是遍历整张表但是不取值，按照行进行累加</p>
</li>
</ul>
<h3 id="SQL-优化-update-优化"><a href="#SQL-优化-update-优化" class="headerlink" title="SQL 优化 - update 优化"></a>SQL 优化 - update 优化</h3><p>update利用了索引，行锁</p>
<p>如果没有利用索引，就要加表锁，因为行锁是根据索引加的，而且索引不能失效</p>
<h2 id="视图、存储过程、触发器"><a href="#视图、存储过程、触发器" class="headerlink" title="视图、存储过程、触发器"></a>视图、存储过程、触发器</h2><p>视图就是给子查询起了个名字，然后作为对象存储到数据库中</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>整个数据库的锁，用于全库备份</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>释放：事务提交</p>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>特点：手动开关</p>
<h5 id="S-共享读锁"><a href="#S-共享读锁" class="headerlink" title="S 共享读锁"></a>S 共享读锁</h5><p>​    所有事务都能读，但都不能写</p>
<h5 id="X-独占写锁"><a href="#X-独占写锁" class="headerlink" title="X 独占写锁"></a>X 独占写锁</h5><p>​    只有当前事务能读写，其他事务都不能读写 </p>
<h4 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h4><p>特点：自动</p>
<p>执行DML, DQL语句会自动加共享SHARED READ/WRITE锁，</p>
<p>执行DDL语句会自动加EXCLUSIVE锁，与上述的锁不兼容。</p>
<p><strong>锁的兼容性</strong>指的是不同类型的锁在同一数据对象（如表或行）上是否可以同时存在的特性，即两个或多个事务能否同时持有某种锁类型，而不会发生冲突或阻塞。</p>
<p>一个事务进行读操作，自动给表加上了共享读锁，另一个事务要改变表结构，此时这个事务想加上独占写的元数据锁，但是因为互相不兼容，所以只能阻塞等待直到另一个事务提交</p>
<h4 id="意向锁-解决行锁表锁冲突"><a href="#意向锁-解决行锁表锁冲突" class="headerlink" title="意向锁 解决行锁表锁冲突"></a>意向锁 解决行锁表锁冲突</h4><p>某个事务DML加行锁，另一个事务来加表锁的时候，要逐行扫描是否有行锁才能加上，性能较低。</p>
<p>因此引入了意向锁，DML加行锁同时对表加了意向写锁(IX)，另一个事务想加表锁，但是IX和常规的表锁不兼容，所以会阻塞等待。</p>
<p><strong>Intention Lock</strong></p>
<h5 id="IX"><a href="#IX" class="headerlink" title="IX"></a><u>IX</u></h5><ul>
<li><code>insert</code>、<code>update</code>、<code>delete </code>(DML自动添加)</li>
<li><code>select...for update</code> (表示查询加行级排他锁)</li>
</ul>
<h5 id="IS"><a href="#IS" class="headerlink" title="IS"></a><u>IS</u></h5><ul>
<li><code>select ... lock in share mode</code>(表示查询加行级共享锁)</li>
</ul>
<p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>IX：加行锁的同时会自动加IX</p>
<p>IS：DQL后边加<code>Lock in share mode</code>表示手动加了IS</p>
<h4 id="表锁兼容性矩阵"><a href="#表锁兼容性矩阵" class="headerlink" title="表锁兼容性矩阵"></a>表锁兼容性矩阵</h4><table>
<thead>
<tr>
<th></th>
<th>共享锁 (S)</th>
<th>独占锁 (X)</th>
<th>意向共享锁 (IS)</th>
<th>意向独占锁 (IX)</th>
</tr>
</thead>
<tbody><tr>
<td>S</td>
<td>O</td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>IS</td>
<td>O</td>
<td>X</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>IX</td>
<td>X</td>
<td>X</td>
<td>O</td>
<td>O</td>
</tr>
</tbody></table>
<h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>InnoDB存储引擎，并发度高</p>
<p>行级锁是针对索引对行加的锁，事务提交后会释放</p>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017194645333.png" alt="image-20241017194645333"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017194802298.png" alt="image-20241017194802298"></p>
<p>DML自动加行级排他锁，自动加表级意向排他锁(IX)</p>
<p>DQL+<code>for update</code> 加行级排他锁，自动加IX</p>
<p>DQL+<code>lock in share mode</code> 加共享锁，自动加IS</p>
<p>IX 和 IS 就是行锁在表级锁中的一种呈现形式</p>
<ul>
<li><p>默认可重复读(RR)，使用 Next-Key 锁 进行搜索和索引扫描，防止幻读。</p>
</li>
<li><p>针对唯一索引进行检索，对已存在的记录等值匹配，自动优化为行锁（详见下文）</p>
<ul>
<li><p>当你执行以下查询时：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email <span class="operator">=</span> <span class="string">&#x27;example@example.com&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>数据库会使用唯一索引快速找到这条记录。</li>
<li>然后，它会在找到的记录上加上行锁，确保其他事务无法修改或删除该行，直到当前事务提交。</li>
<li>由于只锁定了这一行，而不是整个表，其他事务仍然可以并发读取或修改表中的其他记录。</li>
</ul>
</li>
</ul>
</li>
<li><p><u>行锁是针对索引</u>加的，<strong>如果定位数据时不使用索引，</strong>如果此时加锁(除了普通的select查询都会加)那么会对表中所有记录都加上锁，此时<strong>升级为表锁</strong> </p>
</li>
</ul>
<p>由于锁的兼容性，行锁会影响另一个事务的DML以及加后缀的DQL。同时也会影响普通的DQL，除非使用RU隔离级别，否则另一个事务的普通DQL也会阻塞</p>
<h4 id="间隙、临键锁"><a href="#间隙、临键锁" class="headerlink" title="间隙、临键锁"></a>间隙、临键锁</h4><p>InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p>
<ul>
<li><strong>记录锁（Record Lock）</strong>：也被称为记录锁，属于单个行记录上的锁。</li>
<li><strong>间隙锁（Gap Lock）</strong>：锁定一个记录之前的范围，不包括记录本身。防止其他事务<strong>插入</strong>间隙，间隙锁之间可以共存</li>
<li><strong>临键锁（Next-Key Lock）</strong>：Record Lock + Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>
</ul>
<p>在 InnoDB 默认的隔离级别 <strong>REPEATABLE-READ</strong> 下，行锁默认使用的是 <strong>Next-Key Lock</strong>。但是，如果操作的索引是唯一索引或主键的等值查询，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock 或 Gap Lock。</p>
<p><strong>省流</strong>：</p>
<ul>
<li><p>查找过程中访问到的才会被加锁，遍历停止时访问的那个不符合条件的行也要加锁，默认加NextKeyLock。</p>
</li>
<li><p><strong>唯一索引的等值查询</strong>，存在加RecordLock，不存在加右边界的GapLock</p>
</li>
<li><p><strong>唯一索引的范围查询</strong> 或者 <strong>普通索引的查询</strong> 这些查询包含向右遍历，如果出现<strong>唯一索引的等值查询</strong>，加对应的RecordLock，其他被遍历到的都是Next-keyLock，出现正无穷加正无穷的Next-KeyLock</p>
</li>
<li><p>特别地，对于 <strong>唯一索引的范围查询</strong> 或者 <strong>普通索引等值查询</strong> ，遍历停止时访问的那个不符合条件的行，这一行的NextKeyLock会退化为GapLock</p>
</li>
</ul>
<h3 id="行级锁-加锁范围验证"><a href="#行级锁-加锁范围验证" class="headerlink" title="行级锁 加锁范围验证"></a>行级锁 加锁范围验证</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017215201503.png" alt="image-20241017215201503"></p>
<p>X 对应 默认的 Next-key Lock</p>
<p>X, REC_NOT_GAP 对应 Record Lock</p>
<p>X, GAP 对应 Gap Lock </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_t_a <span class="keyword">on</span> t(a);</span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> INDEX_NAME, LOCK_MODE,LOCK_STATUS,LOCK_DATA <span class="keyword">from</span> performance_schema.data_locks;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;  <span class="comment">-- 主键等值查询 存在</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">9</span> <span class="keyword">for</span> <span class="keyword">update</span>;   <span class="comment">-- 主键等值查询 不存在</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">15</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">-- 主键范围查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;   <span class="comment">-- 普通索引等值查询</span></span><br></pre></td></tr></table></figure>



<h4 id="主键等值查询-——-数据存在"><a href="#主键等值查询-——-数据存在" class="headerlink" title="主键等值查询 —— 数据存在"></a>主键等值查询 —— 数据存在</h4><p>查询 id = 10 REC_NOT_GAP</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017223439818.png" alt="image-20241017223439818"></p>
<p>对主键等值加锁，且值存在，临键锁退化为Record，锁住10这条记录</p>
<h4 id="主键等值查询-——-数据不存在"><a href="#主键等值查询-——-数据不存在" class="headerlink" title="主键等值查询 —— 数据不存在"></a>主键等值查询 —— 数据不存在</h4><p>查询 id = 9 GAP</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017223354241.png" alt="image-20241017223354241"></p>
<p>对主键等值加锁，值不存在，临键锁退化为Gap，锁住了10之前的间隙</p>
<h4 id="主键范围查询"><a href="#主键范围查询" class="headerlink" title="主键范围查询"></a>主键范围查询</h4><ol>
<li>查找id&gt;=10 有10,11,12,15,20满足条件</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017224916640.png" alt="image-20241017224916640"></p>
<p>10是等值查询，会退化成Record，其他都是NextKey，还有一个正无穷的NextKey</p>
<ol start="2">
<li>查找id在[10,15) 之间 </li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017230538715.png" alt="image-20241017230538715"></p>
<p>10是等值查询，退化Record，其他都是临键，查到15的时候不符合, 15退化为Gap</p>
<h4 id="普通索引等值查询"><a href="#普通索引等值查询" class="headerlink" title="普通索引等值查询"></a>普通索引等值查询</h4><p>查询 a = 10 一共三条符合的记录 id = 10,11,12 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017222539070.png" alt="image-20241017222539070"></p>
<ul>
<li>对于idx_t_a这个索引，加了四把锁，其中符合条件的3行都是nextKey(也就是默认的行锁)，检索到第一个不符合条件的行 （15,15）nextKey退化成GAP间隙</li>
<li>对于主键，所有的nextKey都退化成Record Lock</li>
</ul>
<p>不存在：查询 a = 9 只有Gap</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017235509444.png" alt="image-20241017235509444"></p>
<h4 id="普通索引范围查询"><a href="#普通索引范围查询" class="headerlink" title="普通索引范围查询"></a>普通索引范围查询</h4><p>查询 a &gt;= 10</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018000157308.png" alt="image-20241018000157308"></p>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Mindmap.png" alt="MindMap"></p>
<h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><p>在事务开始前和结束后，数据库的状态必须一致。InnoDB 在事务提交时会检查所有约束（如外键、唯一性约束），确保数据的完整性和<strong>一致性</strong>。</p>
<h4 id="RedoLog-持久性"><a href="#RedoLog-持久性" class="headerlink" title="RedoLog - 持久性"></a>RedoLog - 持久性</h4><ul>
<li>产生：更新数据之后，事务提交之时</li>
<li>销毁：数据成功刷新到磁盘之时</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029174344508-1730195209915-1.png" alt="image-20241029174344508"></p>
<ul>
<li><p>BufferPool中的脏页会定期刷新到磁盘中，如果写入磁盘失败，则会导致事务提交了，磁盘中的数据却没改变。</p>
</li>
<li><p>BufferPool首先把当次事务的<u>修改存入</u>RedoLogBuffer，RedoLogBuffer会刷新到磁盘中的RedoLogFile，然后过一段时间会将BP中的脏页刷新到磁盘中，如果写入失败，可以通过磁盘中的RedoLogFile恢复数据。</p>
</li>
</ul>
<p><strong>为什么不直接刷新到磁盘中</strong>？因为磁盘随机IO太慢，而日志文件是顺序IO，快得多（Write-Ahead Logging）先写日志，再刷新，并且WAL能够防止还没有刷盘就崩溃的情况。</p>
<p>重做日志记录的是数据页的具体变化<u>（物理修改）</u>，而不是 SQL 语句或逻辑操作，例如页的写入、删除或更新。这种方式确保了在崩溃恢复时，能够准确地重放这些操作，从而恢复数据到一致的状态。物理修改在执行时通常更高效。</p>
<p><mark>物理日志<mark></p>
<h4 id="UndoLog-原子性"><a href="#UndoLog-原子性" class="headerlink" title="UndoLog - 原子性"></a>UndoLog - 原子性</h4><ul>
<li>产生：事务执行具体SQL语句时</li>
<li>销毁：事务未提交时可以用于回滚，事务提交以后也不会立即删除，<strong>用于MVCC</strong> </li>
</ul>
<ul>
<li><mark>逻辑日志<mark>，是具体的SQL语句（反向）</li>
<li>事务Rollback时会从UndoLog读取逻辑语句并执行</li>
</ul>
<ul>
<li>存储在 表空间的 rollback segment 段中</li>
</ul>
<p>表空间TableSpaces-&gt;段Segment-&gt;区Extent-&gt;页Page-&gt;行Row</p>
<h3 id="MVCC-隔离性"><a href="#MVCC-隔离性" class="headerlink" title="MVCC - 隔离性"></a>MVCC - 隔离性</h3><p><strong>M</strong>ulti<strong>V</strong>ersion <strong>C</strong>oncurrency <strong>C</strong>ontrol</p>
<h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>读取数据的当前版本（最新版本），读取时要加锁</p>
<h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>读取的是记录数据的可见版本，不加锁</p>
<ul>
<li>Read Committed：每次select都生成一个快照读</li>
<li>Repeatable Read：开启事务以后的首个select才是快照读</li>
<li>Serializable：快照读退化为当前读</li>
</ul>
<p>MySQL用MVCC实现了一致性非锁定读，读操作只读该事务开始前的数据库的快照，也就是快照读（与当前读相对）</p>
<p>事务隔离级别越低，对应的锁就越少，MySQL用MVCC减少了高并发情况下锁的数量，也就是说默认的RR对性能没有影响</p>
<h4 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h4><p>TRX_ID 最后一次事务ID</p>
<p>ROLL_PTR 指向undolog</p>
<p>ROW_ID 如果没有主键会对每一行生成rowID</p>
<h4 id="利用-UndoLog"><a href="#利用-UndoLog" class="headerlink" title="利用 UndoLog"></a>利用 UndoLog</h4><h5 id="生成UndoLog"><a href="#生成UndoLog" class="headerlink" title="生成UndoLog"></a>生成UndoLog</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018150130329.png" alt="image-20241018150130329"></p>
<h5 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h5><p>事务对记录进行修改，会在Undolog生成对应的undo备份，事务对同一条记录进行修改，会在Undolog中生成一条版本链，链表尾部是最早的旧版本，链表头部是最新的旧版本，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018151050435.png" alt="image-20241018151050435"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018151107149.png" alt="image-20241018151107149"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018151128340.png" alt="image-20241018151128340"></p>
<h4 id="ReadView-amp-数据可见性算法"><a href="#ReadView-amp-数据可见性算法" class="headerlink" title="ReadView &amp; 数据可见性算法"></a>ReadView &amp; 数据可见性算法</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018161558601.png" alt="image-20241018161558601"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/trans_visible-ekj9bMvL.png" alt="trans_visible"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018205730125.png" alt="image-20241018205730125"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018161738996.png" alt="image-20241018161738996"></p>
<h4 id="RC-amp-RR-解决并发事务引发的问题"><a href="#RC-amp-RR-解决并发事务引发的问题" class="headerlink" title="RC &amp; RR 解决并发事务引发的问题"></a>RC &amp; RR 解决并发事务引发的问题</h4><p><mark><u>1. MVCC 通过 ReadView 的数据可见性算法 只会读取其他事务已提交的信息，完全避免了脏读</u><mark> </p>
<p><strong>RC</strong>：避免脏读（读已提交）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018155530221.png" alt="image-20241018155530221"></p>
<p><code>mIDs</code>包含活跃事务，<code>maxID</code>当前最大事务ID+1，<code>minID</code>最小活跃事务ID，<code>trxID</code>当前所浏览版本所属的事务ID</p>
<ol>
<li><code>trxID</code> =<code> create_trxID</code>  自己改的的肯定能读</li>
<li><code>trxID </code>&gt;= <code>maxID</code> 说明事务在快照创建之后才修改的，数据没有参考价值，不能读。</li>
<li><code>trxID </code>&lt;<code>maxID</code>说明事务在快照创建之前修改的，有参考价值，不在活跃列表中的就是已提交了</li>
<li><code>trxID</code> &lt; <code>minID</code>  肯定不在活跃列表，读<strong>已提交</strong>。</li>
<li><code>trxID</code>∈[<code>minID</code>,<code>maxID</code>) 说明事务在快照创建之前修改的，但不知道提交了没有。<ul>
<li>在<code>mIDs</code>中，说明还活跃着没有提交，不能读    </li>
<li>不在<code>mIDs</code>中，说明<strong>已提交</strong></li>
</ul>
</li>
<li><code>mIDs</code>为空，可读</li>
</ol>
<p><code>Read View</code>在SQL执行结束后自动销毁，下次生成新的</p>
<p><mark><a href="https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html#mvcc-%E8%A7%A3%E5%86%B3%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%97%AE%E9%A2%98">2. MVCC 通过设置同一事务复用 ReadView 完全避免了不可重复读问题 </a><mark> </p>
<p><strong>RR</strong>：注意——RR是可以读已提交的，RR是用来解决不可重复读的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018155805136.png" alt="image-20241018155805136"></p>
<p>同一个事务的<code>Read View</code>相同，后开启的事务修改肯定不会去读，只会按照同一个<code>Read View</code>读版本链</p>
<ul>
<li>事务5第一次读，事务3修改了但还没提交，最后选择事务2的版本，生成的<code>Read View</code>不会马上销毁</li>
<li>事务5第二次读，复用之前的<code>Read View</code>，最重要的是记录了<strong>活跃事务列表</strong> <code>mIds</code>，即使事务3提交了，</li>
</ul>
<p><u><mark>3. MVCC 如何解决幻读问题？<mark></u> </p>
<ol>
<li>执行普通select语句，MVCC会使用快照读。RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”。</li>
<li>对于当前读，通过设置Next-Key Lock，将间隙也锁住，阻塞其他事务插入数据，防止插入，幻读也就不会出现。</li>
</ol>
<p>没法防止的幻读：</p>
<p>事务A第一次查询id=5没查到，事务B此时插入了id=5并提交了，事务A为了维持可重复读第二次依然查不到5，但是此时事务A插入5会失败，update id = 5会成功，试图select for update也会成功，好像出现了幻觉，只能改变隔离模式为 Serializable </p>
<p>MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生，</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>日志</tag>
        <tag>事务</tag>
        <tag>b+ tree</tag>
        <tag>索引</tag>
        <tag>sql优化</tag>
        <tag>锁</tag>
        <tag>inoodb</tag>
        <tag>mvcc</tag>
        <tag>redolog</tag>
        <tag>undolog</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 非阻塞 IO 和异步 IO(转自Javadoop)</title>
    <url>/2018/02/27/NIO%20AIO/</url>
    <content><![CDATA[<p>上一篇文章介绍了 Java NIO 中 Buffer、Channel 和 Selector 的基本操作，主要是一些接口操作，比较简单。</p>
<p>本文将介绍<strong>非阻塞 IO</strong> 和<strong>异步 IO</strong>，也就是大家耳熟能详的 NIO 和 AIO。很多初学者可能分不清楚异步和非阻塞的区别，只是在各种场合能听到<strong>异步非阻塞</strong>这个词。</p>
<p>本文会先介绍并演示阻塞模式，然后引入非阻塞模式来对阻塞模式进行优化，最后再介绍 JDK7 引入的异步 IO，由于网上关于异步 IO 的介绍相对较少，所以这部分内容我会介绍得具体一些。</p>
<p>希望看完本文，读者可以对非阻塞 IO 和异步 IO 的迷雾看得更清晰些，或者为初学者解开一丝丝疑惑也是好的。</p>
<!-- toc -->

<h2 id="阻塞模式-IO"><a href="#阻塞模式-IO" class="headerlink" title="阻塞模式 IO"></a>阻塞模式 IO</h2><p>我们已经介绍过使用 Java NIO 包组成一个简单的<strong>客户端-服务端</strong>网络通讯所需要的 ServerSocketChannel、SocketChannel 和 Buffer，我们这里整合一下它们，给出一个完整的可运行的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听 8080 端口进来的 TCP 链接</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里会阻塞，直到有一个请求的连接进来</span></span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开启一个新的线程来处理这个请求，然后在 while 循环中继续监听 8080 端口</span></span><br><span class="line">            <span class="type">SocketHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SocketHandler</span>(socketChannel);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(handler).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里看一下新的线程需要做什么，SocketHandler：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SocketHandler</span><span class="params">(SocketChannel socketChannel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socketChannel = socketChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将请求数据读入 Buffer 中</span></span><br><span class="line">            <span class="type">int</span> num;</span><br><span class="line">            <span class="keyword">while</span> ((num = socketChannel.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 读取 Buffer 内容之前先 flip 一下</span></span><br><span class="line">                buffer.flip();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 提取 Buffer 中的数据</span></span><br><span class="line">                <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[num];</span><br><span class="line">                buffer.get(bytes);</span><br><span class="line"></span><br><span class="line">                <span class="type">String</span> <span class="variable">re</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;收到请求：&quot;</span> + re);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 回应客户端</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">writeBuffer</span> <span class="operator">=</span> ByteBuffer.wrap((<span class="string">&quot;我已经收到你的请求，你的请求内容是：&quot;</span> + re).getBytes());</span><br><span class="line">                socketChannel.write(writeBuffer);</span><br><span class="line"></span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            IOUtils.closeQuietly(socketChannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，贴一下客户端 SocketChannel 的使用，客户端比较简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketChannelTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送请求</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;1234567890&quot;</span>.getBytes());</span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取响应</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="keyword">if</span> ((num = socketChannel.read(readBuffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            readBuffer.flip();</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] re = <span class="keyword">new</span> <span class="title class_">byte</span>[num];</span><br><span class="line">            readBuffer.get(re);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(re, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;返回值: &quot;</span> + result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面介绍的阻塞模式的代码应该很好理解：来一个新的连接，我们就新开一个线程来处理这个连接，之后的操作全部由那个线程来完成。</p>
<p>那么，这个模式下的性能瓶颈在哪里呢？</p>
<ol>
<li>首先，每次来一个连接都开一个新的线程这肯定是不合适的。当活跃连接数在几十几百的时候当然是可以这样做的，但如果活跃连接数是几万几十万的时候，这么多线程明显就不行了。每个线程都需要一部分内存，内存会被迅速消耗，同时，线程切换的开销非常大。</li>
<li>其次，阻塞操作在这里也是一个问题。首先，accept() 是一个阻塞操作，当 accept() 返回的时候，代表有一个连接可以使用了，我们这里是马上就新建线程来处理这个 SocketChannel 了，但是，但是这里不代表对方就将数据传输过来了。所以，SocketChannel#read 方法将阻塞，等待数据，明显这个等待是不值得的。同理，write 方法也需要等待通道可写才能执行写入操作，这边的阻塞等待也是不值得的。</li>
</ol>
<h2 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h2><p>说完了阻塞模式的使用及其缺点以后，我们这里就可以介绍非阻塞 IO 了。</p>
<p>非阻塞 IO 的核心在于使用一个 Selector 来管理多个通道，可以是 SocketChannel，也可以是 ServerSocketChannel，将各个通道注册到 Selector 上，指定监听的事件。</p>
<p>之后可以只用一个线程来轮询这个 Selector，看看上面是否有通道是准备好的，当通道准备好可读或可写，然后才去开始真正的读写，这样速度就很快了。我们就完全没有必要给每个通道都起一个线程。</p>
<p>NIO 中 Selector 是对底层操作系统实现的一个抽象，管理通道状态其实都是底层系统实现的，这里简单介绍下在不同系统下的实现。</p>
<p><strong>select</strong>：上世纪 80 年代就实现了，它支持注册 FD_SETSIZE(1024) 个 socket，在那个年代肯定是够用的，不过现在嘛，肯定是不行了。</p>
<p><strong>poll</strong>：1997 年，出现了 poll 作为 select 的替代者，最大的区别就是，poll 不再限制 socket 数量。</p>
<p>select 和 poll 都有一个共同的问题，那就是<strong>它们都只会告诉你有几个通道准备好了，但是不会告诉你具体是哪几个通道</strong>。所以，一旦知道有通道准备好以后，自己还是需要进行一次扫描，显然这个不太好，通道少的时候还行，一旦通道的数量是几十万个以上的时候，扫描一次的时间都很可观了，时间复杂度 O(n)。所以，后来才催生了以下实现。</p>
<p><strong>epoll</strong>：2002 年随 Linux 内核 2.5.44 发布，epoll 能直接返回具体的准备好的通道，时间复杂度 O(1)。</p>
<p>除了 Linux 中的 epoll，2000 年 FreeBSD 出现了 <strong>Kqueue</strong>，还有就是，Solaris 中有 <strong>/dev/poll</strong>。</p>
<blockquote>
<p>前面说了那么多实现，但是没有出现 Windows，Windows 平台的非阻塞 IO 使用 select，我们也不必觉得 Windows 很落后，在 Windows 中 IOCP 提供的异步 IO 是比较强大的。</p>
</blockquote>
<p>我们回到 Selector，毕竟 JVM 就是这么一个屏蔽底层实现的平台，<strong>我们面向 Selector 编程就可以了</strong>。</p>
<p>之前在介绍 Selector 的时候已经了解过了它的基本用法，这边来一个可运行的实例代码，大家不妨看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectorServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        server.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将其注册到 Selector 中，监听 OP_ACCEPT 事件</span></span><br><span class="line">        server.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">readyChannels</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            <span class="keyword">if</span> (readyChannels == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;SelectionKey&gt; readyKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">// 遍历</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = readyKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">// 有已经接受的新的到服务端的连接</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> server.accept();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 有新的连接并不代表这个通道就有数据，</span></span><br><span class="line">                    <span class="comment">// 这里将这个新的 SocketChannel 注册到 Selector，监听 OP_READ 事件，等待数据</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">// 有数据可读</span></span><br><span class="line">                    <span class="comment">// 上面一个 if 分支中注册了监听 OP_READ 事件的 SocketChannel</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> socketChannel.read(readBuffer);</span><br><span class="line">                    <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 处理进来的数据...</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;收到数据：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(readBuffer.array()).trim());</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;返回给客户端的数据...&quot;</span>.getBytes());</span><br><span class="line">                        socketChannel.write(buffer);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// -1 代表连接已经关闭</span></span><br><span class="line">                        socketChannel.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于客户端，大家可以继续使用上一节介绍阻塞模式时的客户端进行测试。</p>
<h2 id="NIO-2-异步-IO"><a href="#NIO-2-异步-IO" class="headerlink" title="NIO.2 异步 IO"></a>NIO.2 异步 IO</h2><p>More New IO，或称 NIO.2，随 JDK 1.7 发布，包括了引入异步 IO 接口和 Paths 等文件访问接口。</p>
<p>异步这个词，我想对于绝大多数开发者来说都很熟悉，很多场景下我们都会使用异步。</p>
<p>通常，我们会有一个线程池用于执行异步任务，提交任务的线程将任务提交到线程池就可以立马返回，不必等到任务真正完成。如果想要知道任务的执行结果，通常是通过传递一个回调函数的方式，任务结束后去调用这个函数。</p>
<p>同样的原理，Java 中的异步 IO 也是一样的，都是由一个线程池来负责执行任务，然后使用回调或自己去查询结果。</p>
<p>大部分开发者都知道为什么要这么设计了，这里再啰嗦一下。异步 IO 主要是为了控制线程数量，减少过多的线程带来的内存消耗和 CPU 在线程调度上的开销。</p>
<p><strong>在 Unix/Linux 等系统中，JDK 使用了并发包中的线程池来管理任务</strong>，具体可以查看 AsynchronousChannelGroup 的源码。</p>
<p>在 Windows 操作系统中，提供了一个叫做 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365198.aspx">I/O Completion Ports</a> 的方案，通常简称为 <strong>IOCP</strong>，操作系统负责管理线程池，其性能非常优异，所以<strong>在 Windows 中 JDK 直接采用了 IOCP 的支持</strong>，使用系统支持，把更多的操作信息暴露给操作系统，也使得操作系统能够对我们的 IO 进行一定程度的优化。</p>
<blockquote>
<p>在 Linux 中其实也是有异步 IO 系统实现的，但是限制比较多，性能也一般，所以 JDK 采用了自建线程池的方式。</p>
</blockquote>
<p>本文还是以实用为主，想要了解更多信息请自行查找其他资料，下面对 Java 异步 IO 进行实践性的介绍。</p>
<p>总共有三个类需要我们关注，分别是 <strong>AsynchronousSocketChannel</strong>，<strong>AsynchronousServerSocketChannel</strong> 和 <strong>AsynchronousFileChannel</strong>，只不过是在之前介绍的 FileChannel、SocketChannel 和 ServerSocketChannel 的类名上加了个前缀 <strong>Asynchronous</strong>。</p>
<p>Java 异步 IO 提供了两种使用方式，分别是返回 Future 实例和使用回调函数。</p>
<h3 id="1、返回-Future-实例"><a href="#1、返回-Future-实例" class="headerlink" title="1、返回 Future 实例"></a>1、返回 Future 实例</h3><p>返回 java.util.concurrent.Future 实例的方式我们应该很熟悉，JDK 线程池就是这么使用的。Future 接口的几个方法语义在这里也是通用的，这里先做简单介绍。</p>
<ul>
<li><p>future.isDone();</p>
<p>判断操作是否已经完成，包括了<strong>正常完成、异常抛出、取消</strong></p>
</li>
<li><p>future.cancel(true);</p>
<p>取消操作，方式是中断。参数 true 说的是，即使这个任务正在执行，也会进行中断。</p>
</li>
<li><p>future.isCancelled();</p>
<p>是否被取消，只有在任务正常结束之前被取消，这个方法才会返回 true</p>
</li>
<li><p>future.get(); </p>
<p>这是我们的老朋友，获取执行结果，阻塞。</p>
</li>
<li><p>future.get(10, TimeUnit.SECONDS);</p>
<p>如果上面的 get() 方法的阻塞你不满意，那就设置个超时时间。</p>
</li>
</ul>
<h3 id="2、提供-CompletionHandler-回调函数"><a href="#2、提供-CompletionHandler-回调函数" class="headerlink" title="2、提供 CompletionHandler 回调函数"></a>2、提供 CompletionHandler 回调函数</h3><p>java.nio.channels.CompletionHandler 接口定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CompletionHandler</span>&lt;V,A&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(V result, A attachment)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, A attachment)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，参数上有个 attachment，虽然不常用，我们可以在各个支持的方法中传递这个参数值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AsynchronousServerSocketChannel</span> <span class="variable">listener</span> <span class="operator">=</span> AsynchronousServerSocketChannel.open().bind(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// accept 方法的第一个参数可以传递 attachment</span></span><br><span class="line">listener.accept(attachment, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(</span></span><br><span class="line"><span class="params">      AsynchronousSocketChannel client, Object attachment)</span> &#123;</span><br><span class="line">          <span class="comment">// </span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Object attachment)</span> &#123;</span><br><span class="line">          <span class="comment">// </span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="AsynchronousFileChannel"><a href="#AsynchronousFileChannel" class="headerlink" title="AsynchronousFileChannel"></a>AsynchronousFileChannel</h3><p>网上关于 Non-Blocking IO 的介绍文章很多，但是 Asynchronous IO 的文章相对就少得多了，所以我这边会多介绍一些相关内容。</p>
<p>首先，我们就来关注异步的文件 IO，前面我们说了，文件 IO 在所有的操作系统中都不支持非阻塞模式，但是我们可以对文件 IO 采用异步的方式来提高性能。</p>
<p>下面，我会介绍 AsynchronousFileChannel 里面的一些重要的接口，都很简单，读者要是觉得无趣，直接滑到下一个标题就可以了。</p>
<p>实例化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AsynchronousFileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> AsynchronousFileChannel.open(Paths.get(<span class="string">&quot;/Users/hongjie/test.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>一旦实例化完成，我们就可以着手准备将数据读入到 Buffer 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">Future&lt;Integer&gt; result = channel.read(buffer, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>异步文件通道的读操作和写操作都需要提供一个文件的开始位置，文件开始位置为 0</p>
</blockquote>
<p>除了使用返回 Future 实例的方式，也可以采用回调函数进行操作，接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> &lt;A&gt; <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(ByteBuffer dst,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> position,</span></span><br><span class="line"><span class="params">                              A attachment,</span></span><br><span class="line"><span class="params">                              CompletionHandler&lt;Integer,? <span class="built_in">super</span> A&gt; handler)</span>;</span><br></pre></td></tr></table></figure>

<p>顺便也贴一下写操作的两个版本的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Future&lt;Integer&gt; <span class="title function_">write</span><span class="params">(ByteBuffer src, <span class="type">long</span> position)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> &lt;A&gt; <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ByteBuffer src,</span></span><br><span class="line"><span class="params">                               <span class="type">long</span> position,</span></span><br><span class="line"><span class="params">                               A attachment,</span></span><br><span class="line"><span class="params">                               CompletionHandler&lt;Integer,? <span class="built_in">super</span> A&gt; handler)</span>;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，AIO 的读写主要也还是与 Buffer 打交道，这个与 NIO 是一脉相承的。</p>
<p>另外，还提供了用于将内存中的数据刷入到磁盘的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">force</span><span class="params">(<span class="type">boolean</span> metaData)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为我们对文件的写操作，操作系统并不会直接针对文件操作，系统会缓存，然后周期性地刷入到磁盘。如果希望将数据及时写入到磁盘中，以免断电引发部分数据丢失，可以调用此方法。参数如果设置为 true，意味着同时也将文件属性信息更新到磁盘。</p>
</blockquote>
<p>还有，还提供了对文件的锁定功能，我们可以锁定文件的部分数据，这样可以进行排他性的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Future&lt;FileLock&gt; <span class="title function_">lock</span><span class="params">(<span class="type">long</span> position, <span class="type">long</span> size, <span class="type">boolean</span> shared)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>position 是要锁定内容的开始位置，size 指示了要锁定的区域大小，shared 指示需要的是共享锁还是排他锁</p>
</blockquote>
<p>当然，也可以使用回调函数的版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> &lt;A&gt; <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">long</span> position,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> size,</span></span><br><span class="line"><span class="params">                              <span class="type">boolean</span> shared,</span></span><br><span class="line"><span class="params">                              A attachment,</span></span><br><span class="line"><span class="params">                              CompletionHandler&lt;FileLock,? <span class="built_in">super</span> A&gt; handler)</span>;</span><br></pre></td></tr></table></figure>

<p>文件锁定功能上还提供了 tryLock 方法，此方法会快速返回结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> FileLock <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> position, <span class="type">long</span> size, <span class="type">boolean</span> shared)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个方法很简单，就是尝试去获取锁，如果该区域已被其他线程或其他应用锁住，那么立刻返回 null，否则返回  FileLock 对象。</p>
</blockquote>
<p>AsynchronousFileChannel 操作大体上也就以上介绍的这些接口，还是比较简单的，这里就少一些废话早点结束好了。</p>
<h3 id="AsynchronousServerSocketChannel"><a href="#AsynchronousServerSocketChannel" class="headerlink" title="AsynchronousServerSocketChannel"></a>AsynchronousServerSocketChannel</h3><p>这个类对应的是非阻塞 IO 的 ServerSocketChannel，大家可以类比下使用方式。</p>
<p>我们就废话少说，用代码说事吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javadoop.aio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 实例化，并监听端口</span></span><br><span class="line">        <span class="type">AsynchronousServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span></span><br><span class="line">                AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己定义一个 Attachment 类，用于传递一些信息</span></span><br><span class="line">        <span class="type">Attachment</span> <span class="variable">att</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Attachment</span>();</span><br><span class="line">        att.setServer(server);</span><br><span class="line"></span><br><span class="line">        server.accept(att, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Attachment&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel client, Attachment att)</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">SocketAddress</span> <span class="variable">clientAddr</span> <span class="operator">=</span> client.getRemoteAddress();</span><br><span class="line">                    System.out.println(<span class="string">&quot;收到新的连接：&quot;</span> + clientAddr);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 收到新的连接后，server 应该重新调用 accept 方法等待新的连接进来</span></span><br><span class="line">                    att.getServer().accept(att, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="type">Attachment</span> <span class="variable">newAtt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Attachment</span>();</span><br><span class="line">                    newAtt.setServer(server);</span><br><span class="line">                    newAtt.setClient(client);</span><br><span class="line">                    newAtt.setReadMode(<span class="literal">true</span>);</span><br><span class="line">                    newAtt.setBuffer(ByteBuffer.allocate(<span class="number">2048</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 这里也可以继续使用匿名实现类，不过代码不好看，所以这里专门定义一个类</span></span><br><span class="line">                    client.read(newAtt.getBuffer(), newAtt, <span class="keyword">new</span> <span class="title class_">ChannelHandler</span>());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable t, Attachment att)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;accept failed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 为了防止 main 线程退出</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下 ChannelHandler 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javadoop.aio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;Integer, Attachment&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, Attachment att)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (att.isReadMode()) &#123;</span><br><span class="line">            <span class="comment">// 读取来自客户端的数据</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> att.getBuffer();</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="type">byte</span> bytes[] = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.limit()];</span><br><span class="line">            buffer.get(bytes);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array()).toString().trim();</span><br><span class="line">            System.out.println(<span class="string">&quot;收到来自客户端的数据: &quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 响应客户端请求，返回数据</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            buffer.put(<span class="string">&quot;Response from server!&quot;</span>.getBytes(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">            att.setReadMode(<span class="literal">false</span>);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// 写数据到客户端也是异步</span></span><br><span class="line">            att.getClient().write(buffer, att, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 到这里，说明往客户端写数据也结束了，有以下两种选择:</span></span><br><span class="line">            <span class="comment">// 1. 继续等待客户端发送新的数据过来</span></span><br><span class="line"><span class="comment">//            att.setReadMode(true);</span></span><br><span class="line"><span class="comment">//            att.getBuffer().clear();</span></span><br><span class="line"><span class="comment">//            att.getClient().read(att.getBuffer(), att, this);</span></span><br><span class="line">            <span class="comment">// 2. 既然服务端已经返回数据给客户端，断开这次的连接</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                att.getClient().close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable t, Attachment att)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接断开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺便再贴一下自定义的 Attachment 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Attachment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel server;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel client;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isReadMode;</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer buffer;</span><br><span class="line">    <span class="comment">// getter &amp; setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，一个简单的服务端就写好了，接下来可以接收客户端请求了。上面我们用的都是回调函数的方式，读者要是感兴趣，可以试试写个使用 Future 的。</p>
<h3 id="AsynchronousSocketChannel"><a href="#AsynchronousSocketChannel" class="headerlink" title="AsynchronousSocketChannel"></a>AsynchronousSocketChannel</h3><p>其实，说完上面的 AsynchronousServerSocketChannel，基本上读者也就知道怎么使用 AsynchronousSocketChannel 了，和非阻塞 IO 基本类似。</p>
<p>这边做个简单演示，这样读者就可以配合之前介绍的 Server 进行测试使用了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javadoop.aio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">AsynchronousSocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> AsynchronousSocketChannel.open();</span><br><span class="line">      	<span class="comment">// 来个 Future 形式的</span></span><br><span class="line">        Future&lt;?&gt; future = client.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">// 阻塞一下，等待连接成功</span></span><br><span class="line">        future.get();</span><br><span class="line"></span><br><span class="line">        <span class="type">Attachment</span> <span class="variable">att</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Attachment</span>();</span><br><span class="line">        att.setClient(client);</span><br><span class="line">        att.setReadMode(<span class="literal">false</span>);</span><br><span class="line">        att.setBuffer(ByteBuffer.allocate(<span class="number">2048</span>));</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="string">&quot;I am obot!&quot;</span>.getBytes();</span><br><span class="line">        att.getBuffer().put(data);</span><br><span class="line">        att.getBuffer().flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步发送数据到服务端</span></span><br><span class="line">        client.write(att.getBuffer(), att, <span class="keyword">new</span> <span class="title class_">ClientChannelHandler</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里休息一下再退出，给出足够的时间处理数据</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>往里面看下 ClientChannelHandler 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javadoop.aio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientChannelHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;Integer, Attachment&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, Attachment att)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> att.getBuffer();</span><br><span class="line">        <span class="keyword">if</span> (att.isReadMode()) &#123;</span><br><span class="line">            <span class="comment">// 读取来自服务端的数据</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.limit()];</span><br><span class="line">            buffer.get(bytes);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;收到来自服务端的响应数据: &quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接下来，有以下两种选择:</span></span><br><span class="line">            <span class="comment">// 1. 向服务端发送新的数据</span></span><br><span class="line"><span class="comment">//            att.setReadMode(false);</span></span><br><span class="line"><span class="comment">//            buffer.clear();</span></span><br><span class="line"><span class="comment">//            String newMsg = &quot;new message from client&quot;;</span></span><br><span class="line"><span class="comment">//            byte[] data = newMsg.getBytes(Charset.forName(&quot;UTF-8&quot;));</span></span><br><span class="line"><span class="comment">//            buffer.put(data);</span></span><br><span class="line"><span class="comment">//            buffer.flip();</span></span><br><span class="line"><span class="comment">//            att.getClient().write(buffer, att, this);</span></span><br><span class="line">            <span class="comment">// 2. 关闭连接</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                att.getClient().close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 写操作完成后，会进到这里</span></span><br><span class="line">            att.setReadMode(<span class="literal">true</span>);</span><br><span class="line">            buffer.clear();</span><br><span class="line">            att.getClient().read(buffer, att, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable t, Attachment att)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器无响应&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码都是可以运行调试的，如果读者碰到问题，请在评论区留言。</p>
<h3 id="Asynchronous-Channel-Groups"><a href="#Asynchronous-Channel-Groups" class="headerlink" title="Asynchronous Channel Groups"></a>Asynchronous Channel Groups</h3><p>为了知识的完整性，有必要对 group 进行介绍，其实也就是介绍 AsynchronousChannelGroup 这个类。之前我们说过，异步 IO 一定存在一个线程池，这个线程池负责接收任务、处理 IO 事件、回调等。这个线程池就在 group 内部，group 一旦关闭，那么相应的线程池就会关闭。</p>
<p>AsynchronousServerSocketChannels 和     AsynchronousSocketChannels 是属于 group 的，当我们调用 AsynchronousServerSocketChannel 或 AsynchronousSocketChannel 的 open() 方法的时候，相应的 channel 就属于默认的 group，这个 group 由 JVM 自动构造并管理。</p>
<p>如果我们想要配置这个默认的 group，可以在 JVM 启动参数中指定以下系统变量：</p>
<ul>
<li><p>java.nio.channels.DefaultThreadPool.threadFactory</p>
<p>此系统变量用于设置 ThreadFactory，它应该是 java.util.concurrent.ThreadFactory 实现类的全限定类名。一旦我们指定了这个 ThreadFactory 以后，group 中的线程就会使用该类产生。</p>
</li>
<li><p>java.nio.channels.DefaultThreadPool.initialSize</p>
<p>此系统变量也很好理解，用于设置线程池的初始大小。</p>
</li>
</ul>
<p>可能你会想要使用自己定义的 group，这样可以对其中的线程进行更多的控制，使用以下几个方法即可：</p>
<ul>
<li>AsynchronousChannelGroup.withCachedThreadPool(ExecutorService executor, int initialSize)</li>
<li>AsynchronousChannelGroup.withFixedThreadPool(int nThreads, ThreadFactory threadFactory)</li>
<li>AsynchronousChannelGroup.withThreadPool(ExecutorService executor)</li>
</ul>
<p>熟悉线程池的读者对这些方法应该很好理解，它们都是 AsynchronousChannelGroup 中的静态方法。</p>
<p>至于 group 的使用就很简单了，代码一看就懂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AsynchronousChannelGroup</span> <span class="variable">group</span> <span class="operator">=</span> AsynchronousChannelGroup</span><br><span class="line">        .withFixedThreadPool(<span class="number">10</span>, Executors.defaultThreadFactory());</span><br><span class="line"><span class="type">AsynchronousServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> AsynchronousServerSocketChannel.open(group);</span><br><span class="line"><span class="type">AsynchronousSocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> AsynchronousSocketChannel.open(group);</span><br></pre></td></tr></table></figure>

<p><strong>AsynchronousFileChannels 不属于 group</strong>。但是它们也是关联到一个线程池的，如果不指定，会使用系统默认的线程池，如果想要使用指定的线程池，可以在实例化的时候使用以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AsynchronousFileChannel <span class="title function_">open</span><span class="params">(Path file,</span></span><br><span class="line"><span class="params">                                           Set&lt;? extends OpenOption&gt; options,</span></span><br><span class="line"><span class="params">                                           ExecutorService executor,</span></span><br><span class="line"><span class="params">                                           FileAttribute&lt;?&gt;... attrs)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，异步 IO 就算介绍完成了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我想，本文应该是说清楚了非阻塞 IO 和异步 IO 了，对于异步 IO，由于网上的资料比较少，所以不免篇幅多了些。</p>
<p>我们也要知道，看懂了这些，确实可以学到一些东西，多了解一些知识，但是我们还是很少在工作中将这些知识变成工程代码。一般而言，我们需要在网络应用中使用 NIO 或 AIO 来提升性能，但是，在工程上，绝不是了解了一些概念，知道了一些接口就可以的，需要处理的细节还非常多。</p>
<p>这也是为什么 Netty/Mina 如此盛行的原因，因为它们帮助封装好了很多细节，提供给我们用户友好的接口，后面有时间我也会对 Netty 进行介绍。</p>
<p>（全文完）</p>
]]></content>
      <categories>
        <category>jdk</category>
      </categories>
      <tags>
        <tag>nio</tag>
        <tag>aio</tag>
        <tag>bio</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 介绍</title>
    <url>/2024/09/11/JVM/</url>
    <content><![CDATA[<h1 id="JVM-是虚拟机吗？"><a href="#JVM-是虚拟机吗？" class="headerlink" title="JVM 是虚拟机吗？"></a>JVM 是虚拟机吗？</h1><h2 id="JVM-是什么？"><a href="#JVM-是什么？" class="headerlink" title="JVM 是什么？"></a>JVM 是什么？</h2><p><strong>Java Virtual Machine (JVM)</strong> 是 Java 平台的核心组件，它是一个**<mark>程序运行环境<mark>**，专门用来执行 Java 字节码（Bytecode）</p>
<p><strong>主要功能：</strong></p>
<ol>
<li><strong>跨平台支持</strong>：JVM 实现了 Java 的 “Write Once, Run Anywhere” 特性，使 Java 程序能够在不同操作系统上运行。</li>
<li>字节码解释和编译：JVM 将 Java 编译器生成的字节码（平台无关）转换为平台相关的机器代码，并执行。</li>
<li>内存管理：提供垃圾回收机制 (Garbage Collection, GC)。</li>
<li>安全性：内置安全检查机制，确保 Java 程序在受控环境中运行，防止恶意代码执行。</li>
</ol>
<h2 id="Hypervisor-VMM-是什么"><a href="#Hypervisor-VMM-是什么" class="headerlink" title="Hypervisor/VMM 是什么?"></a>Hypervisor/VMM 是什么?</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2560px-Hyperviseur.svg.png" alt="undefined"></p>
<p>Hypervisor 是一种一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件。也可叫做虚拟机监视器，即 VMM（ virtual machine monitor ）。</p>
<ul>
<li>当服务器启动并执行 Hypervisor 时，它会加载所有虚拟机客户端的操作系统同时会分配给每一台虚拟机适量的内存，CPU，网络和磁盘。它允许多个操作系统（称为<strong>Guest OS</strong>）在同一台物理机器（称为<strong>Host</strong>）上同时运行，每个操作系统被隔离在独立的虚拟机中。</li>
<li>Hypervisor 负责资源分配，如 CPU、内存和存储，协调着这些硬件资源的访问，而且在各个虚拟机之间施加防护，处理虚拟机之间的通信和安全隔离。</li>
</ul>
<h2 id="JVM-与-Hypervisor-VMM-的对比"><a href="#JVM-与-Hypervisor-VMM-的对比" class="headerlink" title="JVM 与 Hypervisor/VMM 的对比"></a>JVM 与 Hypervisor/VMM 的对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>JVM</th>
<th>Hypervisor/VMM</th>
</tr>
</thead>
<tbody><tr>
<td><strong>用途</strong></td>
<td>运行 Java 程序的虚拟环境</td>
<td>管理和运行多个虚拟机，每个虚拟机可运行不同操作系统</td>
</tr>
<tr>
<td><strong>虚拟化层级</strong></td>
<td>应用程序级虚拟化（针对 Java 字节码）</td>
<td>操作系统级虚拟化（针对硬件资源）</td>
</tr>
<tr>
<td><strong>管理对象</strong></td>
<td><strong>Java 字节码执行环境</strong></td>
<td>虚拟机管理和<strong>硬件资源虚拟化</strong></td>
</tr>
<tr>
<td><strong>依赖性</strong></td>
<td>必须安装在操作系统上，依赖操作系统环境</td>
<td>Type 1 可以直接运行在硬件上，Type 2 依赖操作系统</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>程序之间隔离性较弱，依赖 JVM 的安全机制</td>
<td>每个虚拟机互相独立，硬件级别隔离</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td>Oracle HotSpot VM、OpenJDK JVM</td>
<td>VMware ESXi、VirtualBox、KVM、Hyper-V</td>
</tr>
</tbody></table>
<ol>
<li>在 VMware ESXi 上创建一个虚拟机；</li>
<li>在虚拟机内部运行一个 Guest OS，比如 Linux；</li>
<li>在 Linux 中安装 Java 环境并运行 JVM。</li>
</ol>
<span id="more"></span>

<h1 id="Java-Memory-Model-J-U-C"><a href="#Java-Memory-Model-J-U-C" class="headerlink" title="Java Memory Model(J.U.C)"></a><a href="../JavaSE/JUC/J%E2%80%A4U%E2%80%A4C.md">Java Memory Model(J.U.C)</a></h1><h1 id="Java-内存区域"><a href="#Java-内存区域" class="headerlink" title="Java 内存区域"></a>Java 内存区域</h1><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 ）" style="zoom: 80%;" />

<p>1.7之前， MetaSpace 在运行时内存区域，也是独立于堆、线程私有内存的一片线程共享内存</p>
<p>线程私有：<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>、<strong>程序计数器 PC</strong></p>
<p>线程共享：堆、Metaspace、直接内存</p>
<p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</p>
<h2 id="运行时数据区域-Runtime"><a href="#运行时数据区域-Runtime" class="headerlink" title="运行时数据区域(Runtime)"></a>运行时数据区域(Runtime)</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250103144549650.png" alt="image-20250103144549650"></p>
<h3 id="线程私有-Local"><a href="#线程私有-Local" class="headerlink" title="线程私有(Local)"></a>线程私有(Local)</h3><h4 id="程序计数器-Program-Counter"><a href="#程序计数器-Program-Counter" class="headerlink" title="程序计数器(Program Counter)"></a><mark>程序计数器<mark>(Program Counter)</h4><ul>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。    </li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，当线程被切换回来时能够知道该线程上次运行的位置。</li>
<li>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地 址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。</li>
<li>唯一不会出现 <code>OutOufMemoryError</code> 的内存区域，与线程的生命周期相同</li>
</ul>
<h4 id="虚拟机栈-VM-Stack"><a href="#虚拟机栈-VM-Stack" class="headerlink" title="虚拟机栈(VM Stack)"></a><mark>虚拟机栈<mark>(VM Stack)</h4><ul>
<li>per thread：与线程的生命周期相同</li>
<li>所有的 Java 方法调用都是通过虚拟机栈来实现的，就是事实上的 Java 方法栈</li>
<li><strong>LIFO</strong>：只支持出栈和入栈两种操作</li>
</ul>
<h5 id="栈帧-Stack-Frame"><a href="#栈帧-Stack-Frame" class="headerlink" title="栈帧(Stack Frame)"></a>栈帧(Stack Frame)</h5><ul>
<li><p>每一次方法调用都会有一个对应的栈帧被压入VM Stack，调用结束时弹出一个栈帧。</p>
</li>
<li><p>每个<strong>栈帧</strong>中都拥有：局部变量表、操作数栈、动态链接、方法返回地址</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/stack-area.png" alt="Java 虚拟机栈" style="zoom:67%;" /></li>
</ul>
<p><strong><mark>局部变量表<mark><strong>：局部变量表存放了编译期可知的各种Java虚拟机</strong>基本数据类型</strong>（boolean、byte、char、short、int、 float、long、double）、<strong>对象引用</strong>（reference类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和<strong>returnAddress 类型</strong>（指向了一条字节码指令的地址）。</p>
<p>其存储空间以局部变量槽（Slot）来表示，其中64位长度的long和 double类型的数据会占用两个变量槽，其余的数据类型只占用一个。所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。这里说的“大小”是指变量槽的数量， 虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。</p>
<p><strong><mark>操作数栈<mark><strong>：主要作为</strong>方法调用的中转站</strong>使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的<strong>临时变量</strong>也会放在操作数栈中。方法执行过程中通过出栈、入栈完成计算操作。</p>
<p><strong><mark>动态链接<mark><strong>：主要用于</strong>一个方法需要调用其他方法</strong>的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为实际内存地址。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 <strong>动态链接</strong>。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/jvmimage-20220331175738692-1735821102490-10.png" alt="img"></p>
<h5 id="StackOverFlow-OutOfMemory-Error"><a href="#StackOverFlow-OutOfMemory-Error" class="headerlink" title="StackOverFlow/OutOfMemory Error"></a>StackOverFlow/OutOfMemory <strong>Error</strong></h5><p>Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， <strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong> </p>
<p>栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E7%9A%84%E7%AC%AC2%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png" alt="img"></p>
<p>**<mark>方法返回地址<mark>**：</p>
<ul>
<li><strong>记录调用点的字节码指令地址</strong>，以便方法执行完毕后能返回到正确的位置继续执行程序。<ol>
<li>JVM 创建一个栈帧并保存调用点的字节码指令地址（<code>result = add(2, 3)</code>）。</li>
<li>计算 <code>a + b</code> 的结果，并将值返回给调用点。</li>
<li>执行结束后，当前栈帧弹出，并根据<strong>返回地址</strong>继续执行 <code>System.out.println(result)</code></li>
</ol>
</li>
<li>保证方法调用的<strong>有序性</strong>和<strong>完整性</strong>，支持嵌套调用和递归处理。</li>
</ul>
<h4 id="本地方法栈-Native-Stack"><a href="#本地方法栈-Native-Stack" class="headerlink" title="本地方法栈(Native Stack)"></a><mark>本地方法栈<mark>(Native Stack)</h4><p>和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<h3 id="线程共享-Global"><a href="#线程共享-Global" class="headerlink" title="线程共享(Global)"></a>线程共享(Global)</h3><h4 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a><mark>堆<mark>(Heap)</h4><p>Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，<mark>几乎<mark>所有的<mark>对象实例<mark>以及<mark>数组<mark>都在这里分配内存。 <a href="#threadlocal">现在还可以在线程栈上分配</a></p>
<p>堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p>
<h5 id="堆分代-HotSpot-VM"><a href="#堆分代-HotSpot-VM" class="headerlink" title="堆分代(HotSpot VM)"></a>堆分代(HotSpot VM)</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/hotspot-heap-structure.png" alt="堆内存结构"></p>
<p> <strong>Eden</strong> 区、两个 <strong>Survivor</strong> 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。<strong>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用本地内存。</strong> </p>
<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。不过，设置的值应该在 0-15，否则会爆出以下错误：MaxTenuringThreshold of 20 is invalid; must be between 0 and 15</p>
<h6 id="为什么年龄只能是-0-15"><a href="#为什么年龄只能是-0-15" class="headerlink" title="为什么年龄只能是 0-15?"></a>为什么年龄只能是 0-15?</h6><p>因为记录年龄的区域在对象头中，这个区域的大小通常是 4 位。这 4 位可以表示的最大二进制数字是 1111，即十进制的 15。因此，对象的年龄被限制为 0 到 15。</p>
<h6 id="堆内存一定分代管理吗"><a href="#堆内存一定分代管理吗" class="headerlink" title="堆内存一定分代管理吗?"></a>堆内存一定分代管理吗?</h6><p>在十年之前（以G1收集器的出现为分界），作为业界绝对主流的HotSpot虚拟机，它内部的垃圾收集器全部 都基于“经典分代” 来设计，需要新生代、老年代收集器搭配才能工作。但是随着GC技术的发展，HotSpot里面也出现了不采用分代设计的新GC。</p>
<p>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 （Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将 Java 堆细分的目的只是为了更好地回收内存，或者更快地分配内存。</p>
<h5 id="字符串常量池-String-Constant-Pool"><a href="#字符串常量池-String-Constant-Pool" class="headerlink" title="字符串常量池(String Constant Pool)"></a><mark>字符串常量池<mark>(String Constant Pool)</h5><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在字符串常量池中创建字符串对象 ”ab“</span><br><span class="line">// 将字符串对象 ”ab“ 的引用赋值给给 aa</span><br><span class="line">String aa = &quot;ab&quot;;</span><br><span class="line">// 直接返回字符串常量池中字符串对象 ”ab“，赋值给引用 bb</span><br><span class="line">String bb = &quot;ab&quot;;</span><br><span class="line">System.out.println(aa==bb); // true</span><br></pre></td></tr></table></figure>

<p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<code>StringTable</code> 可以简单理解为一个固定大小的<code>HashTable</code> ，容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置），保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。</p>
<p>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 <strong>字符串常量池</strong>和<strong>静态变量</strong>从<strong>永久代</strong>移动到了 Java <strong>堆</strong>中。主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p>
<blockquote>
<p><strong>运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。</strong></p>
</blockquote>
<h2 id="本地内存-Native-Memory-也是线程共享"><a href="#本地内存-Native-Memory-也是线程共享" class="headerlink" title="本地内存(Native Memory, 也是线程共享)"></a>本地内存(Native Memory, 也是线程共享)</h2><h3 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区(Method Area)"></a><mark>方法区<mark>(Method Area)</h3><p>方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。</p>
<p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，方法区到底要如何实现那就是虚拟机自己要考虑的事情了。也就是说，在不同的虚拟机实现上，方法区的实现是不同的。</p>
<p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p>
<h4 id="永久代-PermGen-和-元空间-Metaspace"><a href="#永久代-PermGen-和-元空间-Metaspace" class="headerlink" title="永久代(PermGen) 和 元空间(Metaspace)"></a>永久代(PermGen) 和 元空间(Metaspace)</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250103142749020.png" alt="image-20250103142749020"></p>
<p><strong>方法区和永久代以及元空间是什么关系呢？</strong> 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是<strong>永久代</strong>和<strong>元空间</strong>，接口可以看作是<strong>方法区</strong>，也就是说<strong>永久代</strong>以及<strong>元空间</strong>是 <strong>HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式</strong>。并且，<strong>永久代</strong>（Permanent Gen）是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了<strong>元空间</strong>（Metaspace）。</p>
<ul>
<li>整个<strong>永久代</strong>（PermGen）有一个 JVM 本身设置的固定大小上限，无法进行调整（也就是受到 JVM 内存的限制），而<strong>元空间</strong>（Metaspace）使用的是本地内存，受<strong>本机可用内存</strong>的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</li>
<li><strong>元空间</strong>（Metaspace）里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</li>
<li>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</li>
<li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li>
</ul>
<h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">/* 设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line"><span class="comment">				        如果未指定，根据运行时需求动态调整 */</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小 默认unlimited</span></span><br></pre></td></tr></table></figure>

<h4 id="运行时常量池-Runtime-Constant-Pool"><a href="#运行时常量池-Runtime-Constant-Pool" class="headerlink" title="运行时常量池(Runtime Constant Pool)"></a>运行时常量池(Runtime Constant Pool)</h4><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong> 。</p>
<p>字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量 一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常 量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的 intern()方法。</p>
<p>《深入理解 Java 虚拟机》7.34 节第三版对符号引用和直接引用的解释如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/symbol-reference-and-direct-reference.png" alt="符号引用和直接引用"></p>
<p>常量池表会在类加载后存放到方法区的<strong>运行时常量池</strong>中。</p>
<p>运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</p>
<h4 id="GC"><a href="#GC" class="headerlink" title="GC?"></a>GC?</h4><blockquote>
<p>《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选 择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回 收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤 其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>
</blockquote>
<h3 id="直接内存-Direct-Memory"><a href="#直接内存-Direct-Memory" class="headerlink" title="直接内存(Direct Memory)"></a><mark>直接内存<mark>(Direct Memory)</h3><p>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。它并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 <code>OutOfMemoryError</code> 错误出现。</p>
<p>JDK 1.4 中新加入的 <strong>NIO（Non-Blocking I/O，也被称为 New I/O）</strong>，引入了一种基于<strong>通道（Channel）</strong>与<strong>缓存区（Buffer）</strong>的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p>
<p>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到 本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务 器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得 各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError。</p>
<h2 id="HotSpot-VM-对象"><a href="#HotSpot-VM-对象" class="headerlink" title="HotSpot VM 对象"></a>HotSpot VM 对象</h2><h3 id="对象创建的过程"><a href="#对象创建的过程" class="headerlink" title="对象创建的过程"></a>对象创建的过程</h3><h4 id="类加载检查-metadata-check"><a href="#类加载检查-metadata-check" class="headerlink" title="类加载检查 metadata check"></a>类加载检查 metadata check</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，必须先执行类加载过程，确保 class metadata 已经加载到内存中，并在方法区中创建类的相关信息（如字段、方法、常量池等）。</p>
<h4 id="分配内存-memory-allocation"><a href="#分配内存-memory-allocation" class="headerlink" title="分配内存 memory allocation"></a>分配内存 memory allocation</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>
<h5 id="内存分配的两种方式"><a href="#内存分配的两种方式" class="headerlink" title="内存分配的两种方式"></a>内存分配的两种方式</h5><ul>
<li><strong>指针碰撞</strong>(Bump the Pointer): <ul>
<li>适用场合：堆内存规整（即没有内存碎片）的情况下。</li>
<li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>
<li>使用该分配方式的 GC 收集器：Serial, ParNew, G1, ZGC</li>
</ul>
</li>
<li><strong>空闲列表</strong>(Free List): <ul>
<li>适用场合：堆内存不规整的情况下。</li>
<li>原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块来划分给对象实例，最后更新列表记录。类似操作系统分配内存</li>
<li>使用该分配方式的 GC 收集器：CMS</li>
</ul>
</li>
</ul>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 算法是”清除”，还是”压缩”，复制算法的内存也是规整的（Serial, Parallel, PCompact 对于年轻代的收集）。</p>
<h5 id="内存分配并发问题"><a href="#内存分配并发问题" class="headerlink" title="内存分配并发问题"></a>内存分配并发问题</h5><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机可以采用以下方式来保证堆内存分配的线程安全：</p>
<ul>
<li><strong>CAS + 失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS + 失败重试的方式保证更新操作的原子性。</strong> </li>
<li><strong>TLAB (Thread Local Allocation Buffer)：</strong> 为每一个线程预先在堆的 Eden 区分配一小块内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。</li>
</ul>
<h5 id="逃逸分析优化"><a href="#逃逸分析优化" class="headerlink" title="逃逸分析优化"></a><span id="threadlocal">逃逸分析优化</span></h5><p><strong>逃逸分析优化</strong>：将不逃逸的对象直接分配到栈或使用标量替换，避免堆内存分配。</p>
<p>随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果<strong>某些方法中的对象引用没有被返回或者未被外面使用</strong>（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p>
<h4 id="初始化零值-set-to-zero"><a href="#初始化零值-set-to-zero" class="headerlink" title="初始化零值 set to zero"></a>初始化零值 set to zero</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。（例如，整型为0，浮点型为0.0，引用类型为null等）</p>
<h4 id="设置对象头-set-object-header"><a href="#设置对象头-set-object-header" class="headerlink" title="设置对象头 set object header"></a>设置对象头 set object header</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<ul>
<li><strong>Mark Word</strong>: 存储对象的 hashcode, GC 年龄, 锁状态标志等</li>
<li><strong>Klass Pointer</strong>: 指向方法区中的 class metadata，确定对象的类型。</li>
<li>对于数组来说，还有数组的长度信息。</li>
</ul>
<h4 id="执行-init-方法-execute-lt-init-gt"><a href="#执行-init-方法-execute-lt-init-gt" class="headerlink" title="执行 init 方法 execute &lt;init&gt;"></a>执行 init 方法 execute &lt;init&gt;</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><h4 id="64-位-JVM-下的对象内存布局"><a href="#64-位-JVM-下的对象内存布局" class="headerlink" title="64 位 JVM 下的对象内存布局"></a>64 位 JVM 下的对象内存布局</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/57e6e147dbe447d0b96b4d310f01846atplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png"></p>
<table>
<thead>
<tr>
<th>部分</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Mark Word</strong></td>
<td>8 字节</td>
<td>存储对象状态信息，如哈希码、锁信息和 GC 标记。</td>
</tr>
<tr>
<td><strong>Klass Pointer</strong></td>
<td>8 字节</td>
<td>指向对象所属类的类型元数据，便于方法调度和类型检查。</td>
</tr>
<tr>
<td><strong>数组长度（可选）</strong></td>
<td>4 字节 (可选)</td>
<td>如果是数组对象，会额外包含存储数组长度的字段。</td>
</tr>
<tr>
<td><strong>实例数据</strong></td>
<td>动态分配</td>
<td>存储实例变量的值，按照字段声明顺序对齐存储（按 4 字节或 8 字节对齐）。</td>
</tr>
<tr>
<td><strong>对齐填充</strong></td>
<td>动态填充</td>
<td>保证对象大小是 8 字节的倍数，以便提高内存访问效率。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">20.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 64 位 JVM 上，内存布局如下：</p>
<table>
<thead>
<tr>
<th>部分</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>对象头 - Mark Word</strong></td>
<td>8 字节</td>
<td>哈希码、锁信息、GC 状态等。</td>
</tr>
<tr>
<td><strong>对象头 - Klass Pointer</strong></td>
<td>8 字节</td>
<td>指向类元数据的指针。</td>
</tr>
<tr>
<td><strong>实例数据</strong></td>
<td>12 字节</td>
<td>包括 <code>a</code> (4 字节)、<code>flag</code> (1 字节)、填充 (3 字节) 和 <code>value</code> (8 字节)。</td>
</tr>
<tr>
<td><strong>对齐填充</strong></td>
<td>4 字节</td>
<td>保证对象大小为 8 字节的倍数。</td>
</tr>
</tbody></table>
<p>总大小：<strong>32 字节</strong>（对齐填充确保 8 字节对齐）。</p>
<p>Java 对象头主要由 <strong>Mark Word</strong> 和 <strong>Klass Pointer</strong> 组成，存储对象状态信息和类型元数据指针。</p>
<ul>
<li>支持 JVM 的垃圾回收、同步机制（锁）、偏向锁及哈希计算等操作。</li>
<li>数组对象还包含额外的长度字段以支持动态数组存储。</li>
<li>由于对象头是二进制存储格式，不是直接可读的文本信息，需要工具或命令解析其内容，如 <code>jol</code> 或 <code>javap -v</code>。</li>
</ul>
<h4 id="对象头-Object-Header"><a href="#对象头-Object-Header" class="headerlink" title="对象头(Object Header)"></a>对象头(Object Header)</h4><p>Java 对象头（Object Header）是 <strong>Java 对象在内存中的元数据信息</strong>，主要用于支持 JVM 的对象管理和操作</p>
<h5 id="Mark-Word-的详细解析"><a href="#Mark-Word-的详细解析" class="headerlink" title="Mark Word 的详细解析"></a>Mark Word 的详细解析</h5><p>用于存储对象的运行时状态信息，包括：</p>
<ul>
<li><strong>锁状态标记</strong>（轻量级锁、重量级锁等）</li>
<li><strong>哈希码</strong>（HashCode）</li>
<li><strong>GC 标记</strong>（垃圾回收标记位）</li>
<li><strong>年龄计数器</strong>（GC 年龄，用于晋升到老年代的判断）</li>
</ul>
<p>Mark Word 的具体结构会根据对象状态发生变化：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>标记位</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td><strong>未锁定（默认状态）</strong></td>
<td>01</td>
<td>对象哈希码、GC 年龄等信息。</td>
</tr>
<tr>
<td><strong>轻量级锁定</strong></td>
<td>00</td>
<td>指向栈中锁记录的指针（Lock Record）。</td>
</tr>
<tr>
<td><strong>重量级锁定</strong></td>
<td>10</td>
<td>指向重量级锁的指针（Monitor 对象）。</td>
</tr>
<tr>
<td><strong>GC 标记</strong></td>
<td>11</td>
<td>标记 GC 状态。</td>
</tr>
<tr>
<td><strong>偏向锁</strong></td>
<td>01</td>
<td>偏向线程 ID、时间戳等信息（启用偏向锁时）。</td>
</tr>
</tbody></table>
<p>示例 1：Mark Word 示例（未锁定状态）</p>
<p>假设一个对象未加锁且未偏向：</p>
<table>
<thead>
<tr>
<th>偏向锁</th>
<th>锁状态</th>
<th>GC 年龄</th>
<th>对象哈希码 (HashCode)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>01</td>
<td>000000</td>
<td>00101011100011000111100011000101</td>
</tr>
</tbody></table>
<ul>
<li>偏向锁：0 表示未偏向线程。</li>
<li>锁状态：01 表示未加锁状态。</li>
<li>GC 年龄：000000 表示对象的 GC 年龄为 0。</li>
<li>哈希码：对象哈希值经过位移和组合后存储在 Mark Word 中。</li>
</ul>
<p>示例 2：轻量级锁</p>
<p>对象进入轻量级锁定状态：</p>
<table>
<thead>
<tr>
<th>偏向锁</th>
<th>锁状态</th>
<th>指针内容</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>00</td>
<td>指向线程栈中 Lock Record（锁记录）的指针地址。</td>
</tr>
</tbody></table>
<h5 id="Klass-Pointer（类型指针）"><a href="#Klass-Pointer（类型指针）" class="headerlink" title="Klass Pointer（类型指针）"></a>Klass Pointer（类型指针）</h5><p>指向对象的<strong>类元数据</strong>（Class Metadata），用于标识该对象的具体类型及方法表等信息。</p>
<p>Klass Pointer 是一个指向方法区中 <strong>类元数据</strong> 的指针，包含以下信息：</p>
<ul>
<li>对象所属类的名称和继承关系。</li>
<li>类字段和方法表指针（用于动态方法分派）。</li>
<li>类的内存布局及实例大小信息。</li>
</ul>
<p><strong>作用：</strong>帮助 JVM 在运行时支持<strong>多态</strong>和<strong>类型检查</strong>。</p>
<h5 id="数组对象的额外信息"><a href="#数组对象的额外信息" class="headerlink" title="数组对象的额外信息"></a>数组对象的额外信息</h5><p>如果对象是数组类型，则会额外存储<strong>数组长度信息</strong>。</p>
<table>
<thead>
<tr>
<th>部分</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>数组长度字段</strong></td>
<td>4 字节</td>
<td>存储数组元素的个数。</td>
</tr>
<tr>
<td><strong>元素数据</strong></td>
<td>动态大小</td>
<td>实际存储数组元素的连续内存空间。</td>
</tr>
</tbody></table>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p>
<h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/access-location-of-object-handle.png" alt="对象的访问定位-使用句柄"></p>
<p>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄池地址，在对象被移动或者GC时只会改变句柄池中的实例数据指针，而 reference 本身不需要修改。缺点是多一次指针解析，性能略低。</p>
<h4 id="直接指针-HotSpot-VM"><a href="#直接指针-HotSpot-VM" class="headerlink" title="直接指针(HotSpot VM)"></a>直接指针(HotSpot VM)</h4><p>如果使用直接指针访问，reference 中存储的直接就是对象的地址。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/access-location-of-object-handle-direct-pointer.png" alt="对象的访问定位-直接指针"></p>
<p>使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销，更适合现代高性能 JVM 和 GC，如 G1 和 ZGC，这些 GC 使用并发机制降低对象移动成本，同时提高访问速度。</p>
<h3 id="JOL-分析对象内存布局"><a href="#JOL-分析对象内存布局" class="headerlink" title="JOL 分析对象内存布局"></a>JOL 分析对象内存布局</h3><p>Java Object Layout</p>
<ul>
<li><p><strong>JOL 的核心功能</strong></p>
<ol>
<li><strong>对象内存布局分析</strong><br>检查 Java 对象的结构，包括对象头信息、实例数据以及填充字节（padding）。</li>
<li><strong>对象大小计算</strong><br>精确测量对象占用的内存空间，有助于优化内存使用。</li>
<li><strong>对象对齐规则分析</strong><br>研究 Java 虚拟机的内存对齐方式和效率。</li>
<li><strong>偏向锁与轻量级锁的状态分析</strong><br>观察锁状态以及对象头的变化，帮助理解 Java 并发机制的底层实现。</li>
</ol>
</li>
<li><p>JOL 是基于 JVM 实现的，具体表现可能因 JVM 版本和平台而异。</p>
</li>
<li><p>使用 JOL 分析锁状态时，需要结合 <code>-XX:+UseBiasedLocking</code> 等 JVM 参数。</p>
</li>
<li><p>JOL 不支持所有类型的对象分析，例如直接内存分配的对象需要其他工具辅助。</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JOLExample</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">boolean</span> b;</span><br><span class="line">        <span class="type">long</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 打印对象内存布局</span></span><br><span class="line">        <span class="type">Example</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(example).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">org.example.JOLExample<span class="variable">$Example</span> <span class="keyword">object</span> internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                     VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">8</span>        (<span class="keyword">object</span> header)                 <span class="number">0x0000000000000000</span></span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>    <span class="keyword">int</span> JOLExample<span class="variable">$Example</span>.a            <span class="number">0</span></span><br><span class="line">     <span class="number">12</span>     <span class="number">1</span> <span class="keyword">boolean</span> JOLExample<span class="variable">$Example</span>.b           <span class="literal">false</span></span><br><span class="line">     <span class="number">13</span>     <span class="number">3</span>        (alignment/padding gap)</span><br><span class="line">     <span class="number">16</span>     <span class="number">8</span>   long JOLExample<span class="variable">$Example</span>.c            <span class="number">0</span></span><br><span class="line">Instance size: <span class="number">24</span> bytes</span><br><span class="line">Space losses: <span class="number">3</span> bytes internal + <span class="number">0</span> bytes external = <span class="number">3</span> bytes total</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * OFFSET：字段或数据在对象中的偏移量（单位字节）。</span></span><br><span class="line"><span class="comment"> * SIZE：字段占用的字节数。</span></span><br><span class="line"><span class="comment"> * TYPE/DESCRIPTION：字段类型和名称。</span></span><br><span class="line"><span class="comment"> * VALUE：字段的当前值。</span></span><br><span class="line"><span class="comment"> * alignment/padding：由于内存对齐，填充的字节数，保证效率。</span></span><br><span class="line"><span class="comment"> * Instance size：对象的总大小（包括填充字节）。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h1 id="JVM-调参"><a href="#JVM-调参" class="headerlink" title="JVM 调参"></a><a href="https://javaguide.cn/java/jvm/jvm-parameters-intro.html">JVM 调参</a></h1><h2 id="JDK-分析工具"><a href="#JDK-分析工具" class="headerlink" title="JDK 分析工具"></a>JDK 分析工具</h2><p>除了之前提到的 JOL 是运行在 JVM 上的分析工具，还有很多命令行和可视化工具，主要用于监控、性能分析、内存管理和线程死锁与阻塞分析。</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>主要用途</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>JConsole</strong></td>
<td>实时监控 JVM 性能</td>
<td>本地或远程简单监控应用性能</td>
</tr>
<tr>
<td><strong>VisualVM</strong></td>
<td>高级性能分析和内存快照分析</td>
<td>找出性能瓶颈和内存泄漏问题</td>
</tr>
<tr>
<td><strong>jstat</strong></td>
<td>JVM 性能统计和 GC 监控</td>
<td>快速诊断内存和垃圾回收问题</td>
</tr>
<tr>
<td><strong>jmap</strong></td>
<td>查看堆信息，生成堆快照</td>
<td>内存分析和排查内存泄漏</td>
</tr>
<tr>
<td><strong>jhat</strong></td>
<td>分析堆快照，与jmap配合</td>
<td>离线分析堆对象引用关系</td>
</tr>
<tr>
<td><strong>jstack</strong></td>
<td>查看线程堆栈信息</td>
<td>排查线程死锁和阻塞问题</td>
</tr>
<tr>
<td><strong>jinfo</strong></td>
<td>查看和调整 JVM 参数</td>
<td>动态调整配置，调试运行时环境</td>
</tr>
<tr>
<td><strong>JMC/JFR</strong></td>
<td>高级分析工具，支持低开销记录</td>
<td>深入分析生产环境性能问题（低性能影响）</td>
</tr>
</tbody></table>
<p>除了 <strong>JOL (Java Object Layout)</strong> 之外，还有以下几款同类型的 Java 内存分析和对象布局工具，可以用于分析 Java 对象结构、内存占用及内存管理相关问题：</p>
<p>JDK </p>
<table>
<thead>
<tr>
<th>工具</th>
<th>类型</th>
<th>主要用途</th>
<th>是否免费</th>
</tr>
</thead>
<tbody><tr>
<td><strong>JOL</strong></td>
<td>对象布局分析</td>
<td>内存对齐、对象头、填充字节分析</td>
<td>是</td>
</tr>
<tr>
<td><strong>Arthas</strong></td>
<td>在线诊断工具</td>
<td>实时分析线程、内存、锁状态，适合生产环境</td>
<td>是</td>
</tr>
<tr>
<td><strong>MAT</strong></td>
<td>堆内存分析</td>
<td>内存泄漏、引用链分析</td>
<td>是</td>
</tr>
<tr>
<td><strong>javap</strong></td>
<td>字节码分析工具</td>
<td>查看编译后的字节码结构，研究 JVM 执行过程</td>
<td>是</td>
</tr>
</tbody></table>
<h1 id="GC-的对象"><a href="#GC-的对象" class="headerlink" title="GC 的对象"></a>GC 的对象</h1><p><strong>失去引用</strong>是指一个对象在程序中不再被任何变量或其他对象引用，从而变成<strong>不可达对象</strong>。这些对象无法通过代码访问，因此被认为是<strong>垃圾</strong>，可以由<strong>垃圾回收器（GC）</strong>回收并释放内存。对象失去引用意味着程序无法再访问它，它将成为垃圾回收的候选对象。当程序对对象的引用断开或超出作用域后，JVM 会在合适的时机将其回收以优化内存使用。</p>
<p><strong>引用的定义</strong>：引用是指程序中的变量指向堆内存中的对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里变量 <code>str</code> 引用了字符串对象 <code>&quot;Hello&quot;</code>。</p>
<h2 id="失去引用的几种情况"><a href="#失去引用的几种情况" class="headerlink" title="失去引用的几种情况"></a>失去引用的几种情况</h2><ol>
<li><p><strong>变量重新赋值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">str = <span class="literal">null</span>; <span class="comment">// 原来的 &quot;Hello&quot; 对象失去了引用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">str1 = str2; <span class="comment">// &quot;Hello&quot; 对象失去了引用</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>作用域结束</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">example</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="string">&quot;Temporary&quot;</span>; <span class="comment">// 创建引用</span></span><br><span class="line">&#125; <span class="comment">// 方法结束，temp 超出作用域，失去引用</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>对象被移除出集合</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">list.remove(<span class="number">0</span>); <span class="comment">// 元素 &quot;A&quot; 失去了引用</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>对象之间的引用关系断开</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Node</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"><span class="type">Node</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">n1.next = n2;</span><br><span class="line">n1.next = <span class="literal">null</span>; <span class="comment">// n2 失去了引用</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="失去引用后的处理"><a href="#失去引用后的处理" class="headerlink" title="失去引用后的处理"></a>失去引用后的处理</h2><ol>
<li><strong>垃圾回收</strong>：JVM 会自动检测失去引用的对象，并在适当的时机进行垃圾回收（GC）。</li>
<li><strong>内存释放</strong>：GC 回收这些对象占用的堆内存，使其可供新对象使用。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><p>内存泄漏：如果对象仍然被引用，但实际上不再使用，就会导致垃圾回收器无法回收它们，形成内存泄漏。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 对象持续引用导致内存泄漏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>显式释放引用</strong>：可以通过将对象引用赋值为 <code>null</code> 来帮助垃圾回收器更快地释放内存，但通常不需要显式操作，JVM 会自动管理内存。</p>
</li>
</ol>
<h2 id="GC-管理的对象范围"><a href="#GC-管理的对象范围" class="headerlink" title="GC 管理的对象范围"></a>GC 管理的对象范围</h2><ol>
<li><strong>堆内存中的对象</strong><ul>
<li>**新生代 (Young Generation)**：短生命周期对象，通常是临时变量和局部变量。</li>
<li>**老年代 (Old Generation)**：生命周期较长的对象，例如缓存对象或单例对象。</li>
<li>**元空间 (Metaspace)**：类的元数据和常量池。</li>
</ul>
</li>
<li><strong>非 GC 管理的对象</strong><ul>
<li><strong>栈上的局部变量</strong>：存储在线程栈中，不由 GC 管理，方法结束后自动销毁。</li>
<li>**直接内存 (Direct Memory)**：例如 NIO 的直接缓冲区，需要显式释放。</li>
<li><strong>静态变量</strong>：存储在方法区中（元空间），生命周期随类加载器而定，不属于 GC 管理对象。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="GC-回收的对象条件"><a href="#GC-回收的对象条件" class="headerlink" title="GC 回收的对象条件"></a>GC 回收的对象条件</h2><h3 id="不可达对象"><a href="#不可达对象" class="headerlink" title="不可达对象"></a>不可达对象</h3><p>如果一个对象无法通过<strong>GC Roots</strong>直接或间接引用，则它被视为不可达对象，可以被 GC 回收。</p>
<h3 id="GC-Roots-可达"><a href="#GC-Roots-可达" class="headerlink" title="GC Roots 可达"></a>GC Roots 可达</h3><p>以下对象被视为 GC Roots，是垃圾回收的起始点：</p>
<ol>
<li><strong>栈中的局部变量和方法参数</strong>（线程栈帧中引用的对象）。</li>
<li><strong>静态变量引用的对象</strong>。</li>
<li><strong>常量引用的对象</strong>。</li>
<li><strong>类加载器引用的对象</strong>。</li>
<li><strong>JNI 引用的本地代码对象</strong>（如 Native 方法）。</li>
<li><strong>活动线程引用的对象</strong>。</li>
</ol>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>GC 使用<strong>可达性分析算法</strong>判断对象是否可达。如果从 GC Roots 无法找到路径引用某个对象，则它被视为垃圾对象。</p>
<hr>
<h2 id="强引用-软引用-弱引用-虚引用"><a href="#强引用-软引用-弱引用-虚引用" class="headerlink" title="强引用/软引用/弱引用/虚引用"></a>强引用/软引用/弱引用/虚引用</h2><p>Java 提供了 4 种不同强度的引用类型，用于控制对象的生命周期：</p>
<ol>
<li><strong>强引用 (Strong Reference)</strong><ul>
<li>默认引用类型，不可回收。</li>
<li>示例：<code>String s = &quot;Hello&quot;;</code></li>
<li>只有强引用断开，GC 才会考虑回收对象。</li>
</ul>
</li>
<li><strong>软引用 (Soft Reference)</strong><ul>
<li>适合缓存数据，内存不足时才会回收。</li>
<li>示例：<code>SoftReference&lt;String&gt; sr = new SoftReference&lt;&gt;(new String(&quot;Cache&quot;));</code></li>
</ul>
</li>
<li><strong>弱引用 (Weak Reference)</strong><ul>
<li>GC 时会立即回收，无论内存是否充足。</li>
<li>示例：<code>WeakReference&lt;String&gt; wr = new WeakReference&lt;&gt;(new String(&quot;Temp&quot;));</code></li>
</ul>
</li>
<li><strong>虚引用 (Phantom Reference)</strong><ul>
<li>不影响对象生命周期，仅用于检测对象何时被 GC 回收。</li>
<li>示例：<code>PhantomReference&lt;String&gt; pr = new PhantomReference&lt;&gt;(new String(&quot;Test&quot;), refQueue);</code></li>
</ul>
</li>
</ol>
<hr>
<h2 id="触发-GC-的条件"><a href="#触发-GC-的条件" class="headerlink" title="触发 GC 的条件"></a>触发 GC 的条件</h2><ol>
<li><strong>内存不足</strong>：年轻代或老年代空间耗尽。</li>
<li>**调用 System.gc()**：请求 JVM 进行 GC，但不保证立即执行。</li>
<li><strong>对象失去引用</strong>：对象不可达，进入 GC 阶段。</li>
<li><strong>类加载和卸载</strong>：类元数据或方法区空间不足时触发 GC。</li>
<li><strong>手动释放资源</strong>：如关闭文件流、网络连接等，减少内存压力。</li>
</ol>
<h2 id="GC-示例"><a href="#GC-示例" class="headerlink" title="GC 示例"></a>GC 示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 强引用</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> obj1;        <span class="comment">// 共享引用</span></span><br><span class="line">        obj1 = <span class="literal">null</span>;               <span class="comment">// obj1 失去引用，但 obj2 仍指向它</span></span><br><span class="line">        System.gc();               <span class="comment">// 提示 GC 执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong>：</p>
<ul>
<li><code>obj1</code> 被赋值为 <code>null</code>，但 <code>obj2</code> 仍然引用对象，因此不会被回收。</li>
<li>若同时将 <code>obj2</code> 设置为 <code>null</code>，对象变为不可达对象，则 GC 会将其回收。</li>
</ul>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>GC</tag>
        <tag>内存区域</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty 最佳实践</title>
    <url>/2024/12/26/Netty%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><span id="more"></span>

<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServerBestPractice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BOSS_THREADS</span> <span class="operator">=</span> <span class="number">1</span>;    <span class="comment">// 接收连接线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WORKER_THREADS</span> <span class="operator">=</span> <span class="number">8</span>;   <span class="comment">// 处理连接线程数（建议CPU核心数×2）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_CONNECTION</span> <span class="operator">=</span> <span class="number">1000</span>;<span class="comment">// 最大连接数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup bossGroup;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup workerGroup;</span><br><span class="line">    <span class="keyword">private</span> Channel serverChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ConnectionCounterHandler</span> <span class="variable">connectionCounter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionCounterHandler</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NettyServerBestPractice</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建线程组（根据系统选择Epoll）</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">useEpoll</span> <span class="operator">=</span> Epoll.isAvailable();</span><br><span class="line">        bossGroup = createEventLoopGroup(BOSS_THREADS, <span class="string">&quot;ServerBoss&quot;</span>);</span><br><span class="line">        workerGroup = createEventLoopGroup(WORKER_THREADS, <span class="string">&quot;ServerWorker&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 配置ServerBootstrap</span></span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">        bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                .channel(useEpoll ? EpollServerSocketChannel.class : NioServerSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))  <span class="comment">// Server端日志</span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">                        configurePipeline(ch.pipeline());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 3. TCP参数配置</span></span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)          <span class="comment">// 等待连接队列长度</span></span><br><span class="line">                .option(ChannelOption.SO_REUSEADDR, <span class="literal">true</span>)         <span class="comment">// 端口重用</span></span><br><span class="line">                .childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)     <span class="comment">// 禁用Nagle算法</span></span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)    <span class="comment">// 保活检测</span></span><br><span class="line">                .childOption(ChannelOption.WRITE_BUFFER_WATER_MARK, </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">WriteBufferWaterMark</span>(<span class="number">32</span> * <span class="number">1024</span>, <span class="number">64</span> * <span class="number">1024</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 绑定端口（带重试机制）</span></span><br><span class="line">        bindWithRetry(bootstrap, PORT, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 注册监控钩子</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>::shutdownGracefully));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带重试的端口绑定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bindWithRetry</span><span class="params">(ServerBootstrap bootstrap, <span class="type">int</span> port, <span class="type">int</span> retryCount)</span> &#123;</span><br><span class="line">        bootstrap.bind(port).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                serverChannel = future.channel();</span><br><span class="line">                System.out.printf(<span class="string">&quot;Server started on port %d (using %s)&quot;</span>,</span><br><span class="line">                        port, serverChannel.getClass().toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retryCount == <span class="number">0</span>) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Failed to bind after max retries: &quot;</span> + future.cause());</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.err.printf(<span class="string">&quot;Bind failed, retry %d... Cause: %s&quot;</span>,</span><br><span class="line">                        retryCount, future.cause().getMessage());</span><br><span class="line">                bootstrap.config().group().schedule(() -&gt; </span><br><span class="line">                        bindWithRetry(bootstrap, port, retryCount - <span class="number">1</span>), <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 管道配置（可扩展）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configurePipeline</span><span class="params">(ChannelPipeline pipeline)</span> &#123;</span><br><span class="line">        pipeline.addLast(<span class="string">&quot;connCounter&quot;</span>, connectionCounter)  <span class="comment">// 连接数统计</span></span><br><span class="line">                .addLast(<span class="string">&quot;logging&quot;</span>, <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG)) <span class="comment">// 连接级日志</span></span><br><span class="line">                .addLast(<span class="string">&quot;idleCheck&quot;</span>, <span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, TimeUnit.SECONDS))</span><br><span class="line">                .addLast(<span class="string">&quot;frameDecoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>*<span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>))</span><br><span class="line">                .addLast(<span class="string">&quot;business&quot;</span>, <span class="keyword">new</span> <span class="title class_">ServerBusinessHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优雅关闭（支持平滑重启）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">shutdownGracefully</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Initiating server shutdown...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 关闭顺序：ServerChannel -&gt; WorkerGroup -&gt; BossGroup</span></span><br><span class="line">        <span class="keyword">if</span> (serverChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">            serverChannel.close().syncUninterruptibly();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 先关闭WorkerGroup（处理现有连接）</span></span><br><span class="line">        <span class="keyword">if</span> (workerGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">            workerGroup.shutdownGracefully(<span class="number">0</span>, <span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">                    .addListener(f -&gt; logShutdownProgress(<span class="string">&quot;WorkerGroup&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8. 最后关闭BossGroup</span></span><br><span class="line">        <span class="keyword">if</span> (bossGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">            bossGroup.shutdownGracefully(<span class="number">0</span>, <span class="number">5</span>, TimeUnit.SECONDS)</span><br><span class="line">                    .addListener(f -&gt; logShutdownProgress(<span class="string">&quot;BossGroup&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Current connections: &quot;</span> + connectionCounter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建优化的EventLoopGroup</span></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup <span class="title function_">createEventLoopGroup</span><span class="params">(<span class="type">int</span> threads, String namePrefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Epoll.isAvailable() ? </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">EpollEventLoopGroup</span>(threads, <span class="keyword">new</span> <span class="title class_">DefaultThreadFactory</span>(namePrefix)) :</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(threads, <span class="keyword">new</span> <span class="title class_">DefaultThreadFactory</span>(namePrefix));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logShutdownProgress</span><span class="params">(String component)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s shutdown %s%n&quot;</span>, component,</span><br><span class="line">                ((Future&lt;?&gt;)<span class="built_in">this</span>).isSuccess() ? <span class="string">&quot;success&quot;</span> : <span class="string">&quot;failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端业务处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ServerBusinessHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">            <span class="comment">// 业务处理逻辑</span></span><br><span class="line">            ctx.writeAndFlush(<span class="string">&quot;Server response&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Server error: &quot;</span> + cause.getMessage());</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> &#123;</span><br><span class="line">            <span class="comment">// 空闲连接关闭</span></span><br><span class="line">            <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Closing idle connection: &quot;</span> + ctx.channel());</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接数统计处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConnectionCounterHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelDuplexHandler</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">connectionCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> connectionCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (count &gt; MAX_CONNECTION) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Connection limit exceeded: &quot;</span> + count);</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;New connection. Total: &quot;</span> + count);</span><br><span class="line">            ctx.fireChannelActive();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> connectionCount.decrementAndGet();</span><br><span class="line">            System.out.println(<span class="string">&quot;Connection closed. Remaining: &quot;</span> + count);</span><br><span class="line">            ctx.fireChannelInactive();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> connectionCount.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="服务端关键设计说明"><a href="#服务端关键设计说明" class="headerlink" title="服务端关键设计说明"></a><strong>服务端关键设计说明</strong></h3><ol>
<li><p><strong>线程模型优化</strong></p>
<ul>
<li><strong>双线程组架构</strong>：BossGroup（接收连接） + WorkerGroup（处理IO）</li>
<li><strong>线程命名</strong>：使用<code>DefaultThreadFactory</code>明确线程用途</li>
<li><strong>Epoll提升性能</strong>：自动检测并启用Epoll（Linux）</li>
</ul>
</li>
<li><p><strong>连接管理</strong></p>
<ul>
<li><strong>连接数控制</strong>：通过<code>ConnectionCounterHandler</code>限制最大连接</li>
<li><strong>空闲检测</strong>：300秒无活动自动关闭连接</li>
<li><strong>平滑重启</strong>：先关闭接收新连接，再处理现存连接</li>
</ul>
</li>
<li><p><strong>资源管理</strong></p>
<ul>
<li><strong>关闭顺序</strong>：ServerChannel → WorkerGroup → BossGroup</li>
<li><strong>优雅关闭</strong>：允许正在处理的请求完成</li>
<li><strong>内存保护</strong>：通过<code>WriteBufferWaterMark</code>防止OOM</li>
</ul>
</li>
<li><p><strong>可观测性</strong></p>
<ul>
<li><strong>两级日志</strong>：ServerBootstrap级别 + 每个连接级别</li>
<li><strong>连接数监控</strong>：实时统计活跃连接</li>
<li><strong>关闭进度跟踪</strong>：记录各组件关闭状态</li>
</ul>
</li>
<li><p><strong>协议处理</strong></p>
<ul>
<li><strong>解决粘包</strong>：使用<code>LengthFieldBasedFrameDecoder</code></li>
<li><strong>扩展点设计</strong>：<code>configurePipeline()</code>方法允许子类扩展</li>
</ul>
</li>
<li><p><strong>可靠性增强</strong></p>
<ul>
<li><strong>端口绑定重试</strong>：自动重试最多3次</li>
<li><strong>异常熔断</strong>：连接数超限立即拒绝</li>
<li><strong>防雪崩</strong>：限制单个连接的内存使用</li>
</ul>
</li>
</ol>
<hr>
<h3 id="生产环境建议"><a href="#生产环境建议" class="headerlink" title="生产环境建议"></a><strong>生产环境建议</strong></h3><ol>
<li><p><strong>参数调优</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建议调整以下参数：</span></span><br><span class="line">.option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)       <span class="comment">// 根据QPS调整</span></span><br><span class="line">.childOption(ChannelOption.SO_RCVBUF, <span class="number">128</span> * <span class="number">1024</span>) <span class="comment">// 接收缓冲区</span></span><br><span class="line">.childOption(ChannelOption.SO_SNDBUF, <span class="number">128</span> * <span class="number">1024</span>) <span class="comment">// 发送缓冲区</span></span><br><span class="line">.childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT) <span class="comment">// 内存池</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>监控集成</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加指标采集</span></span><br><span class="line">pipeline.addLast(<span class="string">&quot;metrics&quot;</span>, <span class="keyword">new</span> <span class="title class_">MetricsHandler</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义监控Handler示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MetricsHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelDuplexHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Counter</span> <span class="variable">receivedMessages</span> <span class="operator">=</span> Metrics.counter(<span class="string">&quot;server.messages.received&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">        receivedMessages.increment();</span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>安全增强</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加SSL/TLS支持</span></span><br><span class="line">.childHandler(<span class="keyword">new</span> <span class="title class_">SslContextBuilder</span>()</span><br><span class="line">    .forServer(cert, key)</span><br><span class="line">    .build().newHandler(ByteBufAllocator.DEFAULT))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加IP白名单</span></span><br><span class="line">pipeline.addFirst(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">clientIP</span> <span class="operator">=</span> ((InetSocketAddress) ctx.channel().remoteAddress()).getHostString();</span><br><span class="line">        <span class="keyword">if</span> (!allowList.contains(clientIP)) &#123;</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>流量控制</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局流量整形（10MB/s）</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> <span class="title class_">GlobalTrafficShapingHandler</span>(</span><br><span class="line">        workerGroup, <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="与客户端的对比差异"><a href="#与客户端的对比差异" class="headerlink" title="与客户端的对比差异"></a><strong>与客户端的对比差异</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>服务端</th>
<th>客户端</th>
</tr>
</thead>
<tbody><tr>
<td>线程模型</td>
<td>Boss+Worker双线程组</td>
<td>单EventLoopGroup</td>
</tr>
<tr>
<td>连接管理</td>
<td>需要处理大量并发连接</td>
<td>管理单个/少量连接</td>
</tr>
<tr>
<td>关闭顺序</td>
<td>ServerChannel→Worker→Boss</td>
<td>Channel→EventLoopGroup</td>
</tr>
<tr>
<td>协议处理</td>
<td>需要处理多种客户端协议</td>
<td>遵循服务端协议</td>
</tr>
<tr>
<td>性能优化重点</td>
<td>吞吐量、连接数</td>
<td>延迟、重连机制</td>
</tr>
<tr>
<td>典型配置</td>
<td>SO_BACKLOG、连接数限制</td>
<td>CONNECT_TIMEOUT、重试</td>
</tr>
<tr>
<td>安全需求</td>
<td>需防范DDoS、实现访问控制</td>
<td>处理证书认证</td>
</tr>
</tbody></table>
<hr>
<h3 id="典型问题解决方案"><a href="#典型问题解决方案" class="headerlink" title="典型问题解决方案"></a><strong>典型问题解决方案</strong></h3><ol>
<li><p><strong>TIME_WAIT过多</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启用端口复用</span></span><br><span class="line">.option(ChannelOption.SO_REUSEADDR, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>内存泄漏检测</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启动时配置（需增加开销）</span></span><br><span class="line">ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.PARANOID);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>处理慢客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加读超时限制</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ReadTimeoutHandler</span>(<span class="number">30</span>, TimeUnit.SECONDS));</span><br></pre></td></tr></table></figure></li>
<li><p><strong>定制线程模型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用自定义线程池处理耗时操作</span></span><br><span class="line"><span class="type">EventExecutorGroup</span> <span class="variable">businessGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventExecutorGroup</span>(<span class="number">16</span>);</span><br><span class="line">pipeline.addLast(businessGroup, <span class="string">&quot;asyncHandler&quot;</span>, <span class="keyword">new</span> <span class="title class_">AsyncBusinessHandler</span>());</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p>以上实现涵盖Netty服务端的核心最佳实践，建议根据实际业务需求进行以下扩展：</p>
<ol>
<li><strong>协议层</strong>：添加认证/心跳机制</li>
<li><strong>管理层</strong>：实现HTTP管理端点查看连接状态</li>
<li><strong>可观测性</strong>：集成APM监控工具</li>
<li><strong>高可用</strong>：结合服务发现组件实现集群部署</li>
</ol>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>以下是Netty客户端建立连接的最佳实践示例代码，包含详细的注释和关键设计说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClientBestPractice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RETRY</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 最大重试次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BASE_DELAY</span> <span class="operator">=</span> <span class="number">1000</span>; <span class="comment">// 基础重试延迟(ms)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isShuttingDown</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup workerGroup;</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NettyClientBestPractice</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 配置线程组</span></span><br><span class="line">        workerGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>); <span class="comment">// 建议根据业务调整线程数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 配置Bootstrap</span></span><br><span class="line">        <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">        bootstrap.group(workerGroup)</span><br><span class="line">                .channel(NioSocketChannel.class) <span class="comment">// 根据OS选择Epoll</span></span><br><span class="line">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">3000</span>) <span class="comment">// 连接超时</span></span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>) <span class="comment">// TCP保活</span></span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">                        <span class="comment">// 3. 配置管道流水线</span></span><br><span class="line">                        ch.pipeline()</span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO)) <span class="comment">// 日志</span></span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">ClientBusinessHandler</span>()); <span class="comment">// 业务处理器</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 异步连接（非阻塞）</span></span><br><span class="line">        connectWithRetry(bootstrap, HOST, PORT, MAX_RETRY);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 注册优雅关闭钩子</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>::shutdownGracefully));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带指数退避的重连机制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">connectWithRetry</span><span class="params">(Bootstrap bootstrap, String host, <span class="type">int</span> port, <span class="type">int</span> retry)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isShuttingDown) <span class="keyword">return</span>;</span><br><span class="line">			</span><br><span class="line">            bootstrap.connect(host, port).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Connected to server!&quot;</span>);</span><br><span class="line">                channel = future.channel();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 6. 注册连接关闭监听</span></span><br><span class="line">                channel.closeFuture().addListener(closeFuture -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Connection closed, attempting reconnect...&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!isShuttingDown) &#123;</span><br><span class="line">                        connectWithRetry(bootstrap, host, port, MAX_RETRY);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retry == <span class="number">0</span>) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Connection failed after max retries: &quot;</span> + future.cause());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">attempt</span> <span class="operator">=</span> MAX_RETRY - retry + <span class="number">1</span>;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> (<span class="type">long</span>) (Math.pow(<span class="number">2</span>, attempt) * <span class="number">500</span>);</span><br><span class="line">                System.err.printf(<span class="string">&quot;Connect failed, retry %d after %dms: %s\n&quot;</span>, </span><br><span class="line">                        retry, delay, future.cause().getMessage());</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 7. 定时重连（避免阻塞EventLoop）</span></span><br><span class="line">                bootstrap.config().group().schedule(() -&gt; </span><br><span class="line">                        connectWithRetry(bootstrap, host, port, retry - <span class="number">1</span>), </span><br><span class="line">                        delay, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优雅关闭（可被多次调用）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">shutdownGracefully</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isShuttingDown) <span class="keyword">return</span>;</span><br><span class="line">        isShuttingDown = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8. 关闭顺序：Channel -&gt; EventLoopGroup</span></span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="literal">null</span>) &#123;</span><br><span class="line">            channel.close().addListener(future -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Channel closed successfully&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9. 优雅关闭线程组</span></span><br><span class="line">        <span class="keyword">if</span> (workerGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">            workerGroup.shutdownGracefully(<span class="number">0</span>, <span class="number">500</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">                    .addListener((GenericFutureListener&lt;Future&lt;? <span class="built_in">super</span> Void&gt;&gt;) future -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;EventLoopGroup shutdown complete&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示例业务处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClientBusinessHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Connection established, send auth packet&quot;</span>);</span><br><span class="line">            <span class="comment">// 连接建立后发送认证数据等业务逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">            <span class="comment">// 处理服务器响应</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Business exception: &quot;</span> + cause.getMessage());</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="关键设计说明"><a href="#关键设计说明" class="headerlink" title="关键设计说明"></a><strong>关键设计说明</strong></h3><ol>
<li><p><strong>线程模型优化</strong></p>
<ul>
<li>使用独立的<code>EventLoopGroup</code>（推荐1-2线程）</li>
<li>禁止在 ChannelHandler 中执行阻塞操作</li>
</ul>
</li>
<li><p><strong>连接管理</strong></p>
<ul>
<li>内置指数退避重连机制（避免DDoS式重连）</li>
<li>连接关闭自动触发重连（通过<code>closeFuture</code>监听）</li>
<li>支持强制关闭标识<code>isShuttingDown</code> </li>
</ul>
</li>
<li><p><strong>资源管理</strong></p>
<ul>
<li>正确关闭顺序：Channel -&gt; EventLoopGroup</li>
<li>添加Shutdown Hook确保资源释放</li>
<li>使用<code>shutdownGracefully</code>避免强制中断</li>
</ul>
</li>
<li><p><strong>异常处理</strong></p>
<ul>
<li>连接失败时打印具体原因</li>
<li>业务层异常统一在<code>exceptionCaught</code>处理</li>
<li>重试机制记录每次失败原因</li>
</ul>
</li>
<li><p><strong>可观测性</strong></p>
<ul>
<li>内置<code>LoggingHandler</code>记录网络事件</li>
<li>关键节点添加状态日志</li>
</ul>
</li>
<li><p><strong>扩展性设计</strong></p>
<ul>
<li>通过<code>ChannelInitializer</code>灵活配置Pipeline</li>
<li>支持NIO/Epoll自动切换（通过系统属性）</li>
</ul>
</li>
</ol>
<hr>
<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a><strong>使用建议</strong></h3><ol>
<li><p><strong>生产环境配置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建议设置TCP参数</span></span><br><span class="line">.option(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">.option(ChannelOption.SO_REUSEADDR, <span class="literal">true</span>)</span><br><span class="line">.option(ChannelOption.WRITE_BUFFER_WATER_MARK, </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">WriteBufferWaterMark</span>(<span class="number">32</span> * <span class="number">1024</span>, <span class="number">64</span> * <span class="number">1024</span>))</span><br></pre></td></tr></table></figure></li>
<li><p><strong>连接池管理</strong></p>
<ul>
<li>高并发场景建议使用连接池</li>
<li>参考实现：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Bootstrap bootstrap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Channel&gt; pool = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Channel <span class="title function_">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> pool.poll();</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> channel;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bootstrap.connect().sync().channel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>性能监控</strong></p>
<ul>
<li>添加MetricHandler统计QPS/延迟</li>
<li>使用Netty自带<code>ChannelTrafficShapingHandler</code></li>
</ul>
</li>
</ol>
<hr>
<h3 id="典型问题处理"><a href="#典型问题处理" class="headerlink" title="典型问题处理"></a><strong>典型问题处理</strong></h3><ol>
<li><p><strong>连接泄漏检测</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加空闲检测</span></span><br><span class="line">.addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">60</span>, TimeUnit.SECONDS))</span><br><span class="line">.addLast(<span class="keyword">new</span> <span class="title class_">ChannelDuplexHandler</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>流量整形</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 限制发送速率（1MB/s）</span></span><br><span class="line">.addLast(<span class="keyword">new</span> <span class="title class_">ChannelTrafficShapingHandler</span>(<span class="number">1024</span> * <span class="number">1024</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure></li>
<li><p><strong>协议设计建议</strong></p>
<ul>
<li>使用LengthFieldBasedFrameDecoder解决粘包</li>
<li>建议Protobuf/FlatBuffers等高效序列化</li>
</ul>
</li>
</ol>
<hr>
<p>以上实现遵循Netty最佳实践，具备生产级可靠性，可根据具体业务需求扩展调整。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO：Buffer、Channel 和 Selector(转自Javadoop)</title>
    <url>/2018/02/02/NIO/</url>
    <content><![CDATA[<p>本文将介绍 Java NIO 中三大组件 <strong>Buffer、Channel、Selector</strong> 的使用。</p>
<p>本来要一起介绍<strong>非阻塞 IO</strong> 和 JDK7 的<strong>异步 IO</strong> 的，不过因为之前的文章真的太长了，有点影响读者阅读，所以这里将它们放到另一篇文章中进行介绍。</p>
<!-- toc -->


<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>一个 Buffer 本质上是内存中的一块，我们可以将数据写入这块内存，之后从这块内存获取数据。</p>
<p>java.nio 定义了以下几个 Buffer 的实现，这个图读者应该也在不少地方见过了吧。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/nio/6.png" alt="6"></p>
<p>其实核心是最后的 <strong>ByteBuffer</strong>，前面的一大串类只是包装了一下它而已，我们使用最多的通常也是 ByteBuffer。</p>
<p>我们应该将 Buffer 理解为一个数组，IntBuffer、CharBuffer、DoubleBuffer 等分别对应 int[]、char[]、double[] 等。</p>
<p>MappedByteBuffer 用于实现内存映射文件，也不是本文关注的重点。</p>
<p>我觉得操作 Buffer 和操作数组、类集差不多，只不过大部分时候我们都把它放到了 NIO 的场景里面来使用而已。下面介绍 Buffer 中的几个重要属性和几个重要方法。</p>
<h3 id="position、limit、capacity"><a href="#position、limit、capacity" class="headerlink" title="position、limit、capacity"></a>position、limit、capacity</h3><p>就像数组有数组容量，每次访问元素要指定下标，Buffer 中也有几个重要属性：position、limit、capacity。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/nio/5.png" alt="5"></p>
<p>最好理解的当然是 capacity，它代表这个缓冲区的容量，一旦设定就不可以更改。比如 capacity 为 1024 的 IntBuffer，代表其一次可以存放 1024 个 int 类型的值。一旦 Buffer 的容量达到 capacity，需要清空 Buffer，才能重新写入值。</p>
<p>position 和 limit 是变化的，我们分别看下读和写操作下，它们是如何变化的。</p>
<p><strong>position</strong> 的初始值是 0，每往 Buffer 中写入一个值，position 就自动加 1，代表下一次的写入位置。读操作的时候也是类似的，每读一个值，position 就自动加 1。</p>
<p>从写操作模式到读操作模式切换的时候（<strong>flip</strong>），position 都会归零，这样就可以从头开始读写了。</p>
<p><strong>Limit</strong>：写操作模式下，limit 代表的是最大能写入的数据，这个时候 limit 等于 capacity。写结束后，切换到读模式，此时的 limit 等于 Buffer 中实际的数据大小，因为 Buffer 不一定被写满了。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/nio/7.png" alt="7"></p>
<h3 id="初始化-Buffer"><a href="#初始化-Buffer" class="headerlink" title="初始化 Buffer"></a>初始化 Buffer</h3><p>每个 Buffer 实现类都提供了一个静态方法 <code>allocate(int capacity)</code> 帮助我们快速实例化一个 Buffer。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="type">IntBuffer</span> <span class="variable">intBuf</span> <span class="operator">=</span> IntBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="type">LongBuffer</span> <span class="variable">longBuf</span> <span class="operator">=</span> LongBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>另外，我们经常使用 wrap 方法来初始化一个 Buffer。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">wrap</span><span class="params">(<span class="type">byte</span>[] array)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="填充-Buffer"><a href="#填充-Buffer" class="headerlink" title="填充 Buffer"></a>填充 Buffer</h3><p>各个 Buffer 类都提供了一些 put 方法用于将数据填充到 Buffer 中，如 ByteBuffer 中的几个 put 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 填充一个 byte 值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">put</span><span class="params">(<span class="type">byte</span> b)</span>;</span><br><span class="line"><span class="comment">// 在指定位置填充一个 int 值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span> index, <span class="type">byte</span> b)</span>;</span><br><span class="line"><span class="comment">// 将一个数组中的值填充进去</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title function_">put</span><span class="params">(<span class="type">byte</span>[] src)</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> ByteBuffer <span class="title function_">put</span><span class="params">(<span class="type">byte</span>[] src, <span class="type">int</span> offset, <span class="type">int</span> length)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>上述这些方法需要自己控制 Buffer 大小，不能超过 capacity，超过会抛 java.nio.BufferOverflowException 异常。</p>
<p>对于 Buffer 来说，另一个常见的操作中就是，我们要将来自 Channel 的数据填充到 Buffer 中，在系统层面上，这个操作我们称为<strong>读操作</strong>，因为数据是从外部（文件或网络等）读到内存中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> channel.read(buf);</span><br></pre></td></tr></table></figure>

<p>上述方法会返回从 Channel 中读入到 Buffer 的数据大小。</p>
<h3 id="提取-Buffer-中的值"><a href="#提取-Buffer-中的值" class="headerlink" title="提取 Buffer 中的值"></a>提取 Buffer 中的值</h3><p>前面介绍了写操作，每写入一个值，position 的值都需要加 1，所以 position 最后会指向最后一次写入的位置的后面一个，如果 Buffer 写满了，那么 position 等于 capacity（position 从 0 开始）。</p>
<p>如果要读 Buffer 中的值，需要切换模式，从写入模式切换到读出模式。注意，通常在说 NIO 的读操作的时候，我们说的是从 Channel 中读数据到 Buffer 中，对应的是对 Buffer 的写入操作，初学者需要理清楚这个。</p>
<p>调用 Buffer 的 <strong>flip()</strong> 方法，可以从写入模式切换到读取模式。其实这个方法也就是设置了一下 position 和 limit 值罢了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">flip</span><span class="params">()</span> &#123;</span><br><span class="line">    limit = position; <span class="comment">// 将 limit 设置为实际写入的数据数量</span></span><br><span class="line">    position = <span class="number">0</span>; <span class="comment">// 重置 position 为 0</span></span><br><span class="line">    mark = -<span class="number">1</span>; <span class="comment">// mark 之后再说</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应写入操作的一系列 put 方法，读操作提供了一系列的 get 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 position 来获取数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">byte</span> <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 获取指定位置的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">byte</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"><span class="comment">// 将 Buffer 中的数据写入到数组中</span></span><br><span class="line"><span class="keyword">public</span> ByteBuffer <span class="title function_">get</span><span class="params">(<span class="type">byte</span>[] dst)</span></span><br></pre></td></tr></table></figure>
<p>附一个经常使用的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(buffer.array()).trim();</span><br></pre></td></tr></table></figure>

<p>当然了，除了将数据从 Buffer 取出来使用，更常见的操作是将我们写入的数据传输到 Channel 中，如通过 FileChannel 将数据写入到文件中，通过 SocketChannel 将数据写入网络发送到远程机器等。对应的，这种操作，我们称之为<strong>写操作</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> channel.write(buf);</span><br></pre></td></tr></table></figure>

<h3 id="mark-amp-reset"><a href="#mark-amp-reset" class="headerlink" title="mark() &amp; reset()"></a>mark() &amp; reset()</h3><p>除了 position、limit、capacity 这三个基本的属性外，还有一个常用的属性就是 mark。</p>
<p>mark 用于临时保存 position 的值，每次调用 mark() 方法都会将 mark 设值为当前的 position，便于后续需要的时候使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">mark</span><span class="params">()</span> &#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那到底什么时候用呢？考虑以下场景，我们在 position 为 5 的时候，先 mark() 一下，然后继续往下读，读到第 10 的时候，我想重新回到 position 为 5 的地方重新来一遍，那只要调一下 reset() 方法，position 就回到 5 了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidMarkException</span>();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="rewind-amp-clear-amp-compact"><a href="#rewind-amp-clear-amp-compact" class="headerlink" title="rewind() &amp; clear() &amp; compact()"></a>rewind() &amp; clear() &amp; compact()</h3><p>**rewind()**：会重置 position 为 0，通常用于重新从头读写 Buffer。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">rewind</span><span class="params">()</span> &#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**clear()**：有点重置 Buffer 的意思，相当于重新实例化了一样。</p>
<p>通常，我们会先填充 Buffer，然后从 Buffer 读取数据，之后我们再重新往里填充新的数据，我们一般在重新填充之前先调用 clear()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**compact()**：和 clear() 一样的是，它们都是在准备往 Buffer 填充新的数据之前调用。</p>
<p>前面说的 clear() 方法会重置几个属性，但是我们要看到，clear() 方法并不会将 Buffer 中的数据清空，只不过后续的写入会覆盖掉原来的数据，也就相当于清空了数据了。</p>
<p>而 compact() 方法有点不一样，调用这个方法以后，会先处理还没有读取的数据，也就是 position 到 limit 之间的数据（还没有读过的数据），先将这些数据移到左边，然后在这个基础上再开始写入。很明显，此时 limit 还是等于 capacity，position 指向原来数据的右边。</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>所有的 NIO 操作始于通道，通道是数据来源或数据写入的目的地，主要地，我们将关心 java.nio 包中实现的以下几个 Channel：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/nio/8.png" alt="8"></p>
<ul>
<li>FileChannel：文件通道，用于文件的读和写</li>
<li>DatagramChannel：用于 UDP 连接的接收和发送</li>
<li>SocketChannel：把它理解为 TCP 连接通道，简单理解就是 TCP 客户端</li>
<li>ServerSocketChannel：TCP 对应的服务端，用于监听某个端口进来的请求</li>
</ul>
<p><strong>这里不是很理解这些也没关系，后面介绍了代码之后就清晰了。还有，我们最应该关注，也是后面将会重点介绍的是 SocketChannel 和 ServerSocketChannel。</strong></p>
<p>Channel 经常翻译为通道，类似 IO 中的流，用于读取和写入。它与前面介绍的 Buffer 打交道，读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/nio/9.png" alt="9"></p>
<p><img src="https://assets.javadoop.com/imgs/20510079/nio/10.png" alt="10"></p>
<p>至少读者应该记住一点，这两个方法都是 channel 实例的方法。</p>
<h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><p>我想文件操作对于大家来说应该是最熟悉的，不过我们在说 NIO 的时候，其实 FileChannel 并不是关注的重点。而且后面我们说非阻塞的时候会看到，FileChannel 是不支持非阻塞的。</p>
<p><strong>这里算是简单介绍下常用的操作吧，感兴趣的读者瞄一眼就是了。</strong></p>
<p><strong>初始化：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/data.txt&quot;</span>));</span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> inputStream.getChannel();</span><br></pre></td></tr></table></figure>

<p>当然了，我们也可以从 RandomAccessFile#getChannel 来得到 FileChannel。</p>
<p><strong>读取文件内容：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> fileChannel.read(buffer);</span><br></pre></td></tr></table></figure>

<p>前面我们也说了，所有的 Channel 都是和 Buffer 打交道的。</p>
<p><strong>写入文件内容：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">buffer.put(<span class="string">&quot;随机写入一些内容到 Buffer 中&quot;</span>.getBytes());</span><br><span class="line"><span class="comment">// Buffer 切换为读模式</span></span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">    <span class="comment">// 将 Buffer 中的内容写入文件</span></span><br><span class="line">    fileChannel.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><p>我们前面说了，我们可以将 SocketChannel 理解成一个 TCP 客户端。虽然这么理解有点狭隘，因为我们在介绍 ServerSocketChannel 的时候会看到另一种使用方式。</p>
<p>打开一个 TCP 连接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;https://www.javadoop.com&quot;</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure>

<p>当然了，上面的这行代码等价于下面的两行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开一个通道</span></span><br><span class="line"><span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line"><span class="comment">// 发起连接</span></span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;https://www.javadoop.com&quot;</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure>

<p>SocketChannel 的读写和 FileChannel 没什么区别，就是操作缓冲区。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line">socketChannel.read(buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入数据到网络连接中</span></span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">    socketChannel.write(buffer);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要在这里停留太久，先继续往下走。</p>
<h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><p>之前说 SocketChannel 是 TCP 客户端，这里说的 ServerSocketChannel 就是对应的服务端。</p>
<p>ServerSocketChannel 用于监听机器端口，管理从这个端口进来的 TCP 连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"><span class="comment">// 监听 8080 端口</span></span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 一旦有一个 TCP 连接进来，就对应创建一个 SocketChannel 进行处理</span></span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们可以看到 SocketChannel 的第二个实例化方式</p>
</blockquote>
<p>到这里，我们应该能理解 SocketChannel 了，它不仅仅是 TCP 客户端，它代表的是一个网络通道，可读可写。</p>
<p>ServerSocketChannel 不和 Buffer 打交道了，因为它并不实际处理数据，它一旦接收到请求后，实例化 SocketChannel，之后在这个连接通道上的数据传递它就不管了，因为它需要继续监听端口，等待下一个连接。</p>
<h3 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h3><p>UDP 和 TCP 不一样，DatagramChannel 一个类处理了服务端和客户端。</p>
<blockquote>
<p>科普一下，UDP 是面向无连接的，不需要和对方握手，不需要通知对方，就可以直接将数据包投出去，至于能不能送达，它是不知道的</p>
</blockquote>
<p><strong>监听端口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DatagramChannel</span> <span class="variable">channel</span> <span class="operator">=</span> DatagramChannel.open();</span><br><span class="line">channel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9090</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line">channel.receive(buf);</span><br></pre></td></tr></table></figure>

<p><strong>发送数据：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">newData</span> <span class="operator">=</span> <span class="string">&quot;New String to write to file...&quot;</span></span><br><span class="line">                    + System.currentTimeMillis();</span><br><span class="line">    </span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">bytesSent</span> <span class="operator">=</span> channel.send(buf, <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;jenkov.com&quot;</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure>

<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>NIO 三大组件就剩 Selector 了，Selector 建立在非阻塞的基础之上，大家经常听到的 <strong>多路复用</strong> 在 Java 世界中指的就是它，用于实现一个线程管理多个 Channel。</p>
<p>读者在这一节不能消化 Selector 也没关系，因为后续在介绍非阻塞 IO 的时候还得说到这个，这里先介绍一些基本的接口操作。</p>
<ol>
<li><p>首先，我们开启一个 Selector。你们爱翻译成<strong>选择器</strong>也好，<strong>多路复用器</strong>也好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br></pre></td></tr></table></figure></li>
<li><p>将 Channel 注册到 Selector 上。前面我们说了，Selector 建立在非阻塞模式之上，所以注册到 Selector 的 Channel 必须要支持非阻塞模式，<strong>FileChannel 不支持非阻塞</strong>，我们这里讨论最常见的 SocketChannel 和 ServerSocketChannel。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将通道设置为非阻塞模式，因为默认都是阻塞模式的</span></span><br><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>

<p>register 方法的第二个 int 型参数（使用二进制的标记位）用于表明需要监听哪些感兴趣的事件，共以下四种事件：</p>
<ul>
<li><p>SelectionKey.OP_READ</p>
<blockquote>
<p>对应 00000001，通道中有数据可以进行读取</p>
</blockquote>
</li>
<li><p>SelectionKey.OP_WRITE</p>
<blockquote>
<p>对应 00000100，可以往通道中写入数据</p>
</blockquote>
</li>
<li><p>SelectionKey.OP_CONNECT</p>
<blockquote>
<p>对应 00001000，成功建立 TCP 连接</p>
</blockquote>
</li>
<li><p>SelectionKey.OP_ACCEPT</p>
<blockquote>
<p>对应 00010000，接受 TCP 连接</p>
</blockquote>
</li>
</ul>
<p>我们可以同时监听一个 Channel 中的发生的多个事件，比如我们要监听 ACCEPT 和 READ 事件，那么指定参数为二进制的 000<strong>1</strong>000<strong>1</strong> 即十进制数值 17 即可。</p>
<p>注册方法返回值是 <strong>SelectionKey</strong> 实例，它包含了 Channel 和 Selector 信息，也包括了一个叫做 Interest Set 的信息，即我们设置的我们感兴趣的正在监听的事件集合。</p>
</li>
<li><p>调用 select() 方法获取通道信息。用于判断是否有我们感兴趣的事件已经发生了。</p>
</li>
</ol>
<p>Selector 的操作就是以上 3 步，这里来一个简单的示例，大家看一下就好了。之后在介绍非阻塞 IO 的时候，会演示一份可执行的示例代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断是否有事件准备好</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">readyChannels</span> <span class="operator">=</span> selector.select();</span><br><span class="line">  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历</span></span><br><span class="line">  Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">  Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 Selector，我们还需要非常熟悉以下几个方法：</p>
<ol>
<li><strong>select()</strong></li>
</ol>
<p>  调用此方法，会将<strong>上次 select 之后的</strong>准备好的 channel 对应的 SelectionKey 复制到 selected set 中。如果没有任何通道准备好，这个方法会阻塞，直到至少有一个通道准备好。</p>
<ol start="2">
<li><p><strong>selectNow()</strong></p>
<p>功能和 select 一样，区别在于如果没有准备好的通道，那么此方法会立即返回 0。</p>
</li>
<li><p><strong>select(long timeout)</strong></p>
<p>看了前面两个，这个应该很好理解了，如果没有通道准备好，此方法会等待一会</p>
</li>
<li><p><strong>wakeup()</strong></p>
<p>这个方法是用来唤醒等待在 select() 和 select(timeout) 上的线程的。如果 wakeup() 先被调用，此时没有线程在 select 上阻塞，那么之后的一个 select() 或 select(timeout) 会立即返回，而不会阻塞，当然，它只会作用一次。</p>
</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此为止，介绍了 Buffer、Channel 和 Selector 的常见接口。</p>
<p>Buffer 和数组差不多，它有 position、limit、capacity 几个重要属性。put() 一下数据、flip() 切换到读模式、然后用 get() 获取数据、clear() 一下清空数据、重新回到 put() 写入数据。</p>
<p>Channel 基本上只和 Buffer 打交道，最重要的接口就是 channel.read(buffer) 和 channel.write(buffer)。</p>
<p>Selector 用于实现非阻塞 IO，这里仅仅介绍接口使用，后续请关注非阻塞 IO 的介绍。</p>
<p>（全文完）</p>
]]></content>
      <categories>
        <category>jdk</category>
      </categories>
      <tags>
        <tag>nio</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2024/08/15/Spring%20SpringMVC%20SpringBoot/</url>
    <content><![CDATA[<h1 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h1><p>IoC: Inverse of Control 原先调用服务或者DAO的需要自行new出来对象，硬编码，耦合程度高，Spring的Container能够接管对象的创建工作（实际上就是管理Bean） 并且能够根据对象Bean之间的关系进行依赖注入，创建A对象的同时会把B对象创建起来，也就是DI(Dependency Injection)</p>
<p>管理方式：配置文件xml            IoC容器的获取：Spring提供接口</p>
<p>把业务接口的实现类交给Spring管理，遇到接口类，Spring就会自动去找Bean中是否有接口的实现类。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020194848409.png" alt="image-20241020194848409"></p>
<p>BookDao是接口，实现类为BookDaoImpl，Impl交给Spring管理</p>
<p>DI：依赖注入，依赖用方法传参的方式传入</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019114405108.png" alt="image-20241019114405108"></p>
<p>property name 是成员变量的名字</p>
<p>ref 是要引用的bean id/name</p>
<h2 id="IoC-配置"><a href="#IoC-配置" class="headerlink" title="IoC 配置"></a>IoC 配置</h2><h3 id="bean-管理"><a href="#bean-管理" class="headerlink" title="bean 管理"></a>bean 管理</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019222443537.png" alt="image-20241019222443537"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019115106810.png" alt="image-20241019115106810"></p>
<h4 id="name-别名"><a href="#name-别名" class="headerlink" title="name 别名"></a>name 别名</h4><p><u>ATTRIBUTE</u></p>
<p>bean <strong>name</strong> = “s1 s2 s3”  alias</p>
<p><strong>ref</strong>可以使用name也可以使用id</p>
<p>getBean </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019144037398.png" alt="image-20241019144037398"></p>
<h4 id="scope-作用范围"><a href="#scope-作用范围" class="headerlink" title="scope 作用范围"></a>scope 作用范围</h4><p><u>ATTRIBUTE</u></p>
<p>Spring默认创建<strong>单例</strong>bean，scope=”singleton” prototype为多例。</p>
<ul>
<li>适合复用的才作为bean交给IoC容器管理<ul>
<li>表现层，业务层，DAO层，工具层</li>
</ul>
</li>
<li>不适合复用的对象<ul>
<li>封装的实体域对象</li>
</ul>
</li>
</ul>
<h4 id="bean-创建方式"><a href="#bean-创建方式" class="headerlink" title="bean 创建方式"></a>bean 创建方式</h4><h5 id="使用构造方法"><a href="#使用构造方法" class="headerlink" title="使用构造方法"></a><mark>使用构造方法<mark></h5><p>无参构造器，如果使用构造器进行依赖注入，则走的是有参构造</p>
<h5 id="使用静态工厂实例化Bean"><a href="#使用静态工厂实例化Bean" class="headerlink" title="使用静态工厂实例化Bean"></a>使用静态工厂实例化Bean</h5><ul>
<li>工厂的静态方法factoryMethod(return new Bean)，不造工厂，调用工厂的<strong>静态</strong>方法造Bean <u>ATTRIBUTE</u>: factory-method</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019160109618.png" alt="image-20241019160109618"></p>
<h5 id="使用实例工厂实例化Bean"><a href="#使用实例工厂实例化Bean" class="headerlink" title="使用实例工厂实例化Bean"></a>使用实例工厂实例化Bean</h5><ul>
<li>先造工厂bean再调用工厂的<strong>实例</strong>方法(return newBean) 造bean</li>
</ul>
<h5 id="FactoryBean-实例工厂bean"><a href="#FactoryBean-实例工厂bean" class="headerlink" title="FactoryBean 实例工厂bean"></a><mark>FactoryBean 实例工厂bean<mark></h5><ul>
<li><p>第三方自定义工厂Bean类实现FactoryBean接口，重写方法<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019160946566.png" alt="image-20241019160946566"></p>
<ul>
<li>getObject 工厂类的returnNewBean方法</li>
<li>getObjectType return Bean.class bean的 字节码</li>
<li>isSingleton 单例</li>
</ul>
</li>
<li><p>xml 配置<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019161457148.png" alt="image-20241019161457148">    </p>
</li>
<li><p>主要用于第三方框架和Spring框架对接，他们创建的对象要配置一些参数，这时就需要一个FactoryBean，工厂bean会提供set对象参数的方法，返回的就是配好参的对象，可以省去手动配参的麻烦</p>
</li>
</ul>
<h4 id="bean-生命周期"><a href="#bean-生命周期" class="headerlink" title="bean 生命周期"></a>bean 生命周期</h4><p><a href="https://docs.spring.io/spring-framework/reference/core/beans/factory-nature.html#beans-factory-lifecycle-initializingbean">Customizing the Nature of a Bean :: Spring Framework</a> </p>
<h5 id="init-method-初始化"><a href="#init-method-初始化" class="headerlink" title="init-method 初始化"></a>init-method 初始化</h5><p><u>ATTRIBUTE</u> 方法名</p>
<h5 id="destroy-method-销毁"><a href="#destroy-method-销毁" class="headerlink" title="destroy-method 销毁"></a>destroy-method 销毁</h5><p><u>ATTRIBUTE</u> 方法名</p>
<p>销毁方式1: 容器关闭 <code>ctx.close()</code> appctx这个类没有关闭功能，换一个annotationConfigAppctx才有</p>
<p>销毁方式2: 注册关闭钩子<code>ctx.registerShutdownHook()</code></p>
<h5 id="自定义实体类实现接口"><a href="#自定义实体类实现接口" class="headerlink" title="自定义实体类实现接口"></a>自定义实体类实现接口</h5><p><code>DisposableBean</code> <code>InitializingBean</code> </p>
<p>分别重写destory() afterPropertiesSet()</p>
<p>属性设置就是在属性注入(调用setter)之后调用的方法</p>
<h5 id="生命周期示意图"><a href="#生命周期示意图" class="headerlink" title="生命周期示意图"></a>生命周期示意图</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019163321664.png" alt="image-20241019163321664"></p>
<h3 id="DI-依赖注入"><a href="#DI-依赖注入" class="headerlink" title="DI 依赖注入"></a>DI 依赖注入</h3><p><strong>注入</strong> ⇔ <strong>给bean的属性赋值</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019222530413.png" alt="image-20241019222530413"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019163720566.png" alt="image-20241019163720566"></p>
<p>注入多个bean，填写多个property</p>
<h4 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h4><h5 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a><mark>setter注入<mark></h5><ol>
<li>setter 引用其他的bean property ref = 其他bean的名称 <u>ATTRIBUTE</u></li>
<li>setter 注入基本数据类型和简单值 property value = 值  <u>ATTRIBUTE</u></li>
<li>property name实际上是根据setter方法 setUserDao 去掉set首字母小写 userDao得到的</li>
<li>先无参构造创建bean，再用setter注入依赖</li>
</ol>
<h5 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h5><p>针对有参构造器，必须显式声明有参构造器</p>
<p> <u>ATTRIBUTE</u> <code>&lt;constructor-arg name&gt;</code></p>
<ol>
<li><p> 引用其他bean name是构造器形参名，<strong>耦合度高</strong>，参数先后顺序固定不能变<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019173838816.png" alt="image-20241019173838816"></p>
</li>
<li><p> 基本数据类型和简单值<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019174107702.png" alt="image-20241019174107702"></p>
</li>
<li><p>耦合度高解决方案：<strong>参数适配</strong></p>
<ul>
<li><p><code>&lt;constructor-arg name&gt;</code>改成type，解决参数名的高耦合，但是type相同的参数会混淆</p>
</li>
<li><p>改成index，index表示参数的位置</p>
</li>
</ul>
</li>
<li><p> 直接有参构造创建bean，可以没有无参构造</p>
</li>
</ol>
<h4 id="方式选择"><a href="#方式选择" class="headerlink" title="方式选择"></a>方式选择</h4><ul>
<li><strong>强制依赖</strong>使用构造器进行，使用setter注入有概率不进行注入导致NullPointerException</li>
<li><strong>可选依赖</strong>使用setter注入进行，灵活性强</li>
<li>Spring框架倡导使用构造器,第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨</li>
<li>如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入</li>
<li>实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</li>
<li><u>自己开发的模块推荐使用setter注入</u></li>
</ul>
<h4 id="依赖自动装配-autowire"><a href="#依赖自动装配-autowire" class="headerlink" title="依赖自动装配 autowire"></a>依赖自动装配 <span id="autowire">autowire</span></h4><p>只适用于引用类型</p>
<p><u>ATTRIBUTE</u> </p>
<p>不去手动指定，在容器的bean中自动匹配适合的bean。依赖于有参构造或者setter</p>
<h5 id="byType-依赖setter"><a href="#byType-依赖setter" class="headerlink" title="byType (依赖setter)"></a><mark>byType<mark> (依赖setter)</h5><p><code>bean属性的type</code> 要去匹配 <code>容器中bean的class</code></p>
<p>保证相同class的bean唯一 推荐</p>
<h5 id="byName-依赖setter"><a href="#byName-依赖setter" class="headerlink" title="byName (依赖setter)"></a>byName (依赖setter)</h5><p><code>bean属性的name</code> 要去匹配 <code>容器中bean的id</code></p>
<p>保证必须要有指定名称的bean  耦合度高，不推荐</p>
<h5 id="constructor-依赖有参构造器"><a href="#constructor-依赖有参构造器" class="headerlink" title="constructor(依赖有参构造器)"></a>constructor(依赖有参构造器)</h5><h5 id="default"><a href="#default" class="headerlink" title="default"></a>default</h5><p>如果&lt;beans&gt;指定了autowire 此bean跟随beans</p>
<h5 id="no"><a href="#no" class="headerlink" title="no"></a>no</h5><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li><p>只能自动装配引用类型（IoC容器不会去管理简单类型）包装类bean根本没法写</p>
</li>
<li><p>优先级 &lt; 手动装配</p>
</li>
</ul>
<h4 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h4><p>集合要注入内容，而不是注一个空壳</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myArray&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>5<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">value</span>&gt;</span>this<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>that<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>where<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mySet&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">value</span>&gt;</span>this<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>that<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>where<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;A&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;B&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;C&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myProperties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;A&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;B&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;C&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="管理第三方Bean"><a href="#管理第三方Bean" class="headerlink" title="管理第三方Bean"></a>管理第三方Bean</h3><p>别人写的对象，创建bean，类型是什么？你要配哪些参数？</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019191451764.png" alt="image-20241019191451764"></p>
<h4 id="加载-properties-XML-Namespace-JDBC-MyBatis-XML-Maven-md"><a href="#加载-properties-XML-Namespace-JDBC-MyBatis-XML-Maven-md" class="headerlink" title="加载.properties ([XML Namespace](.\JDBC MyBatis XML Maven.md))"></a>加载.properties ([XML Namespace](.\JDBC MyBatis XML Maven.md))</h4><p>创建context命名空间</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019192317628.png" alt="image-20241019192317628"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019220634669.png" alt="image-20241019220634669"></p>
<p>classpath:*.properties 当前模块下所有的配置文件</p>
<h3 id="容器-ctx"><a href="#容器-ctx" class="headerlink" title="容器 ctx"></a>容器 ctx</h3><h4 id="创建容器方式"><a href="#创建容器方式" class="headerlink" title="创建容器方式"></a>创建容器方式</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019221415451.png" alt="image-20241019221415451"></p>
<h4 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019221407031.png" alt="image-20241019221407031"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019221914707.png" alt="image-20241019221914707"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019222158026.png" alt="image-20241019222158026"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019221938964.png" alt="image-20241019221938964"></p>
<p>立即加载（饿汉），lazy-init 延迟加载 (懒汉)</p>
<h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><h3 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h3><h4 id="定义bean-Component"><a href="#定义bean-Component" class="headerlink" title="定义bean@Component"></a><mark>定义bean@Component<mark></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019223116345.png" alt="image-20241019223116345"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019223156078.png" alt="image-20241019223156078"></p>
<p>加上对应的bean的id ，不加就要加载字节码class</p>
<h4 id="纯注解开发-Configuration-ComponetScan"><a href="#纯注解开发-Configuration-ComponetScan" class="headerlink" title="纯注解开发@Configuration  @ComponetScan"></a><mark>纯注解开发@Configuration  @ComponetScan<mark></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019224153002.png" alt="image-20241019224153002"></p>
<p>获取ctx: <code>ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class)</code> </p>
<p>默认xml配置文件只给了beans的命名空间，context还得另外自己加，纯注解开发需要定义一个SpringConfig类，常用的配置都有，不用手动去加命名空间</p>
<p>XML out!</p>
<h3 id="2-bean管理"><a href="#2-bean管理" class="headerlink" title="2. bean管理"></a>2. bean管理</h3><h4 id="作用范围-Scope"><a href="#作用范围-Scope" class="headerlink" title="作用范围 @Scope"></a>作用范围 @Scope</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019225307356.png" alt="image-20241019225307356"></p>
<h4 id="生命周期-PostConstruct-PreDestroy"><a href="#生命周期-PostConstruct-PreDestroy" class="headerlink" title="生命周期 @PostConstruct @PreDestroy"></a>生命周期 @PostConstruct @PreDestroy</h4><p><a href="https://cloud.tencent.com/developer/article/2426419">探究Spring Boot中@PostConstruct注解的使用场景-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1588212">Spring 框架中 @PostConstruct 注解详解-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019225254913.png" alt="image-20241019225254913"></p>
<p>Instantiate(Constructor)&gt; @Autowired &gt; @PostConstruct</p>
<p>依赖注入完成，被显式调用之前</p>
<p><a href="https://docs.spring.io/spring-framework/reference/core/beans/annotation-config/postconstruct-and-predestroy-annotations.html">Using @PostConstruct and @PreDestroy :: Spring Framework</a></p>
<h3 id="DI-自动装配"><a href="#DI-自动装配" class="headerlink" title="DI 自动装配"></a>DI 自动装配</h3><h4 id="自动装配-Autowired（引用类型）"><a href="#自动装配-Autowired（引用类型）" class="headerlink" title="自动装配@Autowired（引用类型）"></a><mark>自动装配@Autowired（引用类型）<mark></h4><p>在需要注入依赖的<strong>一个</strong>属性</p>
<p>与配置文件<a href="#autowire">autowire Attribute of Bean</a>不同，注解Autowired不依赖于setter和有参构造器，直接暴力反射访问private属性，创建对象并注入依赖。 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020011345128.png" alt="image-20241020011345128"></p>
<h5 id="按名称匹配-Qualifier"><a href="#按名称匹配-Qualifier" class="headerlink" title="按名称匹配@Qualifier"></a>按名称匹配@Qualifier</h5><p>autowired默认按类型装 配，同一类型多个实现，用Qualifier指定具体bean名称，<em>不加Qualifier就按一定规则选择</em> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020011356460.png" alt="image-20241020011356460"></p>
<h5 id="先名称匹配，再按照类型匹配-Resource"><a href="#先名称匹配，再按照类型匹配-Resource" class="headerlink" title="先名称匹配，再按照类型匹配@Resource"></a>先名称匹配，再按照类型匹配@Resource</h5><p><a href="https://developer.aliyun.com/article/1003903">面试突击78：@Autowired 和 @Resource 有什么区别？-阿里云开发者社区 (aliyun.com)</a> </p>
<ul>
<li><strong>@Autowired 先根据类型（byType）查找，如果存在多个（Bean）再根据名称（byName）进行查找；</strong></li>
<li><strong>@Resource 先根据名称（byName）查找，如果（根据名称）查找不到，再根据类型（byType）进行查找。</strong> </li>
</ul>
<p>注意下方的<a href="#bean">Bean注解</a></p>
<p><strong>@Autowired 支持属性注入、构造方法注入和 Setter 注入，而 @Resource 只支持属性注入和 Setter 注入</strong> </p>
<p>@Autowired 来自 Spring 框架，而 @Resource 来自于（Java）JSR-250；</p>
<p>@Autowired 只支持设置 1 个参数，而 @Resource 支持设置 7 个参数；</p>
<p>@Autowired 既支持构造方法注入，又支持属性注入和 Setter 注入，而 @Resource 只支持属性注入和 Setter 注入；</p>
<h4 id="简单类型注入依赖-Value"><a href="#简单类型注入依赖-Value" class="headerlink" title="简单类型注入依赖@Value"></a>简单类型注入依赖@Value</h4><p>需要注入的属性上 写value</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020011954765.png" alt="image-20241020011954765"></p>
<h4 id="导入配置文件-PropertySource"><a href="#导入配置文件-PropertySource" class="headerlink" title="导入配置文件@PropertySource"></a>导入配置文件@PropertySource</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020011844984.png" alt="image-20241020011844984"></p>
<h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a><mark>循环依赖<mark></h4><p>Spring循环依赖指的是两个或多个Bean之间相互依赖，形成一个环状依赖的情况。简单来说，就是A依赖B，B依赖C，C依赖A，这样就形成了一个循环依赖的环。</p>
<p>Spring循环依赖通常会导致Bean无法正确地被实例化，从而导致应用程序无法正常启动或者出现异常。因此，Spring循环依赖是一种需要尽量避免的情况。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/633066ae3fcb2fcc117ab142dd90d3da-1730639875106-2.png"></p>
<h5 id="使用构造函数注入"><a href="#使用构造函数注入" class="headerlink" title="使用构造函数注入"></a>使用构造函数注入</h5><p>构造函数注入是一种相对保险的方式，因为在实例化Bean时，Spring会检查是否存在循环依赖，并在发现循环依赖时抛出异常，避免死循环。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用-Lazy注解"><a href="#使用-Lazy注解" class="headerlink" title="使用@Lazy注解"></a>使用@Lazy注解</h5><p>@Lazy注解可以延迟Bean的实例化，从而避免循环依赖的问题。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用setter方法注入"><a href="#使用setter方法注入" class="headerlink" title="使用setter方法注入"></a>使用setter方法注入</h5><p>使用setter方法注入也可以解决循环依赖的问题，但要注意可能出现的空指针异常。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">(B b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(A a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="管理第三方Bean-1"><a href="#管理第三方Bean-1" class="headerlink" title="管理第三方Bean"></a>管理第三方Bean</h3><h4 id="Config配置类中bean的创建-Bean"><a href="#Config配置类中bean的创建-Bean" class="headerlink" title="Config配置类中bean的创建@Bean"></a><span id="bean"><mark>Config配置类中bean的创建@Bean<mark></span></h4><p>与@Component不同 这个是方法级别的注解，方法返回的对象将由Spring容器管理</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020012511399.png" alt="image-20241020012511399"></p>
<h5 id="Bean声明的Bean名称？"><a href="#Bean声明的Bean名称？" class="headerlink" title="@Bean声明的Bean名称？"></a>@Bean声明的Bean名称？</h5><p><a href="https://blog.csdn.net/w1014074794/article/details/106768607">spring boot中通过注解@Bean声明的bean的名称是什么？_springboot 声明bean的名称-CSDN博客</a></p>
<h6 id="不指定name属性，bean名称为方法名"><a href="#不指定name属性，bean名称为方法名" class="headerlink" title="不指定name属性，bean名称为方法名"></a>不指定name属性，bean名称为方法名</h6><h6 id="指定name属性，bean名称为name"><a href="#指定name属性，bean名称为name" class="headerlink" title="指定name属性，bean名称为name"></a>指定name属性，bean名称为name</h6><h5 id="导入其他Config类到核心配置-Import"><a href="#导入其他Config类到核心配置-Import" class="headerlink" title="导入其他Config类到核心配置@Import"></a>导入其他Config类到核心配置@Import</h5><p>不建议直接把其他的配置写到SpringConfig里面，分出去然后import</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020012755726.png" alt="image-20241020012755726"></p>
<h4 id="DI-依赖注入-1"><a href="#DI-依赖注入-1" class="headerlink" title="DI 依赖注入"></a>DI 依赖注入</h4><p><span id="thirdpartydi">最简单的方法：自己new个对象出来，手动配参数，丢给spring</span> (其实xml就是把手动配参的过程从业务代码中解耦出来)</p>
<h5 id="简单类型依赖注入：成员变量-Value"><a href="#简单类型依赖注入：成员变量-Value" class="headerlink" title="简单类型依赖注入：成员变量@Value"></a>简单类型依赖注入：成员变量@Value</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020013246624.png" alt="image-20241020013246624"></p>
<h5 id="引用类型依赖注入：方法形参"><a href="#引用类型依赖注入：方法形参" class="headerlink" title="引用类型依赖注入：方法形参"></a><mark>引用类型依赖注入：方法形参<mark></h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020013406409.png" alt="image-20241020013406409"></p>
<h3 id="XML-vs-Annotation"><a href="#XML-vs-Annotation" class="headerlink" title="XML vs. Annotation"></a>XML vs. Annotation</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020013703651.png" alt="image-20241020013703651"></p>
<h2 id="整合第三方框架实战"><a href="#整合第三方框架实战" class="headerlink" title="整合第三方框架实战"></a>整合第三方框架实战</h2><h3 id="Spring-amp-MyBatis"><a href="#Spring-amp-MyBatis" class="headerlink" title="Spring &amp; MyBatis"></a>Spring &amp; MyBatis</h3><p><a href="https://blog.csdn.net/m0_64737877/article/details/122608987">使用纯注解方式Spring整合MyBatis_spring整合mybatis基于注解-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/SerikaOnoe/article/details/90639135">Spring整合Mybatis(注解方式完整过程，摒弃MyBatis配置文件)_springboot启动去除mybatis-CSDN博客</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020123544343.png" alt="image-20241020123544343"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020123756444.png" alt="image-20241020123756444"></p>
<p>dao是session用动态代理造出来的，不同业务的内部实现有区别。session也不会一直复用，根源在sqlSessionFactory。</p>
<p>还有一个就是mapper映射，这个跟ssf没什么关系。</p>
<h4 id="MyBatisConfig-SqlSessionFactoryBean"><a href="#MyBatisConfig-SqlSessionFactoryBean" class="headerlink" title="MyBatisConfig - SqlSessionFactoryBean"></a>MyBatisConfig - SqlSessionFactoryBean</h4><p>导入mybatis-spring spring-jdbc，mybatis实现了Spring规定的FactoryBean接口，专门用来造sqlSessionFactory对象。</p>
<p>回顾spring创建对象的方法，一种是<a href="#thirdpartydi">使用构造</a>器直接得到对象，另一种就是使用factoryBean&lt;E&gt;得到对象E，定义一个造E的工厂Bean，这样spring就知道类型E创对象需要用工厂Bean的方式。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020130218463.png" alt="image-20241020130218463"></p>
<p>factorybean中提供了很多设置E参数的方法，最终返回的是一个设置好参数的E，思想还是一样的，只不过套了一层工厂的皮，封装进去很多固定的参数set方法，一般这个E需要xml进行配置(跟真正的业务代码解耦)，工厂Bean就取代了xml，直接给你返回一个配置好的对象。</p>
<p>需要传参就直接在写上方法参数即可，spring自动匹配</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020145504890.png" alt="image-20241020145504890"></p>
<h4 id="MyBatisConfig-MapperScannerConfigurer"><a href="#MyBatisConfig-MapperScannerConfigurer" class="headerlink" title="MyBatisConfig - MapperScannerConfigurer"></a>MyBatisConfig - MapperScannerConfigurer</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020145526730.png" alt="image-20241020145526730"></p>
<p>DAO没有实现类了，在原始接口上加Component、Repository给ioc容器标识一下，不标也行。</p>
<p>这个mapperScannerConfigurer是mybatis和spring集成的部分，扫描指定mapper所在的包，mapper生成代理对象，通过factoryBean方式交给Spring容器，所以重点不是让spring知道dao的实现类在哪，重点是要让mybatis知道mapper位置</p>
<h4 id="JdbcConfig-创建DataSource的Bean交给Spring管理"><a href="#JdbcConfig-创建DataSource的Bean交给Spring管理" class="headerlink" title="JdbcConfig - 创建DataSource的Bean交给Spring管理"></a>JdbcConfig - 创建DataSource的Bean交给Spring管理</h4><h3 id="Spring-amp-JUnit"><a href="#Spring-amp-JUnit" class="headerlink" title="Spring &amp; JUnit"></a>Spring &amp; JUnit</h3><p>导入spring-test 在Test<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020191443245.png" alt="image-20241020191443245"></p>
<p>在test.java中测试。</p>
<h4 id="RunWith-ContextConfiguration"><a href="#RunWith-ContextConfiguration" class="headerlink" title="@RunWith @ContextConfiguration"></a>@RunWith @ContextConfiguration</h4><h4 id="Autowired-Test"><a href="#Autowired-Test" class="headerlink" title="@Autowired @Test"></a>@Autowired @Test</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020145826024.png" alt="image-20241020145826024"></p>
<p>需要引用类型参数直接autowired注入即可，一般是业务类做测试</p>
<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><h2 id="AOP的含义"><a href="#AOP的含义" class="headerlink" title="AOP的含义"></a>AOP的含义</h2><p>AOP 面向切面编程 <strong>不惊动原始设计</strong>的情况下增强功能</p>
<p>Spring理念：无侵入式增强功能</p>
<ul>
<li>所有原始方法-&gt;连接点(joint point) 在SpringAOP中如此<ul>
<li>save update delete select</li>
</ul>
</li>
<li>需要追加功能的方法-&gt;切入点(pointcut)<ul>
<li>save update delete </li>
</ul>
</li>
<li>具备的共性功能-&gt;通知 (advice)<ul>
<li>method1   method2</li>
</ul>
</li>
<li>通知和切入点产生关系-&gt;切面 (aspect) <ul>
<li>save update delete追加method</li>
</ul>
</li>
<li>功能的集合-&gt;通知类</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020152910091.png" alt="image-20241020152910091"></p>
<p>连接点包含切入点</p>
<h2 id="Spring中进行AOP编程"><a href="#Spring中进行AOP编程" class="headerlink" title="Spring中进行AOP编程"></a>Spring中进行AOP编程</h2><h3 id="导入坐标"><a href="#导入坐标" class="headerlink" title="导入坐标"></a>导入坐标</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020154236445.png" alt="image-20241020154236445"></p>
<h3 id="MyAdvice"><a href="#MyAdvice" class="headerlink" title="MyAdvice"></a><mark>MyAdvice<mark></h3><h4 id="定义通知"><a href="#定义通知" class="headerlink" title="定义通知"></a>定义通知</h4><h4 id="定义切入点-Pointcut"><a href="#定义切入点-Pointcut" class="headerlink" title="定义切入点 @Pointcut"></a>定义切入点 @Pointcut</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020154309848.png" alt="image-20241020154309848"></p>
<p><code>private</code> <code>void</code> <code>空参</code> </p>
<h4 id="绑定通知与切入点"><a href="#绑定通知与切入点" class="headerlink" title="绑定通知与切入点"></a>绑定通知与切入点</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020154407660.png" alt="image-20241020154407660"></p>
<h4 id="Spring接管此类-Component"><a href="#Spring接管此类-Component" class="headerlink" title="Spring接管此类 @Component"></a>Spring接管此类 @Component</h4><h4 id="定义AOP-Aspect"><a href="#定义AOP-Aspect" class="headerlink" title="定义AOP @Aspect"></a>定义AOP @Aspect</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020154529656.png" alt="image-20241020154529656"></p>
<h3 id="SpringConfig-EnableAspectAutoProxy"><a href="#SpringConfig-EnableAspectAutoProxy" class="headerlink" title="SpringConfig @EnableAspectAutoProxy"></a><mark>SpringConfig @EnableAspectAutoProxy<mark></h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020154505110-1729410361899-4.png" alt="image-20241020154505110"></p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020155857766.png" alt="image-20241020155857766"></p>
<p>**基于<mark>动态代理<mark>**：</p>
<ul>
<li><p>匹配失败，new原始对象；</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020160228368.png" alt="image-20241020160228368"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020160243146.png" alt="image-20241020160243146"></p>
</li>
<li><p>匹配成功，new出来的是原始对象的代理对象；</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020160302140.png" alt="image-20241020160302140"></p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020160341452.png" alt="image-20241020160341452"></p>
</li>
</ul>
<p><strong>用获取到的bean执行方法</strong>：如果是代理的bean，根据通知和切入点进行方法执行。</p>
<h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3><p>切入点：要对其进行增强的方法</p>
<p>切入点表达式：对切入点的描述方式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020161523488.png" alt="image-20241020161523488"></p>
<p>execution(<code>public</code> <code>User</code> <code>com.itheima.service.UserService.findById</code>(<code>int</code>))</p>
<p>public exception 可省略</p>
<p>参数必须有</p>
<h4 id="通配符使用"><a href="#通配符使用" class="headerlink" title="通配符使用"></a>通配符使用</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020161833474.png" alt="image-20241020161833474"></p>
<ul>
<li>..和*的区别 *用于精准匹配到某个位置</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020163432072.png" alt="image-20241020163432072"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.impl.BookDaoImpl.update())&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.impl.BookDaoImpl.update(*))&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.*.*.*.update())&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* *..*(..))&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* *..*e(..))&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(void com..*())&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.itheima.*.*Service.find*(..))&quot;)</span></span><br><span class="line"><span class="comment">//执行com.itheima包下的任意包下的名称以Service结尾的类或接口中的save方法，参数任意，返回值任意</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h3><h4 id="前置-Before"><a href="#前置-Before" class="headerlink" title="前置@Before"></a>前置@Before</h4><h4 id="后置-After"><a href="#后置-After" class="headerlink" title="后置@After"></a>后置@After</h4><h4 id="环绕-Around"><a href="#环绕-Around" class="headerlink" title="环绕@Around"></a><strong><u><mark>环绕@Around<mark></u></strong></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020170038080.png" alt="image-20241020170038080"></p>
<ul>
<li><p>ProceedingJoinPoint</p>
</li>
<li><p>原始方法在环绕方法中执行，用<code>pjp.proceed()</code>执行原始方法，<mark>不出现就能隔离原始方法，（权限校验）<mark></p>
</li>
<li><p>pjp能接原始方法的返回值，类型为Object，强转后可以在给他返回去，思想和动态代理里的案例比较像：利用反射invoke调用可以拿到返回值，<strong>注意修改通知方法的返回值为Object。</strong>没返回值也可以</p>
</li>
<li><p>强制抛Throwable </p>
</li>
</ul>
<h4 id="得到返回值之后-AfterReturning"><a href="#得到返回值之后-AfterReturning" class="headerlink" title="得到返回值之后@AfterReturning"></a>得到返回值之后@AfterReturning</h4><p>和after区别：after只要方法结束即可，不管是得到返回值正常结束还是抛异常。AfterReturning需要得到返回值正常结束才能</p>
<h4 id="抛出异常之后-AfterThrowing"><a href="#抛出异常之后-AfterThrowing" class="headerlink" title="抛出异常之后@AfterThrowing"></a>抛出异常之后@AfterThrowing</h4><h3 id="案例：JUnit-测量业务层接口执行效率"><a href="#案例：JUnit-测量业务层接口执行效率" class="headerlink" title="案例：JUnit 测量业务层接口执行效率"></a>案例：JUnit 测量业务层接口执行效率</h3><p>JUnit 测试服务类就private服务出来，<code>@Autowired</code> </p>
<p>下面写test具体方法。详见JUnit单元测试篇(Java SE)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020171154617.png" alt="image-20241020171154617"></p>
<p>获取方法签名 (执行信息) <code>getSignature()</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020171252962.png" alt="image-20241020171252962"></p>
<h3 id="通知获取数据"><a href="#通知获取数据" class="headerlink" title="通知获取数据"></a>通知获取数据</h3><h4 id="JoinPoint-amp-ProceedingJoinPoint"><a href="#JoinPoint-amp-ProceedingJoinPoint" class="headerlink" title="JoinPoint &amp; ProceedingJoinPoint"></a>JoinPoint &amp; ProceedingJoinPoint</h4><p><strong>作为通知的参数</strong>，如果出现，必须在第一个参数的位置上,PJP是JP的子类</p>
<p><code>Object[] getArgs()</code>: 获取原始方法的参数</p>
<p><code> Object proceed()</code> :环绕 PJP专用，调用原始方法同时返回这个方法的返回值</p>
<h4 id="AOP获取原始方法调用参数"><a href="#AOP获取原始方法调用参数" class="headerlink" title="AOP获取原始方法调用参数"></a><mark>AOP获取原始方法调用参数<mark></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020173959692.png" alt="image-20241020173959692"></p>
<p>这样可以对原始参数进行处理，可以增加程序健壮性。</p>
<p><code>Object proceed(Object[] args)</code> 可以把处理以后的参数传给原始方法。</p>
<h5 id="案例：网盘提取码去空格"><a href="#案例：网盘提取码去空格" class="headerlink" title="案例：网盘提取码去空格"></a>案例：网盘提取码去空格</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020180157823.png" alt="image-20241020180157823"></p>
<p>args本身是Object数组，拿进来需要转成字符串toString getArgs 然后遍历参数数组，对每个字符串参数trim，再把处理以后的传给proceed</p>
<h4 id="AOP获取返回值"><a href="#AOP获取返回值" class="headerlink" title="AOP获取返回值"></a>AOP获取返回值</h4><ol>
<li>环绕 pjp proceed </li>
<li>AfterReturning 注解的returning要和形参名字相同</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020175037570.png" alt="image-20241020175037570"></p>
<h4 id="AOP接收异常"><a href="#AOP接收异常" class="headerlink" title="AOP接收异常"></a>AOP接收异常</h4><ol>
<li><p>环绕 不要往出抛Throwable 内部try-catch</p>
</li>
<li><p>AfterThrowing 注解的throwing和形参名字相同</p>
</li>
</ol>
<p>![image-20241020174307577](<a href="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/屏幕截图</a> 2024-10-20 174257.jpg)</p>
<h3 id="环绕通知模拟其他四种通知"><a href="#环绕通知模拟其他四种通知" class="headerlink" title="环绕通知模拟其他四种通知"></a>环绕通知模拟其他四种通知</h3><table>
<thead>
<tr>
<th>前置</th>
<th>最后调用proceed</th>
</tr>
</thead>
<tbody><tr>
<td>后置</td>
<td>try catch finally 在finally里写</td>
</tr>
<tr>
<td>AfterReturning</td>
<td>Object接住proceed的返回值</td>
</tr>
<tr>
<td>AfterThrowing</td>
<td>不要往出抛Throwable，try catch Throwable</td>
</tr>
</tbody></table>
<h2 id="AOP编程思想—this调用实例方法失效"><a href="#AOP编程思想—this调用实例方法失效" class="headerlink" title="AOP编程思想—this调用实例方法失效"></a>AOP编程思想—this调用实例方法失效</h2><p>AOP的核心，是从调用对象的方法时生成代理对象—PROXY，this指向真正的目标对象—TARGET</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IService</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">zoo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IService</span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">		System.println(<span class="string">&quot;fooStart...&quot;</span>);</span><br><span class="line">		zoo();<span class="comment">//this指针调用实例方法</span></span><br><span class="line">		System.println(<span class="string">&quot;fooFinish...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Transactional</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">zoo</span><span class="params">()</span>&#123;</span><br><span class="line">		save(a);<span class="comment">//假设是将a保存到数据库</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">		save(b);<span class="comment">//假设是将b保存到数据库</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IService service;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        service.foo();<span class="comment">//从外部调用内部的事务方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事务的实现基于spring aop，如果直接用this，则会使用target对象进行方法调用，</p>
<p><a href="https://docs.spring.io/spring-framework/reference/core/aop/proxying.html#aop-understanding-aop-proxies">Proxying Mechanisms :: Spring Framework</a> </p>
<p><a href="https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/tx-decl-explained.html#page-title">Understanding the Spring Framework’s Declarative Transaction Implementation :: Spring Framework</a> </p>
<p>如果是在类内部开启的事务，就需要CGLIB动态代理，实现的基础是方法拦截器，环绕通知，</p>
<h3 id="直接调用方法"><a href="#直接调用方法" class="headerlink" title="直接调用方法"></a>直接调用方法</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241104161707487.png" alt="image-20241104161707487"></p>
<h3 id="通过代理调用方法"><a href="#通过代理调用方法" class="headerlink" title="通过代理调用方法"></a>通过代理调用方法</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241104161648309.png" alt="image-20241104161648309"></p>
<p>也就是说，如果要让代理生效，首先就是要获取代理对象，而通过@Transactional注解的方法<code>zoo()</code>，如果从外部调用，只要获得了代理对象的引用，事务功能就是生效的，因此直接在main中只要获取了代理对象的引用调用service.zoo()方法是没有问题的。</p>
<p>而在目标对象内部，this就是目标对象本身，肯定不会走代理，因此如果实在</p>
<h3 id="解决方案—在类的内部获取代理对象"><a href="#解决方案—在类的内部获取代理对象" class="headerlink" title="解决方案—在类的内部获取代理对象"></a>解决方案—在类的内部获取代理对象</h3><h4 id="AopContext-currentProxy"><a href="#AopContext-currentProxy" class="headerlink" title="AopContext.currentProxy()"></a>AopContext.currentProxy()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (UserHolder.getUser()) &#123;</span><br><span class="line">    <span class="comment">//开启事务需要获取当前的代理对象</span></span><br><span class="line">    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Autowired-注入服务对象本身"><a href="#Autowired-注入服务对象本身" class="headerlink" title="@Autowired 注入服务对象本身"></a>@Autowired 注入服务对象本身</h4><p>获取service对象即可，这样就能在类内部的上下文中获取proxy代理都象的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ServiceImpl service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (UserHolder.getUser()) &#123;</span><br><span class="line">    <span class="comment">//开启事务需要获取当前的代理对象</span></span><br><span class="line">    <span class="keyword">return</span> service.createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以新开一个Impl2类，把方法移植进去，注入Impl2对象，思路一样</span></span><br></pre></td></tr></table></figure>



<h2 id="AOP：动态代理对象的生成时机"><a href="#AOP：动态代理对象的生成时机" class="headerlink" title="AOP：动态代理对象的生成时机"></a>AOP：动态代理对象的生成时机</h2><p><a href="https://blog.csdn.net/xzb5566/article/details/141639614">【spring系列】spring的AOP是在哪个阶段创建的动态代理对象，spring bean的生命周期中在什么阶段创建的aop动态代理对象，很多人会说第一种，其实还有一种情况也会进行aop_spring的aop代理对象什么时候创建-CSDN博客</a></p>
<p><a href="https://cloud.tencent.com/developer/article/2154184">关于Spring的两三事：代理对象的生成时机-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><strong>1） Bean的实例化</strong>：首先，Spring容器会实例化Bean。</p>
<p><strong>2）Bean的属性填充</strong>：然后，为Bean填充依赖注入的属性。</p>
<p><strong>3）Bean的初始化：</strong></p>
<ul>
<li><strong>初始化前（postProcessBeforeInitialization）</strong>：在这一阶段，Spring会调用所有BeanPostProcessor的postProcessBeforeInitialization方法。但此时，代理对象可能还未被创建，因为还需要进一步判断该Bean是否需要被代理。</li>
<li><strong>初始化</strong>：接着，执行Bean的初始化方法（如@PostConstruct注解的方法或实现了InitializingBean接口的afterPropertiesSet方法）。</li>
<li><strong>初始化后（postProcessAfterInitialization）</strong>：在Bean初始化完成后，Spring会调用所有BeanPostProcessor的postProcessAfterInitialization方法。这通常是**创建动态代理对象的时机(AOP)**，因为此时Bean已经完全初始化并准备使用，而且代理对象可以在这一阶段被创建并替换掉原始的Bean实例。</li>
</ul>
<p><strong>4）代理对象的创建：</strong> </p>
<ul>
<li>在postProcessAfterInitialization方法中，Spring会检查该Bean是否需要被代理（通常基于是否存在对应的Advisor或Aspect）。</li>
<li>如果需要，Spring会根据Bean的类型（是否实现了接口）选择合适的代理方式（JDK动态代理或CGLIB代理）来创建代理对象。</li>
<li>代理对象会封装原始Bean，并在方法调用时插入增强的逻辑（如前置通知、后置通知等）。</li>
</ul>
<p><strong>5）Bean的交付</strong>：最后，将创建好的代理对象（如果需要的话）或原始Bean实例交付给客户端使用。</p>
<p>因此，<strong>Spring AOP的动态代理对象主要是在Bean的初始化后的postProcessAfterInitialization阶段创建的</strong>。这一过程确保了代理对象能够封装并增强原始Bean的方法调用，同时保持了Bean的生命周期和依赖注入的完整性。</p>
<h1 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h1><p>事务用于业务层或者Dao层</p>
<p><a href="https://blog.csdn.net/wang489687009/article/details/129259394">【Spring事务三千问】Spring的事务管理与MyBatis事务管理结合的原理_spring transaction和mybatis的整合 原理-CSDN博客</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/358657396">【spring源码深度解析】：spring是如何利用@Transactional注解实现数据库事务的？把握住事务的基本用法你就懂了 - 知乎 (zhihu.com)</a></p>
<h2 id="事务管理整合"><a href="#事务管理整合" class="headerlink" title="事务管理整合"></a>事务管理整合</h2><p><a href="https://www.cnblogs.com/jddreams/p/14024754.html">图解Java JDBC和JPA的区别 - 快乐随行 - 博客园 (cnblogs.com)</a></p>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ul>
<li>InnoDB存储引擎支持事务（SQL语句）</li>
</ul>
<h3 id="原生JDBC"><a href="#原生JDBC" class="headerlink" title="原生JDBC"></a>原生JDBC</h3><ul>
<li> 注册驱动，</li>
<li> 获取Connection，</li>
<li> 建立Statement执行SQL语句，Connection可以管理事务（本质是执行SQL语句）</li>
</ul>
<h3 id="DataSource数据源"><a href="#DataSource数据源" class="headerlink" title="DataSource数据源"></a>DataSource数据源</h3><ul>
<li>主要用来获取并管理，调度Connection</li>
</ul>
<h3 id="原生-MyBatis-ORM"><a href="#原生-MyBatis-ORM" class="headerlink" title="原生 MyBatis (ORM)"></a>原生 MyBatis (ORM)</h3><ul>
<li><p>可以调用外部数据源获取Connection，也可以使用原生JDBC来获取，最终这些Connection可以呗SqlSession获取到。</p>
</li>
<li><p>SqlSession同样能管理事务，底层是基于Transaction(也是mybatis的一个类)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">affected_rows</span> <span class="operator">=</span> session.insert(<span class="string">&quot;com.kvn.mapper.UserMapper.insert&quot;</span>, user);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 捕获到异常，将操作回滚</span></span><br><span class="line">    session.rollback();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正常执行，提交事务</span></span><br><span class="line">session.commit();</span><br><span class="line">session.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Spring联合MyBatis事务管理"><a href="#Spring联合MyBatis事务管理" class="headerlink" title="Spring联合MyBatis事务管理"></a>Spring联合MyBatis事务管理</h3><p><code>SpringManagedTransaction</code> 打通了 MyBatis 的事务管理、连接管理 和 spring-tx 的 事务管理、连接管理，使得 MyBatis 与 Spring 可以使用统一的方式来管理连接的生命周期 和 事务处理。</p>
<ol start="0">
<li><p>原生的MyBatis 使用的是JdbcTransaction实现类</p>
</li>
<li><p>在一个非 <code>@Transactional</code> 标记的方法中执行 sql 命令，则事务的管理会通过 <code>SpringManagedTransaction</code> 来执行。</p>
</li>
<li><p>在一个 <code>@Transactional</code> 标记的事务方法中执行 sql 命令，则 <code>SpringManagedTransaction</code> 的 <code>commit()/rollback()</code> 方法不会执行任何动作，而事务的管理会走 Spring AOP 事务管理，即通过 <code>org.springframework.transaction.interceptor.TransactionInterceptor</code> 来进行拦截处理。</p>
</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020215834772.png" alt="image-20241020215834772"></p>
<ol start="3">
<li>SqlSessionInterceptor 保证了 MyBatis 的 SqlSession 在执行 sql 时使用的连接与 Spring 事务管理操作使用的连接是<u>同一个</u>连接。具体就是通过 Spring 的事务同步器 <code>TransactionSynchronizationManager</code> 来保证的。</li>
<li>SpringManagedTransaction 中连接的获取是从 Spring 管理的 DataSource 中获取的，这样，数据库连接池也就和 spring 整合在一起了。</li>
</ol>
<h2 id="多线程事务"><a href="#多线程事务" class="headerlink" title="多线程事务"></a>多线程事务</h2><h3 id="javax-sql-Connection"><a href="#javax-sql-Connection" class="headerlink" title="javax.sql.Connection"></a>javax.sql.Connection</h3><p>简单地来说，建立<code>Connection</code>连接，会消耗数据库系统的如下资源：</p>
<table>
<thead>
<tr>
<th align="center">资源</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">线程数</td>
<td align="center">线程越多，线程的上下文切换会越频繁，会影响其处理能力</td>
</tr>
<tr>
<td align="center">创建Connection的开销</td>
<td align="center">由于Connection负责和数据库之间的通信，在创建环节会做大量的初始化 ，创建过程所需时间和内存资源上都有一定的开销</td>
</tr>
<tr>
<td align="center">内存资源</td>
<td align="center">为了维护Connection对象会消耗一定的内存</td>
</tr>
<tr>
<td align="center">锁占用</td>
<td align="center">在高并发模式下，不同的Connection可能会操作相同的表数据，就会存在锁的情况，数据库为了维护这种锁会有不少的内存开销</td>
</tr>
</tbody></table>
<p>事务的执行依赖于JDBC-connection，connection的建立基于tcp连接，需要耗费很多资源，所以在多线程并发的情况下，connection数目远少于thread数，需要尽可能考虑connection的共用和复用。</p>
<p>connection可以显式开启和关闭事务，遵循事务的ACID原则，因此虽然共用connection，但是同一时间同一connection只能有同一个事务正在执行，也就是串行执行，否则会造成事务紊乱。</p>
<p>一个最佳实践：<strong>当线程需要做数据库操作时，才会真正请求获取JDBC数据库连接,线程使用完了之后，立即释放，被释放的JDBC数据库连接等待下次分配使用</strong></p>
<p>最简单的方式就是把事务执行的代码块用connection锁对象锁住：事务执行完以后释放（但不销毁）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(connection)&#123;</span><br><span class="line">    <span class="comment">//tx......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程如何获取锁对象？为了保证一个线程所有dao操作都是用的同一个connection，使用threadLocal存放属于线程自己的connection，如果是直接从连接池获得的话，多个 DAO 就用到了多个Connection，不能完成一个事务。而连接池负责提供缓存和提供connection</p>
<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p><a href="https://blog.csdn.net/luanlouis/article/details/37671851">《深入理解mybatis原理》 Mybatis数据源与连接池_mybatis 连接池-CSDN博客</a></p>
<p>原生的JDBC会让connection的close()方法执行数据库连接的释放与销毁，为了保证不更改原生的功能，我们可以使用代理对象，让其close方法不会真正执行，而是回收到数据库连接池中。</p>
<p>使用数据库连接池，通常都是得到一个javax.sql.DataSource[接口]的实例对象，它里面包含了Connection，并且数据库连接池工具类（比如C3P0、JNDI、DBCP等）重新定义了getConnection、closeConnection等方法，所以每次得到的Connection，几乎都不是新建立的连接（而是已经建立好并放到缓存里面的连接），调用closeConnection方法，也不是真正的关闭连接（一般都是起到一个标识作用，标识当前连接已经使用完毕，归还给连接池，让这个连接处于待分配状态）【PS：所以说：使用数据库连接池时，还是要显式的调用数据库连接池API提供的关闭连接的方法】。</p>
<p>至于为什么要用ThreadLocal呢?这个和连接池无关,我认为更多的是和程序本身相关,为了更清楚的说明,我举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">servlet中获取一个连接.首先,servlet是线程安全的吗?</span><br><span class="line"></span><br><span class="line">     class MyServlet extends HttpServlet&#123;</span><br><span class="line">         private Connection conn;</span><br><span class="line">     &#125;</span><br><span class="line">     ok,遗憾的告诉你,这个conn并不是安全的,所有请求这个servlet的连接,使用的都是一个Connection,这个就是致命的了.多个人使用同一个连接,算上延迟啥的,天知道数据会成什么样.</span><br><span class="line">     因此我们要保证Connection对每个请求都是唯一的.这个时候就可以用到ThreadLocal了,保证每个线程都有自己的连接.</span><br><span class="line">     改为 private ThreadLocal&lt;Connection&gt; ct = new ThreadLocal&lt;Connnection&gt;();</span><br><span class="line">     然后从连接池获取Connection,set到ct中,再get就行了,至于得到的是哪个Connection就是连接池的问题了,你也管不到.</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal?"></a>ThreadLocal?</h3><p>就是为每一个使用该变量的线程都提供一个变量值的副本，是每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲</p>
<h2 id="开启步骤"><a href="#开启步骤" class="headerlink" title="开启步骤"></a>开启步骤</h2><h3 id="业务层-接口-为业务方法打开事务-Transactional"><a href="#业务层-接口-为业务方法打开事务-Transactional" class="headerlink" title="业务层**接口**为业务方法打开事务@Transactional"></a>业务层**<mark>接口<mark>**为业务方法打开事务@Transactional</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020204651727.png" alt="image-20241020204651727"></p>
<ul>
<li><p>@Transactional是方法级别或者类级别的注解，可以<strong>开在整个接口上</strong>，也可以开在单个方法上</p>
</li>
<li><p>接口能够提高复用性，降低耦合</p>
</li>
</ul>
<h3 id="JdbcConfig创建事务管理器Bean-Bean"><a href="#JdbcConfig创建事务管理器Bean-Bean" class="headerlink" title="JdbcConfig创建事务管理器Bean@Bean"></a>JdbcConfig创建事务管理器Bean@Bean</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020204933459.png" alt="image-20241020204933459"></p>
<p>PlatformTransactionManager是Spring规定的，DataSourceTransactionManager可以动，根据具体的技术选择</p>
<p>要注意，事务管理器的datasource和mybatis用的datasource必须是同一个，不然</p>
<h3 id="SpringConfig打开事务-EnableTransactionManagement"><a href="#SpringConfig打开事务-EnableTransactionManagement" class="headerlink" title="SpringConfig打开事务@EnableTransactionManagement"></a>SpringConfig打开事务@EnableTransactionManagement</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020205233232.png" alt="image-20241020205233232"></p>
<h2 id="事务角色"><a href="#事务角色" class="headerlink" title="事务角色"></a>事务角色</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020205625500.png" alt="image-20241020205625500"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020205648701.png" alt="image-20241020205648701"></p>
<h2 id="事务配置"><a href="#事务配置" class="headerlink" title="事务配置"></a>事务配置</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020222103484.png" alt="image-20241020222103484"></p>
<p>有些异常不会触发回滚，需要手动设置一下rollbackFor</p>
<h3 id="追加日志"><a href="#追加日志" class="headerlink" title="追加日志"></a>追加日志</h3><p>try finally结构，finally 记日志功能必定触发</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020222628555.png" alt="image-20241020222628555"></p>
<h3 id="事务传播行为控制"><a href="#事务传播行为控制" class="headerlink" title="事务传播行为控制"></a>事务传播行为控制</h3><p><a href="https://segmentfault.com/a/1190000013341344#item-2-2">(1) java - Spring事务传播行为详解 - 个人文章 - SegmentFault 思否</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020222917510.png" alt="image-20241020222917510"></p>
<p>transfer、AccountDao中所有的数据层方法、日志记录的业务方法都加了Transacitonal注解。</p>
<ul>
<li>transfer作为方法的调用者，是事务的管理员。</li>
<li>其他作为被调用者，是事务的协调员。</li>
<li>如果默认设置Required，管理员开事务，协调员都会加入</li>
</ul>
<p><code>@Transactional(propagation = Propagation.REQUIRES_NEW)</code></p>
<p>开启事务：<code>@Transactional</code></p>
<p>管理员肯定要开启事务，管理员默认是<code>REQUIRED</code>一般不用改，某一个协调员要单开另外一个事务，那么就可以把这个协调员的事务传播机制改成<code>REQUIRES_NEW</code> </p>
<h4 id="Propagation-REQUIRED"><a href="#Propagation-REQUIRED" class="headerlink" title="Propagation.REQUIRED"></a>Propagation.REQUIRED</h4><p><strong>外围方法未开启事务的情况下<code>Propagation.REQUIRED</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</strong> </p>
<p><strong>在外围方法开启事务的情况下<code>Propagation.REQUIRED</code>修饰的内部方法会加入到外围方法的事务中，所有<code>Propagation.REQUIRED</code>修饰的内部方法和外围方法均属于同一事务，只要一个方法回滚，整个事务均回滚。</strong></p>
<h4 id="Propagation-REQUIRES-NEW"><a href="#Propagation-REQUIRES-NEW" class="headerlink" title="Propagation.REQUIRES_NEW"></a>Propagation.REQUIRES_NEW</h4><p><strong>外围方法未开启事务的情况下<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</strong> </p>
<p><strong>在外围方法开启事务的情况下<code>Propagation.REQUIRES_NEW</code>修饰的内部方法依然会单独开启独立事务，且与外部方法事务也独立，内部方法之间、内部方法和外部方法事务均相互独立，互不干扰。</strong></p>
<h2 id="事务失效"><a href="#事务失效" class="headerlink" title="事务失效"></a>事务失效</h2><p><a href="https://blog.csdn.net/hanjiaqian/article/details/120501741">spring 事务失效的 12 种场景_spring 截获duplicatekeyexception 不抛异常-CSDN博客</a></p>
<ul>
<li>访问权限，private,default无法生效</li>
<li>方法用final或static修饰，代理对象无法重写</li>
<li>多线程调用事务方法，两个线程获取的不是同一个连接</li>
<li>数据库或表不支持事务（MySQL的MyISAM不支持事务）</li>
<li>未开启事务或未将类纳入Spring管理<code>@Transactional</code> <code>@Service</code> </li>
</ul>
<h3 id="方法自调用"><a href="#方法自调用" class="headerlink" title="方法自调用"></a><span id="selfinvoke">方法自调用</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        updateStatus(userModel);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateStatus</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">        doSameThing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到在事务方法 add 中，直接调用事务方法 updateStatus。从前面介绍的内容可以知道，updateStatus 方法拥有事务的能力是因为 spring aop 生成代理对象proxy，但是这种方法直接调用了 this 对象的方法，所以 updateStatus 方法不会生成事务。</p>
<p>由此可见，在同一个类中的方法直接内部调用，会导致事务失效。</p>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><p>Java实现MVC模型的web框架，灵活性强，主要进行<strong>表现层开发</strong> Controller。</p>
<h3 id="导坐标"><a href="#导坐标" class="headerlink" title="导坐标"></a>导坐标</h3><h3 id="bean创建-Controller"><a href="#bean创建-Controller" class="headerlink" title="bean创建@Controller"></a>bean创建@Controller</h3><h4 id="方法级别注解-请求映射-RequestMapping"><a href="#方法级别注解-请求映射-RequestMapping" class="headerlink" title="方法级别注解 请求映射 @RequestMapping"></a>方法级别注解 请求映射 @RequestMapping</h4><h4 id="方法级别注解-设置响应-ResponseBody"><a href="#方法级别注解-设置响应-ResponseBody" class="headerlink" title="方法级别注解 设置响应 @ResponseBody"></a>方法级别注解 设置响应 @ResponseBody</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021161644841.png" alt="image-20241021161644841"></p>
<p>都是方法级别注解    </p>
<h3 id="创建SpringMvcConfig-Configuration-ComponentScan"><a href="#创建SpringMvcConfig-Configuration-ComponentScan" class="headerlink" title="创建SpringMvcConfig@Configuration@ComponentScan"></a>创建SpringMvcConfig@Configuration@ComponentScan</h3><p>扫描到controller</p>
<h3 id="创建servlet容器Config"><a href="#创建servlet容器Config" class="headerlink" title="创建servlet容器Config"></a>创建servlet容器Config</h3><p>ServletContainerInitConfig继承AbstractDispatcherServeltInitializer类重写对应方法。都是一次性</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021161341011.png" alt="image-20241021161341011"></p>
<ul>
<li><code>getServletMappings</code> 表示接管URL的那个部分的映射</li>
<li><code>createRootApplicationContext</code> 创建Spring Framework容器并指定配置    </li>
<li><code>createServletApplicationContext</code> 创建web容器并指定配置</li>
<li>web容器 <strong>servlet容器</strong></li>
</ul>
<h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021162133487.png" alt="image-20241021162133487"></p>
<h3 id="bean加载-ComponentScan-Filter"><a href="#bean加载-ComponentScan-Filter" class="headerlink" title="bean加载@ComponentScan.Filter"></a>bean加载@ComponentScan.Filter</h3><p><u>Spring避免加载springmvc的controller</u></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021162700082.png" alt="image-20241021162700082"></p>
<p>导包：mybatis自动代理会返回dao接口的实现对象，可以不写，但是其他技术不一定是这样，所以为了通用性还是应该导dao</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021164147565.png" alt="image-20241021164147565"></p>
<p>SpringConfig扫描排除含有Controller注解的类：<strong>Filter</strong> 可以更细粒度地加载bean</p>
<p>exclude排除</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021164311077.png" alt="image-20241021164311077"></p>
<p>加了configuration的类，spring都会将其作为配置类，里面如果有componentScan，就会扫上。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021164930504.png" alt="image-20241021164930504"></p>
<p>创建容器设定配置再去返回容器，简化过程只需要指定类的字节码即可</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021165128160.png" alt="image-20241021165128160"></p>
<h2 id="配置Controller"><a href="#配置Controller" class="headerlink" title="配置Controller"></a>配置Controller</h2><h3 id="请求Request相关"><a href="#请求Request相关" class="headerlink" title="请求Request相关"></a>请求Request相关</h3><h4 id="请求映射路径-RequestMapping"><a href="#请求映射路径-RequestMapping" class="headerlink" title="请求映射路径@RequestMapping"></a>请求映射路径@RequestMapping</h4><p>对于不同的controller可能会优相同方法，这时会有冲突问题，解决办法是在controller**<mark>类<mark><strong>上加一个@RequestMapping，要和</strong><mark>方法<mark>**的@RequestMapping注解结合一下。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021172423291.png" alt="image-20241021172423291"></p>
<h4 id="名称匹配-指定请求参数名-RequestParam"><a href="#名称匹配-指定请求参数名-RequestParam" class="headerlink" title="名称匹配 指定请求参数名@RequestParam"></a>名称匹配 指定<mark>请求参数<mark>名@RequestParam</h4><p>用于接收GET请求中URL的查询参数，也可以接收POST请求的参数（表单）</p>
<blockquote>
<p>You can use the <code>@RequestParam</code> annotation to bind Servlet request parameters (that is, query parameters or form data) to a method argument in a controller.</p>
</blockquote>
<p>与mybatis类似，对于外部传进来的请求参数用map封装，因此**@RequestParam接收的是key-value形式的参数<strong>，</strong>发送get请求**只会处理URL中的参数，忽略请求体中的数据</p>
<p><strong>发送post请求</strong>时，<mark>表单数据在请求体中<mark>，不过仍然是username=root这样键值对的形式存在，如果URL里有请求参数，服务端收到以后会一并加到map中，打印出来，即使方法里的参数只是一个String也能打印出来</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021220731172.png" alt="image-20241021220731172"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021220755961.png" alt="image-20241021220755961" style="zoom:150%;" /></p>
<p>@RequestParam XXX xxx 表示查询参数用XXX类型接</p>
<p><a href="https://blog.csdn.net/weixin_43606226/article/details/106545024">SpringMvc--@RequestBody和@RequestParam注解以及不加注解接收参数的区别_不写接收参数的注解,默认使用什么的-CSDN博客</a></p>
<p><a href="https://blog.51cto.com/u_12393361/5021343">解决mybatis不加@Param报错 org.apache.ibatis.binding.BindingException_51CTO博客_mybatis @Param</a></p>
<p><a href="https://www.cnblogs.com/zeng1994/p/9110632.html">记一次SpringMVC碰到的坑 - zeng1994 - 博客园 (cnblogs.com)</a></p>
<p><a href="https://blog.csdn.net/as513385/article/details/93512699">关于SpringMvc使用时,不加@RequestParam注解,根据方法形参名也可以获取请求值的分析_spring 请求体不写注解-CSDN博客</a></p>
<p>和 <strong>MyBatis</strong> 一样，使用反射机制获取参数名称，JDK8以后 java.lang.reflect.Parameter 中能够获取参数相关信息，框架就是利用这个机制，不加RequestParam获取参数信息。不然就只有arg0 arg1这种形式。</p>
<ul>
<li>required参数 是否为必传参数，默认必传</li>
<li>defaultValue 参数默认值</li>
</ul>
<h4 id="传递多种类型的请求参数"><a href="#传递多种类型的请求参数" class="headerlink" title="传递多种类型的请求参数"></a>传递多种类型的<mark>请求参数<mark></h4><p>与mybatis类似</p>
<ul>
<li><p>pojo：直接使用pojo内部的字段名称</p>
</li>
<li><p>嵌套pojo：address.字段名称</p>
</li>
<li><p>数组：直接接收字符串数组即可，请求的参数名就是数组的形参名，会把数组当成一个独立的参数</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021192646729.png" alt="image-20241021192646729"></p>
</li>
<li><p>集合类型：加RequestParam注解。 因为集合属于<strong>引用类型</strong>，spring会把它当成pojo处理（造pojo然后根据字段名注入依赖），不加param注解，spring就不会像数组一样把他当成一个独立的参数。</p>
</li>
</ul>
<h5 id="传JSON-EnableWebMvc"><a href="#传JSON-EnableWebMvc" class="headerlink" title="传JSON @EnableWebMvc"></a>传JSON @<mark>EnableWebMvc<mark></h5><p>导坐标 webMvc</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021193842326.png" alt="image-20241021193842326"></p>
<h6 id="参数在请求体里-RequestBody"><a href="#参数在请求体里-RequestBody" class="headerlink" title="参数在请求体里@RequestBody"></a>参数在请求体里@RequestBody</h6><p>@RequestBody XXX xxx 表示请求体中的数据用XXX类型接</p>
<p>RequestBody请求体中的数据通常是以JSON、XML等格式发送的，可以将请求体中的数据自动绑定到指定的Java对象上。</p>
<ol>
<li>参数写在请求体里，用List接收json数组</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021194047781.png" alt="image-20241021194047781"></p>
<ol start="2">
<li>用Pojo类接单个pojo对象json</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021194303198.png" alt="image-20241021194303198"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021194445000.png" alt="image-20241021194445000"></p>
<ol start="3">
<li>用List<pojo>接收多个pojo对象的json，</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021194340592.png" alt="image-20241021194340592"></p>
<p>一个请求，只有一个RequestBody；一个请求，可以有多个RequestParam。</p>
<p><strong>Body vs Param:</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021222507281.png" alt="image-20241021222507281"></p>
<h5 id="日期参数格式化-DateTimeFormat-pattern-”yyyy-MM-dd”"><a href="#日期参数格式化-DateTimeFormat-pattern-”yyyy-MM-dd”" class="headerlink" title="日期参数格式化@DateTimeFormat(pattern=”yyyy-MM-dd”)"></a>日期参数格式化@DateTimeFormat(pattern=”yyyy-MM-dd”)</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021223057976.png" alt="image-20241021223057976"></p>
<p>默认yyyy/MM/dd 其他形式不认识，需要自己手动指明formatPattern</p>
<h5 id="Converter接口-将字符串参数转换成Java类型"><a href="#Converter接口-将字符串参数转换成Java类型" class="headerlink" title="Converter接口-将字符串参数转换成Java类型"></a>Converter接口-将字符串参数转换成Java类型</h5><p>请求里面的参数都是以字符串形式发来的，converter要根据形参类型，把字符串转成对应类型提供给方法，这就是为什么前面能把字符串12按照需求转换成int 12</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021223621200.png" alt="image-20241021223621200"></p>
<p>@EnableWebMvc</p>
<h3 id="响应Response相关"><a href="#响应Response相关" class="headerlink" title="响应Response相关"></a>响应Response相关</h3><h4 id="响应页面（跳转页面）"><a href="#响应页面（跳转页面）" class="headerlink" title="响应页面（跳转页面）"></a>响应页面（跳转页面）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toPage&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toJumpPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接在方法里 return “page.jsp” </p>
<p>Spring默认认为Controller的方法返回的就是一个页面</p>
<h4 id="响应文本数据-ResponseBody"><a href="#响应文本数据-ResponseBody" class="headerlink" title="响应文本数据@ResponseBody"></a>响应文本数据@ResponseBody</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021225227708.png" alt="image-20241021225227708"></p>
<p>如果直接return一个字符串Spring会认为这个字符串是一个网页，响应分为响应行响应头和响应体，响应头里是放状态码之类的，只能在响应体里返回数据，加@ResponseBody注解表示返回值就是响应体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toText&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toText</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//表示返回 page.jsp 这个字符串</span></span><br></pre></td></tr></table></figure>

<h4 id="响应POJO对象-JSON形式"><a href="#响应POJO对象-JSON形式" class="headerlink" title="响应POJO对象(JSON形式)"></a>响应POJO对象(JSON形式)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toJsonPOJO&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">toJsonPOJO</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;返回json对象数据&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">15</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接返回user即可，jackson帮我们做的</p>
<h5 id="响应POJO对象集合（JSON数组）"><a href="#响应POJO对象集合（JSON数组）" class="headerlink" title="响应POJO对象集合（JSON数组）"></a>响应POJO对象集合（JSON数组）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toJsonList&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">toJsonList</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;返回json集合数据&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user1.setName(<span class="string">&quot;传智播客&quot;</span>);</span><br><span class="line">    user1.setAge(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user2.setName(<span class="string">&quot;黑马程序员&quot;</span>);</span><br><span class="line">    user2.setAge(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">    userList.add(user1);</span><br><span class="line">    userList.add(user2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="HttpMessageConverter接口"><a href="#HttpMessageConverter接口" class="headerlink" title="HttpMessageConverter接口"></a>HttpMessageConverter接口</h5><p>POJO转JSON字符串</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021225843796.png" alt="image-20241021225843796"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021225823024.png" alt="image-20241021225823024"></p>
<h3 id="REST-风格"><a href="#REST-风格" class="headerlink" title="REST 风格"></a>REST 风格</h3><p><strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021230252993.png" alt="image-20241021230252993"></p>
<p>根据请求的方式区分 GET POST PUT DELETE</p>
<p>同一URL，请求方式不同，调用的方法也不同</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021230150675.png" alt="image-20241021230150675"></p>
<p>RESTful：用REST风格访问资源</p>
<h4 id="RequestMapping-加-method-参数"><a href="#RequestMapping-加-method-参数" class="headerlink" title="@RequestMapping 加 method 参数"></a>@RequestMapping 加 method 参数</h4><p><code>@RequestMapping(value = &quot;/users/&#123;id&#125;&quot; ,method = RequestMethod.DELETE)</code> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021231918974.png" alt="image-20241021231918974"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021231836548.png" alt="image-20241021231836548"></p>
<h5 id="URL占位符传参-PathVariable"><a href="#URL占位符传参-PathVariable" class="headerlink" title="URL占位符传参 @PathVariable"></a>URL占位符传参 <mark>@PathVariable<mark></h5><p>value=”/users/{id}”  URL中的{id}和用@PathVariable修饰的方法参数id是一致的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021231846312.png" alt="image-20241021231846312"></p>
<h5 id="RequestBody-RequestParam-PathVariable"><a href="#RequestBody-RequestParam-PathVariable" class="headerlink" title="@RequestBody@RequestParam@PathVariable"></a>@RequestBody@RequestParam@PathVariable</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021232010983.png" alt="image-20241021232010983"></p>
<h4 id="RESTful-快速开发"><a href="#RESTful-快速开发" class="headerlink" title="RESTful 快速开发"></a><mark>RESTful 快速开发<mark></h4><h5 id="类级别注解-RequestMapping"><a href="#类级别注解-RequestMapping" class="headerlink" title="类级别注解 @RequestMapping"></a>类级别注解 @RequestMapping</h5><p>省去所有user前缀，写一次就好。</p>
<h5 id="类级别注解-RestController"><a href="#类级别注解-RestController" class="headerlink" title="类级别注解 @RestController"></a>类级别注解 @RestController</h5><p>类级别的@RequestBody，表示所有类的返回值都是请求体的数据，既然@Controller和RequestBody都要写，合而为一即可</p>
<h5 id="方法级别注解-PostMapping"><a href="#方法级别注解-PostMapping" class="headerlink" title="方法级别注解 @PostMapping"></a>方法级别注解 @PostMapping</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot; ,method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/&#123;id&#125;&quot;)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021232955549.png" alt="image-20241021232955549"></p>
<h4 id="RESTful-页面交互案例"><a href="#RESTful-页面交互案例" class="headerlink" title="RESTful 页面交互案例"></a>RESTful 页面交互案例</h4><p>RestController PostMapping GetMapping DeleteMapping PutMapping </p>
<p>方法参数RequestBody</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021235556399.png" alt="image-20241021235556399"></p>
<h5 id="Config-类-SpringMvcSupport-放行静态页面访问"><a href="#Config-类-SpringMvcSupport-放行静态页面访问" class="headerlink" title="Config 类 SpringMvcSupport 放行静态页面访问"></a>Config 类 SpringMvcSupport 放行静态页面访问</h5><p>@Configuration</p>
<p>默认SpringMvcConfig接管/后所有东西，通过ResourceHandlerRegistry 设置SpringMVC如何处理对静态资源的访问 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021235616215.png" alt="image-20241021235616215"></p>
<h5 id="前端ajax"><a href="#前端ajax" class="headerlink" title="前端ajax"></a>前端ajax</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021235623670.png" alt="image-20241021235623670"></p>
<h2 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h2><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><h3 id="整合Config包"><a href="#整合Config包" class="headerlink" title="整合Config包"></a>整合Config包</h3><h4 id="SpringConfig"><a href="#SpringConfig" class="headerlink" title="SpringConfig"></a>SpringConfig</h4><p><code>Configuration</code> <code>ComponentScan</code> <code>Import</code></p>
<h5 id="MyBatisConfig-amp-JdbcConfig"><a href="#MyBatisConfig-amp-JdbcConfig" class="headerlink" title="MyBatisConfig &amp; JdbcConfig"></a>MyBatisConfig &amp; JdbcConfig</h5><p>JdbcConfig：数据源 DataSource Bean</p>
<p>MyBatisConfig：sqlSessionFactoryBean</p>
<p><code>Bean</code> <code>jdbc.properties</code> </p>
<h4 id="SpringMvcConfig"><a href="#SpringMvcConfig" class="headerlink" title="SpringMvcConfig"></a>SpringMvcConfig</h4><p><code>Configuration</code> <code>ComponentScan</code> <code>EnableWebMvc</code></p>
<h5 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h5><p>rootApplicationContext和webApplicationContext</p>
<h3 id="编写后端模块"><a href="#编写后端模块" class="headerlink" title="编写后端模块"></a>编写后端模块</h3><h4 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h4><p>实体类，User</p>
<h4 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h4><p>MyBatis Mapper自动代理，写接口，写方法结合注解</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022135643205.png" alt="image-20241022135643205"></p>
<p>占位符对应参数的名称，这里映射实体类中的字段信息     </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022135845990.png" alt="image-20241022135845990"></p>
<h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>BookDao@Autowired</p>
<p>dao接口加repository注解（可加可不加）</p>
<h4 id="RestController"><a href="#RestController" class="headerlink" title="RestController"></a>RestController</h4><p>参数在url中：PathVariable</p>
<p>参数在请求体：RequestBody</p>
<h4 id="JUnit-测试-Service"><a href="#JUnit-测试-Service" class="headerlink" title="JUnit 测试 Service"></a>JUnit 测试 Service</h4><h4 id="Postman-测试-Controller"><a href="#Postman-测试-Controller" class="headerlink" title="Postman 测试 Controller"></a>Postman 测试 Controller</h4><h4 id="Spring-事务激活"><a href="#Spring-事务激活" class="headerlink" title="Spring 事务激活"></a>Spring 事务激活</h4><p><code>JdbcConfig</code> 里 加PlatformTransactionManager Bean, 接dataSource参数</p>
<p><code>Service</code>接口添加@Transactional</p>
<h3 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h3><h4 id="表现层数据封装模型-设置统一的返回结果集Result"><a href="#表现层数据封装模型-设置统一的返回结果集Result" class="headerlink" title="表现层数据封装模型 - 设置统一的返回结果集Result"></a>表现层数据封装模型 - 设置统一的返回结果集Result</h4><p>实际开发过程中前后端<mark>约定<mark></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">//下方提供若干构造方法,有参无参</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code,Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code, Object data, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....getter setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022152253512-1729581786093-1.png" alt="image-20241022152253512"></p>
<h5 id="Result-data"><a href="#Result-data" class="headerlink" title="Result.data"></a>Result.data</h5><p>业务方法不同返回数据格式也不同，可能是true false这样的text，也可能是json数据，还可能是json数组，约定将数据封装到<mark>data<mark>字段中</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022144637267.png" alt="image-20241022144637267"></p>
<h5 id="Result-code"><a href="#Result-code" class="headerlink" title="Result.code"></a>Result.code</h5><p>不同业务方法可能会返回相同的内容，返回一个true可能对应新增，修改，删除的业务方法，加一个识别码<mark>code<mark>字段区分 ，可以约定尾数是0表示失败，尾数是1表示成功：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022145108783.png" alt="image-20241022145108783"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SAVE_OK</span> <span class="operator">=</span> <span class="number">20011</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DELETE_OK</span> <span class="operator">=</span> <span class="number">20021</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">UPDATE_OK</span> <span class="operator">=</span> <span class="number">20031</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">GET_OK</span> <span class="operator">=</span> <span class="number">20041</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SAVE_ERR</span> <span class="operator">=</span> <span class="number">20010</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DELETE_ERR</span> <span class="operator">=</span> <span class="number">20020</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">UPDATE_ERR</span> <span class="operator">=</span> <span class="number">20030</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">GET_ERR</span> <span class="operator">=</span> <span class="number">20040</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里Result的构造器识别的是Integer code</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Enum枚举：CodeEnum是一个类，类内部有一字段code(Integer)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022152238169.png" alt="image-20241022152238169"></p>
<h5 id="Result-message"><a href="#Result-message" class="headerlink" title="Result.message"></a>Result.message</h5><p>一些业务方法，本来应该返回json，没查到只能返回null，不能直接把null展示给用户看，展示的是message信息</p>
<h5 id="Controller-返回值统一设定为-Result"><a href="#Controller-返回值统一设定为-Result" class="headerlink" title="Controller 返回值统一设定为 Result"></a>Controller 返回值统一设定为 Result</h5><p>将返回值封装到Result中，data</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Book&gt; bookList = bookService.getAll();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> bookList != <span class="literal">null</span> ? Code.GET_OK : Code.GET_ERR;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> bookList != <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;数据查询失败，请重试！&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(code,bookList,msg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//data字段是否为null？</span></span><br></pre></td></tr></table></figure>

<h4 id="返回数据格式统一-异常处理器-RestControllerAdvice"><a href="#返回数据格式统一-异常处理器-RestControllerAdvice" class="headerlink" title="返回数据格式统一 - 异常处理器@RestControllerAdvice"></a>返回数据格式统一 - 异常处理器<mark>@RestControllerAdvice<mark></h4><ul>
<li><p><mark>类级别注解<mark></p>
</li>
<li><p>后端抛出的异常如果不处理，就会抛到前端页面，不美观，并且不会返回任何数据，导致<mark>数据不统一<mark> </p>
</li>
<li><p>要让WebMvcConfig扫到这个Advice类</p>
</li>
</ul>
<h5 id="常见异常诱因"><a href="#常见异常诱因" class="headerlink" title="常见异常诱因"></a>常见异常诱因</h5><ul>
<li><strong>框架内部抛出的异常</strong>:因使用不合规导致</li>
<li><strong>数据层抛出的异常</strong>:因外部服务器故障导致(例如:服务器访问超时)</li>
<li><strong>业务层抛出的异常</strong>:因业务逻辑书写错误导致(例如:遍历业务书写操作，导致索引异常等)</li>
<li><strong>表现层抛出的异常</strong>:因数据收集、校验等规则导致(例如:不匹配的数据类型间导致异常)</li>
<li><strong>工具类抛出的异常</strong>:因工具类书写不严谨不够健壮导致(例如:必要释放的连接长期未释放等)</li>
</ul>
<p><u>处理方法</u>：全部抛到表现层Controller —— AOP 编程，<strong>用最少量的代码实现最强大的功能</strong>，快速统一地处理异常 </p>
<h5 id="方法级别注解-处理具体类别的异常-ExceptionHandler"><a href="#方法级别注解-处理具体类别的异常-ExceptionHandler" class="headerlink" title="方法级别注解 处理具体类别的异常@ExceptionHandler"></a>方法级别注解 处理具体类别的异常<mark>@ExceptionHandler<mark></h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022153703868.png" alt="image-20241022153703868"></p>
<p>处理异常返回的结果也要封装成Result</p>
<h3 id="项目异常处理方案-捕获异常并返回Result"><a href="#项目异常处理方案-捕获异常并返回Result" class="headerlink" title="项目异常处理方案 (捕获异常并返回Result)"></a>项目异常处理方案 (捕获异常并返回Result)</h3><h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><ul>
<li><strong>业务异常 BusinessException</strong> 可预期<ul>
<li>发送对应消息，提醒用户规范操作</li>
</ul>
</li>
<li><strong>系统异常 SystemException</strong> <ul>
<li>发送固定消息，安抚用户</li>
<li>发送特定消息给运维，提醒维护</li>
<li>记录日志</li>
</ul>
</li>
<li><strong>其他异常 Exception</strong><ul>
<li>发送固定消息，安抚用户</li>
<li>发送特定消息给开发，提醒维护（纳入预期范围）</li>
<li>记录日志</li>
</ul>
</li>
</ul>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022154704744.png" alt="image-20241022154704744"></p>
<h5 id="继承RuntimeException"><a href="#继承RuntimeException" class="headerlink" title="继承RuntimeException"></a>继承RuntimeException</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022155606802.png" alt="image-20241022155606802"></p>
<p>加一个code属性（getter setter），重写RuntimeException的方法。异常构造的时候需要用到这些构造器，包装返回数据要用到code和message</p>
<p>建议放在源根的exception包下面</p>
<h5 id="异常代码扩充"><a href="#异常代码扩充" class="headerlink" title="异常代码扩充"></a>异常代码扩充</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022160311854.png" alt="image-20241022160311854"></p>
<h5 id="触发异常"><a href="#触发异常" class="headerlink" title="触发异常"></a>触发异常</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022160332391.png" alt="image-20241022160332391"></p>
<h5 id="拦截并处理异常-返回Result"><a href="#拦截并处理异常-返回Result" class="headerlink" title="拦截并处理异常 返回Result"></a>拦截并处理异常 返回Result</h5><p>在RestControllerAdvice下方的类中处理对应类型的异常，将异常继续封装成Result返回</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022160546843.png" alt="image-20241022160546843"></p>
<h3 id="放行静态资源配置"><a href="#放行静态资源配置" class="headerlink" title="放行静态资源配置"></a>放行静态资源配置</h3><h4 id="SpringMvcSupport（Config类）"><a href="#SpringMvcSupport（Config类）" class="headerlink" title="SpringMvcSupport（Config类）"></a>SpringMvcSupport（Config类）</h4><p>加Configuration注解，继承WebMvcConfigurationSupport类，重写resourceHandler方法</p>
<h4 id="Config包详解"><a href="#Config包详解" class="headerlink" title="Config包详解"></a><mark>Config包详解<mark></h4><h5 id="ServletContainersInitializerConfig-Servlet容器配置类"><a href="#ServletContainersInitializerConfig-Servlet容器配置类" class="headerlink" title="ServletContainersInitializerConfig (Servlet容器配置类)"></a>ServletContainersInitializerConfig (Servlet容器配置类)</h5><p>用来构建ServletContext，继承自 AbstractDispatcherServletInitializer，Spring MVC是建立在 DispatcherServlet 基础之上的，每一个请求最先访问的都是它，负责转发每一个Request请求，所以是必不可少的。</p>
<p>先以 <mark>Abstract<u>DispatcherServlet</u>Initializer<mark> 为例介绍这个加载Config类的职责 具体介绍在<a href="#webappinit">下方</a></p>
<h6 id="a-createRootApplicationContext"><a href="#a-createRootApplicationContext" class="headerlink" title="a. createRootApplicationContext"></a>a. createRootApplicationContext</h6><p>需要加载Spring IoC容器的配置类(SpringConfig)，返回配置好的 <a href="#wac">Root WAC</a> </p>
<h6 id="b-createServletApplicationContext"><a href="#b-createServletApplicationContext" class="headerlink" title="b.createServletApplicationContext"></a>b.createServletApplicationContext</h6><p>需要加载WebMvc容器的配置类(SpringMvcConfig) 返回配置好的 <a href="#swac">Servlet WAC</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022205635235.png" alt="image-20241022205635235"></p>
<h6 id="c-getServletMappings"><a href="#c-getServletMappings" class="headerlink" title="c.getServletMappings"></a>c.getServletMappings</h6><p>配置由此DispatcherServlet接管的URL映射路径</p>
<h5 id="SpringConfig-Configuration"><a href="#SpringConfig-Configuration" class="headerlink" title="SpringConfig(@Configuration)"></a>SpringConfig(@Configuration)</h5><p><u>对应applicationContext.xml</u>，配置 <a href="#wac">Root WAC</a>  </p>
<p><a href="https://www.cnblogs.com/zzjlxy-225223/p/12611093.html">applicationContext.xml及spring-servlet.xml详解 - 长木木弓 - 博客园 (cnblogs.com)</a>  </p>
<p>注解开发用来替代传统的XML配置文件，因此可以透过xml与注解的映射关系来了解，<code>@Configuration</code>用来替代<code>&lt;beans&gt;</code> <code>&lt;/beans&gt;</code> 在应用启动时，Spring 会自动扫描并加载所有带有 <code>@Configuration</code> 注解的类，根据<code>@ComponentScan</code>扫描要加入的<code>@Component</code>(代替<code>&lt;bean&gt;</code> <code>&lt;/bean&gt;</code>)，最终创建出对应的容器(Context) </p>
<h6 id="Import-MyBatisConfig-class-JdbcConfig-class"><a href="#Import-MyBatisConfig-class-JdbcConfig-class" class="headerlink" title="@Import({MyBatisConfig.class,JdbcConfig.class})"></a>@Import({MyBatisConfig.class,JdbcConfig.class})</h6><p><code>MyBatisConfig</code> 和 <code>JdbcConfig</code>中方法级别注解<code>@Bean</code>用来替代 <code>&lt;bean&gt;</code> <code>&lt;/bean&gt;</code> 标签（表示方法返回的对象当成Bean/Component交给Spring容器管理）虽然没有加<code>Configuration</code>注解，但是会由<code>SpringConfig</code> <code>@Import</code>，导入的还是SpringConfig配置的容器，属于 <a href="#wac">Root WAC</a> </p>
<h5 id="SpringMvcConfig-Configuration-EnableWebMvc"><a href="#SpringMvcConfig-Configuration-EnableWebMvc" class="headerlink" title="SpringMvcConfig(@Configuration @EnableWebMvc)"></a>SpringMvcConfig(@Configuration @EnableWebMvc)</h5><p><u>对应spring-servlet.xml</u>，配置 <a href="#swac">Servlet WAC</a> </p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/EnableWebMvc.html">@EnableWebMvc (Spring Framework 6.1.14 API)</a> </p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurationSupport.html">WebMvcConfigurationSupport (Spring Framework 6.1.14 API)</a>  (WMCS)</p>
<ul>
<li><p><code>@EnableWebMvc</code> 会通过导入 <code>WMCS</code> 完成 Spring MVC 默认配置的添加，<strong>只有一个类能拥有此注解</strong> </p>
</li>
<li><p>不写 <code>@EnableWebMvc</code> 直接继承 WMCS 也可以实现相同效果</p>
</li>
<li><p>自定义具体某项WebMvc配置：<code>extends WebMvcConfigurer</code> 允许多个WebMvcConfigurer存在，但是具有一定侵入性</p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023210351697.png" alt="image-20241023210351697"></p>
<ul>
<li>主要Config：<code>@EnableWebMvc</code> + 继承 <code>WebMvcConfigurer</code> 重写方法 + <code>@ComponentScan</code> 其他Config类</li>
<li>次要Config：继承 <code>WebMvcConfigurer</code>重写方法+@Configuration确保被主要Config扫描到</li>
<li>没有暴露高级设置，如果需要高级设置 需要第二种方式直接继承 WMCS 来做更高级别的配置，此时要移除@Enable注解</li>
</ul>
<h6 id="SpringMvcSupport-Configuration"><a href="#SpringMvcSupport-Configuration" class="headerlink" title="SpringMvcSupport(@Configuration)"></a>SpringMvcSupport(@Configuration)</h6><p><u>对应springMvcContext.xml</u>，配置 <a href="#swac">Servlet WAC</a> </p>
<ul>
<li>继承WMCS，完成对SpringMVC的默认配置，重写resourceHandler方法，实现在默认配置基础上的自定义。</li>
<li>案例中的SMS是配置类，用于配置容器，被SMC扫config包扫到了，此时SMS这里的自定义配置会覆盖SMC的Enable注解</li>
</ul>
<h3 id="前端逻辑"><a href="#前端逻辑" class="headerlink" title="前端逻辑"></a>前端逻辑</h3><p>查询： get请求</p>
<p>保存/添加：post请求</p>
<p>新增要弹出表单，添加成功要关闭表单并<strong>清空表单数据</strong>，不论成功与否finallyGetAll回显 ，按照识别码判别成功与否</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023190220059.png" alt="image-20241023190220059"></p>
<p>修改：put请求</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023191646261.png" alt="image-20241023191646261"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023191751771.png" alt="image-20241023191751771"></p>
<p>删除：delete请求</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023191526268.png" alt="image-20241023191526268"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023191952545.png" alt="image-20241023191952545"></p>
<h3 id="容器之间的嵌套关系-概念解释-源码解析"><a href="#容器之间的嵌套关系-概念解释-源码解析" class="headerlink" title="容器之间的嵌套关系 + 概念解释 (源码解析)"></a>容器之间的嵌套关系 + 概念解释 (源码解析)</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022175254007-1729595662475-3.png" alt="image-20241022175254007"></p>
<h4 id="WebApplicationContext-WAC"><a href="#WebApplicationContext-WAC" class="headerlink" title="WebApplicationContext(WAC)"></a><span id="wac">WebApplicationContext(WAC)</span></h4><ul>
<li>ApplicationContext(AC) 表示整个 Spring 应用的上下文。WAC是普通AC的扩展，它具有Web应用程序所需的一些额外功能，比如可以<u>get</u>ServletContext或者<u>set</u>ServletContext</li>
<li><code>Root WAC</code>在应用启动时首先被加载，并且作为父上下文，供表示层使用，主要负责管理服务层（Service）、数据访问层（DAO）、中间件配置等非 Web 层（表示层）的 Bean</li>
</ul>
<h4 id="Servlet-WebApplicationContext-Servlet-WAC"><a href="#Servlet-WebApplicationContext-Servlet-WAC" class="headerlink" title="Servlet WebApplicationContext(Servlet WAC)"></a><span id="swac">Servlet WebApplicationContext(Servlet WAC)</span></h4><ul>
<li><code>Servlet WAC</code> 是 <code>Root WAC</code> 的<strong>子上下文</strong>，专门用于处理表示层的 Bean 和配置。比如控制器（<code>Controller</code>）、视图解析器、拦截器(<code>Interceptor</code>)等</li>
<li>每个 <code>DispatcherServlet</code> 实例会有一个独立的 <code>Servlet WAC</code> </li>
</ul>
<h5 id="Parent-amp-Child-ApplicatitonContext"><a href="#Parent-amp-Child-ApplicatitonContext" class="headerlink" title="Parent &amp; Child ApplicatitonContext"></a>Parent &amp; Child ApplicatitonContext</h5><p>Root WAC 作为 所有 Servlet WAC 的 Parent，DispatherServlet在创建属于自己的ServletContext的getAttribute方法来判断是否存在Root WebApplicationContext。如果存在，则将其设置为自己的parent。这就是父子上下文(父子容器)的概念，getParentBeanFactory。</p>
<p>对于作用范围而言，在DispatcherServlet中可以引用由ContextLoaderListener所创建的RootWAC中的内容，而反过来不行。当Spring在执行ApplicationContext的getBean时，如果在自己context中找不到对应的bean，则会在父ApplicationContext中去找。这也解释了为什么我们可以在DispatcherServlet中获取到RootWAC中的bean。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023154504980.png" alt="image-20241023154504980"></p>
<h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><ul>
<li>Servlet容器（Tomcat）在启动一个web应用时，根据web.xml 会为整个应用创建一个<mark>唯一<mark>的ServletContext(SC)对象，应用内部所有的Servlet共享同一个SC。</li>
<li>ServletContext是Servlet与Servlet容器（Tomcat）之间直接通信的接口。</li>
<li>容器中的Servlet可以通过它来访问容器中的各种资源</li>
<li>ServletContext跟XML一样，由Attributes组成，要访问资源就要通过字符串name访问，可以通过<code>void setAttribute(name, object) </code>来将ServletContext与你的object绑定，<code>Object getAttribute(name)</code>可以得到object</li>
<li><code>Enumeration&lt;String&gt; getInitParameterNames()</code> 获取所有 <code>&lt;context-param/&gt;</code> 参数的名称 字符串枚举</li>
<li><code> String getInitParameter(name)</code> 根据name获取指定的 <code>&lt;context-param/&gt;</code> 参数值</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023013135254.png" alt="image-20241023013135254"></p>
<h5 id="Root-WAC-Servlet-WAC-ServletContext之间的关系"><a href="#Root-WAC-Servlet-WAC-ServletContext之间的关系" class="headerlink" title="Root WAC, Servlet WAC, ServletContext之间的关系"></a>Root WAC, Servlet WAC, ServletContext之间的关系</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022230909096.png" alt="image-20241022230909096"></p>
<ul>
<li><p>Root WebApplicationContext存储key为<code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>，可以通过此Key访问Root WAC。</p>
</li>
<li><p>WebApplicationContextUtis工具类提供了从ServletContext获取RootWAC的方法：</p>
<ul>
<li><code>WebApplicationContextUtils.getWebApplicationContext(ServletContext sc)</code></li>
</ul>
</li>
<li><p>WAC提供了获取ServletContext的抽象方法 <code>getServletContext()</code> </p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E6%97%A0%E6%A0%87%E9%A2%98-1729654361571-5.png" alt="context"></p>
<h5 id="web-xml-配置-ServletContext"><a href="#web-xml-配置-ServletContext" class="headerlink" title="web.xml 配置 ServletContext"></a>web.xml 配置 ServletContext</h5><p>Tomcat创建web应用时，会构建ServletContext对象，根据web.xml中的配置把如下参数都存到ServletContext对象中，注册Listener，Servlet等</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line">    &lt;!—ServletContext自有的init 参数--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span>  </span><br><span class="line">        &lt;!—创建Root WAC所需要的配置文件路径--&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span>  </span><br><span class="line">  	</span><br><span class="line">    &lt;!—注册ContextLoaderListener--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line">    &lt;!—注册DispatcherServlet ServletConfig--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span> </span><br><span class="line">        &lt;!—init Servlet所需参数--&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">            &lt;!—创建Servlet WAC所需参数--&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/spring-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line">        &lt;!—指定某个servlet的URL映射路径--&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="ContextLoaderListener-创建-Root-WAC"><a href="#ContextLoaderListener-创建-Root-WAC" class="headerlink" title="ContextLoaderListener - 创建 Root WAC"></a>ContextLoader<mark>Listener<mark> - 创建 Root WAC</h4><ul>
<li><p>本质就是一个Listener，因此需要在web.xml中注册</p>
</li>
<li><p>实现了ServletContextListener接口，EventListener-&gt;ServletContextListener</p>
</li>
<li><p>继承了ContextLoader类，见名知意，是用来加载WAC的，有一个WAC参数context，所有方法都是围绕加工这个context字段进行的</p>
</li>
</ul>
<h5 id="WebApplicationContext-initWAC-ServletContext-sc"><a href="#WebApplicationContext-initWAC-ServletContext-sc" class="headerlink" title="WebApplicationContext initWAC(ServletContext sc)"></a>WebApplicationContext initWAC(ServletContext sc)</h5><p>ContextLoaer 接收一个ServletContext参数sc，调用initWAC方法返回加载好的WAC对象this.context</p>
<p>打印在服务器日志上 <code>servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);</code></p>
<p>中间调用<code>createWAC(ServletContext sc)</code>返回一个ConfigurableWAC对象，将其<strong>parentContext设置为sc</strong>，</p>
<p>再把这个CWAC和sc传给<code>configureAndRefreshWAC(CWAC cwac,ServletContext sc)</code>方法进行配置（ServletContext是根据web.xml构建的，根据key: contextConfigLocation找到RootWAC的配置文件<code>applicationContext.xml</code>）</p>
<p>之后在sc中创建一个Attribute，使得能通过ServletContext对这个Root WAC进行访问（键值对形式）</p>
<p><code>setAttribute(</code> <code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>, <code>this.context)</code></p>
<p>最终返回 <code>this.context</code> 作为 Root WAC</p>
<h5 id="WebApplicationContext-contextInitialized-ServletContextEvent-sce"><a href="#WebApplicationContext-contextInitialized-ServletContextEvent-sce" class="headerlink" title="WebApplicationContext contextInitialized(ServletContextEvent sce)"></a>WebApplicationContext contextInitialized(ServletContextEvent sce)</h5><p>ContextLoaderListener 能监听Web应用启动或关闭的事件（会修改ServletContext中的参数），触发contextInitializaed/contextDestroyed，创建或销毁Root WAC。</p>
<h4 id="DispatcherServlet-创建-Servlet-WAC"><a href="#DispatcherServlet-创建-Servlet-WAC" class="headerlink" title="DispatcherServlet - 创建 Servlet WAC"></a>Dispatcher<mark>Servlet<mark> - 创建 Servlet WAC</h4><ul>
<li><p>本质就是一个Servlet，所以需要在web.xml中注册，继承自HttpServlet-&gt;HttpServletBean-&gt;FrameworkServlet</p>
</li>
<li><p>Spring MVC 的核心前端控制器，用于处理所有进入的 HTTP 请求。将请求分发给适当的处理器（控制器 Controller），并在处理后将响应返回给客户端。</p>
</li>
<li><p>每一个 <code>DispatcherServlet</code> 都拥有自己的 <a href="#swac">Servlet WebApplicationContext</a>，管理与 Web 层(表现层)相关的 Bean，如控制器、视图解析器、拦截器等。</p>
</li>
<li><p>HttpServletBean有一个final的init()<strong>[Servlet的入口方法]</strong>  其中会调用抽象方法initServletBean()</p>
</li>
<li><p>FrameServlet实现了initServletBean(): <strong>[生成Servlet WAC，设置parent和ServletContext]</strong> 最后会调用initStrategies</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">var10000</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line"><span class="type">String</span> <span class="variable">var10001</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getSimpleName();</span><br><span class="line">var10000.log(<span class="string">&quot;Initializing Spring &quot;</span> + var10001 + <span class="string">&quot; &#x27;&quot;</span> + <span class="built_in">this</span>.getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"><span class="comment">//记录日志</span></span><br></pre></td></tr></table></figure>

<ul>
<li>同样的，途中也会调用自己的initWAC方法：<ul>
<li>调用WACUtils工具类，获得自己所在的ServletContext的<strong>Root WAC</strong> </li>
<li>将自己的WAC转换成CWAC，如果存在RootWAC，则将其设置为自己的parent</li>
<li>然后configureAndRefreshWAC(cwac)：设置ServletContext为sc，从其中ServletConfig中获取 <code>&lt;init-param&gt;</code> 参数的值</li>
</ul>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023013013442.png" alt="image-20241023013013442"></p>
<ul>
<li>最后根据自己的ServletConfig获取到ServletContext，根据自己的名称设置自己的Servlet WAC在ServletContext中的Key</li>
</ul>
</li>
<li><p>DispatcherServlet实现了initStrategies [生成各个功能组件，异常处理器，视图处理，请求映射]</p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/mvc-context-hierarchy.png" alt="mvc-context-hierarchy"></p>
<p>这两个context都是在ServletContext中，属于dispatcherServlet的上下文是servletWAC，找不到的话就去rootWAC中找</p>
<h4 id="替代web-xml，以Java形式配置ServletContext——WebApplicationInitializer"><a href="#替代web-xml，以Java形式配置ServletContext——WebApplicationInitializer" class="headerlink" title="替代web.xml，以Java形式配置ServletContext——WebApplicationInitializer"></a><span id="webappinit">替代web.xml，以Java形式配置ServletContext——WebApplicationInitializer</span></h4><p>![屏幕截图 2024-10-23 133904](<a href="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/屏幕截图</a> 2024-10-23 133904.png)</p>
<h5 id="ServletContainerInitializer"><a href="#ServletContainerInitializer" class="headerlink" title="ServletContainerInitializer"></a>ServletContainerInitializer</h5><p>之前，web容器（Tomcat）会根据WEB-INF下的web.xml初始化ServletContext</p>
<p>Java EE Servlet 规范定义了这个接口，web容器（Tomcat）启动时根据这个初始化器做一些组件内的初始化工作。 </p>
<p><strong>SpringServletContainerInitializer</strong> 是Spring 对其的实现，其onStartup方法会调用 <strong><a href="#webappinit">WebApplicationInitializer</a></strong> 的onStartup(<strong>ServletContext sc</strong>)初始化Web应用</p>
<h4 id="SpringMVC-Web应用启动流程"><a href="#SpringMVC-Web应用启动流程" class="headerlink" title="SpringMVC Web应用启动流程"></a>SpringMVC Web应用启动流程</h4><ul>
<li>Tomcat 读取web.xml中 <code>&lt;context-param&gt;</code> <code>&lt;listener&gt;</code>  然后创建一个全局共享的ServletContext</li>
<li>Tomcat 将<code>&lt;context-param&gt;</code> <code>&lt;listener&gt;</code>转化为键值对，存到ServletContext </li>
<li>Tomcat 加载Listener实例，实施监听，Listener必须实现<u>ServletContext</u>Listener接口（比如ContextLoaderListener）</li>
<li><strong>Web项目继续启动中</strong>，触发Listener中的contextInitialized(ServletContexEvent event)，根据ServletContext中 <code>&lt;context-param&gt;</code> 部分创建父容器，configClass是类的形式，configLocation是xml配置文件的形式</li>
<li>创建完父容器，如果有<code>&lt;filter&gt;</code>会创建filter，然后读取 <code>&lt;servlet&gt;</code> 用于注册DispatcherServlet（这块流程建议从init方法一步步往下看，流程还是很清晰的），因为DispatcherServlet实质是一个Servlet，所以会先执行它的init方法。这个init()方法在<strong>HttpServletBean</strong>这个类中实现，其主要工作是做一些初始化工作，将我们在web.xml中配置的参数设置到ServletContext的ServletConfig中，然后再触发<strong>FrameworkServlet</strong>的initServletBean()方法；<ul>
<li><strong>FrameworkServlet</strong>主要作用是初始化Spring子容器，设置其父容器，并将其放入ServletContext中；</li>
<li><strong>FrameworkServlet</strong>在调用initServletBean()的过程中同时会触发<strong>DispatcherServlet</strong>的onRefresh()方法，这个方法会初始化Spring MVC的各个功能组件。比如异常处理器、视图处理器、请求映射处理等</li>
</ul>
</li>
</ul>
<p><a href="https://www.cnblogs.com/54chensongxia/p/12522804.html">Spring MVC启动流程</a> </p>
<h5 id="100-code-based"><a href="#100-code-based" class="headerlink" title="100% code-based"></a>100% code-based</h5><p>用Java类的形式配置ServletContext，有一些细微差异，Spring这边实现了ServletContainerInitializer接口，注册组件的工作就交给了WebApplicationInitializer：</p>
<p>先根据指定的rootWacConfig配置类（SpringConfig）创建出父容器，父容器作为参数进行Listener的有参构造，最后以<mark>add<mark>Listener的方式注册到ServletContext中。</p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023193138396.png" alt="image-20241023193138396"></p>
<h4 id="Interceptor-vs-Filter"><a href="#Interceptor-vs-Filter" class="headerlink" title="Interceptor vs Filter"></a>Interceptor vs Filter</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023193414214.png" alt="image-20241023193414214"></p>
<p>filter在一定是在访问servlet之前，interceptor只能在servlet中， <mark>before Controller<mark></p>
<h3 id="功能类"><a href="#功能类" class="headerlink" title="功能类"></a>功能类</h3><p>控制表现层：controller下新建interceptor包，新建一个Interceptor类 <strong>extends HandlerInterceptor</strong> </p>
<p>注意preHandle返回值和@Component</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023210048371.png" alt="image-20241023210048371"></p>
<h4 id="SpringMvcSupport"><a href="#SpringMvcSupport" class="headerlink" title="SpringMvcSupport"></a>SpringMvcSupport</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023205518460.png" alt="image-20241023205518460"></p>
<p>addInterceptors 自动注入自定义拦截器</p>
<p>addPathPatterns 加的不是前缀，<mark>是严格的URL匹配<mark>，配/books就拦截对/books发的请求，/books/100就拦截不了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023205715345.png" alt="image-20241023205715345"></p>
<p><mark>preHandle<mark>，yourService，postHandle，afterCompletion 顺序</p>
<h4 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023210636045.png" alt="image-20241023210636045"></p>
<h4 id="简化开发"><a href="#简化开发" class="headerlink" title="简化开发"></a>简化开发</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023210528299.png" alt="image-20241023210528299"></p>
<p>已经和Spring接口绑定，侵入性强。</p>
<h3 id="拦截方法参数配置"><a href="#拦截方法参数配置" class="headerlink" title="拦截方法参数配置"></a>拦截方法参数配置</h3><h4 id="boolean-preHandle-req-resp-handler"><a href="#boolean-preHandle-req-resp-handler" class="headerlink" title="boolean preHandle(req,resp,handler)"></a>boolean preHandle(req,resp,<mark>handler<mark>)</h4><p>req和resp是servlet的响应和请求，handler实际上是HandlerMethod，通过getMethod能拿到执行的业务方法的对象（反射）</p>
<h4 id="void-postHandle-req-resp-handler-modelAndView"><a href="#void-postHandle-req-resp-handler-modelAndView" class="headerlink" title="void postHandle(req,resp,handler,modelAndView)"></a>void postHandle(req,resp,<mark>handler<mark>,modelAndView)</h4><p>页面跳转相关。</p>
<h4 id="void-afterCompletion-req-resp-handler-exception"><a href="#void-afterCompletion-req-resp-handler-exception" class="headerlink" title="void afterCompletion(req,resp,handler,exception)"></a>void afterCompletion(req,resp,<mark>handler<mark>,exception)</h4><p>能拿到原始业务方法执行过程中的异常</p>
<h3 id="拦截链顺序"><a href="#拦截链顺序" class="headerlink" title="拦截链顺序"></a>拦截链顺序</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023211911820.png" alt="image-20241023211911820"></p>
<p>拦截顺序，和注册顺序有关系</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023212439810.png" alt="image-20241023212439810"></p>
<p>如果某个pre返回false，post全部跳过，倒序执行，从最近一个pre返回true的拦截器开始执行afterCompletion</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023212527269.png" alt="image-20241023212527269"></p>
<p><a href="https://blog.csdn.net/penriver/article/details/118571991">万字详解 GoF 23 种设计模式（多图、思维导图、模式对比），让你一文全面理解-CSDN博客</a></p>
<h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><h2 id="入门案例——Web项目"><a href="#入门案例——Web项目" class="headerlink" title="入门案例——Web项目"></a>入门案例——Web项目</h2><h3 id="创建boot模块"><a href="#创建boot模块" class="headerlink" title="创建boot模块"></a>创建boot模块</h3><p><a href="https://blog.csdn.net/dream_ready/article/details/134639886">idea创建不了spring2.X版本，无法使用JDK8，最低支持JDK17 ， 如何用idea创建spring2.X版本，使用JDK8解决方案_spring3不支持jdk8-CSDN博客</a></p>
<p>SpringBoot2停止维护，SpringBoot3最低Java17</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025190302057.png" alt="image-20241025190302057"></p>
<h3 id="写控制器类"><a href="#写控制器类" class="headerlink" title="写控制器类"></a>写控制器类</h3><p>把controller类写好</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025194037167.png" alt="image-20241025194037167"></p>
<h3 id="启动app"><a href="#启动app" class="headerlink" title="启动app"></a>启动app</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025194052846.png" alt="image-20241025194052846"></p>
<h2 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h2><h3 id="打包—jar"><a href="#打包—jar" class="headerlink" title="打包—jar"></a>打包—jar</h3><p><code>package</code> 之前 <code>clean</code> 全部设置为UTF-8参数</p>
<h3 id="命令行启动-java-jar"><a href="#命令行启动-java-jar" class="headerlink" title="命令行启动 java -jar"></a>命令行启动 java -jar</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025194844475.png" alt="image-20241025194844475"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025194925821.png" alt="image-20241025194925821"></p>
<p>jar执行要有入口类，boot打包需要插件才能生成可执行的入口类</p>
<h2 id="简述boot"><a href="#简述boot" class="headerlink" title="简述boot"></a>简述boot</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025195226537.png" alt="image-20241025195226537"></p>
<h3 id="starter-起步依赖"><a href="#starter-起步依赖" class="headerlink" title="starter 起步依赖"></a>starter 起步依赖</h3><h3 id="starter-parent-依赖管理"><a href="#starter-parent-依赖管理" class="headerlink" title="starter-parent 依赖管理"></a>starter-parent 依赖管理</h3><p>starter-parent：定义了无数jar包的版本管理和依赖管理，减少依赖冲突。只写GA 不写V</p>
<h3 id="dependencies-辅助功能"><a href="#dependencies-辅助功能" class="headerlink" title="dependencies-辅助功能"></a>dependencies-辅助功能</h3><p>每一个dependency（以web包为例）把真正需要用到的jar包声明，去找parent要即可</p>
<p>spring-boot-starter-web: </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025201404198.png" alt="image-20241025201404198"></p>
<p>spring-boot-dependencies: </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025201443556.png" alt="image-20241025201443556"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025201805886.png" alt="image-20241025201805886"></p>
<h3 id="替换starter的某个依赖"><a href="#替换starter的某个依赖" class="headerlink" title="替换starter的某个依赖"></a>替换starter的某个依赖</h3><p>依赖排除exclusion，换技术</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025202142653.png" alt="image-20241025202142653"></p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="resources目录下配置文件加载优先级"><a href="#resources目录下配置文件加载优先级" class="headerlink" title="resources目录下配置文件加载优先级"></a>resources目录下配置文件加载优先级</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025204356892.png" alt="image-20241025204356892"></p>
<p>properties&gt;<mark>yml<mark>&gt;yaml</p>
<h3 id="自动提示功能消失—引入配置文件到boot模块中"><a href="#自动提示功能消失—引入配置文件到boot模块中" class="headerlink" title="自动提示功能消失—引入配置文件到boot模块中"></a>自动提示功能消失—引入配置文件到boot模块中</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025204437530.png" alt="image-20241025204437530"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025204503008.png" alt="image-20241025204503008"></p>
<p>debug&gt;info&gt;warn</p>
<h3 id="YAML—-YAML-Ain’t-Markup-Language"><a href="#YAML—-YAML-Ain’t-Markup-Language" class="headerlink" title="YAML—(YAML Ain’t Markup Language)"></a>YAML—(YAML Ain’t Markup Language)</h3><h4 id="YAML-简介"><a href="#YAML-简介" class="headerlink" title="YAML 简介"></a>YAML 简介</h4><p>Jamel  Camel</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025204800590.png" alt="image-20241025204800590"></p>
<h4 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025204945594.png" alt="image-20241025204945594"></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 空格数量不限，只要前面格数一样就是同一级，不允许使用tab缩进</span></span><br><span class="line"><span class="attr">enterprise:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">John</span></span><br><span class="line"> <span class="attr">likes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Java</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Python</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">C++</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025205033642.png" alt="image-20241025205033642"></p>
<h3 id="以Java方式读取yaml配置文件"><a href="#以Java方式读取yaml配置文件" class="headerlink" title="以Java方式读取yaml配置文件"></a>以Java方式读取yaml配置文件</h3><h4 id="读取单个数据—定义成员变量-Value-enterprise-subject"><a href="#读取单个数据—定义成员变量-Value-enterprise-subject" class="headerlink" title="读取单个数据—定义成员变量@Value(${enterprise.subject)"></a>读取单个数据—定义成员变量@Value(${enterprise.subject)</h4><p>自动赋值</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025205805383.png" alt="image-20241025205805383"></p>
<h4 id="读取全部数据—Environment对象"><a href="#读取全部数据—Environment对象" class="headerlink" title="读取全部数据—Environment对象"></a>读取全部数据—Environment对象</h4><p>定义一个Environment，自动装配，将配置中的属性全部遍历:</p>
<p><code>environment.getProperty(&quot;name&quot;)</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025210024893.png" alt="image-20241025210024893"></p>
<h4 id="自定义对象封装指定数据-Component-ConfigurationProperties-prefix-enterprise"><a href="#自定义对象封装指定数据-Component-ConfigurationProperties-prefix-enterprise" class="headerlink" title="自定义对象封装指定数据@Component@ConfigurationProperties(prefix = enterprise)"></a><strong>自定义对象封装指定数据</strong>@Component@ConfigurationProperties(prefix = enterprise)</h4><p>可以拿到需要的某个属性的信息(prefix)</p>
<p>在控制器中定义成员变量自动装配，常用</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025210946272.png" alt="image-20241025210710013"></p>
<h5 id="自定义对象封装数据警告"><a href="#自定义对象封装数据警告" class="headerlink" title="自定义对象封装数据警告"></a>自定义对象封装数据警告</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025211036999.png" alt="image-20241025211036999"></p>
<h3 id="多环境开发"><a href="#多环境开发" class="headerlink" title="多环境开发"></a>多环境开发</h3><h4 id="生产环境设定"><a href="#生产环境设定" class="headerlink" title="生产环境设定"></a>生产环境设定</h4><p><strong>独立生产环境设定</strong>：</p>
<p><code>spring.profiles</code> <strong>boot2</strong></p>
<p><code>spring.config.activate.on-profile</code> <strong>boot3</strong></p>
<p><code>---</code> 三条横线分割配置</p>
<p><code>spring.profiles.active</code> 设置激活的环境</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025214421983.png" alt="image-20241025214421983"></p>
<h4 id="带参数启动boot"><a href="#带参数启动boot" class="headerlink" title="带参数启动boot"></a>带参数启动boot</h4><h5 id="命令行参数临时修改配置内容"><a href="#命令行参数临时修改配置内容" class="headerlink" title="命令行参数临时修改配置内容"></a>命令行参数临时修改配置内容</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改启动环境为test</span></span><br><span class="line">java -jar boot_1.0_SNAPSHOT.jar --spring.profiles.active=<span class="built_in">test</span></span><br><span class="line"><span class="comment"># 修改服务器端口号为88</span></span><br><span class="line">java -jar boot_1.0_SNAPSHOT.jar --server.port=88</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="参数加载优先级"><a href="#参数加载优先级" class="headerlink" title="参数加载优先级"></a>参数加载优先级</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025215406246.png" alt="image-20241025215406246"></p>
<h4 id="maven-amp-boot开发环境兼容—加载配置文件"><a href="#maven-amp-boot开发环境兼容—加载配置文件" class="headerlink" title="maven&amp;boot开发环境兼容—加载配置文件"></a>maven&amp;boot开发环境兼容—加载配置文件</h4><p>maven和boot都设置了多环境，但是打包工作是maven负责，所以maven应该占主导</p>
<p>手动配置resources插件，覆盖parent设定</p>
<p><a href="https://www.cnblogs.com/hcgk/p/17600908.html">maven-resources-plugin详解 - 红尘过客2022 - 博客园 (cnblogs.com)</a></p>
<h5 id="lt-resources-gt-lt-filtering-gt"><a href="#lt-resources-gt-lt-filtering-gt" class="headerlink" title="&lt;resources&gt; (&lt;filtering&gt;)"></a><code>&lt;resources&gt;</code> (<code>&lt;filtering&gt;</code>)</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026013908079.png" alt="image-20241026013908079"></p>
<p><code>&lt;resources&gt;</code>标签其实就是<code>maven-resources-plugin</code>的<code>&lt;resources&gt;</code>配置，主要用来配置资源目录的。普通项目没有<code>parent</code>，默认继承<code>父pom.xml</code>: </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026024547372.png" alt="image-20241026024547372"></p>
<p>可以看到<code>resources</code>默认就是项目下的<code>src/main/resources</code>，但是没开过滤<code>filtering</code>，所以之前maven课程中，<u>在配置文件中引入占位符还得重写一遍resources标签。</u></p>
<p>而boot模块默认继承的starter-parent默认的<code>resources</code>标签是开了过滤的，而且资源明确<code>包括application.yml</code>这种配置文件，所以即使子项目里不用手动复写<code>resources</code>也能匹配到占位符：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026025346547.png" alt="image-20241026025346547"></p>
<h5 id="maven-resources-plugin-lt-useDefaultDelimeters-gt"><a href="#maven-resources-plugin-lt-useDefaultDelimeters-gt" class="headerlink" title="maven-resources-plugin (&lt;useDefaultDelimeters&gt; )"></a><code>maven-resources-plugin</code> (<code>&lt;useDefaultDelimeters&gt;</code> )</h5><p><code>&lt;useDefaultDelimeters&gt;</code> 支持使用<code>$&#123;&#125;或@</code>过滤资源 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026021624316.png" alt="image-20241026021624316"></p>
<p>boot的starter-parent默认对<code>resources-plugin</code>的配置也做了自定义更改（主要就是<code>&lt;useDefaultDelimeters&gt;</code> = false）而上文提到的父pom没有，<code>&lt;useDefaultDelimeters&gt;</code>默认就是true</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026025510839.png" alt="image-20241026025510839"></p>
<h4 id="定义多环境-lt-profiles-gt"><a href="#定义多环境-lt-profiles-gt" class="headerlink" title="定义多环境 &lt;profiles&gt;"></a>定义多环境 <code>&lt;profiles&gt;</code></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026005328800.png" alt="image-20241026005328800"></p>
<h4 id="配置属性替换占位符"><a href="#配置属性替换占位符" class="headerlink" title="配置属性替换占位符"></a>配置属性替换占位符</h4><h5 id=""><a href="#" class="headerlink" title="@"></a><code>@</code></h5><p>boot项目的parent为了防止spring占位符被扩展，所以只允许<code>@</code>为占位符，不解析<code>$&#123;&#125;</code>。如果已经继承starter-parent，直接在配置文件中@xxx@即可。 <a href="https://docs.springjava.cn/spring-boot/how-to/properties-and-configuration.html#howto.properties-and-configuration.expand-properties.maven">parent不是starter-parent的解决办法</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026021230152.png" alt="image-20241026021230152"></p>
<h5 id="-1"><a href="#-1" class="headerlink" title="${}"></a><code>$&#123;&#125;</code></h5><p>非要用${}，可以使用如下方法覆盖配置：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026081744618.png" alt="image-20241026081744618"></p>
<p>或者启用插件的<code>&lt;useDefaultDelimeters&gt;</code> = true</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026005308461-1729903011039-5.png" alt="image-20241026005308461"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026005348094-1729902750823-1-1729902803907-3.png" alt="image-20241026005348094"></p>
<h4 id="多配置文件加载优先级"><a href="#多配置文件加载优先级" class="headerlink" title="多配置文件加载优先级"></a>多配置文件加载优先级</h4><h5 id="包外配置"><a href="#包外配置" class="headerlink" title="包外配置"></a>包外配置</h5><p>假设JAR包位于file目录下，<code>file/config/application.yml</code> &gt; <code>file/application.yml</code></p>
<h5 id="包内配置"><a href="#包内配置" class="headerlink" title="包内配置"></a>包内配置</h5><p><code>resources/config/application.yml</code> &gt; <code>resources/application.yml</code></p>
<h4 id="Java项目目录结构"><a href="#Java项目目录结构" class="headerlink" title="Java项目目录结构"></a>Java项目目录结构</h4><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026140333629.png" alt="image-20241026140333629" style="zoom: 67%;" />

<ul>
<li><p>src/main 就是编译以后的classpath(classes)，java是java源代码，resources资源文件，编译完打包都在同一个classes目录下。</p>
</li>
<li><p>src/test 是test-classes，属于测试文件，默认不会参与打包。</p>
</li>
<li><p>依赖放在<strong>包内</strong>和classes并列的lib目录</p>
</li>
<li><p>对于maven webapp骨架，main还有webapp目录，其中WEB-INF文件夹存放web.xml，打包之后web.xml classes lib并列放在WEB-INF中</p>
<ul>
<li>webapp也可存放静态资源，打包之后在JAR包中的第一级</li>
</ul>
</li>
</ul>
<h4 id="JAR包内部结构"><a href="#JAR包内部结构" class="headerlink" title="JAR包内部结构"></a>JAR包内部结构</h4><p><a href="https://zh.wikipedia.org/wiki/JAR_(%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F)">JAR (文件格式) - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p>META-INF 整个项目的元数据，MANIFEST.MF 包含执行时的入口类等信息</p>
<p>BOOT-INF boot项目的jar包中 classes+lib</p>
<p>WEB-INF web项目war包中 classes+lib+web.xml</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026143753352.png" alt="image-20241026143753352"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026143816570.png" alt="image-20241026143816570"></p>
<h5 id="APK内部结构"><a href="#APK内部结构" class="headerlink" title="APK内部结构"></a>APK内部结构</h5><p>APK作为JAR包的变种，也具有相似的结构：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026144246642.png" alt="image-20241026144246642"></p>
<h2 id="与其他框架整合"><a href="#与其他框架整合" class="headerlink" title="与其他框架整合"></a>与其他框架整合</h2><h3 id="Spring-Boot-X-JUnit"><a href="#Spring-Boot-X-JUnit" class="headerlink" title="Spring Boot X JUnit"></a>Spring Boot X JUnit</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026151902777.png" alt="image-20241026151902777"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026152538674.png" alt="image-20241026152538674"></p>
<h4 id="测试类注解-SpringBootTest"><a href="#测试类注解-SpringBootTest" class="headerlink" title="测试类注解@SpringBootTest"></a>测试类注解@SpringBootTest</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026152650043.png" alt="image-20241026152650043"></p>
<p>SpringBoot启动类：@SpringBootApplication有加载bean的功能，会扫描当前包同层以及子包中所有的bean，加载bean（包含配置类）</p>
<p>SpringBootTest会自动扫描SpringBootApplication，测试类不在启动类所在包/子包中，需要指定启动类的class文件</p>
<h3 id="基于SpringBoot实现SSM整合"><a href="#基于SpringBoot实现SSM整合" class="headerlink" title="基于SpringBoot实现SSM整合"></a>基于SpringBoot实现SSM整合</h3><h4 id="整合MyBatis案例"><a href="#整合MyBatis案例" class="headerlink" title="整合MyBatis案例"></a>整合MyBatis案例</h4><h5 id="启动依赖-MyBatis-MySQL"><a href="#启动依赖-MyBatis-MySQL" class="headerlink" title="启动依赖-MyBatis,MySQL"></a>启动依赖-MyBatis,MySQL</h5><h5 id="pojo-dao-Mapper-MapperScan"><a href="#pojo-dao-Mapper-MapperScan" class="headerlink" title="pojo dao @Mapper @MapperScan"></a>pojo dao @Mapper @MapperScan</h5><p>mybatis自动代理注解开发返回的对象就是实体类，所以实体类不用配置，</p>
<p>mybatis注解开发中@Mapper注解取代了bookMapper.xml，对mybatis声明这是一个mapper。</p>
<p>spring-mybatis整合中，mybatis生成mapper的代理对象会以FactoryBean的形式交给Spring容器管理，要让mybatis知道mapper在哪里，就要加@Mapper注解</p>
<p>spring-mybatis整合中，不加@Mapper注解，要么配置mapperScannerConfigurer，要么加@MapperScan扫mapper包。</p>
<h5 id="application-yml-配置数据源"><a href="#application-yml-配置数据源" class="headerlink" title="application.yml 配置数据源"></a>application.yml 配置数据源</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026163010546.png" alt="image-20241026163010546"></p>
<h4 id="SSM项目迁移到Spring-Boot"><a href="#SSM项目迁移到Spring-Boot" class="headerlink" title="SSM项目迁移到Spring Boot"></a>SSM项目迁移到Spring Boot</h4><p>TODO 注释前面加TODO 可以有事项清单</p>
<h5 id="配置类全部删除"><a href="#配置类全部删除" class="headerlink" title="配置类全部删除"></a>配置类全部删除</h5><h5 id="Dao加-Mapper"><a href="#Dao加-Mapper" class="headerlink" title="Dao加@Mapper"></a>Dao加@Mapper</h5><h5 id="Controller-Service不变"><a href="#Controller-Service不变" class="headerlink" title="Controller Service不变"></a>Controller Service不变</h5><h5 id="application-yml-配置端口和数据源"><a href="#application-yml-配置端口和数据源" class="headerlink" title="application.yml 配置端口和数据源"></a>application.yml 配置端口和数据源</h5><h5 id="静态资源放到resources-static"><a href="#静态资源放到resources-static" class="headerlink" title="静态资源放到resources/static"></a>静态资源放到resources/static</h5><h6 id="静态资源的重定向-JS脚本"><a href="#静态资源的重定向-JS脚本" class="headerlink" title="静态资源的重定向(JS脚本)"></a>静态资源的重定向(JS脚本)</h6><p>访问一个web资源，如果直接访问 <code>localhost:port</code> 一般会请求一个主页index.html，为了能直接从地址访问资源，创建一个index.html，添加一个跳转的js脚本</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span>=<span class="string">&quot;pages/books.html&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>spring</tag>
        <tag>spring-boot</tag>
        <tag>spring-interceptor</tag>
        <tag>bean-lifecycle</tag>
        <tag>dependency-injection</tag>
        <tag>aop</tag>
        <tag>web</tag>
        <tag>annotation</tag>
        <tag>ioc</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希函数的工程应用</title>
    <url>/2024/08/15/hash/</url>
    <content><![CDATA[<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p><a href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">散列函数 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<h2 id="Hash-是什么"><a href="#Hash-是什么" class="headerlink" title="Hash 是什么"></a>Hash 是什么</h2><p>哈希（Hash）的原理是通过一种<strong>特定的函数</strong>，将任意长度的输入（也称为键）<strong>映射</strong>为固定长度的输出（称为哈希值、哈希码或散列值）。这种函数称为<strong>哈希函数</strong>或<strong>散列函数</strong>。哈希主要用于快速查找、数据完整性验证等方面，下面具体解释其原理和应用：</p>
<span id="more"></span>

<h2 id="哈希函数的原理"><a href="#哈希函数的原理" class="headerlink" title="哈希函数的原理"></a>哈希函数的原理</h2><p>哈希函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0">函数</a>将数据打乱混合，重新创建一个叫做<strong>散列值</strong>（又叫<strong>哈希值</strong>）（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。</p>
<p>哈希函数的基本目标是<strong>将不同的输入映射为不同的输出</strong>。常见哈希函数的特性包括：</p>
<ul>
<li><strong>确定性</strong>：相同的输入永远会产生相同的哈希值。</li>
<li><strong>效率</strong>：计算哈希值的过程非常快，便于快速存取和查找。</li>
<li><strong>分布均匀</strong>：不同的输入尽可能分布到不同的哈希值上，以减少哈希冲突。</li>
<li><strong>不可逆性</strong>：通常不能通过哈希值反推出原始输入（主要在密码学中强调）。<ul>
<li>攻破：能够找出具有相同哈希值的一对报文，但是从一个已知报文篡改成具有相同哈希值的报文仍然没有方法</li>
</ul>
</li>
</ul>
<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>哈希函数将无限多的输入映射到有限的输出空间，因此必然会发生不同输入产生相同哈希值的情况，即<strong>哈希冲突</strong>。常见的处理冲突方法有：</p>
<ul>
<li><p><strong>链地址法（链表法）</strong>：在哈希表中，每个位置存储一个链表，当出现冲突时将数据插入链表。（JDK HashMap）链地址法适用于经常进行插入和删除的情况。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ThreadLocal-20230822202707.png" alt="img"></p>
</li>
<li><p><strong>开放地址法</strong>：通过探测和寻找空位存储冲突的数据，例如线性探测、二次探测、伪随机探测再散列等。二次探测消除了线性探测的聚集问题，这种聚集问题叫做原始聚集</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ThreadLocal-20230822203134.png" alt="img"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ThreadLocal-20230822203306.png" alt="img"></p>
</li>
<li><p><strong>再哈希法</strong>：当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p>
</li>
</ul>
<h2 id="哈希应用"><a href="#哈希应用" class="headerlink" title="哈希应用"></a>哈希应用</h2><ul>
<li><strong>哈希表</strong>：用于快速存储和查找数据，常用的数据结构之一。</li>
<li><strong>数据完整性</strong>：验证数据的完整性，如文件校验和。</li>
<li><strong>密码学</strong>：生成数据的“指纹”，用于验证用户密码、数字签名等。</li>
</ul>
<h2 id="哈希函数的常见算法"><a href="#哈希函数的常见算法" class="headerlink" title="哈希函数的常见算法"></a>哈希函数的常见算法</h2><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p><strong><a href="https://zh.wikipedia.org/wiki/MD5">MD5消息摘要算法</a><strong>（英语：</strong>MD5 Message-Digest Algorithm</strong>），一种被广泛使用的<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8">密码散列函数</a>，可以产生出一个128位（16个<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82">字节</a>）的<a href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97">散列</a>值（hash value），用于确保信息传输完整一致。曾被用于文件校验、<a href="https://zh.wikipedia.org/wiki/SSL">SSL</a>/<a href="https://zh.wikipedia.org/wiki/TLS">TLS</a>、<a href="https://zh.wikipedia.org/wiki/IPsec">IPsec</a>、<a href="https://zh.wikipedia.org/wiki/Secure_Shell">SSH</a></p>
<p><a href="https://cloud.tencent.com/developer/article/2404002">深入解析MD5哈希算法：原理、应用与安全性-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/37257569">MD5算法 - 知乎 (zhihu.com)</a></p>
<ul>
<li>将报文按模2^64^取余，追加在报文后面</li>
<li>在报文和余数之间填充若干位，使得总长度为512的整数倍，第一位是1其他位是0</li>
<li>按照512位一块，分成若干块，分割之后再把每块分成4个128位的数据块，送到4个不同的哈希函数进行4轮计算，每一轮按照32位的小块进行运算，一直到最后计算出MD5报文摘要代码。</li>
</ul>
<h3 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h3><p><strong><a href="https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F">安全散列算法</a><strong>（英语：</strong>Secure Hash Algorithm</strong>，缩写为<strong>SHA</strong>）是一个<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8">密码散列函数</a>家族，是<a href="https://zh.wikipedia.org/wiki/%E8%81%94%E9%82%A6%E8%B5%84%E6%96%99%E5%A4%84%E7%90%86%E6%A0%87%E5%87%86">FIPS</a>所认证的安全<a href="https://zh.wikipedia.org/wiki/%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8">散列算法</a>。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。且若输入的消息不同，它们对应到不同字符串的几率很高。</p>
<p><a href="https://www.freebuf.com/news/351438.html">什么是 SHA 加密？ SHA-1 与 SHA-2 - FreeBuf网络安全行业门户</a></p>
<h3 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h3><p><strong><a href="https://zh.wikipedia.org/zh-cn/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97">循环冗余校验</a><strong>（英语：</strong>Cyclic redundancy check</strong>，通称“<strong>CRC</strong>”）是一种根据网络数据包或<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E6%AA%94%E6%A1%88">电脑文件</a>等数据产生简短固定位数校验码的一种<a href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">散列函数</a>，主要用来检测或校验数据传输或者保存后可能出现的错误。生成的数字在传输或者存储之前计算出来并且附加到数据后面，然后接收方进行检验确定数据是否发生变化。</p>
<p><a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/CRC.html">什么是CRC（Cyclic Redundancy Check）？如何解决CRC错误？ - 华为 (huawei.com)</a></p>
<p><a href="https://zh.wikipedia.org/zh-cn/%E6%A0%A1%E9%AA%8C%E5%92%8C">校验和 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<h3 id="分布式哈希算法—服务节点集群、DHT"><a href="#分布式哈希算法—服务节点集群、DHT" class="headerlink" title="分布式哈希算法—服务节点集群、DHT"></a>分布式哈希算法—服务节点集群、DHT</h3><p><strong>分布式哈希函数</strong>：用于负载均衡和分布式存储，如一致性哈希。</p>
<h4 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h4><p><a href="https://blog.csdn.net/a745233700/article/details/120814088">一致性哈希算法原理详解-CSDN博客</a> </p>
<p>如果简单的用服务器数量取模来进行负载均衡，一旦新增或者故障移除使服务器数变化，就会导致同一个key，一开始存储在A服务器上，数量变化后，去B服务器查询，也就是被分配到了与之前不同的服务器上，导致缓存大量失效，缓存失效的根本原因是：普通哈希算法的映射规则与节点数量高度耦合，导致节点数量变化时，几乎所有数据的映射关系都会变动。因此，之前缓存的绝大部分数据都会失效，无法在原有的缓存节点上找到，导致缓存命中率急剧下降。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/7903f62393641e5f3cafa28b059321b6.png" alt="取模" style="zoom: 75%;" />

<ul>
<li><p>一致性哈希通过对2^32^取模，将各个服务器进行哈希，分配到哈希环上，可以使用IP地址或者主机名哈希</p>
</li>
<li><p>把数据key也分配到哈希环上面，然后顺时针寻找离自己最近的服务器（哈希值）</p>
</li>
</ul>
<p>如下图所示，一台服务器挂了，不会影响到它之后的key，最小化缓存失效的影响</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111180255460.png" alt="image-20241111180255460"></p>
<h5 id="哈希环倾斜—虚拟节点"><a href="#哈希环倾斜—虚拟节点" class="headerlink" title="哈希环倾斜—虚拟节点"></a>哈希环倾斜—虚拟节点</h5><p>如下图所示，服务器节点较少，导致大部分key都缓存在A服务器上，数据分布不均匀，削弱了负载均衡的效果</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111180439707.png" alt="image-20241111180439707" style="zoom:50%;" />

<p>还有一种情况，节点数过少，只有AB</p>
<p>为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点，一个实际物理节点可以对应多个虚拟节点，虚拟节点越多，hash环上的节点就越多，缓存被均匀分布的概率就越大，hash环倾斜所带来的影响就越小，同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射。一个节点挂掉不至于将所有请求打到另一个节点上导致连续崩溃，起到负载均衡的作用。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111180905461.png" alt="image-20241111180905461" style="zoom:50%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2084611-20220527090607907-112778299.png" alt="img" style="zoom: 80%;" />



<h5 id="应用：DHT"><a href="#应用：DHT" class="headerlink" title="应用：DHT"></a>应用：DHT</h5><p>DHT 将<strong>键值对 (key-value)</strong> 存储在多个分布式节点中，通过哈希函数映射键值到节点位置，实现快速查找和存储。</p>
<ul>
<li>**键 (Key)**：唯一标识数据项的标记。</li>
<li>**值 (Value)**：存储的实际数据或其引用。</li>
<li><strong>哈希函数</strong>：将键映射到固定长度的哈希值，用于定位数据。</li>
</ul>
<p>DHT 使用<strong>一致性哈希算法</strong>（Consistent Hashing）将节点和数据映射到一个<strong>哈希环</strong>上，确保节点的加入或退出只影响少量数据的重新分布。</p>
<p><strong>存储数据</strong>：</p>
<ul>
<li>数据通过哈希函数生成键，例如 <code>hash(key)</code>。</li>
<li>键定位到负责存储的节点。</li>
</ul>
<p><strong>查找数据</strong>：</p>
<ul>
<li>查询方根据相同哈希规则计算键的哈希值，找到对应节点。</li>
<li>请求直接或逐步（路由）传递到存储数据的节点。</li>
</ul>
<p><strong>节点变化处理</strong>：</p>
<ul>
<li>新节点加入：重新分配部分数据给新节点。</li>
<li>节点退出：其数据重新分配到其他节点上，保证冗余备份和数据一致性。</li>
</ul>
<p>应用：</p>
<p><strong>P2P 网络</strong>：</p>
<ul>
<li>BitTorrent 使用 DHT 寻找资源和共享文件。</li>
<li>Kad 网络（eMule）基于 Kademlia 算法实现。</li>
</ul>
<p><strong>分布式缓存</strong>：</p>
<ul>
<li>Cassandra、DynamoDB 等分布式数据库利用 DHT 进行数据分布和一致性维护。</li>
</ul>
<p><strong>区块链和去中心化存储</strong>：</p>
<ul>
<li>IPFS（InterPlanetary File System）利用 DHT 定位文件存储位置。</li>
</ul>
<p><strong>分布式文件系统</strong>：</p>
<ul>
<li>Chord、Pastry、Tapestry 等协议用于存储和检索分布式文件。</li>
</ul>
<p><strong>Chord</strong>：环形结构，使用一致性哈希算法，支持动态节点增减。</p>
<p><strong>Kademlia</strong>：基于二叉树的路由协议，用于 eMule 和 BitTorrent。</p>
<p><strong>Pastry</strong>：支持高效查找和动态扩展，适用于大型网络。</p>
<p><strong>Tapestry</strong>：与 Pastry 类似，优化了搜索路径和延迟控制。</p>
<h4 id="哈希插槽"><a href="#哈希插槽" class="headerlink" title="哈希插槽"></a>哈希插槽</h4><p>详见redis cluster的哈希插槽实现</p>
<h2 id="应用：哈希表"><a href="#应用：哈希表" class="headerlink" title="应用：哈希表"></a>应用：哈希表</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8">散列表 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p>哈希表在大多数实现中，本质上是<strong>一个大数组</strong>，其中每个元素称为<strong>桶（bucket）</strong>。在这个大数组的基础上，通过哈希函数将键映射到数组的索引位置来存储和查找数据。</p>
<p>本质还是一个数组，但是数组的角标和键挂钩，在数组角标位置存储值，根据键就能很快找到对应的索引。</p>
<h3 id="哈希表的实现原理"><a href="#哈希表的实现原理" class="headerlink" title="哈希表的实现原理"></a>哈希表的实现原理</h3><ol>
<li><p><strong>一个大数组</strong>：哈希表的核心数据结构是一个数组，用于存储数据的位置。每个数组元素可以直接存储数据（若无冲突）或指向链表、红黑树等其他结构（若发生冲突）。</p>
</li>
<li><p><strong>数组中的每个元素即为一个桶</strong>：</p>
<ul>
<li>当多个键的哈希值映射到同一个索引位置（即哈希冲突）时，这个位置的元素会作为桶的“起点”，桶内部可以使用链表或树结构来存储多个值。</li>
<li>在 JDK 的 <code>HashMap</code> 中，每个桶初始是一个链表，当冲突元素超过一定数量时，该桶会从链表转换为红黑树结构，以提升查找效率。</li>
</ul>
</li>
<li><p><strong>桶数组的大小</strong>：一般是固定大小或者按需扩容。例如，Java 中的 <code>HashMap</code> 会在达到一定负载因子后（通常为 0.75）自动扩容，将原数组容量扩大一倍。这相当于增加了存储空间，从而减小了发生冲突的概率。</p>
</li>
</ol>
<h3 id="多数组的情况"><a href="#多数组的情况" class="headerlink" title="多数组的情况"></a>多数组的情况</h3><p>一般情况下，哈希表只使用一个数组来存储桶。但在一些特殊的场景下，可能会用到多个数组：</p>
<ul>
<li><strong>分布式哈希表（DHT）</strong>：在分布式系统中，数据分布在不同的服务器上，可以视作多个“数组”分布在不同节点上。</li>
<li><strong>分区哈希表</strong>：在特定应用场景中，有时会对哈希表进行分区，每个分区对应一个独立的数组，以实现分片存储或负载均衡。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在常见的哈希表实现（如 <code>HashMap</code>）中，通常是<strong>一个大数组</strong>来管理桶，在冲突发生时每个桶内可能使用链表或红黑树等结构存储多个值。</p>
<h3 id="JDK-HashMap"><a href="#JDK-HashMap" class="headerlink" title="JDK HashMap"></a>JDK HashMap</h3><p>是的，<code>HashMap</code> 是基于哈希实现的。在 JDK 的 <code>HashMap</code> 中，底层实现利用了<strong>数组 + 链表 + 红黑树</strong>的结构来存储键值对。其主要原理包括以下几个关键步骤：</p>
<h4 id="哈希计算"><a href="#哈希计算" class="headerlink" title="哈希计算"></a>哈希计算</h4><p><code>HashMap</code> 使用键的 <code>hashCode()</code> 方法来计算哈希值。计算哈希值后，会进一步通过位运算来<strong>优化分布</strong>，从而减少哈希冲突。具体来说，<code>HashMap</code> 会对哈希值进行一次扰动处理，使得高位和低位信息更加均匀地影响到数组索引。</p>
<p>例如，在 JDK 8 中使用了以下计算方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组索引映射"><a href="#数组索引映射" class="headerlink" title="数组索引映射"></a>数组索引映射</h4><p><code>HashMap</code> 的底层是一个<strong>数组</strong>，称为<strong>桶数组</strong>。通过 <code>(n - 1) &amp; hash</code> 的操作，哈希值被映射到数组的某个索引位置（其中 <code>n</code> 是桶数组的长度，且 <code>n</code> 始终为 2 的幂）。这种位运算的方式比取模运算更加高效。</p>
<h4 id="处理哈希冲突"><a href="#处理哈希冲突" class="headerlink" title="处理哈希冲突"></a>处理哈希冲突</h4><p>如果多个键的哈希值映射到了相同的数组索引（即发生哈希冲突），<code>HashMap</code> 会在该索引处使用<strong>链表</strong>或<strong>红黑树</strong>来存储这些冲突的键值对。</p>
<ul>
<li><strong>链表</strong>：在 JDK 8 及之前，当冲突的键较少时，<code>HashMap</code> 使用链表将冲突的键连接起来。链表的插入操作简单，但是查找速度是 <code>O(n)</code>。</li>
<li><strong>红黑树</strong>：在 JDK 8 中，如果某个桶中的元素数量超过一定阈值（默认是 8），链表会转化为<strong>红黑树</strong>结构，从而提升查找效率至 <code>O(log n)</code>。</li>
</ul>
<h4 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h4><p>当 <code>HashMap</code> 的负载因子（元素个数 / 数组容量）超过某个阈值（默认是 0.75），<code>HashMap</code> 会<strong>进行扩容</strong>。扩容会将桶数组的大小扩大为原来的两倍，并重新分配所有元素的位置。这一过程称为<strong>rehash</strong>，它会重新计算所有键的索引，以减少哈希冲突。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>JDK 中的 <code>HashMap</code> 是通过哈希函数来计算键的哈希值，并将其映射到数组的索引。遇到冲突时，采用链表或红黑树存储方式，并通过动态扩容和重哈希来保证存取效率。</p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><h4 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h4><p>当你往简单数组或列表中插入新数据时，将不会根据插入项的值来确定该插入项的索引值。这意味着新插入项的索引值与数据值之间没有直接关系。这样的话，当你需要在数组或列表中搜索相应值的时候，你必须遍历已有的集合。若集合中存在大量的数据，就会影响数据查找的效率。</p>
<p>针对这个问题，你可以考虑使用哈希表。<strong>利用哈希表你可以通过对 “值” 进行哈希处理来获得该值对应的键或索引值</strong>，然后把该值存放到列表中对应的索引位置。这意味着索引值是由插入项的值所确定的，当你需要判断列表中是否存在该值时，只需要对值进行哈希处理并在相应的索引位置进行搜索即可，这时的搜索速度是非常快的。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/v2-ba324df953f121b077f7bdc2a6109f0a_r.jpg"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111133002751.png" alt="image-20241111133002751"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111133015151.png" alt="image-20241111133015151"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111133059526.png" alt="image-20241111133059526"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111133111464.png" alt="image-20241111133111464"></p>
<p>插入数据时顺便将数据键添加进布隆过滤器中，会根据n个哈希函数计算出n个索引，随后将这些索引位置1，因为哈希函数存在碰撞的可能，所以要计算出多个哈希值，图中使用了3个哈希值，fullstack和semlinker出现了完全重复，这就导致了误判。</p>
<p><strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在</strong> </p>
<p>如果哈希运算后任何一个索引位为0，则肯定不存在，否则可能存在</p>
<h4 id="误判率"><a href="#误判率" class="headerlink" title="误判率"></a>误判率</h4><p>幸运的是，布隆过滤器有一个可预测的误判率（FPP）：</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111133418275.png" alt="image-20241111133418275" style="zoom: 33%;" />

<ul>
<li>n 是已经添加元素的数量；</li>
<li>k 哈希的次数；</li>
<li>m 布隆过滤器的长度（如比特数组的大小）；</li>
</ul>
<p>极端情况下，当布隆过滤器没有空闲空间时（满），每一次查询都会返回 true 。这也就意味着 m 的选择取决于期望预计添加元素的数量 n ，并且 m 需要远远大于 n 。</p>
<h4 id="最佳实践：Guava"><a href="#最佳实践：Guava" class="headerlink" title="最佳实践：Guava"></a>最佳实践：Guava</h4><p>guava的布隆过滤器直接使用即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建布隆过滤器对象</span></span><br><span class="line">BloomFilter&lt;Integer&gt; filter = BloomFilter.create(</span><br><span class="line">    Funnels.integerFunnel(),</span><br><span class="line">    <span class="number">1500</span>,</span><br><span class="line">    <span class="number">0.01</span>);</span><br><span class="line"><span class="comment">// 判断指定元素是否存在</span></span><br><span class="line">System.out.println(filter.mightContain(<span class="number">1</span>));</span><br><span class="line">System.out.println(filter.mightContain(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 将元素添加进布隆过滤器</span></span><br><span class="line">filter.put(<span class="number">1</span>);</span><br><span class="line">filter.put(<span class="number">2</span>);</span><br><span class="line">System.out.println(filter.mightContain(<span class="number">1</span>));</span><br><span class="line">System.out.println(filter.mightContain(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>一致性哈希</tag>
        <tag>布隆过滤器</tag>
        <tag>哈希插槽</tag>
      </tags>
  </entry>
  <entry>
    <title>ClassFile</title>
    <url>/2024/09/13/classfile/</url>
    <content><![CDATA[<h1 id="ClassFile-字节码"><a href="#ClassFile-字节码" class="headerlink" title="ClassFile 字节码"></a>ClassFile 字节码</h1><p>Java 字节码是 Java 编译器将 Java 源代码编译成的 <strong>中间表示格式</strong>，它运行在 <strong>Java 虚拟机（JVM）</strong> 上。Java 字节码文件的扩展名为 <code>.class</code>，可以通过 <code>javap -c</code> 命令查看其内容。</p>
<p>任何一个Class文件都对应着唯一的一个类或接口的定义信息[1]，但是反过来说，类或 接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。本章中， 笔者只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”，实际上它完全不 需要以磁盘文件的形式存在。</p>
<p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文 件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数 据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[2]的方式分割 成若干个8个字节进行存储。</p>
<span id="more"></span>

<h2 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h2><p><strong>示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BytecodeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译和查看字节码指令</strong> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javac BytecodeExample.java</span><br><span class="line">javap -c BytecodeExample</span><br><span class="line"><span class="comment"># 打印类中每个方法的反汇编代码，例如组成 Java 字节码的指令。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteCodeExample</span> &#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> MAX;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ByteCodeExample</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iload_0</span><br><span class="line">       <span class="number">1</span>: iload_1</span><br><span class="line">       <span class="number">2</span>: iadd</span><br><span class="line">       <span class="number">3</span>: ireturn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_2</span><br><span class="line">       <span class="number">1</span>: iconst_3</span><br><span class="line">       <span class="number">2</span>: invokestatic  #<span class="number">7</span>                  <span class="comment">// Method add:(II)I</span></span><br><span class="line">       <span class="number">5</span>: istore_1</span><br><span class="line">       <span class="number">6</span>: getstatic     #<span class="number">13</span>                 <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">9</span>: iload_1</span><br><span class="line">      <span class="number">10</span>: invokevirtual #<span class="number">19</span>                 <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">      <span class="number">13</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节码指令解释"><a href="#字节码指令解释" class="headerlink" title="字节码指令解释"></a><span id="code">字节码指令解释</span></h3><h4 id="构造方法：BytecodeExample"><a href="#构造方法：BytecodeExample" class="headerlink" title="构造方法：BytecodeExample()"></a>构造方法：BytecodeExample()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ByteCodeExample</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0           <span class="comment">// 将 this 引用加载到操作数栈</span></span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>			<span class="comment">// 返回</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：自动生成的默认构造函数，调用 <code>Object</code> 的构造函数。</p>
<h4 id="add-方法：add-int-int"><a href="#add-方法：add-int-int" class="headerlink" title="add 方法：add(int, int)"></a>add 方法：add(int, int)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iload_0              <span class="comment">// 加载第一个参数 a</span></span><br><span class="line">       <span class="number">1</span>: iload_1              <span class="comment">// 加载第二个参数 b</span></span><br><span class="line">       <span class="number">2</span>: iadd                 <span class="comment">// 执行整数相加</span></span><br><span class="line">       <span class="number">3</span>: ireturn              <span class="comment">// 返回结果</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：</p>
<ol>
<li><code>iload_0</code>、<code>iload_1</code>：将参数加载到操作数栈。</li>
<li><code>iadd</code>：弹出栈顶两个整数并执行加法运算，再将结果压入栈顶。</li>
<li><code>ireturn</code>：将栈顶的结果返回给调用者。</li>
</ol>
<h4 id="main-方法：main-String"><a href="#main-方法：main-String" class="headerlink" title="main 方法：main(String[])"></a>main 方法：main(String[])</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_2           <span class="comment">// 将常量 2 压入栈</span></span><br><span class="line">       <span class="number">1</span>: iconst_3           <span class="comment">// 将常量 3 压入栈</span></span><br><span class="line">       <span class="number">2</span>: invokestatic  #<span class="number">7</span>   <span class="comment">// 调用静态方法 add(2, 3)</span></span><br><span class="line">       <span class="number">5</span>: istore_1           <span class="comment">// 将结果保存到局部变量表中的索引 1</span></span><br><span class="line">       <span class="number">6</span>: getstatic     #<span class="number">13</span>  <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">9</span>: iload_1            <span class="comment">// 加载变量 result</span></span><br><span class="line">      <span class="number">10</span>: invokevirtual #<span class="number">19</span>  <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br><span class="line">      <span class="number">13</span>: <span class="keyword">return</span>             <span class="comment">// 结束 main 方法</span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><code>iconst_2</code> 和 <code>iconst_3</code>：将常量 2 和 3 压入栈顶。</li>
<li><code>invokestatic</code>：调用静态方法 <code>add</code>，返回结果并压入栈顶。</li>
<li><code>istore_1</code>：将结果存入局部变量表的索引 1（变量 result）。</li>
<li><code>getstatic</code>：加载 <code>System.out</code> 对象到栈顶，用于后续方法调用。</li>
<li><code>invokevirtual</code>：调用 <code>println</code> 方法打印结果。</li>
</ul>
<h3 id="常见字节码指令表"><a href="#常见字节码指令表" class="headerlink" title="常见字节码指令表"></a>常见字节码指令表</h3><table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>aload_x</strong></td>
<td>将引用变量加载到操作数栈</td>
</tr>
<tr>
<td><strong>iload_x</strong></td>
<td>将 int 型变量加载到操作数栈</td>
</tr>
<tr>
<td><strong>istore_x</strong></td>
<td>将 int 型值从栈顶存入局部变量表</td>
</tr>
<tr>
<td><strong>iconst_x</strong></td>
<td>将常量 x 压入操作数栈</td>
</tr>
<tr>
<td><strong>iadd</strong></td>
<td>执行整数加法</td>
</tr>
<tr>
<td><strong>isub</strong></td>
<td>执行整数减法</td>
</tr>
<tr>
<td><strong>invokestatic</strong></td>
<td>调用静态方法</td>
</tr>
<tr>
<td><strong>invokevirtual</strong></td>
<td>调用对象的实例方法</td>
</tr>
<tr>
<td><strong>return</strong></td>
<td>方法结束，返回 void</td>
</tr>
<tr>
<td><strong>ireturn</strong></td>
<td>方法结束，返回 int 值</td>
</tr>
</tbody></table>
<h2 id="class-文件结构-ClassFile"><a href="#class-文件结构-ClassFile" class="headerlink" title=".class 文件结构(ClassFile)"></a>.class 文件结构(ClassFile)</h2><p>ClassFile 结构定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;<span class="comment">// first 4 bytes of the file must be 0xCAFEBABE</span></span><br><span class="line">    u2             minor_version;<span class="comment">// 次版本号                        2 bytes</span></span><br><span class="line">    u2             major_version;<span class="comment">// 主版本号 比如 JDK 21 对应 65.0   2 bytes </span></span><br><span class="line">    </span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量 2 bytes</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    </span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记   </span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    </span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口数量</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//字段数量</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/16d5ec47609818fc.jpeg" alt="ClassFile 内容分析"></p>
<h3 id="常量池-cp-info-constant-pool-constant-pool-count-1"><a href="#常量池-cp-info-constant-pool-constant-pool-count-1" class="headerlink" title="常量池 cp_info constant_pool[constant_pool_count-1]"></a>常量池 <code>cp_info constant_pool[constant_pool_count-1]</code></h3><p>常量池是 ClassFile 的核心，存储类的常量信息，如字符串、字段名、方法名和方法描述符等。</p>
<p>计数器 constant_pool_count 表示常量池项的数量（从 1 开始计数）。（<strong>常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”</strong>）。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">cp_info <span class="punctuation">&#123;</span></span><br><span class="line">    u1 tag;                  <span class="comment">// 常量类型标志      1 byte</span></span><br><span class="line">    u1 info<span class="punctuation">[</span><span class="punctuation">]</span>;               <span class="comment">// 常量值或引用      1 byte</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">标志（tag）</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CONSTANT_utf8_info</td>
<td align="center">1</td>
<td align="center">UTF-8 编码的字符串</td>
</tr>
<tr>
<td align="center">CONSTANT_Integer_info</td>
<td align="center">3</td>
<td align="center">整形字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Float_info</td>
<td align="center">4</td>
<td align="center">浮点型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Long_info</td>
<td align="center">5</td>
<td align="center">长整型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Double_info</td>
<td align="center">6</td>
<td align="center">双精度浮点型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Class_info</td>
<td align="center">7</td>
<td align="center">类或接口的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_String_info</td>
<td align="center">8</td>
<td align="center">字符串类型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_FieldRef_info</td>
<td align="center">9</td>
<td align="center">字段的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodRef_info</td>
<td align="center">10</td>
<td align="center">类中方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_InterfaceMethodRef_info</td>
<td align="center">11</td>
<td align="center">接口中方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_NameAndType_info</td>
<td align="center">12</td>
<td align="center">字段或方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodType_info</td>
<td align="center">16</td>
<td align="center">标志方法类型</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodHandle_info</td>
<td align="center">15</td>
<td align="center">表示方法句柄</td>
</tr>
<tr>
<td align="center">CONSTANT_InvokeDynamic_info</td>
<td align="center">18</td>
<td align="center">表示一个动态方法调用点</td>
</tr>
</tbody></table>
<h3 id="类访问标志-access-flags"><a href="#类访问标志-access-flags" class="headerlink" title="类访问标志 access flags"></a>类访问标志 <code>access flags</code></h3><p>定义类或接口的修饰符：</p>
<table>
<thead>
<tr>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0x0001 (ACC_PUBLIC)</td>
<td>公共类。</td>
</tr>
<tr>
<td>0x0010 (ACC_FINAL)</td>
<td>不可继承（final）。</td>
</tr>
<tr>
<td>0x0020 (ACC_SUPER)</td>
<td>支持 invokespecial。</td>
</tr>
<tr>
<td>0x0200 (ACC_INTERFACE)</td>
<td>接口。</td>
</tr>
<tr>
<td>0x0400 (ACC_ABSTRACT)</td>
<td>抽象类或接口。</td>
</tr>
<tr>
<td>0x1000 (ACC_SYNTHETIC)</td>
<td>编译器自动生成的类或方法。</td>
</tr>
<tr>
<td>0x2000 (ACC_ANNOTATION)</td>
<td>注解类。</td>
</tr>
<tr>
<td>0x4000 (ACC_ENUM)</td>
<td>枚举类。</td>
</tr>
</tbody></table>
<h3 id="当前类和父类的索引-this-class-super-class"><a href="#当前类和父类的索引-this-class-super-class" class="headerlink" title="当前类和父类的索引 this_class super_class"></a>当前类和父类的索引 <code>this_class</code> <code>super_class</code></h3><ul>
<li><strong>this_class</strong> 指向当前类在常量池中的索引，描述类名。</li>
<li>super_class 指向父类的索引。<ul>
<li>如果父类是 <code>java.lang.Object</code>，其值为 0。</li>
</ul>
</li>
</ul>
<h4 id="接口索引集合-interfaces-interface-count"><a href="#接口索引集合-interfaces-interface-count" class="headerlink" title="接口索引集合 interfaces[interface_count]"></a>接口索引集合 <code>interfaces[interface_count]</code></h4><p>接口索引集合用来描述这个类实现了哪些接口，这些被实现的接口将按 <code>implements</code> (如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</p>
<h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><h4 id="字段集合-field-info-fields-fields-count"><a href="#字段集合-field-info-fields-fields-count" class="headerlink" title="字段集合 field_info fields[fields_count]"></a>字段集合 <code>field_info fields[fields_count]</code></h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">field_info <span class="punctuation">&#123;</span></span><br><span class="line">    u2 access_flags;       <span class="comment">// 访问标志字段的作用域（public ,private,protected修饰符），是实例变量还是类变量（static修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</span></span><br><span class="line">    u2 name_index;         <span class="comment">// 字段名称 对常量池的引用</span></span><br><span class="line">    u2 descriptor_index;   <span class="comment">// 描述符 对常量池的引用</span></span><br><span class="line">    u2 attributes_count;   <span class="comment">// 属性计数器</span></span><br><span class="line">    attribute_info attributes<span class="punctuation">[</span><span class="punctuation">]</span>; <span class="comment">// 属性表</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p>
<p>字段的访问标志位：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20201031084342859.png" alt="字段的 access_flag 的取值"></p>
<h4 id="方法表-method-info-methods-methods-count"><a href="#方法表-method-info-methods-methods-count" class="headerlink" title="方法表 method_info methods[methods_count]"></a>方法表 <code>method_info methods[methods_count]</code></h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">method_info <span class="punctuation">&#123;</span></span><br><span class="line">    u2 access_flags;       <span class="comment">// </span></span><br><span class="line">    u2 name_index;         <span class="comment">// 方法名 对常量池的引用</span></span><br><span class="line">    u2 descriptor_index;   <span class="comment">// 描述符 对常量池的引用</span></span><br><span class="line">    u2 attributes_count;   <span class="comment">// 属性计数器</span></span><br><span class="line">    attribute_info attributes<span class="punctuation">[</span><span class="punctuation">]</span>; <span class="comment">// 属性表</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意：因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p>
<p>方法的访问标志位：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20201031084248965.png" alt="方法表的 access_flag 取值"></p>
<h4 id="属性表-attribute-info-attributes-attributes-count"><a href="#属性表-attribute-info-attributes-attributes-count" class="headerlink" title="属性表 attribute_info attributes[attributes_count]"></a>属性表 <code>attribute_info attributes[attributes_count]</code></h4><p>存储与类、字段或方法相关的附加信息，如注解、调试信息等。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Code</td>
<td>存储方法的字节码指令。</td>
</tr>
<tr>
<td>ConstantValue</td>
<td>常量值属性（如 static final 常量）。</td>
</tr>
<tr>
<td>LineNumberTable</td>
<td>行号表，用于调试信息映射源代码行。</td>
</tr>
<tr>
<td>SourceFile</td>
<td>源文件名属性，用于调试信息。</td>
</tr>
<tr>
<td>Exceptions</td>
<td>方法抛出的异常信息。</td>
</tr>
<tr>
<td>LocalVariableTable</td>
<td>方法中局部变量的信息（调试用途）。</td>
</tr>
<tr>
<td>Deprecated</td>
<td>标记类、方法或字段为废弃。</td>
</tr>
</tbody></table>
<p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p>
<p>比如在上文<a href="#code">字节码指令解释</a>的部分，方法的Code属性就是字节码指令</p>
<h2 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">javap -verbose BytecodeExample <span class="comment">// 打印有关所选类别的附加信息</span></span><br><span class="line"></span><br><span class="line">Classfile /C<span class="punctuation">:</span>/Users/Lenovo/Desktop/coding/JavaSingle/BytecodeExample.class</span><br><span class="line">  Last modified <span class="number">2025</span>年<span class="number">1</span>月<span class="number">3</span>日; size <span class="number">555</span> bytes</span><br><span class="line">  SHA<span class="number">-256</span> checksum <span class="number">2</span>ade518b0d7194939efe9f3eefc0d055e21b70bab639130f050bc35282fa976b</span><br><span class="line">  Compiled from <span class="string">&quot;ByteCodeExample.java&quot;</span></span><br><span class="line">public class ByteCodeExample</span><br><span class="line">  minor version<span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  major version<span class="punctuation">:</span> <span class="number">65</span></span><br><span class="line">  flags<span class="punctuation">:</span> (<span class="number">0x0021</span>) ACC_PUBLIC<span class="punctuation">,</span> ACC_SUPER</span><br><span class="line">  this_class<span class="punctuation">:</span> #<span class="number">8</span>                          <span class="comment">// ByteCodeExample</span></span><br><span class="line">  super_class<span class="punctuation">:</span> #<span class="number">2</span>                         <span class="comment">// java/lang/Object</span></span><br><span class="line">  interfaces<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="comment">// 实现了0个接口</span></span><br><span class="line">  fields<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span>    <span class="comment">// 有3个字段 （成员变量）</span></span><br><span class="line">  methods<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span>  <span class="comment">// 有3个方法</span></span><br><span class="line">  attributes<span class="punctuation">:</span> <span class="number">1</span>  </span><br><span class="line">Constant pool<span class="punctuation">:</span></span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">2.</span>#<span class="number">3</span>          <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">4</span>             <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">3</span> = NameAndType        #<span class="number">5</span><span class="punctuation">:</span>#<span class="number">6</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">4</span> = Utf8               java/lang/Object</span><br><span class="line">   #<span class="number">5</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">6</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">8.</span>#<span class="number">9</span>          <span class="comment">// ByteCodeExample.add:(II)I</span></span><br><span class="line">   #<span class="number">8</span> = Class              #<span class="number">10</span>            <span class="comment">// ByteCodeExample</span></span><br><span class="line">   #<span class="number">9</span> = NameAndType        #<span class="number">11</span><span class="punctuation">:</span>#<span class="number">12</span>        <span class="comment">// add:(II)I</span></span><br><span class="line">  #<span class="number">10</span> = Utf8               ByteCodeExample</span><br><span class="line">  #<span class="number">11</span> = Utf8               add</span><br><span class="line">  #<span class="number">12</span> = Utf8               (II)I</span><br><span class="line">  #<span class="number">13</span> = Fieldref           #<span class="number">14.</span>#<span class="number">15</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">14</span> = Class              #<span class="number">16</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">15</span> = NameAndType        #<span class="number">17</span><span class="punctuation">:</span>#<span class="number">18</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">16</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">17</span> = Utf8               out</span><br><span class="line">  #<span class="number">18</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">19</span> = Methodref          #<span class="number">20.</span>#<span class="number">21</span>        <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br><span class="line">  #<span class="number">20</span> = Class              #<span class="number">22</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">21</span> = NameAndType        #<span class="number">23</span><span class="punctuation">:</span>#<span class="number">24</span>        <span class="comment">// println:(I)V</span></span><br><span class="line">  #<span class="number">22</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">23</span> = Utf8               println</span><br><span class="line">  #<span class="number">24</span> = Utf8               (I)V</span><br><span class="line">  #<span class="number">25</span> = Utf8               a</span><br><span class="line">  #<span class="number">26</span> = Utf8               I</span><br><span class="line">  #<span class="number">27</span> = Utf8               b</span><br><span class="line">  #<span class="number">28</span> = Utf8               MAX</span><br><span class="line">  #<span class="number">29</span> = Utf8               D</span><br><span class="line">  #<span class="number">30</span> = Utf8               ConstantValue</span><br><span class="line">  #<span class="number">31</span> = Double             <span class="number">12.0</span>d</span><br><span class="line">  #<span class="number">33</span> = Utf8               Code</span><br><span class="line">  #<span class="number">34</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">35</span> = Utf8               main</span><br><span class="line">  #<span class="number">36</span> = Utf8               (<span class="punctuation">[</span>Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">37</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">38</span> = Utf8               ByteCodeExample.java</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  int a;</span><br><span class="line">    descriptor<span class="punctuation">:</span> I</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0000</span>)</span><br><span class="line"></span><br><span class="line">  int b;</span><br><span class="line">    descriptor<span class="punctuation">:</span> I</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0000</span>)</span><br><span class="line"></span><br><span class="line">  public static final double MAX;</span><br><span class="line">    descriptor<span class="punctuation">:</span> D</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0019</span>) ACC_PUBLIC<span class="punctuation">,</span> ACC_STATIC<span class="punctuation">,</span> ACC_FINAL</span><br><span class="line">    ConstantValue<span class="punctuation">:</span> double <span class="number">12.0</span>d</span><br><span class="line"></span><br><span class="line">  public ByteCodeExample();</span><br><span class="line">    descriptor<span class="punctuation">:</span> ()V</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code<span class="punctuation">:</span></span><br><span class="line">      stack=<span class="number">1</span><span class="punctuation">,</span> locals=<span class="number">1</span><span class="punctuation">,</span> args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span><span class="punctuation">:</span> aload_0</span><br><span class="line">         <span class="number">1</span><span class="punctuation">:</span> invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span><span class="punctuation">:</span> return</span><br><span class="line">      LineNumberTable<span class="punctuation">:</span></span><br><span class="line">        line <span class="number">1</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  public static int add(int<span class="punctuation">,</span> int);</span><br><span class="line">    descriptor<span class="punctuation">:</span> (II)I</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0009</span>) ACC_PUBLIC<span class="punctuation">,</span> ACC_STATIC</span><br><span class="line">    Code<span class="punctuation">:</span></span><br><span class="line">      stack=<span class="number">2</span><span class="punctuation">,</span> locals=<span class="number">2</span><span class="punctuation">,</span> args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span><span class="punctuation">:</span> iload_0</span><br><span class="line">         <span class="number">1</span><span class="punctuation">:</span> iload_1</span><br><span class="line">         <span class="number">2</span><span class="punctuation">:</span> iadd</span><br><span class="line">         <span class="number">3</span><span class="punctuation">:</span> ireturn</span><br><span class="line">      LineNumberTable<span class="punctuation">:</span></span><br><span class="line">        line <span class="number">6</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String<span class="punctuation">[</span><span class="punctuation">]</span>);</span><br><span class="line">    descriptor<span class="punctuation">:</span> (<span class="punctuation">[</span>Ljava/lang/String;)V</span><br><span class="line">    flags<span class="punctuation">:</span> (<span class="number">0x0009</span>) ACC_PUBLIC<span class="punctuation">,</span> ACC_STATIC</span><br><span class="line">    Code<span class="punctuation">:</span></span><br><span class="line">      stack=<span class="number">2</span><span class="punctuation">,</span> locals=<span class="number">2</span><span class="punctuation">,</span> args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span><span class="punctuation">:</span> iconst_2</span><br><span class="line">         <span class="number">1</span><span class="punctuation">:</span> iconst_3</span><br><span class="line">         <span class="number">2</span><span class="punctuation">:</span> invokestatic  #<span class="number">7</span>                  <span class="comment">// Method add:(II)I</span></span><br><span class="line">         <span class="number">5</span><span class="punctuation">:</span> istore_1</span><br><span class="line">         <span class="number">6</span><span class="punctuation">:</span> getstatic     #<span class="number">13</span>                 <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">9</span><span class="punctuation">:</span> iload_1</span><br><span class="line">        <span class="number">10</span><span class="punctuation">:</span> invokevirtual #<span class="number">19</span>                 <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">13</span><span class="punctuation">:</span> return</span><br><span class="line">      LineNumberTable<span class="punctuation">:</span></span><br><span class="line">        line <span class="number">10</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">        line <span class="number">11</span><span class="punctuation">:</span> <span class="number">6</span></span><br><span class="line">        line <span class="number">12</span><span class="punctuation">:</span> <span class="number">13</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">SourceFile<span class="punctuation">:</span> <span class="string">&quot;ByteCodeExample.java&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="ClassLoading"><a href="#ClassLoading" class="headerlink" title="ClassLoading"></a>ClassLoading</h1><h2 id="One-main-to-one-JVM-process"><a href="#One-main-to-one-JVM-process" class="headerlink" title="One main to one JVM process"></a>One main to one JVM process</h2><p>当我们启动一个Java程序，即启动一个main方法时，都将启动一个Java虚拟机进程，不管这个进程有多么复杂。而不同的JVM进程之间是不会相互影响的。这也就是为什么说，Java程序只有一个入口——main方法，让虚拟机调用。而两个main方法，对应的是2个JVM进程，启动的是两个不同的类加载器，操作的实际上是不同的类。故而不会互相影响。</p>
<h2 id="ClassLoading-Workflow"><a href="#ClassLoading-Workflow" class="headerlink" title="ClassLoading Workflow"></a>ClassLoading Workflow</h2><p>当我们使用一个类，如果这个类还未加载到内存中，系统会通过加载、连接、初始化对类进行初始化。完成后可以使用Using和卸载Unloading。</p>
<h3 id="加载-Loading"><a href="#加载-Loading" class="headerlink" title="加载(Loading)"></a>加载(Loading)</h3><p><strong>目的</strong>：将类的字节码文件从持久存储加载到内存的方法区，并生成对应的 <strong>Class 对象</strong>。</p>
<p><strong>具体步骤</strong>：</p>
<ol>
<li>通过类名查找 <code>.class</code> 文件，并将其二进制字节码读入内存</li>
<li>将字节码中的静态存储结构转换为方法区中的 <strong>运行时数据结构</strong>。</li>
<li>在堆内存中创建一个 <strong>java.lang.Class</strong> 对象，作为对方法区载入数据的访问入口。</li>
</ol>
<p>类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 <strong>双亲委派模型</strong> 决定（不过，我们也能打破由双亲委派模型）。</p>
<p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p>
<p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。默认的loadClass方法最后就是Link的</p>
<h3 id="连接-Linking"><a href="#连接-Linking" class="headerlink" title="连接(Linking)"></a>连接(Linking)</h3><p>类连接：指的是把类的二进制数据合并到 JRE 中，这又分为 3 个阶段：</p>
<h4 id="验证-Verification"><a href="#验证-Verification" class="headerlink" title="验证(Verification)"></a>验证(Verification)</h4><p><strong>目的</strong>：检查载入Class文件数据的正确性，确保字节码文件符合 JVM 要求，不会危害虚拟机安全。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/class-loading-process-verification.png" alt="验证阶段示意图"></p>
<p><strong>具体检查</strong>：</p>
<ol>
<li><strong>文件格式验证</strong>：是否符合 Class 文件格式规范。</li>
<li><strong>元数据验证</strong>：类继承、接口实现是否正确。</li>
<li><strong>字节码验证</strong>：指令流是否合法，如变量初始化和栈操作正确。</li>
<li><strong>符号引用验证</strong>：类、字段、方法等是否存在。</li>
</ol>
<p><strong>结果</strong>：不合法的字节码会抛出 <strong>VerifyError</strong>。</p>
<p>文件格式验证这一阶段是基于该类的二进制字节流进行的，主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。除了这一阶段之外，其余三个验证阶段都是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。符号引用验证发生在类加载过程中的解析阶段，具体点说是 JVM 将符号引用转化为直接引用的时候（解析阶段会介绍符号引用和直接引用）。</p>
<p>符号引用验证的主要目的是确保解析阶段能正常执行，如果无法通过符号引用验证，JVM 会抛出异常NoSuchFieldError NoSuchMethodError IllegalAccessError。</p>
<h4 id="准备-Preparation"><a href="#准备-Preparation" class="headerlink" title="准备(Preparation)"></a>准备(Preparation)</h4><p>给类的<mark>静态变量<mark>分配存储空间，并进行<mark>默认初始化，赋零值<mark>。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png" alt="基本数据类型的零值"></p>
<p><strong>目的</strong>：为类的静态变量分配内存，并设置默认值（不会执行静态初始化）。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行阶段</strong>：</p>
<ul>
<li>分配内存，并将 <code>a</code> 的初始值设为 <code>0</code>（默认值）。</li>
<li>注意：这里不会执行 <code>= 10</code>，赋值在初始化阶段完成。</li>
</ul>
<p>从概念上讲，类变量所使用的内存都应当在 <strong>方法区</strong> 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。</p>
<h4 id="解析-Resolution"><a href="#解析-Resolution" class="headerlink" title="解析(Resolution)"></a>解析(Resolution)</h4><p><strong>目的</strong>：将类的二进制数据中 常量池的 <strong>符号引用</strong> 替换为 <strong>直接引用</strong>。</p>
<ul>
<li><strong>符号引用</strong>：类、方法、字段等以字符串形式存在于常量池中。<ul>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</li>
<li>符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引 用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同， 但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规 范》的Class文件格式中。</li>
</ul>
</li>
<li><strong>直接引用</strong>：实际内存地址或偏移量。<ul>
<li>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚 拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机 的内存中存在。</li>
<li>在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</li>
</ul>
</li>
</ul>
<h3 id="初始化-Initialization"><a href="#初始化-Initialization" class="headerlink" title="初始化(Initialization)"></a>初始化(Initialization)</h3><p>对类的静态变量、静态初始化块进行初始化，因此不是必须的。<strong>这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</strong> </p>
<p>初始化阶段就是执行类构造器<code>&lt;clinit&gt; ()</code>方法的过程。<code>&lt;clinit&gt; ()</code>并不是程序员在Java代码中直接编写 的方法，它是Javac编译器的自动生成物</p>
<p>对于<code>&lt;clinit&gt; ()</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt; ()</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起多个线程阻塞，并且这种阻塞很难被发现。</p>
<p>由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的 语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能<strong>访问到定义在静态语句块之前的变量，</strong> 在前面的静态语句块可以赋值定义在其后的变量，但是不能访问它</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         i = <span class="number">0</span>; <span class="comment">// 给变量复制可以正常编译通过</span></span><br><span class="line">         System.out.print(i); <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>&lt;clinit&gt; ()</code>方法与类的构造函数（即在虚拟机视角中的实例构造器<code>&lt;init&gt; ()</code>方法）不同，它不需要显 式地调用父类构造器，Java虚拟机会保证在子类的<code>&lt;clinit&gt; ()</code>方法执行前，父类的<code>&lt;init&gt; ()</code>方法已经执行 完毕。因此在Java虚拟机中第一个被执行的()方法的类型肯定是java.lang.Object</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250104142317079.png" alt="clinit"></p>
<p><strong>具体步骤</strong>：</p>
<ol>
<li>按照声明顺序依次执行静态变量赋值和静态代码块。</li>
<li>若父类未初始化，会先初始化父类。</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123; a = <span class="number">20</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行结果</strong>：<code>a = 20</code>（因为静态代码块会覆盖前面的赋值）。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>初始化是类加载的最后阶段，只有在首次使用类时触发。</li>
<li>使用场景：实例化对象、调用静态方法、访问静态变量等。</li>
</ul>
<h4 id="初始化的触发条件-主动"><a href="#初始化的触发条件-主动" class="headerlink" title="初始化的触发条件(主动)"></a>初始化的触发条件(主动)</h4><p>关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java虚拟机规范》中并没有进行 强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，《Java虚拟机规范》 则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之 前开始）：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始 化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：<ol>
<li>创建该类的实例对象</li>
<li>访问static变量</li>
<li>调用static方法</li>
</ol>
</li>
<li>反射调用时如 <code>Class.forName(&quot;...&quot;)</code>, <code>newInstance()</code> 等<ul>
<li><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用，就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类</li>
</ul>
</li>
<li>初始化子类会触发父类的初始化</li>
<li>有 <code>default</code> 方法的接口实现类初始化，接口也要初始化</li>
<li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 <code>main</code> 方法的那个类)，虚拟机会先初始化这个类。</li>
</ol>
<p>被动访问不会触发初始化：</p>
<ol>
<li>访问类的 <strong>常量</strong>（<code>static final</code> 修饰）因为常量位于 运行时常量池<ul>
<li>在编译阶段通过常量传播优化，已经将常量的值“hello world”直接存储在NotInitialization类的常量池中，以后NotInitialization对常量 ConstClass.HELLOWORLD的引用，实际都被转化为NotInitialization类对自身常量池的引用了。也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成 Class文件后就已不存在任何联系了。</li>
</ul>
</li>
<li>通过 <strong>数组定义类引用</strong>（如 <code>Test[] arr</code>）。<ul>
<li>运行之后发现没有输出“SuperClass init！”，说明并没有触发类org.fenixsoft.classloading.SuperClass的初始化阶段。但是这段代码里面触发了 另一个名为“[Lorg.fenixsoft.classloading.SuperClass”的类的初始化阶段，对于用户代码来说，这并不是 一个合法的类型名称，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由 字节码指令newarray触发。</li>
</ul>
</li>
<li>对于静态字段， 只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发 父类的初始化而不会触发子类的初始化。</li>
</ol>
<p>（注意：一个final类型的静态属性，如果在编译时已经得到了属性值，那么调用该属性时，不会导致该类初始化，因为这个相当于使用常量；使用ClassLoader()方法，只是加载该类，并未初始化。）</p>
<h3 id="使用-Using"><a href="#使用-Using" class="headerlink" title="使用(Using)"></a>使用(Using)</h3><p>类加载完成后，可以使用类创建实例、调用方法或访问字段。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li>使用过程中 JVM 可能会进行 <strong>动态绑定</strong>（如多态方法调用）和 <strong>反射机制</strong>。 </li>
</ul>
<h3 id="卸载-Unloading"><a href="#卸载-Unloading" class="headerlink" title="卸载(Unloading)"></a>卸载(Unloading)</h3><p><strong>目的</strong>：当某些类不再被使用时，将其从内存中移除。</p>
<p><strong>条件</strong>：</p>
<ul>
<li>该类的所有实例已被回收。</li>
<li>该类的 ClassLoader 实例已被回收。</li>
<li>JVM 中没有该类的任何引用。</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>卸载阶段只针对用户的使用自定义类加载器加载的类，Bootstrap 引导加载器加载的类不会被卸载。</li>
<li>GC 会回收 <strong>Class 对象</strong> 和相关的元数据。</li>
</ul>
<p>所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p>
<p>只要想通一点就好了，JDK 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p>
<h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><p>类加载器是一个负责加载类的对象。<code>ClassLoader</code> 是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。负责将.class文件加载到内存中，并为之生成对应的java.lang.Class对象。</p>
<p>在 Java 中，一个类用其全限定类名（即包名+类名）作为标识。</p>
<p>而在 JVM 中，一个类用其全限定类名和其类加载器作为标识。</p>
<h3 id="dynamic-lazy-loading-only-once"><a href="#dynamic-lazy-loading-only-once" class="headerlink" title="dynamic lazy loading, only once"></a>dynamic lazy loading, only once</h3><p>JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。加载时机并没有明确的要求。</p>
<p>对于已经加载的类会被放在 <code>ClassLoader</code> 中的 <code>classes</code> 字段，这是一个存放Class对象的容器。在类加载的时候，首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。</p>
<p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="comment">// 由这个类加载器加载的类。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Vector&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 由VM调用，用此类加载器记录每个已加载类。</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">addClass</span><span class="params">(Class&lt;?&gt; c)</span> &#123;</span><br><span class="line">        classes.addElement(c);</span><br><span class="line">   &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><strong>Bootstrap ClassLoader</strong>（引导类加载器）：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级。加载核心类库（ <code>%JAVA_HOME%/lib</code>目录下的 <code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类）以及被 <code>-Xbootclasspath</code>参数指定的路径下的所有类）。<ul>
<li><code>rt.jar</code>：rt 代表“RunTime”，<code>rt.jar</code>是 Java 基础类库，包含 Java doc 里面看到的所有的类的类文件。也就是说，我们常用内置库 <code>java.xxx.*</code>都在里面，比如<code>java.util.*</code>、<code>java.io.*</code>、<code>java.nio.*</code>、<code>java.lang.*</code>、<code>java.sql.*</code>、<code>java.math.*</code>。</li>
</ul>
</li>
<li><strong>Extension ClassLoader</strong>（扩展类加载器）：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。<ul>
<li>Java 9 引入了模块系统，并且略微更改了上述的类加载器。Extension ClassLoader被改名为平台类加载器（Platform Classloader）。Java SE 中除了少数几个关键模块，比如说 <code>java.base</code> 是由 Bootstrap ClassLoader 加载之外，其他的模块均由 Platform Classloader 所加载。</li>
</ul>
</li>
<li><strong>Application ClassLoader</strong>（应用类加载器）：加载应用程序的 <code>classpath</code> 下的类。</li>
<li><strong>自定义类加载器</strong>：用户实现的特殊需求类加载器。</li>
</ul>
<p>除了 <code>BootstrapClassLoader</code> 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 <code>ClassLoader</code>抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。</p>
<h3 id="加载器调用顺序"><a href="#加载器调用顺序" class="headerlink" title="加载器调用顺序"></a>加载器调用顺序</h3><p>每个 <code>ClassLoader</code> 可以通过<code>getParent()</code>获取其父 <code>ClassLoader</code>，如果获取到 <code>ClassLoader</code> 为<code>null</code>的话，那么该类是通过 <code>BootstrapClassLoader</code> 加载的。</p>
<ul>
<li>我们编写的 Java 类 <code>PrintClassLoaderTree</code> 的 <code>ClassLoader</code> 是<code>AppClassLoader</code>；</li>
<li><code>AppClassLoader</code>的父 <code>ClassLoader</code> 是 <code>ExtClassLoader</code>；</li>
<li><code>ExtClassLoader</code>的父 <code>ClassLoader</code> 是 <code>Bootstrap ClassLoader</code> </li>
</ul>
<p>其中，<code>BootstrapClassLoader</code>负责加载JRE的核心类库，它不是<code>ClassLoader</code>的子类，使用C++编写，因此我们在Java中看不到它，通过其子类的<code>getParent()</code>方法获取时，将返回<code>null</code>。</p>
<p><code>ExtClassLoader</code>和<code>AppClassLoader</code>为<code>ClassLoader</code>的子类。在 API 中看不到它们，他们位于 rt.jar 文件中，因此由<code>BootstrapClassLoader</code>进行加载，全限定类名分别为：</p>
<ul>
<li><p><code>sun.misc.Launcher$AppClassLoader</code> </p>
<ul>
<li><code>jdk.internal.loader.ClassLoaders$AppClassLoader</code> </li>
</ul>
</li>
<li><p><code>sun.misc.Launcher$ExtClassLoader</code> </p>
<ul>
<li><code>jdk.internal.loader.ClassLoaders$PlatformClassLoader</code> </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.stopTalking.crazy;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="comment">//获取当前线程的类装载器 </span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader(); </span><br><span class="line">        <span class="comment">//获取System类的类装载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader1</span> <span class="operator">=</span> System.class.getClassLoader(); </span><br><span class="line">        <span class="comment">//获取本类TestClassLoader的类加载器loader2 </span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader2</span> <span class="operator">=</span> TestClassLoader.class.getClassLoader(); </span><br><span class="line">        <span class="comment">//获取loader2的父加载器 </span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader3</span> <span class="operator">=</span> loader2.getParent(); </span><br><span class="line">        <span class="comment">//获取loader2的父加载器的父加载器 </span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader4</span> <span class="operator">=</span> loader3.getParent(); </span><br><span class="line">        System.out.println(loader); </span><br><span class="line">        System.out.println(loader1); </span><br><span class="line">        System.out.println(loader2); </span><br><span class="line">        System.out.println(loader3); </span><br><span class="line">        System.out.println(loader4); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前线程类获取的类加载器是AppClassLoader</span></span><br><span class="line">jdk.internal.loader.ClassLoaders$AppClassLoader@4aa298b7</span><br><span class="line"><span class="comment">//System类为根装载器加载，java中访问不到，所以为null</span></span><br><span class="line"><span class="literal">null</span> </span><br><span class="line"><span class="comment">//本类的类加载器当然也是AppClassLoader    </span></span><br><span class="line">jdk.internal.loader.ClassLoaders$AppClassLoader@4aa298b7</span><br><span class="line">jdk.internal.loader.ClassLoaders$PlatformClassLoader@5caf905d</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义-ClassLoader"><a href="#自定义-ClassLoader" class="headerlink" title="自定义 ClassLoader"></a>自定义 ClassLoader</h3><p>需要继承 <code>ClassLoader</code>抽象类。<code>ClassLoader</code> 类有两个关键方法：</p>
<ul>
<li><code>protected Class loadClass(String name, boolean resolve)</code>：加载指定二进制名称的类，实现了双亲委派机制 。<code>name</code> 为类的二进制名称，<code>resolve</code> 如果为 true，在加载时调用 <code>resolveClass(Class&lt;?&gt; c)</code> 方法解析该类。</li>
<li><code>protected Class findClass(String name)</code>：根据类的二进制名称来查找类，默认实现是空方法。</li>
</ul>
<blockquote>
<p>建议 <code>ClassLoader</code>的子类重写 <code>findClass(String name)</code>方法而不是<code>loadClass(String name, boolean resolve)</code> 方法。</p>
</blockquote>
<p>如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。</p>
<h2 id="Parents-Delegation-Model"><a href="#Parents-Delegation-Model" class="headerlink" title="Parents Delegation Model"></a>Parents Delegation Model</h2><p><code>ClassLoader</code> 类使用委托模型来搜索类和资源。</p>
<p>父辈委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p>
<p><code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。</p>
<p>父辈委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的，后文会介绍具体的方法。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/class-loader-parents-delegation-model-1735908352601-36.png" alt="类加载器层次关系图"></p>
<p>另外，类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 组合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在面向对象编程中，有一条非常经典的设计原则：<strong>组合优于继承，多用组合少用继承。</strong></p>
<h3 id="java-lang-ClassLoader-loadClass"><a href="#java-lang-ClassLoader-loadClass" class="headerlink" title="java.lang.ClassLoader.loadClass()"></a><code>java.lang.ClassLoader.loadClass()</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先，检查该类是否已经加载过，自底向上</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 c 为 null，则说明该类没有被加载过</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span></span><br><span class="line">                <span class="comment">//用户可通过覆写该方法，来自定义类加载器</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">        		<span class="comment">//用于统计类加载器相关的信息</span></span><br><span class="line">                PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">//对类进行连接操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</li>
<li>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</li>
<li>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 <code>findClass()</code> 方法来加载类）。</li>
<li>如果子类加载器也无法加载这个类，那么它会抛出一个 <code>ClassNotFoundException</code> 异常。</li>
</ul>
<p><strong>JVM 判定两个 Java 类是否相同的具体规则</strong>：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 <code>Class</code> 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。</p>
<p>双亲委派很好地解决了各个类 加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型之所以被 称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变 的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？</p>
<blockquote>
<p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务， 它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型 了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程 序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，启 动类加载器是绝不可能认识、加载这些代码的，那该怎么办？ 为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器 （Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方 法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内 都没有设置过的话，那这个类加载器默认就是应用程序类加载器。 有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类 加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行 为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性 原则，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、 JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供 者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了 java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加 载提供了一种相对合理的解决方案。</p>
</blockquote>
<p>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code> 类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code> 类，而不是你写的 <code>Object</code> 类。这是因为 <code>AppClassLoader</code> 在加载你的 <code>Object</code> 类时，会委托给 <code>ExtClassLoader</code> 去加载，而 <code>ExtClassLoader</code> 又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code> 发现自己已经加载过了 <code>Object</code> 类，会直接返回，不会去加载你写的 <code>Object</code> 类。</p>
<p>自定义加载器的话，需要继承 <code>ClassLoader</code> 。如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。</p>
<p>但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。重写 <code>loadClass()</code>方法之后，我们就可以改变传统双亲委派模型的执行流程。例如，子类加载器可以在委派给父类加载器之前，先自己尝试加载这个类，或者在父类加载器返回之后，再尝试从其他地方加载这个类。具体的规则由我们自己实现，根据项目需求定制化。另外，仅仅自定义加载器也不能够满足全部的要求。</p>
<p><a href="https://javaguide.cn/java/jvm/classloader.html#%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%96%B9%E6%B3%95">打破双亲委派模型方法 | JavaGuide</a> </p>
<h2 id="Classpath"><a href="#Classpath" class="headerlink" title="Classpath"></a>Classpath</h2><p><strong>Classpath</strong> 是 Java 应用程序运行时用来查找 <strong>类文件（.class）</strong> 和 <strong>资源文件</strong> 的路径。它定义了 JVM 加载类和资源的搜索目录。<strong>Classpath</strong> 指定了 JVM 在加载类时搜索的目录或 JAR 包路径。</p>
<p><strong>Classpath</strong> 是 JVM 加载类和资源的搜索路径，通常包括：</p>
<ol>
<li>当前目录 (<code>.</code>)。</li>
<li>指定的文件夹（包含 <code>.class</code> 文件或 JAR 包）。</li>
<li>第三方库文件（如 <code>lib/*.jar</code>）。</li>
</ol>
<p>在开发和运行 Java 程序时，可以通过命令行、环境变量或 IDE 设置 Classpath，以确保依赖文件和类可以正确加载。</p>
<h3 id="设置方式"><a href="#设置方式" class="headerlink" title="设置方式"></a>设置方式</h3><ol>
<li><p><strong>命令行设置：</strong><br>使用 <code>-classpath</code> 或 <code>-cp</code> 参数指定路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -cp .;lib/* com.example.Main</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>“.”</strong> 表示当前目录。</li>
<li><strong>“lib/*”</strong> 表示 <code>lib</code> 文件夹下的所有 JAR 文件。</li>
</ul>
</li>
<li><p><strong>环境变量设置：</strong><br>设置全局环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export CLASSPATH=/usr/local/app/classes:/usr/local/app/lib/*</span><br></pre></td></tr></table></figure>

<p>或 Windows 下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set CLASSPATH=.;lib\*</span><br></pre></td></tr></table></figure></li>
<li><p><strong>IDE 设置：</strong><br>在 IDE（如 IntelliJ IDEA、Eclipse）中，classpath 默认包含 <strong>src/main/java</strong> 和 <strong>target/classes</strong>，以及项目引用的依赖项。</p>
</li>
</ol>
<h3 id="Classpath-路径内容"><a href="#Classpath-路径内容" class="headerlink" title="Classpath 路径内容"></a>Classpath 路径内容</h3><p>Classpath 支持以下类型的路径：</p>
<ol>
<li><p><strong>目录路径：</strong></p>
<ul>
<li><p>包含编译好的类文件，如：<code>/home/user/classes</code>。</p>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp /home/user/classes Test</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>JAR 文件路径：</strong></p>
<ul>
<li><p>支持直接引用 JAR 包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp lib/example.jar Test</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>通配符路径：</strong></p>
<ul>
<li><p>可使用 <code>*</code> 引用多个 JAR 包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp lib/* Test</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>相对路径或绝对路径：</strong></p>
<ul>
<li>相对路径：<code>./lib</code>（当前目录）。</li>
<li>绝对路径：<code>/usr/lib/java/</code>.</li>
</ul>
</li>
</ol>
<h3 id="默认-Classpath-设置"><a href="#默认-Classpath-设置" class="headerlink" title="默认 Classpath 设置"></a>默认 Classpath 设置</h3><ol>
<li><p>如果未显式设置 <code>-classpath</code> 或 <code>CLASSPATH</code> 环境变量，JVM 默认搜索 <strong>当前目录（.）</strong>。</p>
</li>
<li><p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac Test.java</span><br><span class="line">java Test</span><br></pre></td></tr></table></figure>

<p>默认会从当前目录加载 <code>Test.class</code> 文件。</p>
</li>
</ol>
<h3 id="示例-1：单个类文件"><a href="#示例-1：单个类文件" class="headerlink" title="示例 1：单个类文件"></a>示例 1：单个类文件</h3><p>假设有以下目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/project/</span><br><span class="line">  Main.java</span><br></pre></td></tr></table></figure>

<p>编译与运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac Main.java</span><br><span class="line">java Main</span><br></pre></td></tr></table></figure>

<h3 id="示例-2：JAR-包依赖"><a href="#示例-2：JAR-包依赖" class="headerlink" title="示例 2：JAR 包依赖"></a>示例 2：JAR 包依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/project/</span><br><span class="line">  lib/</span><br><span class="line">    gson.jar</span><br><span class="line">  Main.java</span><br></pre></td></tr></table></figure>

<p>编译与运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac -cp lib/gson.jar Main.java</span><br><span class="line">java -cp lib/gson.jar:. Main</span><br></pre></td></tr></table></figure>

<h3 id="示例-3：多个-JAR-包"><a href="#示例-3：多个-JAR-包" class="headerlink" title="示例 3：多个 JAR 包"></a>示例 3：多个 JAR 包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -cp &quot;lib/*&quot; com.example.Main</span><br></pre></td></tr></table></figure>

<h2 id="加载顺序demo"><a href="#加载顺序demo" class="headerlink" title="加载顺序demo"></a>加载顺序demo</h2><p>这其实是去年校招时我遇到的一道阿里巴巴的笔试题(承认有点久远了-。-)，嗯，如果我没记错的话，当时是作为java方向的一道选做大题。当然题意没有这么直白，题目只要求你写出程序运行后所有system.out.println的输出结果，其中程序是题目给的，而各个system.out.println的执行顺序不同会导致最后程序输出的结果也不同。</p>
<p>具体的题目我肯定记不清，不过我们可以换个直接的问法，如果类A和类B中有静态变量，静态语句块，非静态变量，非静态语句块，构造函数，静态方法，非静态方法，同时类A继承类B，请问当实例化A时，类内部的加载顺序是什么?</p>
<p>当时我也是一头雾水，事后我就自己写了一个小Demo，这才知道了类内部的实际加载顺，测试代码如下：</p>
<p>Class B:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="comment">//静态变量 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//静态语句块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;  System.out.println(<span class="string">&quot;Class B1:static blocks&quot;</span>+i);&#125;</span><br><span class="line">    <span class="comment">//非静态变量</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//静态语句块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;  i++;  System.out.println(<span class="string">&quot;Class B2:static blocks&quot;</span>+i);&#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;  </span><br><span class="line">        i++;  j++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;constructor B: &quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态语句块</span></span><br><span class="line">    &#123; </span><br><span class="line">        i++; j++; </span><br><span class="line">        System.out.println(<span class="string">&quot;Class B:common blocks&quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bDisplay</span><span class="params">()</span>&#123;  </span><br><span class="line">        i++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Class B:static void bDisplay(): &quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);  </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bTest</span><span class="params">()</span>&#123; </span><br><span class="line">        i++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Class B:static void bTest():  &quot;</span>+<span class="string">&quot;i=&quot;</span>+i);  </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Class A:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="comment">//静态变量 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//静态语句块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;  System.out.println(<span class="string">&quot;Class A1:static blocks&quot;</span>+i);&#125;</span><br><span class="line">    <span class="comment">//非静态变量</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//静态语句块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;  i++;  System.out.println(<span class="string">&quot;Class A2:static blocks&quot;</span>+i);&#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="built_in">super</span>();  i++;  j++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;constructor A: &quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态语句块</span></span><br><span class="line">    &#123; </span><br><span class="line">        i++; j++; </span><br><span class="line">        System.out.println(<span class="string">&quot;Class A:common blocks&quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aDisplay</span><span class="params">()</span>&#123;  </span><br><span class="line">        i++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Class A:static void aDisplay(): &quot;</span>+<span class="string">&quot;i=&quot;</span>+i+<span class="string">&quot;,j=&quot;</span>+j);  </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">aTest</span><span class="params">()</span>&#123;  </span><br><span class="line">        i++;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Class A:static void aTest():  &quot;</span>+<span class="string">&quot;i=&quot;</span>+i);  </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Class ClassLoading :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoading</span> &#123;      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String args[])</span> &#123;    </span><br><span class="line">        A a=<span class="keyword">new</span> <span class="title class_">A</span>();    </span><br><span class="line">        a.aDisplay();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1484270652220239.jpg" alt="Java中类的加载顺序剖析（常用于面试题）"></p>
<p>通过上述示图，我们可以比较清晰的看出java类的整个加载过程。</p>
<ol>
<li>若要加载类A，则先加载执行其父类B(Object)的静态变量以及静态语句块(执行先后顺序按排列的先后顺序)。</li>
<li>然后再加载执行类A的静态变量以及静态语句块。(并且1、2步骤只会执行1次)</li>
<li>若需实例化类A，则先调用其父类B的构造函数,并且在调用其父类B的构造函数前,依次先调用父类B中的非静态变量及非静态语句块.最后再调用父类B中的构造函数初始化。</li>
<li>然后再依次调用类A中的非静态变量及非静态语句块.最后调用A中的构造函数初始化。( 并且3、4步骤可以重复执行)</li>
<li>而对于静态方法和非静态方法都是被动调用,即系统不会自动调用执行,所以用户没有调用时都不执行,主要区别在于静态方法可以直接用类名直接调用(实例化对象也可以),而非静态方法只能先实例化对象后才能调用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类--静态变量</span><br><span class="line">父类--静态初始化块</span><br><span class="line">子类--静态变量</span><br><span class="line">子类--静态初始化块</span><br><span class="line">*************in main***************</span><br><span class="line">父类--变量</span><br><span class="line">父类--初始化块</span><br><span class="line">父类--构造器</span><br><span class="line">子类--变量</span><br><span class="line">子类--初始化块</span><br><span class="line">子类--构造器</span><br><span class="line">*************second subclass***************</span><br><span class="line">父类--变量</span><br><span class="line">父类--初始化块</span><br><span class="line">父类--构造器</span><br><span class="line">子类--变量</span><br><span class="line">子类--初始化块</span><br><span class="line">子类--构造器</span><br></pre></td></tr></table></figure>

<p>结果分析：</p>
<p>很显然在加载main方法后，静态变量不管父类还是子类的都执行了，然后才是父类和子类的的普通变量和构造器。这是因为，当要创建子类这个对象时，发现这个类需要一个父类，所以把父类的.class加载进来，然后依次初始化其普通变量和初始化代码块，最后其构造器，然后可以开始子类的工作，把子类的.class加载进来，在做子类的工作。</p>
<p>另外在 Java 中子类中都会有默认的调用父类的默认构造函数即super() 如果父类声明了有参构造函数，那么如果没有显式声明无参构造，子类就会爆出语法错误，无法调用父类的无参构造。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>字节码</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义 starter</title>
    <url>/2024/10/01/Starter%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p><mark>在 Spring Boot 生态中，“Starter” 本质上就是一组依赖的“捆绑包”，它的目标是让使用方 <strong>一行依赖</strong> 就把启动一个完整的 Spring Boot 应用所需的所有东西都拉过来。</mark> </p>
<span id="more"></span>

<h1 id="父模块实现"><a href="#父模块实现" class="headerlink" title="父模块实现"></a>父模块实现</h1><p>父POM的作用：作为配置的样板、插件管理、依赖管理。</p>
<p><code>parent</code> 定义了继承关系，子模块从父 POM 继承配置。</p>
<p><code>modules</code> 定义了聚合关系，父 POM 聚合了需要统一管理的子模块。</p>
<p>在我们项目顶层的pom文件中，我们会看到dependencyManagement元素。通过它元素来管理jar包的版本，让子项目中引用一个依赖而不用显示的列出版本号。Maven会沿着父子层次向上走，直到找到一个拥有dependencyManagement元素的项目，然后它就会使用在这个dependencyManagement元素中指定的版本号。</p>
<p>Dependencies相对于dependencyManagement，所有声明在dependencies里的依赖都会自动引入，并默认被所有的子项目继承，但是父项目引入依赖没有任何用处，所以只需要用dependencyManagement声明即可。</p>
<p>在使用springboot时，通常工程有自己的父模块，而<a href="https://docs.spring.io/spring-boot/docs/2.1.12.RELEASE/reference/html/using-boot-build-systems.html#using-boot-maven-without-a-parent">不能继承spring-boot-starter-parent</a>时，推荐按照下面的做法</p>
<p><code>&lt;type&gt;pom&lt;/type&gt;</code>，<code>&lt;scope&gt;import&lt;/scope&gt;</code>，表示将<code>spring-boot-dependencies</code> 中<code>dependencyManagement</code>下的<code>dependencies</code>插入到当前工程的<code>dependencyManagement</code>中，所以不存在依赖传递。当没有<code>&lt;scope&gt;import&lt;/scope&gt;</code>时，意思是将<code>spring-boot-dependencies</code> 的<code>dependencies</code>全部插入到当前工程的<code>dependencies</code>中，并且会依赖传递。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>3.4.4<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rpc.version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">rpc.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 其他依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>$&#123;maven.compiler.source&#125;<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>$&#123;maven.compiler.source&#125;<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>false<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 其他插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="starter-子模块实现"><a href="#starter-子模块实现" class="headerlink" title="starter 子模块实现"></a>starter 子模块实现</h1><p>starter——核心功能在 core 实现，一定要有<code>autoconfigure</code>以及<code>configuration-processor</code></p>
<ul>
<li>starter 依赖 core、<mark>spring-boot-starter</mark>（一行代码引入依赖的核心） <code>autoconfigure</code>其实也包括在内了</li>
<li>增强扩展性：core 的依赖全部改为 optional，然后在 starter 内再次依赖</li>
<li>名称：以spring-boot-starter结尾，易于辨识</li>
</ul>
<h1 id="使用-starter"><a href="#使用-starter" class="headerlink" title="使用 starter"></a>使用 starter</h1><p>直接在pom引入自定义 starter 即可</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>spring-boot</tag>
        <tag>自动装配</tag>
      </tags>
  </entry>
  <entry>
    <title>深度解读 java 线程池设计思想及源码实现(转自Javadoop)</title>
    <url>/2017/09/05/ThreadPool/</url>
    <content><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>我相信大家都看过很多的关于线程池的文章，基本上也是面试的时候必问的，如果你在看过很多文章以后，还是一知半解的，那希望这篇文章能让你真正的掌握好 Java 线程池。</p>
<p>本文一大重点是源码解析，同时会有少量篇幅介绍线程池设计思想以及作者 Doug Lea 实现过程中的一些巧妙用法。本文还是会一行行关键代码进行分析，目的是为了让那些自己看源码不是很理解的同学可以得到参考。</p>
<p>线程池是非常重要的工具，如果你要成为一个好的工程师，还是得比较好地掌握这个知识，很多线上问题都是因为没有用好线程池导致的。即使你为了谋生，也要知道，这基本上是面试必问的题目，而且面试官很容易从被面试者的回答中捕捉到被面试者的技术水平。</p>
<p>本文略长，建议在 pc 上阅读，边看文章边翻源码（Java7 和 Java8 都一样），建议想好好看的读者抽出至少 30 分钟的整块时间来阅读。当然，如果读者仅为面试准备，可以直接滑到最后的<strong>总结</strong>部分。</p>
<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>开篇来一些废话。下图是 java 线程池几个相关类的继承结构：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/java-thread-pool/1.jpg" alt="1"></p>
<p>先简单说说这个继承结构，Executor 位于最顶层，也是最简单的，就一个 execute(Runnable runnable) 接口方法定义。</p>
<p>ExecutorService 也是接口，在 Executor 接口的基础上添加了很多的接口方法，所以<strong>一般来说我们会使用这个接口</strong>。</p>
<p>然后再下来一层是 AbstractExecutorService，从名字我们就知道，这是抽象类，这里实现了非常有用的一些方法供子类直接使用，之后我们再细说。</p>
<p>然后才到我们的重点部分 ThreadPoolExecutor 类，这个类提供了关于线程池所需的非常丰富的功能。</p>
<p>另外，我们还涉及到下图中的这些类：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/java-thread-pool/others.png" alt="others"></p>
<p>同在并发包中的 Executors 类，类名中带字母 s，我们猜到这个是工具类，里面的方法都是静态方法，如以下我们最常用的用于生成 ThreadPoolExecutor 的实例的一些方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，由于线程池支持<strong>获取线程执行的结果</strong>，所以，引入了 Future 接口，RunnableFuture 继承自此接口，然后我们最需要关心的就是它的实现类 FutureTask。到这里，记住这个概念，在线程池的使用过程中，我们是往线程池提交任务（task），使用过线程池的都知道，我们提交的每个任务是实现了 Runnable 接口的，其实就是先将 Runnable 的任务包装成 FutureTask，然后再提交到线程池。这样，读者才能比较容易记住 FutureTask 这个类名：它首先是一个任务（Task），然后具有 Future 接口的语义，即可以在将来（Future）得到执行的结果。</p>
<p>当然，线程池中的 BlockingQueue 也是非常重要的概念，如果线程数达到 corePoolSize，我们的每个任务会提交到等待队列中，等待线程池中的线程来取任务并执行。这里的 BlockingQueue 通常我们使用其实现类 LinkedBlockingQueue、ArrayBlockingQueue 和 SynchronousQueue，每个实现类都有不同的特征，使用场景之后会慢慢分析。想要详细了解各个 BlockingQueue 的读者，可以参考我的前面的一篇对 BlockingQueue 的各个实现类进行详细分析的文章。</p>
<blockquote>
<p>把事情说完整：除了上面说的这些类外，还有一个很重要的类，就是定时任务实现类 ScheduledThreadPoolExecutor，它继承自本文要重点讲解的 ThreadPoolExecutor，用于实现定时执行。不过本文不会介绍它的实现，我相信读者看完本文后可以比较容易地看懂它的源码。</p>
</blockquote>
<p>以上就是本文要介绍的知识，废话不多说，开始进入正文。</p>
<h2 id="Executor-接口"><a href="#Executor-接口" class="headerlink" title="Executor 接口"></a>Executor 接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * @since 1.5</span></span><br><span class="line"><span class="comment"> * @author Doug Lea</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 Executor 接口非常简单，就一个 <code>void execute(Runnable command)</code> 方法，代表提交一个任务。为了让大家理解 java 线程池的整个设计方案，我会按照 Doug Lea 的设计思路来多说一些相关的东西。</p>
<p>我们经常这样启动一个线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>用了线程池 Executor 后就可以像下面这么使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> anExecutor;</span><br><span class="line">executor.execute(<span class="keyword">new</span> <span class="title class_">RunnableTask1</span>());</span><br><span class="line">executor.execute(<span class="keyword">new</span> <span class="title class_">RunnableTask2</span>());</span><br></pre></td></tr></table></figure>

<p>如果我们希望线程池同步执行每一个任务，我们可以这么实现这个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DirectExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        r.run();<span class="comment">// 这里不是用的new Thread(r).start()，也就是说没有启动任何一个新的线程。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望每个任务提交进来后，直接启动一个新的线程来执行这个任务，我们可以这么实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();  <span class="comment">// 每个任务都用一个新的线程来执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看下怎么组合两个 Executor 来使用，下面这个实现是将所有的任务都加到一个 queue 中，然后从 queue 中取任务，交给真正的执行器执行，这里采用 synchronized 进行并发控制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SerialExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">final</span> Queue&lt;Runnable&gt; tasks = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Runnable&gt;();</span><br><span class="line">    <span class="comment">// 这个才是真正的执行器</span></span><br><span class="line">    <span class="keyword">final</span> Executor executor;</span><br><span class="line">    <span class="comment">// 当前正在执行的任务</span></span><br><span class="line">    Runnable active;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 初始化的时候，指定执行器</span></span><br><span class="line">    SerialExecutor(Executor executor) &#123;</span><br><span class="line">        <span class="built_in">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 添加任务到线程池: 将任务添加到任务队列，scheduleNext 触发执行器去任务队列取任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> &#123;</span><br><span class="line">        tasks.offer(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    scheduleNext();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (active == <span class="literal">null</span>) &#123;</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">scheduleNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((active = tasks.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 具体的执行转给真正的执行器 executor</span></span><br><span class="line">            executor.execute(active);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然了，Executor 这个接口只有提交任务的功能，太简单了，我们想要更丰富的功能，比如我们想知道执行结果、我们想知道当前线程池有多少个线程活着、已经完成了多少任务等等，这些都是这个接口的不足的地方。接下来我们要介绍的是继承自 <code>Executor</code> 接口的 <code>ExecutorService</code> 接口，这个接口提供了比较丰富的功能，也是我们最常使用到的接口。</p>
<h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><p>一般我们定义一个线程池的时候，往往都是使用这个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(args...);</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool(args...);</span><br></pre></td></tr></table></figure>

<p>因为这个接口中定义的一系列方法大部分情况下已经可以满足我们的需要了。</p>
<p>那么我们简单初略地来看一下这个接口中都有哪些方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExecutorService</span> <span class="keyword">extends</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池，已提交的任务继续执行，不接受继续提交新任务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池，尝试停止正在执行的所有任务，不接受继续提交新任务</span></span><br><span class="line">    <span class="comment">// 它和前面的方法相比，加了一个单词“now”，区别在于它会去停止当前正在进行的任务</span></span><br><span class="line">    List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池是否已关闭</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果调用了 shutdown() 或 shutdownNow() 方法后，所有任务结束了，那么返回true</span></span><br><span class="line">    <span class="comment">// 这个方法必须在调用shutdown或shutdownNow方法之后调用才会返回true</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有任务完成，并设置超时时间</span></span><br><span class="line">    <span class="comment">// 我们这么理解，实际应用中是，先调用 shutdown 或 shutdownNow，</span></span><br><span class="line">    <span class="comment">// 然后再调这个方法等待所有的线程真正地完成，返回值意味着有没有超时</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个 Callable 任务</span></span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个 Runnable 任务，第二个参数将会放到 Future 中，作为返回值，</span></span><br><span class="line">    <span class="comment">// 因为 Runnable 的 run 方法本身并不返回任何东西</span></span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个 Runnable 任务</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行所有任务，返回 Future 类型的一个 list</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也是执行所有任务，但是这里设置了超时时间</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                                  <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 同上一个方法，只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果，</span></span><br><span class="line">    <span class="comment">// 不过这个带超时，超过指定的时间，抛出 TimeoutException 异常</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                    <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些方法都很好理解，一个简单的线程池主要就是这些功能，能提交任务，能获取结果，能关闭线程池，这也是为什么我们经常用这个接口的原因。</p>
<div id="FutureTask"></div>

<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>在继续往下层介绍 ExecutorService 的实现类之前，我们先来说说相关的类 FutureTask。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future      Runnable</span><br><span class="line">   \           /</span><br><span class="line">    \         /</span><br><span class="line">   RunnableFuture</span><br><span class="line">          |</span><br><span class="line">          |</span><br><span class="line">      FutureTask</span><br><span class="line">      </span><br><span class="line">FutureTask 通过 RunnableFuture 间接实现了 Runnable 接口，</span><br><span class="line">所以每个 Runnable 通常都先包装成 FutureTask，</span><br><span class="line">然后调用 executor.execute(Runnable command) 将其提交给线程池</span><br></pre></td></tr></table></figure>

<p>我们知道，Runnable 的 void run() 方法是没有返回值的，所以，通常，如果我们需要的话，会在 submit 中指定第二个参数作为返回值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br></pre></td></tr></table></figure>

<p>其实到时候会通过这两个参数，将其包装成 Callable。它和 Runnable 的区别在于 run() 没有返回值，而 Callable 的 call() 方法有返回值，同时，如果运行出现异常，call() 方法会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">   </span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，就不展开说 FutureTask 类了，因为本文篇幅本来就够大了，这里我们需要知道怎么用就行了。</p>
<p>下面，我们来看看 <code>ExecutorService</code> 的抽象实现 <code>AbstractExecutorService</code> 。</p>
<h2 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h2><p>AbstractExecutorService 抽象类派生自 ExecutorService 接口，然后在其基础上实现了几个实用的方法，这些方法提供给子类进行调用。</p>
<p>这个抽象类实现了 invokeAny 方法和 invokeAll 方法，这里的两个 newTaskFor 方法也比较有用，用于将任务包装成 FutureTask。定义于最上层接口 Executor中的 <code>void execute(Runnable command)</code> 由于不需要获取结果，不会进行 FutureTask 的包装。</p>
<blockquote>
<p>需要获取结果（FutureTask），用 submit 方法，不需要获取结果，可以用 execute 方法。</p>
</blockquote>
<p>下面，我将一行一行源码地来分析这个类，跟着源码来看看其实现吧：</p>
<blockquote>
<p>Tips: invokeAny 和 invokeAll 方法占了这整个类的绝大多数篇幅，读者可以选择适当跳过，因为它们可能在你的实践中使用的频次比较低，而且它们不带有承前启后的作用，不用担心会漏掉什么导致看不懂后面的代码。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title class_">ExecutorService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RunnableFuture 是用于获取执行结果的，我们常用它的子类 FutureTask</span></span><br><span class="line">    <span class="comment">// 下面两个 newTaskFor 方法用于将我们的任务包装成 FutureTask 提交到线程池中执行</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="comment">// 1. 将任务包装成 FutureTask</span></span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 2. 交给执行器执行，execute 方法由具体的子类来实现</span></span><br><span class="line">        <span class="comment">// 前面也说了，FutureTask 间接实现了Runnable 接口。</span></span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="comment">// 1. 将任务包装成 FutureTask</span></span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">        <span class="comment">// 2. 交给执行器执行</span></span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="comment">// 1. 将任务包装成 FutureTask</span></span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        <span class="comment">// 2. 交给执行器执行</span></span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法目的：将 tasks 集合中的任务提交到线程池执行，任意一个线程执行完后就可以结束了</span></span><br><span class="line">    <span class="comment">// 第二个参数 timed 代表是否设置超时机制，超时时间为第三个参数，</span></span><br><span class="line">    <span class="comment">// 如果 timed 为 true，同时超时了还没有一个线程返回结果，那么抛出 TimeoutException 异常</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; T <span class="title function_">doInvokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                            <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">        <span class="keyword">if</span> (tasks == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="comment">// 任务数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ntasks</span> <span class="operator">=</span> tasks.size();</span><br><span class="line">        <span class="keyword">if</span> (ntasks == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        List&lt;Future&lt;T&gt;&gt; futures= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Future&lt;T&gt;&gt;(ntasks);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// ExecutorCompletionService 不是一个真正的执行器，参数 this 才是真正的执行器</span></span><br><span class="line">        <span class="comment">// 它对执行器进行了包装，每个任务结束后，将结果保存到内部的一个 completionQueue 队列中</span></span><br><span class="line">        <span class="comment">// 这也是为什么这个类的名字里面有个 Completion 的原因吧。</span></span><br><span class="line">        ExecutorCompletionService&lt;T&gt; ecs =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ExecutorCompletionService</span>&lt;T&gt;(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 用于保存异常信息，此方法如果没有得到任何有效的结果，那么我们可以抛出最后得到的一个异常</span></span><br><span class="line">            <span class="type">ExecutionException</span> <span class="variable">ee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lastTime</span> <span class="operator">=</span> timed ? System.nanoTime() : <span class="number">0</span>;</span><br><span class="line">            Iterator&lt;? <span class="keyword">extends</span> <span class="title class_">Callable</span>&lt;T&gt;&gt; it = tasks.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首先先提交一个任务，后面的任务到下面的 for 循环一个个提交</span></span><br><span class="line">            futures.add(ecs.submit(it.next()));</span><br><span class="line">            <span class="comment">// 提交了一个任务，所以任务数量减 1</span></span><br><span class="line">            --ntasks;</span><br><span class="line">            <span class="comment">// 正在执行的任务数(提交的时候 +1，任务结束的时候 -1)</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">active</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// ecs 上面说了，其内部有一个 completionQueue 用于保存执行完成的结果</span></span><br><span class="line">                <span class="comment">// BlockingQueue 的 poll 方法不阻塞，返回 null 代表队列为空</span></span><br><span class="line">                Future&lt;T&gt; f = ecs.poll();</span><br><span class="line">                <span class="comment">// 为 null，说明刚刚提交的第一个线程还没有执行完成</span></span><br><span class="line">                <span class="comment">// 在前面先提交一个任务，加上这里做一次检查，也是为了提高性能</span></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ntasks &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        --ntasks;</span><br><span class="line">                        futures.add(ecs.submit(it.next()));</span><br><span class="line">                        ++active;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 这里是 else if，不是 if。这里说明，没有任务了，同时 active 为 0 说明</span></span><br><span class="line">                    <span class="comment">// 任务都执行完成了。其实我也没理解为什么这里做一次 break？</span></span><br><span class="line">                    <span class="comment">// 因为我认为 active 为 0 的情况，必然从下面的 f.get() 返回了</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 2018-02-23 感谢读者 newmicro 的 comment，</span></span><br><span class="line">                    <span class="comment">//  这里的 active == 0，说明所有的任务都执行失败，那么这里是 for 循环出口</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (active == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 这里也是 else if。这里说的是，没有任务了，但是设置了超时时间，这里检测是否超时</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                        <span class="comment">// 带等待的 poll 方法</span></span><br><span class="line">                        f = ecs.poll(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                        <span class="comment">// 如果已经超时，抛出 TimeoutException 异常，这整个方法就结束了</span></span><br><span class="line">                        <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">                        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                        nanos -= now - lastTime;</span><br><span class="line">                        lastTime = now;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 这里是 else。说明，没有任务需要提交，但是池中的任务没有完成，还没有超时(如果设置了超时)</span></span><br><span class="line">                    <span class="comment">// take() 方法会阻塞，直到有元素返回，说明有任务结束了</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        f = ecs.take();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 我感觉上面这一段并不是很好理解，这里简单说下。</span></span><br><span class="line"><span class="comment">                 * 1. 首先，这在一个 for 循环中，我们设想每一个任务都没那么快结束，</span></span><br><span class="line"><span class="comment">                 *     那么，每一次都会进到第一个分支，进行提交任务，直到将所有的任务都提交了</span></span><br><span class="line"><span class="comment">                 * 2. 任务都提交完成后，如果设置了超时，那么 for 循环其实进入了“一直检测是否超时”</span></span><br><span class="line"><span class="comment">                       这件事情上</span></span><br><span class="line"><span class="comment">                 * 3. 如果没有设置超时机制，那么不必要检测超时，那就会阻塞在 ecs.take() 方法上，</span></span><br><span class="line"><span class="comment">                       等待获取第一个执行结果</span></span><br><span class="line"><span class="comment">                 * 4. 如果所有的任务都执行失败，也就是说 future 都返回了，</span></span><br><span class="line"><span class="comment">                       但是 f.get() 抛出异常，那么从 active == 0 分支出去(感谢 newmicro 提出)</span></span><br><span class="line"><span class="comment">                         // 当然，这个需要看下面的 if 分支。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">                <span class="comment">// 有任务结束了</span></span><br><span class="line">                <span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</span><br><span class="line">                    --active;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 返回执行结果，如果有异常，都包装成 ExecutionException</span></span><br><span class="line">                        <span class="keyword">return</span> f.get();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ExecutionException eex) &#123;</span><br><span class="line">                        ee = eex;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException rex) &#123;</span><br><span class="line">                        ee = <span class="keyword">new</span> <span class="title class_">ExecutionException</span>(rex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">// 注意看 for 循环的范围，一直到这里</span></span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> (ee == <span class="literal">null</span>)</span><br><span class="line">                ee = <span class="keyword">new</span> <span class="title class_">ExecutionException</span>();</span><br><span class="line">            <span class="keyword">throw</span> ee;</span><br><span class="line">		</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 方法退出之前，取消其他的任务</span></span><br><span class="line">            <span class="keyword">for</span> (Future&lt;T&gt; f : futures)</span><br><span class="line">                f.cancel(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> doInvokeAny(tasks, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException cannotHappen) &#123;</span><br><span class="line">            <span class="keyword">assert</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                           <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">        <span class="keyword">return</span> doInvokeAny(tasks, <span class="literal">true</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行所有的任务，返回任务结果。</span></span><br><span class="line">    <span class="comment">// 先不要看这个方法，我们先想想，其实我们自己提交任务到线程池，也是想要线程池执行所有的任务</span></span><br><span class="line">    <span class="comment">// 只不过，我们是每次 submit 一个任务，这里以一个集合作为参数提交</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (tasks == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        List&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">done</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这个很简单</span></span><br><span class="line">            <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class="line">                <span class="comment">// 包装成 FutureTask</span></span><br><span class="line">                RunnableFuture&lt;T&gt; f = newTaskFor(t);</span><br><span class="line">                futures.add(f);</span><br><span class="line">                <span class="comment">// 提交任务</span></span><br><span class="line">                execute(f);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Future&lt;T&gt; f : futures) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 这是一个阻塞方法，直到获取到值，或抛出了异常</span></span><br><span class="line">                        <span class="comment">// 这里有个小细节，其实 get 方法签名上是会抛出 InterruptedException 的</span></span><br><span class="line">                        <span class="comment">// 可是这里没有进行处理，而是抛给外层去了。此异常发生于还没执行完的任务被取消了</span></span><br><span class="line">                        f.get();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            done = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 这个方法返回，不像其他的场景，返回 List&lt;Future&gt;，其实执行结果还没出来</span></span><br><span class="line">            <span class="comment">// 这个方法返回是真正的返回，任务都结束了</span></span><br><span class="line">            <span class="keyword">return</span> futures;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 为什么要这个？就是上面说的有异常的情况</span></span><br><span class="line">            <span class="keyword">if</span> (!done)</span><br><span class="line">                <span class="keyword">for</span> (Future&lt;T&gt; f : futures)</span><br><span class="line">                    f.cancel(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时的 invokeAll，我们找不同吧</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                                         <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (tasks == <span class="literal">null</span> || unit == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">        List&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">done</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks)</span><br><span class="line">                futures.add(newTaskFor(t));</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">lastTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"></span><br><span class="line">            Iterator&lt;Future&lt;T&gt;&gt; it = futures.iterator();</span><br><span class="line">            <span class="comment">// 每提交一个任务，检测一次是否超时</span></span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                execute((Runnable)(it.next()));</span><br><span class="line">                <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                nanos -= now - lastTime;</span><br><span class="line">                lastTime = now;</span><br><span class="line">                <span class="comment">// 超时</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> futures;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Future&lt;T&gt; f : futures) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> futures;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 调用带超时的 get 方法，这里的参数 nanos 是剩余的时间，</span></span><br><span class="line">                        <span class="comment">// 因为上面其实已经用掉了一些时间了</span></span><br><span class="line">                        f.get(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">                        <span class="keyword">return</span> futures;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    nanos -= now - lastTime;</span><br><span class="line">                    lastTime = now;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            done = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> futures;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!done)</span><br><span class="line">                <span class="keyword">for</span> (Future&lt;T&gt; f : futures)</span><br><span class="line">                    f.cancel(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，我们发现，这个抽象类包装了一些基本的方法，可是像 submit、invokeAny、invokeAll 等方法，它们都没有真正开启线程来执行任务，它们都只是在方法内部调用了 execute 方法，所以最重要的 execute(Runnable runnable) 方法还没出现，需要等具体执行器来实现这个最重要的部分，这里我们要说的就是 ThreadPoolExecutor 类了。</p>
<blockquote>
<p>鉴于本文的篇幅，我觉得看到这里的读者应该已经不多了，大家都习惯了快餐文化。我写的每篇文章都力求让读者可以通过我的一篇文章而对相关内容有全面的了解，所以篇幅不免长了些。</p>
</blockquote>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>ThreadPoolExecutor 是 JDK 中的线程池实现，这个类实现了一个线程池需要的各个方法，它实现了任务提交、线程管理、监控等等方法。</p>
<p>我们可以基于它来进行业务上的扩展，以实现我们需要的其他功能，比如实现定时任务的类 ScheduledThreadPoolExecutor 就继承自 ThreadPoolExecutor。当然，这不是本文关注的重点，下面，还是赶紧进行源码分析吧。</p>
<p>首先，我们来看看线程池实现中的几个概念和处理流程。</p>
<p>我们先回顾下提交任务的几个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个最基本的概念是，submit 方法中，参数是 Runnable 类型（也有Callable 类型），这个参数不是用于 new Thread(<strong>runnable</strong>).start() 中的，此处的这个参数不是用于启动线程的，这里指的是<strong>任务</strong>，任务要做的事情是 run() 方法里面定义的或 Callable 中的 call() 方法里面定义的。</p>
<p>初学者往往会搞混这个，因为 Runnable 总是在各个地方出现，经常把一个 Runnable 包到另一个 Runnable 中。请把它想象成有个 Task 接口，这个接口里面有一个 run() 方法。</p>
<p>我们回过神来继续往下看，我画了一个简单的示意图来描述线程池中的一些主要的构件：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/java-thread-pool/pool-1.png" alt="pool-1"></p>
<p>当然，上图没有考虑队列是否有界，提交任务时队列满了怎么办？什么情况下会创建新的线程？提交任务时线程池满了怎么办？空闲线程怎么关掉？这些问题下面我们会一一解决。</p>
<p>我们经常会使用 <code>Executors</code> 这个工具类来快速构造一个线程池，对于初学者而言，这种工具类是很有用的，开发者不需要关注太多的细节，只要知道自己需要一个线程池，仅仅提供必需的参数就可以了，其他参数都采用作者提供的默认值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先不说有什么区别，它们最终都会导向这个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="comment">// 这几个参数都是必须要有的</span></span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上，上面的构造方法中列出了我们最需要关心的几个属性了，下面逐个介绍下构造方法中出现的这几个属性：</p>
<ul>
<li><p>corePoolSize</p>
<blockquote>
<p>核心线程数，不要抠字眼，反正先记着有这么个属性就可以了。</p>
</blockquote>
</li>
<li><p>maximumPoolSize</p>
<blockquote>
<p>最大线程数，线程池允许创建的最大线程数。</p>
</blockquote>
</li>
<li><p>workQueue</p>
<blockquote>
<p>任务队列，BlockingQueue 接口的某个实现（常使用 ArrayBlockingQueue 和 LinkedBlockingQueue）。</p>
</blockquote>
</li>
<li><p>keepAliveTime</p>
<blockquote>
<p>空闲线程的保活时间，如果某线程的空闲时间超过这个值都没有任务给它做，那么可以被关闭了。注意这个值并不会对所有线程起作用，如果线程池中的线程数少于等于核心线程数 corePoolSize，那么这些线程不会因为空闲太长时间而被关闭，当然，也可以通过调用 <code>allowCoreThreadTimeOut(true)</code>使核心线程数内的线程也可以被回收。</p>
</blockquote>
</li>
<li><p>threadFactory</p>
<blockquote>
<p>用于生成线程，一般我们可以用默认的就可以了。通常，我们可以通过它将我们的线程的名字设置得比较可读一些，如 Message-Thread-1， Message-Thread-2 类似这样。</p>
</blockquote>
</li>
<li><p>handler：</p>
<blockquote>
<p>当线程池已经满了，但是又有新的任务提交的时候，该采取什么策略由这个来指定。有几种方式可供选择，像抛出异常、直接拒绝然后返回等，也可以自己实现相应的接口实现自己的逻辑，这个之后再说。</p>
</blockquote>
</li>
</ul>
<p>除了上面几个属性外，我们再看看其他重要的属性。</p>
<p>Doug Lea 采用一个 32 位的整数来存放线程池的状态和当前池中的线程数，其中高 3 位用于存放线程池状态，低 29 位表示线程数（即使只有 29 位，也已经不小了，大概 5 亿多，现在还没有哪个机器能起这么多线程的吧）。我们知道，java 语言在整数编码上是统一的，都是采用补码的形式，下面是简单的移位操作和布尔操作，都是挺简单的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里 COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数</span></span><br><span class="line"><span class="comment">// 很多初学者很喜欢在自己的代码中写很多 29 这种数字，或者某个特殊的字符串，然后分布在各个地方，这是非常糟糕的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 000 11111111111111111111111111111</span></span><br><span class="line"><span class="comment">// 这里得到的是 29 个 1，也就是说线程池的最大线程数是 2^29-1=536870911</span></span><br><span class="line"><span class="comment">// 以我们现在计算机的实际情况，这个数量还是够用的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们说了，线程池的状态存放在高 3 位中</span></span><br><span class="line"><span class="comment">// 运算结果为 111跟29个0：111 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 000 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 001 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 010 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 011 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将整数 c 的低 29 位修改为 0，就得到了线程池的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 将整数 c 的高 3 为修改为 0，就得到了线程池中的线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bit field accessors that don&#x27;t require unpacking ctl.</span></span><br><span class="line"><span class="comment"> * These depend on the bit layout and on workerCount being never negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateLessThan</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateAtLeast</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是对一个整数的简单的位操作，几个操作方法将会在后面的源码中一直出现，所以读者最好把方法名字和其代表的功能记住，看源码的时候也就不需要来来回回翻了。</p>
<p>在这里，介绍下线程池中的各个状态和状态变化的转换过程：</p>
<ul>
<li>RUNNING：这个没什么好说的，这是最正常的状态：接受新的任务，处理等待队列中的任务</li>
<li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务</li>
<li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程</li>
<li>TIDYING：所有的任务都销毁了，workCount 为 0。线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()</li>
<li>TERMINATED：terminated() 方法结束后，线程池的状态就会变成这个</li>
</ul>
<blockquote>
<p>RUNNING 定义为 -1，SHUTDOWN 定义为 0，其他的都比 0 大，所以等于 0 的时候不能提交任务，大于 0 的话，连正在执行的任务也需要中断。</p>
</blockquote>
<p>看了这几种状态的介绍，读者大体也可以猜到十之八九的状态转换了，各个状态的转换过程有以下几种：</p>
<ul>
<li>RUNNING -&gt; SHUTDOWN：当调用了 shutdown() 后，会发生这个状态转换，这也是最重要的</li>
<li>(RUNNING or SHUTDOWN) -&gt; STOP：当调用 shutdownNow() 后，会发生这个状态转换，这下要清楚 shutDown() 和 shutDownNow() 的区别了</li>
<li>SHUTDOWN -&gt; TIDYING：当任务队列和线程池都清空后，会由 SHUTDOWN 转换为 TIDYING</li>
<li>STOP -&gt; TIDYING：当任务队列清空后，发生这个转换</li>
<li>TIDYING -&gt; TERMINATED：这个前面说了，当 terminated() 方法结束后</li>
</ul>
<p>上面的几个记住核心的就可以了，尤其第一个和第二个。</p>
<p>另外，我们还要看看一个内部类 Worker，因为 Doug Lea 把线程池中的线程包装成了一个个 Worker，翻译成工人，就是线程池中做任务的线程。所以到这里，我们知道<strong>任务是 Runnable（内部变量名叫 task 或 command），线程是 Worker</strong>。</p>
<p>Worker 这里又用到了抽象类 AbstractQueuedSynchronizer。题外话，AQS 在并发中真的是到处出现，而且非常容易使用，写少量的代码就能实现自己需要的同步方式（对 AQS 源码感兴趣的读者请参看我之前写的几篇文章）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个是真正的线程，任务靠你啦</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前面说了，这里的 Runnable 是任务。为什么叫 firstTask？因为在创建线程的时候，如果同时指定了</span></span><br><span class="line">    <span class="comment">// 这个线程起来以后需要执行的第一个任务，那么第一个任务就是存放在这里的(线程可不止执行这一个任务)</span></span><br><span class="line">    <span class="comment">// 当然了，也可以为 null，这样线程起来了，自己到任务队列（BlockingQueue）中取任务（getTask 方法）就行了</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于存放此线程完成的任务数，注意了，这里用了 volatile，保证可见性</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Worker 只有这一个构造方法，传入 firstTask，也可以传 null</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 调用 ThreadFactory 来创建一个新的线程</span></span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里调用了外部类的 runWorker 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        runWorker(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...<span class="comment">// 其他几个方法没什么好看的，就是用 AQS 操作，来获取这个线程的执行权，用了独占锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面虽然啰嗦，但是简单。有了上面的这些基础后，我们终于可以看看 ThreadPoolExecutor 的 execute 方法了，前面源码分析的时候也说了，各种方法都最终依赖于 execute 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 前面说的那个表示 “线程池状态” 和 “线程数” 的整数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务，</span></span><br><span class="line">    <span class="comment">// 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 添加任务成功，那么就结束了。提交任务嘛，线程池已经接受了这个任务，这个方法也就可以返回了</span></span><br><span class="line">        <span class="comment">// 至于执行的结果，到时候会包装到 FutureTask 中。</span></span><br><span class="line">        <span class="comment">// 返回 false 代表线程池不允许提交任务</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">/* 这里面说的是，如果任务进入了 workQueue，我们是否需要开启新的线程</span></span><br><span class="line"><span class="comment">         * 因为线程数在 [0, corePoolSize) 是无条件开启新的线程</span></span><br><span class="line"><span class="comment">         * 如果线程数已经大于等于 corePoolSize，那么将任务添加到队列中，然后进到这里</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程</span></span><br><span class="line">        <span class="comment">// 到这里，我们知道了，这块代码的真正意图是：担心任务提交到队列中了，但是线程都关闭了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 workQueue 队列满了，那么进入到这个分支</span></span><br><span class="line">    <span class="comment">// 以 maximumPoolSize 为界创建新的 worker，</span></span><br><span class="line">    <span class="comment">// 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对创建线程的错误理解：如果线程数少于 corePoolSize，创建一个线程，如果线程数在 [corePoolSize, maximumPoolSize] 之间那么可以创建线程或复用空闲线程，keepAliveTime 对这个区间的线程有效。</p>
<p>从上面的几个分支，我们就可以看出，上面的这段话是错误的。</p>
</blockquote>
<p>上面这些一时半会也不可能全部消化搞定，我们先继续往下吧，到时候再回头看几遍。</p>
<p>这个方法非常重要 addWorker(Runnable firstTask, boolean core) 方法，我们看看它是怎么创建新的线程的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是准备提交给这个线程执行的任务，之前说了，可以为 null</span></span><br><span class="line"><span class="comment">// 第二个参数为 true 代表使用核心线程数 corePoolSize 作为创建线程的界限，也就说创建这个线程的时候，</span></span><br><span class="line"><span class="comment">// 		如果线程池中的线程总数已经达到 corePoolSize，那么不能响应这次创建线程的请求</span></span><br><span class="line"><span class="comment">// 		如果是 false，代表使用最大线程数 maximumPoolSize 作为界限</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个非常不好理解</span></span><br><span class="line">        <span class="comment">// 如果线程池已关闭，并满足以下条件之一，那么不创建新的 worker：</span></span><br><span class="line">        <span class="comment">// 1. 线程池状态大于 SHUTDOWN，其实也就是 STOP, TIDYING, 或 TERMINATED</span></span><br><span class="line">        <span class="comment">// 2. firstTask != null</span></span><br><span class="line">        <span class="comment">// 3. workQueue.isEmpty()</span></span><br><span class="line">        <span class="comment">// 简单分析下：</span></span><br><span class="line">        <span class="comment">// 还是状态控制的问题，当线程池处于 SHUTDOWN 的时候，不允许提交任务，但是已有的任务继续执行</span></span><br><span class="line">        <span class="comment">// 当状态大于 SHUTDOWN 时，不允许提交任务，且中断正在执行的任务</span></span><br><span class="line">        <span class="comment">// 多说一句：如果线程池处于 SHUTDOWN，但是 firstTask 为 null，且 workQueue 非空，那么是允许创建 worker 的</span></span><br><span class="line">        <span class="comment">// 这是因为 SHUTDOWN 的语义：不允许提交新的任务，但是要把已经进入到 workQueue 的任务执行完，所以在满足条件的基础上，是允许创建新的 Worker 的</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 如果成功，那么就是所有创建线程前的条件校验都满足了，准备创建线程执行任务了</span></span><br><span class="line">            <span class="comment">// 这里失败的话，说明有其他线程也在尝试往线程池中创建线程</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 由于有并发，重新再读取一下 ctl</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">            <span class="comment">// 正常如果是 CAS 失败的话，进到下一个里层的for循环就可以了</span></span><br><span class="line">            <span class="comment">// 可是如果是因为其他线程的操作，导致线程池的状态发生了变更，如有其他线程关闭了这个线程池</span></span><br><span class="line">            <span class="comment">// 那么需要回到外层的for循环</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 到这里，我们认为在当前这个时刻，可以开始创建线程来执行任务了，</span></span><br><span class="line"><span class="comment">     * 因为该校验的都校验了，至于以后会发生什么，那是以后的事，至少当前是满足条件的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// worker 是否已经启动</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 是否已将这个 worker 添加到 workers 这个 HashSet 中</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        <span class="comment">// 把 firstTask 传给 worker 的构造方法</span></span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="comment">// 取 worker 中的线程对象，之前说了，Worker的构造方法会调用 ThreadFactory 来创建一个新的线程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这个是整个线程池的全局锁，持有这个锁才能让下面的操作“顺理成章”，</span></span><br><span class="line">            <span class="comment">// 因为关闭一个线程池需要这个锁，至少我持有锁的期间，线程池不会被关闭</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 小于 SHUTTDOWN 那就是 RUNNING，这个自不必说，是最正常的情况</span></span><br><span class="line">                <span class="comment">// 如果等于 SHUTDOWN，前面说了，不接受新的任务，但是会继续执行等待队列中的任务</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// worker 里面的 thread 可不能是已经启动的</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    <span class="comment">// 加到 workers 这个 HashSet 中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="comment">// largestPoolSize 用于记录 workers 中的个数的最大值</span></span><br><span class="line">                    <span class="comment">// 因为 workers 是不断增加减少的，通过这个值可以知道线程池的大小曾经达到的最大值</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加成功的话，启动这个线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回线程是否启动成功</span></span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单看下 addWorkFailed 的处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// workers 中删除掉相应的 worker</span></span><br><span class="line"><span class="comment">// workCount 减 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addWorkerFailed</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="literal">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        <span class="comment">// rechecks for termination, in case the existence of this worker was holding up termination</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回过头来，继续往下走。我们知道，worker 中的线程 start 后，其 run 方法会调用 runWorker 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Worker 类的 run() 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    runWorker(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续往下看 runWorker 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此方法由 worker 线程启动后调用，这里用一个 while 循环来不断地从等待队列中获取任务并执行</span></span><br><span class="line"><span class="comment">// 前面说了，worker 在初始化的时候，可以指定 firstTask，那么第一个任务也就可以不需要从队列中获取</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 该线程的第一个任务(如果有的话)</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 循环调用 getTask 获取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            w.lock();          </span><br><span class="line">            <span class="comment">// 如果线程池状态大于等于 STOP，那么意味着该线程也要中断</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这是一个钩子方法，留给需要的子类实现</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 到这里终于可以执行任务了</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    <span class="comment">// 这里不允许抛出 Throwable，所以转换为 Error</span></span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 也是一个钩子方法，将 task 和异常作为参数，留给需要的子类实现</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 置空 task，准备 getTask 获取下一个任务</span></span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 累加完成的任务数</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                <span class="comment">// 释放掉 worker 的独占锁</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果到这里，需要执行线程关闭：</span></span><br><span class="line">        <span class="comment">// 1. 说明 getTask 返回 null，也就是说，队列中已经没有任务需要执行了，执行关闭</span></span><br><span class="line">        <span class="comment">// 2. 任务执行过程中发生了异常</span></span><br><span class="line">        <span class="comment">// 第一种情况，已经在代码处理了将 workCount 减 1，这个在 getTask 方法分析中会说</span></span><br><span class="line">        <span class="comment">// 第二种情况，workCount 没有进行处理，所以需要在 processWorkerExit 中处理</span></span><br><span class="line">        <span class="comment">// 限于篇幅，我不准备分析这个方法了，感兴趣的读者请自行分析源码</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看看 getTask() 是怎么获取任务的，这个方法写得真的很好，每一行都很简单，组合起来却所有的情况都想好了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此方法有三种可能：</span></span><br><span class="line"><span class="comment">// 1. 阻塞直到获取到任务返回。我们知道，默认 corePoolSize 之内的线程是不会被回收的，</span></span><br><span class="line"><span class="comment">//      它们会一直等待任务</span></span><br><span class="line"><span class="comment">// 2. 超时退出。keepAliveTime 起作用的时候，也就是如果这么多时间内都没有任务，那么应该执行关闭</span></span><br><span class="line"><span class="comment">// 3. 如果发生了以下条件，此方法必须返回 null:</span></span><br><span class="line"><span class="comment">//    - 池中有大于 maximumPoolSize 个 workers 存在(通过调用 setMaximumPoolSize 进行设置)</span></span><br><span class="line"><span class="comment">//    - 线程池处于 SHUTDOWN，而且 workQueue 是空的，前面说了，这种不再接受新的任务</span></span><br><span class="line"><span class="comment">//    - 线程池处于 STOP，不仅不接受新的线程，连 workQueue 中的线程也不再执行</span></span><br><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">  </span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line">        <span class="comment">// 两种可能</span></span><br><span class="line">        <span class="comment">// 1. rs == SHUTDOWN &amp;&amp; workQueue.isEmpty()</span></span><br><span class="line">        <span class="comment">// 2. rs &gt;= STOP</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">// CAS 操作，减少工作线程数</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> timed;      <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="comment">// 允许核心线程数内的线程回收，或当前线程数超过了核心线程数，那么有可能发生超时关闭</span></span><br><span class="line">            timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里 break，是为了不往下执行后一个 if (compareAndDecrementWorkerCount(c))</span></span><br><span class="line">            <span class="comment">// 两个 if 一起看：如果当前线程数 wc &gt; maximumPoolSize，或者超时，都返回 null</span></span><br><span class="line">            <span class="comment">// 那这里的问题来了，wc &gt; maximumPoolSize 的情况，为什么要返回 null？</span></span><br><span class="line">            <span class="comment">//    换句话说，返回 null 意味着关闭线程。</span></span><br><span class="line">            <span class="comment">// 那是因为有可能开发者调用了 setMaximumPoolSize() 将线程池的 maximumPoolSize 调小了，那么多余的 Worker 就需要被关闭</span></span><br><span class="line">            <span class="keyword">if</span> (wc &lt;= maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// compareAndDecrementWorkerCount(c) 失败，线程池中的线程数发生了改变</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// wc &lt;= maximumPoolSize 同时没有超时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 到 workQueue 中获取任务</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">// 如果此 worker 发生了中断，采取的方案是重试</span></span><br><span class="line">            <span class="comment">// 解释下为什么会发生中断，这个读者要去看 setMaximumPoolSize 方法。</span></span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 如果开发者将 maximumPoolSize 调小了，导致其小于当前的 workers 数量，</span></span><br><span class="line">            <span class="comment">// 那么意味着超出的部分线程要被关闭。重新进入 for 循环，自然会有部分线程会返回 null</span></span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，基本上也说完了整个流程，读者这个时候应该回到 execute(Runnable command) 方法，看看各个分支，我把代码贴过来一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 前面说的那个表示 “线程池状态” 和 “线程数” 的整数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务，</span></span><br><span class="line">    <span class="comment">// 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 添加任务成功，那么就结束了。提交任务嘛，线程池已经接受了这个任务，这个方法也就可以返回了</span></span><br><span class="line">        <span class="comment">// 至于执行的结果，到时候会包装到 FutureTask 中。</span></span><br><span class="line">        <span class="comment">// 返回 false 代表线程池不允许提交任务</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">/* 这里面说的是，如果任务进入了 workQueue，我们是否需要开启新的线程</span></span><br><span class="line"><span class="comment">         * 因为线程数在 [0, corePoolSize) 是无条件开启新的线程</span></span><br><span class="line"><span class="comment">         * 如果线程数已经大于等于 corePoolSize，那么将任务添加到队列中，然后进到这里</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程</span></span><br><span class="line">        <span class="comment">// 到这里，我们知道了，这块代码的真正意图是：担心任务提交到队列中了，但是线程都关闭了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 workQueue 队列满了，那么进入到这个分支</span></span><br><span class="line">    <span class="comment">// 以 maximumPoolSize 为界创建新的 worker，</span></span><br><span class="line">    <span class="comment">// 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面各个分支中，有两种情况会调用 reject(command) 来处理任务，因为按照正常的流程，线程池此时不能接受这个任务，所以需要执行我们的拒绝策略。接下来，我们说一说 ThreadPoolExecutor 中的拒绝策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="comment">// 执行拒绝策略</span></span><br><span class="line">    handler.rejectedExecution(command, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处的 handler 我们需要在构造线程池的时候就传入这个参数，它是 RejectedExecutionHandler 的实例。</p>
<p>RejectedExecutionHandler 在 ThreadPoolExecutor 中有四个已经定义好的实现类可供我们直接使用，当然，我们也可以实现自己的策略，不过一般也没有必要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只要线程池没有被关闭，那么由提交任务的线程自己来执行这个任务。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CallerRunsPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不管怎样，直接抛出 RejectedExecutionException 异常</span></span><br><span class="line"><span class="comment">// 这个是默认的策略，如果我们构造线程池的时候不传相应的 handler 的话，那就会指定使用这个</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AbortPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbortPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                             <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不做任何处理，直接忽略掉这个任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DiscardPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个相对霸道一点，如果线程池没有被关闭的话，</span></span><br><span class="line"><span class="comment">// 把队列队头的任务(也就是等待了最长时间的)直接扔掉，然后提交这个任务到等待队列中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DiscardOldestPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，ThreadPoolExecutor 的源码算是分析结束了。单纯从源码的难易程度来说，ThreadPoolExecutor 的源码还算是比较简单的，只是需要我们静下心来好好看看罢了。</p>
<h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>这节其实也不是分析 Executors 这个类，因为它仅仅是工具类，它的所有方法都是 static 的。</p>
<ul>
<li>生成一个固定大小的线程池：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最大线程数设置为与核心线程数相等，此时 keepAliveTime 设置为 0（因为这里它是没用的，即使不为 0，线程池默认也不会回收 corePoolSize 内的线程），任务队列采用 LinkedBlockingQueue，无界队列。</p>
<p>过程分析：刚开始，每提交一个任务都创建一个 worker，当 worker 的数量达到 nThreads 后，不再创建新的线程，而是把任务提交到 LinkedBlockingQueue 中，而且之后线程数始终为 nThreads。</p>
<ul>
<li>生成只有<strong>一个线程</strong>的固定线程池，这个更简单，和上面的一样，只要设置线程数为 1 就可以了：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>生成一个需要的时候就创建新的线程，同时可以复用之前创建的线程（如果这个线程当前没有任务）的线程池：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心线程数为 0，最大线程数为 Integer.MAX_VALUE，keepAliveTime 为 60 秒，任务队列采用 SynchronousQueue。</p>
<p>这种线程池对于任务可以比较快速地完成的情况有比较好的性能。如果线程空闲了 60 秒都没有任务，那么将关闭此线程并从线程池中移除。所以如果线程池空闲了很长时间也不会有问题，因为随着所有的线程都会被关闭，整个线程池不会占用任何的系统资源。</p>
<p>过程分析：我把 execute 方法的主体黏贴过来，让大家看得明白些。鉴于 corePoolSize 是 0，那么提交任务的时候，直接将任务提交到队列中，由于采用了 SynchronousQueue，所以如果是第一个任务提交的时候，offer 方法肯定会返回 false，因为此时没有任何 worker 对这个任务进行接收，那么将进入到最后一个分支来创建第一个 worker。之后再提交任务的话，取决于是否有空闲下来的线程对任务进行接收，如果有，会进入到第二个 if 语句块中，否则就是和第一个任务一样，进到最后的 else if 分支创建新线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"><span class="comment">// corePoolSize 为 0，所以不会进到这个 if 分支</span></span><br><span class="line"><span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// offer 如果有空闲线程刚好可以接收此任务，那么返回 true，否则返回 false</span></span><br><span class="line"><span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        reject(command);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">    reject(command);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SynchronousQueue 是一个比较特殊的 BlockingQueue，其本身不储存任何元素，它有一个虚拟队列（或虚拟栈），不管读操作还是写操作，如果当前队列中存储的是与当前操作相同模式的线程，那么当前操作也进入队列中等待；如果是相反模式，则配对成功，从当前队列中取队头节点。具体的信息，可以看我的另一篇关于 BlockingQueue 的文章。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我一向不喜欢写总结，因为我把所有需要表达的都写在正文中了，写小篇幅的总结并不能真正将话说清楚，本文的总结部分为准备面试的读者而写，希望能帮到面试者或者没有足够的时间看完全文的读者。</p>
<ol>
<li><p>java 线程池有哪些关键属性？</p>
<blockquote>
<p>corePoolSize，maximumPoolSize，workQueue，keepAliveTime，rejectedExecutionHandler</p>
<p>corePoolSize 到 maximumPoolSize 之间的线程会被回收，当然 corePoolSize 的线程也可以通过设置而得到回收（allowCoreThreadTimeOut(true)）。</p>
<p>workQueue 用于存放任务，添加任务的时候，如果当前线程数超过了 corePoolSize，那么往该队列中插入任务，线程池中的线程会负责到队列中拉取任务。</p>
<p>keepAliveTime 用于设置空闲时间，如果线程数超出了 corePoolSize，并且有些线程的空闲时间超过了这个值，会执行关闭这些线程的操作</p>
<p>rejectedExecutionHandler 用于处理当线程池不能执行此任务时的情况，默认有<strong>抛出 RejectedExecutionException 异常</strong>、<strong>忽略任务</strong>、<strong>使用提交任务的线程来执行此任务</strong>和<strong>将队列中等待最久的任务删除，然后提交此任务</strong>这四种策略，默认为抛出异常。</p>
</blockquote>
</li>
<li><p>说说线程池中的线程创建时机？</p>
<blockquote>
<ol>
<li>如果当前线程数少于 corePoolSize，那么提交任务的时候创建一个新的线程，并由这个线程执行这个任务；</li>
<li>如果当前线程数已经达到 corePoolSize，那么将提交的任务添加到队列中，等待线程池中的线程去队列中取任务；</li>
<li>如果队列已满，那么创建新的线程来执行任务，需要保证池中的线程数不会超过 maximumPoolSize，如果此时线程数超过了 maximumPoolSize，那么执行拒绝策略。</li>
</ol>
</blockquote>
<p>* 注意：如果将队列设置为无界队列，那么线程数达到 corePoolSize 后，其实线程数就不会再增长了。因为后面的任务直接往队列塞就行了，此时 maximumPoolSize 参数就没有什么意义。</p>
</li>
<li><p>Executors.newFixedThreadPool(…) 和 Executors.newCachedThreadPool() 构造出来的线程池有什么差别？</p>
<blockquote>
<p>细说太长，往上滑一点点，在 Executors 的小节进行了详尽的描述。</p>
</blockquote>
</li>
<li><p>任务执行过程中发生异常怎么处理？</p>
<blockquote>
<p>如果某个任务执行出现异常，那么执行任务的线程会被关闭，而不是继续接收其他任务。然后会启动一个新的线程来代替它。</p>
</blockquote>
</li>
<li><p>什么时候会执行拒绝策略？</p>
<blockquote>
<ol>
<li>workers 的数量达到了 corePoolSize（任务此时需要进入任务队列），任务入队成功，与此同时线程池被关闭了，而且关闭线程池并没有将这个任务出队，那么执行拒绝策略。这里说的是非常边界的问题，入队和关闭线程池并发执行，读者仔细看看 execute 方法是怎么进到第一个 reject(command) 里面的。</li>
<li>workers 的数量大于等于 corePoolSize，将任务加入到任务队列，可是队列满了，任务入队失败，那么准备开启新的线程，可是线程数已经达到 maximumPoolSize，那么执行拒绝策略。</li>
</ol>
</blockquote>
</li>
</ol>
<p>因为本文实在太长了，所以我没有说执行结果是怎么获取的，也没有说关闭线程池相关的部分，这个就留给读者吧。</p>
<p>本文篇幅是有点长，如果读者发现什么不对的地方，或者有需要补充的地方，请不吝提出，谢谢。</p>
<p>（全文完）</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/12/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>分布式锁</title>
    <url>/2024/10/03/distributed-lock/</url>
    <content><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>在应用开发中，特别是web工程开发，通常都是并发编程，不是多进程就是多线程。这种场景下极易出现线程并发性安全问题，此时不得不使用锁来解决问题。在多线程高并发场景下，为了保证资源的线程安全问题，jdk为我们提供了synchronized关键字和ReentrantLock可重入锁，但是它们只能保证一个工程内的线程安全。在分布式集群、微服务、云原生横行的当下，如何保证不同进程、不同服务、不同机器的线程安全问题，jdk并没有给我们提供既有的解决方案。此时，我们就必须借助于相关技术手动实现了。目前主流的实现有以下方式：</p>
<ol>
<li>基于mysql关系型实现</li>
<li>基于redis非关系型数据实现</li>
<li>基于zookeeper/etcd实现</li>
</ol>
<p>本课程将会全面深入、全程手撸代码式的讲解这三种分布式锁的实现。并深入源码讲解第三方分布式锁框架。</p>
<p>基础知识储备及技术要求： </p>
<p>​    开发工具：idea + jdk1.8<br>​    工程构建工具：maven<br>​    相关框架基础：SpringBoot SpringMVC Spring Mybatis（mybatis-plus） SpringData-Redis<br>​    数据库：mysql（InnoDB引擎 事务 锁机制） redis<br>​    负载均衡工具：nginx<br>​    压力测试工具：jmeter<br>​    其他：zookeeper lua脚本语言 JUC(java.util.concurrent相关背景知识) 微服务相关背景知识</p>
<h1 id="传统分布式锁"><a href="#传统分布式锁" class="headerlink" title="传统分布式锁"></a>传统分布式锁</h1><h2 id="从减库存聊起"><a href="#从减库存聊起" class="headerlink" title="从减库存聊起"></a>从减库存聊起</h2><p>多线程并发安全问题最典型的代表就是超卖现象</p>
<p>库存在并发量较大情况下很容易发生超卖现象，一旦发生超卖现象，就会出现多成交了订单而发不了货的情况。</p>
<p>场景：</p>
<p>​        商品S库存余量为5时，用户A和B同时来购买一个商品，此时查询库存数都为5，库存充足则开始减库存：</p>
<p>用户A：update db_stock set stock = stock - 1 where id = 1</p>
<p>用户B：update db_stock set stock = stock - 1 where id = 1</p>
<p>并发情况下，更新后的结果可能是4，而实际的最终库存量应该是3才对</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>建表语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `db_stock` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `product_code` varchar(255) DEFAULT NULL COMMENT &#x27;商品编号&#x27;,</span><br><span class="line">  `stock_code` varchar(255) DEFAULT NULL COMMENT &#x27;仓库编号&#x27;,</span><br><span class="line">  `count` int(11) DEFAULT NULL COMMENT &#x27;库存量&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p>表中数据如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606400425343.png" alt="1606400425343"></p>
<p>1001商品在001仓库有5000件库存。</p>
<p>创建分布式锁demo工程：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606393792456.png" alt="1606393792456"></p>
<p>创建好之后：</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606395123427.png" alt="1606395123427"></p>
<p>pom.xml如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.11.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>distributed-lock<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>distributed-lock<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>分布式锁demo工程<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.46<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>application.yml配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://172.16.116.100:3306/test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">172.16</span><span class="number">.116</span><span class="number">.100</span></span><br></pre></td></tr></table></figure>

<p>DistributedLockApplication启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.atguigu.distributedlock.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributedLockApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DistributedLockApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Stock实体类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@TableName(&quot;db_stock&quot;)</span><br><span class="line">public class Stock &#123;</span><br><span class="line"></span><br><span class="line">    @TableId</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    private String productCode;</span><br><span class="line"></span><br><span class="line">    private String stockCode;</span><br><span class="line"></span><br><span class="line">    private Integer count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StockMapper接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StockMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Stock&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="简单实现减库存"><a href="#简单实现减库存" class="headerlink" title="简单实现减库存"></a>简单实现减库存</h2><p>接下来咱们代码实操一下。</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606400144254.png" alt="1606400144254"></p>
<p>StockController：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;check/lock&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">checkAndLock</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.stockService.checkAndLock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;验库存并锁库存成功！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StockService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StockMapper stockMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAndLock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先查询库存是否充足</span></span><br><span class="line">        <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="built_in">this</span>.stockMapper.selectById(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再减库存</span></span><br><span class="line">        <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            stock.setCount(stock.getCount() - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.stockMapper.updateById(stock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606400294689.png" alt="1606400294689"></p>
<p>查看数据库：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606400340594.png" alt="1606400340594"></p>
<p>在浏览器中一个一个访问时，每访问一次，库存量减1，没有任何问题。</p>
<h2 id="演示超卖现象"><a href="#演示超卖现象" class="headerlink" title="演示超卖现象"></a>演示超卖现象</h2><p>接下来咱们使用jmeter压力测试工具，高并发下压测一下，添加线程组：并发100循环50次，即5000次请求。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606442946203.png" alt="1606442946203"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606443124589.png" alt="1606443124589"></p>
<p>给线程组添加HTTP Request请求：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606443172072.png" alt="1606443172072"></p>
<p>填写测试接口路径如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606443276322.png" alt="1606443276322"></p>
<p>再选择你想要的测试报表，例如这里选择聚合报告：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606443541407.png" alt="1606443541407"></p>
<p>启动测试，查看压力测试报告：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220313204754310.png" alt="image-20220313204754310"></p>
<ul>
<li>Label          取样器别名，如果勾选<strong>Include group name</strong> ，则会添加线程组的名称作为前缀</li>
<li># Samples      取样器运行次数</li>
<li>Average       请求（事务）的平均响应时间</li>
<li>Median        中位数</li>
<li>90% Line       90%用户响应时间</li>
<li>95% Line       90%用户响应时间</li>
<li>99% Line       90%用户响应时间</li>
<li>Min           最小响应时间</li>
<li>Max           最大响应时间</li>
<li>Error          错误率</li>
<li>Throughput     吞吐率</li>
<li>Received KB/sec  每秒收到的千字节</li>
<li>Sent KB/sec      每秒收到的千字节</li>
</ul>
<p>测试结果：请求总数5000次，平均请求时间37ms，中位数（50%）请求是在36ms内完成的，错误率0%，每秒钟平均吞吐量2568.1次。</p>
<p>查看mysql数据库剩余库存数：还有4870</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606445079298.png" alt="1606445079298"></p>
<p>此时如果还有人来下单，就会出现超卖现象（别人购买成功，而无货可发）。</p>
<h2 id="jvm锁问题演示"><a href="#jvm锁问题演示" class="headerlink" title="jvm锁问题演示"></a>jvm锁问题演示</h2><h3 id="添加jvm锁"><a href="#添加jvm锁" class="headerlink" title="添加jvm锁"></a>添加jvm锁</h3><p>使用jvm锁（synchronized关键字或者ReetrantLock）试试：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606448306438.png" alt="1606448306438"></p>
<p>重启tomcat服务，再次使用jmeter压力测试，效果如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220313212150451.png" alt="image-20220313212150451"></p>
<p>查看mysql数据库：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606448616499.png" alt="1606448616499"></p>
<p>并没有发生超卖现象，完美解决。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>添加synchronized关键字之后，StockService就具备了对象锁，由于添加了独占的排他锁，同一时刻只有一个请求能够获取到锁，并减库存。此时，所有请求只会one-by-one执行下去，也就不会发生超卖现象。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606448189738.png" alt="1606448189738"></p>
<h2 id="多服务问题"><a href="#多服务问题" class="headerlink" title="多服务问题"></a>多服务问题</h2><p>使用jvm锁在单工程单服务情况下确实没有问题，但是在集群情况下会怎样？</p>
<p>接下启动多个服务并使用nginx负载均衡，结构如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606453095867.png" alt="1606453095867"></p>
<p>启动三个服务（端口号分别8000 8100 8200），如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606468851705.png" alt="1606468851705"></p>
<h3 id="安装配置nginx"><a href="#安装配置nginx" class="headerlink" title="安装配置nginx"></a>安装配置nginx</h3><p>基于安装nginx：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span></span><br><span class="line">docker pull nginx:latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建nginx对应资源、日志及配置目录</span></span><br><span class="line">mkdir -p /opt/nginx/logs /opt/nginx/conf /opt/nginx/html</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先在conf目录下创建nginx.conf文件，配置内容参照下方</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再运行容器</span></span><br><span class="line">docker run -d -p 80:80 --name nginx -v /opt/nginx/html:/usr/share/nginx/html -v /opt/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /opt/nginx/logs:/var/log/nginx nginx</span><br></pre></td></tr></table></figure>

<p>nginx.conf配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/<span class="literal">error</span>.log <span class="literal">warn</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#include /etc/nginx/conf.d/*.conf;</span></span><br><span class="line">	</span><br><span class="line">	<span class="section">upstream</span> distributed &#123;</span><br><span class="line">		<span class="attribute">server</span> <span class="number">172.16.116.1:8000</span>;</span><br><span class="line">		<span class="attribute">server</span> <span class="number">172.16.116.1:8100</span>;</span><br><span class="line">		<span class="attribute">server</span> <span class="number">172.16.116.1:8200</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="section">server</span> &#123;</span><br><span class="line">		<span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">172.16.116.100</span>;</span><br><span class="line">		<span class="section">location</span> / &#123;</span><br><span class="line">			<span class="attribute">proxy_pass</span> http://distributed;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在浏览器中测试：172.16.116.100是我的nginx服务器地址</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606467613477.png" alt="1606467613477"></p>
<p>经过测试，通过nginx访问服务一切正常。</p>
<h3 id="Jmeter压力测试"><a href="#Jmeter压力测试" class="headerlink" title="Jmeter压力测试"></a>Jmeter压力测试</h3><p>注意：先把数据库库存量还原到5000。</p>
<p>参照之前的测试用例，再创建一个新的测试组：参数给之前一样</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606467848874.png" alt="1606467848874"></p>
<p>配置nginx的地址及 服务的访问路径如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606467953589.png" alt="1606467953589"></p>
<p>测试结果：性能只是略有提升。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220313215233371.png" alt="image-20220313215233371"></p>
<p>数据库库存剩余量如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606469161544.png" alt="1606469161544"></p>
<p>又出现了并发问题，即出现了超卖现象。</p>
<h2 id="mysql锁演示"><a href="#mysql锁演示" class="headerlink" title="mysql锁演示"></a>mysql锁演示</h2><p>除了使用jvm锁之外，还可以使用数据锁：<strong>悲观锁</strong> 或者 <strong>乐观锁</strong></p>
<ol>
<li><p>一个sql：直接更新时判断，在更新中判断库存是否大于0 </p>
<p>update table set surplus = (surplus - buyQuantity) where id = 1 and (surplus - buyQuantity) &gt; 0 ;</p>
</li>
<li><p>悲观锁：在读取数据时锁住那几行，其他对这几行的更新需要等到悲观锁结束时才能继续 。</p>
<p>select … for update</p>
</li>
<li><p>乐观锁：读取数据时不锁，更新时检查是否数据已经被更新过，如果是则取消当前更新进行重试。</p>
<p>version 或者 时间戳（CAS思想）。</p>
</li>
</ol>
<h3 id="一个sql"><a href="#一个sql" class="headerlink" title="一个sql"></a>一个sql</h3><p>略。。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>在MySQL的InnoDB中，预设的Tansaction isolation level 为REPEATABLE READ（可重读）</p>
<p><strong>在SELECT 的读取锁定主要分为两种方式：</strong></p>
<ul>
<li>SELECT … LOCK IN SHARE MODE　（共享锁）</li>
<li>SELECT … FOR UPDATE                     （悲观锁）</li>
</ul>
<p>这两种方式在事务(Transaction) 进行当中SELECT 到同一个数据表时，都必须等待其它事务数据被提交(Commit)后才会执行。</p>
<p>而主要的不同在于LOCK IN SHARE MODE 在有一方事务要Update 同一个表单时很容易造成死锁。</p>
<p>简单的说，如果SELECT 后面若要UPDATE 同一个表单，最好使用SELECT … FOR UPDATE。</p>
<p><strong>代码实现</strong></p>
<p>改造StockService：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606487086837.png" alt="1606487086837"></p>
<p>在StockeMapper中定义selectStockForUpdate方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StockMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Stock&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Stock <span class="title function_">selectStockForUpdate</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在StockMapper.xml中定义对应的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.atguigu.distributedlock.mapper.StockMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStockForUpdate&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.distributedlock.pojo.Stock&quot;</span>&gt;</span></span><br><span class="line">        select * from db_stock where id = #&#123;id&#125; for update</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>压力测试</strong></p>
<p>注意：测试之前，需要把库存量改成5000。压测数据如下：比jvm性能高很多，比无锁要低将近1倍</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606487362848.png" alt="1606487362848"></p>
<p>mysql数据库存：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606487554822.png" alt="1606487554822"></p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则重试。那么我们如何实现乐观锁呢</p>
<p>使用数据版本（Version）记录机制实现，这是乐观锁最常用的实现 方式。一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录 的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新。</p>
<p>给db_stock表添加version字段：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606489307266.png" alt="1606489307266"></p>
<p>对应也需要给Stock实体类添加version属性。此处略。。。。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAndLock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先查询库存是否充足</span></span><br><span class="line">    <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="built_in">this</span>.stockMapper.selectById(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再减库存</span></span><br><span class="line">    <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 获取版本号</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">version</span> <span class="operator">=</span> stock.getVersion();</span><br><span class="line"></span><br><span class="line">        stock.setCount(stock.getCount() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 每次更新 版本号 + 1</span></span><br><span class="line">        stock.setVersion(stock.getVersion() + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 更新之前先判断是否是之前查询的那个版本，如果不是重试</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.stockMapper.update(stock, <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;Stock&gt;().eq(<span class="string">&quot;id&quot;</span>, stock.getId()).eq(<span class="string">&quot;version&quot;</span>, version)) == <span class="number">0</span>) &#123;</span><br><span class="line">            checkAndLock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启后使用jmeter压力测试工具结果如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606491642613.png" alt="1606491642613"></p>
<p>修改测试参数如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606491689743.png" alt="1606491689743"></p>
<p>测试结果如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606491754596.png" alt="1606491754596"></p>
<p>说明乐观锁在并发量越大的情况下，性能越低（因为需要大量的重试）；并发量越小，性能越高。</p>
<h3 id="mysql锁总结"><a href="#mysql锁总结" class="headerlink" title="mysql锁总结"></a>mysql锁总结</h3><p>性能：一个sql &gt; 悲观锁 &gt; jvm锁 &gt; 乐观锁</p>
<p>如果追求极致性能、业务场景简单并且不需要记录数据前后变化的情况下。</p>
<p>​        优先选择：一个sql</p>
<p>如果写并发量较低（多读），争抢不是很激烈的情况下优先选择：乐观锁</p>
<p>如果写并发量较高，一般会经常冲突，此时选择乐观锁的话，会导致业务代码不间断的重试。</p>
<p>​        优先选择：mysql悲观锁</p>
<p>不推荐jvm本地锁。</p>
<h2 id="redis乐观锁"><a href="#redis乐观锁" class="headerlink" title="redis乐观锁"></a>redis乐观锁</h2><p>利用redis监听 + 事务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch stock</span><br><span class="line">multi</span><br><span class="line">set stock 5000</span><br><span class="line">exec</span><br></pre></td></tr></table></figure>

<p>如果执行过程中stock的值没有被其他链接改变，则执行成功</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220428200109930.png" alt="image-20220428200109930"></p>
<p>如果执行过程中stock的值被改变，则执行失败效果如下：</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220428200244567.png" alt="image-20220428200244567"></p>
<p>具体代码实现，只需要改造对应的service方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">SessionCallback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">            operations.watch(<span class="string">&quot;stock&quot;</span>);</span><br><span class="line">            <span class="comment">// 1. 查询库存信息</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">stock</span> <span class="operator">=</span> operations.opsForValue().get(<span class="string">&quot;stock&quot;</span>);</span><br><span class="line">            <span class="comment">// 2. 判断库存是否充足</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">st</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; (st = Integer.parseInt(stock.toString())) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 3. 扣减库存</span></span><br><span class="line">                operations.multi();</span><br><span class="line">                operations.opsForValue().set(<span class="string">&quot;stock&quot;</span>, String.valueOf(--st));</span><br><span class="line">                <span class="type">List</span> <span class="variable">exec</span> <span class="operator">=</span> operations.exec();</span><br><span class="line">                <span class="keyword">if</span> (exec == <span class="literal">null</span> || exec.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    deduct();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> exec;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>借助于redis中的命令setnx(key, value)，key不存在就新增，存在就什么都不做。同时有多个客户端发送setnx命令，只有一个客户端可以成功，返回1（true）；其他的客户端返回0（false）。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606626611922.png" alt="1606626611922"></p>
<ol>
<li>多个客户端同时获取锁（setnx）</li>
<li>获取成功，执行业务逻辑，执行完成释放锁（del）</li>
<li>其他客户端等待重试</li>
</ol>
<p>改造StockService方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StockMapper stockMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁setnx</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">        <span class="comment">// 重试：递归调用</span></span><br><span class="line">        <span class="keyword">if</span> (!lock)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="built_in">this</span>.deduct();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1. 查询库存信息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">stock</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 判断库存是否充足</span></span><br><span class="line">                <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.length() != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">st</span> <span class="operator">=</span> Integer.valueOf(stock);</span><br><span class="line">                    <span class="keyword">if</span> (st &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 3.扣减库存</span></span><br><span class="line">                        redisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, String.valueOf(--st));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 解锁</span></span><br><span class="line">                <span class="built_in">this</span>.redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，加锁也可以使用循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加锁，获取锁失败重试</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>))&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">40</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="built_in">this</span>.redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用Jmeter压力测试如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606736612201.png" alt="1606736612201"></p>
<h2 id="防死锁"><a href="#防死锁" class="headerlink" title="防死锁"></a>防死锁</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606702476465.png" alt="1606702476465"></p>
<p>问题：setnx刚刚获取到锁，当前服务器宕机，导致del释放锁无法执行，进而导致锁无法锁无法释放（死锁）</p>
<p>解决：给锁设置过期时间，自动释放锁。</p>
<p>设置过期时间两种方式：</p>
<ol>
<li>通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放）</li>
<li>使用set指令设置过期时间：set key value ex 3 nx（既达到setnx的效果，又设置了过期时间）</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220504102416597.png" alt="image-20220504102416597"></p>
<p>压力测试肯定也没有问题。</p>
<h2 id="防误删"><a href="#防误删" class="headerlink" title="防误删"></a>防误删</h2><p>问题：可能会释放其他服务器的锁。</p>
<p>场景：如果业务逻辑的执行时间是7s。执行流程如下</p>
<ol>
<li><p>index1业务逻辑没执行完，3秒后锁被自动释放。</p>
</li>
<li><p>index2获取到锁，执行业务逻辑，3秒后锁被自动释放。</p>
</li>
<li><p>index3获取到锁，执行业务逻辑</p>
</li>
<li><p>index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。</p>
<p>最终等于没锁的情况。</p>
</li>
</ol>
<p>解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606707959639.png" alt="1606707959639"></p>
<p>实现如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220504102714512.png" alt="image-20220504102714512"></p>
<p>问题：删除操作缺乏原子性。</p>
<p>场景：</p>
<ol>
<li>index1执行删除时，查询到的lock值确实和uuid相等</li>
<li>index1执行删除前，lock刚好过期时间已到，被redis自动释放</li>
<li>index2获取了lock</li>
<li>index1执行删除，此时会把index2的lock删除</li>
</ol>
<p>解决方案：没有一个命令可以同时做到判断 + 删除，所有只能通过其他方式实现（<strong>LUA脚本</strong>）</p>
<h2 id="redis中的lua脚本"><a href="#redis中的lua脚本" class="headerlink" title="redis中的lua脚本"></a>redis中的lua脚本</h2><h3 id="现实问题"><a href="#现实问题" class="headerlink" title="现实问题"></a>现实问题</h3><p>redis采用单线程架构，可以保证单个命令的原子性，但是无法保证一组命令在高并发场景下的原子性。例如：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606711874388.png" alt="1606711874388"></p>
<p>在串行场景下：A和B的值肯定都是3</p>
<p>在并发场景下：A和B的值可能在0-6之间。</p>
<p>极限情况下1：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606712580214.png" alt="1606712580214"></p>
<p>则A的结果是0，B的结果是3</p>
<p>极限情况下2：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606712697401.png" alt="1606712697401"></p>
<p>则A和B的结果都是6</p>
<p>如果redis客户端通过lua脚本把3个命令一次性发送给redis服务器，那么这三个指令就不会被其他客户端指令打断。Redis 也保证脚本会以原子性(atomic)的方式执行： 当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。 这和使用 MULTI/ EXEC 包围的事务很类似。 </p>
<p>但是MULTI/ EXEC方法来使用事务功能，将一组命令打包执行，无法进行业务逻辑的操作。这期间有某一条命令执行报错（例如给字符串自增），其他的命令还是会执行，并不会回滚。</p>
<h3 id="lua介绍"><a href="#lua介绍" class="headerlink" title="lua介绍"></a>lua介绍</h3><p>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p>
<p><strong>设计目的</strong></p>
<p>​    其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p>
<p><strong>Lua 特性</strong></p>
<ul>
<li><strong>轻量级</strong>：它用标准C语言编写并以源代码形式开放，编译后仅仅一百余K，可以很方便的嵌入别的程序里。</li>
<li><strong>可扩展</strong>：Lua提供了非常易于使用的扩展接口和机制：由宿主语言(通常是C或C++)提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。</li>
<li>其它特性：<ul>
<li>支持面向过程(procedure-oriented)编程和函数式编程(functional programming)；</li>
<li>自动内存管理；只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象；</li>
<li>语言内置模式匹配；闭包(closure)；函数也可以看做一个值；提供多线程（协同进程，并非操作系统所支持的线程）支持；</li>
<li>通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。</li>
</ul>
</li>
</ul>
<h3 id="lua基本语法"><a href="#lua基本语法" class="headerlink" title="lua基本语法"></a>lua基本语法</h3><p>对lua脚本感兴趣的同学，请移步到官方教程或者《菜鸟教程》。这里仅以redis中可能会用到的部分语法作介绍。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span>               <span class="comment">-- 全局变量</span></span><br><span class="line"><span class="keyword">local</span> b = <span class="number">5</span>         <span class="comment">-- 局部变量， redis只支持局部变量</span></span><br><span class="line">a, b = <span class="number">10</span>, <span class="number">2</span>*x      <span class="comment">-- 等价于       a=10; b=2*x</span></span><br></pre></td></tr></table></figure>

<p>流程控制：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( 布尔表达式 <span class="number">1</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 在布尔表达式 1 为 true 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">elseif</span>( 布尔表达式 <span class="number">2</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 在布尔表达式 2 为 true 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">   <span class="comment">--[ 如果以上布尔表达式都不为 true 则执行该语句块 --]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="redis执行lua脚本-EVAL指令"><a href="#redis执行lua脚本-EVAL指令" class="headerlink" title="redis执行lua脚本 - EVAL指令"></a>redis执行lua脚本 - EVAL指令</h3><p>在redis中需要通过eval命令执行lua脚本。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EVAL script numkeys key [key ...] arg [arg ...]</span><br><span class="line">script：lua脚本字符串，这段Lua脚本不需要（也不应该）定义函数。</span><br><span class="line">numkeys：lua脚本中KEYS数组的大小</span><br><span class="line">key [key ...]：KEYS数组中的元素</span><br><span class="line">arg [arg ...]：ARGV数组中的元素</span><br></pre></td></tr></table></figure>

<p>案例1：基本案例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EVAL &quot;return 10&quot; 0</span><br></pre></td></tr></table></figure>

<p>输出：(integer) 10</p>
<p>案例2：动态传参</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EVAL &quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot; 5 10 20 30 40 50 60 70 80 90</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出：10 20 60 70</span></span><br><span class="line"></span><br><span class="line">EVAL &quot;if KEYS[1] &gt; ARGV[1] then return 1 else return 0 end&quot; 1 10 20</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出：0</span></span><br><span class="line"></span><br><span class="line">EVAL &quot;if KEYS[1] &gt; ARGV[1] then return 1 else return 0 end&quot; 1 20 10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出：1</span></span><br></pre></td></tr></table></figure>

<p>传入了两个参数10和20，KEYS的长度是1，所以KEYS中有一个元素10，剩余的一个20就是ARGV数组的元素。</p>
<p>redis.call()中的redis是redis中提供的lua脚本类库，仅在redis环境中可以使用该类库。</p>
<p>案例3：执行redis类库方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set aaa 10  -- 设置一个aaa值为10</span><br><span class="line">EVAL &quot;return redis.call(&#x27;get&#x27;, &#x27;aaa&#x27;)&quot; 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过<span class="built_in">return</span>把call方法返回给redis客户端，打印：<span class="string">&quot;10&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>脚本里使用的所有键都应该由 KEYS 数组来传递。</strong>但并不是强制性的，代价是这样写出的脚本不能被 Redis 集群所兼容。</p>
<p>案例4：给redis类库方法动态传参</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EVAL &quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[1])&quot; 1 bbb 20</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1600610957600.png" alt="1600610957600"></p>
<p>学到这里基本可以应付redis分布式锁所需要的脚本知识了。</p>
<p>案例5：pcall函数的使用（了解）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- 当call() 在执行命令的过程中发生错误时，脚本会停止执行，并返回一个脚本错误，输出错误信息</span><br><span class="line">EVAL &quot;return redis.call(&#x27;sets&#x27;, KEYS[1], ARGV[1]), redis.call(&#x27;set&#x27;, KEYS[2], ARGV[2])&quot; 2 bbb ccc 20 30</span><br><span class="line">-- pcall函数不影响后续指令的执行</span><br><span class="line">EVAL &quot;return redis.pcall(&#x27;sets&#x27;, KEYS[1], ARGV[1]), redis.pcall(&#x27;set&#x27;, KEYS[2], ARGV[2])&quot; 2 bbb ccc 20 30</span><br></pre></td></tr></table></figure>

<p><strong>注意：set方法写成了sets</strong>，肯定会报错。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1600612707202.png" alt="1600612707202"></p>
<h2 id="使用lua保证删除原子性"><a href="#使用lua保证删除原子性" class="headerlink" title="使用lua保证删除原子性"></a>使用lua保证删除原子性</h2><p>删除LUA脚本：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span> <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]) <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="comment">// 加锁setnx</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, uuid, <span class="number">3</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        <span class="comment">// 重试：循环</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// this.redisTemplate.expire(&quot;lock&quot;, 3, TimeUnit.SECONDS);</span></span><br><span class="line">        <span class="comment">// 1. 查询库存信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">stock</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">st</span> <span class="operator">=</span> Integer.valueOf(stock);</span><br><span class="line">            <span class="keyword">if</span> (st &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 3.扣减库存</span></span><br><span class="line">                redisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, String.valueOf(--st));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 先判断是否自己的锁，再解锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] &quot;</span> +</span><br><span class="line">            <span class="string">&quot;then &quot;</span> +</span><br><span class="line">            <span class="string">&quot;   return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;else &quot;</span> +</span><br><span class="line">            <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">            <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(<span class="string">&quot;lock&quot;</span>), uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>压力测试，库存量也没有问题，截图略过。。。</p>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>由于上述加锁命令使用了 SETNX ，一旦键存在就无法再设置成功，这就导致后续同一线程内继续加锁，将会加锁失败。当一个线程执行一段代码成功获取锁之后，继续执行时，又遇到加锁的子任务代码，可重入性就保证线程能继续执行，而不可重入就是需要等待锁释放之后，再次获取锁成功，才能继续往下执行。</p>
<p>用一段 Java 代码解释可重入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// pass</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 X 线程在 a 方法获取锁之后，继续执行 b 方法，如果此时<strong>不可重入</strong>，线程就必须等待锁释放，再次争抢锁。</p>
<p>锁明明是被 X 线程拥有，却还需要等待自己释放锁，然后再去抢锁，这看起来就很奇怪，我释放我自己~</p>
<p>可重入性就可以解决这个尴尬的问题，当线程拥有锁之后，往后再遇到加锁方法，直接将加锁次数加 1，然后再执行方法逻辑。退出加锁方法之后，加锁次数再减 1，当加锁次数为 0 时，锁才被真正的释放。</p>
<p>可以看到可重入锁最大特性就是计数，计算加锁的次数。所以当可重入锁需要在分布式环境实现时，我们也就需要统计加锁次数。</p>
<p>解决方案：redis + Hash</p>
<h3 id="加锁脚本"><a href="#加锁脚本" class="headerlink" title="加锁脚本"></a>加锁脚本</h3><p>Redis 提供了 Hash （哈希表）这种可以存储键值对数据结构。所以我们可以使用 Redis Hash 存储的锁的重入次数，然后利用 lua 脚本判断逻辑。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span> <span class="keyword">or</span> redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]) == <span class="number">1</span>) </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>假设值为：KEYS:[lock], ARGV[uuid, expire]</p>
<p>如果锁不存在或者这是自己的锁，就通过hincrby（不存在就新增并加1，存在就加1）获取锁或者锁次数加1。</p>
<h3 id="解锁脚本"><a href="#解锁脚本" class="headerlink" title="解锁脚本"></a>解锁脚本</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 判断 hash set 可重入 key 的值是否等于 0</span></span><br><span class="line"><span class="comment">-- 如果为 nil 代表 自己的锁已不存在，在尝试解其他线程的锁，解锁失败</span></span><br><span class="line"><span class="comment">-- 如果为 0 代表 可重入次数被减 1</span></span><br><span class="line"><span class="comment">-- 如果为 1 代表 该可重入 key 解锁成功</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; </span><br><span class="line"><span class="keyword">elseif</span>(redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], <span class="number">-1</span>) &gt; <span class="number">0</span>) <span class="keyword">then</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>



<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>由于加解锁代码量相对较多，这里可以封装成一个工具类：</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220504095916188.png" alt="image-20220504095916188"></p>
<p>DistributedLockClient工厂类具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributedLockClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DistributedLockClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.uuid = UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DistributedRedisLock <span class="title function_">getRedisLock</span><span class="params">(String lockName)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DistributedRedisLock</span>(redisTemplate, lockName, uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DistributedRedisLock实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributedRedisLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">expire</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DistributedRedisLock</span><span class="params">(StringRedisTemplate redisTemplate, String lockName, String uuid)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.lockName = lockName;</span><br><span class="line">        <span class="built_in">this</span>.uuid = uuid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tryLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.tryLock(-<span class="number">1L</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (time != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.expire = unit.toSeconds(time);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;exists&#x27;, KEYS[1]) == 0 or redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return 1 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">this</span>.redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(lockName), getId(), String.valueOf(expire)))&#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return nil &quot;</span> +</span><br><span class="line">                <span class="string">&quot;elseif redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1) == 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="built_in">this</span>.redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Long.class), Arrays.asList(lockName), getId());</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>(<span class="string">&quot;this lock doesn&#x27;t belong to you!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给线程拼接唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getId</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uuid + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="使用及测试"><a href="#使用及测试" class="headerlink" title="使用及测试"></a>使用及测试</h3><p>在业务代码中使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DistributedRedisLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> <span class="built_in">this</span>.distributedLockClient.getRedisLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    redisLock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 查询库存信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">stock</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">st</span> <span class="operator">=</span> Integer.valueOf(stock);</span><br><span class="line">            <span class="keyword">if</span> (st &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 3.扣减库存</span></span><br><span class="line">                redisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, String.valueOf(--st));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        redisLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606747747780.png" alt="1606747747780"></p>
<p>测试可重入性：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220504101636357.png" alt="image-20220504101636357"></p>
<h2 id="自动续期"><a href="#自动续期" class="headerlink" title="自动续期"></a>自动续期</h2><p>lua脚本：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]) == <span class="number">1</span>) <span class="keyword">then</span> </span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>在RedisDistributeLock中添加renewExpire方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributedRedisLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">expire</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DistributedRedisLock</span><span class="params">(StringRedisTemplate redisTemplate, String lockName, String uuid)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.lockName = lockName;</span><br><span class="line">        <span class="built_in">this</span>.uuid = uuid + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tryLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.tryLock(-<span class="number">1L</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (time != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.expire = unit.toSeconds(time);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;exists&#x27;, KEYS[1]) == 0 or redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return 1 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">this</span>.redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(lockName), uuid, String.valueOf(expire)))&#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加锁成功，返回之前，开启定时器自动续期</span></span><br><span class="line">        <span class="built_in">this</span>.renewExpire();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return nil &quot;</span> +</span><br><span class="line">                <span class="string">&quot;elseif redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1) == 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="built_in">this</span>.redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Long.class), Arrays.asList(lockName), uuid);</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>(<span class="string">&quot;this lock doesn&#x27;t belong to you!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String getId()&#123;</span></span><br><span class="line">    <span class="comment">//     return this.uuid + &quot;:&quot; + Thread.currentThread().getId();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpire</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Timer</span>().schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(lockName), uuid, String.valueOf(expire))) &#123;</span><br><span class="line">                    renewExpire();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="built_in">this</span>.expire * <span class="number">1000</span> / <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在tryLock方法中使用：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220504100503780.png" alt="image-20220504100503780"></p>
<p>构造方法作如下修改：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220504100728343.png" alt="image-20220504100728343"></p>
<p>解锁方法作如下修改：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220504100850162.png" alt="image-20220504100850162"></p>
<h2 id="手写分步式锁小结"><a href="#手写分步式锁小结" class="headerlink" title="手写分步式锁小结"></a>手写分步式锁小结</h2><p>特征：</p>
<ol>
<li><p>独占排他：setnx</p>
</li>
<li><p>防死锁：</p>
<p>redis客户端程序获取到锁之后，立马宕机。给锁添加过期时间</p>
<p>不可重入：可重入</p>
</li>
<li><p>防误删：</p>
<p>先判断是否自己的锁才能删除</p>
</li>
<li><p>原子性：</p>
<p>加锁和过期时间之间：set k v ex 3 nx</p>
<p>判断和释放锁之间：lua脚本</p>
</li>
<li><p>可重入性：hash（key field value） + lua脚本 </p>
</li>
<li><p>自动续期：Timer定时器 + lua脚本</p>
</li>
<li><p>在集群情况下，导致锁机制失效：</p>
<ol>
<li>客户端程序10010，从主中获取锁</li>
<li>从还没来得及同步数据，主挂了</li>
<li>于是从升级为主</li>
<li>客户端程序10086就从新主中获取到锁，导致锁机制失效</li>
</ol>
</li>
</ol>
<p>锁操作：</p>
<p>加锁：</p>
<ol>
<li><p>setnx：独占排他   死锁、不可重入、原子性</p>
</li>
<li><p>set k v ex 30 nx：独占排他、死锁         不可重入 </p>
</li>
<li><p>hash + lua脚本：可重入锁</p>
<ol>
<li>判断锁是否被占用（exists），如果没有被占用则直接获取锁（hset/hincrby）并设置过期时间（expire）</li>
<li>如果锁被占用，则判断是否当前线程占用的（hexists），如果是则重入（hincrby）并重置过期时间（expire）</li>
<li>否则获取锁失败，将来代码中重试</li>
</ol>
</li>
<li><p>Timer定时器 + lua脚本：实现锁的自动续期</p>
<p>判断锁是否自己的锁（hexists == 1），如果是自己的锁则执行expire重置过期时间</p>
</li>
</ol>
<p>解锁 </p>
<ol>
<li>del：导致误删</li>
<li>先判断再删除同时保证原子性：lua脚本</li>
<li>hash + lua脚本：可重入 <pre><code>1. 判断当前线程的锁是否存在，不存在则返回nil，将来抛出异常
</code></pre>
<ol start="2">
<li>存在则直接减1（hincrby -1），判断减1后的值是否为0，为0则释放锁（del），并返回1</li>
<li>不为0，则返回0</li>
</ol>
</li>
</ol>
<p>重试：递归 循环 </p>
<h2 id="红锁算法"><a href="#红锁算法" class="headerlink" title="红锁算法"></a>红锁算法</h2><p>redis集群状态下的问题：</p>
<ol>
<li>客户端A从master获取到锁</li>
<li>在master将锁同步到slave之前，master宕掉了。</li>
<li>slave节点被晋级为master节点</li>
<li>客户端B取得了同一个资源被客户端A已经获取到的另外一个锁。</li>
</ol>
<p><strong>安全失效</strong>！</p>
<p>解决集群下锁失效，参照redis官方网站针对redlock文档：<a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a></p>
<p>在算法的分布式版本中，我们假设有N个Redis服务器。这些节点是完全独立的，因此我们不使用复制或任何其他隐式协调系统。<strong>前几节已经描述了如何在单个实例中安全地获取和释放锁，在分布式锁算法中，将使用相同的方法在单个实例中获取和释放锁。</strong>将N设置为5是一个合理的值，因此需要在不同的计算机或虚拟机上运行5个Redis主服务器，确保它们以独立的方式发生故障。</p>
<p>为了获取锁，客户端执行以下操作：</p>
<ol>
<li>客户端以毫秒为单位获取当前时间的时间戳，作为<strong>起始时间</strong>。</li>
<li>客户端尝试在所有N个实例中顺序使用相同的键名、相同的随机值来获取锁定。每个实例尝试获取锁都需要时间，客户端应该设置一个远小于总锁定时间的超时时间。例如，如果自动释放时间为10秒，则<strong>尝试获取锁的超时时间</strong>可能在5到50毫秒之间。这样可以防止客户端长时间与处于故障状态的Redis节点进行通信：如果某个实例不可用，尽快尝试与下一个实例进行通信。</li>
<li>客户端获取当前时间 减去在步骤1中获得的<strong>起始时间</strong>，来计算<strong>获取锁所花费的时间</strong>。当且仅当客户端能够在大多数实例（至少3个）中获取锁时，并且获取锁所花费的总时间小于锁有效时间，则认为已获取锁。</li>
<li>如果获取了锁，则将锁有效时间减去 <strong>获取锁所花费的时间</strong>，如步骤3中所计算。</li>
<li>如果客户端由于某种原因（无法锁定N / 2 + 1个实例或有效时间为负）而未能获得该锁，它将尝试解锁所有实例（即使没有锁定成功的实例）。</li>
</ol>
<p>每台计算机都有一个本地时钟，我们通常可以依靠不同的计算机来产生很小的时钟漂移。只有在拥有锁的客户端将在锁有效时间内（如步骤3中获得的）减去一段时间（仅几毫秒）的情况下终止工作，才能保证这一点。以补偿进程之间的时钟漂移</p>
<p>当客户端无法获取锁时，它应该在随机延迟后重试，以避免同时获取同一资源的多个客户端之间不同步（这可能会导致脑裂的情况：没人胜）。同样，客户端在大多数Redis实例中尝试获取锁的速度越快，出现裂脑情况（以及需要重试）的窗口就越小，因此理想情况下，客户端应尝试将SET命令发送到N个实例同时使用多路复用。</p>
<p>值得强调的是，对于未能获得大多数锁的客户端，尽快释放（部分）获得的锁有多么重要，这样就不必等待锁定期满才能再次获得锁（但是，如果发生了网络分区，并且客户端不再能够与Redis实例进行通信，则在等待密钥到期时需要付出可用性损失）。</p>
<h2 id="redisson中的分布式锁"><a href="#redisson中的分布式锁" class="headerlink" title="redisson中的分布式锁"></a>redisson中的分布式锁</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220501155501783.png" alt="image-20220501155501783"></p>
<p>​        Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish / Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1568176834908.png" alt="1568176834908"></p>
<p>官方文档地址：<a href="https://github.com/redisson/redisson/wiki">https://github.com/redisson/redisson/wiki</a></p>
<h3 id="2-1-可重入锁（Reentrant-Lock）"><a href="#2-1-可重入锁（Reentrant-Lock）" class="headerlink" title="2.1 可重入锁（Reentrant Lock）"></a>2.1 可重入锁（Reentrant Lock）</h3><p>基于Redis的Redisson分布式可重入锁<code>RLock</code> Java对象实现了<code>java.util.concurrent.locks.Lock</code>接口。</p>
<p>大家都知道，如果负责储存这个分布式锁的Redisson节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情况的发生，Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。默认情况下，看门狗检查锁的超时时间是30秒钟，也可以通过修改<code>Config.lockWatchdogTimeout</code>来另行指定。</p>
<p><code>RLock</code>对象完全符合Java的Lock规范。也就是说只有拥有锁的进程才能解锁，其他进程解锁则会抛出<code>IllegalMonitorStateException</code>错误。</p>
<p>另外Redisson还通过加锁的方法提供了<code>leaseTime</code>的参数来指定加锁的时间。超过这个时间后锁便自动解开了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line"><span class="comment">// 最常见的使用方法</span></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁以后10秒钟自动解锁</span></span><br><span class="line"><span class="comment">// 无需调用unlock方法手动解锁</span></span><br><span class="line">lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> lock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">if</span> (res) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>添加配置</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">// 可以用&quot;rediss://&quot;来启用SSL连接</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://172.16.116.100:6379&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>代码中使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAndLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁，获取锁失败重试</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.redissonClient.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先查询库存是否充足</span></span><br><span class="line">    <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="built_in">this</span>.stockMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">// 再减库存</span></span><br><span class="line">    <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        stock.setCount(stock.getCount() - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.stockMapper.updateById(stock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>压力测试</li>
</ol>
<p>性能跟我们手写的区别不大。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606958454966.png" alt="1606958454966"></p>
<p>数据库也没有问题</p>
<h3 id="2-1-公平锁（Fair-Lock）"><a href="#2-1-公平锁（Fair-Lock）" class="headerlink" title="2.1 公平锁（Fair Lock）"></a>2.1 公平锁（Fair Lock）</h3><p>基于Redis的Redisson分布式可重入公平锁也是实现了<code>java.util.concurrent.locks.Lock</code>接口的一种<code>RLock</code>对象。同时还提供了<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockAsync.html">异步（Async）</a>、<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockReactive.html">反射式（Reactive）</a>和<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockRx.html">RxJava2标准</a>的接口。它保证了当多个Redisson客户端线程同时请求加锁时，优先分配给先发出请求的线程。所有请求线程会在一个队列中排队，当某个线程出现宕机时，Redisson会等待5秒后继续下一个线程，也就是说如果前面有5个线程都处于等待状态，那么后面的线程会等待至少25秒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> redisson.getFairLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line"><span class="comment">// 最常见的使用方法</span></span><br><span class="line">fairLock.lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10秒钟以后自动解锁</span></span><br><span class="line"><span class="comment">// 无需调用unlock方法手动解锁</span></span><br><span class="line">fairLock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> fairLock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">fairLock.unlock();</span><br></pre></td></tr></table></figure>



<h3 id="2-1-联锁（MultiLock）"><a href="#2-1-联锁（MultiLock）" class="headerlink" title="2.1 联锁（MultiLock）"></a>2.1 联锁（MultiLock）</h3><p>基于Redis的Redisson分布式联锁<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/RedissonMultiLock.html"><code>RedissonMultiLock</code></a>对象可以将多个<code>RLock</code>对象关联为一个联锁，每个<code>RLock</code>对象实例可以来自于不同的Redisson实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock1</span> <span class="operator">=</span> redissonInstance1.getLock(<span class="string">&quot;lock1&quot;</span>);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock2</span> <span class="operator">=</span> redissonInstance2.getLock(<span class="string">&quot;lock2&quot;</span>);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock3</span> <span class="operator">=</span> redissonInstance3.getLock(<span class="string">&quot;lock3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">RedissonMultiLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonMultiLock</span>(lock1, lock2, lock3);</span><br><span class="line"><span class="comment">// 同时加锁：lock1 lock2 lock3</span></span><br><span class="line"><span class="comment">// 所有的锁都上锁成功才算成功。</span></span><br><span class="line">lock.lock();</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>



<h3 id="2-1-红锁（RedLock）"><a href="#2-1-红锁（RedLock）" class="headerlink" title="2.1 红锁（RedLock）"></a>2.1 红锁（RedLock）</h3><p>基于Redis的Redisson红锁<code>RedissonRedLock</code>对象实现了<a href="http://redis.cn/topics/distlock.html">Redlock</a>介绍的加锁算法。该对象也可以用来将多个<code>RLock</code>对象关联为一个红锁，每个<code>RLock</code>对象实例可以来自于不同的Redisson实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock1</span> <span class="operator">=</span> redissonInstance1.getLock(<span class="string">&quot;lock1&quot;</span>);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock2</span> <span class="operator">=</span> redissonInstance2.getLock(<span class="string">&quot;lock2&quot;</span>);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock3</span> <span class="operator">=</span> redissonInstance3.getLock(<span class="string">&quot;lock3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">RedissonRedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonRedLock</span>(lock1, lock2, lock3);</span><br><span class="line"><span class="comment">// 同时加锁：lock1 lock2 lock3</span></span><br><span class="line"><span class="comment">// 红锁在大部分节点上加锁成功就算成功。</span></span><br><span class="line">lock.lock();</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>



<h3 id="2-1-读写锁（ReadWriteLock）"><a href="#2-1-读写锁（ReadWriteLock）" class="headerlink" title="2.1 读写锁（ReadWriteLock）"></a>2.1 读写锁（ReadWriteLock）</h3><p>基于Redis的Redisson分布式可重入读写锁<a href="http://static.javadoc.io/org.redisson/redisson/3.4.3/org/redisson/api/RReadWriteLock.html"><code>RReadWriteLock</code></a> Java对象实现了<code>java.util.concurrent.locks.ReadWriteLock</code>接口。其中读锁和写锁都继承了<a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8#81-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81reentrant-lock">RLock</a>接口。</p>
<p>分布式可重入读写锁允许同时有多个读锁和一个写锁处于加锁状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RReadWriteLock</span> <span class="variable">rwlock</span> <span class="operator">=</span> redisson.getReadWriteLock(<span class="string">&quot;anyRWLock&quot;</span>);</span><br><span class="line"><span class="comment">// 最常见的使用方法</span></span><br><span class="line">rwlock.readLock().lock();</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">rwlock.writeLock().lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10秒钟以后自动解锁</span></span><br><span class="line"><span class="comment">// 无需调用unlock方法手动解锁</span></span><br><span class="line">rwlock.readLock().lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">rwlock.writeLock().lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> rwlock.readLock().tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> rwlock.writeLock().tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>



<p>添加StockController方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;test/read&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRead</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> stockService.testRead();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;测试读&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;test/write&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testWrite</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> stockService.testWrite();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;测试写&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>添加StockService方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">testRead</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="built_in">this</span>.redissonClient.getReadWriteLock(<span class="string">&quot;rwLock&quot;</span>);</span><br><span class="line">    rwLock.readLock().lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;测试读锁。。。。&quot;</span>);</span><br><span class="line">    <span class="comment">// rwLock.readLock().unlock();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testWrite</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="built_in">this</span>.redissonClient.getReadWriteLock(<span class="string">&quot;rwLock&quot;</span>);</span><br><span class="line">    rwLock.writeLock().lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;测试写锁。。。。&quot;</span>);</span><br><span class="line">    <span class="comment">// rwLock.writeLock().unlock();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>打开开两个浏览器窗口测试：</p>
<ul>
<li>同时访问写：一个写完之后，等待一会儿（约10s），另一个写开始</li>
<li>同时访问读：不用等待</li>
<li>先写后读：读要等待（约10s）写完成</li>
<li>先读后写：写要等待（约10s）读完成</li>
</ul>
<h3 id="2-10-6-信号量（Semaphore）"><a href="#2-10-6-信号量（Semaphore）" class="headerlink" title="2.10.6. 信号量（Semaphore）"></a>2.10.6. 信号量（Semaphore）</h3><p>基于Redis的Redisson的分布式信号量（<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphore.html">Semaphore</a>）Java对象<code>RSemaphore</code>采用了与<code>java.util.concurrent.Semaphore</code>相似的接口和用法。同时还提供了<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphoreAsync.html">异步（Async）</a>、<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphoreReactive.html">反射式（Reactive）</a>和<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphoreRx.html">RxJava2标准</a>的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RSemaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> redisson.getSemaphore(<span class="string">&quot;semaphore&quot;</span>);</span><br><span class="line">semaphore.trySetPermits(<span class="number">3</span>);</span><br><span class="line">semaphore.acquire();</span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure>



<p>在StockController添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;test/semaphore&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testSemaphore</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stockService.testSemaphore();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;测试信号量&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在StockService添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSemaphore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RSemaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="built_in">this</span>.redissonClient.getSemaphore(<span class="string">&quot;semaphore&quot;</span>);</span><br><span class="line">    semaphore.trySetPermits(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        semaphore.acquire();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        semaphore.release();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>添加测试用例：并发10次，循环一次</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606961296212.png" alt="1606961296212"></p>
<p>控制台效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">控制台1：</span><br><span class="line">1606960790234</span><br><span class="line">1606960800337</span><br><span class="line">1606960800443</span><br><span class="line">1606960805248</span><br><span class="line"></span><br><span class="line">控制台2：</span><br><span class="line">1606960790328</span><br><span class="line">1606960795332</span><br><span class="line">1606960800245</span><br><span class="line"></span><br><span class="line">控制台3：</span><br><span class="line">1606960790433</span><br><span class="line">1606960795238</span><br><span class="line">1606960795437</span><br></pre></td></tr></table></figure>



<p>由此可知：</p>
<p>1606960790秒有3次请求进来：每个控制台各1次</p>
<p>1606960795秒有3次请求进来：控制台2有1次，控制台3有2次</p>
<p>1606960800秒有3次请求进来：控制台1有2次，控制台2有1次</p>
<p>1606960805秒有1次请求进来：控制台1有1次</p>
<h3 id="2-1-闭锁（CountDownLatch）"><a href="#2-1-闭锁（CountDownLatch）" class="headerlink" title="2.1 闭锁（CountDownLatch）"></a>2.1 闭锁（CountDownLatch）</h3><p>基于Redisson的Redisson分布式闭锁（<a href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RCountDownLatch.html">CountDownLatch</a>）Java对象<code>RCountDownLatch</code>采用了与<code>java.util.concurrent.CountDownLatch</code>相似的接口和用法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RCountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> redisson.getCountDownLatch(<span class="string">&quot;anyCountDownLatch&quot;</span>);</span><br><span class="line">latch.trySetCount(<span class="number">1</span>);</span><br><span class="line">latch.await();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其他线程或其他JVM里</span></span><br><span class="line"><span class="type">RCountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> redisson.getCountDownLatch(<span class="string">&quot;anyCountDownLatch&quot;</span>);</span><br><span class="line">latch.countDown();</span><br></pre></td></tr></table></figure>

<p>需要两个方法：一个等待，一个计数countDown</p>
<p>给StockController添加测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;test/latch&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testLatch</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stockService.testLatch();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;班长锁门。。。&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;test/countdown&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testCountDown</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stockService.testCountDown();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;出来了一位同学&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>给StockService添加测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLatch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RCountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="built_in">this</span>.redissonClient.getCountDownLatch(<span class="string">&quot;latch&quot;</span>);</span><br><span class="line">    latch.trySetCount(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        latch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCountDown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RCountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="built_in">this</span>.redissonClient.getCountDownLatch(<span class="string">&quot;latch&quot;</span>);</span><br><span class="line">    latch.trySetCount(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    latch.countDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>重启测试，打开两个页面：当第二个请求执行6次之后，第一个请求才会执行。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606962536746.png" alt="1606962536746"></p>
<h1 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h1><p>实现分布式锁目前有三种流行方案，分别为基于数据库、Redis、Zookeeper的方案。这里主要介绍基于zk怎么实现分布式锁。在实现分布式锁之前，先回顾zookeeper的相关知识点</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220622191952608.png" alt="image-20220622191952608"></p>
<h2 id="知识点回顾"><a href="#知识点回顾" class="headerlink" title="知识点回顾"></a>知识点回顾</h2><h3 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h3><p>安装：把zk安装包上传到/opt目录下，并切换到/opt目录下，执行以下指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf zookeeper-3.7.0-bin.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重命名</span></span><br><span class="line">mv apache-zookeeper-3.7.0-bin/ zookeeper</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开zookeeper根目录</span></span><br><span class="line">cd /opt/zookeeper</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个数据目录，备用</span></span><br><span class="line">mkdir data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开zk的配置目录</span></span><br><span class="line">cd /opt/zookeeper/conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">copy配置文件，zk启动时会加载zoo.cfg文件</span></span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑配置文件</span></span><br><span class="line">vim zoo.cfg</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改dataDir参数为之前创建的数据目录：/opt/zookeeper/data</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到bin目录</span></span><br><span class="line">cd /opt/zookeeper/bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span> </span><br><span class="line">./zkServer.sh start</span><br><span class="line">./zkServer.sh status # 查看启动状态</span><br><span class="line">./zkServer.sh stop # 停止</span><br><span class="line">./zkServer.sh restart # 重启</span><br><span class="line">./zkCli.sh # 查看zk客户端</span><br></pre></td></tr></table></figure>

<p>如下，说明启动成功：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220501175644704.png" alt="image-20220501175644704"></p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>Zookeeper提供一个多层级的节点命名空间（节点称为znode），每个节点都用一个以斜杠（/）分隔的路径表示，而且每个节点都有父节点（根节点除外），非常类似于文件系统。并且每个节点都是唯一的。</p>
<p>znode节点有四种类型：</p>
<ul>
<li><strong>PERSISTENT</strong>：永久节点。客户端与zookeeper断开连接后，该节点依旧存在</li>
<li><strong>EPHEMERAL</strong>：临时节点。客户端与zookeeper断开连接后，该节点被删除</li>
<li><strong>PERSISTENT_SEQUENTIAL</strong>：永久节点、序列化。客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</li>
<li><strong>EPHEMERAL_SEQUENTIAL</strong>：临时节点、序列化。客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</li>
</ul>
<p>创建这四种节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] create /aa test  # 创建持久化节点</span><br><span class="line">Created /aa</span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] create -s /bb test  # 创建持久序列化节点</span><br><span class="line">Created /bb0000000001</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] create -e /cc test  # 创建临时节点</span><br><span class="line">Created /cc</span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] create -e -s /dd test  # 创建临时序列化节点</span><br><span class="line">Created /dd0000000003</span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /   # 查看某个节点下的子节点</span><br><span class="line">[aa, bb0000000001, cc, dd0000000003, zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] stat /  # 查看某个节点的状态</span><br><span class="line">cZxid = 0x0</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">pZxid = 0x5</span><br><span class="line">cversion = 3</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 5</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] get /aa  # 查看某个节点的内容</span><br><span class="line">test</span><br><span class="line">[zk: localhost:2181(CONNECTED) 11] delete /aa  # 删除某个节点</span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] ls /  # 再次查看</span><br><span class="line">[bb0000000001, cc, dd0000000003, zookeeper]</span><br></pre></td></tr></table></figure>



<p>事件监听：在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时，zookeeper会通知客户端。当前zookeeper针对节点的监听有如下四种事件：</p>
<ol>
<li><p>节点创建：stat -w /xx</p>
<p>当/xx节点创建时：NodeCreated</p>
</li>
<li><p>节点删除：stat -w /xx</p>
<p>当/xx节点删除时：NodeDeleted</p>
</li>
<li><p>节点数据修改：get -w /xx</p>
<p>当/xx节点数据发生变化时：NodeDataChanged</p>
</li>
<li><p>子节点变更：ls -w /xx</p>
<p>当/xx节点的子节点创建或者删除时：NodeChildChanged</p>
</li>
</ol>
<h3 id="java客户端"><a href="#java客户端" class="headerlink" title="java客户端"></a>java客户端</h3><p>ZooKeeper的java客户端有：原生客户端、ZkClient、Curator框架（类似于redisson，有很多功能性封装）。</p>
<ol>
<li>引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>常用api及其方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> KeeperException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取zookeeper链接</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">ZooKeeper</span> <span class="variable">zooKeeper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zooKeeper = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(<span class="string">&quot;172.16.116.100:2181&quot;</span>, <span class="number">30000</span>, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Event.KeeperState.SyncConnected.equals(event.getState()) </span><br><span class="line">                            &amp;&amp; Event.EventType.None.equals(event.getType())) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;获取链接成功。。。。。。&quot;</span> + event);</span><br><span class="line">                        countDownLatch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个节点，1-节点路径 2-节点内容 3-节点的访问权限 4-节点类型</span></span><br><span class="line">        <span class="comment">// OPEN_ACL_UNSAFE：任何人可以操作该节点</span></span><br><span class="line">        <span class="comment">// CREATOR_ALL_ACL：创建者拥有所有访问权限</span></span><br><span class="line">        <span class="comment">// READ_ACL_UNSAFE: 任何人都可以读取该节点</span></span><br><span class="line">        <span class="comment">// zooKeeper.create(&quot;/atguigu/aa&quot;, &quot;haha~~&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span></span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/test&quot;</span>, <span class="string">&quot;haha~~&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">        <span class="comment">// zooKeeper.create(&quot;/atguigu/cc&quot;, &quot;haha~~&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);</span></span><br><span class="line">        <span class="comment">// zooKeeper.create(&quot;/atguigu/dd&quot;, &quot;haha~~&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span></span><br><span class="line">        <span class="comment">// zooKeeper.create(&quot;/atguigu/dd&quot;, &quot;haha~~&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span></span><br><span class="line">        <span class="comment">// zooKeeper.create(&quot;/atguigu/dd&quot;, &quot;haha~~&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断节点是否存在</span></span><br><span class="line">        <span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> zooKeeper.exists(<span class="string">&quot;/test&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (stat != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前节点存在！&quot;</span> + stat.getVersion());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前节点不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断节点是否存在，同时添加监听</span></span><br><span class="line">        zooKeeper.exists(<span class="string">&quot;/test&quot;</span>, event -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取一个节点的数据</span></span><br><span class="line">        <span class="type">byte</span>[] data = zooKeeper.getData(<span class="string">&quot;/atguigu/ss0000000001&quot;</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询一个节点的所有子节点</span></span><br><span class="line">        List&lt;String&gt; children = zooKeeper.getChildren(<span class="string">&quot;/test&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        System.out.println(children);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        zooKeeper.setData(<span class="string">&quot;/test&quot;</span>, <span class="string">&quot;wawa...&quot;</span>.getBytes(), stat.getVersion());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除一个节点</span></span><br><span class="line">        <span class="comment">//zooKeeper.delete(&quot;/test&quot;, -1);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (zooKeeper != <span class="literal">null</span>)&#123;</span><br><span class="line">            zooKeeper.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>分布式锁的步骤：</p>
<ol>
<li>获取锁：create一个节点</li>
<li>删除锁：delete一个节点</li>
<li>重试：没有获取到锁的请求重试</li>
</ol>
<p>参照redis分布式锁的特点：</p>
<ol>
<li>互斥 排他</li>
<li>防死锁：<ol>
<li>可自动释放锁（临时节点） ：获得锁之后客户端所在机器宕机了，客户端没有主动删除子节点；如果创建的是永久的节点，那么这个锁永远不会释放，导致死锁；由于创建的是临时节点，客户端宕机后，过了一定时间zookeeper没有收到客户端的心跳包判断会话失效，将临时节点删除从而释放锁。</li>
<li>可重入锁：借助于ThreadLocal</li>
</ol>
</li>
<li>防误删：宕机自动释放临时节点，不需要设置过期时间，也就不存在误删问题。</li>
<li>加锁/解锁要具备原子性</li>
<li>单点问题：使用Zookeeper可以有效的解决单点问题，ZK一般是集群部署的。</li>
<li>集群问题：zookeeper集群是强一致性的，只要集群中有半数以上的机器存活，就可以对外提供服务。</li>
</ol>
<h2 id="基本实现-1"><a href="#基本实现-1" class="headerlink" title="基本实现"></a>基本实现</h2><p>实现思路：</p>
<ol>
<li>多个请求同时添加一个相同的临时节点，只有一个可以添加成功。添加成功的获取到锁</li>
<li>执行业务逻辑</li>
<li>完成业务流程后，删除节点释放锁。</li>
</ol>
<p>由于zookeeper获取链接是一个耗时过程，这里可以在项目启动时，初始化链接，并且只初始化一次。借助于spring特性，代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">connectString</span> <span class="operator">=</span> <span class="string">&quot;172.16.116.100:2181&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROOT_PATH</span> <span class="operator">=</span> <span class="string">&quot;/distributed&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 连接zookeeper服务器</span></span><br><span class="line">            <span class="built_in">this</span>.zooKeeper = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(connectString, <span class="number">30000</span>, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;获取链接成功！！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建分布式锁根节点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.zooKeeper.exists(ROOT_PATH, <span class="literal">false</span>) == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.zooKeeper.create(ROOT_PATH, <span class="literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;获取链接失败！&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (zooKeeper != <span class="literal">null</span>)&#123;</span><br><span class="line">                zooKeeper.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化zk分布式锁对象方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ZkDistributedLock <span class="title function_">getZkDistributedLock</span><span class="params">(String lockName)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ZkDistributedLock</span>(zooKeeper, lockName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>zk分布式锁具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkDistributedLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROOT_PATH</span> <span class="operator">=</span> <span class="string">&quot;/distributed&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZkDistributedLock</span><span class="params">(ZooKeeper zooKeeper, String lockName)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.zooKeeper = zooKeeper;</span><br><span class="line">        <span class="built_in">this</span>.path = ROOT_PATH + <span class="string">&quot;/&quot;</span> + lockName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zooKeeper.create(path, <span class="literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 重试</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                lock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.zooKeeper.delete(path, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>改造StockService的checkAndLock方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ZkClient client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAndLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁，获取锁失败重试</span></span><br><span class="line">    <span class="type">ZkDistributedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.client.getZkDistributedLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先查询库存是否充足</span></span><br><span class="line">    <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="built_in">this</span>.stockMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">// 再减库存</span></span><br><span class="line">    <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        stock.setCount(stock.getCount() - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.stockMapper.updateById(stock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Jmeter压力测试：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1607046072239.png" alt="1607046072239"></p>
<p>性能一般，mysql数据库的库存余量为0（注意：所有测试之前都要先修改库存量为5000）</p>
<p>基本实现存在的问题：</p>
<ol>
<li>性能一般（比mysql分布式锁略好）</li>
<li>不可重入</li>
</ol>
<p>接下来首先来提高性能</p>
<h2 id="优化：性能优化"><a href="#优化：性能优化" class="headerlink" title="优化：性能优化"></a>优化：性能优化</h2><p>基本实现中由于无限自旋影响性能：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1607048160051.png" alt="1607048160051"></p>
<p>试想：每个请求要想正常的执行完成，最终都是要创建节点，如果能够避免争抢必然可以提高性能。</p>
<p>这里借助于zk的临时序列化节点，实现分布式锁：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1607048783043.png" alt="1607048783043"></p>
<h3 id="实现阻塞锁"><a href="#实现阻塞锁" class="headerlink" title="实现阻塞锁"></a>实现阻塞锁</h3><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkDistributedLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROOT_PATH</span> <span class="operator">=</span> <span class="string">&quot;/distributed&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZkDistributedLock</span><span class="params">(ZooKeeper zooKeeper, String lockName)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.zooKeeper = zooKeeper;</span><br><span class="line">            <span class="built_in">this</span>.path = zooKeeper.create(ROOT_PATH + <span class="string">&quot;/&quot;</span> + lockName + <span class="string">&quot;-&quot;</span>, <span class="literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">preNode</span> <span class="operator">=</span> getPreNode(path);</span><br><span class="line">        <span class="comment">// 如果该节点没有前一个节点，说明该节点时最小节点，放行执行业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(preNode))&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新检查。是否获取到锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.zooKeeper.delete(path, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定节点的前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getPreNode</span><span class="params">(String path)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的序列化号</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">curSerial</span> <span class="operator">=</span> Long.valueOf(StringUtils.substringAfterLast(path, <span class="string">&quot;-&quot;</span>));</span><br><span class="line">            <span class="comment">// 获取根路径下的所有序列化子节点</span></span><br><span class="line">            List&lt;String&gt; nodes = <span class="built_in">this</span>.zooKeeper.getChildren(ROOT_PATH, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判空</span></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(nodes))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取前一个节点</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">preNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (String node : nodes) &#123;</span><br><span class="line">                <span class="comment">// 获取每个节点的序列化号</span></span><br><span class="line">                <span class="type">Long</span> <span class="variable">serial</span> <span class="operator">=</span> Long.valueOf(StringUtils.substringAfterLast(node, <span class="string">&quot;-&quot;</span>));</span><br><span class="line">                <span class="keyword">if</span> (serial &lt; curSerial &amp;&amp; serial &gt; flag)&#123;</span><br><span class="line">                    flag = serial;</span><br><span class="line">                    preNode = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> preNode;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>主要修改了构造方法和lock方法：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1607051823582.png" alt="1607051823582"></p>
<p>并添加了getPreNode获取前置节点的方法。</p>
<p>测试结果如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1607051896117.png" alt="1607051896117"></p>
<p>性能反而更弱了。</p>
<p>原因：虽然不用反复争抢创建节点了，但是会自旋判断自己是最小的节点，这个判断逻辑反而更复杂更耗时。</p>
<p>解决方案：监听。</p>
<h3 id="监听实现阻塞锁"><a href="#监听实现阻塞锁" class="headerlink" title="监听实现阻塞锁"></a>监听实现阻塞锁</h3><p>对于这个算法有个极大的优化点：假如当前有1000个节点在等待锁，如果获得锁的客户端释放锁时，这1000个客户端都会被唤醒，这种情况称为“羊群效应”；在这种羊群效应中，zookeeper需要通知1000个客户端，这会阻塞其他的操作，最好的情况应该只唤醒新的最小节点对应的客户端。应该怎么做呢？在设置事件监听时，每个客户端应该对刚好在它之前的子节点设置事件监听，例如子节点列表为/locks/lock-0000000000、/locks/lock-0000000001、/locks/lock-0000000002，序号为1的客户端监听序号为0的子节点删除消息，序号为2的监听序号为1的子节点删除消息。</p>
<p>所以调整后的分布式锁算法流程如下：</p>
<ul>
<li>客户端连接zookeeper，并在/lock下创建临时的且有序的子节点，第一个客户端对应的子节点为/locks/lock-0000000000，第二个为/locks/lock-0000000001，以此类推；</li>
<li>客户端获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，<strong>否则监听刚好在自己之前一位的子节点删除消息</strong>，获得子节点变更通知后重复此步骤直至获得锁；</li>
<li>执行业务代码；</li>
<li>完成业务流程后，删除对应的子节点释放锁。</li>
</ul>
<p>改造ZkDistributedLock的lock方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">preNode</span> <span class="operator">=</span> getPreNode(path);</span><br><span class="line">        <span class="comment">// 如果该节点没有前一个节点，说明该节点时最小节点，放行执行业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(preNode))&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.zooKeeper.exists(ROOT_PATH + <span class="string">&quot;/&quot;</span> + preNode, <span class="keyword">new</span> <span class="title class_">Watcher</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 阻塞。。。。</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// 重新检查。是否获取到锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        lock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>压力测试效果如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1607052541669.png" alt="1607052541669"></p>
<p>由此可见性能提高不少，接近于redis的分布式锁</p>
<h2 id="优化：可重入锁"><a href="#优化：可重入锁" class="headerlink" title="优化：可重入锁"></a>优化：可重入锁</h2><p>引入ThreadLocal线程局部变量保证zk分布式锁的可重入性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkDistributedLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROOT_PATH</span> <span class="operator">=</span> <span class="string">&quot;/distributed&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; THREAD_LOCAL = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZkDistributedLock</span><span class="params">(ZooKeeper zooKeeper, String lockName)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.zooKeeper = zooKeeper;</span><br><span class="line">            <span class="keyword">if</span> (THREAD_LOCAL.get() == <span class="literal">null</span> || THREAD_LOCAL.get() == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.path = zooKeeper.create(ROOT_PATH + <span class="string">&quot;/&quot;</span> + lockName + <span class="string">&quot;-&quot;</span>, <span class="literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">flag</span> <span class="operator">=</span> THREAD_LOCAL.get();</span><br><span class="line">        <span class="keyword">if</span> (flag != <span class="literal">null</span> &amp;&amp; flag &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            THREAD_LOCAL.set(flag + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">preNode</span> <span class="operator">=</span> getPreNode(path);</span><br><span class="line">            <span class="comment">// 如果该节点没有前一个节点，说明该节点时最小节点，放行执行业务逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(preNode))&#123;</span><br><span class="line">                THREAD_LOCAL.set(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.zooKeeper.exists(ROOT_PATH + <span class="string">&quot;/&quot;</span> + preNode, <span class="keyword">new</span> <span class="title class_">Watcher</span>()&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">                        countDownLatch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    THREAD_LOCAL.set(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 阻塞。。。。</span></span><br><span class="line">                countDownLatch.await();</span><br><span class="line">                THREAD_LOCAL.set(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">// 重新检查。是否获取到锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            lock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            THREAD_LOCAL.set(THREAD_LOCAL.get() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (THREAD_LOCAL.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.zooKeeper.delete(path, <span class="number">0</span>);</span><br><span class="line">                THREAD_LOCAL.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定节点的前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getPreNode</span><span class="params">(String path)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的序列化号</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">curSerial</span> <span class="operator">=</span> Long.valueOf(StringUtils.substringAfterLast(path, <span class="string">&quot;-&quot;</span>));</span><br><span class="line">            <span class="comment">// 获取根路径下的所有序列化子节点</span></span><br><span class="line">            List&lt;String&gt; nodes = <span class="built_in">this</span>.zooKeeper.getChildren(ROOT_PATH, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判空</span></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(nodes))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取前一个节点</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">preNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (String node : nodes) &#123;</span><br><span class="line">                <span class="comment">// 获取每个节点的序列化号</span></span><br><span class="line">                <span class="type">Long</span> <span class="variable">serial</span> <span class="operator">=</span> Long.valueOf(StringUtils.substringAfterLast(node, <span class="string">&quot;-&quot;</span>));</span><br><span class="line">                <span class="keyword">if</span> (serial &lt; curSerial &amp;&amp; serial &gt; flag)&#123;</span><br><span class="line">                    flag = serial;</span><br><span class="line">                    preNode = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> preNode;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="zk分布式锁小结"><a href="#zk分布式锁小结" class="headerlink" title="zk分布式锁小结"></a>zk分布式锁小结</h2><p>参照redis分布式锁的特点：</p>
<ol>
<li>互斥 排他：zk节点的不可重复性，以及序列化节点的有序性</li>
<li>防死锁：<ol>
<li>可自动释放锁：临时节点</li>
<li>可重入锁：借助于ThreadLocal</li>
</ol>
</li>
<li>防误删：临时节点</li>
<li>加锁/解锁要具备原子性</li>
<li>单点问题：使用Zookeeper可以有效的解决单点问题，ZK一般是集群部署的。</li>
<li>集群问题：zookeeper集群是强一致性的，只要集群中有半数以上的机器存活，就可以对外提供服务。</li>
<li>公平锁：有序性节点</li>
</ol>
<h2 id="Curator中的分布式锁"><a href="#Curator中的分布式锁" class="headerlink" title="Curator中的分布式锁"></a>Curator中的分布式锁</h2><p>Curator是netflix公司开源的一套zookeeper客户端，目前是Apache的顶级项目。与Zookeeper提供的原生客户端相比，Curator的抽象层次更高，简化了Zookeeper客户端的开发量。Curator解决了很多zookeeper客户端非常底层的细节开发工作，包括连接重连、反复注册wathcer和NodeExistsException 异常等。</p>
<p>通过查看官方文档，可以发现Curator主要解决了三类问题：</p>
<ul>
<li>封装ZooKeeper client与ZooKeeper server之间的连接处理</li>
<li>提供了一套Fluent风格的操作API</li>
<li>提供ZooKeeper各种应用场景(recipe， 比如：分布式锁服务、集群领导选举、共享计数器、缓存机制、分布式队列等)的抽象封装，这些实现都遵循了zk的最佳实践，并考虑了各种极端情况</li>
</ul>
<p>Curator由一系列的模块构成，对于一般开发者而言，常用的是curator-framework和curator-recipes：</p>
<ul>
<li>curator-framework：提供了常见的zk相关的底层操作</li>
<li>curator-recipes：提供了一些zk的典型使用场景的参考。本节重点关注的分布式锁就是该包提供的</li>
</ul>
<p>引入依赖：</p>
<p>最新版本的curator 4.3.0支持zookeeper 3.4.x和3.5，但是需要注意curator传递进来的依赖，需要和实际服务器端使用的版本相符，以我们目前使用的zookeeper 3.4.14为例。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加curator客户端配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CuratorConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CuratorFramework <span class="title function_">curatorFramework</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 重试策略，这里使用的是指数补偿重试策略，重试3次，初始重试间隔1000ms，每次重试之后重试间隔递增。</span></span><br><span class="line">        <span class="type">RetryPolicy</span> <span class="variable">retry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 初始化Curator客户端：指定链接信息 及 重试策略</span></span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;172.16.116.100:2181&quot;</span>, retry);</span><br><span class="line">        client.start(); <span class="comment">// 开始链接，如果不调用该方法，很多方法无法工作</span></span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="可重入锁InterProcessMutex"><a href="#可重入锁InterProcessMutex" class="headerlink" title="可重入锁InterProcessMutex"></a>可重入锁InterProcessMutex</h3><p>Reentrant和JDK的ReentrantLock类似， 意味着同一个客户端在拥有锁的同时，可以多次获取，不会被阻塞。它是由类<strong>InterProcessMutex</strong>来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常用构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessMutex</span><span class="params">(CuratorFramework client, String path)</span></span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 带超时时间的可重入锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquire</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span>;</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><p>改造service测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CuratorFramework curatorFramework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAndLock</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">InterProcessMutex</span> <span class="variable">mutex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(curatorFramework, <span class="string">&quot;/curator/lock&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        mutex.acquire();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先查询库存是否充足</span></span><br><span class="line">        <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="built_in">this</span>.stockMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">        <span class="comment">// 再减库存</span></span><br><span class="line">        <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            stock.setCount(stock.getCount() - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.stockMapper.updateById(stock);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// this.testSub(mutex);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        mutex.release();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSub</span><span class="params">(InterProcessMutex mutex)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mutex.acquire();</span><br><span class="line">    	System.out.println(<span class="string">&quot;测试可重入锁。。。。&quot;</span>);</span><br><span class="line">        mutex.release();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意：<strong>如想重入，则需要使用同一个InterProcessMutex对象。</strong></p>
<p>压力测试结果：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1607069431523.png" alt="1607069431523"></p>
<h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><h3 id="不可重入锁InterProcessSemaphoreMutex"><a href="#不可重入锁InterProcessSemaphoreMutex" class="headerlink" title="不可重入锁InterProcessSemaphoreMutex"></a>不可重入锁InterProcessSemaphoreMutex</h3><p>具体实现：InterProcessSemaphoreMutex。与InterProcessMutex调用方法类似，区别在于该锁是不可重入的，在同一个线程中不可重入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessSemaphoreMutex</span><span class="params">(CuratorFramework client, String path)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquire</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CuratorFramework curatorFramework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">InterProcessSemaphoreMutex</span> <span class="variable">mutex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessSemaphoreMutex</span>(curatorFramework, <span class="string">&quot;/curator/lock&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mutex.acquire();</span><br><span class="line">        <span class="comment">// 1. 查询库存信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">stock</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">st</span> <span class="operator">=</span> Integer.valueOf(stock);</span><br><span class="line">            <span class="keyword">if</span> (st &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 3.扣减库存</span></span><br><span class="line">                redisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, String.valueOf(--st));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mutex.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="可重入读写锁InterProcessReadWriteLock"><a href="#可重入读写锁InterProcessReadWriteLock" class="headerlink" title="可重入读写锁InterProcessReadWriteLock"></a>可重入读写锁InterProcessReadWriteLock</h3><p>类似JDK的ReentrantReadWriteLock。一个拥有写锁的线程可重入读锁，但是读锁却不能进入写锁。这也意味着写锁可以降级成读锁。从读锁升级成写锁是不成的。主要实现类InterProcessReadWriteLock：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessReadWriteLock</span><span class="params">(CuratorFramework client, String basePath)</span>;</span><br><span class="line"><span class="comment">// 获取读锁对象</span></span><br><span class="line">InterProcessMutex <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 获取写锁对象</span></span><br><span class="line">InterProcessMutex <span class="title function_">writeLock</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>写锁在释放之前会一直阻塞请求线程，而读锁不会</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZkReadLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InterProcessReadWriteLock</span> <span class="variable">rwlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessReadWriteLock</span>(curatorFramework, <span class="string">&quot;/curator/rwlock&quot;</span>);</span><br><span class="line">        rwlock.readLock().acquire(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// TODO：一顿读的操作。。。。</span></span><br><span class="line">        <span class="comment">//rwlock.readLock().unlock();</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZkWriteLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InterProcessReadWriteLock</span> <span class="variable">rwlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessReadWriteLock</span>(curatorFramework, <span class="string">&quot;/curator/rwlock&quot;</span>);</span><br><span class="line">        rwlock.writeLock().acquire(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// TODO：一顿写的操作。。。。</span></span><br><span class="line">        <span class="comment">//rwlock.writeLock().unlock();</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="联锁InterProcessMultiLock"><a href="#联锁InterProcessMultiLock" class="headerlink" title="联锁InterProcessMultiLock"></a>联锁InterProcessMultiLock</h3><p>Multi Shared Lock是一个锁的容器。当调用acquire， 所有的锁都会被acquire，如果请求失败，所有的锁都会被release。同样调用release时所有的锁都被release(失败被忽略)。基本上，它就是组锁的代表，在它上面的请求释放操作都会传递给它包含的所有的锁。实现类InterProcessMultiLock：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数需要包含的锁的集合，或者一组ZooKeeper的path</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessMultiLock</span><span class="params">(List&lt;InterProcessLock&gt; locks)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessMultiLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; paths)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquire</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<h3 id="信号量InterProcessSemaphoreV2"><a href="#信号量InterProcessSemaphoreV2" class="headerlink" title="信号量InterProcessSemaphoreV2"></a>信号量InterProcessSemaphoreV2</h3><p>一个计数的信号量类似JDK的Semaphore。JDK中Semaphore维护的一组许可(permits)，而Cubator中称之为租约(Lease)。注意，所有的实例必须使用相同的numberOfLeases值。调用acquire会返回一个租约对象。客户端必须在finally中close这些租约对象，否则这些租约会丢失掉。但是，如果客户端session由于某种原因比如crash丢掉， 那么这些客户端持有的租约会自动close， 这样其它客户端可以继续使用这些租约。主要实现类InterProcessSemaphoreV2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessSemaphoreV2</span><span class="params">(CuratorFramework client, String path, <span class="type">int</span> maxLeases)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意一次你可以请求多个租约，如果Semaphore当前的租约不够，则请求线程会被阻塞。</span></span><br><span class="line"><span class="comment">// 同时还提供了超时的重载方法</span></span><br><span class="line"><span class="keyword">public</span> Lease <span class="title function_">acquire</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> Collection&lt;Lease&gt; <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> qty)</span>;</span><br><span class="line"><span class="keyword">public</span> Lease <span class="title function_">acquire</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span>;</span><br><span class="line"><span class="keyword">public</span> Collection&lt;Lease&gt; <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> qty, <span class="type">long</span> time, TimeUnit unit)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 租约还可以通过下面的方式返还</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnAll</span><span class="params">(Collection&lt;Lease&gt; leases)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnLease</span><span class="params">(Lease lease)</span>;</span><br></pre></td></tr></table></figure>



<p>案例代码：</p>
<p>StockController中添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;test/semaphore&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testSemaphore</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stockService.testSemaphore();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello Semaphore&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StockService中添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSemaphore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置资源量 限流的线程数</span></span><br><span class="line">    <span class="type">InterProcessSemaphoreV2</span> <span class="variable">semaphoreV2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessSemaphoreV2</span>(curatorFramework, <span class="string">&quot;/locks/semaphore&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Lease</span> <span class="variable">acquire</span> <span class="operator">=</span> semaphoreV2.acquire();<span class="comment">// 获取资源，获取资源成功的线程可以继续处理业务操作。否则会被阻塞住</span></span><br><span class="line">        <span class="built_in">this</span>.redisTemplate.opsForList().rightPush(<span class="string">&quot;log&quot;</span>, <span class="string">&quot;10010获取了资源，开始处理业务逻辑。&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span> + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>));</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate.opsForList().rightPush(<span class="string">&quot;log&quot;</span>, <span class="string">&quot;10010处理完业务逻辑，释放资源=====================&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        semaphoreV2.returnLease(acquire); <span class="comment">// 手动释放资源，后续请求线程就可以获取该资源</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="栅栏barrier"><a href="#栅栏barrier" class="headerlink" title="栅栏barrier"></a>栅栏barrier</h3><ol>
<li><p><strong>DistributedBarrier</strong>构造函数中barrierPath参数用来确定一个栅栏，只要barrierPath参数相同(路径相同)就是同一个栅栏。通常情况下栅栏的使用如下：</p>
<ol>
<li>主client设置一个栅栏</li>
<li>其他客户端就会调用waitOnBarrier()等待栅栏移除，程序处理线程阻塞</li>
<li>主client移除栅栏，其他客户端的处理程序就会同时继续运行。</li>
</ol>
<p>DistributedBarrier类的主要方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setBarrier() - 设置栅栏</span><br><span class="line">waitOnBarrier() - 等待栅栏移除</span><br><span class="line">removeBarrier() - 移除栅栏</span><br></pre></td></tr></table></figure></li>
<li><p>DistributedDoubleBarrier双栅栏，允许客户端在计算的开始和结束时同步。当足够的进程加入到双栅栏时，进程开始计算，当计算完成时，离开栅栏。DistributedDoubleBarrier实现了双栅栏的功能。构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client - the client</span></span><br><span class="line"><span class="comment">// barrierPath - path to use</span></span><br><span class="line"><span class="comment">// memberQty - the number of members in the barrier</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DistributedDoubleBarrier</span><span class="params">(CuratorFramework client, String barrierPath, <span class="type">int</span> memberQty)</span>;</span><br><span class="line"></span><br><span class="line">enter()、enter(<span class="type">long</span> maxWait, TimeUnit unit) - 等待同时进入栅栏</span><br><span class="line">leave()、leave(<span class="type">long</span> maxWait, TimeUnit unit) - 等待同时离开栅栏</span><br></pre></td></tr></table></figure>

<p>memberQty是成员数量，当enter方法被调用时，成员被阻塞，直到所有的成员都调用了enter。当leave方法被调用时，它也阻塞调用线程，直到所有的成员都调用了leave。</p>
<p>注意：参数memberQty的值只是一个阈值，而不是一个限制值。当等待栅栏的数量大于或等于这个值栅栏就会打开！</p>
<p>与栅栏(DistributedBarrier)一样,双栅栏的barrierPath参数也是用来确定是否是同一个栅栏的，双栅栏的使用情况如下：</p>
<ol>
<li>从多个客户端在同一个路径上创建双栅栏(DistributedDoubleBarrier),然后调用enter()方法，等待栅栏数量达到memberQty时就可以进入栅栏。</li>
<li>栅栏数量达到memberQty，多个客户端同时停止阻塞继续运行，直到执行leave()方法，等待memberQty个数量的栅栏同时阻塞到leave()方法中。</li>
<li>memberQty个数量的栅栏同时阻塞到leave()方法中，多个客户端的leave()方法停止阻塞，继续运行。</li>
</ol>
</li>
</ol>
<h3 id="共享计数器"><a href="#共享计数器" class="headerlink" title="共享计数器"></a>共享计数器</h3><p>利用ZooKeeper可以实现一个集群共享的计数器。只要使用相同的path就可以得到最新的计数器值， 这是由ZooKeeper的一致性保证的。Curator有两个计数器， 一个是用int来计数，一个用long来计数。</p>
<h4 id="SharedCount"><a href="#SharedCount" class="headerlink" title="SharedCount"></a>SharedCount</h4><p>共享计数器SharedCount相关方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SharedCount</span><span class="params">(CuratorFramework client, String path, <span class="type">int</span> seedValue)</span>;</span><br><span class="line"><span class="comment">// 获取共享计数的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 设置共享计数的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">(<span class="type">int</span> newCount)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="comment">// 当版本号没有变化时，才会更新共享变量的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span>  <span class="title function_">trySetCount</span><span class="params">(VersionedValue&lt;Integer&gt; previous, <span class="type">int</span> newCount)</span>;</span><br><span class="line"><span class="comment">// 通过监听器监听共享计数的变化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(SharedCountListener listener)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(<span class="keyword">final</span> SharedCountListener listener, Executor executor)</span>;</span><br><span class="line"><span class="comment">// 共享计数在使用之前必须开启</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="comment">// 关闭共享计数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>使用案例：</p>
<p>StockController：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;test/zk/share/count&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testZkShareCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stockService.testZkShareCount();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello shareData&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StockService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZkShareCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 第三个参数是共享计数的初始值</span></span><br><span class="line">        <span class="type">SharedCount</span> <span class="variable">sharedCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedCount</span>(curatorFramework, <span class="string">&quot;/curator/count&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 启动共享计数器</span></span><br><span class="line">        sharedCount.start();</span><br><span class="line">        <span class="comment">// 获取共享计数的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> sharedCount.getCount();</span><br><span class="line">        <span class="comment">// 修改共享计数的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>);</span><br><span class="line">        sharedCount.setCount(random);</span><br><span class="line">        System.out.println(<span class="string">&quot;我获取了共享计数的初始值：&quot;</span> + count + <span class="string">&quot;，并把计数器的值改为：&quot;</span> + random);</span><br><span class="line">        sharedCount.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="DistributedAtomicNumber"><a href="#DistributedAtomicNumber" class="headerlink" title="DistributedAtomicNumber"></a>DistributedAtomicNumber</h4><p>DistributedAtomicNumber接口是分布式原子数值类型的抽象，定义了分布式原子数值类型需要提供的方法。</p>
<p>DistributedAtomicNumber接口有两个实现：<code>DistributedAtomicLong</code> 和 <code>DistributedAtomicInteger</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220711225708066.png" alt="image-20220711225708066"></p>
<p>这两个实现将各种原子操作的执行委托给了<code>DistributedAtomicValue</code>，所以这两种实现是类似的，只不过表示的数值类型不同而已。这里以<code>DistributedAtomicLong</code> 为例进行演示</p>
<p>DistributedAtomicLong除了计数的范围比SharedCount大了之外，比SharedCount更简单易用。它首先尝试使用乐观锁的方式设置计数器， 如果不成功(比如期间计数器已经被其它client更新了)， 它使用InterProcessMutex方式来更新计数值。此计数器有一系列的操作：</p>
<ul>
<li>get(): 获取当前值</li>
<li>increment()：加一</li>
<li>decrement(): 减一</li>
<li>add()：增加特定的值</li>
<li>subtract(): 减去特定的值</li>
<li>trySet(): 尝试设置计数值</li>
<li>forceSet(): 强制设置计数值</li>
</ul>
<p>你必须检查返回结果的succeeded()， 它代表此操作是否成功。如果操作成功， preValue()代表操作前的值， postValue()代表操作后的值。</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>不管是jvm锁还是mysql锁，为了保证线程的并发安全，都提供了悲观独占排他锁。所以<strong>独占排他</strong>也是分布式锁的基本要求。</p>
<p>可以利用唯一键索引不能重复插入的特点实现。设计表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `tb_lock` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `lock_name` varchar(50) NOT NULL COMMENT &#x27;锁名&#x27;,</span><br><span class="line">  `class_name` varchar(100) DEFAULT NULL COMMENT &#x27;类名&#x27;,</span><br><span class="line">  `method_name` varchar(50) DEFAULT NULL COMMENT &#x27;方法名&#x27;,</span><br><span class="line">  `server_name` varchar(50) DEFAULT NULL COMMENT &#x27;服务器ip&#x27;,</span><br><span class="line">  `thread_name` varchar(50) DEFAULT NULL COMMENT &#x27;线程名&#x27;,</span><br><span class="line">  `create_time` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;获取锁时间&#x27;,</span><br><span class="line">  `desc` varchar(100) DEFAULT NULL COMMENT &#x27;描述&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `idx_unique` (`lock_name`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1332899824461455363 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p>Lock实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@TableName(&quot;tb_lock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String lockName;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> String serverName;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LockMapper接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LockMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Lock&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>synchronized关键字和ReetrantLock锁都是独占排他锁，即多个线程争抢一个资源时，同一时刻只有一个线程可以抢占该资源，其他线程只能阻塞等待，直到占有资源的线程释放该资源。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606620944823.png" alt="1606620944823"></p>
<ol>
<li>线程同时获取锁（insert）</li>
<li>获取成功，执行业务逻辑，执行完成释放锁（delete）</li>
<li>其他线程等待重试</li>
</ol>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><p>改造StockService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StockMapper stockMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LockMapper lockMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库分布式锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAndLock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock</span>(<span class="literal">null</span>, <span class="string">&quot;lock&quot;</span>, <span class="built_in">this</span>.getClass().getName(), <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.lockMapper.insert(lock);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">// 获取锁失败，则重试</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="built_in">this</span>.checkAndLock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先查询库存是否充足</span></span><br><span class="line">        <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="built_in">this</span>.stockMapper.selectById(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再减库存</span></span><br><span class="line">        <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            stock.setCount(stock.getCount() - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.stockMapper.updateById(stock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        <span class="built_in">this</span>.lockMapper.deleteById(lock.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>加锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock</span>(<span class="literal">null</span>, <span class="string">&quot;lock&quot;</span>, <span class="built_in">this</span>.getClass().getName(), <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lockMapper.insert(lock);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">// 获取锁失败，则重试</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        <span class="built_in">this</span>.checkAndLock();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="built_in">this</span>.lockMapper.deleteById(lock.getId());</span><br></pre></td></tr></table></figure>



<p>使用Jmeter压力测试结果：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606625971086.png" alt="1606625971086"></p>
<p>可以看到性能感人。mysql数据库库存余量为0，可以保证线程安全。</p>
<h2 id="缺陷及解决方案"><a href="#缺陷及解决方案" class="headerlink" title="缺陷及解决方案"></a>缺陷及解决方案</h2><p><strong>缺点</strong>：</p>
<ol>
<li><p>这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</p>
<p>解决方案：给 锁数据库 搭建主备</p>
</li>
<li><p>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</p>
<p>解决方案：只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</p>
</li>
<li><p>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</p>
<p>解决方案：记录获取锁的主机信息和线程信息，如果相同线程要获取锁，直接重入。</p>
</li>
<li><p>受制于数据库性能，并发能力有限。</p>
<p>解决方案：无法解决。</p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实现的复杂性或者难度角度：Zookeeper &gt; redis &gt; 数据库</p>
<p>实际性能角度：redis &gt; Zookeeper &gt; 数据库</p>
<p>可靠性角度：Zookeeper &gt; redis = 数据库</p>
<p>这三种方式都不是尽善尽美，我们可以根据实际业务情况选择最适合的方案：</p>
<p>如果追求极致性能可以选择：reds方案</p>
<p>如果追求可靠性可以选择：zk</p>
<p>常见锁分类：</p>
<blockquote>
<p><strong>悲观锁</strong>：具有强烈的独占和排他特性，在整个数据处理过程中，将数据处于锁定状态。适合于写比较多，会阻塞读操作。<br><strong>乐观锁</strong>：采取了更加宽松的加锁机制，大多是基于数据版本（ Version ）及时间戳来实现。。适合于读比较多，不会阻塞读</p>
</blockquote>
<blockquote>
<p><strong>独占锁、互斥锁、排他锁</strong>：保证在任一时刻，只能被一个线程独占排他持有。synchronized、ReentrantLock<br><strong>共享锁</strong>：可同时被多个线程共享持有。CountDownLatch到计数器、Semaphore信号量</p>
</blockquote>
<blockquote>
<p><strong>可重入锁</strong>：又名递归锁。同一个线程在外层方法获取锁的时候，在进入内层方法时会自动获取锁。<br><strong>不可重入锁</strong>：例如早期的synchronized</p>
</blockquote>
<blockquote>
<p><strong>公平锁</strong>：有优先级的锁，先来先得，谁先申请锁就先获取到锁<br><strong>非公平锁</strong>：无优先级的锁，后来者也有机会先获取到锁</p>
</blockquote>
<blockquote>
<p><strong>自旋锁</strong>：当线程尝试获取锁失败时（锁已经被其它线程占用了），无限循环重试尝试获取锁<br><strong>阻塞锁</strong>：当线程尝试获取锁失败时，线程进入阻塞状态，直到接收信号后被唤醒。在竞争激烈情况下，性能较高</p>
</blockquote>
<blockquote>
<p><strong>读锁</strong>：共享锁<br><strong>写锁</strong>：独占排他锁</p>
</blockquote>
<blockquote>
<p><strong>偏向锁</strong>：一直被一个线程所访问，那么该线程会自动获取锁<br><strong>轻量级锁</strong>（CAS）：当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。<br><strong>重量级锁</strong>：当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候（10次），还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。<br>以上其实是synchronized的锁升级过程</p>
</blockquote>
<p>​    </p>
<blockquote>
<p><strong>表级锁</strong>：对整张表加锁，加锁快开销小，不会出现死锁，但并发度低，会增加锁冲突的概率<br><strong>行级锁</strong>：是mysql粒度最小的锁，只针对操作行，可大大减少锁冲突概率，并发度高，但加锁慢，开销大，会出现死锁</p>
</blockquote>
]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>redis</tag>
        <tag>zookeeper</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>java.lang.Thread</title>
    <url>/2024/11/20/java.lang.Thread/</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="线程概念相关"><a href="#线程概念相关" class="headerlink" title="线程概念相关"></a>线程概念相关</h2><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119185155274-1735313112574-111.png" alt="image-20241119185155274"></p>
<p><strong>Parallel Unit 并行最小单位</strong></p>
<ul>
<li>拥有自己的上下文</li>
<li>拥有调用堆栈</li>
<li>有自己的 PC</li>
<li>但是内存和同一个进程的其他线程共享（SHARED），发生竞态条件（RACE CONDITION）</li>
</ul>
<h4 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h4><p>操作系统对执行中程序的一种抽象</p>
<p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p>
<p>每个程序都有自己的进程，互不干扰。即使它们都是同一份代码，但各自播放的内容和进度都可以不同。进程（可以看成只有一个线程的进程）同时只能做一件事，如果将一个进程分成多个线程，这样就不会浪费时间空等了进程间是完全独立的，互不干扰。而线程则共享同一个进程的资源，所以线程间交换数据更方便，几乎没有通讯损耗。但进程间交换数据就麻烦多了，得通过一些通讯机制，比如管道、消息队列之类的（Inter-Process Communication）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119184759519.png" alt="image-20241119184759519"></p>
<h4 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a>Coroutine</h4><p>线程在执行加载视频片段时，必须等待结果返回才能再次执行解码操作，如果引入多线程：加载本身是IO行为，CPU在等待结果返回期间几乎是在空等，浪费了CPU资源。当然，你可以让它休眠以释放 CPU 时间，但创建线程本身就有开销，线程切换同样有开销。</p>
<p>相比之下，协程（Coroutine）非常轻量，创建和切换的开销极小——它并非操作系统层面的东西，就不涉及内核调度。一般是由编程语言来实现（比如 Python 的 asyncio 标准库），它属于用户态的东西。</p>
<p>资源共享问题：线程的执行时机由操作系统调度，程序员无法控制，这正是多线程容易出现资源覆盖的主要原因。而协程的执行时机由程序自身控制，不受操作系统调度影响，因此可以完全避免这类问题。同一个线程内的多个协程共享同一个线程的 CPU 时间片资源，它们在 CPU 上的执行是有先后顺序的，不能并行执行。而线程是可以并行执行的</p>
<p>协程（coroutine），其实是一种特殊的子程序（subroutine，比如普通函数）。普通函数一旦执行就会从头到尾运行，然后返回结果，中间不会暂停。而协程则可以在执行到一半时暂停。利用这一特性，我们可以在遇到 I/O 这类不消耗 CPU 资源的操作时，将其挂起，继续执行其他计算任务，充分利用 CPU 资源。等 I/O 操作结果返回时，再恢复执行。在一个线程内并发执行多个任务</p>
<h3 id="为什么要有多线程？"><a href="#为什么要有多线程？" class="headerlink" title="为什么要有多线程？"></a>为什么要有多线程？</h3><p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代</strong>：在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li>
<li><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 核心上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）</li>
</ul>
<h3 id="多线程效率一定高吗？"><a href="#多线程效率一定高吗？" class="headerlink" title="多线程效率一定高吗？"></a>多线程效率一定高吗？</h3><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><p>众所周知，CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:</p>
<ul>
<li>CPU 增加了 Cache，以均衡与内存的速度差异，导致 <code>可见性</code>问题</li>
<li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异，导致 <code>原子性</code>问题</li>
<li>编译程序优化指令执行次序，使得 Cache 能够得到更加合理地利用，导致 <code>有序性</code>问题</li>
</ul>
<h4 id="单核-CPU-多线程"><a href="#单核-CPU-多线程" class="headerlink" title="单核 CPU 多线程"></a>单核 CPU 多线程</h4><p>对于 IO 密集型，效率明显提高，因为线程切换带来的收益可以抵消代价</p>
<p>对于计算密集型，频繁的上下文切换开销很大</p>
<h3 id="易混淆"><a href="#易混淆" class="headerlink" title="易混淆"></a>易混淆</h3><h4 id="并发-并行"><a href="#并发-并行" class="headerlink" title="并发/并行"></a>并发/并行</h4><ul>
<li>运行的程序就是一个独立的进程</li>
<li><strong>并发</strong>：CPU轮询执行每个线程，切换速度快，感觉线程在同时和执行，这就是<strong>并发</strong></li>
<li><strong>并行</strong>：同一时刻有多个线程在被CPU调度执行</li>
</ul>
<h4 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h4><ul>
<li><strong>同步</strong>：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li>
<li><strong>异步</strong>：调用在发出之后，不用等待返回结果，该调用直接返回。</li>
</ul>
<h2 id="Java-线程和-OS-线程"><a href="#Java-线程和-OS-线程" class="headerlink" title="Java 线程和 OS 线程"></a>Java 线程和 OS 线程</h2><p>JDK 1.2 之前，Java 线程是基于绿色线程（Green Threads）实现的，这是一种用户级线程（用户线程），也就是说 JVM 自己模拟了多线程的运行，而不依赖于操作系统。由于绿色线程和原生线程比起来在使用时有一些限制（比如绿色线程不能直接使用操作系统提供的功能如异步 I/O、只能在一个内核线程上运行无法利用多核），在 JDK 1.2 及以后，Java 线程改为基于原生线程（Native Threads）实现，也就是说 JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。</p>
<p>我们上面提到了用户线程和内核线程，考虑到很多读者不太了解二者的区别，这里简单介绍一下：</p>
<ul>
<li>用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。</li>
<li>内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。</li>
</ul>
<p>顺便简单总结一下用户线程和内核线程的区别和特点：用户线程创建和切换成本低，但不可以利用多核。内核态线程，创建和切换成本高，可以利用多核。</p>
<p>一句话概括 Java 线程和操作系统线程的关系：<strong>现在的 Java 线程的本质其实就是操作系统的线程</strong>。</p>
<p>线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有这三种：</p>
<ol>
<li>一对一（一个用户线程对应一个内核线程）</li>
<li>多对一（多个用户线程映射到一个内核线程）</li>
<li>多对多（多个用户线程映射到多个内核线程）</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/three-types-of-thread-models.png" alt="常见的三种线程模型"></p>
<p>在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个 Java 线程对应一个系统内核线程。Solaris 系统是一个特例（Solaris 系统本身就支持多对多的线程模型），HotSpot VM 在 Solaris 上支持多对多和一对一。</p>
<h2 id="线程创建、运行、中断"><a href="#线程创建、运行、中断" class="headerlink" title="线程创建、运行、中断"></a>线程创建、运行、中断</h2><h3 id="三种-Thread-构造器"><a href="#三种-Thread-构造器" class="headerlink" title="三种 Thread 构造器"></a>三种 Thread 构造器</h3><p><strong><mark>继承 Thread 抽象类<mark></strong></p>
<ol>
<li>创建<strong>子类</strong>继承Thread类，重写 run 方法</li>
<li>创建子类对象<code>Thread t = new MyThread()</code></li>
<li><code>t.start()</code> </li>
</ol>
<ul>
<li>编码简单，不能继承其他类</li>
<li>不要把主线程任务放在启动子线程之前</li>
<li>必须调用start方法，调用run方法还是会顺序执行，先启动，启动后会自动调用</li>
<li>不能返回执行结果</li>
</ul>
<p><strong><mark>实现 Runnable 接口 任务对象<mark></strong></p>
<ol>
<li>自己创建一个类实现Runnable接口，重写run方法</li>
<li>创建任务对象<code>Runnable target = new MyRunnable()</code></li>
<li>创建线程对象<code>new Thread(target)</code></li>
<li>调用线程对象的start方法</li>
</ol>
<ul>
<li>只是实现接口，可以继承其他的类，实现其他接口，扩展性强</li>
<li>不能返回执行结果</li>
</ul>
<p>匿名内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//create an annoymous inner class object</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		...;</span><br><span class="line">        ...;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(target).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lambda expression</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>( ()-&gt;&#123;</span><br><span class="line">    ...;</span><br><span class="line">    ...;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p><strong><mark>实现 Callable 接口<mark></strong></p>
<ol>
<li>定义类实现<code>Callable&lt;&gt;</code>，重写call方法，封装要做的事情和返回的数据。<code>Callable</code>后边的泛型就是返回的数据类型</li>
<li>创建<code>Callable</code>对象，把他封装成<code>FutureTask&lt;String&gt;(Callable&lt;String&gt; callable)</code> 对象，泛型要相同</li>
<li><code>FutureTask</code>实现了<code>Runnable</code>接口，是任务对象</li>
<li>在线程执行完毕之后，对<code>FutureTask</code>对象调用<code>get</code>方法获取线程执行结果。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Callable&lt;String&gt; callable = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">10</span>); <span class="comment">//创建 Callable对象</span></span><br><span class="line"></span><br><span class="line">FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable); <span class="comment">//用Callable对象 创建 任务对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start(); <span class="comment">//用任务对象 创建 线程对象 并启动</span></span><br><span class="line"></span><br><span class="line">System.out.println(futureTask.get());<span class="comment">//获取返回值</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	如果执行到get()线程还未执行完毕</span></span><br><span class="line"><span class="comment">*	代码会暂停，等待执行完毕才获取结果</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以获取返回值，扩展性强</li>
<li>编码复杂一些</li>
</ul>
<h3 id="thread-start"><a href="#thread-start" class="headerlink" title="thread.start()"></a><code>thread.start()</code></h3><p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了 Runnable 状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
<p>在别的平台，比如 C/C++ ，线程创建即运行</p>
<h3 id="thread-interrupt"><a href="#thread-interrupt" class="headerlink" title="thread.interrupt()"></a><code>thread.interrupt()</code></h3><p>如果异常没有被捕获该线程将会停止执行。</p>
<ol>
<li>Java 通过 <strong><code>interrupt()</code></strong> 发出线程中断信号，<strong>不会强制停止线程</strong>，而是依靠线程自行检查并响应。</li>
<li>使用 <strong><code>isInterrupted()</code></strong> 查询中断状态，或 <strong><code>interrupted()</code></strong> 查询并重置状态。</li>
<li>在阻塞操作中，抛出 <strong><code>InterruptedException</code></strong> 时需恢复中断标志位并及时退出。</li>
<li>遵循协作式终止原则，确保线程安全和资源正确释放。</li>
</ol>
<p><strong>推荐方式：</strong></p>
<ul>
<li>在关键任务中轮询中断状态。</li>
<li>在阻塞状态下捕获异常并优雅退出线程。</li>
</ul>
<p><strong>如何处理中断</strong>？</p>
<ol>
<li><strong>响应中断标志位</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务执行中...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;检测到中断，退出线程！&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>2. 捕获异常并退出</strong></p>
<p>在阻塞状态下（如 <code>sleep()</code>、<code>wait()</code>、<code>join()</code> 等方法），线程会抛出 <strong><code>InterruptedException</code><strong>，此时中断标志位会被</strong>自动清除</strong>。示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程被中断！&quot;</span>);</span><br><span class="line">    Thread.currentThread().interrupt(); <span class="comment">// 恢复中断标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么中断不能强制终止线程</strong>？</p>
<p>Java 提倡线程的<strong>协作式终止</strong>，而不是<strong>强制终止</strong>（如 <code>Thread.stop()</code> 已被废弃）。原因包括：</p>
<ol>
<li><strong>强制终止会导致资源泄漏：</strong> 线程可能在持有锁或打开文件等资源时被突然终止，导致资源无法正常释放。</li>
<li><strong>不安全的状态：</strong> 数据可能处于不一致状态，从而引发数据损坏。</li>
<li><strong>可控性低：</strong> 开发者无法自行控制线程的退出逻辑。</li>
</ol>
<h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918105642868-1726751033487-52-1735555863361-53.png" alt="image-20240918105642868"></p>
<h2 id="Thread-常用方法"><a href="#Thread-常用方法" class="headerlink" title="Thread 常用方法"></a>Thread 常用方法</h2><p>  <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917203637026-1726751033487-46.png" alt="image-20240917203637026"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917203429253-1726751033487-47.png" alt="image-20240917203429253"></p>
<ul>
<li><strong><code>start()</code></strong>: 线程转为 Runnable 可运行状态，相当于 <code>pthread_create()</code></li>
<li><strong><code>run()</code></strong>: 线程应该执行的方法，相当于 <code>pthread_create()</code> 传的函数指针</li>
<li><strong><code>sleep(long millis)</code></strong>: 调用者睡眠一段时间</li>
<li><strong><code>join()</code></strong>: 父线程等待子线程执行完毕再继续执行</li>
<li><strong><code>interrupt()</code></strong>: 使线程中断</li>
<li><code>currentThread()</code>: 获取当前执行的线程对象</li>
<li><code>get/setName()</code>: 获取线程名称</li>
<li><code>yield()</code>: 声明当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。只是对线程调度器的一个建议，只是建议具有相同优先级的其它线程可以运行。只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。</li>
<li><code>setDaemon()</code>: 将一个线程设置为守护线程。当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。main() 属于非守护线程。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/640-1735555856683-51.png" alt="Java 线程状态变迁图"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918105918176-1726751033487-54.png" alt="image-20240918105918176"></p>
<h2 id="线程安全问题-1"><a href="#线程安全问题-1" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p>
<p>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadUnsafeExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">ThreadUnsafeExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadUnsafeExample</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadSize);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --- 997 // 结果总是小于1000</span></span><br></pre></td></tr></table></figure>

<p>多个线程，同时修改同一个共享资源，可能出现业务安全问题 <a href="jetbrains://idea/navigate/reference?project=MyFirstProject&fqn=com.it.threadtest.BankSimulator">Banksim</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917205938036-1726751033487-48.png" alt="image-20240917205938036"></p>
<p>又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：如果你的代码 在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。 这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p>
<h3 id="不可变-Immutable"><a href="#不可变-Immutable" class="headerlink" title="不可变 Immutable"></a>不可变 Immutable</h3><p>final 关键字修饰的基本数据类型，枚举类型，Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。任何一个线程都改变不了它们的值，要改变除 非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p>
<h3 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h3><p>不管运行时环境如何，调用者都不需要任何额外的同步措施。</p>
<h3 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h3><p>相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。也就是我们通常意义上所说的线程安全</p>
<p>ConcurrentHashMap, Vector, HashTable, StringBuffer</p>
<p>像 <strong>Vector</strong> 这种，add、remove方法都是原子 操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个 Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。HashTable也同理。StringBuffer 自带缓冲区，线程安全，性能较低。</p>
<p><mark>ConcurrentHashMap<mark> 的复合操作：<code>if(map.containsKey(x)) map.put(x,1);</code> 不能保证原子性，需要使用内置的原子操作方法，如 <code>putIfAbsent()</code>。另外批量操作也不一定线程安全</p>
<h3 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h3><p>ArrayList、LinkedList、HashMap等都是线程非安全的类 StringBuilder也不安全。完全不安全</p>
<h2 id="线程互斥同步-Mutex-Synchronization"><a href="#线程互斥同步-Mutex-Synchronization" class="headerlink" title="线程互斥同步(Mutex Synchronization)"></a>线程互斥同步(Mutex Synchronization)</h2><h3 id="悲观、乐观锁"><a href="#悲观、乐观锁" class="headerlink" title="悲观、乐观锁"></a>悲观、乐观锁</h3><p><strong>乐观锁</strong>：CAS算法，共享资源修改之后跟修改之前做对比，如果一样就确认修改，不一样就作废，重新进行修改</p>
<p>主线程里调用子线程的join方法，表示主线程等待次线程执行完毕，再继续执行<a href="jetbrains://idea/navigate/reference?project=MyFirstProject&fqn=com.it.threadtest.GiftSender">赠送礼物案例</a> </p>
<p><strong>悲观锁</strong>：直接把核心代码锁住，只要线程开始执行就加锁，线程安全,但并发性能差</p>
<p>t1和t2两个子线程同时启动，调用start方法，t1，t2进入就绪状态，何时启动，启动顺序由调度器决定，启动以后，main,t1,t2各自执行互不影响，此时如果在子线程的start语句后调用子线程的join方法，t1.join表示主线程要在这一步暂停，直到t1执行完毕，但是t2不会受到任何影响，当t1执行完毕之后，再调用t2.join等待t2执行完毕，可能在t1执行完之前t2就完了，所以有时候t2不join也不会影响结果，但是最好还是加上</p>
<p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。解决线程安全问题的方案，让多个线程先后依次访问共享资源</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><code>synchronized</code></h3><h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><ul>
<li>作用：把访问共享资源的核心代码上锁，保证线程安全</li>
<li>原理：每次只允许一个线程加锁以后进入，执行完毕自动解锁，其他线程才能进来执行。</li>
<li>同步锁必须是同一个锁对象。</li>
</ul>
<p>关键字 <code>synchronized</code> 后边括号里是锁对象，<mark>必须保证是同一个<mark>，最简单的方法就是唯一的 字符串常量池。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917214332757-1726751033487-49.png" alt="image-20240917214332757"></p>
<p>不同类或模块中不相关的代码会因为使用相同的字符串常量作为锁而相互干扰，你取钱关我什么事？我的账号我为什么不能取！搜易</p>
<p><code>synchronized(this)</code> 实例方法，锁对象代表正在操作的共享资源</p>
<p>静态方法：<code>synchronized(Account.class)</code> </p>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p><code>public synchronized int steal()</code></p>
<p>实例方法就是用this作为锁，静态方法的锁：类名.class</p>
<p>web应用的业务层对象service通常是同一个（spring容器的单例）</p>
<p>如果多个线程都要调用service对象的synchronized方法，此时线程A拿到了this对象开始执行方法，其他线程只能阻塞等待A执行完毕释放this对象锁才可继续执行。</p>
<p>锁必须是不同的线程都能访问到的对象，比如字符串常量，比如this</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><code>ReentrantLock</code></h3><p><code>final Lock lk = new ReentrantLock();</code> 声明在共享资源的成员变量，</p>
<p><code>lk.lock()</code> <code>lk.unlock()</code></p>
<ul>
<li>final 关键字 不能修改锁</li>
<li>加锁之后，执行核心代码的时候如果遇到异常，后面程序无法执行，就变成了死锁，所以用 <code>try-catch-finally</code></li>
</ul>
<h3 id="which-one"><a href="#which-one" class="headerlink" title="which one?"></a>which one?</h3><p><strong>比较</strong></p>
<p><strong>1. 锁的实现</strong></p>
<p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p>
<p><strong>2. 性能</strong></p>
<p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p>
<p><strong>3. 等待可中断</strong></p>
<p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p>
<p>ReentrantLock 可中断，而 synchronized 不行。</p>
<p><strong>4. 公平锁</strong></p>
<p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p>
<p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p>
<p><strong>5. 锁绑定多个条件</strong></p>
<p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p>
<p><strong>使用选择</strong></p>
<p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><ul>
<li><p>Hold and wait:  一个进程因请求资源而阻塞时，对以获得的资源保持不放。</p>
<ul>
<li>原子性抢锁, 把要抢的锁集中到一起,一块抢了</li>
</ul>
</li>
<li><p>No preemption: 进程已获得的资源，在使用完毕之前，不能被强行抢走。</p>
<ul>
<li><code>a.lock()</code>-&gt;<code>if(!b.tryLock()) then a.unlock()</code> </li>
<li>如果 b tryLock 失败就会被抢走。</li>
<li>Issue: Livelock</li>
</ul>
</li>
<li><p>Circular wait: </p>
<ul>
<li>fixed order</li>
</ul>
</li>
<li><p>Mutual exclusion: </p>
<ul>
<li>Lock-free CAS</li>
</ul>
</li>
</ul>
<h2 id="线程通信-Inter-Thread-Communication"><a href="#线程通信-Inter-Thread-Communication" class="headerlink" title="线程通信(Inter-Thread Communication)"></a>线程通信(Inter-Thread Communication)</h2><p>可以通过共享变量的方式实现线程间的通讯和协作：volatile、while 轮询</p>
<p>同时可以使用下面线程消息传递机制：</p>
<h3 id="thread-join"><a href="#thread-join" class="headerlink" title="thread.join()"></a><code>thread.join()</code></h3><p><strong><mark>join()<mark></strong></p>
<p>join 在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p>
<p>线程之间互相告知对方自己的状态，相互协调。<strong>避免无效资源争夺</strong> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917222622519-1726751033487-50.png" alt="image-20240917222622519"></p>
<h3 id="object-wait"><a href="#object-wait" class="headerlink" title="object.wait()"></a><code>object.wait()</code></h3><p><strong><mark>wait() notify() notifyAll()<mark></strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917224325687-1726751033487-51.png" alt="image-20240917224325687"></p>
<p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。它们都属于 Object 的一部分，而不属于 Thread。</p>
<p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception。</p>
<p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。上述方法应该使用当前同步锁对象进行调用，只有锁知道当前占用自己的是哪个线程</p>
<p>先notifyAll 后wait   </p>
<p>先wait 后notifyAll 当前线程等待，notifyAll又再次唤醒了自己</p>
<p>底层逻辑：如果没有通信机制，就会出现无效的资源争夺，我做好了包子，我就应该通知你们所有人，我的工作做完了，你们可以开始你们的工作了，不然我会一直占用桌子但是又做不了包子，你们想吃包子的也因为桌子被占用而吃不上，导致厨师和吃货之间没有必要的资源挤兑与争抢。</p>
<h4 id="wait-与-sleep"><a href="#wait-与-sleep" class="headerlink" title="wait() 与 sleep()"></a><code>wait()</code> 与 <code>sleep()</code></h4><p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p>
<p>类似的问题：<strong>为什么 <code>sleep()</code> 方法定义在 <code>Thread</code> 中？</strong> </p>
<p>因为 <code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p>
<p><strong>区别</strong>：</p>
<ul>
<li><strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</li>
<li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code>通常被用于暂停执行。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
<li><code>sleep()</code> 是 <code>Thread</code> 类的静态native方法，<code>wait()</code> 则是 <code>Object</code> 类的native方法。</li>
</ul>
<h3 id="condition-await"><a href="#condition-await" class="headerlink" title="condition.await()"></a><code>condition.await()</code></h3><p><mark><strong>await() signal() signalAll()</strong><mark></p>
<p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p>
<p>使用 Lock 来获取一个 Condition 对象。</p>
<h3 id="Producer-Consumer"><a href="#Producer-Consumer" class="headerlink" title="Producer/Consumer"></a>Producer/Consumer</h3><p><strong>生产者-消费者模式</strong>（Producer-Consumer Pattern）是一种常见的多线程设计模式，通常用于解决<strong>不同速率的线程之间如何协调工作</strong>的问题。它的主要目标是将“<strong>生产数据</strong>”和“<strong>消费数据</strong>”的任务解耦，使用一个共享的缓冲区（通常是队列）来协调生产者和消费者的工作。 </p>
<p><mark>模式概述<mark></p>
<ol>
<li><strong>生产者（Producer）</strong>：负责生成数据，并将数据放入缓冲区或队列中。生产者线程的工作是“生产”，即产生新数据。</li>
<li><strong>消费者（Consumer）</strong>：负责从缓冲区中获取数据并进行处理。消费者线程的工作是“消费”，即处理已经由生产者产生的数据。</li>
<li><strong>共享缓冲区</strong>：生产者和消费者通过共享一个缓冲区（通常是一个线程安全的队列）进行数据传递。生产者将数据放入缓冲区，消费者从缓冲区中取出数据。</li>
</ol>
<p>在该模式下，生产者和消费者可以独立运行，而不需要直接相互依赖。两者通过共享缓冲区进行<strong>松耦合的通信</strong>。</p>
<p><mark>关键问题<mark></p>
<p>生产者和消费者的工作速率可能不同：</p>
<ul>
<li>如果生产者比消费者快，消费者可能一时无法处理所有的数据，导致缓冲区满。</li>
<li>如果消费者比生产者快，消费者可能没有数据可消费，导致缓冲区空。</li>
</ul>
<p>因此，需要有一种机制来处理这两种情况：</p>
<ul>
<li><strong>缓冲区满时</strong>：生产者应该等待，直到有空间可以继续生产数据。</li>
<li><strong>缓冲区空时</strong>：消费者应该等待，直到有数据可以消费。</li>
</ul>
<p>如果在生产者-消费者模式中没有合适的<strong>等待机制</strong>，而生产者和消费者直接对缓冲区进行操作，那么可能会出现以下问题：</p>
<ol>
<li><strong>缓冲区满时的情况</strong></li>
</ol>
<p>当缓冲区已经满了，<strong>生产者</strong>线程如果继续向缓冲区添加数据，而没有等待机制，可能会出现以下两种情况：</p>
<ul>
<li><strong>覆盖数据</strong>：如果没有检查缓冲区是否已满，生产者可能会继续向缓冲区写入数据，从而覆盖掉之前的数据，导致丢失尚未被消费者读取的数据。</li>
<li><strong>抛出异常</strong>：在某些实现中，尝试向满的缓冲区写入数据可能会抛出异常，程序会因为未处理该异常而崩溃或出现不可预测的行为。</li>
</ul>
<p>示例：没有等待机制的生产者向满缓冲区添加数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoWaitBufferFull</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] buffer = <span class="keyword">new</span> <span class="title class_">int</span>[CAPACITY];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 简单模拟生产者行为</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count == CAPACITY) &#123;</span><br><span class="line">                    <span class="comment">// 缓冲区已满，没有等待机制，可能出现问题</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Buffer is full! Data may be lost or overwritten.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                buffer[count % CAPACITY] = count; <span class="comment">// 可能覆盖数据</span></span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(<span class="string">&quot;Produced: &quot;</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题：</strong></p>
<ul>
<li>在没有等待机制的情况下，生产者线程一旦缓冲区满了，就会继续写入新数据，覆盖掉尚未被消费者读取的数据，从而丢失数据。</li>
</ul>
<ol start="2">
<li><strong>缓冲区空时的情况</strong></li>
</ol>
<p>当缓冲区为空，<strong>消费者</strong>线程如果继续尝试从缓冲区读取数据，而没有等待机制，可能会出现以下问题：</p>
<ul>
<li><strong>读取无效数据</strong>：消费者从空的缓冲区读取到无效的或未初始化的数据，导致消费错误。</li>
<li><strong>抛出异常</strong>：如果没有等待机制，当消费者试图从空的缓冲区获取数据时，可能会抛出空指针异常或数组越界异常，导致程序崩溃。</li>
</ul>
<p>示例：没有等待机制的消费者从空缓冲区读取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoWaitBufferEmpty</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] buffer = <span class="keyword">new</span> <span class="title class_">int</span>[CAPACITY];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 简单模拟消费者行为</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 缓冲区为空，没有等待机制，可能出现问题</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Buffer is empty! Consumer may read invalid data.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> buffer[(count - <span class="number">1</span>) % CAPACITY]; <span class="comment">// 可能读取到无效数据</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Consumed: &quot;</span> + data);</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题：</strong></p>
<ul>
<li>如果消费者在缓冲区为空时继续尝试读取，可能会读到无效的数据，或者抛出异常。</li>
</ul>
<ol start="3">
<li><strong>竞态条件（Race Condition）</strong></li>
</ol>
<p>没有等待机制的生产者和消费者可能会产生竞争条件，导致<strong>数据一致性问题</strong>。</p>
<ul>
<li><strong>生产者和消费者竞争访问缓冲区</strong>：生产者在写入数据时，消费者同时读取缓冲区，可能导致消费者读取到部分更新的数据，或者读取到不完整的数据。</li>
<li><strong>缓冲区状态不一致</strong>：由于生产者和消费者缺乏同步，缓冲区的状态可能变得不可预测，例如在消费者从空缓冲区读取数据时，生产者已经开始写入数据，导致状态错乱。</li>
</ul>
<p>正确的等待机制</p>
<p>为了避免上述问题，生产者和消费者应该使用合适的<strong>等待和唤醒机制</strong>，例如：</p>
<ul>
<li><strong>使用阻塞队列（BlockingQueue）</strong>：自动处理缓冲区满和空的情况。</li>
<li>**使用 <code>wait()</code> 和 <code>notify()</code>**：手动实现线程间的等待和通知。</li>
</ul>
<p>这些机制可以保证：</p>
<ul>
<li>当缓冲区满时，生产者会自动等待，直到消费者消费了一些数据并腾出空间。</li>
<li>当缓冲区为空时，消费者会自动等待，直到生产者产生新的数据。</li>
</ul>
<p>总结</p>
<p>如果没有等待机制：</p>
<ul>
<li><strong>缓冲区满时</strong>，生产者可能会覆盖数据或抛出异常。</li>
<li><strong>缓冲区空时</strong>，消费者可能会读取到无效数据或抛出异常。</li>
<li><strong>竞态条件</strong>会导致数据不一致和程序异常行为。</li>
</ul>
<p>等待机制可以确保生产者和消费者之间的正确同步，保证数据的完整性和线程安全性。</p>
<p>示例代码：使用 `BlockingQueue</p>
<p><code>BlockingQueue</code> 是 Java 并发包中的线程安全队列，当队列为空时，消费者会阻塞等待；当队列满时，生产者会阻塞等待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 缓冲区容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(CAPACITY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Producing: &quot;</span> + value);</span><br><span class="line">                    queue.put(value); <span class="comment">// 队列满时生产者阻塞</span></span><br><span class="line">                    value++;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟生产耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> queue.take(); <span class="comment">// 队列空时消费者阻塞</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Consuming: &quot;</span> + value);</span><br><span class="line">                    Thread.sleep(<span class="number">1500</span>); <span class="comment">// 模拟消费耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码解释</p>
<ul>
<li>**<code>ArrayBlockingQueue</code>**：这是一个固定容量的阻塞队列，容量为 5。</li>
<li><strong>生产者线程</strong>：生产一个整数，将其放入队列中。如果队列满了，<code>put()</code> 方法会阻塞，直到队列有空余位置。</li>
<li><strong>消费者线程</strong>：从队列中取出一个整数进行消费。如果队列为空，<code>take()</code> 方法会阻塞，直到有数据可以消费。</li>
<li>生产者每秒生产一个数据，消费者每 1.5 秒消费一个数据，因此队列会周期性地满和空。</li>
</ul>
<p>运行结果（部分）：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">Producing: 0</span></span><br><span class="line"><span class="section">Consuming: 0</span></span><br><span class="line"><span class="section">Producing: 1</span></span><br><span class="line"><span class="section">Producing: 2</span></span><br><span class="line"><span class="section">Consuming: 1</span></span><br><span class="line"><span class="section">Producing: 3</span></span><br><span class="line"><span class="section">Producing: 4</span></span><br><span class="line"><span class="section">Producing: 5</span></span><br><span class="line"><span class="section">Consuming: 2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>实现的核心优势：</p>
<ul>
<li><strong>线程安全</strong>：<code>BlockingQueue</code> 是线程安全的，它自动管理生产者和消费者之间的同步操作。</li>
<li><strong>自动阻塞与唤醒</strong>：<code>BlockingQueue</code> 的 <code>put()</code> 和 <code>take()</code> 方法在队列满或空时自动阻塞生产者或消费者线程，不需要手动使用 <code>wait()</code> 和 <code>notify()</code> 。</li>
<li><strong>简单的并发控制</strong>：相比于自己手动编写锁和条件变量，<code>BlockingQueue</code> 使得生产者-消费者模式的实现更加简洁和可靠。</li>
</ul>
<p>使用场景</p>
<p>生产者-消费者模式广泛用于以下场景：</p>
<ul>
<li><strong>多线程任务处理</strong>：例如在消息队列中，生产者产生消息并存放到队列中，消费者从队列中读取并处理消息。</li>
<li><strong>流式数据处理</strong>：例如网络服务器中，生产者线程从网络中读取数据，消费者线程对数据进行处理。</li>
<li><strong>异步任务队列</strong>：后台线程不断产生任务，工作线程从任务队列中取出任务并执行。</li>
</ul>
<p>总结</p>
<p>生产者-消费者模式通过解耦生产和消费的过程，提高了系统的<strong>并发性</strong>和<strong>响应速度</strong>，并通过使用共享的缓冲区，确保了线程之间的协调和通信。在 Java 中，通过 <code>BlockingQueue</code> 等并发工具，可以非常简便地实现这一模式。</p>
<p>为了更好地理解生产者-消费者模式中缓冲区满、空以及等待机制的问题，可以通过几个生活中的例子来形象化解释。</p>
<p><mark>案例1：餐厅的厨房和服务员<mark></p>
<p><strong>背景</strong>：我们把餐厅的厨房比作生产者，把服务员比作消费者，而“出菜窗口”就是缓冲区。厨师不断做菜（生产者），然后把做好的菜放到窗口。服务员从窗口取菜并送到顾客桌上（消费者）。窗口有固定的空间（比如只能放5盘菜）。</p>
<p>情况一：<strong>没有等待机制，缓冲区满</strong> </p>
<p>假设窗口只能放5盘菜，但没有任何规则限制厨房什么时候该停止做菜。</p>
<ul>
<li><strong>缓冲区满的情况</strong>：当窗口已经放满了5盘菜时，厨师继续做菜并将新菜强行放到窗口，结果是已经在窗口的菜被挤掉了（覆盖数据），导致有些菜从来没有被服务员送出去（数据丢失）。</li>
<li><strong>没有等待的后果</strong>：这样会让顾客拿不到部分菜，而厨师和服务员也浪费了时间。顾客会抱怨因为菜不够，服务员也因为混乱的出菜流程而忙得不可开交。</li>
</ul>
<p><strong>现实中的问题</strong>：如果生产者不等待缓冲区腾出空间继续生产，数据就可能会被覆盖，导致丢失。</p>
<p>情况二：<strong>没有等待机制，缓冲区空</strong></p>
<p>假设服务员到窗口取菜时，没有任何规则限制什么时候该停止等菜。</p>
<ul>
<li><strong>缓冲区为空的情况</strong>：当窗口里一盘菜也没有时，服务员会继续来回在窗口取菜，却发现没有菜可以送（读取无效数据）。服务员一次次白跑，最终浪费时间，不能及时给顾客送餐。</li>
<li><strong>没有等待的后果</strong>：服务员会忙碌但却无法送餐，而顾客等待时间过长，抱怨连连。</li>
</ul>
<p><strong>现实中的问题</strong>：如果消费者在没有数据可取时不等待，那么它可能会白忙一场，甚至读取无效数据或造成错误。</p>
<p>在这些生活案例中，缓冲区（窗口、传送带、货架）的满和空如果不通过合适的等待机制进行处理，会导致资源浪费、系统效率下降，甚至使整个系统无法正常工作。等待机制的引入可以确保：</p>
<ul>
<li>当缓冲区满时，生产者等待，避免覆盖数据。</li>
<li>当缓冲区空时，消费者等待，避免无效操作或消费错误。</li>
</ul>
<p>通过这些例子可以更直观地理解，<strong>等待机制</strong>在多线程程序中的重要性就在于确保生产者和消费者合理协同，防止资源浪费或错误行为。</p>
<h2 id="线程调度-scheduling"><a href="#线程调度-scheduling" class="headerlink" title="线程调度 scheduling"></a>线程调度 scheduling</h2><p>Java 的线程调度完全依赖于操作系统。操作系统根据线程优先级、时间片和调度算法来控制线程执行顺序和时间。JVM 负责将 Java 线程映射到操作系统线程，确保线程的创建、调度和同步机制正常工作。Java 提供的优先级和调度方法只是“建议”，最终执行权由操作系统决定。在大多数现代操作系统（如 Linux）中，线程优先级被忽略，使用时间片轮转调度所有线程。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/three-types-of-thread-models-1735555167554-48.png" alt="常见的三种线程模型"></p>
<h3 id="基于内核线程"><a href="#基于内核线程" class="headerlink" title="基于内核线程"></a>基于内核线程</h3><p>Java 中的线程调度依赖于操作系统提供的<strong>原生线程（Native Thread）</strong>支持。具体来说：</p>
<ol>
<li><strong>Java 线程映射到操作系统线程：</strong><ul>
<li>Java 使用 <strong>1:1 模型</strong>，即每个 Java 线程对应一个操作系统线程。</li>
<li>线程的创建、管理和调度全部委托给底层操作系统的线程调度器（如 Windows 的 <strong>线程调度器</strong> 或 Linux 的 <strong>CFS调度器</strong>）。</li>
</ul>
</li>
<li><strong>线程调度策略：</strong><br>操作系统调度器通常采用 <strong>时间片轮转（Round-Robin）</strong> 或 <strong>优先级调度（Priority Scheduling）</strong>策略，为线程分配 CPU 时间。<ul>
<li>Java 线程也有优先级，但其实际执行顺序依赖于操作系统的实现。</li>
</ul>
</li>
<li><strong>时间片和抢占式调度：</strong><ul>
<li>Java 虚拟机（JVM）并不直接管理线程的时间片分配，而是由操作系统决定何时挂起或恢复线程。</li>
<li>Java 线程默认是<strong>抢占式调度</strong>，即高优先级线程可能会抢占 CPU 资源，但操作系统仍有最终决定权。</li>
</ul>
</li>
</ol>
<p>Java 线程通过 JVM 的 <strong>线程库（Thread API）</strong> 调用底层 <strong>操作系统线程库（如 POSIX pthreads 或 Windows API）</strong>来实现线程调度。</p>
<p>Java 线程是基于<strong>内核级线程（Kernel Thread）</strong>，因为：</p>
<ul>
<li>Java 线程依赖操作系统的内核调度器进行管理。</li>
<li>内核线程直接由操作系统管理和调度，可以利用多核 CPU 并行执行多个线程。</li>
<li>用户级线程（如早期的绿色线程）已经被淘汰，Java 不再支持用户级线程。</li>
</ul>
<p><strong>关键组件：</strong></p>
<ol>
<li><strong><code>java.lang.Thread</code>：</strong> Java 提供的线程抽象类，依赖 JVM 的原生接口。</li>
<li><strong><code>Thread.start()</code>：</strong> 调用 JVM 本地方法 <code>start0()</code>，最终委托给操作系统创建线程。</li>
<li><strong><code>Thread.yield()</code>：</strong> 提示线程调度器让出 CPU，但具体是否让出由操作系统决定。</li>
<li><strong><code>Thread.sleep()</code>：</strong> 当前线程进入休眠状态，底层通过操作系统的 <strong>计时器</strong> 和 <strong>休眠 API</strong> 实现。</li>
<li><strong><code>Thread.join()</code>：</strong> 等待其他线程执行完成，依赖于操作系统提供的线程同步机制。</li>
</ol>
<h3 id="OS-线程调度"><a href="#OS-线程调度" class="headerlink" title="OS 线程调度"></a>OS 线程调度</h3><p><strong>1) Windows：</strong></p>
<ul>
<li>使用 <strong>Windows API</strong> 管理线程调度。</li>
<li>支持优先级和基于时间片的抢占式调度策略。</li>
</ul>
<p><strong>2) Linux/Unix：</strong></p>
<ul>
<li>使用 <strong>POSIX Threads (pthreads)</strong> 作为底层实现。</li>
<li>基于 <strong>CFS（Completely Fair Scheduler）</strong> 调度器执行线程调度，按“公平性”分配 CPU 时间片。</li>
</ul>
<h2 id="线程池-Executor"><a href="#线程池-Executor" class="headerlink" title="线程池 Executor"></a>线程池 <code>Executor</code></h2><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p>
<ul>
<li><p>可以复用线程的技术</p>
</li>
<li><p>如果不使用线程池，后台要用新的线程，创建新线程开销很大，请求过多就会严重影响系统性能</p>
</li>
<li><p>创建线程池</p>
<ul>
<li><p>ExecutorService的实现类ThreadPoolExecutor 自创建对象</p>
</li>
<li><p>Executors 工具类</p>
</li>
</ul>
</li>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918001837124-1726751033487-53.png" alt="image-20240918001837124"></p>
</li>
</ul>
<h3 id="构造-ThreadPoolExecutor"><a href="#构造-ThreadPoolExecutor" class="headerlink" title="构造 ThreadPoolExecutor"></a>构造 <code>ThreadPoolExecutor</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">int</span> corePoolSize,//核心线程数量</span></span><br><span class="line"><span class="params">	<span class="type">int</span> maximumPoolSize,//核心线程数量+临时线程数量</span></span><br><span class="line"><span class="params">	<span class="type">long</span> keepAliveTime,//临时线程存活时间</span></span><br><span class="line"><span class="params">	TimeUnit unit,  //临时线程存活时间的单位,是一个枚举<span class="keyword">enum</span></span></span><br><span class="line"><span class="params">	BlockingQueue&lt;Runnable&gt; workQueue,//线程池的任务队列</span></span><br><span class="line"><span class="params">	ThreadFactory threadFactory,//线程池的线程工厂,创建线程</span></span><br><span class="line"><span class="params">	RejectedExecutionHandler handler//任务拒绝策略, 线程全在忙,任务队列也满了,新任务来了怎么处理</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p><code>workQueue</code>: <code>new ArrayBlockingQueue&lt;&gt;(4)</code> 声明一个新的任务队列,容量为4</p>
<p><code>threadFactory</code>: <code>Executors.defaultThreadFactory()</code></p>
<p><code>handler</code>: <code>new ThreadPoolExecutor.AbortPolicy()</code> 丢弃任务抛出异常 默认策略</p>
<p>​        <code>DiscardPolicy</code> 丢弃任务不抛异常     <code>DiscardOldestPolicy</code> 抛弃队列中等待最久任务</p>
<p>​        <code>CallerRunsPolicy</code> 主线程调用<code>Runnable</code>任务的<code>run()</code>方法从而绕过线程池直接执行</p>
<h3 id="处理-Runnable-任务"><a href="#处理-Runnable-任务" class="headerlink" title="处理 Runnable 任务"></a>处理 <code>Runnable</code> 任务</h3><p><code>void execute(Runnable command)</code>: 处理一个任务</p>
<p><code>void shutdown()</code>: 停机, 但是等待所有任务完成</p>
<p><code>List&lt;Runnable&gt; shutdownNow()</code>: 立即停机, 返回未完成任务的列表</p>
<p>核心线程占满, 再排任务队列, 任务队列占满, 就加临时线程。</p>
<h3 id="处理-Callable-任务"><a href="#处理-Callable-任务" class="headerlink" title="处理 Callable 任务"></a>处理 <code>Callable</code> 任务</h3><p><code>Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code> 返回一个任务对象获取线程结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;String&gt; f1 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>));</span><br><span class="line">Future&lt;String&gt; f2 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>));</span><br><span class="line">Future&lt;String&gt; f3 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">300</span>));</span><br><span class="line">Future&lt;String&gt; f4 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">400</span>));</span><br></pre></td></tr></table></figure>

<h3 id="构造线程池：Executors-工具类"><a href="#构造线程池：Executors-工具类" class="headerlink" title="构造线程池：Executors 工具类"></a>构造线程池：Executors 工具类</h3><ul>
<li><p><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>: 创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。任务队列可达 <code>Integer.MAX_VALUE</code> <a href="https://blog.csdn.net/qq_42447950/article/details/81435080">OOM</a>风险</p>
</li>
<li><p><code>public static ExecutorService newSingleThreadExecutor()</code>: 创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程。任务队列可达 <code>Integer.MAX_VALUE</code> <a href="https://blog.csdn.net/qq_42447950/article/details/81435080">OOM</a>风险</p>
</li>
<li><p><code>public static ExecutorService newCachedThreadPool()</code>: 线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了60s则会被回收掉。线程数可达 <code>Integer.MAX_VALUE</code> <a href="https://blog.csdn.net/qq_42447950/article/details/81435080">OOM</a>风险</p>
</li>
<li><p><code>public static ScheduledExecutorService newScheduledThreadPool(int corePoolsize)</code>: 创建一个线程池，可以实现在给定的延迟后运行任务或者定期执行任务。</p>
</li>
<li><p>底层都是ThreadPoolExecutor创建的线程池对象</p>
</li>
</ul>
<p>计算密集型：核心线程数量 = CPU核数 + 1</p>
<p>IO密集型：核心线程数量 = CPU核数*2</p>
<p>Executors工具类可能在大型并发系统有危险，内存溢出</p>
<h2 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a>虚拟线程</h2><p><a href="https://javaguide.cn/java/concurrent/virtual-thread.html">虚拟线程常见问题总结 | JavaGuide</a></p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>java.util.concurrent</title>
    <url>/2024/11/30/java.util.concurrent/</url>
    <content><![CDATA[<h1 id="Java-Concurrency-Overview"><a href="#Java-Concurrency-Overview" class="headerlink" title="Java Concurrency Overview"></a>Java Concurrency Overview</h1><h2 id="java-lang-Thread"><a href="#java-lang-Thread" class="headerlink" title="java.lang.Thread"></a><code>java.lang.Thread</code></h2><ol>
<li><p><strong>线程创建与运行</strong>:</p>
<ul>
<li><strong>继承 <code>Thread</code> 类</strong>: 继承 <code>Thread</code> 并重写 <code>run()</code> 方法<ul>
<li><code>new MyThread().start()</code> </li>
</ul>
</li>
<li><strong>实现 <code>Runnable</code> 接口</strong>: 实现 <code>Runnable</code> 实现 <code>run()</code> 方法<ul>
<li><code>new Thread(runnable).start()</code> </li>
</ul>
</li>
</ul>
</li>
<li><p><strong>线程生命周期</strong>:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/640.png" alt="Java 线程状态变迁图"></p>
<ul>
<li><strong>New</strong>: <code>new Thread()</code>, 还没有调用 <code>start()</code> </li>
<li><strong>Runnable</strong>: 线程已经调用了 <code>start()</code> / 获取锁等待 CPU 调度执行，操作系统层面属于 <strong>Ready</strong> 和 <strong>Running</strong> 状态</li>
<li><strong>Blocked</strong>:  等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</li>
<li><strong>Waiting</strong>: 操作系统的 <strong>Sleep</strong> 状态，等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。需要等待其他线程做出一些特定动作（通知或中断）</li>
<li><strong>Timed Waiting</strong>: 无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。获取锁之后调用 <code>wait(long ms)</code> <code>sleep(long ms)</code> 可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li>
<li><strong>Terminated</strong>: <code>run()</code> 执行完毕正常退出或者抛出了未处理的异常</li>
</ul>
</li>
<li><p><strong>Thread Methods</strong>:</p>
<ul>
<li><strong><code>start()</code></strong>: 线程转为 Runnable 可运行状态，相当于 <code>pthread_create()</code></li>
<li><strong><code>run()</code></strong>: 线程应该执行的方法，相当于 <code>pthread_create()</code> 传的函数指针</li>
<li><strong><code>sleep(long millis)</code></strong>: 调用者睡眠一段时间</li>
<li><strong><code>join()</code></strong>: 父线程等待子线程执行完毕再继续执行</li>
<li><strong><code>interrupt()</code></strong>: 使线程中断</li>
<li><code>currentThread()</code>: 获取当前执行的线程对象</li>
<li><code>get/setName()</code>: 获取线程名称</li>
<li><code>yield()</code>: 声明当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。只是对线程调度器的一个建议，只是建议具有相同优先级的其它线程可以运行。只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。</li>
<li><code>setDaemon()</code>: 将一个线程设置为守护线程。当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。main() 属于非守护线程。</li>
</ul>
</li>
<li><p>线程安全：</p>
<ol>
<li><p>线程互斥同步：<code>synchronized</code> <code>ReentrantLock</code> </p>
</li>
<li><p>线程非阻塞同步：<code>AtomicInteger</code> (CAS)</p>
</li>
<li><p>无同步：<code>ThreadLocal</code> 利用线程各自的栈(FutureTask，线程池)</p>
</li>
</ol>
</li>
<li><p>线程通信与协作：</p>
<ul>
<li><code>thread.join()</code> 父线程与子线程的通信</li>
<li><code>object.wait()/notify()/notifyAll()</code> 可用于 synchronized 对象锁</li>
<li><code>condition.await()/signal()/signalAll()</code> 可用于 Lock 的条件变量</li>
<li>或者使用共享内存，volatile/while轮询 的形式隐式通信</li>
</ul>
</li>
</ol>
<h2 id="java-util-concurrent"><a href="#java-util-concurrent" class="headerlink" title="java.util.concurrent"></a><code>java.util.concurrent</code></h2><p>**<mark><a href="#jvm">理论基础</a><mark>**：</p>
<ol>
<li><p><strong>JVM</strong> 对并发的支持：</p>
<ul>
<li><strong>JMM 内存模型</strong> 解决由于 Cache、指令重排序导致的可见性、有序性问题</li>
<li><code>synchronized</code> 用于解决 CPU 时分复用(操作系统调度)导致的原子性问题<ul>
<li>偏向锁、轻量级锁与重量级锁，理解锁升级和锁优化机制，如自旋锁与锁消除。</li>
</ul>
</li>
<li><code>volatile</code> 用于解决指令重排序与可见性问题</li>
<li><code>final</code> 创建不可变对象或常量(线程安全)，内存可见性</li>
<li>happens-before 原则</li>
</ul>
</li>
<li><p>常见<strong>并发设计模式</strong>：</p>
<ul>
<li><p><strong>生产者-消费者模式：</strong> 使用阻塞队列（BlockingQueue）优化实现。</p>
</li>
<li><p><strong>读写分离模式：</strong> 提高读写性能，适合数据库访问优化，读写锁、CoW 集合。</p>
</li>
<li><p><strong>线程池模式：</strong> 使用线程池 ThreadPool 统一管理线程资源。</p>
</li>
<li><p><strong>Future 模式：</strong> 提供任务执行结果的异步返回。</p>
</li>
</ul>
</li>
<li><p><strong>死锁检测与避免策略</strong></p>
</li>
</ol>
<p><strong>可选：</strong>虚拟线程、Reactor、Disruptor</p>
<p><code>java.util.concurrent</code> 给并发控制提供更多可用的操作:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/format,webp.webp" alt="img"></p>
<ol>
<li><p><strong><mark><a href="#lock">Locks</a><mark></strong>:（悲观锁）</p>
<ul>
<li><strong>ReentrantLock</strong>: 相同线程可以重复持有同一把锁</li>
<li><strong>ReentrantReadWriteLock</strong>: 有读锁和写锁两部分组成，支持多线程读取和单个线程写入</li>
<li><strong>StampedLock</strong>: 不可重入的读写锁</li>
<li><strong>LockSupport</strong>: 提供线程阻塞同步原语<ul>
<li><code>park()</code> <code>unpark(thread)</code> </li>
</ul>
</li>
<li><strong>Condition</strong>: 更细粒度的线程同步</li>
<li><strong>AbstractQueuedSynchronizer</strong>: AQS 自定义同步器</li>
</ul>
</li>
<li><p><strong><mark><a href="#tools">Tools</a><mark></strong>(Synchronizers): 和锁配合使用，线程安全工具类</p>
<ul>
<li><strong>CountDownLatch</strong>: Allows one or more threads to wait until a set of operations being performed in other threads completes. 闭锁是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待</li>
<li><strong>CyclicBarrier</strong>: A barrier that all threads must reach before any thread can proceed.（栅栏） 是因为是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 ，并且在释放等待线程后可以重用。</li>
<li><strong>Semaphore</strong>: Controls access to a resource by multiple threads. 它的本质是一个“共享锁“。信号量维护了一个信号量许可集。线程可以通过调用 acquire()来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过release()来释放它所持有的信号量许可。</li>
</ul>
</li>
<li><p><strong><mark><a href="#atomic">Atomic Variables</a><mark></strong>: CAS Lock-free(乐观锁)</p>
<ul>
<li><strong>AtomicBoolean</strong>, <strong>AtomicInteger</strong>, <strong>AtomicLong</strong></li>
<li><strong>AtomicIntegerArray</strong> These classes support lock-free thread-safe programming on single variables using low-level atomic operations.</li>
<li>CAS 构建自旋锁</li>
<li>ABA 问题与解决方案（如 AtomicStampedReference）。</li>
</ul>
</li>
<li><p><strong><mark><a href="#executor">Executor</a><mark></strong>: 线程池及异步任务相关</p>
<ul>
<li><p><strong>Callable</strong>: 和 Runnable 类似，但是有返回值</p>
</li>
<li><p><strong>Future</strong> <strong>FutureTask</strong> </p>
<ul>
<li>CompletableFuture 异步编程</li>
</ul>
</li>
<li><p><strong>ExecutorService</strong>: A flexible interface for managing and controlling thread execution.</p>
<ul>
<li><strong>ThreadPoolExecutor</strong>: 通常所说的线程池</li>
</ul>
</li>
<li><p><strong>Fork/Join</strong> 框架</p>
</li>
</ul>
</li>
<li><p><strong>Concurrent Collections/Maps</strong>: 线程安全的集合</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-concurrent-collections.png" alt="Concurrent Collections"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-thread-x-juc-overview-2.png" alt="image"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Collection-Hierarchy-concurrent-1735225309564-38.png" alt="Collection Hierarchy concurrent"></p>
<ul>
<li><strong>ConcurrentHashMap</strong> 线程安全的哈希表</li>
<li><strong>CopyOnWriteArrayList</strong> CoW List</li>
<li><strong>CopyOnWriteArraySet</strong> CoW Set</li>
<li><strong>BlockingQueue</strong> 阻塞队列</li>
</ul>
</li>
</ol>
<h1 id="JVM-支持"><a href="#JVM-支持" class="headerlink" title="JVM 支持"></a><span id="jvm">JVM 支持</span></h1><h2 id="并发问题的根源"><a href="#并发问题的根源" class="headerlink" title="并发问题的根源"></a>并发问题的根源</h2><h3 id="CPU-时分复用"><a href="#CPU-时分复用" class="headerlink" title="CPU 时分复用"></a>CPU 时分复用</h3><p>**<mark>原子性<mark>**：一个过程要么完全执行并且执行的过程不会被任何因素打断，要么就完全不执行。</p>
<p>操作系统基于受限直接执行(Limited Direct Execution)来运行任务，基于 CPU 的时钟中断对任务进行调度，通过这种 CPU 虚拟化技术让应用程序认为是自己在独占 CPU。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">i += <span class="number">1</span>;<span class="comment">// 线程1执行</span></span><br><span class="line">i += <span class="number">1</span>;<span class="comment">// 线程2执行</span></span><br><span class="line"><span class="comment">/*注意：i += 1 需要三条 CPU 指令</span></span><br><span class="line"><span class="comment">1. 将变量 i 从内存读取到 CPU寄存器；</span></span><br><span class="line"><span class="comment">2. 在CPU寄存器中执行 i + 1 操作；</span></span><br><span class="line"><span class="comment">3. 将最后的结果 i 写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。*/</span></span><br></pre></td></tr></table></figure>

<p>由于CPU分时复用（线程切换）的存在，线程 1 执行了第一条指令后，就切换到线程 2 执行，假如线程 2 执行了这三条指令后，再切换会线程 1 执行后续两条指令，将造成最后写到内存中的 <code>i</code> 是 2 而不是 3</p>
<blockquote>
<p>在 Java 中，可以借助<code>synchronized</code>、各种 <code>Lock</code> 以及各种原子类实现原子性。</p>
<p><code>synchronized</code> 和各种 <code>Lock</code> 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 <code>volatile</code>或者<code>final</code>关键字）来保证原子操作。</p>
</blockquote>
<h3 id="CPU-Cache"><a href="#CPU-Cache" class="headerlink" title="CPU Cache"></a>CPU Cache</h3><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/cpu-cache-protocol.png" alt="缓存一致性协议" style="zoom:67%;" />

<p><mark><strong>可见性</strong><mark>：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。</p>
<ol>
<li>CPU Cache 缓存的是物理内存数据，用于解决 CPU 处理速度和物理内存不匹配的问题<ul>
<li>多核缓存与主内存交互时需要遵守的原则和规范叫做 <strong>缓存一致协议</strong>，如 MESI</li>
</ul>
</li>
<li>应用程序眼中是一片完整的虚拟内存，由操作系统提供内存的虚拟化，将虚拟内存地址映射到真正的物理内存空间中。<ul>
<li>操作系统也要解决缓存(比如 TLB)与内存(比如页表)的一致性问题</li>
</ul>
</li>
</ol>
<blockquote>
<p>在 Java 中，可以借助<code>synchronized</code>、<code>volatile</code> 以及各种 <code>Lock</code> 实现可见性。</p>
<p>如果我们将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
</blockquote>
<h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>**<mark>有序性<mark>**：即程序执行的顺序按照代码的先后顺序执行。</p>
<p>为了提升执行速度/性能，计算机在执行程序代码的时候，会对指令进行重排序。 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。<strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p>
<blockquote>
<p>在 Java 中，<code>volatile</code> 关键字可以禁止指令进行重排序优化。</p>
</blockquote>
<h4 id="编译器优化重排"><a href="#编译器优化重排" class="headerlink" title="编译器优化重排"></a>编译器优化重排</h4><p>编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</p>
<p>对于编译器，禁止重排两句代码的指令，需要在它们之间插入 compiler fence。</p>
<h4 id="CPU-优化重排"><a href="#CPU-优化重排" class="headerlink" title="CPU 优化重排"></a>CPU 优化重排</h4><p>对于处理器，通过插入内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence，一种 CPU 指令）的方式来禁止特定类型的处理器重排序。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障变量的可见性。</p>
<p><a href="https://zhuanlan.zhihu.com/p/413889872">并发编程：乱序执行的那些事儿 - 知乎</a>  <a href="https://www.cnblogs.com/maycap/p/15690751.html">图解CPU为何要乱序执行 - last_coding - 博客园</a>  </p>
<h5 id="指令级并行重排-乱序执行-ILP"><a href="#指令级并行重排-乱序执行-ILP" class="headerlink" title="指令级并行重排/乱序执行(ILP)"></a>指令级并行重排/乱序执行(ILP)</h5><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2586739-20211214234820966-1713761498.png" alt="img" style="zoom: 80%;" />

<p>RISC 架构的特点就是指令长度相等，执行时间恒定(通常为一个时钟周期)，因此处理器设计起来就很简单，可以通过深长的流水线达到很高的频率，IBM 的 Power6 就可以轻松地达到 4.7GHz 的起步频率。和 RISC 相反，CISC 指令的长度不固定，执行时间也不固定，因此 Intel 的 RISC/CISC 混合处理器架构就要通过 Instruction Fetch &amp; Decode 将 x86 指令翻译为 μops，从而获得 RISC 架构的长处，提升内部执行效率。x86 指令大部分简单指令可以一对一翻译为 μops，复杂的可能 1 ~ 4 条 μops。解码器是按位数取指的，在经过译码，因此每次可能产生多条 μops。</p>
<p>计算机执行符合局部性原理，这里不仅指同个指令可能重复执行，也指内存访问。而内存访问显然是比较慢的，<strong>对多条指令重新排序，把访存相关的指令放到一起，显然是可以提升效率的。</strong></p>
<h5 id="内存系统重排"><a href="#内存系统重排" class="headerlink" title="内存系统重排"></a>内存系统重排</h5><p>另外，内存系统也会有“重排序”，但又不是真正意义上的重排序。在 JMM 里表现为主内存和线程的本地内存可能不一致，进而导致程序在多线程下执行可能出现问题。</p>
<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a><mark>Java 内存模型<mark></h2><p>并发编程环境下，像 CPU 多级缓存和指令重排这类设计可能会导致程序运行出现一些问题。就比如说我们上面提到的指令重排序就可能会让多线程程序的执行出现问题。</p>
<p>JMM 说白了就是定义了一些规范来解决这些问题，例如 JMM 抽象了 happens-before 原则（后文会详细介绍到）来解决指令重排序问题。开发者可以利用 JMM 规范更方便地开发多线程程序。Java 开发者不需要了解底层原理，直接使用并发相关的一些关键字和类（比如 <code>volatile</code>、<code>synchronized</code>、各种 <code>Lock</code>）即可开发出并发安全的程序。</p>
<p>与 Java 内存区域要区分开：</p>
<ul>
<li>JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说<strong>堆主要用于存放对象实例</strong>，栈用来存放局部变量。</li>
<li>Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</li>
</ul>
<h3 id="线程与主内存"><a href="#线程与主内存" class="headerlink" title="线程与主内存"></a>线程与主内存</h3><p>在当前的 Java 内存模型下，线程可以把变量保存 <strong>本地内存</strong> （比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/jmm.png" alt="JMM(Java 内存模型)" style="zoom:60%;" />

<ul>
<li><strong>主内存</strong>：所有线程创建的实例对象都存放在主内存中，不管该实例对象是<strong>成员变量</strong>，还是<strong>局部变量</strong>，类信息、<strong>常量</strong>、<strong>静态变量</strong>都是放在主内存中。为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。</li>
<li><strong>本地内存</strong>：每个线程都有一个私有的本地内存，本地内存存储了该线程以读 / 写共享变量的副本。每个线程只能操作自己本地内存中的变量，<strong>无法直接访问其他线程的本地内存</strong>。线程间通信必须通过主内存来进行。本地内存是 JMM 抽象出来的一个概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。图中的线程1想和线程2通信，线程1必须把自己的共享变量副本同步到住内存里，然后线程2需要从主内存读取，读取的共享变量是否是线程1修改过的，是不知道的，由此引发了线程安全问题。</li>
<li>Java 内存模型定义了八种同步操作，规定了关于主内存与工作内存直接的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现细节。规定了一些同步规则来保证这些同步操作的正确执行 <a href="https://javaguide.cn/java/concurrent/jmm.html#jmm-%E6%98%AF%E5%A6%82%E4%BD%95%E6%8A%BD%E8%B1%A1%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%B8%BB%E5%86%85%E5%AD%98%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">详见 JavaGuide</a> </li>
</ul>
<h3 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a>happens-before 原则</h3><p>JSR 133 引入了 happens-before 这个概念来描述<strong>两个操作之间的内存可见性</strong>。</p>
<p>happens-before 原则的诞生是为了程序员和编译器、处理器之间的平衡。程序员追求的是易于理解和编程的强内存模型，遵守既定规则编码即可。编译器和处理器追求的是较少约束的弱内存模型，让它们尽己所能地去优化性能，让性能最大化。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220731155332375-1735372822645-10-1735372984006-14.png" alt="img" style="zoom:70%;" />

<ul>
<li>为了对编译器和处理器的约束尽可能少，只要<strong>不改变程序的执行结果</strong>（单线程程序和正确执行的多线程程序），编译器和处理器怎么进行重排序优化都行。两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。</li>
<li>对于会改变程序执行结果的重排序，JMM 要求<u>编译器</u>和<u>处理器</u>必须<mark>禁止<mark>这种重排序。</li>
</ul>
<p>happens-before 原则表达的意义其实并不是一个操作发生在另外一个操作的前面，虽然这从程序员的角度上来说也并无大碍。更准确地来说，它更想表达的意义是**前一个操作的结果对于后一个操作<mark>是可见的<mark>**，无论这两个操作是否在同一个线程里。</p>
<p>具体规则：1. 按照代码先后顺序 2. 线程的 <code>start()</code> 先于其他所有动作 3. 传递性</p>
<ol start="4">
<li><p>Monitor 的解锁 happens- before 于随后对此 Monitor 的加锁 <code>synchronized</code></p>
</li>
<li><p>对 <code>volatile</code> 域的<mark>写<mark>，happens- before 于任意的后续对此 <code>volatile</code> 域的<mark>读<mark> </p>
<ul>
<li><code>volatile</code> 仅保证变量读写操作的可见性和有序性，不保证复合操作（ <code>i++</code>）的原子性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 线程1</span></span><br><span class="line">a = <span class="number">1</span>;        <span class="comment">// 普通写</span></span><br><span class="line">flag = <span class="literal">true</span>;  <span class="comment">// volatile 写</span></span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;   <span class="comment">// volatile 读</span></span><br><span class="line">    System.out.println(a); <span class="comment">// 一定会输出 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>保证 <code>flag = true</code> 的写入之前，<code>a = 1</code> 已经执行完毕，并且对线程 2 可见。</li>
<li>在 JDK 5 之前，由于没有禁止 volatile 指令重排序，<code>a = 1</code> 可能会被移动到 <code>flag = true</code> 之后执行，导致线程 2 看到 <code>flag</code> 为 true，但 <code>a</code> 的值仍然是 0。这种情况显然是违背直觉的，也无法确保程序正确性。</li>
<li>在 JDK 5 及之后，<code>a = 1</code> 一定会在 <code>flag = true</code> 之前执行， <code>flag = true</code> 一定在 <code>if(flag)</code> 之前执行，从而保证了有序性和内存可见性。</li>
</ul>
</li>
</ol>
<p><strong>JMM 与 happens-before</strong></p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220731084604667.png" alt="happens-before 与 JMM 的关系" style="zoom:67%;" />

<p>程序员在 happens-before 提供的内存可见性基础上编程，JMM 的实现：根据编译器和处理器的重排序规则，如果出现了重排序，除非没有影响执行结果，否则就禁止重排序：为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。实现细节对于程序员是透明的，只要保证程序执行时语义不改变即可。</p>
<h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a><mark><code>volatile</code> 关键字<mark></h2><ol>
<li><p><code>volatile</code> 关键字并非 Java 语言特有，在 C 语言里也有，其最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 <code>volatile</code> 修饰，这就告诉编译器这个变量是共享且不稳定的，每次使用它都到主存中进行读取。（可见性）</p>
</li>
<li><p>在 Java 中，<code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是<strong>防止 JVM 的指令重排序</strong>。 如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。（有序性）（Unsafe 类的内存屏障方法也可以实现 volatile 相同的效果）</p>
</li>
<li><p><code>volatile</code> 无法保证原子性。</p>
</li>
</ol>
<h3 id="双重校验实现单例：volatile-synchronized"><a href="#双重校验实现单例：volatile-synchronized" class="headerlink" title="双重校验实现单例：volatile + synchronized"></a>双重校验实现单例：<code>volatile</code> + <code>synchronized</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton unique;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getunique</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (unique &lt;mark&gt; <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁(对象锁)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (unique &lt;mark&gt; <span class="literal">null</span>) &#123;</span><br><span class="line">                    unique = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unique;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 <code>unique</code> 的写操作: <code>unique = new Singleton();</code> 可以分成如下三步</p>
<ol>
<li>为 <code>unique</code> 分配内存空间 malloc</li>
<li>初始化 <code>unique</code> initialize</li>
<li>将 <code>unique</code> 指向分配的引用地址(赋值)</li>
</ol>
<p>对 <code>unique</code> 的读操作: <code>if (unique == null)</code> </p>
<p><code>volatile</code> 使 <strong>写操作的第 3 步</strong> 一定对读操作可见；</p>
<p>但是指令重排仍然会导致一些问题，在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getunique</code>() 后发现 <code>unique</code> 不为空，因此返回 <code>unique</code>，但此时 <code>unique</code> 还未被初始化。<code>volatile</code> 能够禁止这种重排。</p>
<h2 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a><mark><code>synchronized</code> 关键字<mark></h2><p><code>synchronized</code> 是 Java 中的一个关键字，也叫做对象锁，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。它是 Java 内置的同步机制，在 JVM 中实现，隐式获取、自动释放。</p>
<p>在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。这是因为监视器锁（Monitor）是依赖于底层的操作系统的互斥锁 <code>mutex</code> 和条件变量 <code>cond</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>
<p>在 Java 6 之后， <code>synchronized</code> 引入了大量的优化如<strong>自旋锁</strong>、适应性自旋锁、<strong>锁消除</strong>、<strong>锁粗化</strong>、<del>-偏向锁-</del>、<strong>轻量级锁</strong>等技术来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多。因此， <code>synchronized</code> 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 <code>synchronized</code> 。</p>
<blockquote>
<p>由于偏向锁增加了 JVM 的复杂性，同时也并没有为所有应用都带来性能提升。因此，在 JDK 15 中，偏向锁被默认关闭（仍然可以使用 <code>-XX:+UseBiasedLocking</code> 启用偏向锁），在 JDK 18 中，偏向锁已经被彻底废弃（无法通过命令行打开）。</p>
</blockquote>
<ul>
<li>加在实例方法上，相当于<code>synchronized(this)</code>；</li>
<li>加在静态方法上，相当于<code>synchronized(Example.class)</code>；</li>
<li>尽量使用<code>this</code>作为对象锁，不要图方便使用字符串常量等</li>
</ul>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><h4 id="同步代码块与同步方法"><a href="#同步代码块与同步方法" class="headerlink" title="同步代码块与同步方法"></a>同步代码块与同步方法</h4><p><strong><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong></p>
<p>含有同步代码块的字节码中包含一个 <code>monitorenter</code> 指令以及两个 <code>monitorexit</code> 指令，这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放。</p>
<p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<blockquote>
<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的。每个对象中都内置了一个 <code>ObjectMonitor</code> 对象。</p>
<p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p>
</blockquote>
<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p>
<p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p>
<p><strong>同步方法</strong>：<code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取而代之的是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p>
<h4 id="可重入性-Reentrancy"><a href="#可重入性-Reentrancy" class="headerlink" title="可重入性 (Reentrancy)"></a>可重入性 (Reentrancy)</h4><p><code>synchronized</code> 的可重入性依赖于 <strong>Monitor 对象</strong> 的 <strong>锁计数器</strong> 和 <strong>锁持有线程ID</strong>。</p>
<p>同一个线程每进入一次同步方法或者对象锁相同的同步代码块，就会将锁计数器+1，退出时-1，减到0则释放锁</p>
<h4 id="ObjectMonitor"><a href="#ObjectMonitor" class="headerlink" title="ObjectMonitor"></a>ObjectMonitor</h4><p>synchronized 是基于管程实现的，核心的数据结构是 ObjectMonitor，AQS也基于MESA管程</p>
<p><strong>ObjectMonitor 的核心作用</strong></p>
<ul>
<li>保证同一时刻只有一个线程能执行同步代码块（<strong>互斥</strong>）。</li>
<li>提供线程之间的等待和唤醒机制（<strong>条件变量</strong>）。</li>
</ul>
<p>每个 Java 对象都与一个 对象监视器锁 关联，用于控制对该对象的访问权限。采用 Mesa 语义</p>
<p><strong>底层机制</strong> </p>
<ul>
<li><strong>互斥锁（Mutex）</strong>：<ul>
<li>Monitor 使用操作系统的互斥锁来实现互斥访问。</li>
<li>重量级锁通过内核态的同步原语（如 <code>futex</code> 或 <code>pthread_mutex</code>）挂起和唤醒线程。</li>
</ul>
</li>
<li><strong>条件变量（Condition Variable）</strong>：<ul>
<li>等待队列和条件变量用于管理线程状态。<code>pthread_cond</code></li>
<li>条件变量依赖于操作系统的 <code>wait()</code> 和 <code>signal()</code> 机制，控制线程等待和唤醒。</li>
</ul>
</li>
<li><strong>线程阻塞与唤醒</strong>：<ul>
<li>当线程无法获取锁时，Monitor 会将其挂起，并调用操作系统的线程调度机制。</li>
<li>被唤醒的线程通过抢占式调度重新竞争锁资源。</li>
</ul>
</li>
</ul>
<h3 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h3><p>锁主要有四种状态：无锁、偏向锁、轻量级锁、重量级锁，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3230688-20231101142724469-1226844103.png" alt="img" style="zoom: 80%;" />

<p><strong>对象头中的 Mark Word</strong></p>
<p>Java 对象在内存中由以下部分组成：</p>
<table>
<thead>
<tr>
<th>内存布局</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>对象头（Header）</td>
<td>4 字节 Mark Word、4 字节 <code>.class</code> Pointer</td>
</tr>
<tr>
<td>实例数据</td>
<td>实例变量存储的数据</td>
</tr>
<tr>
<td>对齐填充</td>
<td>用于内存对齐，按照8字节填充</td>
</tr>
</tbody></table>
<p>Mark Word 是对象头中的一部分，存储对象的状态和锁信息。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/443934-20201207134826598-1740849743.png" alt="img"></p>
<p><strong>注：锁状态会根据竞争情况自动升级，从偏向锁到轻量级锁，再到重量级锁。</strong> </p>
<h3 id="synchronized-与-volatile-的区别"><a href="#synchronized-与-volatile-的区别" class="headerlink" title="synchronized 与 volatile 的区别"></a><code>synchronized</code> 与 <code>volatile</code> 的区别</h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li>
<li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li>
<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a><code>final</code> 关键字</h2><p><a href="https://www.nenggz.com/md/java/thread/java-thread-x-key-final.html">关键字: final详解 | Java 全栈知识体系</a> </p>
<p>用 final 修饰的类不可以被继承，用 final 修饰的方法不可以被覆写，用 final 修饰的属性一旦初始化以后不可以被修改。当然，我们不关心这些段子，这节，我们来看看 final 带来的内存可见性影响。</p>
<p>之前在说双重检查的单例模式的时候，提过了一句，如果所有的属性都使用了 final 修饰，那么 volatile 也是可以不要的，这就是 final 带来的可见性影响。</p>
<p>在对象的构造方法中设置 final 属性，<strong>同时在对象初始化完成前，不要将此对象的引用写入到其他线程可以访问到的地方</strong>（不要让引用在构造函数中逸出）。如果这个条件满足，当其他线程看到这个对象的时候，那个线程始终可以看到正确初始化后的对象的 final 属性。</p>
<p>上面说得很明白了，final 属性的写操作不会和此引用的赋值操作发生重排序，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x.finalField = v; ...; sharedRef = x;</span><br></pre></td></tr></table></figure>

<h2 id="ThreadLocal-lt-T-gt"><a href="#ThreadLocal-lt-T-gt" class="headerlink" title="ThreadLocal&lt;T&gt;"></a><mark><code>ThreadLocal&lt;T&gt;</code><mark></h2><p><code>ThreadLocal</code> 主要用于以下场景：</p>
<ol>
<li><strong>线程安全的变量管理：</strong> 比如事务管理、用户会话等。</li>
<li><strong>避免同步锁：</strong> 替代传统的锁机制，提高并发性能。</li>
<li><strong>数据库连接或会话缓存：</strong> 每个线程维护自己的数据库连接实例。</li>
</ol>
<p>T 用于表示 ThreadLocal 存的值类型</p>
<p>ThreadLocal在Spring中发挥着巨大的作用，在管理request作用域中的bean、事务管理、任务调度、aop等模块都出现了它的身影。<br>Spring中绝大部分Bean都可以声明成Singleton作用域，采用ThreadLocal进行封装，因此有状态的bean就能够以 Singleton的方式在多线程中正常工作了。</p>
<h3 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h3><p><strong>JVM 提供线程隔离：</strong></p>
<ul>
<li>每个线程都有自己的栈空间和线程私有变量。</li>
<li>JVM 将 <code>Thread</code> 对象与其局部变量绑定，保证变量不被其他线程访问。</li>
</ul>
<p><strong>JDK 提供 <code>ThreadLocal</code>：</strong> </p>
<ul>
<li><code>ThreadLocal</code> 依赖于每个线程 (<code>Thread</code> 对象) 内部的 <code>ThreadLocalMap</code> 实现数据存储，每个线程都持有一个独立的 <code>ThreadLocalMap</code> 实例</li>
<li><code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</li>
<li><code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</li>
<li>每次访问 <code>ThreadLocal</code> 时，都会从当前线程的 <code>ThreadLocalMap</code> 查找对应的value。</li>
<li>不同线程之间的 <code>ThreadLocalMap</code> 互不影响，因此保证了变量的线程隔离性。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2-CFHd4NU8.png" alt="img"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ThreadLocal-01.png" alt="ThreadLocal各引用间的关系"></p>
<p>哈希冲突解决：开放地址法（线性探测）</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>注意泛型、remove避免内存泄露 public static final</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义 ThreadLocal 变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// tl = ThreadLocal.withInitial(() -&gt; 0) 可以设置初始值</span></span><br><span class="line">tl.set(<span class="number">100</span>); <span class="comment">// 当前线程设置值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get(); <span class="comment">// 获取当前线程的值</span></span><br><span class="line">tl.remove(); <span class="comment">// 避免内存泄漏</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241230193230746.png" alt="image-20241230193230746"></p>
<p>如图 在 web 请求到达时，进入controller之前的interceptor可以</p>
<h3 id="内存泄漏：弱引用与强引用"><a href="#内存泄漏：弱引用与强引用" class="headerlink" title="内存泄漏：弱引用与强引用"></a>内存泄漏：弱引用与强引用</h3><p>key 是 ThreadLocal 对象，弱引用；value 是 Object 对象，强引用。</p>
<p>那么在<code>ThreadLocal.get()</code>的时候，发生<code>GC</code>之后，<code>key</code>是否是<code>null</code>？</p>
<p>为了搞清楚这个问题，我们需要搞清楚<code>Java</code>的<strong>四种引用类型</strong>：</p>
<ul>
<li><strong>强引用</strong>：我们常常 new 出来的对象就是强引用类型，只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足的时候</li>
<li><strong>软引用</strong>：使用 SoftReference 修饰的对象被称为软引用，软引用指向的对象在内存要溢出的时候被回收</li>
<li><strong>弱引用</strong>：使用 WeakReference 修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收</li>
<li><strong>虚引用</strong>：虚引用是最弱的引用，在 Java 中使用 PhantomReference 进行定义。虚引用中唯一的作用就是用队列接收对象即将死亡的通知</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/5-GYIVKEun.png" alt="img"></p>
<p>当作为 key 的 <code>ThreadLocal</code> 实例失去强引用后，只要发生 GC 就会被回收，但是其对应的 value <code>Object</code> 仍然存在于 <code>ThreadLocalMap</code> 中，因为 <code>Entry</code> 对象强引用了它。如果线程持续存活（例如线程池中的线程），<code>ThreadLocalMap</code> 也会一直存在，导致 key 为 <code>null</code> 的 entry 无法被垃圾回收，机会造成内存泄漏。</p>
<ol>
<li>在使用完 <code>ThreadLocal</code> 后，<mark>务必调用 <code>remove()</code> 方法<mark>。 这是最安全和最推荐的做法。 <code>remove()</code> 方法会从 <code>ThreadLocalMap</code> 中显式地移除对应的 entry，彻底解决内存泄漏的风险。 即使将 <code>ThreadLocal</code> 定义为 <code>static final</code>，也强烈建议在每次使用后调用 <code>remove()</code>。</li>
<li>在线程池等线程复用的场景下，<mark>使用 <code>try-finally</code> 块<mark>可以确保即使发生异常，<code>remove()</code> 方法也一定会被执行。</li>
</ol>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a><span id="lock">锁</span></h1><p><code>java.util.concurrent.locks</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241230173434255-1735551283426-42.png" alt="image-20241230173434255"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241230173500715.png" alt="image-20241230173500715"></p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><mark><code>ReentrantLock</code><mark></h2><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个<mark>可重入<mark>且<mark>独占式<mark>的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了<strong>非阻塞</strong>、<strong>超时</strong>、<strong>中断</strong>、<strong>公平锁和非公平锁</strong>等高级功能。</p>
<p>继承关系：实现了 Lock 接口，有一个 Sync 内部类，Sync 继承了 AQS，加锁和释放锁基本在 Sync 中实现，Sync 有公平锁 FairSync 和非公平锁 NonfairSync 两个子类。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aqs.png" alt="Classes"></p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本如上，finally 逻辑一定要释放锁，防止死锁</p>
<h3 id="与-synchronized-比较"><a href="#与-synchronized-比较" class="headerlink" title="与 synchronized 比较"></a>与 <code>synchronized</code> 比较</h3><table>
<thead>
<tr>
<th></th>
<th><code>synchronized</code></th>
<th><code>ReentrantLock</code></th>
</tr>
</thead>
<tbody><tr>
<td>实现</td>
<td><strong>JVM</strong> 底层关键字</td>
<td><strong>JDK</strong> API</td>
</tr>
<tr>
<td>公平锁</td>
<td>不支持</td>
<td>可显式指定 <code>new Reentrantlock(true)</code></td>
</tr>
<tr>
<td>多条件/选择通信</td>
<td>只支持一个条件变量</td>
<td>Condition 支持多个条件变量</td>
</tr>
<tr>
<td>线程通信API</td>
<td><code>wait()</code> <code>notify()</code> <code>notifyAll()</code></td>
<td><code>await()</code> <code>signal()</code> <code>signalAll()</code> <code>lock.newCondition()</code></td>
</tr>
<tr>
<td>可重入</td>
<td>支持</td>
<td>支持 <code>getHoldCount()</code> 查看重入次数</td>
</tr>
<tr>
<td>超时等待</td>
<td>不支持</td>
<td>支持 <code>tryLock(timeout)</code> 超时返回机制</td>
</tr>
<tr>
<td>释放</td>
<td>进出代码块自动完成</td>
<td>手动 (<code>lock()</code> <code>unlock()</code>)</td>
</tr>
<tr>
<td>中断</td>
<td>不可响应中断</td>
<td><code>lock.lockInterruptibly()</code></td>
</tr>
<tr>
<td>阻塞获取</td>
<td>只能阻塞获取</td>
<td>支持非阻塞获取<code>tryLock()</code> 失败直接返回</td>
</tr>
</tbody></table>
<p>超时等待：防止死锁， 防止线程无限期阻塞</p>
<p>等待可中断：获取锁的线程在阻塞等待的过程中，如果其他线程中断当前线程 <code>interrupt()</code> ，就会抛出 <code>InterruptedException</code> 异常，可以捕获该异常，做一些处理操作</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>包含独占写锁和共享读锁，在读多写少的情况下性能很好，分为可重入<code>ReentrantReadWriteLock</code> 和不可重入 <code>StampedLock</code> <a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#reentrantreadwritelock-%E6%98%AF%E4%BB%80%E4%B9%88">详见 JavaGuide</a> </p>
<p>ReentrantReadWriteLock </p>
<p>1、读写锁接口ReadWriteLock接口的一个具体实现，实现了读写锁的分离， </p>
<p>2、支持公平和非公平，底层也是基于AQS实现 </p>
<p>3、允许从写锁降级为读锁 流程：先获取写锁，然后获取读锁，最后释放写锁；但不能从读锁升级到写锁 </p>
<p>4、重入：读锁后还可以获取读锁；获取了写锁之后既可以再次获取写锁又可以获取读锁 核心：读锁是共享的，写锁是独占的。 读和读之间不会互斥，读和写、写和读、写和写之间才会互斥， 主要是提升了读写的性能</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a><span id="tools"><mark>AQS<mark></span></h2><p><a href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解 - waterystone - 博客园</a> </p>
<p><strong>AQS（AbstractQueuedSynchronizer）</strong> 是 <strong>Java 并发包</strong>（<code>java.util.concurrent</code>）提供的一个<strong>底层同步框架</strong>，是一个抽象类，用来实现锁和同步器。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，</p>
<ul>
<li>独占：<code>tryAcquire-tryRelease</code>(ReentrantLock)</li>
<li>共享：<code>tryAcquireShared-tryReleaseShared</code>(Semaphore, CountDownLatch)</li>
<li>AQS也支持同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code> </li>
</ul>
<h3 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ol>
<li><p><strong>共享变量 (state)：</strong> </p>
<ul>
<li>AQS 内部有一个整数 <code>volatile</code> 变量 <code>state</code>，用来表示当前锁的状态，比如 0 表示空闲，1 表示已占用。</li>
<li>多个线程可以通过 <strong>CAS 操作</strong>来修改这个共享变量，从而实现并发控制。</li>
</ul>
</li>
<li><p><strong>等待队列 (CLH FIFO队列)：</strong> </p>
<p><code>Node</code>: 含有<code>thread</code>对象</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/40cb932a64694262993907ebda6a0bfetplv-k3u1fbpfcp-zoom-1.png" alt="img"></p>
<ul>
<li>如果线程无法获取共享资源，就进入一个等待队列，这个队列是一个<strong>双向链表</strong>结构。</li>
</ul>
<p><code>waitStatus</code>: </p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/785ca26c055b5be2761374af6a0c7bc5.webp?x-image-process=image/format,png#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><strong>CANCELLED</strong>(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li>
<li><strong>SIGNAL</strong>(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</li>
<li><strong>CONDITION</strong>(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将<strong>从等待队列转移到同步队列中</strong>，等待获取同步锁。</li>
<li><strong>PROPAGATE</strong>(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li>
<li><strong>0</strong>：新结点入队时的默认状态。</li>
</ul>
<p>注意，<strong>负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用&gt;0、&lt;0来判断结点的状态是否正常</strong>。</p>
</li>
<li><p><strong>模板方法：</strong>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可<strong>，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</strong> </p>
<ul>
<li><p><code>isHeldExclusively()</code>：是否正在独占资源。只有用到condition才需要去实现它。</p>
</li>
<li><p><code>tryAcquire(int i)</code>：独占方式。尝试获取资源，成功则返回true，失败则返回false。</p>
</li>
<li><p><code>tryRelease(int i</code>)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</p>
</li>
<li><p><code>tryAcquireShared(int i)</code>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</p>
</li>
<li><p><code>tryReleaseShared(int i)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>
</li>
<li><p>参数 <code>i</code> 表示共享资源的个数，<code>tryAcquire</code> 就是在更改 <code>state</code></p>
<ul>
<li>以<code>ReentrantLock</code>为例，<code>tryLock()</code>就是在非阻塞获取，<code>lock()</code>就是真正的获取过程，先<code>initialTryLock()</code> 一下，逻辑和<code>tryLock()</code>类似这里默认state就是1，因为是Lock自己内部的。如果失败了才真正<code>acquire(1)</code>，这里的1就代表资源的个数（锁的个数）只有1，这里才开始重写AQS的内容，<code>tryAcquire(1)</code> 开始…</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!initialTryLock())</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><a href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解 - waterystone - 博客园</a> </p>
<ol>
<li>尝试获取<ul>
<li>如果共享资源空闲，线程可以直接占用资源。</li>
<li>如果锁已被占用，线程会创建一个节点加入队列尾部。</li>
</ul>
</li>
<li>排队等待<ul>
<li>前一个线程释放锁时，会通知队列中的下一个线程。</li>
<li>通知机制依赖 <code>LockSupport.park()</code> 和 <code>LockSupport.unpark()</code> 实现线程通信。</li>
</ul>
</li>
<li>被唤醒的线程继续尝试获取锁，如果成功，则从队列中移除原队头，老二称为新的队头。</li>
</ol>
<p><strong>CLR 队列节点大致结构</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 等待状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 通知下一个线程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 已取消 已放弃</span></span><br><span class="line">    <span class="type">int</span> waitStatus; </span><br><span class="line"></span><br><span class="line">    Node prev; <span class="comment">// 前驱节点</span></span><br><span class="line">    Node next; <span class="comment">// 后继节点</span></span><br><span class="line">    Thread thread; <span class="comment">// 当前线程引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/721070-20170504110246211-10684485-1735391533653-31-1735395150328-37.png" alt="img"></p>
<h5 id="acquire-int"><a href="#acquire-int" class="headerlink" title="acquire(int)"></a><code>acquire(int)</code></h5><p>获取操作：<code>acquire(int arg)</code>：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/721070-20151102145743461-623794326-1735395145015-35-1735395190296-39.png" alt="img"></p>
<p>如图所示，队头是当前共享资源占用者，AQS保证严格按照入队顺序唤醒，老二被<code>unpark</code>之后尝试获取，如果成功自己就是队头，之前的队头将来会自动回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 acquire() 方法中，当 if 语句的条件返回 true 后，就会调用 selfInterrupt() ，该方法会中断当前线程，为什么需要中断当前线程呢？当 if 判断为 true 时，需要 tryAcquire() 返回 false ，并且 acquireQueued() 返回 true 。其中 acquireQueued() 方法返回的是线程被唤醒之后的 中断状态 ，通过执行 Thread.interrupted() 来返回。该方法在返回中断状态的同时，会清除线程的中断状态。因此如果 if 判断为 true ，表明线程的中断状态为 true ，但是调用 Thread.interrupted() 之后，线程的中断状态被清除为 false ，因此需要重新执行 selfInterrupt() 来重新设置线程的中断状态。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aqs-acquire-exclusive-1735447666698-3-1735447685230-5-1735447698634-7.png" alt="Exclusive Acquire"></p>
<p><strong>尝试获取</strong>：<code>tryAcquire(int arg)</code> : 应该由具体的实现类去实现(对status的CAS操作)</p>
<ul>
<li><p>以ReentrantLock为例：</p>
<ul>
<li><p>非公平锁(NotFairSync)：<code>tryAcquire()</code> 无需考虑队列中是否有前驱节点，前面有人也可以试着抢一下。失败后再排队。</p>
</li>
<li><p>公平锁(FairSync)：<code>tryAcquire()</code> 只有 !hasQueuedPredecessors() 才能尝试acquire</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static final class NonfairSync extends Sync:</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getState() == <span class="number">0</span> &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// static final class FairSync extends Sync:</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (getState() == <span class="number">0</span> &amp;&amp; !hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">       compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">       setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>**线程入队: **<code>addWaiter(Node)</code> <code>enq(Node)</code></p>
<p>应该用CAS更新，有快速和自旋两个阶段，快速插入是队列已经初始化了，尝试一次CAS更改</p>
<p>如果快速插入的CAS不成功，就进行自旋CAS插入<code>enq()</code> 同时，如果未初始化会先初始化队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、将当前线程封装为 Node 节点。</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">// 2、如果 pred ！= null，则证明 tail 节点已经被初始化，直接将 Node 节点加入队列即可。 CAS</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 2.1、通过 CAS 控制并发安全。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、初始化队列，并将新创建的 Node 节点加入队列。</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 1、通过 CAS 操作保证队列初始化的并发安全</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2、与 addWaiter() 方法中节点入队的操作相同</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程睡眠</strong>：<code>acquireQueued(Node, int arg)</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AQS：令队列中的节点尝试获取锁，并且对线程进行阻塞。</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//标记是否成功拿到资源</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 1、如果已经是老二，就可以再去尝试获取一下。</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2、判断线程是否可以阻塞，如果可以，则阻塞当前线程。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 3、如果获取锁失败，就会取消获取锁，将节点状态更新为 CANCELLED。</span></span><br><span class="line">        <span class="keyword">if</span> (failed)<span class="comment">// 等待过程中没有成功获取资源（超时/中断）</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS：判断当前线程节点是否可以阻塞。</span></span><br><span class="line"><span class="comment">// 前面可能有已经放弃的节点，应该挪到最后一个正常等待的节点后边；</span></span><br><span class="line"><span class="comment">// 并且只有前面节点状态为 `SIGNAL` 才能睡，不是的话就应该改成`SIGNAL`再睡</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="comment">// 1、前继节点状态正常，直接返回 true 即可。</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 2、ws &gt; 0 表示前继节点的状态异常，即为 CANCELLED 状态，需要跳过异常状态的节点。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3、如果前继节点的状态不是 SIGNAL，也不是 CANCELLED，就将状态设置为 SIGNAL。</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS 如果确实可以睡，就睡在`parkAndCheckInterrupt()`里等待唤醒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1、线程阻塞到这里 等待unpark()或interrupt()唤醒自己；</span></span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 2、线程被唤醒之后，返回线程中断状态</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="release-int"><a href="#release-int" class="headerlink" title="release(int)"></a><code>release(int)</code></h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aqs-release.png" alt="Release"></p>
<p>线程唤醒：<code>unparkSuccessor()</code> 唤醒队头之后第一个未放弃正常等待的节点，从后往前找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;<span class="comment">//找到头结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);<span class="comment">//唤醒等待队列里的下一个线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//底层基于 LockSupport.unpark(thread);</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//这里，node一般为当前线程所在的结点。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)<span class="comment">//置零当前线程所在的结点状态，允许失败。</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;<span class="comment">//找到下一个需要唤醒的结点s</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">//如果为空或已取消</span></span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev) </span><br><span class="line">     <span class="comment">// 从后向前遍历,找到头节点后面第一个正常等待的节点</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)<span class="comment">//从这里可以看出，&lt;=0的结点，都是还有效的结点。</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);<span class="comment">//唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aqs-addWaiter.png" alt="img"></p>
<p>为什么prev链是强一致的？因为addWaiter()里每次compareAndSetTail(pred, node)之前都有node.prev = pred，enq()会反复尝试CAStail，直到成功。一旦CAStail成功，该node.prev就成功挂在之前的tail结点上而且是唯一的，这时其他新结点的prev只能尝试往新tail结点上挂。这里的组合用法非常巧妙，能保证CAS之前的prev链强一致，但不能保证CAS后的next链强一致。</p>
<p><code>acquireShared(int arg)</code>  </p>
<p>前面逻辑基本一致，先try 如果失败了，就准备入队，</p>
<p><code>setHeadAndPropagate(Node node, int propagate)</code> </p>
<p>如果自己成了老二并且尝试获取成功，如果资源还有剩余，就会唤醒下一个正常等待的节点：</p>
<p>这些都是失败了就会寻找安全点，进入睡眠</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    setHead(node);<span class="comment">//head指向自己</span></span><br><span class="line">     <span class="comment">//如果还有剩余量，继续唤醒下一个邻居线程</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>releaseShared(int arg)</code> </p>
<p>独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                unparkSuccessor(h);<span class="comment">//唤醒后继</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)<span class="comment">// head发生变化</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="AQS-的常见应用"><a href="#AQS-的常见应用" class="headerlink" title="AQS 的常见应用"></a>AQS 的常见应用</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-thread-x-juc-overview-lock.png" alt="image"></p>
<p>AQS 本身不是直接用来加锁的，而是作为<strong>其他锁工具的基础</strong>。</p>
<ul>
<li><strong>ReentrantLock（可重入锁）：</strong> 用于线程互斥。<ul>
<li> <code>state</code> 表示重入次数，每lock一次就+1，unlock一次就-1，因此获取和释放要一一对应，否则就会死锁，tryAcquire(1)</li>
</ul>
</li>
<li><strong>Semaphore（信号量）：</strong> 控制并发访问的线程数。tryAcquire(n)</li>
<li><strong>CountDownLatch（计数器）：</strong> 等待多个线程完成任务。tryAcquire(n)<ul>
<li> <code>state = N</code>，N 个子线程执行任务，每个子线程执行完后<code>countDown()</code> 一次，也就是 CAS 减 1，<code>state</code> 归零之后，会<code>unpark(callerThread)</code> 主调用线程，主线程从<code>await</code> 返回，继续后面的动作。</li>
</ul>
</li>
<li><strong>ReadWriteLock（读写锁）：</strong> 支持多个读线程和一个写线程。</li>
</ul>
<h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><code>Semaphore</code></h4><p>Semaphore 是 synchronized 的加强版，作用是控制线程的并发数量（允许 自定义多少线程同时访问）。就这一点而言，单纯的synchronized 关键字是实现不了的。</p>
<p>Semaphore有一个构造函数， 可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待， 等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中 传入的int型整数n=1，相当于变成了一个synchronized了。</p>
<p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，而<code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。</p>
<p>Semaphore 的使用简单，我们这里假设有 N(N&gt;5) 个线程来获取 <code>Semaphore</code> 中的共享资源，下面的代码表示同一时刻 N 个线程中只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。</p>
<p>当初始的资源个数为 1 的时候，<code>Semaphore</code> 退化为独占锁。</p>
<p><code>Semaphore</code> 有两种模式：公平和非公平 </p>
<p><code>Semaphore</code> 是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为 <code>permits</code>，你可以将 <code>permits</code> 的值理解为许可证的数量，只有拿到许可证的线程才能执行。</p>
<p>调用<code>semaphore.acquire()</code> ，线程尝试获取许可证，如果 <code>state &gt;= 0</code> 的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state-1</code>。如果 <code>state&lt;0</code> 的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。</p>
<p>调用<code>semaphore.release();</code> ，线程尝试释放许可证，并使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state+1</code>。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 <code>state</code> 的值 <code>state=state-1</code> ，如果 <code>state&gt;=0</code> 则获取令牌成功，否则重新进入阻塞队列，挂起线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始共享资源数量</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取1个许可</span></span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">// 释放1个许可</span></span><br><span class="line">semaphore.release();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreExample</span> &#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">300</span>);</span><br><span class="line">    <span class="comment">// 初始许可证数量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">      threadPool.execute(() -&gt; &#123;<span class="comment">// Lambda 表达式的运用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          semaphore.acquire();<span class="comment">// 获取一个许可，所以可运行线程数量为20/1=20</span></span><br><span class="line">          test(threadnum);</span><br><span class="line">          semaphore.release();<span class="comment">// 释放一个许可</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><code>CountDownLatch</code></h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>releaseShared()</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。</p>
<p>当主线程调用 <code>await()</code> 方法的时候，实际是<code>tryAcquireShared(1)和acquire(1)</code>: 如果 <strong>state 不为 0</strong>，表示计数器未归零，线程会被<strong>封装成 Node 并加入 AQS 的等待队列</strong>中，并进入 <strong>阻塞状态</strong>。<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。直到 <code>count</code> 个线程调用了<code>countDown()</code>使 state 值被减为 0，或者调用<code>await()</code>的线程被中断，该线程才会从阻塞中被唤醒，<code>await()</code> 方法之后的语句得到执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted() ||</span><br><span class="line">        (tryAcquireShared(arg) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         acquire(<span class="literal">null</span>, arg, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">0L</span>) &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 减-1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        signalNext(head);<span class="comment">// SIGNAL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">signalNext</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; (s = h.next) != <span class="literal">null</span> &amp;&amp; s.status != <span class="number">0</span>) &#123;</span><br><span class="line">        s.getAndUnsetStatus(WAITING);</span><br><span class="line">        LockSupport.unpark(s.waiter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample1</span> &#123;</span><br><span class="line">    <span class="comment">// 处理文件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//处理文件的业务操作</span></span><br><span class="line">                    <span class="comment">//......</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//表示一个文件已经被完成</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="用法及注意事项"><a href="#用法及注意事项" class="headerlink" title="用法及注意事项"></a>用法及注意事项</h5><ol>
<li>某一线程在开始运行前等待 n 个线程执行完毕 : 将 <code>CountDownLatch</code> 的计数器初始化为 n （<code>new CountDownLatch(n)</code>），每当一个任务线程执行完毕，就将计数器减 1 （<code>countdownlatch.countDown()</code>），当计数器的值变为 0 时，在 <code>CountDownLatch 上 await()</code> 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</li>
<li>实现多个线程开始执行任务的最大并行性：注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 <code>CountDownLatch</code> 对象，将其计数器初始化为 1 （<code>new CountDownLatch(1)</code>），多个线程在开始执行任务前首先 <code>coundownlatch.await()</code>，当主线程调用 <code>countDown()</code> 时，计数器变为 0，<strong>多个线程同时被唤醒</strong>。</li>
</ol>
<p>与 <code>CountDownLatch</code> 的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用 <code>CountDownLatch.await()</code> 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p>
<p>其他 N 个线程必须引用闭锁对象，因为他们需要通知 <code>CountDownLatch</code> 对象，他们已经完成了各自的任务。这种通知机制是通过 <code>CountDownLatch.countDown()</code>方法来完成的；每调用一次这个方法，在构造函数中初始化的 count 值就减 1。所以当 N 个线程都调 用了这个方法，count 的值等于 0，然后主线程就能通过 <code>await()</code>方法，恢复执行自己的任务。</p>
<p>再插一嘴：<code>CountDownLatch</code> 的 <code>await()</code> 方法使用不当很容易产生死锁，比如我们上面代码中的 for 循环改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount-<span class="number">1</span>; i++) &#123;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就导致 <code>count</code> 的值没办法等于 0，然后就会导致一直等待。</p>
<h5 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a><code>CyclicBarrier</code></h5><p>一个加强版的CountDownLatch。</p>
<p>作用就是会让所有线程都等待完成后才会继续下一步行 动。 CyclicBarrier初始化时规定一个数目，然后计算调用了CyclicBarrier.await()进入等待的线程数。 当线程数达到了这个数目时，所有进入等待状态的线程被唤醒并继续</p>
<p>CyclicBarrier初始时还可带一个Runnable的参数， 此Runnable任务在CyclicBarrier的数目达到 后，所有其它线程被唤醒前被执行。</p>
<h3 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a><code>ConditionObject</code></h3><p>Usage</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!conditionMet()) &#123;</span><br><span class="line">        condition.await(); <span class="comment">// 等待条件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行条件满足后的逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其他线程中：</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    updateCondition();</span><br><span class="line">    condition.signal(); <span class="comment">// 通知等待的线程</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Condition-的等待队列"><a href="#Condition-的等待队列" class="headerlink" title="Condition 的等待队列"></a>Condition 的等待队列</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Monitor.png" alt="Monitor"></p>
<p><code>ConditionObject</code> 维护一个<strong>等待队列</strong>（<mark>单向链表<mark>），其中每个节点是一个AQS CLH 队列的 <code>Node</code> ，节点的 <code>waitStatus</code> 被设置为 <code>COND</code>，表示属于Condition的等待队列节点。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/979960-20180430090729190-1934051559.png" alt="img"></p>
<p><code>ConditionNode</code> 关键字段：</p>
<ul>
<li><code>waitStatus</code>：<code>COND</code> </li>
<li><code>nextWaiter</code>：指向下一个等待节点。</li>
</ul>
<p><code>ConditionObject</code> 拥有等待队列的 <strong>头尾指针</strong>：</p>
<ul>
<li><code>firstWaiter</code>：指向队列头部（第一个等待线程）。</li>
<li><code>lastWaiter</code>：指向队列尾部（最后一个等待线程）。</li>
</ul>
<p>挂起自己的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isReleasable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> status &lt;= <span class="number">1</span> || Thread.currentThread().isInterrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">block</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!isReleasable()) LockSupport.park();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>线程调用 <code>await()</code> 进入等待队列，同时释放锁(AQS的独占锁实现，比如ReentrantLock)。<ol>
<li>调用 <code>addConditionWaiter()</code> 将线程加入条件队列。</li>
<li>调用 <code>fullyRelease()</code> 释放当前线程持有的锁。</li>
<li>判断线程是否进入同步队列，如果没有，则阻塞线程。</li>
<li>被唤醒后，通过 <code>reacquireQueued()</code> 重新获取锁。</li>
</ol>
</li>
<li>线程被阻塞，直到被其他线程唤醒（<code>signal()</code> 或 <code>signalAll()</code>）。<ol>
<li>检查调用线程是否持有锁。</li>
<li>调用 <code>doSignal()</code> 将条件队列中的节点移动到同步队列。</li>
<li>调用 <code>LockSupport.unpark()</code> 唤醒节点线程。</li>
</ol>
</li>
<li>被唤醒后，该线程进入 <strong>AQS 的 CLH 队列</strong> 排队尝试重新获取锁。</li>
</ol>
<h4 id="await"><a href="#await" class="headerlink" title="await()"></a><code>await()</code></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/979960-20180430095049880-331436771.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把当前线程的节点加入到等待队列中　</span></span><br><span class="line"><span class="comment">//调用await()的线程已经获取锁，所以在加入等待队列后，需要释放锁，并且唤醒后继节点线程</span></span><br><span class="line"><span class="comment">//挂起当前线程，当别的线程调用了signal（），并且是当前线程被唤醒的时候才从返回</span></span><br><span class="line"><span class="comment">//当被唤醒后，该线程会尝试去获取锁，只有获取到了才会从await()返回，否则挂起自己</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 创建节点并加入等待队列</span></span><br><span class="line">    <span class="type">ConditionNode</span> <span class="variable">node</span> <span class="operator">=</span> newConditionNode();</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> enableWait(node);<span class="comment">// 加入等待队列，唤醒同步队列的后继节点</span></span><br><span class="line">    LockSupport.setCurrentBlocker(<span class="built_in">this</span>); <span class="comment">// for back-compatibility</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>, cancelled = <span class="literal">false</span>, rejected = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/********************* 无法进入同步队列，循环 ******************************/</span></span><br><span class="line">    <span class="keyword">while</span> (!canReacquire(node)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interrupted |= Thread.interrupted()) &#123; <span class="comment">// 被中断 取消</span></span><br><span class="line">            <span class="keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((node.status &amp; COND) != <span class="number">0</span>) &#123;<span class="comment">// 未被中断 状态是COND 挂起自己</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rejected)</span><br><span class="line">                    node.block();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ForkJoinPool.managedBlock(node);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">                rejected = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">//其他情况，自选等待</span></span><br><span class="line">            Thread.onSpinWait();    <span class="comment">// awoke while enqueuing</span></span><br><span class="line">    &#125;</span><br><span class="line">    LockSupport.setCurrentBlocker(<span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/******** 从上方的循环中跳出，清除 status，准备ReAcquire，进入同步队列  ********/</span></span><br><span class="line">    node.clearStatus();</span><br><span class="line">    acquire(node, savedState, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cancelled) &#123;</span><br><span class="line">            unlinkCancelledWaiters(node);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="enableWait-node"><a href="#enableWait-node" class="headerlink" title="enableWait(node)"></a><code>enableWait(node)</code></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">enableWait</span><span class="params">(ConditionNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// 先检查是否拥有独占锁 </span></span><br><span class="line">    <span class="keyword">if</span> (isHeldExclusively()) &#123;</span><br><span class="line">        </span><br><span class="line">        node.waiter = Thread.currentThread();</span><br><span class="line">        node.setStatusRelaxed(COND | WAITING);</span><br><span class="line">        <span class="comment">// 尾插法插入条件变量的等待队列中</span></span><br><span class="line">        <span class="type">ConditionNode</span> <span class="variable">last</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">            firstWaiter = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last.nextWaiter = node;</span><br><span class="line">        lastWaiter = node;</span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 释放锁并唤醒同步队列中的下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState))</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有独占锁就需要将节点状态改变为 CANCELLED</span></span><br><span class="line">    node.status = CANCELLED; <span class="comment">// lock not held or inconsistent</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="canReacquire-node"><a href="#canReacquire-node" class="headerlink" title="canReacquire(node)"></a><code>canReacquire(node)</code></h5><p>如果一个在等待队列中的节点现在能够参与同步队列的 ReAcquire，返回 true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Returns true if a node that was initially placed on a condition</span></span><br><span class="line"><span class="comment">         * queue is now ready to reacquire on sync queue.*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canReacquire</span><span class="params">(ConditionNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// check links, not status to avoid enqueue race</span></span><br><span class="line">    Node p; <span class="comment">// traverse unless known to be bidirectionally linked</span></span><br><span class="line">    <span class="comment">// 必须要有前驱节点才能</span></span><br><span class="line">    <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; (p = node.prev) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (p.next == node || isEnqueued(node));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Returns true if node is found in traversal from tail */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isEnqueued</span><span class="params">(Node node)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="unlinkCancelledWaiters-node"><a href="#unlinkCancelledWaiters-node" class="headerlink" title="unlinkCancelledWaiters(node)"></a><code>unlinkCancelledWaiters(node)</code></h5><p><strong>机制</strong>：通过遍历队列节点检查状态标记，将已取消的节点从队列中断开引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">(ConditionNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span> || node.nextWaiter != <span class="literal">null</span> || node == lastWaiter) &#123;</span><br><span class="line">        <span class="type">ConditionNode</span> <span class="variable">w</span> <span class="operator">=</span> firstWaiter, trail = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (w != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ConditionNode</span> <span class="variable">next</span> <span class="operator">=</span> w.nextWaiter;</span><br><span class="line">            <span class="keyword">if</span> ((w.status &amp; COND) == <span class="number">0</span>) &#123;</span><br><span class="line">                w.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (trail == <span class="literal">null</span>)</span><br><span class="line">                    firstWaiter = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    trail.nextWaiter = next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                    lastWaiter = trail;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                trail = w;</span><br><span class="line">            w = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="doSignal-firstNode-all"><a href="#doSignal-firstNode-all" class="headerlink" title="doSignal(firstNode, all)"></a><code>doSignal(firstNode, all)</code></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/979960-20180430101906927-1765442903.png" alt="img"></p>
<p>signal(）方法首先会判断当前线程是不是独占的持有锁，从等待队列中取出第一个节点，并将其移动到 AQS 的同步队列中，然后唤醒等待线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(ConditionNode first, <span class="type">boolean</span> all)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ConditionNode</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">        <span class="keyword">if</span> ((firstWaiter = next) == <span class="literal">null</span>)</span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((first.getAndUnsetStatus(COND) &amp; COND) != <span class="number">0</span>) &#123;</span><br><span class="line">            enqueue(first);</span><br><span class="line">            <span class="keyword">if</span> (!all)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ConditionNode</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="signalAll"><a href="#signalAll" class="headerlink" title="signalAll()"></a><code>signalAll()</code></h5><p>与 <code>signal()</code> 类似，只是将所有等待节点依次移动到同步队列并唤醒。<code>signalAll()</code> 会唤醒所有线程，但可能导致“惊群效应”（即多个线程争夺锁），需要根据场景合理选择 <code>signal()</code> 或 <code>signalAll()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ConditionNode</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="死锁排查——JPS"><a href="#死锁排查——JPS" class="headerlink" title="死锁排查——JPS"></a>死锁排查——JPS</h3><p>jps进程状态工具 <strong>jps.exe 工具是 jdk 自带的，在 %JAVA_HOME%/bin 目录下。</strong></p>
<p>第一步：打开idea提供terminal终端命令行，使用<code>jps -l</code>查看进程<br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20230105200845649-1781815144.png" alt="DeadLock1"><br>第二步：使用<code>jstack 进程号</code>查看堆栈信息<br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20230105201438568-23123605.png" alt="DeadLock2"><br>一般情况信息在最后面<br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20230105201125421-886160053.png" alt="DeadLock3"></p>
<h1 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a><span id="atomic">原子变量</span></h1><p>一个操作具有原子性，即该操作不可分割、不可中断。即使在多个线程同时执行时，该操作要么全部执行完成，要么不执行，不会被其他线程看到部分完成的状态。</p>
<p><code>java.util.concurrent.atomic</code> 包中的 <code>Atomic</code> 原子类提供了一种线程安全的方式来操作单个变量。<code>Atomic</code> 类依赖于 CAS（Compare-And-Swap，比较并交换）乐观锁来保证其方法的原子性，而不需要使用传统的锁机制（如 <code>synchronized</code> 块或 <code>ReentrantLock</code>）。</p>
<h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a><mark>乐观锁与悲观锁<mark></h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁总是假设最坏的情况，即一定会发生线程安全问题，因此必须串行访问临界区，<code>synchronized</code> 和 <code>ReentrantLock</code> 就是悲观锁，高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题（线程获得锁的顺序不当时），影响代码的正常运行。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。</p>
<p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败并重试，会出现类似活锁的问题，这样同样会非常影响性能，导致 CPU 飙升。</p>
<p>不过，大量失败重试的问题也是可以解决的，像我们前面提到的 <code>LongAdder</code>以空间换时间的方式就解决了这个问题。</p>
<p><strong>理论上</strong>：</p>
<ul>
<li>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li>
<li>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li>
</ul>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>一般是在数据库表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。线程 A 更新数据时读入版本号为 1，此时插入一个线程 B 抢先操作完并提交使版本号更新为 2，线程 A 要提交的时候发现版本号不对，因此重新进行更新操作。</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>CAS 是一条原子操作，依赖于 CPU 的一条指令，在 Java 中由 Unsafe 类(native本地方法类)实现，一共有三个参数：要更新的变量，变量的预期值（旧值），要赋给变量的新值；返回值为CAS是否成功。具体原理参见OSTEP Concurrency 部分，<code>do-while</code> 循环也是自旋锁的原理。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><h5 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h5><p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong> </p>
<p>解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<h5 id="自旋开销大"><a href="#自旋开销大" class="headerlink" title="自旋开销大"></a>自旋开销大</h5><p>CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p>
<h5 id="只对单个变量有效"><a href="#只对单个变量有效" class="headerlink" title="只对单个变量有效"></a>只对单个变量有效</h5><p>CAS 操作仅能对单个共享变量有效。当需要操作多个共享变量时，CAS 就显得无能为力。不过，从 JDK 1.5 开始，Java 提供了<code>AtomicReference</code>类，这使得我们能够保证引用对象之间的原子性。通过将多个变量封装在一个对象中，我们可以使用<code>AtomicReference</code>来执行 CAS 操作。</p>
<p>除了 <code>AtomicReference</code> 这种方式之外，还可以利用加锁来保证。</p>
<h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><p>基本类型：<code>AtomicInteger/Long/Boolean</code></p>
<p>数组类型：<code>AtomicXXXArray</code>  XXX = <code>Integer/Long/Reference</code></p>
<p>引用类型：<code>AtomicReference</code> <code>AtomicStampedReference</code> 引用类型解决ABA</p>
<p>基本方法就是 get getAndAdd getAndIncrement compareAndSet getAndSet</p>
<ul>
<li><code>LongAdder</code>:  消耗内存更多，适合写多读少的情况</li>
<li><code>LongAccumulator</code>: generalized version of LongAdder, use <code>LongBinaryOperator</code> as operations</li>
</ul>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a><span id="executor">线程池</span></h1><h2 id="Future-lt-V-gt"><a href="#Future-lt-V-gt" class="headerlink" title="Future&lt;V&gt;"></a><code>Future&lt;V&gt;</code></h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241230173414548.png" alt="image-20241230173414548"></p>
<p><code>Future</code> 提供了一种轮询/阻塞的方式来获取异步任务的结果，但它不直接支持通知机制，而是需要主动检查任务是否完成。提供方法检查任务是否完成、等待任务完成和获取结果。</p>
<p>是 <code>submit()</code>  的返回值，   isDone() 检查是否完成，get() 阻塞等待返回结果</p>
<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a><code>Callable</code></h3><p>Callable 接口类似于 Runnable，从名字就可以看出来了，会返回结果，并且可以抛出返回结果的异常，使用 <strong>call()</strong> 方法代替 <strong>run()</strong> 方法，适合需要结果的任务。可以直接提交到线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureCallableExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        Callable&lt;Integer&gt; task = () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时任务</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务是否完成: &quot;</span> + future.isDone());</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 阻塞等待结果</span></span><br><span class="line">            System.out.println(<span class="string">&quot;任务结果: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="FutureTask-lt-V-gt"><a href="#FutureTask-lt-V-gt" class="headerlink" title="FutureTask&lt;V&gt;"></a><code>FutureTask&lt;V&gt;</code></h3><p>FutureTask 表示一个异步运算的任务，实现了 Runnable 和 Future 接口（RunnableFuture）</p>
<p>FutureTask 通过传入 Callable 的实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然也可以传入 Runnable 的实现类，但是 Runnable 没有返回值，因此需要额外传入一个指定的返回值。V 表示返回值的类型</p>
<p>只有当任务完成的时候结果才能取回，如果<mark>任务尚未完成 <code>get()</code> 方法将会阻塞<mark>。</p>
<p>FutureTask 可以 submit 到线程池，还可以可以直接作为 Thread 构造器的参数(Runnable)创建新线程（实践中不建议直接创建新线程）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Callable&lt;String&gt; callable = () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;任务完成!&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行其他任务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程正在执行其他任务...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get(); <span class="comment">// 阻塞等待</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行结果: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a><code>ExecutorService</code></h2><p>继承了 ExecutorService 并进行一定程度扩展</p>
<p><code>shutdown()</code> 关闭            <code>submit()</code> 提交任务</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-concurrent-executors.png" alt="Executors"></p>
<h3 id="execute-Runnable-command-Runnable-ONLY"><a href="#execute-Runnable-command-Runnable-ONLY" class="headerlink" title="execute(Runnable command) (Runnable ONLY)"></a><code>execute(Runnable command)</code> (<strong>Runnable ONLY</strong>)</h3><p>ThreadPoolExecutor 实现的方法，定义在 <strong><code>Executor</code></strong> 接口中。</p>
<p>只支持提交 <strong><code>Runnable</code></strong> 类型的任务。无返回值，无法获取任务执行结果。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/thread-pool-principle.png" alt="图解线程池实现原理"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********源码************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment"> * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment"> * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment"> * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment"> * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment"> * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment"> * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment"> * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment"> * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment"> * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment"> * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment"> * and so reject the task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 1. 当前线程数 &lt; corePoolSize，创建核心线程</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 如果corePoolSize已满，将任务放入阻塞队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command); <span class="comment">// 检查是否需要拒绝</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 任务队列已满，尝试扩展到 maximumPoolSize</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command); <span class="comment">// 执行拒绝策略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用例</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务1执行: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;);</span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>

<h4 id="submit-supports-Callable-Runnable"><a href="#submit-supports-Callable-Runnable" class="headerlink" title="submit() (supports Callable, Runnable)"></a><code>submit()</code> (supports Callable, Runnable)</h4><p>可以提交 Callable 和 Runnable 任务，返回的是 Future 对象</p>
<ol>
<li>**<code>Runnable</code>**：不返回结果的任务。</li>
<li>**<code>Callable&lt;T&gt;</code>**：<mark>可以返回结果或抛出异常的任务<mark>。</li>
<li>**<code>T result</code>**：指定任务完成后返回的结果。可以给Runnable人工指定返回值，不指定也行</li>
</ol>
<ul>
<li>返回 <strong><code>Future</code></strong> 对象，用于获取任务执行的结果或状态，并且可以方便异常处理。</li>
</ul>
<p>定义在 <strong><code>ExecutorService</code></strong> 接口中，由<code>AbstractExecutorService</code>实现。支持 <strong><code>Runnable</code></strong> 和 <strong><code>Callable</code></strong> 两种任务类型。返回一个 <strong><code>Future&lt;T&gt;</code></strong> 对象，可以获取任务结果或判断任务状态。</p>
<p>主要的任务就是将 Runnable 或者 Callable 封装成 <strong>FutureTask</strong>，FutureTask 实现了 RunnableFuture（实现了 Runnable）可以直接作为 execute(Runnable command) 的参数，查看返回值本身跟线程池没关系，是 Future 的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br><span class="line">Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务2执行: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务结果: &quot;</span> + future.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>

<h3 id="Executors-工具类提供的默认线程池"><a href="#Executors-工具类提供的默认线程池" class="headerlink" title="Executors 工具类提供的默认线程池"></a>Executors 工具类提供的默认线程池</h3><table>
<thead>
<tr>
<th>线程池类型</th>
<th>核心线程数</th>
<th>最大线程数</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>FixedThreadPool</strong></td>
<td>固定数量</td>
<td>固定数量</td>
<td>固定线程数，适合长期稳定的任务执行。积压任务排队等待</td>
</tr>
<tr>
<td><strong>CachedThreadPool</strong></td>
<td>0</td>
<td>无限制</td>
<td>动态扩展线程，适合短期大量任务。60s 回收空闲位置</td>
</tr>
<tr>
<td><strong>SingleThreadExecutor</strong></td>
<td>1</td>
<td>1</td>
<td>单线程执行任务，保证顺序。</td>
</tr>
<tr>
<td><strong>ScheduledThreadPool</strong></td>
<td>固定数量</td>
<td>无限制</td>
<td>支持延迟和周期性任务调度。</td>
</tr>
<tr>
<td><strong>WorkStealingPool</strong></td>
<td>CPU 核心数</td>
<td>CPU 核心数</td>
<td>支持并行任务执行和任务窃取算法。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 固定大小线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 可缓存线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">// 单线程线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">// 定时任务线程池</span></span><br><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 定时任务</span></span><br><span class="line">pool.schedule(() -&gt; System.out.println(<span class="string">&quot;delay&quot;</span>), <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 周期任务</span></span><br><span class="line">pool.scheduleAtFixedRate(() -&gt; System.out.println(<span class="string">&quot;周期&quot;</span>), </span><br><span class="line">                         <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><h4 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h4><ul>
<li>**<code>execute()</code>**：只关注任务执行，不关注结果或异常处理。适合无需返回值的任务，只支持Runnable。</li>
<li>**<code>submit()</code>**：既关注任务执行，也关注结果和异常处理，适合需要返回结果的任务，除了Runnable 也支持 Callable，返回 Future，对其调用get()会阻塞当前任务。</li>
</ul>
<p><strong>最佳实践：</strong> 优先使用 **<code>submit()</code>**，即使不需结果，也可以捕获潜在异常，避免线程池异常崩溃。</p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ul>
<li><strong>使用<code>execute()</code>提交任务</strong>：当任务通过<code>execute()</code>提交到线程池并在执行过程中抛出异常时，如果这个异常没有在任务内被捕获，那么该异常会导致当前线程终止，并且异常会被打印到控制台或日志文件中。线程池会检测到这种线程终止，并创建一个新线程来替换它，从而保持配置的线程数不变。</li>
<li><strong>使用<code>submit()</code>提交任务</strong>：对于通过<code>submit()</code>提交的任务，如果在任务执行中发生异常，这个异常不会直接打印出来。相反，异常会被封装在由<code>submit()</code>返回的<code>Future</code>对象中。当调用<code>Future.get()</code>方法时，可以捕获到一个<code>ExecutionException</code>。在这种情况下，线程不会因为异常而终止，它会继续存在于线程池中，准备执行后续的任务。</li>
</ul>
<p>简单来说：使用<code>execute()</code>时，未捕获异常导致线程终止，线程池创建新线程替代；使用<code>submit()</code>时，异常被封装在<code>Future</code>中，线程继续复用。</p>
<p>这种设计允许<code>submit()</code>提供更灵活的错误处理机制，因为它允许调用者决定如何处理异常，而<code>execute()</code>则适用于那些不需要关注执行结果的场景。</p>
<h4 id="使用自定义线程池-ThreadPoolExecutor"><a href="#使用自定义线程池-ThreadPoolExecutor" class="headerlink" title="使用自定义线程池 ThreadPoolExecutor"></a><mark>使用自定义线程池 <code>ThreadPoolExecutor</code><mark></h4><p>**避免使用 <code>Executors</code> 创建线程池：推荐直接使用<code>ThreadPoolExecutor</code> 自定义线程池：因为 **<code>Executors</code> 默认队列为 <strong>无限队列</strong>，可能导致内存溢出。除了避免 OOM 的原因之外，不推荐使用 <code>Executors</code>提供快捷的线程池的原因：</p>
<ul>
<li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。<ul>
<li>CPU 密集型任务的 <code>WT/ST</code> 接近或者等于 0，因此， 线程数可以设置为 N（CPU 核心数）∗（1+0）= N，和我们上面说的 N（CPU 核心数）+1 差不多。</li>
<li>IO 密集型任务下，几乎全是线程等待时间，从理论上来说，你就可以将线程数设置为 2N（按道理来说，WT/ST 的结果应该比较大，这里选择 2N 的原因应该是为了避免创建过多线程吧）。</li>
</ul>
</li>
</ul>
<h5 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h5><p>建议实践中手动指定线程池配置，ThreadPoolExecutor的构造器共有七个参数：</p>
<ol>
<li><p><code>int corePoolSize</code>: 核心线程数     </p>
</li>
<li><p><code>int maxPoolSize</code>: 最大线程数</p>
</li>
<li><p><code>long keepAliveTime</code>: 非核心线程闲置的最长时间，超时销毁</p>
</li>
<li><p><code>TimeUnit unit</code>: 时间单位，枚举</p>
</li>
<li><p><code>BlockingQueue&lt;Runnable&gt; workQueue</code>: 保存任务的阻塞队列</p>
<ul>
<li><p>如果运行的线程数少于 corePoolSize，则执行器始终倾向于添加新线程而不是排队。</p>
</li>
<li><p>如果 corePoolSize 或更多线程正在运行，对请求进行排队而不是添加新线程。</p>
</li>
<li><p>如果请求无法排队，则会创建一个新线程，如果超出了 MaximumPoolSize，拒绝策略</p>
</li>
</ul>
</li>
</ol>
<ul>
<li><code>SynchronousQueue</code>不会保存任务，直接递交给线程，没有就创建，需要maxPoolSize很大，<code>CachedThreadPool</code> 就属于这种，创建无限个线程也会OOM。</li>
<li><code>LinkedBlockingQueue</code>为无界队列，默认最大容量为 <strong>Integer.MAX_VALUE</strong>，可能会导致任务积压 OOM，比如 Fixed 和 Single<ul>
<li>当所有 <code>corePoolSize</code> 线程都忙时，使用无界队列（例如没有预定义容量的 LinkedBlockingQueue）将导致新任务在队列中等待。</li>
<li>线程最多只有corePoolSize，maxSize没有影响。</li>
<li>当每个任务完全独立于其他任务时，这可能是合适的，因此任务不会影响彼此的执行；例如，在网页服务器中。虽然这种排队方式对于平滑请求的瞬态突发很有用，但它当命令平均到达速度继续快于处理速度时，可能发生OOM</li>
</ul>
</li>
<li><code>ArrayBlockingQueue</code>为有界队列，防止OOM：<ul>
<li>使用大队列和小池可以最大限度地减少 CPU 使用率、操作系统资源和上下文切换开销，但可能会导致人为降低吞吐量。</li>
<li>使用小队列通常需要更大的池，提高了 CPU 的利用率，但遇到不可接受的调度开销时也会降低吞吐量。</li>
</ul>
</li>
</ul>
<p><strong><u>Optional</u> Parameters</strong>：</p>
<ol start="5">
<li><code>ThreadFactory threadFactory</code>: 线程工厂，创建新线程，支持自定义线程名称等属性。</li>
</ol>
<ul>
<li>默认为 <code>Executors.defaultThreadFactory()</code> </li>
</ul>
<ol start="6">
<li><code>RejectedExecutionHandler handler</code>: 线程池满负荷(队列满且maxPoolSize)的拒绝策略</li>
</ol>
<ul>
<li><code>AbortPolicy</code>(default): 抛出<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/RejectedExecutionException.html"><code>RejectedExecutionException</code></a> 异常</li>
<li><code>CallerRunsPolicy</code>: 由提交任务的线程直接执行任务，防止任务丢失。这提供了一个简单的反馈控制机制，将减慢新任务提交的速度。</li>
<li><code>DiscardOldestPolicy</code>: 丢弃最旧未执行的任务，工作队列头部的任务将被删除，然后重试执行（可能会再次失败，导致重复执行）。这种策略很少被接受</li>
<li><code>DiscardPolicy</code>: 直接丢弃，不抛出任何异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">// 队列长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>线程池可以使用getter setter等方法进行参数的访问与更改</p>
</li>
<li><p>使用 Spring 内部线程池 ThreadPoolTaskExecutor 时，一定要手动自定义，合理配置参数，不然会出现生产问题（一个请求创建一个线程）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(name=&quot;threadPoolExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">threadPoolExecutor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">// 返回可用处理器的Java虚拟机的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">processNum</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors(); </span><br><span class="line">        <span class="type">int</span> <span class="variable">corePoolSize</span> <span class="operator">=</span> (<span class="type">int</span>) (processNum / (<span class="number">1</span> - <span class="number">0.2</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxPoolSize</span> <span class="operator">=</span> (<span class="type">int</span>) (processNum / (<span class="number">1</span> - <span class="number">0.5</span>));</span><br><span class="line">        threadPoolExecutor.setCorePoolSize(corePoolSize); <span class="comment">// 核心池大小</span></span><br><span class="line">        threadPoolExecutor.setMaxPoolSize(maxPoolSize); <span class="comment">// 最大线程数</span></span><br><span class="line">        threadPoolExecutor.setQueueCapacity(maxPoolSize * <span class="number">1000</span>); <span class="comment">// 队长</span></span><br><span class="line">        threadPoolExecutor.setThreadPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        threadPoolExecutor.setDaemon(<span class="literal">false</span>);</span><br><span class="line">        threadPoolExecutor.setKeepAliveSeconds(<span class="number">300</span>);<span class="comment">// 线程空闲时间</span></span><br><span class="line">        <span class="comment">// 线程名字前缀</span></span><br><span class="line">        threadPoolExecutor.setThreadNamePrefix(<span class="string">&quot;test-Executor-&quot;</span>); </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> threadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h5><ul>
<li><p>给线程池(实际上是ThreadFactory)命名，有助于定位问题。一般可以使用 Guava：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                        .setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>)</span><br><span class="line">                        .setDaemon(<span class="literal">true</span>).build();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize,</span><br><span class="line">  maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue,</span><br><span class="line"> threadFactory);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="适度复用"><a href="#适度复用" class="headerlink" title="适度复用"></a><strong>适度</strong>复用</h4><ul>
<li><p>要<mark>适当复用<mark>线程池，不要一个请求创建一个线程池，浪费资源且效率极低。</p>
</li>
<li><p>根据当前业务的情况对线程池进行配置，<mark>不同业务不要复用线程池<mark>：父任务占满线程池，导致子任务阻塞，但是父任务也同时被子任务阻塞，造成互相等待的死锁局面。</p>
</li>
</ul>
<h4 id="正确关闭"><a href="#正确关闭" class="headerlink" title="正确关闭"></a>正确关闭</h4><p>释放资源，shutdown(Now)不过只是异步通知，不会同步阻塞等待。</p>
<ul>
<li><strong><code>void shutdown()</code></strong> 有序关闭，执行完先前提交的任务。</li>
<li><strong><code>List&lt;Runnable&gt; shutdownNow()</code></strong> 停止所有正在执行的任务，停止正在等待的任务的处理，并返回正在等待执行的任务的列表。</li>
<li><code>awaitTermination</code> 同步阻塞等待</li>
<li>实现了autoclosable，close方法可以阻塞等待，因此trywithresource</li>
</ul>
<h4 id="不要和-JDK-自带-ThreadLocal-共用"><a href="#不要和-JDK-自带-ThreadLocal-共用" class="headerlink" title="不要和 JDK 自带 ThreadLocal 共用"></a>不要和 JDK 自带 ThreadLocal 共用</h4><p>这是因为线程池会复用线程对象，与线程对象绑定的类的静态属性 <code>ThreadLocal</code> 变量也会被重用，这就导致一个线程可能获取到其他线程的<code>ThreadLocal</code> 值。</p>
<h4 id="不要放入耗时任务"><a href="#不要放入耗时任务" class="headerlink" title="不要放入耗时任务"></a>不要放入耗时任务</h4><p>线程池本身的目的是为了提高任务执行效率，避免因频繁创建和销毁线程而带来的性能开销。如果将耗时任务提交到线程池中执行，可能会导致线程池中的线程被长时间占用，无法及时响应其他任务，甚至会导致线程池崩溃或者程序假死。这些任务可以采用异步 <code>CompletableFuture</code> 完成</p>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a><code>CompletableFuture</code></h2><p><code>Future</code> 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 <code>get()</code> 方法为阻塞调用。Java 8 才被引入<code>CompletableFuture</code> 类可以解决<code>Future</code> 的这些缺陷。<code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。对某些部分可以并行执行的异步任务支持比较好。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>runAsync</code></strong></td>
<td>执行无返回值异步任务。</td>
</tr>
<tr>
<td><strong><code>supplyAsync</code></strong></td>
<td>执行有返回值异步任务。</td>
</tr>
<tr>
<td><strong><code>thenApply</code></strong></td>
<td>转换结果并返回新的结果。</td>
</tr>
<tr>
<td><strong><code>thenAccept</code></strong></td>
<td>消费结果但不返回新结果。</td>
</tr>
<tr>
<td><strong><code>thenCombine</code></strong></td>
<td>合并两个任务的结果。</td>
</tr>
<tr>
<td><strong><code>allOf</code></strong> / <strong><code>anyOf</code></strong></td>
<td>等待所有任务完成 / 任意任务完成。</td>
</tr>
<tr>
<td><strong><code>exceptionally</code></strong> / <strong><code>handle</code></strong></td>
<td>处理异常并提供默认值或继续处理结果。</td>
</tr>
</tbody></table>
<p>以下是 <strong><code>CompletableFuture</code></strong> 的使用示例及详解：</p>
<h3 id="任务创建"><a href="#任务创建" class="headerlink" title="任务创建"></a>任务创建</h3><p><strong>创建异步任务：</strong><code>runAsync()</code><strong>：执行无返回值任务。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行异步任务：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;);</span><br><span class="line">future.join(); <span class="comment">// 等待任务执行完成</span></span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>join()</code>**：等待任务执行完成（类似 **<code>get()</code>**，但不会抛出 checked 异常）。</li>
</ul>
<p><strong>执行有返回值任务：</strong><code>supplyAsync()</code><strong>：执行有返回值任务。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;计算中...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;计算结果：&quot;</span> + future.join());</span><br></pre></td></tr></table></figure>

<h3 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h3><p><code>thenApply</code> - 对任务结果进行变换（同步执行）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span>)</span><br><span class="line">        .thenApply(result -&gt; result * <span class="number">2</span>); <span class="comment">// 结果翻倍</span></span><br><span class="line">System.out.println(future.join()); <span class="comment">// 输出 20</span></span><br></pre></td></tr></table></figure>

<p><code>thenAccept</code> - 消费结果，不返回新的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">        .thenAccept(result -&gt; System.out.println(<span class="string">&quot;结果: &quot;</span> + result));</span><br></pre></td></tr></table></figure>

<p><code>thenRun</code> - 不关心前一任务结果，直接执行下一步操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;任务完成&quot;</span>)</span><br><span class="line">        .thenRun(() -&gt; System.out.println(<span class="string">&quot;继续执行任务&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="组合多个任务"><a href="#组合多个任务" class="headerlink" title="组合多个任务"></a>组合多个任务</h3><p><code>thenCombine</code> - 合并两个任务结果，组合两个任务结果，并执行新任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span>);</span><br><span class="line">CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; result = future1.thenCombine(future2, (a, b) -&gt; a + b);</span><br><span class="line">System.out.println(<span class="string">&quot;结果: &quot;</span> + result.join()); <span class="comment">// 输出 30</span></span><br></pre></td></tr></table></figure>

<p><code>allOf</code> - 等待所有任务完成，但不返回结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;任务1&quot;</span>)),</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;任务2&quot;</span>)),</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;任务3&quot;</span>))</span><br><span class="line">);</span><br><span class="line">all.join(); <span class="comment">// 等待所有任务完成</span></span><br></pre></td></tr></table></figure>

<p><code>anyOf</code> - 任意任务完成即结束，返回第一个任务的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Object&gt; any = CompletableFuture.anyOf(</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;任务1&quot;</span>),</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;任务2&quot;</span>),</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;任务3&quot;</span>)</span><br><span class="line">);</span><br><span class="line">System.out.println(<span class="string">&quot;最快完成的任务: &quot;</span> + any.join());</span><br></pre></td></tr></table></figure>

<h3 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h3><p><code>exceptionally</code> - 捕获异常并返回默认值，继续执行任务链。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;任务异常&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;捕获异常: &quot;</span> + ex.getMessage());</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 返回默认值</span></span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;结果: &quot;</span> + future.join()); <span class="comment">// 输出 -1</span></span><br></pre></td></tr></table></figure>

<p><code>handle</code>- 捕获异常并处理结果,同时处理正常结果和异常情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;计算出错&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;).handle((result, ex) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理异常: &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 返回默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;最终结果: &quot;</span> + future.join());</span><br></pre></td></tr></table></figure>

<h3 id="线程池自定义"><a href="#线程池自定义" class="headerlink" title="线程池自定义"></a>线程池自定义</h3><p>指定线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;自定义线程池: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;, executor).join();</span><br><span class="line"></span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>

<p>**异步任务默认使用 **<code>ForkJoinPool.commonPool()</code>，但可以自定义线程池以控制资源。</p>
<h3 id="例：批量任务处理"><a href="#例：批量任务处理" class="headerlink" title="例：批量任务处理"></a>例：批量任务处理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;CompletableFuture&lt;Integer&gt;&gt; futures = IntStream.range(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">        .mapToObj(i -&gt; CompletableFuture.supplyAsync(() -&gt; i * <span class="number">2</span>))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; allDone = CompletableFuture.allOf(</span><br><span class="line">        futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>])</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">allDone.join();</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; results = futures.stream()</span><br><span class="line">        .map(CompletableFuture::join)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;所有结果: &quot;</span> + results);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <strong><code>allOf()</code></strong> 确保所有任务完成。</li>
<li>收集各任务结果并返回。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">所有结果: [2, 4, 6, 8, 10]</span><br></pre></td></tr></table></figure>

<h3 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a><a href="https://javaguide.cn/java/concurrent/virtual-thread.html">虚拟线程</a></h3>]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis-Plus</title>
    <url>/2024/08/31/mp+lombok/</url>
    <content><![CDATA[<p>大家在日常开发中应该能发现，单表的CRUD功能代码重复度很高，也没有什么难度。而这部分代码量往往比较大，开发起来比较费时。</p>
<p>因此，目前企业中都会使用一些组件来简化或省略单表的CRUD开发工作。目前在国内使用较多的一个组件就是MybatisPlus.</p>
<p>当然，MybatisPlus不仅仅可以简化单表操作，而且还对Mybatis的功能有很多的增强。可以让我们的开发更加的简单，高效。</p>
<p>通过今天的学习，我们要达成下面的目标：</p>
<ul>
<li>能利用MybatisPlus实现基本的CRUD</li>
<li>会使用条件构建造器构建查询和更新语句</li>
<li>会使用MybatisPlus中的常用注解</li>
<li>会使用MybatisPlus处理枚举、JSON类型字段</li>
<li>会使用MybatisPlus实现分页</li>
</ul>
<p><a href="https://b11et3un53m.feishu.cn/wiki/PsyawI04ei2FQykqfcPcmd7Dnsc">day01-MybatisPlus - 飞书云文档</a> </p>
<span id="more"></span>

<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="创建boot模块"><a href="#创建boot模块" class="headerlink" title="创建boot模块"></a>创建boot模块</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026201253878.png" alt="image-20241026201253878"></p>
<h2 id="勾选JDBC驱动"><a href="#勾选JDBC驱动" class="headerlink" title="勾选JDBC驱动"></a>勾选JDBC驱动</h2><p>不勾mybatis</p>
<h2 id="添加mp-druid依赖"><a href="#添加mp-druid依赖" class="headerlink" title="添加mp, druid依赖"></a>添加mp, druid依赖</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026201406343.png" alt="image-20241026201406343"></p>
<h2 id="设置数据源参数"><a href="#设置数据源参数" class="headerlink" title="设置数据源参数"></a>设置数据源参数</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026201455412.png" alt="image-20241026201455412"></p>
<h2 id="继承-BaseMapper-lt-User-gt"><a href="#继承-BaseMapper-lt-User-gt" class="headerlink" title="继承 BaseMapper&lt;User&gt;"></a>继承 BaseMapper&lt;User&gt;</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026201522435.png" alt="image-20241026201522435"></p>
<h2 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026201729063.png" alt="image-20241026201729063"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026202539047.png" alt="image-20241026202539047"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026202550900.png" alt="image-20241026202550900"></p>
<h1 id="标准数据层开发—DAO-层"><a href="#标准数据层开发—DAO-层" class="headerlink" title="标准数据层开发—DAO 层"></a>标准数据层开发—DAO 层</h1><h2 id="pojo实体类注意"><a href="#pojo实体类注意" class="headerlink" title="pojo实体类注意"></a>pojo实体类注意</h2><h3 id="字段映射"><a href="#字段映射" class="headerlink" title="字段映射"></a>字段映射</h3><h4 id="类名映射表名"><a href="#类名映射表名" class="headerlink" title="类名映射表名"></a>类名映射表名</h4><p><a href="https://baomidou.com/guides/mybatis-x/#%E7%94%9F%E6%88%90%E7%9A%84%E8%A1%A8%E5%90%8D%E4%B8%8E%E9%A2%84%E6%9C%9F%E4%B8%8D%E7%AC%A6">Mybatis X 插件 | MyBatis-Plus (baomidou.com)</a></p>
<p>未指定映射表明，会将驼峰命名转化为下划线命名：</p>
<p><code>User -&gt; user</code> <code>UserModel-&gt;user_model</code></p>
<h4 id="驼峰命名字段自动映射表字段名"><a href="#驼峰命名字段自动映射表字段名" class="headerlink" title="驼峰命名字段自动映射表字段名"></a>驼峰命名字段自动映射表字段名</h4><h5 id="全局配置-驼峰映射mapUnderscoreToCamelCase"><a href="#全局配置-驼峰映射mapUnderscoreToCamelCase" class="headerlink" title="全局配置 驼峰映射mapUnderscoreToCamelCase"></a>全局配置 驼峰映射mapUnderscoreToCamelCase</h5><ul>
<li><strong>类型</strong>：<code>boolean</code></li>
<li><strong>默认值</strong>：<code>true</code></li>
</ul>
<p>开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN（下划线命名） 到经典 Java 属性名 aColumn（驼峰命名） 的类似映射。</p>
<p><code>studentNum-&gt;student_num</code> <code>student-&gt;student</code> </p>
<h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><h4 id="简化pojo-Data"><a href="#简化pojo-Data" class="headerlink" title="简化pojo @Data"></a>简化pojo <code>@Data</code></h4><p><code>@Getter @Setter @EqualsAndHashCode @ToString @RequiredArgsConstructor</code> </p>
<ul>
<li><p>一键生成上述所有<mark>@Data<mark> </p>
</li>
<li><p><code>@AllArgsConstructor</code>：生成全参构造</p>
</li>
<li><p><code>@NoArgsConstructor</code>：显式生成无参构造</p>
</li>
</ul>
<h4 id="record类-amp-不可变对象-Value"><a href="#record类-amp-不可变对象-Value" class="headerlink" title="record类 &amp; 不可变对象 @Value"></a><strong>record类</strong> &amp; 不可变对象 <code>@Value</code></h4><p>不可变对象 JDK14开始引入record类，用来表示一个不可变的实体类。所有字段都为private final，类也为final，<u>也不能继承其他类</u>，只有一个全参构造器。getName()变成name() </p>
<p>不可变对象<code>@Value</code>：所有字段都为<code>private final</code>，类也为<code>final</code>，只提供<code>@Getter</code>不提供<code>@Setter</code>，，只提供全参构造不提供无参构造。</p>
<h4 id="简单基本属性要用包装类"><a href="#简单基本属性要用包装类" class="headerlink" title="简单基本属性要用包装类"></a>简单基本属性要用包装类</h4><p>比如Long Integer Byte Double Boolean Character Float Boolean Short</p>
<h4 id="Lombok-Builder-建造者模式"><a href="#Lombok-Builder-建造者模式" class="headerlink" title="Lombok @Builder 建造者模式"></a>Lombok <code>@Builder</code> 建造者模式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用生成的构建器</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> User.builder()</span><br><span class="line">    .name(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">    .age(<span class="number">30</span>)</span><br><span class="line">    .email(<span class="string">&quot;alice@example.com&quot;</span>)</span><br><span class="line">    .build(); <span class="comment">// 最终构造 User 对象</span></span><br><span class="line">-------------------------------------</span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="meta">@Builder</span>.Default</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">status</span> <span class="operator">=</span> <span class="string">&quot;Pending&quot;</span>; <span class="comment">// 默认值</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时未设置 status 则默认为 &quot;Pending&quot;</span></span><br><span class="line"><span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> Task.builder().title(<span class="string">&quot;Fix Bug&quot;</span>).build();</span><br></pre></td></tr></table></figure>

<p>Lombok 会为类自动生成以下内容：</p>
<ul>
<li>一个静态内部类 <code>UserBuilder</code>（构建器）</li>
<li>链式方法（如 <code>.name()</code>, <code>.age()</code>）</li>
<li><code>build()</code> 方法用于最终构造对象</li>
</ul>
<p>生成的代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    rivate String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserBuilder <span class="title function_">builder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">        <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">name</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他属性的链式方法...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> User <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(name, age, email);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的 <code>build()</code> 方法会调用全参构造函数，若类中未显式定义全参构造，需配合 <code>@AllArgsConstructor</code> 使用。</p>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><h5 id="链式构造-不可变对象"><a href="#链式构造-不可变对象" class="headerlink" title="链式构造 + 不可变对象"></a>链式构造 + 不可变对象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span>  <span class="comment">// 自动生成getter、setter、equals、hashCode、toString requiredargsconstru</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span>  <span class="comment">// 无参构造（JPA要求）</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span> <span class="comment">// 全参构造（可选）</span></span><br><span class="line"><span class="meta">@Builder</span>            <span class="comment">// 支持链式构建（推荐）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 字段定义</span></span><br><span class="line">&#125;</span><br><span class="line">-------------------------</span><br><span class="line"><span class="meta">@Value</span>  <span class="comment">// 生成所有字段为final的类（等价于@Data + final字段） 不可变对象 只读类</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImmutableUser</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RequiredArgsConstructor 只关注 final 以及 nonnull 字段。</p>
<h5 id="处理继承问题"><a href="#处理继承问题" class="headerlink" title="处理继承问题"></a>处理继承问题</h5><ul>
<li><strong>避免 <code>@Data</code> 在继承场景</strong><br>父类和子类同时使用 <code>@Data</code> 可能导致 <code>equals</code>/<code>hashCode</code> 忽略父类字段，手动重写更安全。</li>
<li><strong>显式排除字段</strong><br>使用 <code>@ToString(exclude = &quot;password&quot;)</code> 或 <code>@EqualsAndHashCode(exclude = &#123;&quot;id&quot;&#125;)</code> 避免敏感字段泄露或循环引用。</li>
</ul>
<h5 id="日志框架-Slf4j"><a href="#日志框架-Slf4j" class="headerlink" title="日志框架 @Slf4j"></a>日志框架 <code>@Slf4j</code></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Order processed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SneakyThrows-偷偷抛出异常"><a href="#SneakyThrows-偷偷抛出异常" class="headerlink" title="@SneakyThrows 偷偷抛出异常"></a><code>@SneakyThrows</code> 偷偷抛出异常</h5><ol>
<li><p><strong>明确异常类型</strong><br>建议显式指定 <code>@SneakyThrows</code> 抛出的异常类型，避免隐藏潜在问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows(IOException.class)</span>  <span class="comment">// ✅ 明确异常类型</span></span><br><span class="line"><span class="comment">// @SneakyThrows                   // ❌ 不推荐（捕获 Throwable，可能隐藏其他异常）</span></span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.SneakyThrows;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUtils</span> &#123;</span><br><span class="line">    <span class="meta">@SneakyThrows</span>  <span class="comment">// 自动处理受检异常，无需声明 throws 或 try-catch</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] readFile(String path) &#123;</span><br><span class="line">        <span class="keyword">return</span> Files.readAllBytes(Paths.get(path));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processFile</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = readFile(<span class="string">&quot;data.txt&quot;</span>);  <span class="comment">// 直接调用，无异常处理代码</span></span><br><span class="line">        <span class="comment">// 处理数据...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="DQL编程控制"><a href="#DQL编程控制" class="headerlink" title="DQL编程控制"></a>DQL编程控制</h2><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><h4 id="配置分页拦截器作为Spring管理的Bean"><a href="#配置分页拦截器作为Spring管理的Bean" class="headerlink" title="配置分页拦截器作为Spring管理的Bean"></a>配置分页拦截器作为Spring管理的Bean</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026214322493.png" alt="image-20241026214322493"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MpConfig</span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">pageInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">	interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">	<span class="keyword">return</span> interceptor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="封装页面数据—IPage"><a href="#封装页面数据—IPage" class="headerlink" title="封装页面数据—IPage"></a>封装页面数据—IPage</h4><p>相当于原来的PageBean功能</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026213838191.png" alt="image-20241026213838191"></p>
<h4 id="开启日志：观察执行过程"><a href="#开启日志：观察执行过程" class="headerlink" title="开启日志：观察执行过程"></a>开启日志：观察执行过程</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026213947947.png" alt="image-20241026213947947"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026214121826.png" alt="image-20241026214121826"></p>
<h3 id="查询条件"><a href="#查询条件" class="headerlink" title="查询条件"></a>查询条件</h3><p><a href="https://baomidou.com/guides/wrapper/#_top">条件构造器 | MyBatis-Plus (baomidou.com)</a></p>
<h4 id="大小关系"><a href="#大小关系" class="headerlink" title="大小关系"></a>大小关系</h4><h5 id="等值匹配-eq"><a href="#等值匹配-eq" class="headerlink" title="等值匹配 eq"></a>等值匹配 <code>eq</code></h5><p><code>lqw.eq(User::getName,&quot;Jerry&quot;).eq(User::getPassword,&quot;jerry&quot;)</code></p>
<p><strong><code>userDao.selectOne(lqw)</code></strong> 没有必要用List</p>
<h5 id="范围匹配-le-lt-ge-gt-between"><a href="#范围匹配-le-lt-ge-gt-between" class="headerlink" title="范围匹配 le lt ge gt between"></a>范围匹配 <code>le</code> <code>lt</code> <code>ge</code> <code>gt</code> <code>between</code></h5><p><code>lqw.between(User::getAge,10,30)</code></p>
<h4 id="模糊匹配-like"><a href="#模糊匹配-like" class="headerlink" title="模糊匹配 like"></a>模糊匹配 <code>like</code></h4><p><code>lqw.like(User::getName,&quot;J&quot;)</code> -&gt; J%，默认是<code>likeRight</code> 百分号在右边</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027162540434.png" alt="image-20241027162540434"></p>
<h4 id="分组查询聚合函数select-groupBy"><a href="#分组查询聚合函数select-groupBy" class="headerlink" title="分组查询聚合函数select, groupBy"></a>分组查询聚合函数<code>select, groupBy</code></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027162651975.png" alt="image-20241027162651975"></p>
<h3 id="QueryWrapper-封装查询条件"><a href="#QueryWrapper-封装查询条件" class="headerlink" title="QueryWrapper 封装查询条件"></a><code>QueryWrapper</code> 封装查询条件</h3><p>查询多条数据，返回List&lt;User&gt; <strong><code>userDao.selectList(queryWrapper)</code></strong> </p>
<h4 id="按照条件查询-QueryWrapper"><a href="#按照条件查询-QueryWrapper" class="headerlink" title="按照条件查询(QueryWrapper)"></a>按照条件查询(<code>QueryWrapper</code>)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">QueryWrapper</span> <span class="variable">qw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>(); <span class="comment">//通过反射读取字段名称，不用加泛型</span></span><br><span class="line">qw.lt(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);<span class="comment">//age是字段名称(不能写错) lt表示小于</span></span><br><span class="line">qw.gt(age)</span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(qw);<span class="comment">//将wrapper对象传给DQL即可</span></span><br><span class="line">System.out.println(userList);</span><br></pre></td></tr></table></figure>

<h4 id="Lambda方式按照单条件查询-QueryWrapper-支持链式编程"><a href="#Lambda方式按照单条件查询-QueryWrapper-支持链式编程" class="headerlink" title="Lambda方式按照单条件查询(QueryWrapper) -支持链式编程"></a>Lambda方式按照单条件查询(<code>QueryWrapper</code>) -支持<strong>链式编程</strong></h4><p><a href="https://blog.csdn.net/ShuSheng0007/article/details/107562812">秒懂Java之方法引用（method reference）详解-CSDN博客</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;();<span class="comment">//泛型</span></span><br><span class="line">qw.lambda().lt(User::getAge, <span class="number">10</span>);<span class="comment">//写lambda()</span></span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(qw);</span><br><span class="line">System.out.println(userList);</span><br><span class="line"><span class="comment">//    new SFunction&lt;User, Object&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public Object apply(User user) &#123;</span></span><br><span class="line"><span class="comment">//               return user.getAge();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//       &#125;</span></span><br><span class="line"><span class="comment">//    user-&gt;user.getAge();</span></span><br></pre></td></tr></table></figure>

<p>QueryWrapper的<code>lambda()</code>方法返回一个LambdaQueryWrapper</p>
<p><code>qw.lambda().lt(...)</code>⇔<code>lqw.lt(...)</code>  链式编程</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026230607128-1729955629817-1.png" alt="image-20241026230607128"></p>
<h4 id="Lambda方式按多条件查询-LambdaQueryWrapper"><a href="#Lambda方式按多条件查询-LambdaQueryWrapper" class="headerlink" title="Lambda方式按多条件查询(LambdaQueryWrapper)"></a>Lambda方式按多条件查询(<code>LambdaQueryWrapper</code>)</h4><h5 id="and—直接增加条件"><a href="#and—直接增加条件" class="headerlink" title="and—直接增加条件"></a>and—直接增加条件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//age大于5小于10</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();<span class="comment">//泛型</span></span><br><span class="line">lqw.lt(User::getAge, <span class="number">10</span>).gt(User::getAge, <span class="number">5</span>);<span class="comment">//不用写lambda() 链式编程</span></span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br><span class="line">System.out.println(userList);</span><br></pre></td></tr></table></figure>

<h5 id="or—条件之间插入or"><a href="#or—条件之间插入or" class="headerlink" title="or—条件之间插入or()"></a>or—条件之间插入<code>or()</code></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//age大于10或小于5</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();<span class="comment">//泛型</span></span><br><span class="line">lqw.lt(User::getAge, <span class="number">5</span>).or().gt(User::getAge, <span class="number">10</span>);<span class="comment">//中间插入or</span></span><br><span class="line">List&lt;User&gt; userList = userDao.selectList(lqw);</span><br><span class="line">System.out.println(userList);</span><br></pre></td></tr></table></figure>

<h3 id="条件查询null判定"><a href="#条件查询null判定" class="headerlink" title="条件查询null判定"></a>条件查询null判定</h3><p>多查询条件有的时候可能部分为null，查询模型和真正的实体类数据模型不同，查询模型是交给QueryWrapper，而QueryWrapper应该仅根据这个查询模型就能解析出所有的条件，所以应该为查询模型单开一个类，继承自User，把可能会有多条件查询的属性增加一个，分别表示这个属性的上限和下限。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027154359648.png" alt="image-20241027154359648"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027154411221.png" alt="image-20241027154411221"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027154540970.png" alt="image-20241027154540970"></p>
<p>如上图所示，没有设置下限，只设置上限，本意是想去除一个查询条件，但实际上并未去除，而是传进去一个null，导致无效查询，我们要做的就是当null的时候就忽略掉这个查询条件 <code>lqw.lt(condition,column,value)</code> 在条件函数中加一个condition<code>uq.getAge()!=null</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027155803642.png" alt="image-20241027155803642"></p>
<h3 id="查询投影-lqw-select"><a href="#查询投影-lqw-select" class="headerlink" title="查询投影 (lqw.select)"></a>查询投影 <strong><code>(lqw.select)</code></strong></h3><h4 id="只查询模型中定义的部分字段"><a href="#只查询模型中定义的部分字段" class="headerlink" title="只查询模型中定义的部分字段"></a>只查询模型中定义的部分字段</h4><p><code>lqw.select(User::getId,User::getAge,User::getName)</code> </p>
<p><code>lqw.select(&quot;id&quot;,&quot;age&quot;,&quot;name&quot;)</code> </p>
<p><code>userDao.selectList(lqw)</code> </p>
<h4 id="查询模型中未定义的字段-count-lqw-selectMaps"><a href="#查询模型中未定义的字段-count-lqw-selectMaps" class="headerlink" title="查询模型中未定义的字段(count(*)) lqw.selectMaps()"></a>查询模型中未定义的字段(count(*)) <strong><code>lqw.selectMaps()</code></strong></h4><p><code>lqw.select(&quot;count(*)&quot;)</code> 查询具体字段，就像写sql一样，可以加别名<code>as xxx</code>不支持lambda形式</p>
<p><strong><code>userDao.selectMaps(lqw)</code></strong> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027160943389.png" alt="image-20241027160943389"></p>
<p>group by</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027161232100.png" alt="image-20241027161232100"></p>
<h3 id="实体模型与表字段不匹配"><a href="#实体模型与表字段不匹配" class="headerlink" title="实体模型与表字段不匹配"></a>实体模型与表字段不匹配</h3><h4 id="字段映射-TableField"><a href="#字段映射-TableField" class="headerlink" title="字段映射 @TableField"></a>字段映射 @TableField</h4><p>一般情况下我们并不需要给字段添加<code>@TableField</code>注解，一些特殊情况除外：</p>
<ul>
<li>成员变量名与数据库字段名不一致</li>
<li>成员变量是以<code>isXXX</code>命名，按照<code>JavaBean</code>的规范，<code>MybatisPlus</code>识别字段时会把<code>is</code>去除，这就导致与数据库不符。</li>
<li>成员变量名与数据库一致，但是与数据库的关键字冲突。使用<code>@TableField</code>注解给字段名添加转义字符：````</li>
</ul>
<p>支持的其它属性如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>必填</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>String</td>
<td>否</td>
<td>“”</td>
<td>数据库字段名</td>
</tr>
<tr>
<td>exist</td>
<td>boolean</td>
<td>否</td>
<td>true</td>
<td>是否为数据库表字段</td>
</tr>
<tr>
<td>condition</td>
<td>String</td>
<td>否</td>
<td>“”</td>
<td>字段 where 实体查询比较条件，有值设置则按设置的值为准，没有则为默认全局的</td>
</tr>
<tr>
<td>update</td>
<td>String</td>
<td>否</td>
<td>“”</td>
<td>字段 update set 部分注入，例如：当在version字段上注解update=”%s+1” 表示更新时会 set version=version+1 （该属性优先级高于 e  l 属性）</td>
</tr>
<tr>
<td>insertStrategy</td>
<td>Enum</td>
<td>否</td>
<td>FieldStrategy.DEFAULT</td>
<td></td>
</tr>
<tr>
<td>updateStrategy</td>
<td>Enum</td>
<td>否</td>
<td>FieldStrategy.DEFAULT</td>
<td>举例：IGNORED update table_a set column=#{columnProperty}</td>
</tr>
<tr>
<td>whereStrategy</td>
<td>Enum</td>
<td>否</td>
<td>FieldStrategy.DEFAULT</td>
<td></td>
</tr>
<tr>
<td>fill</td>
<td>Enum</td>
<td>否</td>
<td>FieldFill.DEFAULT</td>
<td>字段自动填充策略</td>
</tr>
<tr>
<td>select</td>
<td>boolean</td>
<td>否</td>
<td>true</td>
<td>是否进行 select 查询</td>
</tr>
<tr>
<td>keepGlobalFormat</td>
<td>boolean</td>
<td>否</td>
<td>false</td>
<td>是否保持使用全局的 format 进行处理</td>
</tr>
<tr>
<td>jdbcType</td>
<td>JdbcType</td>
<td>否</td>
<td>JdbcType.UNDEFINED</td>
<td>JDBC 类型 (该默认值不代表会按照该值生效)</td>
</tr>
<tr>
<td>typeHandler</td>
<td>TypeHander</td>
<td>否</td>
<td></td>
<td>类型处理器 (该默认值不代表会按照该值生效)</td>
</tr>
<tr>
<td>numericScale</td>
<td>String</td>
<td>否</td>
<td>“”</td>
<td>指定小数点后保留的位数</td>
</tr>
</tbody></table>
<h5 id="属性级别注解-TableField-value-“pwd”"><a href="#属性级别注解-TableField-value-“pwd”" class="headerlink" title="属性级别注解@TableField(value = “pwd”)"></a>属性级别注解@TableField(value = “pwd”)</h5><p>相当于ResultMap</p>
<p>value 指定实体类的字段对应的数据库表字段名</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027163707005.png" alt="image-20241027163707005"></p>
<h5 id="实体类中添加了表中不存在的字段-TableField-exist-false"><a href="#实体类中添加了表中不存在的字段-TableField-exist-false" class="headerlink" title="实体类中添加了表中不存在的字段@TableField(exist = false)"></a>实体类中添加了表中不存在的字段@TableField(exist = false)</h5><p>exist 设置属性在数据库表中是否存在，默认true，无法与value合并使用</p>
<h5 id="设置属性是否包含在查询结果中-TableField-select-false"><a href="#设置属性是否包含在查询结果中-TableField-select-false" class="headerlink" title="设置属性是否包含在查询结果中@TableField(select = false)"></a>设置属性是否包含在查询结果中@TableField(select = false)</h5><p>与查询投影select不冲突，有些属性较为敏感，不能参与查询结果中</p>
<h4 id="表名映射-TableName"><a href="#表名映射-TableName" class="headerlink" title="表名映射 @TableName"></a>表名映射 @TableName</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027164800496.png" alt="image-20241027164800496"></p>
<p>TableName注解除了指定表名以外，还可以指定很多其它属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>必须指定</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>String</td>
<td>否</td>
<td>“”</td>
<td>表名</td>
</tr>
<tr>
<td>schema</td>
<td>String</td>
<td>否</td>
<td>“”</td>
<td>schema</td>
</tr>
<tr>
<td>keepGlobalPrefix</td>
<td>boolean</td>
<td>否</td>
<td>false</td>
<td>是否保持使用全局的 tablePrefix 的值（当全局 tablePrefix 生效时）</td>
</tr>
<tr>
<td>resultMap</td>
<td>String</td>
<td>否</td>
<td>“”</td>
<td>xml 中 resultMap 的 id（用于满足特定类型的实体类对象绑定）</td>
</tr>
<tr>
<td>autoResultMap</td>
<td>boolean</td>
<td>否</td>
<td>false</td>
<td>是否自动构建 resultMap 并使用（如果设置 resultMap 则不会进行 resultMap 的自动构建与注入）</td>
</tr>
<tr>
<td>excludeProperty</td>
<td>String[]</td>
<td>否</td>
<td>{}</td>
<td>需要排除的属性名 @since 3.3.1</td>
</tr>
</tbody></table>
<h2 id="DML编程控制"><a href="#DML编程控制" class="headerlink" title="DML编程控制"></a>DML编程控制</h2><h3 id="Insert-添加"><a href="#Insert-添加" class="headerlink" title="Insert 添加"></a>Insert 添加</h3><h4 id="id生成策略-TableId"><a href="#id生成策略-TableId" class="headerlink" title="id生成策略@TableId"></a>id生成策略@TableId</h4><p>在主键字段上方的注解</p>
<p>@TableId(type = IdType.AUTO)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027171143267.png" alt="image-20241027171143267"></p>
<p><code>TableId</code>注解支持两个属性：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">类型</th>
<th align="left">必须指定</th>
<th align="left">默认值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">value</td>
<td align="left">String</td>
<td align="left">否</td>
<td align="left">“”</td>
<td align="left">表名</td>
</tr>
<tr>
<td align="left">type</td>
<td align="left">Enum</td>
<td align="left">否</td>
<td align="left">IdType.NONE</td>
<td align="left">指定主键类型</td>
</tr>
</tbody></table>
<p><code>IdType</code>支持的类型有：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">AUTO</td>
<td align="left">数据库 ID 自增</td>
</tr>
<tr>
<td align="left">NONE</td>
<td align="left">无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT）</td>
</tr>
<tr>
<td align="left">INPUT</td>
<td align="left">insert 前自行 set 主键值</td>
</tr>
<tr>
<td align="left">ASSIGN_ID</td>
<td align="left">分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法)</td>
</tr>
<tr>
<td align="left">ASSIGN_UUID</td>
<td align="left">分配 UUID,主键类型为 String(since 3.3.0),使用接口IdentifierGenerator的方法nextUUID(默认 default 方法)</td>
</tr>
<tr>
<td align="left">ID_WORKER</td>
<td align="left">分布式全局唯一 ID 长整型类型(please use ASSIGN_ID)</td>
</tr>
<tr>
<td align="left">UUID</td>
<td align="left">32 位 UUID 字符串(please use ASSIGN_UUID)</td>
</tr>
<tr>
<td align="left">ID_WORKER_STR</td>
<td align="left">分布式全局唯一 ID 字符串类型(please use ASSIGN_ID)</td>
</tr>
</tbody></table>
<p>这里比较常见的有三种：</p>
<ul>
<li><code>AUTO</code>：利用数据库的id自增长</li>
<li><code>INPUT</code>：手动生成id</li>
<li><code>ASSIGN_ID</code>：雪花算法生成<code>Long</code>类型的全局唯一id，这是默认的ID策略</li>
</ul>
<h5 id="默认策略-ASSIGN-ID—雪花算法"><a href="#默认策略-ASSIGN-ID—雪花算法" class="headerlink" title="默认策略 ASSIGN_ID—雪花算法"></a>默认策略 ASSIGN_ID—雪花算法</h5><p>未指定id则生成一个随机id，是64位的二进制数，要求数据库主键用bigINT，实体类字段Long</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027171823185.png" alt="image-20241027171823185"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027173529947.png" alt="image-20241027173529947"></p>
<h4 id="application-yml-全局配置"><a href="#application-yml-全局配置" class="headerlink" title="application.yml 全局配置"></a>application.yml 全局配置</h4><h5 id="全局id生成策略-id-type"><a href="#全局id生成策略-id-type" class="headerlink" title="全局id生成策略 id-type"></a>全局id生成策略 <code>id-type</code></h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027172005757.png" alt="image-20241027172005757"></p>
<p>关键字：id-type</p>
<h5 id="全局表名前缀-table-prefix"><a href="#全局表名前缀-table-prefix" class="headerlink" title="全局表名前缀 table-prefix"></a>全局表名前缀 <code>table-prefix</code></h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027172325296.png" alt="image-20241027172325296"></p>
<p>通过反射获取实体类名(User) 首字母小写，加上前缀拼成表名tbl_user </p>
<h3 id="Delete-删除"><a href="#Delete-删除" class="headerlink" title="Delete 删除"></a>Delete 删除</h3><h4 id="多记录操作—批量删除"><a href="#多记录操作—批量删除" class="headerlink" title="多记录操作—批量删除"></a>多记录操作—批量删除</h4><h5 id="根据id批量删除-deleteBatchIds-list"><a href="#根据id批量删除-deleteBatchIds-list" class="headerlink" title="根据id批量删除 deleteBatchIds(list)"></a>根据id批量删除 <code>deleteBatchIds(list)</code></h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027172711970.png" alt="image-20241027172711970"></p>
<h5 id="根据id批量查询selectBatchIds-list"><a href="#根据id批量查询selectBatchIds-list" class="headerlink" title="根据id批量查询selectBatchIds(list)"></a>根据id批量查询<code>selectBatchIds(list)</code></h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027172756939.png" alt="image-20241027172756939"></p>
<h4 id="逻辑删除—减少物理删除行为"><a href="#逻辑删除—减少物理删除行为" class="headerlink" title="逻辑删除—减少物理删除行为"></a>逻辑删除—减少物理删除行为</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027173131845.png" alt="image-20241027173131845"></p>
<h5 id="表里添加状态字段"><a href="#表里添加状态字段" class="headerlink" title="表里添加状态字段"></a>表里添加状态字段</h5><p>deleted int(1) default 0</p>
<h5 id="实体类添加状态字段-TableLogic-value-“0”-delval-“1”"><a href="#实体类添加状态字段-TableLogic-value-“0”-delval-“1”" class="headerlink" title="实体类添加状态字段@TableLogic(value = “0”, delval = “1”)"></a>实体类添加状态字段@TableLogic(value = “0”, delval = “1”)</h5><p>delval表示delete操作时（实际为update）将状态字段为0的行更新为1，value表示执行select时无条件追加状态字段=0的查询条件</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027173428739.png" alt="image-20241027173428739"></p>
<h5 id="对语句的影响"><a href="#对语句的影响" class="headerlink" title="对语句的影响"></a>对语句的影响</h5><p>**delete操作变成update set deleted = 1 where id = 1 and deleted = 0 **</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027173835384.png" alt="image-20241027173835384"></p>
<p><strong>select操作最后添加一个where deleted=0，只查询未被删除的记录</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027174031847.png" alt="image-20241027174031847"></p>
<h5 id="application-yml-全局配置逻辑删除属性"><a href="#application-yml-全局配置逻辑删除属性" class="headerlink" title="application.yml 全局配置逻辑删除属性"></a>application.yml 全局配置逻辑删除属性</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027174445793.png" alt="image-20241027174445793"></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除状态字段名称(实体类的属性名)</span></span><br><span class="line"><span class="attr">logic-delete-field:</span> <span class="string">deleted</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示未被删除的状态值</span></span><br><span class="line"><span class="attr">logic-not-delete-value:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示已被删除的状态值</span></span><br><span class="line"><span class="attr">logic-delete-value:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="Update-修改"><a href="#Update-修改" class="headerlink" title="Update 修改"></a>Update 修改</h3><h4 id="乐观锁—并发控制"><a href="#乐观锁—并发控制" class="headerlink" title="乐观锁—并发控制"></a>乐观锁—并发控制</h4><h5 id="添加version字段-Version注解"><a href="#添加version字段-Version注解" class="headerlink" title="添加version字段 @Version注解"></a>添加version字段 @Version注解</h5><p>数据库和实体类都要加，前面的改完将version自增，让后面的修改失效</p>
<h5 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h5><p>MpConfig ： addInnerInterceptor OptimisticLocker</p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ol>
<li>收集到的实体类对象version属性不能为空</li>
<li><strong>可以先将修改的数据查出来</strong>，然后逐一set属性值，这样不用手动设置version</li>
<li>A，B同时来修改记录c，AB获取到的version都是4，A先修改，update语句中会自动给sql加上<code>set version = version + 1 where version = 4</code> ， 下一条执行的时候，SQL语句中的version依然是4，但是实际上version已经变成5，修改失效 </li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027185741184.png" alt="image-20241027185741184"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241027190301011.png" alt="image-20241027190301011"></p>
<h1 id="Service-层"><a href="#Service-层" class="headerlink" title="Service 层"></a>Service 层</h1><h2 id="服务接口和实现类需要继承"><a href="#服务接口和实现类需要继承" class="headerlink" title="服务接口和实现类需要继承"></a>服务接口和实现类需要继承</h2><p>接口需要继承<code>IService&lt;T&gt;</code> 实现类需要继承<code>ServiceImpl&lt;TMapper,T&gt;</code> T为实体类名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IBlogService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Blog&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlogServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;BlogMapper, Blog&gt; <span class="keyword">implements</span> <span class="title class_">IBlogService</span></span><br></pre></td></tr></table></figure>

<p>Mapper接口继承BaseMapper即可。</p>
<h2 id="查-get"><a href="#查-get" class="headerlink" title="查 (get)"></a>查 (get)</h2><h3 id="开始方法"><a href="#开始方法" class="headerlink" title="开始方法"></a>开始方法</h3><p>对于复杂的查询：</p>
<ul>
<li><code>query()</code> 可以拿到queryWrapper的链式调用 可以用这个开始查询，后面跟条件</li>
<li><code>lambdaQuery()</code> 拿到lqw的链式调用</li>
</ul>
<h3 id="终结方法"><a href="#终结方法" class="headerlink" title="终结方法"></a>终结方法</h3><ul>
<li><p><code>count()</code> 作为终结方法可以返回查询结果的个数</p>
</li>
<li><p><code>one()</code>返回一个结果 类型为实体类</p>
</li>
<li><p><code>list()</code> 将结果作为list返回</p>
</li>
<li><p><code>page(Page page)</code> 返回某页的内容</p>
</li>
</ul>
<h2 id="增-save"><a href="#增-save" class="headerlink" title="增 (save)"></a>增 (save)</h2><h2 id="删-remove"><a href="#删-remove" class="headerlink" title="删 (remove)"></a>删 (remove)</h2><h2 id="改-update"><a href="#改-update" class="headerlink" title="改 (update)"></a>改 (update)</h2><h3 id="开始方法、结束方法"><a href="#开始方法、结束方法" class="headerlink" title="开始方法、结束方法"></a>开始方法、结束方法</h3><p><code>update()</code> 更新语句必须以此开始，以此结束，返回的是boolean</p>
<h3 id="中间方法"><a href="#中间方法" class="headerlink" title="中间方法"></a>中间方法</h3><p><code>setsql(String sql)</code> set的复杂表达式</p>
<p>中间使用条件语句 </p>
<h2 id="条件语句（中间方法）"><a href="#条件语句（中间方法）" class="headerlink" title="条件语句（中间方法）"></a>条件语句（中间方法）</h2><ul>
<li>大小关系：eq ne ge le gt lt </li>
<li>模糊匹配：like()</li>
<li>where id in(1,2,3,4)  ： in(“id”, idList)</li>
<li>last(): sql语句的最后一部分，可以添加orderByField等信息，手动拼字符串</li>
</ul>
]]></content>
      <categories>
        <category>web development</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>mybatis</tag>
        <tag>lombok</tag>
        <tag>持久层</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC MyBatis XML Maven</title>
    <url>/2024/07/25/mvn%20xml%20mybatis%20jdbc/</url>
    <content><![CDATA[<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p>标记语言 e<strong>X</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage</p>
<p>自闭合标签 ：标签不包含任何内容可以简化为<code>&lt;br/&gt;</code> </p>
<p><a href="https://zh.wikipedia.org/wiki/XML">XML - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<p><a href="https://www.runoob.com/xml/xml-tutorial.html">XML 教程 | 菜鸟教程 (runoob.com)</a> </p>
<p><strong>XML</strong>（可扩展标记语言，Extensible Markup Language）的核心语法主要用于描述结构化数据。XML 语法非常严格，但也因此具有良好的可读性和可扩展性。以下是 <strong>XML</strong> 的一些重要核心语法规则和概念，它们是理解和正确编写 XML 文档的基础：</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><hr>
<p><strong>元素（Element）</strong></p>
<ul>
<li><strong>元素是 XML 文档的基本构建块</strong>。每个元素有一个<strong>开始标签</strong>和一个<strong>结束标签</strong>，或是自闭合的标签。</li>
</ul>
<p>语法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element</span>&gt;</span>content<span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>开始标签</strong>：<code>&lt;element&gt;</code></li>
<li><strong>结束标签</strong>：<code>&lt;/element&gt;</code></li>
<li><strong>自闭合标签</strong>：<code>&lt;element /&gt;</code></li>
</ul>
<p>元素之间可以嵌套：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span>content<span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>规则：</p>
<ul>
<li>元素名称必须区分大小写。<code>&lt;Element&gt;</code> 与 <code>&lt;element&gt;</code> 是不同的标签。</li>
<li>标签名称不能以数字或特殊符号开头，通常使用字母、数字和某些符号（如 <code>_</code>、<code>-</code>）。</li>
<li>标签必须要有匹配的结束标签，或是用自闭合标签。</li>
</ul>
<hr>
<p><strong>属性（Attributes）</strong></p>
<ul>
<li><strong>属性</strong>为元素提供额外的信息。属性位于开始标签的内部，使用键值对表示，且值必须使用双引号或单引号包裹。</li>
</ul>
<p>语法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element</span> <span class="attr">attribute</span>=<span class="string">&quot;value&quot;</span>&gt;</span>content<span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element</span> <span class="attr">attribute</span>=<span class="string">&quot;value&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>规则：</p>
<ul>
<li>一个元素可以有多个属性，属性的名称必须唯一。</li>
<li>属性值必须用引号包裹（双引号或单引号均可）。</li>
</ul>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">title</span>=<span class="string">&quot;XML Guide&quot;</span> <span class="attr">author</span>=<span class="string">&quot;John Doe&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>声明（XML Declaration）</strong></p>
<ul>
<li>XML 文档通常以声明开头，定义了 XML 版本和编码格式。虽然声明是可选的，但建议在每个 XML 文件开头声明。</li>
</ul>
<p>语法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>version</code>：指定 XML 版本，通常为 <code>1.0</code> 或 <code>1.1</code>。</li>
<li><code>encoding</code>：指定字符编码，通常为 <code>UTF-8</code>。</li>
</ul>
<hr>
<p><strong>注释（Comments）</strong></p>
<ul>
<li><strong>注释</strong>用于对 XML 文档进行说明或标注，注释不会被解析器处理。</li>
</ul>
<p>语法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是一个注释 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>规则：</p>
<ul>
<li>注释不能嵌套，且不能出现在声明之前。</li>
<li>注释内容不能包含 <code>--</code> 连字符。</li>
</ul>
<hr>
<p><strong>CDATA（Character Data，字符数据）</strong></p>
<ul>
<li><strong>CDATA</strong> 区域用于包含原样保留的字符数据。它告诉 XML 解析器不要处理其中的内容为标签或实体。通常用于嵌入包含特殊符号（如 <code>&lt;</code>、<code>&amp;</code>）的文本数据，例如 HTML 代码片段。</li>
</ul>
<p>语法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;![CDATA[</span><br><span class="line">    &lt;content&gt; 这里的内容将不会被解析为标签 &lt;/content&gt;</span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure>

<p>规则：</p>
<ul>
<li>CDATA 区块中的内容不会被解析器处理，即使它包含 <code>&lt;</code>、<code>&gt;</code>、<code>&amp;</code> 等特殊字符。</li>
</ul>
<hr>
<p><strong>实体引用（Entities）</strong></p>
<ul>
<li><strong>实体</strong>用于替代特殊字符或常用的短字符串。常见的实体包括：<code>&amp;amp;</code>、<code>&amp;lt;</code>、<code>&amp;gt;</code>、<code>&amp;apos;</code> 和 <code>&amp;quot;</code>。</li>
</ul>
<p>语法：</p>
<ul>
<li><strong>特殊符号的实体引用</strong>：<ul>
<li><code>&amp;lt;</code> 表示 <code>&lt;</code></li>
<li><code>&amp;gt;</code> 表示 <code>&gt;</code></li>
<li><code>&amp;amp;</code> 表示 <code>&amp;</code></li>
<li><code>&amp;apos;</code> 表示 <code>&#39;</code></li>
<li><code>&amp;quot;</code> 表示 <code>&quot;</code></li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>This is <span class="symbol">&amp;lt;</span>important<span class="symbol">&amp;gt;</span> content <span class="symbol">&amp;amp;</span> data<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此 XML 中的内容表示为 <code>This is &lt;important&gt; content &amp; data</code>。</p>
<hr>
<p><strong>命名空间（Namespaces）</strong></p>
<ul>
<li><strong>命名空间</strong>用于避免不同 XML 文档中的元素或属性发生冲突，尤其在合并两个不同 XML 数据集时更为重要。</li>
</ul>
<p>语法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element</span> <span class="attr">xmlns:prefix</span>=<span class="string">&quot;namespaceURI&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prefix:child</span>&gt;</span>content<span class="tag">&lt;/<span class="name">prefix:child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>xmlns</strong> 是定义命名空间的标准属性。</li>
<li><code>prefix</code> 是命名空间的前缀，<code>namespaceURI</code> 是对应的命名空间地址。</li>
</ul>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span> <span class="attr">xmlns:bk</span>=<span class="string">&quot;http://example.org/book&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bk:book</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bk:title</span>&gt;</span>XML Guide<span class="tag">&lt;/<span class="name">bk:title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bk:book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里定义了一个命名空间 <code>bk</code>，用来区分不同命名空间下的元素。</p>
<hr>
<p><strong>空元素（Empty Elements）</strong></p>
<ul>
<li><strong>空元素</strong>是没有内容的元素。可以用以下两种方式表示：<ul>
<li><code>&lt;element&gt;&lt;/element&gt;</code></li>
<li><code>&lt;element /&gt;</code>（自闭合）</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">emptyElement</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>处理指令（Processing Instructions）</strong></p>
<ul>
<li><strong>处理指令</strong>用于为应用程序提供处理 XML 文档的特定指令。</li>
</ul>
<p>语法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?instruction content?&gt;</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;style.xsl&quot;</span>?&gt;</span></span><br></pre></td></tr></table></figure>

<p>此指令告诉浏览器使用 <code>style.xsl</code> 样式表来展示 XML 数据。</p>
<h2 id="XML-Schema-和-DTD"><a href="#XML-Schema-和-DTD" class="headerlink" title="XML Schema 和 DTD"></a>XML Schema 和 DTD</h2><ul>
<li><strong>XML Schema</strong> 和 <strong>DTD（Document Type Definition）</strong> 是定义 XML 文档结构和约束的工具，帮助确保 XML 数据的有效性和结构一致性。</li>
</ul>
<h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> [</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">to</span>,<span class="keyword">from</span>,<span class="keyword">heading</span>,<span class="keyword">body</span>)&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">to</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">from</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">heading</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">body</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="XML-Schema"><a href="#XML-Schema" class="headerlink" title="XML Schema"></a>XML Schema</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xs:schema</span> <span class="attr">xmlns:xs</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&quot;note&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&quot;to&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xs:string&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&quot;from&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xs:string&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&quot;heading&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xs:string&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&quot;body&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xs:string&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xs:element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>DTD</strong>：早期用来定义 XML 文档结构，较为简单。</li>
<li><strong>XML Schema</strong>：更现代且功能更强大的 XML 定义方式，支持更精确的数据类型定义。</li>
</ul>
<h4 id="Spring-maven中的命名空间是什么？"><a href="#Spring-maven中的命名空间是什么？" class="headerlink" title="Spring maven中的命名空间是什么？"></a>Spring maven中的命名空间是什么？</h4><p>为了避免标签名称冲突创建了namespace的概念，对于beans这个标签：</p>
<ul>
<li>xmlns=”<a href="https://springframework.org/schema/beans/&quot;">https://springframework.org/schema/beans/&quot;</a> 默认命名空间的namespaceURI指向spring官网</li>
<li>xmlns:context 创建名为context的命名空间</li>
<li>context:property-placeholder 指明property-placeholder这个标签含义从context命名空间解析</li>
</ul>
<p>XML schema(.xsd文件)用于定义xml文档的结构，要说明的是XML作为标记语言本身其实比较自由，如果要严格一些，比如作为框架的配置文件，就需要做出一些限制，XML schema正好是做这个的。</p>
<p><code>xsi</code> 是一个业界默认的用于 XSD(（XML Schema Definition) 文件的命名空间。</p>
<p>如果你创建一个命名空间需要引用别人的schema，需要加上这个schema的namespaceURI，并且在xsi的schemaLocation中加入namespaceURI和xsd文件的准确URL</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span><br></pre></td></tr></table></figure>

<p>上面这行的语法其实是， <code>xsi:schemaLocation = &quot;键&quot; “值”</code><br>即 xsi 命名空间下 schemaLocation 元素的值为一个由空格分开的URI pair。</p>
<blockquote>
<p>The first records the author’s warrant with pairs of URI references (<strong>one for the namespace name</strong>, and <strong>one for a hint as to the location of a schema document</strong> defining names for that namespace name)</p>
</blockquote>
<ul>
<li>前一个“键” <a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a> 指代 命名空间， 只是一个全局唯一字符串 URI ，用来表示这个命名空间是唯一的 </li>
<li>后一个值指代 XSD URL , 这个值指示了命名空间所对应的 <u>XSD 文件</u>的位置， xml parser 可以利用这个信息获取到 XSD 文件， 从而通过 XSD 文件对所有属于 URN <a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a> 的元素结构进行校验， 因此这个值必然是可以访问的， 且访问到的内容是一个 XSD 文件的内容</li>
</ul>
<h4 id="URI-amp-URL-amp-URN"><a href="#URI-amp-URL-amp-URN" class="headerlink" title="URI &amp; URL &amp; URN"></a>URI &amp; URL &amp; URN</h4><p>Identifier &amp; Locator &amp; Name</p>
<p>URI比URL更加抽象</p>
<p>URN确定了东西的身份，不提供找到资源的方法，URL提供了找到它的方式，点开一个URL就能直接找到资源。</p>
<blockquote>
<p>用于标志唯一书目的<a href="https://zh.wikipedia.org/wiki/ISBN">ISBN</a>系统是一个典型的URN使用范例。例如，<code>ISBN 0-486-27557-4</code>无二义性地标志出莎士比亚的戏剧《<a href="https://zh.wikipedia.org/wiki/%E7%BD%97%E5%AF%86%E6%AC%A7%E4%B8%8E%E6%9C%B1%E4%B8%BD%E5%8F%B6">罗密欧与朱丽叶</a>》的某一特定版本。为获得该资源并阅读该书，人们需要它的位置，也就是一个URL地址。在<a href="https://zh.wikipedia.org/wiki/%E7%B1%BBUnix">类Unix</a>操作系统中，一个典型的URL地址可能是一个<a href="https://zh.wikipedia.org/w/index.php?title=%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95&action=edit&redlink=1">文件目录</a>，例如<code>file:///home/username/RomeoAndJuliet.pdf</code>。该URL标志出存储于本地硬盘中的电子书文件。因此，URL和URN有着互补的作用。</p>
</blockquote>
<p>这里有两个URI，分别是maven和spring的配置xml中的namespaceURI：</p>
<p><a href="http://springframework.org/schema/beans">http://springframework.org/schema/beans</a> 官方做成了像网盘一样的页面，里面有xsd文件的存储超链接，可以方便地访问xsd文件</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019210205303.png" alt="image-20241019210205303"></p>
<p><a href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a> 就是一个PageNotFound页面</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019210235645.png" alt="image-20241019210235645"></p>
<p>对于schemaLocation中的URI pair，到底能不能通过第一个URI直接定位资源不重要，重要的是它是一个<u>唯一</u>标识这个东西身份的字符串，第二个URI一定是一个URL，能访问到.xsd文件本身</p>
<h4 id="XML-拓展阅读"><a href="#XML-拓展阅读" class="headerlink" title="XML 拓展阅读"></a>XML 拓展阅读</h4><p><a href="https://zh.wikipedia.org/zh-cn/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E8%AF%86%E7%AC%A6">统一资源标识符（URI） - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/38120321">URL与URI与URN，有联系有区别？ - 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/372022140">XML中的xmlns、xmlns:xsi和xsi:sechemaLoacation的具体含义是什么？ - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/lengxiao1993/article/details/77914155">详解 xml 文件头部的 xmlns:xsi-CSDN博客</a></p>
<p><a href="https://www.w3.org/TR/xmlschema-1/#schema-loc">How schema definitions are located on the Web - w3.org</a> </p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><strong>元素</strong> 是 XML 的核心构建块，标签必须正确匹配或自闭合。</li>
<li><strong>属性</strong> 为元素提供额外信息，值必须用引号包裹。</li>
<li><strong>XML 声明</strong> 用于定义 XML 的版本和字符编码。</li>
<li><strong>注释</strong> 用于在文档中添加说明性文字，不会被解析器执行。</li>
<li><strong>CDATA 区域</strong> 用于保留未解析的原始文本数据。</li>
<li><strong>实体引用</strong> 用于表示特殊字符。</li>
<li><strong>命名空间</strong> 用于避免元素或属性名称冲突。</li>
<li><strong>空元素</strong> 可以通过自闭合标签表示。</li>
<li><strong>DTD 和 XML Schema</strong> 是用于验证 XML 文档结构的工具。</li>
<li><strong>处理指令</strong> 可以传递给应用程序或解析器，提供特定处理逻辑。</li>
</ol>
<p>这些核心语法确保了 XML 文档的规范性和可读性，帮助应用程序和解析器处理结构化数据。</p>
<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><h4 id="项目-Project"><a href="#项目-Project" class="headerlink" title="项目 Project"></a>项目 Project</h4><p>IDEA项目结构：.idea文件代表整个项目（整个窗口）</p>
<p>如果删掉.idea文件，里面的模块都将无法运行</p>
<h4 id="模块-Modules"><a href="#模块-Modules" class="headerlink" title="模块 Modules"></a>模块 Modules</h4><p>创建项目时自动创建一个和项目同名的module，这个module里包含项目的.idea以及自己的示例src等。每个module都有一个iml(information of module)文件，如果从外部导入其他路径的module，会和这个module并列。</p>
<p>模块套模块就是物理上的依赖关系，maven project有一个pom，其子模块也可以有pom，并且可以相互依赖。maven项目创建以后自动创建一个maven父模块，模块路径就是项目所在的路径，包含了iml和.idea，可以手动移除整个模块，但不能删除idea文件。</p>
<p>如果导入不同的modules之间有物理上的嵌套关系，自动变成父子模块关系，如果没有嵌套关系，就是并列的，相互之间不会影响。</p>
<p>项目管理工具</p>
<p><a href="https://mvnrepository.com/">Maven Repository: Search/Browse/Explore (mvnrepository.com)</a> </p>
<h3 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h3><p>标准化统一的构建路程，编译测试打包发布</p>
<h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>default: compile</p>
<p>编译：main 测试：test 运行：打包以后的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924153605252-1727923499126-1.png" alt="image-20240924153605252"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="POM-对象模型"><a href="#POM-对象模型" class="headerlink" title="POM 对象模型"></a>POM 对象模型</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924151728949-1727923499126-2.png" alt="image-20240924151728949"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924152425583-1727923499126-3.png" alt="image-20240924152425583"></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>clean 清理项目下文件</p>
<p>compile 编译项目下文件生成target目录</p>
<p>test 执行项目下的文件</p>
<p>package 打包成jar包</p>
<p>install 把当前的项目打包jar 放到本地仓库 能对其配置依赖</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924153131022-1727923499126-4.png" alt="image-20240924153131022"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024201235892-1729772077345-1.png" alt="image-20241024201235892"></p>
<h4 id="clean—清理target目录"><a href="#clean—清理target目录" class="headerlink" title="clean—清理target目录"></a><strong>clean</strong>—清理target目录</h4><p>清理当前项目的target目录（上一次构建生成的文件）</p>
<h4 id="validate——验证项目元信息可用"><a href="#validate——验证项目元信息可用" class="headerlink" title="validate——验证项目元信息可用"></a>validate——验证项目元信息可用</h4><h4 id="compile—将src-main-java编译为字节码，输出到target目录"><a href="#compile—将src-main-java编译为字节码，输出到target目录" class="headerlink" title="compile—将src/main/java编译为字节码，输出到target目录"></a><strong>compile</strong>—将src/main/java编译为字节码，输出到target目录</h4><h4 id="test——单元测试（可跳过）"><a href="#test——单元测试（可跳过）" class="headerlink" title="test——单元测试（可跳过）"></a>test——单元测试（可跳过）</h4><h4 id="package—打包-jar-war-pom等"><a href="#package—打包-jar-war-pom等" class="headerlink" title="package—打包(jar,war,pom等)"></a><strong>package</strong>—打包(jar,war,pom等)</h4><h4 id="verify——检查打的包是否有效"><a href="#verify——检查打的包是否有效" class="headerlink" title="verify——检查打的包是否有效"></a>verify——检查打的包是否有效</h4><h4 id="install—将项目部署到本地仓库"><a href="#install—将项目部署到本地仓库" class="headerlink" title="install—将项目部署到本地仓库"></a><strong>install</strong>—将项目部署到本地仓库</h4><h4 id="deploy—将项目部署到远程仓库"><a href="#deploy—将项目部署到远程仓库" class="headerlink" title="deploy—将项目部署到远程仓库"></a><strong>deploy</strong>—将项目部署到远程仓库</h4><p>需要在maven的setting.xml中配置私服的用户名和密码（<server><mirror>的id相同），在pom.xml配置distributionmanagement</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025184411633.png" alt="image-20241025184411633"></p>
<h4 id="site——创建项目站点"><a href="#site——创建项目站点" class="headerlink" title="site——创建项目站点"></a>site——创建项目站点</h4><p>不属于build</p>
<h2 id="高级进阶"><a href="#高级进阶" class="headerlink" title="高级进阶"></a>高级进阶</h2><h3 id="分模块开发"><a href="#分模块开发" class="headerlink" title="分模块开发"></a>分模块开发</h3><p>不同模块之间的依赖关系</p>
<p>添加依赖到pom.xml中的dependency</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>安装依赖到本地仓库：</p>
<p><mark>maven-install<mark></p>
<h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><h4 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a>依赖冲突</h4><p>同一个pom.xml 后配置的覆盖先配置的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024184013133-1729772371846-3.png" alt="image-20241024184013133"></p>
<h3 id="可选依赖-amp-排除依赖"><a href="#可选依赖-amp-排除依赖" class="headerlink" title="可选依赖&amp;排除依赖"></a>可选依赖&amp;排除依赖</h3><h4 id="可选依赖——主动向别人隐藏，别人引用时看不到（被引用者）"><a href="#可选依赖——主动向别人隐藏，别人引用时看不到（被引用者）" class="headerlink" title="可选依赖——主动向别人隐藏，别人引用时看不到（被引用者）"></a>可选依赖——主动向别人隐藏，别人引用时看不到（被引用者）</h4><p><code>&lt;optional&gt;true&lt;optional&gt;</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024184316546-1729772371847-4.png" alt="image-20241024184316546"></p>
<h4 id="排除依赖——引用时主动忽略某个元素（引用者）"><a href="#排除依赖——引用时主动忽略某个元素（引用者）" class="headerlink" title="排除依赖——引用时主动忽略某个元素（引用者）"></a>排除依赖——引用时主动忽略某个元素（引用者）</h4><p><code>&lt;exclusion&gt;&lt;/exclusion&gt;</code> 不用写版本号</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024184835202-1729772371847-7.png" alt="image-20241024184835202"></p>
<h3 id="聚合工程与继承"><a href="#聚合工程与继承" class="headerlink" title="聚合工程与继承"></a>聚合工程与继承</h3><h4 id="聚合——同时构建模块"><a href="#聚合——同时构建模块" class="headerlink" title="聚合——同时构建模块"></a>聚合——同时构建模块</h4><p>某个模块变化了，依赖于它的还要一个一个重新构建。聚合工程可以同时重新构建他们</p>
<h5 id="创建空工程"><a href="#创建空工程" class="headerlink" title="创建空工程"></a>创建空工程</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024185111570-1729772371847-5.png" alt="image-20241024185111570"></p>
<h5 id="改变打包方式——pom"><a href="#改变打包方式——pom" class="headerlink" title="改变打包方式——pom"></a>改变打包方式——pom</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024185202904-1729772371847-6.png" alt="image-20241024185202904"></p>
<h5 id="添加聚合的模块"><a href="#添加聚合的模块" class="headerlink" title="添加聚合的模块"></a>添加聚合的模块</h5><p>顺序会自动根据依赖关系处理</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024185331214-1729772371847-8.png" alt="image-20241024185331214"></p>
<h4 id="继承——简化子工程配置"><a href="#继承——简化子工程配置" class="headerlink" title="继承——简化子工程配置"></a>继承——简化子工程配置</h4><p>多个模块有相同的依赖，更换版本比较繁琐。</p>
<p>简化子工程配置，减少版本冲突</p>
<h5 id="父工程打包方式——pom"><a href="#父工程打包方式——pom" class="headerlink" title="父工程打包方式——pom"></a>父工程打包方式——pom</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024190544704-1729772371847-9.png" alt="image-20241024190544704"></p>
<h5 id="父工程配置子工程共同依赖"><a href="#父工程配置子工程共同依赖" class="headerlink" title="父工程配置子工程共同依赖"></a>父工程配置子工程共同依赖</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024190619020-1729772371847-10.png" alt="image-20241024190619020"></p>
<h5 id="子工程配置parent"><a href="#子工程配置parent" class="headerlink" title="子工程配置parent"></a>子工程配置parent</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024185744377-1729772371847-11.png" alt="image-20241024185744377"></p>
<p>子类会继承父类的全部依赖，父类动一下，子类全部跟着动，</p>
<h5 id="子类可选的继承项"><a href="#子类可选的继承项" class="headerlink" title="子类可选的继承项"></a>子类可选的继承项</h5><p>有些依赖并不是所有的子工程都需要</p>
<h6 id="父工程配置可选依赖管理"><a href="#父工程配置可选依赖管理" class="headerlink" title="父工程配置可选依赖管理"></a>父工程配置可选依赖管理</h6><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024190202481-1729772371847-12.png" alt="image-20241024190202481"></p>
<h6 id="子工程声明需要此依赖"><a href="#子工程声明需要此依赖" class="headerlink" title="子工程声明需要此依赖"></a>子工程声明需要此依赖</h6><p>不要加版本</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024190240611-1729772371848-13.png" alt="image-20241024190240611"></p>
<h4 id="继承-vs-聚合"><a href="#继承-vs-聚合" class="headerlink" title="继承 vs 聚合"></a>继承 vs 聚合</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024190720813-1729772371848-14.png" alt="image-20241024190720813"></p>
<h3 id="属性加载"><a href="#属性加载" class="headerlink" title="属性加载"></a>属性加载</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024190830292-1729772371848-15.png" alt="image-20241024190830292"></p>
<p>定义一个常量，需要的时候直接写<code>$&#123;&#125;</code>，减少硬编码，降低耦合 </p>
<p><code>&lt;properties&gt;</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024191136401-1729772371848-17.png" alt="image-20241024191136401"></p>
<h4 id="properties配置文件-加载属性"><a href="#properties配置文件-加载属性" class="headerlink" title=".properties配置文件 加载属性"></a>.properties配置文件 加载属性</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024191334633-1729772371848-16.png" alt="image-20241024191334633"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024191340916-1729772371848-18.png" alt="image-20241024191340916"></p>
<p><a href="https://www.cnblogs.com/hcgk/p/17600908.html">maven-resources-plugin详解 - 红尘过客2022 - 博客园 (cnblogs.com)</a></p>
<h5 id="指定resources目录，纳入maven管理"><a href="#指定resources目录，纳入maven管理" class="headerlink" title="指定resources目录，纳入maven管理"></a>指定resources目录，纳入maven管理</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024195223511-1729772371848-19.png" alt="image-20241024195223511"></p>
<p>子项目会继承父项目的配置，将自己的resources作为资源</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024191550934-1729772371848-22.png" alt="image-20241024191550934"></p>
<h5 id="解决打war包强制要求WEB-INF-web-xml"><a href="#解决打war包强制要求WEB-INF-web-xml" class="headerlink" title="解决打war包强制要求WEB-INF/web.xml"></a>解决打war包强制要求WEB-INF/web.xml</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024200210773-1729772371848-21.png" alt="image-20241024200210773"></p>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024200423176-1729772371848-23.png" alt="image-20241024200423176"></p>
<p>GA General Availability</p>
<h3 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h3><h4 id="配置多环境"><a href="#配置多环境" class="headerlink" title="配置多环境"></a>配置多环境</h4><h5 id="指定加载某一环境"><a href="#指定加载某一环境" class="headerlink" title="指定加载某一环境"></a>指定加载某一环境</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024200555818-1729772371848-25.png" alt="image-20241024200555818"></p>
<p>profiles id </p>
<p>activeByDefault 默认环境</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024200720633-1729772371848-24.png" alt="image-20241024200720633"></p>
<h5 id="构建指令-P-环境名"><a href="#构建指令-P-环境名" class="headerlink" title="构建指令 -P 环境名"></a>构建指令 -P 环境名</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024200902692-1729772371848-26.png" alt="image-20241024200902692"></p>
<h4 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024201215677-1729772371848-27.png" alt="image-20241024201215677"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024201235892-1729772371848-28.png" alt="image-20241024201235892"></p>
<p>测试，但是忽略一些东西</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024201333235-1729772371848-29.png" alt="image-20241024201333235"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024201411791-1729772371848-30.png" alt="image-20241024201411791"></p>
<h3 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024225654228.png" alt="image-20241024225654228"></p>
<h4 id="私服仓库分类"><a href="#私服仓库分类" class="headerlink" title="私服仓库分类"></a>私服仓库分类</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024230834698.png" alt="image-20241024230834698"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024230845592.png" alt="image-20241024230845592"></p>
<p>第三方资源：oracle的jdbcJar包</p>
<h4 id="资源上传与下载"><a href="#资源上传与下载" class="headerlink" title="资源上传与下载"></a>资源上传与下载</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024231324939.png" alt="image-20241024231324939"></p>
<p>这些都是本地仓库的配置</p>
<p>需要在maven的xml</p>
<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923155407582-1727923816030-9.png" alt="image-20240923155407582"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923155451882-1727923816031-10.png" alt="image-20240923155451882"></p>
<p>jdbc 接口 </p>
<h2 id="执行SQL步骤"><a href="#执行SQL步骤" class="headerlink" title="执行SQL步骤"></a>执行SQL步骤</h2><p>驱动 实现接口</p>
<ol>
<li>注册Class <code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</code></li>
<li>建立<code>Connection</code>使用<code>DriverManager</code>的<code>getConnenction(url,username,password)</code> 创建连接</li>
<li>建立<code>Statement</code>调用上一部连接对象的<code>createStatement()</code> </li>
<li>调用上一部<code>Statement</code>对象的<code>execute(sql)</code> 执行sql语句，这个函数返回的是操作的数据库的行数</li>
<li>关闭资源，或者try with resource</li>
</ol>
<h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><h4 id="注册驱动，连接数据库"><a href="#注册驱动，连接数据库" class="headerlink" title="注册驱动，连接数据库"></a>注册驱动，连接数据库</h4><p>registerDriver 驱动中自带静态代码块，forname加载之后自动执行（可选）</p>
<p>连接数据库 URL 统一资源定位符</p>
<p><code>jdbc:mysql://localhost:3306/itcast</code> </p>
<p><code>protocol:</code> // <code>ip+port</code> / <code>databaseName</code></p>
<p>DriverManager.getConnection(url, usr, pw)</p>
<h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><h2 id="获取执行sql的对象"><a href="#获取执行sql的对象" class="headerlink" title="获取执行sql的对象"></a>获取执行sql的对象</h2><ul>
<li><code>prepareStatement(sql) </code>  预编译</li>
<li><code>createStatement()</code> 普通执行sql对象</li>
</ul>
<h4 id="管理事务"><a href="#管理事务" class="headerlink" title="管理事务"></a><mark>管理事务<mark></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923195630325-1727923816031-12.png" alt="image-20240923195630325"></p>
<p>mysql自动提交事务，</p>
<p>setAutoCommit(false) 开启事务</p>
<p>commit() 提交事务 rollback() 回滚事务</p>
<p>rollback放到catch块中。</p>
<p>Atomic Consistency Isolational Durability</p>
<h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><h3 id="执行SQL"><a href="#执行SQL" class="headerlink" title="执行SQL"></a>执行SQL</h3><p><code>int executeUpdate(DML, DDL)</code>返回受到影响的行数 </p>
<p><code>ResultSet executeQuery(DQL)</code> 执行DQL，返回结果集</p>
<h2 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h2><h3 id="预防SQL注入"><a href="#预防SQL注入" class="headerlink" title="预防SQL注入"></a>预防SQL注入</h3><p><strong>SQL Injection</strong>：脚本</p>
<p><strong>登录逻辑</strong>：接收username和pswd, 然后在sql语句中插入usrname和pswd</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from tb_user where username = &#x27;&quot;</span> + username + <span class="string">&quot;&#x27;and password = &#x27;&quot;</span> + pswd + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="comment">//结果集没有结果则返回失败</span></span><br></pre></td></tr></table></figure>

<p>登录操作实际上就是查询数据库，pswd = ‘ or ‘1’ =’1 拼接sql语句，改变原先的验证逻辑</p>
<p><strong>解决方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sql = <span class="string">&quot;select * from tb_user where username = ? and password = ?&quot;</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> myConnection.prepareStatement(sql);</span><br><span class="line"><span class="comment">//给参数赋值</span></span><br><span class="line">pstmt.setString(<span class="number">1</span>,username);</span><br><span class="line">pstmt.setString(<span class="number">2</span>,pswd);</span><br><span class="line"><span class="comment">//1,2是问号的位置编号 start from 1</span></span><br><span class="line"></span><br><span class="line">pstmt.executeQuery();</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924163227260-1727923816031-11.png" alt="image-20240924163227260"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">AND</span> password <span class="operator">=</span> <span class="string">&#x27;\&#x27;</span> <span class="keyword">OR</span> \<span class="string">&#x27;1\&#x27;</span><span class="operator">=</span>\<span class="string">&#x27;1&#x27;</span></span><br><span class="line">#用户名为admin 密码为<span class="string">&#x27; OR &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span> </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">AND</span> password <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">OR</span> <span class="string">&#x27;1&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>占位符<strong>将敏感字符变成转义字符</strong>，这样sql就会认为这是一个文本类的单引号而不是格式的单引号</p>
</li>
<li><p>自动进行类型转换，外边加一层引号</p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924165014456-1727923816031-13.png" alt="image-20240924165014456"></p>
<h3 id="预编译SQL语句，高性能"><a href="#预编译SQL语句，高性能" class="headerlink" title="预编译SQL语句，高性能"></a>预编译SQL语句，高性能</h3><p>原来sql执行，要把检查语法和编译sql都交给数据库服务器，<code>?userServerPrepStmts=true</code> 串加到最后的参数后边，默认关闭</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924165716038-1727923816031-15.png" alt="image-20240924165716038"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924165801554-1727923816031-16.png" alt="image-20240924165801554"></p>
<p> 执行两次，只会预编译一次：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924170025388-1727923816032-18.png" alt="image-20240924170025388"></p>
<ul>
<li>PreparedStatement 原理<br>在获取PreparedStatement对象时，将sql语发送给mysqI服务器进行检查，编译(这些步骤很耗时)</li>
<li>执行时就不用再进行这些步骤了，速度更快</li>
<li>如果sql模板一样，则只需要进行一次检查、编译</li>
</ul>
<h2 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h2><p>把查询结果（表）封装起来</p>
<p><code>boolean next()</code> 将光标向下移动一行，判断是否有效</p>
<p><code>int getInt(&quot;id&quot;)</code>获取id列的数据</p>
<p><code>String getString()</code>获取字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(resultset.next())&#123;</span><br><span class="line">    resultset.getInt();</span><br><span class="line">    ... ...</span><br><span class="line"><span class="comment">//可以将查询到的数据封装到自定义类中，然后list存储多个对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环判断游标是否在最后一行的末尾 </span></span><br></pre></td></tr></table></figure>

<h2 id="DataSource-数据库连接池"><a href="#DataSource-数据库连接池" class="headerlink" title="DataSource 数据库连接池"></a>DataSource 数据库连接池</h2><ul>
<li><p>数据库连接池，sun定义的官方接口</p>
</li>
<li><p>connection要调用系统资源，开启关闭都要耗费系统资源。</p>
</li>
<li><p>连接池：资源复用，提升响应速度，避免连接遗漏（连接池资源占满时，如果有新的请求，就会根据一定的算法从已占用资源中空出来一个资源）</p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924170701651-1727923816032-19.png" alt="image-20240924170701651"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924170726525-1727923816031-14.png" alt="image-20240924170726525"></p>
<h3 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924170924469-1727923816031-17.png" alt="image-20240924170924469"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">prop.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;path&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection;</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.getProperty(&quot;user.dir&quot;) 得到当前的相对路径起始点</span></span><br></pre></td></tr></table></figure>

<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>MyBatis：<strong>持久层框架</strong>，可简化JDBC开发</p>
<p><strong>持久层</strong>：数据保存到数据库的一层代码（JavaEE：表现层，业务层，持久层）</p>
<p><strong>框架</strong>：可重用的通用的软件基础代码模型，在框架的基础上构建软件编写更加高效规范</p>
<p>使用XML配置文件进行简化，免除了几乎所有JDBC代码 设置参数 获取结果集，减少硬编码，免除了繁冗步骤。</p>
<p>mybatis-config.xml 记录 JDBC注册连接信息和下方的映射文件</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925145936781.png" alt="image-20240925145936781"></p>
<p>EmployeeMapper.xml 记录映射信息 用session  select 的时候用test.selectAll来执行对应sql语句，<u>resultType是POJO(Plain old java object)的类名（全限定名）</u>  </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925150035852.png" alt="image-20240925150035852"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream); </span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">List&lt;Employee&gt; list = sqlSession.selectList(<span class="string">&quot;test.selectAll&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Mapper-代理"><a href="#Mapper-代理" class="headerlink" title="Mapper 代理"></a>Mapper 代理</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925151447994.png" alt="image-20240925151447994"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925151453517.png" alt="image-20240925151453517"></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>src/main下有java和resources </p>
<p>相对路径：编译之后java下的内容和resources的内容放在同一个classes文件夹下,如果java和resources的目录结构有相同的地方，合并内容。 接口在java文件夹下面新建com.example.mapper 对应的映射文件在resources文件夹下新建com/example/mapper目录放入</p>
<p>对应的，mybatis-config文件中也得修改映射文件的名称。上图所示，可以用包名代替 mapper resource</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925152748288.png" alt="image-20240925152748288"></p>
<p>原来session执行select* 语句调用的是selectList方法，这句话的意思是返回一个表，所以返回值要用List来接，</p>
<p>执行sql语句本质上是调用jdbc的各种api方法，重复性较高，并且有相当数量的硬编码，为了减少硬编码，把参数放入配置文件中，运用了动态代理技术</p>
<h3 id="源码分析（粗浅）"><a href="#源码分析（粗浅）" class="headerlink" title="源码分析（粗浅）"></a>源码分析（粗浅）</h3><p>框架利用java反射机制和动态代理机制，比如上图的select id  = selectAll，重写了mapper的sql方法，并据此生成mapper接口的代理对象                          method.getName == selectAll 执行 sql方法并返回值      </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925155924934.png" alt="image-20240925155924934"></p>
<p>manager的有参构造器，创建了一个代理</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925160215649.png" alt="image-20240925160215649"></p>
<p>InvocationHandler 中 invoke 的 重写 此处代理的是session，替session执行sql语句</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925160058102-1727251872747-1.png" alt="image-20240925160058102"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 处理默认方法（如接口的 `default` 方法）</span></span><br><span class="line">        <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.sqlSession.selectOne(method.getName(), args); <span class="comment">// 根据具体方法执行查询</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="JDK-动态代理的关键点"><a href="#JDK-动态代理的关键点" class="headerlink" title="JDK 动态代理的关键点"></a>JDK 动态代理的关键点</h4><ol>
<li><strong>接口代理</strong>：<ul>
<li>JDK 动态代理只能为实现了接口的类生成代理，因此 MyBatis 的 <code>Mapper</code> 必须是接口。</li>
<li>在运行时生成的代理类实现了 <code>Mapper</code> 接口，并将方法调用委托给 <code>MapperProxy</code>。</li>
</ul>
</li>
<li>**<code>InvocationHandler</code>**：<ul>
<li><code>MapperProxy</code> 作为 <code>InvocationHandler</code>，负责拦截 <code>Mapper</code> 接口的方法调用。</li>
<li><code>invoke</code> 方法中的逻辑决定了如何将接口方法映射到数据库操作。</li>
</ul>
</li>
<li><strong>灵活的 SQL 映射</strong>：<ul>
<li>通过动态代理，MyBatis 可以将 <code>Mapper</code> 接口中的任意方法与对应的 SQL 映射，无需编写具体的实现代码。</li>
</ul>
</li>
</ol>
<h2 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config.xml"></a>mybatis-config.xml</h2><h3 id="environments"><a href="#environments" class="headerlink" title="environments"></a>environments</h3><p>不同的environment对应不同的工作环境，通过default来切换</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925162843370.png" alt="image-20240925162843370"></p>
<p>transaction manage 事务管理 这里是JDBC</p>
<p>datasource  pooled</p>
<p>property xxx 对应数据库的连接信息</p>
<h3 id="mappers"><a href="#mappers" class="headerlink" title="mappers"></a>mappers</h3><p>标注mapper的配置文件的路径或者包名</p>
<h3 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h3><ul>
<li><p><code>&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.Employee&quot; alias=&quot;emp/&gt;</code></p>
<p>为这个类起一个别名emp，不写alias默认是小写employee，这样可以在resultType项用emp来代替全限定名</p>
</li>
<li><p><code>&lt;package name=&quot;com.atguigu.mybatis.bean&quot;/&gt;</code> 对这个包下所有的类起别名，是类本名的小写</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;emp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"><span class="comment">// 类的其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XML配置要遵循如下约束</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925164103152.png" alt="image-20240925164103152"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020124943974.png" alt="image-20241020124943974"></p>
<h2 id="crud"><a href="#crud" class="headerlink" title="crud"></a>crud</h2><p>插件：MyBatisX</p>
<p>三步走：</p>
<ul>
<li>编写Mapper接口 定义抽象方法，注意参数和返回值，还有抽象方法的名字就是 select id，</li>
<li>编写SQL语句：mapper映射文件中的 id resultType sql要齐全</li>
<li>session.getMapper    用 mapper调用</li>
</ul>
<h3 id="实体类字段和数据库名称"><a href="#实体类字段和数据库名称" class="headerlink" title="实体类字段和数据库名称"></a>实体类字段和数据库名称</h3><ul>
<li><p>成员变量名字和数据库字段严格一致</p>
</li>
<li><p>sql语句中，给要查询的列起别名 <code>brand_name as brandName, company_Name as companyName</code></p>
<ul>
<li>每一次都要写一大段，把相同的部分看做<strong>sql片段</strong> 不灵活</li>
<li><code>&lt;sql id=&quot;brand_column&quot;&gt; 相同的部分 &lt;/sql&gt;</code> </li>
<li>sql语句中 select <code>&lt;include refid=&quot;brand_colomn&quot;/&gt;</code> from xxxx</li>
</ul>
</li>
</ul>
<h4 id="最好解决方案：ResultMap"><a href="#最好解决方案：ResultMap" class="headerlink" title="最好解决方案：ResultMap"></a>最好解决方案：ResultMap</h4><ul>
<li><p>定义<code>resultMap</code>标签</p>
</li>
<li><p>把<code>resultType</code>改成<code>resultMap</code> 结果 column行对应的是数据库里的别名 property对应的是pojo的属性 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925175306144.png" alt="image-20240925175306144"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;SELECT id, name, email FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Results(id = &quot;userResultMap&quot;, value = &#123;</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;id&quot;, column = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;name&quot;, column = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;email&quot;, column = &quot;email&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM users&quot;)</span></span><br><span class="line">    <span class="meta">@ResultMap(&quot;userResultMap&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">getAllUsers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//select注解开发，Results注解映射结果，给自己起名userResultMap</span></span><br><span class="line"><span class="comment">//getAllUsers方法就可用ResultMap注解来映射返回值</span></span><br></pre></td></tr></table></figure>

<h3 id="参数占位符"><a href="#参数占位符" class="headerlink" title="参数占位符"></a>参数占位符</h3><p>定义抽象方法selectById(int id) 假如这里定义形参名id，返回值是实体类Brand，sql语句用 where 修饰，<code>where id = #&#123;id&#125; </code> 形参名字用大括号加井号括起来</p>
<p>${id} -&gt;     直接拼接字符串，不能防止<a href="">SQL注入</a></p>
<p>#{id} -&gt; ?  占位符，能将内容转义，防止sql注入</p>
<p>preparedstatement执行，#{id} 会将id视为参数，接收以后把参数填补进去</p>
<p>#{}表名或者列名不固定</p>
<p>parameterType可以省略</p>
<h4 id="特殊字符处理"><a href="#特殊字符处理" class="headerlink" title="特殊字符处理"></a>特殊字符处理</h4><ul>
<li>转义字符 &amp;amp;  &amp;gt;  &amp;lt;  双引号 &amp;quot; 单引号 &amp;apos;</li>
<li><code>&lt;![CDATA[ &lt; ]]&gt;</code> </li>
</ul>
<h3 id="模糊查询-分页查询"><a href="#模糊查询-分页查询" class="headerlink" title="模糊查询 分页查询"></a>模糊查询 分页查询</h3><p>补充见[webfu服务端](Java Web 服务端.md)-其他细节</p>
<h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询<select></select></h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925182248759.png" alt="image-20240925182248759"></p>
<h4 id="参数接收"><a href="#参数接收" class="headerlink" title="参数接收"></a>参数接收</h4><p>模糊条件查询</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925184318146.png" alt="image-20240925184318146"></p>
<ol>
<li>散装参数，多个参数需要加@Param注解 后面要和sql语句占位符一样，最好是pojo类的属性名称</li>
<li>对象参数：对象的属性名称要和参数占位符名称一致</li>
<li>map参数：创建一个map，里面键是sql语句的占位符，值是对象的属性名成员变量</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(<span class="string">&quot;status&quot;</span>,status);</span><br><span class="line">map.put(<span class="string">&quot;companyName&quot;</span>,companyName);</span><br><span class="line">map.put(<span class="string">&quot;brandName&quot;</span>,brandName);</span><br></pre></td></tr></table></figure>

<p>传参数进来就是一个填字游戏详见下方的param注解</p>
<h4 id="多条件-动态条件查询-if"><a href="#多条件-动态条件查询-if" class="headerlink" title="多条件 动态条件查询 if"></a>多条件 动态条件查询 if</h4><p>用户查询可能不会把条件全部填满：动态SQL</p>
<h5 id="if-条件判断"><a href="#if-条件判断" class="headerlink" title="if 条件判断"></a>if 条件判断</h5><p>test：逻辑表达式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925184740473.png" alt="image-20240925184740473"></p>
<p><code>&lt;if test = &quot;companyName != null and companyName != &#39; &#39; &quot;&gt;</code> sql条件字段  有选择地拼接</p>
<p>如果map中不包含brandname或者brandname是空的，mybatis 就不会把那一部分拼接到sql语句中，由于是直接拼接，所以不可避免会出现格式问题, 第一个条件不需要逻辑运算符。</p>
<p>if条件后的test 后面是参数的键名</p>
<ul>
<li>可以在条件前面加个and 再用恒等式 缓冲一下</li>
<li><em>where</em> 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，<em>where</em> 元素也会将它们去除。where标签，里面加上判断标签，判断标签里面用and开头 ，如果只有一个判断标签有效，还会自动去掉and<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925185741878.png" alt="image-20240925185741878"></li>
</ul>
<h4 id="单条件动态查询-choose"><a href="#单条件动态查询-choose" class="headerlink" title="单条件动态查询 choose"></a>单条件动态查询 choose</h4><p>还有 choose(when otherwise) 类似 switch-case </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925190242016.png" alt="image-20240925190242016"></p>
<p>用户输入完就是给对象赋值，可能有些字段是空的，这会导致不能正确解析，出现where后面空的情况，此时otherwise标签里要有一个默认保底的查询方法</p>
<p>另外，where标签也可以代替otherwise的功能，如果检测到语法错误他会自动删除where </p>
<p>where标签注意事项</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925192533201.png" alt="image-20240925192533201"></p>
<p>trim(where set) foreach</p>
<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p><code>&lt;insert&gt;&lt;/insert&gt;</code></p>
<p>autocommit 默认 false </p>
<p><code>sqlSession.commit()</code> 提交事务</p>
<p><code>sqlSessionFactory.openSession(true)</code></p>
<h4 id="主键返回"><a href="#主键返回" class="headerlink" title="主键返回"></a>主键返回</h4><p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925221746219.png" alt="image-20240925221746219"></p>
<p><code>&lt;insert&gt; id=&quot;addOrder&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot; &lt;/insert&gt;</code></p>
<p>自动设置主键id的值，即使对象的id没有设定，也能自动设置其ID</p>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p><code>&lt;update&gt;&lt;/update&gt;</code> </p>
<h4 id="修改全部字段"><a href="#修改全部字段" class="headerlink" title="修改全部字段"></a>修改全部字段</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925225339176.png" alt="image-20240925225339176"></p>
<h4 id="动态修改字段"><a href="#动态修改字段" class="headerlink" title="动态修改字段"></a>动态修改字段</h4><p><code>&lt;set&gt;</code>关键字</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925225816604.png" alt="image-20240925225816604"></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>&lt;delete&gt;</code> 关键字</p>
<h4 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h4><p>复选框删除 根据ID数组 批量删除 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925230216448.png" alt="image-20240925230216448"></p>
<p>foreach能遍历collection或者array，item是给每个元素起的名字，sep分隔符，open close分别代表起始符号和结束符号, ids是数组参数的param注解，如果没有param注解，就要用array</p>
<h3 id="Param-注解"><a href="#Param-注解" class="headerlink" title="@Param 注解"></a>@Param 注解</h3><p><a href="https://blog.51cto.com/u_12393361/5021343">解决mybatis不加@Param报错 org.apache.ibatis.binding.BindingException_51CTO博客_mybatis @Param</a></p>
<p>对于参数，mybatis先使用map集合进行封装，每个参数都有对应的键名，解析sql语句时，遇到占位符就用值填充键的对应位置，或者在<strong>if标签的test</strong>、<strong>foreach的collection标签</strong> 中  用键名来代指参数。如果不使用参数注解，map会为参数生成默认的键，@Param注解用来代替map默认的键arg0, (param1还能用)</p>
<p>(-parameters可以生成元数据用于方法参数的反射，<strong>JDK8起</strong>在反射包中引入了java.lang.reflect.Parameter 来获取参数相关的信息。IDE编译时自动加了参数 -parameters，所以能把方法参数名给解析出来作为key)</p>
<ul>
<li>对于一个基本类型参数，没有指定param，随便都可以, 加了注解就只能用param1和注解的别名</li>
</ul>
<ul>
<li><p>对于多个基本类型参数，如果没有指定param，mybatis底层会自动给予param1+arg0键，param2+arg1键，占位符需要用param1（arg0）和param2（arg1）‘’。IDE会优化，参数的键就变成自己的形参名，但如果形参的名字变化，没有注解，而且对应的占位符没有及时更新，就会出现异常</p>
</li>
<li><p>对于POJO对象类型参数，mybatis底层会给予对象字段键名，键名就是自己的字段名称，只需要保证字段名能和占位符一一对应。<strong>不需要</strong>使用param注解</p>
</li>
<li><p>对于map类参数，<strong>直接使用不需要</strong>注解，只要保证map中键名能和占位符一一对应即可。</p>
</li>
<li><p>对于collection类参数，至少会有arg0和colleciton两个键 ，对于list还会多一个list。key:”list”  value: userList</p>
<ul>
<li>对于数组类参数，至少会有array和arg0键名</li>
</ul>
</li>
</ul>
<p>为了映射结果一致，最好参数全部使用param进行注解，便于后期维护</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul>
<li><p>如果map集合中存储一个user对象(key=”user”)和address对象(key=”address”)，但是在sql语句中要使用他们的字段，占位符应该用user.id user.name进行引用。另外一个user对象(key=”user2”)就需要用user2.name 进行引用。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; paramMap = new HashMap<span class="tag">&lt;&gt;</span>();</span><br><span class="line">paramMap.put(&quot;user&quot;, user);</span><br><span class="line">paramMap.put(&quot;address&quot;, address);</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUserWithAddress&quot;</span>&gt;</span></span><br><span class="line">    INSERT INTO tb_user (id, name, email, address)</span><br><span class="line">    VALUES (#&#123;user.id&#125;, #&#123;user.name&#125;, #&#123;user.email&#125;, #&#123;address.street&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果是collection存储user对象，就要用foreach遍历，item 如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUsers&quot;</span>&gt;</span></span><br><span class="line">    INSERT INTO tb_user (id, name, email)</span><br><span class="line">    VALUES</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;users&quot;</span> <span class="attr">item</span>=<span class="string">&quot;user&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        (#&#123;user.id&#125;, #&#123;user.name&#125;, #&#123;user.email&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>总结：对象map传进来不需要遍历，mybatis会根据对象对应的键找值，用<code>.</code>进行字段引用；对象collection和array需要遍历</p>
</li>
</ul>
<h3 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926100629592.png" alt="image-20240926100629592"></p>
<p><a href="https://blog.csdn.net/weixin_43883917/article/details/113830667">Mybatis注解开发（超详细）-CSDN博客</a></p>
]]></content>
      <categories>
        <category>web development</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>jdbc</tag>
        <tag>xml</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>认真的 Netty 源码解析（一）(转自JavaDoop)</title>
    <url>/2018/11/03/netty-1/</url>
    <content><![CDATA[<p>本文又是一篇源码分析文章，其实除了 Doug Lea 的并发包源码，我是真不太爱写源码分析。因为要花非常多的时间，而且很多地方需要反复组织语言。</p>
<p>本文将介绍 Netty，Java 平台上使用最广泛的 NIO 包，它是对 JDK 中的 NIO 实现的一层封装，让我们能更方便地开发 NIO 程序。其实，Netty 不仅仅是 NIO 吧，但是，基本上大家都冲着 NIO 来的。</p>
<p>个人感觉国内对于 Netty 的吹嘘是有点过了，主要是很多人靠它吃饭，要么是搞培训的，要么是出书的，恨不得把 Netty 吹上天去，这种现象也是挺不好的，反而使得初学者觉得 Netty 是什么高深的技术一样。</p>
<p>Netty 的源码不是很简单，因为它比较多，而且各个类之间的关系错综复杂，很多人说它的源码很好，这点我觉得一般，真要说好代码，还得 Doug Lea 的并发源码比较漂亮，一行行都是精华，不过它们是不同类型的，也没什么好对比的。Netty 源码好就好在它的接口使用比较灵活，往往接口好用的框架，源码都不会太简单。</p>
<p>本文将立足于源码分析，所以读者需要先掌握 NIO 的基础知识，至少我之前写的 <a href="/post/java-nio">《Java NIO：Buffer、Channel 和 Selector》</a> 中介绍的基础知识要清楚，如果读者已经对 Netty 有些了解，或者使用过，那就更好了。</p>
<ul>
<li>本文只介绍 TCP 相关的内容，Netty 对于其他协议的支持，不在本文的讨论范围内。</li>
<li>和并发包的源码分析不一样，我不可能一行一行源码说，所以有些异常分支是会直接略过，除非我觉得需要介绍。</li>
<li>Netty 源码一直在更新，各版本之间有些差异，我是按照 2018-09-06 的最新版本 <strong>4.1.25.Final</strong> 来进行介绍的。</li>
</ul>
<p>建议初学者在看完本文以后，可以去翻翻《Netty In Action》，网上也可以找到中文文字版的。</p>
<!-- toc -->

<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>学习源码，一开始肯定是准备环境。</p>
<p>我喜欢用 maven，也喜欢 Spring Boot，所以我一般先到 <a href="https://start.spring.io/">https://start.spring.io/</a> 准备一个最简单的脚手架。</p>
<p>10 秒搞定脚手架，然后就是导入到 Intellij 中，如果用新版本的 Spring Boot，可能还需要等待下载依赖，期间打开 <a href="https://mvnrepository.com/">https://mvnrepository.com/</a> 搜索马上要用到的 maven 依赖。</p>
<p>Netty 分为好些模块，有 <a href="https://mvnrepository.com/artifact/io.netty/netty-handler">netty-handler</a>、<a href="https://mvnrepository.com/artifact/io.netty/netty-buffer">netty-buffer</a>、<a href="https://mvnrepository.com/artifact/io.netty/netty-transport">netty-transport</a>、<a href="https://mvnrepository.com/artifact/io.netty/netty-common">netty-common</a> 等等，也有一个 <a href="https://mvnrepository.com/artifact/io.netty/netty-all">netty-all</a>，它包含了所有的模块。</p>
<p>既然我们是源码分析，那么自然是用一个最简单的。netty-all 不是最好的选择，netty-example 才是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-example<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.25.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>它不仅可以解决我们的依赖，而且 example 里面的示例非常适合我们学习使用。</p>
<h2 id="Echo-例子"><a href="#Echo-例子" class="headerlink" title="Echo 例子"></a>Echo 例子</h2><p>Netty 作为 NIO 的库，自然既可以作为服务端接受请求，也可以作为客户端发起请求。使用 Netty 开发客户端或服务端都是非常简单的，Netty 做了很好的封装，我们通常只要开发一个或多个 <strong>handler</strong> 用来处理我们的自定义逻辑就可以了。</p>
<p>下面，我们来看一个经常会见到的例子，它叫 <strong>Echo</strong>，也就是<strong>回声</strong>，客户端传过去什么值，服务端原样返回什么值。</p>
<blockquote>
<p>打开 netty-example 的源码，把 <code>echo</code> 包下面的代码复制出来玩一玩。</p>
</blockquote>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/5.png" alt="5"></p>
<blockquote>
<p>左边是服务端代码，右边是客户端代码。</p>
</blockquote>
<p>上面的代码基本就是模板代码，每次使用都是这一个套路，唯一需要我们开发的部分是 handler(…) 和 childHandler(…) 方法中指定的各个 handler，如 <strong>EchoServerHandler</strong> 和 <strong>EchoClientHandler</strong>，当然 Netty 源码也给我们提供了很多的 handler，比如上面的 LoggingHandler，它就是 Netty 源码中为我们提供的，需要的时候直接拿过来用就好了。</p>
<p>我们先来看一下上述代码中涉及到的一些内容：</p>
<ul>
<li><p>ServerBootstrap 类用于创建服务端实例，Bootstrap 用于创建客户端实例。</p>
</li>
<li><p>两个 EventLoopGroup：bossGroup 和 workerGroup，它们涉及的是 Netty 的线程模型，可以看到服务端有两个 group，而客户端只有一个，它们就是 Netty 中的线程池。</p>
</li>
<li><p>Netty 中的 Channel，没有直接使用 Java 原生的 ServerSocketChannel 和 SocketChannel，而是包装了 NioServerSocketChannel 和 NioSocketChannel 与之对应。</p>
<blockquote>
<p>当然，也有对其他协议的支持，如支持 UDP 协议的 NioDatagramChannel，本文只关心 TCP 相关的。</p>
</blockquote>
</li>
<li><p>左边 handler(…) 方法指定了一个 handler（LoggingHandler），这个 handler 是给服务端收到新的请求的时候处理用的。右边 handler(…) 方法指定了客户端处理请求过程中需要使用的 handlers。</p>
<blockquote>
<p>如果你想在 EchoServer 中也指定多个 handler，也可以像右边的 EchoClient 一样使用 ChannelInitializer</p>
</blockquote>
</li>
<li><p>左边 childHandler(…) 指定了 childHandler，这边的 handlers 是给新创建的连接用的，我们知道服务端 ServerSocketChannel 在 accept 一个连接以后，需要创建 SocketChannel 的实例，childHandler(…) 中设置的 handler 就是用于处理新创建的 SocketChannel 的，而不是用来处理 ServerSocketChannel 实例的。</p>
</li>
<li><p>pipeline：handler 可以指定多个（需要上面的 ChannelInitializer 类辅助），它们会组成了一个 pipeline，它们其实就类似拦截器的概念，现在只要记住一点，每个 NioSocketChannel 或 NioServerSocketChannel 实例内部都会有一个 pipeline 实例。pipeline 中还涉及到 handler 的执行顺序。</p>
</li>
<li><p>ChannelFuture：这个涉及到 Netty 中的异步编程，和 JDK 中的 Future 接口类似。</p>
</li>
</ul>
<p>对于不了解 Netty 的读者，也不要有什么压力，我会一一介绍它们，本文主要面向新手，我觉得比较难理解或比较重要的部分，会花比较大的篇幅来介绍清楚。</p>
<p>上面的源码中没有展示消息发送和消息接收的处理，此部分我会在介绍完上面的这些内容以后再进行介绍。</p>
<p>下面，将分块来介绍这些内容。鉴于读者对 NIO 或 Netty 的了解程度可能参差不齐，为了照顾初学者，很多地方需要啰嗦一些，所以希望读者一节一节往下看，对于自己熟悉的内容可以适当看快一些。</p>
<h2 id="Netty-中的-Channel"><a href="#Netty-中的-Channel" class="headerlink" title="Netty 中的 Channel"></a>Netty 中的 Channel</h2><p>这节我们来看看 NioSocketChannel 是怎么和 JDK 底层的 SocketChannel 联系在一起的，它们是一对一的关系。NioServerSocketChannel 和 ServerSocketChannel 同理，也是一对一的关系。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/3.png" alt="3"></p>
<p>在 Bootstrap（客户端） 和 ServerBootstrap（服务端） 的启动过程中都会调用 channel(…) 方法：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/10.png" alt="10"></p>
<p>下面，我们来看 channel(…) 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractBootstrap</span></span><br><span class="line"><span class="keyword">public</span> B <span class="title function_">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (channelClass == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;channelClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> <span class="title class_">ReflectiveChannelFactory</span>&lt;C&gt;(channelClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这个方法只是设置了 channelFactory 为 ReflectiveChannelFactory 的一个实例，然后我们看下这里的 ReflectiveChannelFactory 到底是什么：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/1.png" alt="1"></p>
<p><strong>newChannel()</strong> 方法是 ChannelFactory 接口中的唯一方法，<strong>工厂模式</strong>大家都很熟悉。我们可以看到，<code>ReflectiveChannelFactory#newChannel()</code> 方法中使用了反射调用 Channel 的无参构造方法来创建 Channel，我们只要知道，ChannelFactory 的 newChannel() 方法什么时候会被调用就可以了。</p>
<ul>
<li>对于 NioSocketChannel，由于它充当客户端的功能，它的创建时机在 <code>connect(…)</code> 的时候；</li>
<li>对于 NioServerSocketChannel 来说，它充当服务端功能，它的创建时机在绑定端口 <code>bind(…)</code> 的时候。</li>
</ul>
<p>接下来，我们来简单追踪下充当客户端的 Bootstrap 中 NioSocketChannel 的创建过程，看看 NioSocketChannel 是怎么和 JDK 中的 SocketChannel 关联在一起的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bootstrap</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">connect</span><span class="params">(String inetHost, <span class="type">int</span> inetPort)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> connect(InetSocketAddress.createUnresolved(inetHost, inetPort));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再往里看，到这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">connect</span><span class="params">(SocketAddress remoteAddress)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (remoteAddress == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;remoteAddress&quot;</span>);</span><br><span class="line">    <span class="comment">// validate 只是校验一下各个参数是不是正确设置了</span></span><br><span class="line">    validate();</span><br><span class="line">    <span class="keyword">return</span> doResolveAndConnect(remoteAddress, config.localAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 再往里就到这里了</span></span><br><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">doResolveAndConnect</span><span class="params">(<span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class="line">    <span class="comment">// 我们要说的部分在这里</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> regFuture.channel();</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们看 <code>initAndRegister()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 前面我们说过，这里会进行 Channel 的实例化</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们找到了 <code>channel = channelFactory.newChannel()</code> 这行代码，根据前面说的，这里会调用相应 Channel 的无参构造方法。</p>
<p>然后我们就可以去看 NioSocketChannel 的构造方法了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioSocketChannel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// SelectorProvider 实例用于创建 JDK 的 SocketChannel 实例</span></span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_SELECTOR_PROVIDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioSocketChannel</span><span class="params">(SelectorProvider provider)</span> &#123;</span><br><span class="line">    <span class="comment">// 看这里，newSocket(provider) 方法会创建 JDK 的 SocketChannel</span></span><br><span class="line">    <span class="built_in">this</span>(newSocket(provider));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在调用 newSocket(provider) 的时候，会创建 JDK NIO 的一个 SocketChannel 实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SocketChannel <span class="title function_">newSocket</span><span class="params">(SelectorProvider provider)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 SocketChannel 实例</span></span><br><span class="line">        <span class="keyword">return</span> provider.openSocketChannel();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ChannelException</span>(<span class="string">&quot;Failed to open a socket.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NioServerSocketChannel 同理，也非常简单，从 <code>ServerBootstrap#bind(...)</code> 方法一路点进去就清楚了。</p>
<p>所以我们知道了，NioSocketChannel 在实例化过程中，会先实例化 JDK 底层的 SocketChannel，NioServerSocketChannel 也一样，会先实例化 ServerSocketChannel 实例：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/18.png" alt="18"></p>
<p>说到这里，我们顺便再继续往里看一下 NioSocketChannel 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioSocketChannel</span><span class="params">(SelectorProvider provider)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(newSocket(provider));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚才我们看到这里，newSocket(provider) 创建了底层的 SocketChannel 实例，我们继续往下看构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioSocketChannel</span><span class="params">(Channel parent, SocketChannel socket)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent, socket);</span><br><span class="line">    config = <span class="keyword">new</span> <span class="title class_">NioSocketChannelConfig</span>(<span class="built_in">this</span>, socket.socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面有两行代码，第二行代码很简单，实例化了内部的 NioSocketChannelConfig 实例，它用于保存 channel 的配置信息，这里没有我们现在需要关心的内容，直接跳过。</p>
<p>第一行调用父类构造器，除了设置属性外，还设置了 SocketChannel 的非阻塞模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractNioByteChannel</span><span class="params">(Channel parent, SelectableChannel ch)</span> &#123;</span><br><span class="line">    <span class="comment">// 毫无疑问，客户端关心的是 OP_READ 事件，等待读取服务端返回数据</span></span><br><span class="line">    <span class="built_in">super</span>(parent, ch, SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后是到这里</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="type">int</span> readInterestOp)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">    <span class="built_in">this</span>.ch = ch;</span><br><span class="line">    <span class="comment">// 我们看到这里只是保存了 SelectionKey.OP_READ 这个信息，在后面的时候会用到</span></span><br><span class="line">    <span class="built_in">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ******设置 channel 的非阻塞模式******</span></span><br><span class="line">        ch.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NioServerSocketChannel 的构造方法类似，也设置了非阻塞，然后设置服务端关心的 SelectionKey.OP_ACCEPT 事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> &#123;</span><br><span class="line">    <span class="comment">// 对于服务端来说，关心的是 SelectionKey.OP_ACCEPT 事件，等待客户端连接</span></span><br><span class="line">    <span class="built_in">super</span>(<span class="literal">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    config = <span class="keyword">new</span> <span class="title class_">NioServerSocketChannelConfig</span>(<span class="built_in">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这节关于 Channel 的内容我们先介绍这么多，主要就是实例化了 JDK 层的 SocketChannel 或 ServerSocketChannel，然后设置了非阻塞模式，我们后面再继续深入下去。</p>
<h2 id="Netty-中的-Future、Promise"><a href="#Netty-中的-Future、Promise" class="headerlink" title="Netty 中的 Future、Promise"></a>Netty 中的 Future、Promise</h2><p>Netty 中非常多的异步调用，所以在介绍更多 NIO 相关的内容之前，我们来看看它的异步接口是怎么使用的。</p>
<p>前面我们在介绍 Echo 例子的时候，已经用过了 ChannelFuture 这个接口了：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/6.png" alt="6"></p>
<p>争取在看完本节后，读者能搞清楚上面的这几行划线部分是怎么走的。</p>
<p>关于 Future 接口，我想大家应该都很熟悉，用得最多的就是在使用 Java 的线程池 ThreadPoolExecutor 的时候了。在 <strong>submit</strong> 一个任务到线程池中的时候，返回的就是一个 <strong>Future</strong> 实例，通过它来获取提交的任务的执行状态和最终的执行结果，我们最常用它的 <code>isDone()</code> 和 <code>get()</code> 方法。</p>
<p>下面是 JDK  中的 Future 接口 java.util.concurrent.Future：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">	<span class="comment">// 取消该任务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="comment">// 任务是否已取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">// 任务是否已完成</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 阻塞获取任务执行结果</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    <span class="comment">// 带超时参数的获取任务执行结果</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Netty 中的 Future 接口（同名）继承了 JDK 中的 Future 接口，然后添加了一些方法：</p>
<p>// io.netty.util.concurrent.Future</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">java</span>.util.concurrent.Future&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSuccess</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 是否可取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancellable</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果任务执行失败，这个方法返回异常信息</span></span><br><span class="line">    Throwable <span class="title function_">cause</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 Listener 来进行回调</span></span><br><span class="line">    Future&lt;V&gt; <span class="title function_">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt; listener)</span>;</span><br><span class="line">    Future&lt;V&gt; <span class="title function_">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt;... listeners)</span>;</span><br><span class="line"></span><br><span class="line">    Future&lt;V&gt; <span class="title function_">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt; listener)</span>;</span><br><span class="line">    Future&lt;V&gt; <span class="title function_">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt;... listeners)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待任务结束，如果任务失败，将“导致失败的异常”重新抛出来</span></span><br><span class="line">    Future&lt;V&gt; <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="comment">// 不响应中断的 sync()，这个大家应该都很熟了</span></span><br><span class="line">    Future&lt;V&gt; <span class="title function_">syncUninterruptibly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待任务结束，和 sync() 功能是一样的，不过如果任务失败，它不会抛出执行过程中的异常</span></span><br><span class="line">    Future&lt;V&gt; <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    Future&lt;V&gt; <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeoutMillis)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitUninterruptibly</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitUninterruptibly</span><span class="params">(<span class="type">long</span> timeoutMillis)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取执行结果，不阻塞。我们都知道 java.util.concurrent.Future 中的 get() 是阻塞的</span></span><br><span class="line">    V <span class="title function_">getNow</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消任务执行，如果取消成功，任务会因为 CancellationException 异常而导致失败</span></span><br><span class="line">    <span class="comment">//	  也就是 isSuccess()==false，同时上面的 cause() 方法返回 CancellationException 的实例。</span></span><br><span class="line">    <span class="comment">// mayInterruptIfRunning 说的是：是否对正在执行该任务的线程进行中断(这样才能停止该任务的执行)，</span></span><br><span class="line">    <span class="comment">// 	  似乎 Netty 中 Future 接口的各个实现类，都没有使用这个参数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完上面的 Netty 的 Future 接口，我们可以发现，它加了 sync() 和 await() 用于阻塞等待，还加了 Listeners，只要任务结束去回调 Listener 们就可以了，那么我们就不一定要主动调用 isDone() 来获取状态，或通过 get() 阻塞方法来获取值。</p>
<blockquote>
<p>所以它其实有两种使用范式</p>
</blockquote>
<p>顺便说下 sync() 和 await() 的区别：sync() 内部会先调用 await() 方法，等 await() 方法返回后，会检查下<strong>这个任务是否失败</strong>，如果失败，重新将导致失败的异常抛出来。也就是说，如果使用 await()，任务抛出异常后，await() 方法会返回，但是不会抛出异常，而 sync() 方法返回的同时会抛出异常。</p>
<blockquote>
<p>我们也可以看到，Future 接口没有和 IO 操作关联在一起，还是比较<em>纯净</em>的接口。</p>
</blockquote>
<p>接下来，我们来看 Future 接口的子接口 ChannelFuture，这个接口用得最多，它将和 IO 操作中的 Channel 关联在一起了，用于异步处理 Channel 中的事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChannelFuture</span> <span class="keyword">extends</span> <span class="title class_">Future</span>&lt;Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ChannelFuture 关联的 Channel</span></span><br><span class="line">    Channel <span class="title function_">channel</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆写以下几个方法，使得它们返回值为 ChannelFuture 类型 </span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt; listener)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt;... listeners)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt; listener)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt;... listeners)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">syncUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来标记该 future 是 void 的，</span></span><br><span class="line">    <span class="comment">// 这样就不允许使用 addListener(...), sync(), await() 以及它们的几个重载方法</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isVoid</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，ChannelFuture 接口相对于 Future 接口，除了将 channel 关联进来，没有增加什么东西。还有个 isVoid() 方法算是不那么重要的存在吧。其他几个都是方法覆写，为了让返回值类型变为 ChannelFuture，而不是原来的 Future。</p>
<p>这里有点跳，我们来介绍下 Promise 接口，它和 ChannelFuture 接口无关，而是和前面的 Future 接口相关，Promise 这个接口非常重要。</p>
<p>Promise 接口和 ChannelFuture 一样，也继承了 Netty 的 Future 接口，然后加了一些 Promise 的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Promise</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记该 future 成功及设置其执行结果，并且会通知所有的 listeners。</span></span><br><span class="line">    <span class="comment">// 如果该操作失败，将抛出异常(失败指的是该 future 已经有了结果了，成功的结果，或者失败的结果)</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">setSuccess</span><span class="params">(V result)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和 setSuccess 方法一样，只不过如果失败，它不抛异常，返回 false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">trySuccess</span><span class="params">(V result)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记该 future 失败，及其失败原因。</span></span><br><span class="line">    <span class="comment">// 如果失败，将抛出异常(失败指的是已经有了结果了)</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">setFailure</span><span class="params">(Throwable cause)</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 标记该 future 失败，及其失败原因。</span></span><br><span class="line">    <span class="comment">// 如果已经有结果，返回 false，不抛出异常</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryFailure</span><span class="params">(Throwable cause)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记该 future 不可以被取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">setUncancellable</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里和 ChannelFuture 一样，对这几个方法进行覆写，目的是为了返回 Promise 类型的实例</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt; listener)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt;... listeners)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt; listener)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt;... listeners)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">syncUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能有些读者对 Promise 的概念不是很熟悉，这里简单说两句。</p>
<p>我觉得只要明白一点，Promise 实例内部是一个任务，任务的执行往往是异步的，通常是一个线程池来处理任务。Promise 提供的 setSuccess(V result) 或 setFailure(Throwable t) 将来会被某个执行任务的线程在执行完成以后调用，同时那个线程在调用 setSuccess(result) 或 setFailure(t) 后会回调 listeners 的回调函数（当然，回调的具体内容不一定要由执行任务的线程自己来执行，它可以创建新的线程来执行，也可以将回调任务提交到某个线程池来执行）。而且，一旦 setSuccess(…) 或 setFailure(…) 后，那些 await() 或 sync() 的线程就会从等待中返回。</p>
<p><strong>所以这里就有两种编程方式，一种是用 await()，等 await() 方法返回后，得到 promise 的执行结果，然后处理它；另一种就是提供 Listener 实例，我们不太关心任务什么时候会执行完，只要它执行完了以后会去执行 listener 中的处理方法就行。</strong></p>
<p>接下来，我们再来看下 <strong>ChannelPromise</strong>，它继承了前面介绍的 ChannelFuture 和 Promise 接口。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/4.png" alt="4"></p>
<p>ChannelPromise 接口在 Netty 中使用得比较多，因为它综合了 ChannelFuture 和 Promise 两个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Special &#123;<span class="doctag">@link</span> ChannelFuture&#125; which is writable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChannelPromise</span> <span class="keyword">extends</span> <span class="title class_">ChannelFuture</span>, Promise&lt;Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆写 ChannelFuture 中的 channel() 方法，其实这个方法一点没变</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Channel <span class="title function_">channel</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面几个方法是覆写 Promise 中的接口，为了返回值类型是 ChannelPromise</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">setSuccess</span><span class="params">(Void result)</span>;</span><br><span class="line">    ChannelPromise <span class="title function_">setSuccess</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">trySuccess</span><span class="params">()</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">setFailure</span><span class="params">(Throwable cause)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里大家应该都熟悉了，下面几个方法的覆写也是为了得到 ChannelPromise 类型的实例</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt; listener)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt;... listeners)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt; listener)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt;... listeners)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">syncUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a new &#123;<span class="doctag">@link</span> ChannelPromise&#125; if &#123;<span class="doctag">@link</span> #isVoid()&#125; returns &#123;<span class="doctag">@code</span> true&#125; otherwise itself.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 我们忽略这个方法吧。</span></span><br><span class="line">    ChannelPromise <span class="title function_">unvoid</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，它综合了 ChannelFuture 和 Promise 中的方法，只不过通过覆写将返回值都变为 ChannelPromise 了而已，<strong>没有增加什么新的功能</strong>。</p>
<p>小结一下，我们上面介绍了几个接口，Future 以及它的子接口 ChannelFuture 和 Promise，然后是 ChannelPromise 接口同时继承了 ChannelFuture 和 Promise。</p>
<p>我把这几个接口的主要方法列在一起，这样大家看得清晰些：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/7.png" alt="4"></p>
<p>接下来，我们需要来一个实现类，这样才能比较直观地看出它们是怎么使用的，因为上面的这些都是接口定义，具体还得看实现类是怎么工作的。</p>
<p>下面，我们来介绍下 <strong>DefaultPromise</strong> 这个实现类，这个类很常用，它的源码也不短，我们先介绍几个关键的内容，然后介绍一个示例使用。</p>
<p>首先，我们看下它有哪些属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultPromise</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractFuture</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">Promise</span>&lt;V&gt; &#123;</span><br><span class="line">	  <span class="comment">// 保存执行结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Object result;</span><br><span class="line">    <span class="comment">// 执行任务的线程池，promise 持有 executor 的引用，这个其实有点奇怪了</span></span><br><span class="line">    <span class="comment">// 因为“任务”其实没必要知道自己在哪里被执行的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor executor;</span><br><span class="line">	  <span class="comment">// 监听者，回调函数，任务结束后（正常或异常结束）执行</span></span><br><span class="line">    <span class="keyword">private</span> Object listeners;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待这个 promise 的线程数(调用sync()/await()进行等待的线程数量)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">short</span> waiters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否正在唤醒等待线程，用于防止重复执行唤醒，不然会重复执行 listeners 的回调方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> notifyingListeners;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看出，此类实现了 Promise，但是没有实现 ChannelFuture，所以它和 Channel 联系不起来。</p>
<p>别急，我们后面会碰到另一个类 DefaultChannelPromise 的使用，这个类是综合了 ChannelFuture 和 Promise 的，但是它的实现其实大部分都是继承自这里的 DefaultPromise 类的。</p>
</blockquote>
<p>说完上面的属性以后，大家可以看下 <code>setSuccess(V result)</code> 、<code>trySuccess(V result)</code> 和 <code>setFailure(Throwable cause)</code> 、 <code>tryFailure(Throwable cause)</code> 这几个方法：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/8.png" alt="8"></p>
<blockquote>
<p>看出 setSuccess(result) 和 trySuccess(result) 的区别了吗？</p>
</blockquote>
<p>上面几个方法都非常简单，先设置好值，然后执行监听者们的回调方法。notifyListeners() 方法感兴趣的读者也可以看一看，不过它还涉及到 Netty 线程池的一些内容，我们还没有介绍到线程池，这里就不展开了。上面的代码，在 setSuccess0 或 setFailure0 方法中都会唤醒阻塞在 sync() 或 await() 的线程</p>
<p>另外，就是可以看下 sync() 和 await() 的区别，其他的我觉得随便看看就好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    await();</span><br><span class="line">    <span class="comment">// 如果任务是失败的，重新抛出相应的异常</span></span><br><span class="line">    rethrowIfFailed();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们来写个实例代码吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造线程池</span></span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventExecutor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 DefaultPromise 实例</span></span><br><span class="line">    <span class="type">Promise</span> <span class="variable">promise</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>(executor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面给这个 promise 添加两个 listener</span></span><br><span class="line">    promise.addListener(<span class="keyword">new</span> <span class="title class_">GenericFutureListener</span>&lt;Future&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务结束，结果：&quot;</span> + future.get());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务失败，异常：&quot;</span> + future.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).addListener(<span class="keyword">new</span> <span class="title class_">GenericFutureListener</span>&lt;Future&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务结束，balabala...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务到线程池，五秒后执行结束，设置执行 promise 的结果</span></span><br><span class="line">    executor.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置 promise 的结果</span></span><br><span class="line">            <span class="comment">// promise.setFailure(new RuntimeException());</span></span><br><span class="line">            promise.setSuccess(<span class="number">123456</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main 线程阻塞等待执行结果</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        promise.sync();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码，两个 listener 将在 5 秒后将输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">任务结束，结果：123456</span><br><span class="line">任务结束，balabala...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>读者这里可以试一下 sync() 和 await() 的区别，在任务中调用 promise.setFailure(new RuntimeException()) 试试看。</p>
</blockquote>
<p>上面的代码中，大家可能会对线程池 executor 和 promise 之间的关系感到有点迷惑。读者应该也要清楚，具体的任务不一定就要在这个 executor 中被执行。任务结束以后，需要调用 promise.setSuccess(result) 作为通知。</p>
<p>通常来说，promise 代表的 future 是不需要和线程池搅在一起的，future 只关心任务是否结束以及任务的执行结果，至于是哪个线程或哪个线程池执行的任务，future 其实是不关心的。</p>
<p>不过 Netty 毕竟不是要创建一个通用的线程池实现，而是和它要处理的 IO 息息相关的，所以我们只不过要理解它就好了。</p>
<p>这节就说这么多吧，我们回过头来再看一下这张图，看看大家是不是看懂了这节内容：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/6.png" alt="6"></p>
<p>我们就说说上图左边的部分吧，虽然我们还不知道 bind() 操作中具体会做什么工作，但是我们应该可以猜出一二。</p>
<p>显然，main 线程调用 b.bind(port) 这个方法会返回一个 ChannelFuture，bind() 是一个异步方法，当某个执行线程执行了真正的绑定操作后，那个执行线程一定会标记这个 future 为成功（我们假定 bind 会成功），然后这里的 sync() 方法（main 线程）就会返回了。</p>
<blockquote>
<p>如果 bind(port) 失败，我们知道，sync() 方法会将异常抛出来，然后就会执行到 finally 块了。 </p>
</blockquote>
<p>一旦绑定端口 bind 成功，进入下面一行，f.channel() 方法会返回该 future 关联的 channel。</p>
<p>channel.closeFuture() 也会返回一个 ChannelFuture，然后调用了 sync() 方法，这个 sync() 方法返回的条件是：<strong>有其他的线程关闭了 NioServerSocketChannel</strong>，往往是因为需要停掉服务了，然后那个线程会设置 future 的状态（ setSuccess(result) 或 setFailure(cause) ），这个 sync() 方法才会返回。</p>
<p>这节就到这里，希望大家对 Netty 中的异步编程有些了解，后续碰到源码的时候能知道是怎么使用的了。</p>
<h2 id="ChannelPipeline，和-Inbound、Outbound"><a href="#ChannelPipeline，和-Inbound、Outbound" class="headerlink" title="ChannelPipeline，和 Inbound、Outbound"></a>ChannelPipeline，和 Inbound、Outbound</h2><p>我想很多读者应该或多或少都有 Netty 中 pipeline 的概念。前面我们说了，使用 Netty 的时候，我们通常就只要写一些自定义的 handler 就可以了，我们定义的这些 handler 会组成一个 pipeline，用于处理 IO 事件，这个和我们平时接触的 Filter 或 Interceptor 表达的差不多是一个意思。</p>
<p>每个 Channel 内部都有一个 pipeline，pipeline 由多个 handler 组成，handler 之间的顺序是很重要的，因为 IO 事件将按照顺序顺次经过 pipeline 上的 handler，这样每个 handler 可以专注于做一点点小事，由多个 handler 组合来完成一些复杂的逻辑。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/11.png" alt="11"></p>
<p>从图中，我们知道这是一个双向链表。</p>
<p>首先，我们看两个重要的概念：<strong>Inbound</strong> 和 <strong>Outbound</strong>。在 Netty 中，IO 事件被分为 Inbound 事件和 Outbound 事件。</p>
<p><strong>Outbound</strong> 的 <strong>out</strong> 指的是 <strong>出去</strong>，有哪些 IO 事件属于此类呢？比如 connect、write、flush 这些 IO 操作是往外部方向进行的，它们就属于 Outbound 事件。</p>
<p>其他的，诸如 accept、read 这种就属于 Inbound 事件。</p>
<blockquote>
<p>比如客户端在发起请求的时候，需要 1️⃣connect 到服务器，然后 2️⃣write 数据传到服务器，再然后 3️⃣read 服务器返回的数据，前面的 connect 和 write 就是 <strong>out</strong> 事件，后面的 read 就是 <strong>in</strong> 事件。</p>
</blockquote>
<p>比如很多初学者看不懂下面的这段代码，这段代码用于服务端的 childHandler 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line"><span class="number">2.</span> pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line"><span class="number">3.</span> pipeline.addLast(<span class="keyword">new</span> <span class="title class_">BizHandler</span>());</span><br></pre></td></tr></table></figure>

<p>初学者肯定都纳闷，以为这个顺序写错了，应该是先 decode 客户端过来的数据，然后用 BizHandler 处理业务逻辑，最后再 encode 数据然后返回给客户端，所以添加的顺序应该是 <strong>1 -&gt; 3 -&gt; 2</strong> 才对。</p>
<p>其实这里的三个 handler 是分组的，分为 Inbound（1 和 3） 和 Outbound（2）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line"><span class="number">2.</span> pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line"><span class="number">3.</span> pipeline.addLast(<span class="keyword">new</span> <span class="title class_">BizHandler</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端连接进来的时候，读取（read）客户端请求数据的操作是 Inbound 的，所以会先使用 1，然后是 3 对处理进行处理；</li>
<li>处理完数据后，返回给客户端数据的 write 操作是 Outbound 的，此时使用的是 2。</li>
</ul>
<p>所以虽然添加顺序有点怪，但是执行顺序其实是按照 1 -&gt; 3 -&gt; 2 进行的。</p>
<blockquote>
<p>如果我们在上面的基础上，加上下面的第四行，这是一个 OutboundHandler：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4.</span> pipeline.addLast(<span class="keyword">new</span> <span class="title class_">OutboundHandlerA</span>());</span><br></pre></td></tr></table></figure>

<p>那么执行顺序是不是就是 1 -&gt; 3 -&gt; 2 -&gt; 4 呢？答案是：不是的。</p>
<p>对于 Inbound 操作，按照添加顺序执行每个 Inbound 类型的 handler；而对于 Outbound 操作，是反着来的，从后往前，顺次执行 Outbound 类型的 handler。</p>
<p>所以，上面的顺序应该是先 1 后 3，它们是 Inbound 的，然后是 4，最后才是 2，它们两个是 Outbound 的。说实话，我真不喜欢这种组织方式。</p>
</blockquote>
<p>到这里，我想大家应该都知道 Inbound 和 Outbound 了吧？下面我们来介绍它们的接口使用。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/9.png" alt="9"></p>
<p>定义处理 Inbound 事件的 handler 需要实现 ChannelInboundHandler，定义处理 Outbound 事件的 handler 需要实现 ChannelOutboundHandler。最下面的三个类，是 Netty 提供的适配器，特别的，如果我们希望定义一个 handler 能同时处理 Inbound 和 Outbound 事件，可以通过继承中间的 <strong>ChannelDuplexHandler</strong> 的方式，比如 <strong>LoggingHandler</strong> 这种既可以用来处理 Inbound 也可以用来处理 Outbound 事件的 handler。</p>
<p>有了 Inbound 和 Outbound 的概念以后，我们来开始介绍 Pipeline 的源码。</p>
<p>我们说过，一个 Channel 关联一个 pipeline，NioSocketChannel 和 NioServerSocketChannel 在执行构造方法的时候，都会走到它们的父类 AbstractChannel 的构造方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractChannel</span><span class="params">(Channel parent)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    <span class="comment">// 给每个 channel 分配一个唯一 id</span></span><br><span class="line">    id = newId();</span><br><span class="line">    <span class="comment">// 每个 channel 内部需要一个 Unsafe 的实例</span></span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    <span class="comment">// 每个 channel 内部都会创建一个 pipeline</span></span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的三行代码中，id 比较不重要，Netty 中的 Unsafe 实例其实挺重要的，这里简单介绍一下。</p>
<p>在 JDK 的源码中，sun.misc.Unsafe 类提供了一些底层操作的能力，它设计出来是给 JDK 中的源码使用的，比如 AQS、ConcurrentHashMap 等，我们在之前的并发包的源码分析中也看到了很多它们使用 Unsafe 的场景，这个 Unsafe 类不是给我们的代码使用的，是给 JDK 源码使用的（需要的话，我们也是可以获取它的实例的）。</p>
<blockquote>
<p>Unsafe 类的构造方法是 private 的，但是它提供了 getUnsafe() 这个静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br></pre></td></tr></table></figure>
<p>大家可以试一下，上面这行代码编译没有问题，但是执行的时候会抛 <code>java.lang.SecurityException</code> 异常，因为它就不是给我们的代码用的。</p>
<p>但是如果你就是想获取 Unsafe 的实例，可以通过下面这个代码获取到:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) f.get(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Netty 中的 Unsafe 也是同样的意思，它封装了 Netty 中会使用到的 JDK 提供的 NIO 接口，比如将 channel 注册到 selector 上，比如 bind 操作，比如 connect 操作等，<strong>这些操作都是稍微偏底层一些</strong>。Netty 同样也是不希望我们的业务代码使用 Unsafe 的实例，它是提供给 Netty 中的源码使用的。</p>
<blockquote>
<p>不过，对于我们源码分析来说，我们还是会有很多时候需要分析 Unsafe 中的源码的</p>
</blockquote>
<p>关于 Unsafe，我们后面用到了再说，这里只要知道，它封装了大部分需要访问 JDK 的 NIO 接口的操作就好了。这里我们继续将焦点放在实例化 pipeline 上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title function_">newChannelPipeline</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelPipeline</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里开始调用 DefaultChannelPipeline 的构造方法，并把当前 channel 的引用传入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">    succeededFuture = <span class="keyword">new</span> <span class="title class_">SucceededChannelFuture</span>(channel, <span class="literal">null</span>);</span><br><span class="line">    voidPromise =  <span class="keyword">new</span> <span class="title class_">VoidChannelPromise</span>(channel, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    tail = <span class="keyword">new</span> <span class="title class_">TailContext</span>(<span class="built_in">this</span>);</span><br><span class="line">    head = <span class="keyword">new</span> <span class="title class_">HeadContext</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里实例化了 tail 和 head 这两个 handler。tail 实现了 ChannelInboundHandler 接口，而 head 实现了 ChannelOutboundHandler 和 ChannelInboundHandler 两个接口，并且最后两行代码将 tail 和 head 连接起来:</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/12.png" alt="12"></p>
<blockquote>
<p>注意，在不同的版本中，源码也略有差异，head 不一定是 in + out，大家知道这点就好了。</p>
<p>还有，从上面的 head 和 tail 我们也可以看到，其实 pipeline 中的每个元素是 <strong>ChannelHandlerContext</strong> 的实例，而不是 ChannelHandler 的实例，context 包装了一下 handler，但是，后面我们都会用 handler 来描述一个 pipeline 上的节点，而不是使用 context，希望读者知道这一点。</p>
</blockquote>
<p>这里只是构造了 pipeline，并且添加了两个固定的 handler 到其中（head + tail），还不涉及到自定义的 handler 代码执行。我们回过头来看下面这段代码：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/13.png" alt="13"></p>
<blockquote>
<p>我们说过 childHandler 中指定的 handler 不是给 NioServerSocketChannel 使用的，是给 NioSocketChannel 使用的，所以这里我们不看它。</p>
</blockquote>
<p>这里调用 handler(…) 方法指定了一个 LoggingHandler 的实例，然后我们再进去下面的 bind(…) 方法中看看这个 LoggingHandler 实例是怎么进入到我们之前构造的 pipeline 内的。</p>
<p>顺着 bind() 一直往前走，bind() -&gt; doBind() -&gt; initAndRegister()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 构造 channel 实例，同时会构造 pipeline 实例，</span></span><br><span class="line">        <span class="comment">// 现在 pipeline 中有 head 和 tail 两个 handler 了</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        <span class="comment">// 2. 看这里</span></span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的两行代码，第一行实现了构造 channel 和 channel 内部的 pipeline，我们来看第二行 init 代码：</p>
<p>// ServerBootstrap：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 拿到刚刚创建的 channel 内部的 pipeline 实例</span></span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> channel.pipeline();</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 开始往 pipeline 中添加一个 handler，这个 handler 是 ChannelInitializer 的实例</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们以后会看到，下面这个 initChannel 方法何时会被调用</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">            <span class="comment">// 这个方法返回我们最开始指定的 LoggingHandler 实例</span></span><br><span class="line">            <span class="type">ChannelHandler</span> <span class="variable">handler</span> <span class="operator">=</span> config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 添加 LoggingHandler</span></span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先不用管这里的 eventLoop</span></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 添加一个 handler 到 pipeline 中：ServerBootstrapAcceptor</span></span><br><span class="line">                    <span class="comment">// 从名字可以看到，这个 handler 的目的是用于接收客户端请求</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ServerBootstrapAcceptor</span>(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及到 pipeline 中的辅助类 ChannelInitializer，我们看到，它本身是一个 handler（Inbound 类型），但是它的作用和普通 handler 有点不一样，它纯碎是用来辅助将其他的 handler 加入到 pipeline 中的。</p>
<p>大家可以稍微看一下 ChannelInitializer 的 initChannel 方法，有个简单的认识就好，此时的 pipeline 应该是这样的：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/14.png" alt="14"></p>
<p>ChannelInitializer 的 initChannel(channel) 方法被调用的时候，会往 pipeline 中添加我们最开始指定的 <strong>LoggingHandler</strong> 和添加一个 <strong>ServerBootstrapAcceptor</strong>。但是我们现在还不知道这个 initChannel 方法何时会被调用。</p>
<p>上面我们说的是作为服务端的 NioServerSocketChannel 的 pipeline，NioSocketChannel 也是差不多的，我们可以看一下 Bootstrap 类的 init(channel) 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> channel.pipeline();</span><br><span class="line">    p.addLast(config.handler());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/23.png" alt="23"></p>
<p>它和服务端 ServerBootstrap 要添加 ServerBootstrapAcceptor 不一样，它只需要将 EchoClient 类中的 ChannelInitializer 实例加进来就可以了，它的 ChannelInitializer 中添加了两个 handler，LoggingHandler 和 EchoClientHandler：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/16.png" alt="16"></p>
<p>很显然，我们需要的是像 LoggingHandler 和 EchoClientHandler 这样的 handler，但是，它们现在还不在 pipeline 中，那么它们什么时候会真正进入到 pipeline 中呢？以后我们再揭晓。</p>
<p>还有，为什么 Server 端我们指定的是一个 handler 实例，而 Client 指定的是一个 ChannelInitializer 实例？其实它们是可以随意搭配使用的，你甚至可以在 ChannelInitializer 实例中添加 ChannelInitializer 的实例。</p>
<p>非常抱歉，这里又要断了，下面要先介绍线程池了，大家要记住 pipeline 现在的样子，<strong>head + channelInitializer + tail</strong>。</p>
<p>本节没有介绍 handler 的向后传播，就是一个 handler 处理完了以后，怎么传递给下一个 handler 来处理？比如我们熟悉的 JavaEE 中的 Filter 是采用在一个 Filter 实例中调用 chain.doFilter(request, response) 来传递给下一个 Filter 这种方式的。</p>
<p>我们用下面这张图结束本节。下图展示了传播的方法，但我其实是更想让大家看一下，哪些事件是 Inbound 类型的，哪些是 Outbound 类型的：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/19.png" alt="19"></p>
<p>Outbound 类型的几个事件大家应该比较好认，注意 bind 也是 Outbound 类型的。</p>
<h2 id="Netty-中的线程池-EventLoopGroup"><a href="#Netty-中的线程池-EventLoopGroup" class="headerlink" title="Netty 中的线程池 EventLoopGroup"></a>Netty 中的线程池 EventLoopGroup</h2><p>接下来，我们来分析 Netty 中的线程池。Netty 中的线程池比较不好理解，因为它的类比较多，而且它们之间的关系错综复杂。看下图，感受下 NioEventLoop 类和 NioEventLoopGroup 类的继承结构：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/2.png" alt="2"></p>
<p>这张图我按照继承关系整理而来，大家仔细看一下就会发现，涉及到的类确实挺多的。本节来给大家理理清楚这部分内容。</p>
<p>首先，我们说的 Netty 的线程池，指的就是 <strong>NioEventLoopGroup</strong> 的实例；线程池中的单个线程，指的是右边 <strong>NioEventLoop</strong> 的实例。</p>
<p>我们第一节介绍的 Echo 例子，客户端和服务端的启动代码中，最开始我们总是先实例化 NioEventLoopGroup：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EchoClient 代码最开始：</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// EchoServer 代码最开始：</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br></pre></td></tr></table></figure>

<p>下面，我们就从 NioEventLoopGroup 的源码开始进行分析。</p>
<p>我们打开 NioEventLoopGroup 的源码，可以看到，NioEventLoopGroup 有多个构造方法用于参数设置，最简单地，我们采用无参构造函数，或仅仅设置线程数量就可以了，其他的参数采用默认值。</p>
<blockquote>
<p>比如上面的代码中，我们只在实例化 bossGroup 的时候指定了参数，代表该线程池需要一个线程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(nThreads, (Executor) <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 参数最全的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor, EventExecutorChooserFactory chooserFactory,</span></span><br><span class="line"><span class="params">                         <span class="keyword">final</span> SelectorProvider selectorProvider,</span></span><br><span class="line"><span class="params">                         <span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory,</span></span><br><span class="line"><span class="params">                         <span class="keyword">final</span> RejectedExecutionHandler rejectedExecutionHandler)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">    <span class="built_in">super</span>(nThreads, executor, chooserFactory, selectorProvider, selectStrategyFactory, rejectedExecutionHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来稍微看一下构造方法中的各个参数：</p>
<ul>
<li>nThreads：这个最简单，就是线程池中的线程数，也就是 NioEventLoop 的实例数量。</li>
<li>executor：我们知道，我们本身就是要构造一个线程池（Executor），为什么这里传一个 executor 实例呢？它其实不是给线程池用的，而是给 NioEventLoop 用的，以后再说。</li>
<li>chooserFactory：当我们提交一个任务到线程池的时候，线程池需要选择（choose）其中的一个线程来执行这个任务，这个就是用来实现选择策略的。</li>
<li>selectorProvider：这个简单，我们需要通过它来实例化 JDK 的 Selector，可以看到每个线程池都持有一个 selectorProvider 实例。</li>
<li>selectStrategyFactory：这个涉及到的是线程池中线程的工作流程，在介绍 NioEventLoop 的时候会说。</li>
<li>rejectedExecutionHandler：这个也是线程池的好朋友了，用于处理线程池中没有可用的线程来执行任务的情况。在 Netty 中稍微有一点点不一样，这个是给 NioEventLoop 实例用的，以后我们再详细介绍。</li>
</ul>
<p>这里介绍这些参数是希望大家有个印象而已，大家发现没有，在构造 NioEventLoopGroup 实例时的好几个参数，都是用来构造 NioEventLoop 用的。</p>
<p>下面，我们从 NioEventLoopGroup 的无参构造方法开始，跟着源码走：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后一步步走下去，到这个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory, <span class="keyword">final</span> SelectorProvider selectorProvider, <span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">super</span>(nThreads, threadFactory, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家自己要去跟一下源码，这样才知道中间设置了哪些默认值，下面这几个参数都被设置了默认值： </p>
<ul>
<li><p>selectorProvider = SelectorProvider.provider()</p>
<blockquote>
<p>这个没什么好说的，调用了 JDK 提供的方法</p>
</blockquote>
</li>
<li><p>selectStrategyFactory = DefaultSelectStrategyFactory.INSTANCE</p>
<blockquote>
<p>这个涉及到的是线程在做 select 操作和执行任务过程中的策略选择问题，在介绍 NioEventLoop 的时候会用到。 </p>
</blockquote>
</li>
<li><p>rejectedExecutionHandler = RejectedExecutionHandlers.reject()</p>
<blockquote>
<p>大家进去看一下 reject() 方法，也就是说，Netty 选择的默认拒绝策略是：抛出异常</p>
</blockquote>
</li>
</ul>
<p>跟着源码走，我们会来到父类 MultithreadEventLoopGroup 的构造方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory, Object... args)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们发现，如果采用无参构造函数，那么到这里的时候，默认地 nThreads 会被设置为 **CPU 核心数 *2**。大家可以看下 DEFAULT_EVENT_LOOP_THREADS 的默认值，以及 static 代码块的设值逻辑。</p>
<p>我们继续往下走：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventExecutorGroup</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory, Object... args)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(nThreads, threadFactory == <span class="literal">null</span> ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">ThreadPerTaskExecutor</span>(threadFactory), args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这一步的时候，<code>new ThreadPerTaskExecutor(threadFactory)</code> 会构造一个 executor。</p>
<blockquote>
<p>我们现在还不知道这个 executor 怎么用。这里我们先看下它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPerTaskExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (threadFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;threadFactory&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">        <span class="comment">// 为每个任务新建一个线程</span></span><br><span class="line">        threadFactory.newThread(command).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Executor 作为线程池的最顶层接口， 我们知道，它只有一个 execute(runnable) 方法，从上面我们可以看到，实现类 ThreadPerTaskExecutor 的逻辑就是<strong>每来一个任务，新建一个线程</strong>。</p>
<p>我们先记住这个，前面也说了，它是给 NioEventLoop 用的，不是给 NioEventLoopGroup 用的。</p>
</blockquote>
<p>上一步设置完了 executor，我们继续往下看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventExecutorGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor, Object... args)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步设置了 chooserFactory，用来实现从线程池中选择一个线程的选择策略。</p>
<blockquote>
<p>ChooserFactory 的逻辑比较简单，我们看下 DefaultEventExecutorChooserFactory 的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> EventExecutorChooser <span class="title function_">newChooser</span><span class="params">(EventExecutor[] executors)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPowerOfTwo(executors.length)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PowerOfTwoEventExecutorChooser</span>(executors);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GenericEventExecutorChooser</span>(executors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里设置的策略也很简单：</p>
<p>1、如果线程池的线程数量是 2^n，采用下面的方式会高效一些：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> EventExecutor <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、如果不是，用取模的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> EventExecutor <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> executors[Math.abs(idx.getAndIncrement() % executors.length)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>走了这么久，我们终于到了一个<strong>干实事</strong>的构造方法中了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventExecutorGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor,</span></span><br><span class="line"><span class="params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// executor 如果是 null，做一次和前面一样的默认设置。</span></span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="literal">null</span>) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> <span class="title class_">ThreadPerTaskExecutor</span>(newDefaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的 children 数组非常重要，它就是线程池中的线程数组，这么说不太严谨，但是就大概这个意思</span></span><br><span class="line">    children = <span class="keyword">new</span> <span class="title class_">EventExecutor</span>[nThreads];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这个 for 循环将实例化 children 数组中的每一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化！！！！！！</span></span><br><span class="line">            children[i] = newChild(executor, args);</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Think about if this is a good exception type</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;failed to create a child event loop&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果有一个 child 实例化失败，那么 success 就会为 false，然后进入下面的失败处理逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="comment">// 把已经成功实例化的“线程” shutdown，shutdown 是异步操作</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    children[j].shutdownGracefully();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待这些线程成功 shutdown</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    <span class="type">EventExecutor</span> <span class="variable">e</span> <span class="operator">=</span> children[j];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> (!e.isTerminated()) &#123;</span><br><span class="line">                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException interrupted) &#123;</span><br><span class="line">                        <span class="comment">// 把中断状态设置回去，交给关心的线程来处理.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ================================================</span></span><br><span class="line">    <span class="comment">// === 到这里，就是代表上面的实例化所有线程已经成功结束 ===</span></span><br><span class="line">    <span class="comment">// ================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过之前设置的 chooserFactory 来实例化 Chooser，把线程池数组传进去，</span></span><br><span class="line">    <span class="comment">//     这就不必再说了吧，实现线程选择策略</span></span><br><span class="line">    chooser = chooserFactory.newChooser(children);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置一个 Listener 用来监听该线程池的 termination 事件</span></span><br><span class="line">    <span class="comment">// 下面的代码逻辑是：给池中每一个线程都设置这个 listener，当监听到所有线程都 terminate 以后，这个线程池就算真正的 terminate 了。</span></span><br><span class="line">    <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> <span class="title class_">FutureListener</span>&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                terminationFuture.setSuccess(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (EventExecutor e: children) &#123;</span><br><span class="line">        e.terminationFuture().addListener(terminationListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 readonlyChildren，它是只读集合，以后用到再说</span></span><br><span class="line">    Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;EventExecutor&gt;(children.length);</span><br><span class="line">    Collections.addAll(childrenSet, children);</span><br><span class="line">    readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码非常简单吧，没有什么需要特别说的，接下来，我们来看看 newChild() 这个方法，这个方法非常重要，它将创建线程池中的线程。</p>
<blockquote>
<p>我上面已经用过很多次”线程”这个词了，它可不是 Thread 的意思，而是指池中的个体，后面我们会看到每个”线程”在什么时候会真正创建 Thread 实例。反正每个 NioEventLoop 实例内部都会有一个自己的 Thread 实例，所以把这两个概念混在一起也无所谓吧。</p>
</blockquote>
<p><code>newChild(…)</code> 方法在 NioEventLoopGroup 中覆写了，上面说的”线程”其实就是 NioEventLoop：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> EventLoop <span class="title function_">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NioEventLoop</span>(<span class="built_in">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>],</span><br><span class="line">        ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它调用了 NioEventLoop 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;</span><br><span class="line">    <span class="comment">// 调用父类构造器</span></span><br><span class="line">    <span class="built_in">super</span>(parent, executor, <span class="literal">false</span>, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);</span><br><span class="line">    <span class="keyword">if</span> (selectorProvider == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;selectorProvider&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strategy == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;selectStrategy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    provider = selectorProvider;</span><br><span class="line">    <span class="comment">// 开启 NIO 中最重要的组件：Selector</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SelectorTuple</span> <span class="variable">selectorTuple</span> <span class="operator">=</span> openSelector();</span><br><span class="line">    selector = selectorTuple.selector;</span><br><span class="line">    unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">    selectStrategy = strategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先粗略观察一下，然后再往下看：</p>
<ul>
<li>在 Netty 中，NioEventLoopGroup 代表线程池，NioEventLoop 就是其中的线程。</li>
<li>线程池 NioEventLoopGroup 是池中的线程 NioEventLoop 的 <strong>parent</strong>，从上面的代码中的取名可以看出。</li>
<li>每个 NioEventLoop 都有自己的 Selector，上面的代码也反应了这一点，这和 Tomcat 中的 NIO 模型有点区别。</li>
<li>executor、selectStrategy 和 rejectedExecutionHandler 从 NioEventLoopGroup 中一路传到了 NioEventLoop 中。</li>
</ul>
<p>这个时候，我们来看一下 NioEventLoop 类的属性都有哪些，我们先忽略它继承自父类的属性，单单看它自己的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Selector selector;</span><br><span class="line"><span class="keyword">private</span> Selector unwrappedSelector;</span><br><span class="line"><span class="keyword">private</span> SelectedSelectionKeySet selectedKeys;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectorProvider provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">wakenUp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectStrategy selectStrategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">ioRatio</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> cancelledKeys;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> needsToSelectAgain;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结合它的构造方法我们来总结一下：</p>
<ul>
<li>provider：它由 NioEventLoopGroup 传进来，前面我们说了一个线程池有一个 selectorProvider，用于创建 Selector 实例</li>
<li>selector：虽然我们还没看创建 selector 的代码，但我们已经知道，在 Netty 中 Selector 是跟着线程池中的线程走的。也就是说，并非一个线程池一个 Selector 实例，而是线程池中每一个线程都有一个 Selector 实例。</li>
<li>selectStrategy：select 操作的策略，这个不急。</li>
<li>ioRatio：这是 IO 任务的执行时间比例，因为每个线程既有 IO 任务执行，也有非 IO 任务需要执行，所以该参数为了保证有足够时间是给 IO 的。这里也不需要急着去理解什么 IO 任务、什么非 IO 任务。</li>
</ul>
<p>然后我们继续走它的构造方法，我们看到上面的构造方法调用了父类的构造器，它的父类是 SingleThreadEventLoop。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">SingleThreadEventLoop</span><span class="params">(EventLoopGroup parent, Executor executor,</span></span><br><span class="line"><span class="params">                                <span class="type">boolean</span> addTaskWakesUp, <span class="type">int</span> maxPendingTasks,</span></span><br><span class="line"><span class="params">                                RejectedExecutionHandler rejectedExecutionHandler)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent, executor, addTaskWakesUp, maxPendingTasks, rejectedExecutionHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们可以直接忽略这个东西，以后我们也不会再介绍它</span></span><br><span class="line">    tailTasks = newTaskQueue(maxPendingTasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SingleThreadEventLoop 这个名字很诡异有没有？然后它的构造方法又调用了父类 SingleThreadEventExecutor 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">SingleThreadEventExecutor</span><span class="params">(EventExecutorGroup parent, Executor executor,</span></span><br><span class="line"><span class="params">                                    <span class="type">boolean</span> addTaskWakesUp, <span class="type">int</span> maxPendingTasks,</span></span><br><span class="line"><span class="params">                                    RejectedExecutionHandler rejectedHandler)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">    <span class="built_in">this</span>.addTaskWakesUp = addTaskWakesUp;</span><br><span class="line">    <span class="built_in">this</span>.maxPendingTasks = Math.max(<span class="number">16</span>, maxPendingTasks);</span><br><span class="line">    <span class="built_in">this</span>.executor = ObjectUtil.checkNotNull(executor, <span class="string">&quot;executor&quot;</span>);</span><br><span class="line">    <span class="comment">// taskQueue，这个东西很重要，提交给 NioEventLoop 的任务都会进入到这个 taskQueue 中等待被执行</span></span><br><span class="line">    <span class="comment">// 这个 queue 的默认容量是 16</span></span><br><span class="line">    taskQueue = newTaskQueue(<span class="built_in">this</span>.maxPendingTasks);</span><br><span class="line">    rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, <span class="string">&quot;rejectedHandler&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里就更加诡异了，NioEventLoop 的父类是 SingleThreadEventLoop，而 SingleThreadEventLoop 的父类是 <strong>SingleThreadEventExecutor</strong>，它的名字告诉我们，它是一个 Executor，是一个线程池，而且是 Single Thread 单线程的。</p>
<p>也就是说，线程池 NioEventLoopGroup 中的每一个线程 NioEventLoop 也可以当做一个线程池来用，只不过它只有一个线程。这种设计虽然看上去很巧妙，不过有点反人类的样子。</p>
<p>上面这个构造函数比较简单：</p>
<ul>
<li><p>设置了 parent，也就是之前创建的线程池 NioEventLoopGroup 实例</p>
</li>
<li><p>executor：它是我们之前实例化的 ThreadPerTaskExecutor，我们说过，这个东西在线程池中没有用，它是给 NioEventLoop 用的，马上我们就要看到它了。提前透露一下，它用来开启 NioEventLoop 中的线程（Thread 实例）。</p>
</li>
<li><p>taskQueue：这算是该构造方法中新的东西，它是任务队列。我们前面说过，NioEventLoop 需要负责 IO 事件和非 IO 事件，通常它都在执行 selector 的 select 方法或者正在处理 selectedKeys，如果我们要 submit 一个任务给它，任务就会被放到 taskQueue 中，等它来轮询。该队列是线程安全的 LinkedBlockingQueue，默认容量为 16。</p>
</li>
<li><p>rejectedExecutionHandler：taskQueue 的默认容量是 16，所以，如果 submit 的任务堆积了到了 16，再往里面提交任务会触发 rejectedExecutionHandler 的执行策略。</p>
<blockquote>
<p>还记得默认策略吗：抛出RejectedExecutionException 异常。</p>
<p>在 NioEventLoopGroup 的默认构造中，它的实现是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">REJECT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionHandler</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejected</span><span class="params">(Runnable task, SingleThreadEventExecutor executor)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p>然后，我们再回到 NioEventLoop 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;</span><br><span class="line">    <span class="comment">// 我们刚刚说完了这个</span></span><br><span class="line">    <span class="built_in">super</span>(parent, executor, <span class="literal">false</span>, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);</span><br><span class="line">    <span class="keyword">if</span> (selectorProvider == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;selectorProvider&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strategy == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;selectStrategy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    provider = selectorProvider;</span><br><span class="line">    <span class="comment">// 创建 selector 实例</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SelectorTuple</span> <span class="variable">selectorTuple</span> <span class="operator">=</span> openSelector();</span><br><span class="line">    selector = selectorTuple.selector;</span><br><span class="line">    unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">    </span><br><span class="line">    selectStrategy = strategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最重要的方法其实就是 openSelector() 方法，它将创建 NIO 中最重要的一个组件 <strong>Selector</strong>。在这个方法中，Netty 也做了一些优化，这部分我们就不去分析它了。</p>
<p>到这里，我们的线程池 NioEventLoopGroup 创建完成了，并且实例化了池中的所有 NioEventLoop 实例。</p>
<p>同时，大家应该已经看到，上面并没有真正创建 NioEventLoop 中的线程（没有创建 Thread 实例）。</p>
<p>提前透露一下，创建线程的时机在第一个任务提交过来的时候，那么第一个任务是什么呢？是我们马上要说的 channel 的 <strong>register</strong> 操作。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 使用</title>
    <url>/2024/08/11/redis-quickstart/</url>
    <content><![CDATA[<h1 id="初识Redis"><a href="#初识Redis" class="headerlink" title="初识Redis"></a>初识Redis</h1><p>Redis是一种键值型的NoSql数据库，这里有两个关键字：</p>
<ul>
<li><p>键值型</p>
</li>
<li><p>NoSql</p>
</li>
</ul>
<p>其中<strong>键值型</strong>，是指Redis中存储的数据都是以key、value对的形式存储，而value的形式多种多样，可以是字符串、数值、甚至json：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/6U1Rhxo.png" alt="image-20220502190959608"></p>
<p>而NoSql则是相对于传统关系型数据库而言，有很大差异的一种数据库。</p>
<h2 id="认识NoSQL"><a href="#认识NoSQL" class="headerlink" title="认识NoSQL"></a>认识NoSQL</h2><p><strong>NoSql</strong>可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为<strong>非关系型数据库</strong>。</p>
<h3 id="结构化与非结构化"><a href="#结构化与非结构化" class="headerlink" title="结构化与非结构化"></a>结构化与非结构化</h3><p>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名、字段数据类型、字段约束等等信息，插入的数据必须遵守这些约束：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/4tUgFo6.png"></p>
<p>而NoSql则对数据库格式没有严格约束，往往形式松散，自由。</p>
<p>可以是键值型：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/GdqOSsj.png"></p>
<p>也可以是文档型：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/zBBQfcc.png"></p>
<p>甚至可以是图格式：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/zBnKxWf.png"></p>
<h3 id="关联和非关联"><a href="#关联和非关联" class="headerlink" title="关联和非关联"></a>关联和非关联</h3><p>传统数据库的表与表之间往往存在关联，例如外键：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/tXYSl5x.png"></p>
<p>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  name<span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  orders<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	 id<span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;荣耀6&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">4999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	 id<span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;小米11&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">3999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。</p>
<h3 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h3><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；</p>
<p>而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/AzaHOTF.png"></p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>传统关系型数据库能满足事务ACID的原则。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/J1MqOJM.png"></p>
<p>而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>除了上述四点以外，在存储方式、扩展性、查询性能上关系型与非关系型也都有着显著差异，总结如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/kZP40dQ.png"></p>
<ul>
<li>存储方式<ul>
<li>关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响</li>
<li>非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些</li>
</ul>
</li>
</ul>
<ul>
<li>扩展性<ul>
<li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li>
<li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li>
<li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li>
</ul>
</li>
</ul>
<h2 id="认识Redis"><a href="#认识Redis" class="headerlink" title="认识Redis"></a>认识Redis</h2><p>Redis诞生于2009年全称是<strong>Re</strong>mote  <strong>D</strong>ictionary <strong>S</strong>erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p>
<p><strong>特征</strong>：</p>
<ul>
<li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li>
<li>单线程，每个命令具备原子性</li>
<li>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</li>
<li>支持数据持久化</li>
<li>支持主从集群、分片集群</li>
<li>支持多语言客户端</li>
</ul>
<p><strong>作者</strong>：Antirez</p>
<p>Redis的官方网站地址：<a href="https://redis.io/">https://redis.io/</a></p>
<h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><p>大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis.</p>
<p>此处选择的Linux版本为CentOS 7.</p>
<h3 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a>依赖库</h3><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure>



<h3 id="上传安装包并解压"><a href="#上传安装包并解压" class="headerlink" title="上传安装包并解压"></a>上传安装包并解压</h3><p>然后将课前资料提供的Redis安装包上传到虚拟机的任意目录：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/SyjanS5.png"></p>
<p>例如，我放到了/usr/local/src 目录：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/01DTNCf.png"></p>
<p>解压缩：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -xzf redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure>

<p>解压后：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/8V6zvCD.png" alt="image-20211211080339076"></p>
<p>进入redis目录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-6.2.6</span><br></pre></td></tr></table></figure>



<p>运行编译命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>如果没有出错，应该就安装成功了。</p>
<p>默认的安装路径是在 <code>/usr/local/bin</code>目录下：</p>
<p><img src="https://i.imgur.com/YSxkGm7.png"></p>
<p>该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p>
<ul>
<li>redis-cli：是redis提供的命令行客户端</li>
<li>redis-server：是redis的服务端启动脚本</li>
<li>redis-sentinel：是redis的哨兵启动脚本</li>
</ul>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>redis的启动方式有很多种，例如：</p>
<ul>
<li>默认启动</li>
<li>指定配置启动</li>
<li>开机自启</li>
</ul>
<h3 id="默认启动"><a href="#默认启动" class="headerlink" title="默认启动"></a>默认启动</h3><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/v7xWsqC.png"></p>
<p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p>
<h3 id="指定配置启动"><a href="#指定配置启动" class="headerlink" title="指定配置启动"></a>指定配置启动</h3><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20211211082225509.png" alt="image-20211211082225509"></p>
<p>我们先将这个配置文件备份一份：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure>



<p>然后修改redis.conf文件中的一些配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes </span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123321</span></span><br></pre></td></tr></table></figure>



<p>Redis的其它常见配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">.</span></span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line"><span class="attr">maxmemory</span> <span class="string">512mb</span></span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure>



<p>启动Redis：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure>



<p>停止服务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span></span><br><span class="line">redis-cli -u 123321 shutdown</span><br></pre></td></tr></table></figure>



<h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><p>我们也可以通过配置来实现开机自启。</p>
<p>首先，新建一个系统服务文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>



<p>然后重载系统服务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>



<p>现在，我们可以用下面这组命令来操作redis了：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure>



<p>执行下面的命令，可以让redis开机自启：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure>



<h2 id="Redis桌面客户端"><a href="#Redis桌面客户端" class="headerlink" title="Redis桌面客户端"></a>Redis桌面客户端</h2><p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p>
<ul>
<li>命令行客户端</li>
<li>图形化桌面客户端</li>
<li>编程客户端</li>
</ul>
<h3 id="Redis命令行客户端"><a href="#Redis命令行客户端" class="headerlink" title="Redis命令行客户端"></a>Redis命令行客户端</h3><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure>

<p>其中常见的options有：</p>
<ul>
<li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li>
<li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li>
<li><code>-a 123321</code>：指定redis的访问密码 </li>
</ul>
<p>其中的commonds就是Redis的操作命令，例如：</p>
<ul>
<li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li>
</ul>
<p>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/OYYWPNo.png"></p>
<h3 id="图形化桌面客户端"><a href="#图形化桌面客户端" class="headerlink" title="图形化桌面客户端"></a>图形化桌面客户端</h3><p>GitHub上的大神编写了Redis的图形化桌面客户端，地址：<a href="https://github.com/uglide/RedisDesktopManager">https://github.com/uglide/RedisDesktopManager</a></p>
<p>不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。</p>
<p>在下面这个仓库可以找到安装包：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在课前资料中可以找到Redis的图形化桌面客户端：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/BZ4Agbi.png"></p>
<p>解压缩后，运行安装程序即可安装：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/hguGHbX.png"></p>
<p>安装完成后，在安装目录下找到rdm.exe文件：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/hwK5LQ8.png"></p>
<p>双击即可运行：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/6hUqslY.png"></p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>点击左上角的<code>连接到Redis服务器</code>按钮：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/9qTGyoN.png"></p>
<p>在弹出的窗口中填写Redis服务信息：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/DshNnKC.png"></p>
<p>点击确定后，在左侧菜单会出现这个链接：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/A2cOm7Q.png"></p>
<p>点击即可建立连接了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ja8Fd9s.png"></p>
<p>Redis默认有16个仓库，编号从0至15.  通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p>
<p>如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选择 0号库</span></span><br><span class="line"><span class="keyword">select</span> 0</span><br></pre></td></tr></table></figure>



<h1 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a>Redis常见命令</h1><p>Redis是典型的key-value数据库，key一般是字符串，而value包含很多不同的数据类型：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/8tli2o9.png"></p>
<p>Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ <a href="https://redis.io/commands">https://redis.io/commands </a>）可以查看到不同的命令：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/5Lcr3BE.png"></p>
<p>不同类型的命令称为一个group，我们也可以通过help命令来查看各种不同group的命令：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/suevOIR.png"></p>
<p>接下来，我们就学习常见的五种基本数据类型的相关命令。</p>
<h2 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h2><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p>
<ul>
<li>KEYS：查看符合模板的所有key</li>
<li>DEL：删除一个指定的key</li>
<li>EXISTS：判断key是否存在</li>
<li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li>
<li>TTL：查看一个KEY的剩余有效期</li>
</ul>
<p>通过help [command] 可以查看一个命令的具体用法，例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看keys命令的帮助信息：</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> keys</span><br><span class="line"></span><br><span class="line">KEYS pattern</span><br><span class="line">summary: Find all keys matching the given pattern</span><br><span class="line">since: 1.0.0</span><br><span class="line">group: generic</span><br></pre></td></tr></table></figure>



<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p>
<p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p>
<ul>
<li>string：普通字符串</li>
<li>int：整数类型，可以做自增、自减操作</li>
<li>float：浮点类型，可以做自增、自减操作</li>
</ul>
<p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/VZqpv73.png"></p>
<h3 id="String的常见命令"><a href="#String的常见命令" class="headerlink" title="String的常见命令"></a>String的常见命令</h3><p>String的常见命令有：</p>
<ul>
<li>SET：添加或者修改已经存在的一个String类型的键值对</li>
<li>GET：根据key获取String类型的value</li>
<li>MSET：批量添加多个String类型的键值对</li>
<li>MGET：根据多个key获取多个String类型的value</li>
<li>INCR：让一个整型的key自增1</li>
<li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li>
<li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li>
<li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li>
<li>SETEX：添加一个String类型的键值对，并且指定有效期</li>
</ul>
<h3 id="Key结构"><a href="#Key结构" class="headerlink" title="Key结构"></a>Key结构</h3><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p>
<p>例如，需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p>
<p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p>
<p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">项目名:业务名:类型:id</span><br></pre></td></tr></table></figure>

<p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。这样以来，我们就可以把不同类型的数据区分开了。从而避免了key的冲突问题。</p>
<p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p>
<ul>
<li><p>user相关的key：<strong>heima:user:1</strong></p>
</li>
<li><p>product相关的key：<strong>heima:product:1</strong></p>
</li>
</ul>
<p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p>
<table>
<thead>
<tr>
<th><strong>KEY</strong></th>
<th><strong>VALUE</strong></th>
</tr>
</thead>
<tbody><tr>
<td>heima:user:1</td>
<td>{“id”:1,  “name”: “Jack”, “age”: 21}</td>
</tr>
<tr>
<td>heima:product:1</td>
<td>{“id”:1,  “name”: “小米11”, “price”: 4999}</td>
</tr>
</tbody></table>
<p>并且，在Redis的桌面客户端中，还会以相同前缀作为层级结构，让数据看起来层次分明，关系清晰：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/InWMfeD.png"></p>
<h2 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h2><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p>
<p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/x2zDBjf.png"></p>
<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/VF2EPt0.png"></p>
<p>Hash的常见命令有：</p>
<ul>
<li><p>HSET key field value：添加或者修改hash类型key的field的值</p>
</li>
<li><p>HGET key field：获取一个hash类型key的field的值</p>
</li>
<li><p>HMSET：批量添加多个hash类型key的field的值</p>
</li>
<li><p>HMGET：批量获取多个hash类型key的field的值</p>
</li>
<li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p>
</li>
<li><p>HKEYS：获取一个hash类型的key中的所有的field</p>
</li>
<li><p>HINCRBY:让一个hash类型key的字段值自增并指定步长</p>
</li>
<li><p>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</p>
</li>
</ul>
<h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p>
<p>特征也与LinkedList类似：</p>
<ul>
<li>有序</li>
<li>元素可以重复</li>
<li>插入和删除快</li>
<li>查询速度一般</li>
</ul>
<p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p>
<p>List的常见命令有：</p>
<ul>
<li>LPUSH key element … ：向列表左侧插入一个或多个元素</li>
<li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li>
<li>RPUSH key element … ：向列表右侧插入一个或多个元素</li>
<li>RPOP key：移除并返回列表右侧的第一个元素</li>
<li>LRANGE key star end：返回一段角标范围内的所有元素</li>
<li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li>
</ul>
<h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p>
<ul>
<li><p>无序</p>
</li>
<li><p>元素不可重复</p>
</li>
<li><p>查找快</p>
</li>
<li><p>支持交集、并集、差集等功能</p>
</li>
</ul>
<p>Set的常见命令有：</p>
<ul>
<li>SADD key member … ：向set中添加一个或多个元素</li>
<li>SREM key member … : 移除set中的指定元素</li>
<li>SCARD key： 返回set中元素的个数</li>
<li>SISMEMBER key member：判断一个元素是否存在于set中</li>
<li>SMEMBERS：获取set中的所有元素</li>
<li>SINTER key1 key2 … ：求key1与key2的交集</li>
</ul>
<p>例如两个集合：s1和s2:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ha8x86R.png"></p>
<p>求交集：SINTER s1 s2</p>
<p>求s1与s2的不同：SDIFF s1 s2</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/L9vTv2X.png"></p>
<p>练习：</p>
<ol>
<li>将下列数据用Redis的Set集合来存储：</li>
</ol>
<ul>
<li>张三的好友有：李四、王五、赵六</li>
<li>李四的好友有：王五、麻子、二狗</li>
</ul>
<ol start="2">
<li>利用Set的命令实现下列功能：</li>
</ol>
<ul>
<li>计算张三的好友有几人</li>
<li>计算张三和李四有哪些共同好友</li>
<li>查询哪些人是张三的好友却不是李四的好友</li>
<li>查询张三和李四的好友总共有哪些人</li>
<li>判断李四是否是张三的好友</li>
<li>判断张三是否是李四的好友</li>
<li>将李四从张三的好友列表中移除</li>
</ul>
<h2 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个<strong>score</strong>属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p>
<p>SortedSet具备下列特性：</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p>
<p>SortedSet的常见命令有：</p>
<ul>
<li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li>
<li>ZREM key member：删除sorted set中的一个指定元素</li>
<li>ZSCORE key member : 获取sorted set中的指定元素的score值</li>
<li>ZRANK key member：获取sorted set 中的指定元素的排名</li>
<li>ZCARD key：获取sorted set中的元素个数</li>
<li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li>
<li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li>
<li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li>
<li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li>
<li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li>
</ul>
<p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p>
<ul>
<li><p><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</p>
</li>
<li><p><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</p>
</li>
</ul>
<p>REVERSE</p>
<p>练习题：</p>
<p>将班级的下列学生得分存入Redis的SortedSet中：</p>
<p>Jack 85, Lucy 89, Rose 82, Tom 95, Jerry 78, Amy 92, Miles 76</p>
<p>并实现下列功能：</p>
<ul>
<li>删除Tom同学</li>
<li>获取Amy同学的分数</li>
<li>获取Rose同学的排名</li>
<li>查询80分以下有几个学生</li>
<li>给Amy同学加2分</li>
<li>查出成绩前3名的同学</li>
<li>查出成绩80分以下的所有同学</li>
</ul>
<p>range 分数条件 </p>
<p>count 分数条件</p>
<h1 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h1><p>在Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/9f68ivq.png"></p>
<p>其中Java客户端也包含很多：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220609102817435-165735883948534.png" alt="image-20220609102817435"></p>
<p>标记为*的就是推荐使用的java客户端，包括：</p>
<ul>
<li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。</li>
<li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。</li>
</ul>
<h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>Jedis的官网地址： <a href="https://github.com/redis/jedis">https://github.com/redis/jedis</a></p>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>我们先来个快速入门：</p>
<p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--jedis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>建立连接</p>
<p>新建一个单元测试类，内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.建立连接</span></span><br><span class="line">    <span class="comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span></span><br><span class="line">    jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">    <span class="comment">// 2.设置密码</span></span><br><span class="line">    jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.选择库</span></span><br><span class="line">    jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 存入数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 插入hash数据</span></span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取</span></span><br><span class="line">    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>释放资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.jedis.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig, <span class="string">&quot;192.168.150.101&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>, <span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心线程数 线程最大数 多余线程自动销毁时间 多余线程自动销毁时间单位 阻塞队列BlockingQueue  拒绝策略abortPolicy 线程工厂</p>
<h2 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p>
<ul>
<li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li>
<li>提供了RedisTemplate统一API来操作Redis</li>
<li>支持Redis的发布订阅模型</li>
<li>支持Redis哨兵和Redis集群</li>
<li>支持基于Lettuce的响应式编程</li>
<li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li>
<li>支持基于Redis的JDKCollection实现</li>
</ul>
<p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/UFlNIV0.png"></p>
<h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><p>SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单。</p>
<p>首先，新建一个maven项目，然后按照下面步骤执行：</p>
<h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redis-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>redis-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Jackson依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="配置Redis"><a href="#配置Redis" class="headerlink" title="配置Redis"></a>配置Redis</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br></pre></td></tr></table></figure>



<h4 id="注入RedisTemplate"><a href="#注入RedisTemplate" class="headerlink" title="注入RedisTemplate"></a>注入RedisTemplate</h4><p>因为有了SpringBoot的自动装配，我们可以拿来就用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="编写测试"><a href="#编写测试" class="headerlink" title="编写测试"></a>编写测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate edisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入一条String数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取string数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h3><p>RedisTemplate可以接收任意Object作为值写入Redis：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/OEMcbuu.png"></p>
<p>一种方法，redistemplate指定泛型，</p>
<p>另外一种，Redis</p>
<p>只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/5FjtWk5.png"></p>
<p>缺点：</p>
<ul>
<li>可读性差</li>
<li>内存占用较大</li>
</ul>
<p>我们可以自定义RedisTemplate的序列化方式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> </span><br><span class="line">            							<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/XOAq3cN.png"></p>
<p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</p>
<h3 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h3><p>为了节省内存空间，我们可以不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Ip9TKSY.png"></p>
<p>因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis了。</p>
<p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/zXH6Qn6.png"></p>
<p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="comment">// JSON序列化工具</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;虎哥&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 手动序列化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">    <span class="comment">// 手动反序列化</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="OperationsForHash"><a href="#OperationsForHash" class="headerlink" title="OperationsForHash"></a>OperationsForHash</h3><p>entries(key) 所有键值对</p>
<p>keys(key) key的所有field</p>
<p>values(key)key的所有value</p>
<p>put(key,field,value)</p>
<p>get(key,field)</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>认真的 Netty 源码解析（二）(转自JavaDoop)</title>
    <url>/2018/11/03/netty-2/</url>
    <content><![CDATA[<h2 id="Channel-的-register-操作"><a href="#Channel-的-register-操作" class="headerlink" title="Channel 的 register 操作"></a>Channel 的 register 操作</h2><p>经过前面的铺垫，我们已经具备一定的基础了，我们开始来把前面学到的内容揉在一起。这节，我们会介绍 register 操作，这一步其实是非常关键的，对于我们源码分析非常重要。</p>
<h3 id="register"><a href="#register" class="headerlink" title="register"></a>register</h3><p>我们从 EchoClient 中的 connect() 方法出发，或者 EchoServer 的 bind(port) 方法出发，都会走到 initAndRegister() 这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        <span class="comment">// 2 对于 Bootstrap 和 ServerBootstrap，这里面有些不一样</span></span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 3 我们这里要说的是这行</span></span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>initAndRegister() 这个方法我们已经接触过两次了，前面介绍了 1️⃣ Channel 的实例化，实例化过程中，会执行 Channel 内部 Unsafe 和 Pipeline 的实例化，以及在上面 2️⃣ init(channel) 方法中，会往 pipeline 中添加 handler（pipeline 此时是 head+channelnitializer+tail）。</p>
<blockquote>
<p>我们这节终于要揭秘 ChannelInitializer 中的 initChannel 方法了~~~</p>
</blockquote>
<p>现在，我们继续往下走，看看 3️⃣ <strong>register</strong> 这一步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> config().group().register(channel);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们说了，register 这一步是非常关键的，它发生在 channel 实例化以后，大家回忆一下当前 channel 中的一些情况：</p>
<p>实例化了 JDK 底层的 Channel，设置了非阻塞，实例化了 Unsafe，实例化了 Pipeline，同时往 pipeline 中添加了 head、tail 以及一个 ChannelInitializer 实例。</p>
</blockquote>
<p>上面的 <code>config().group()</code> 方法会返回前面实例化的 NioEventLoopGroup 的实例，然后调用其 register(channel) 方法：</p>
<p>// MultithreadEventLoopGroup</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> next().register(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>next() 方法很简单，就是选择线程池中的一个线程（还记得 chooserFactory 吗），也就是选择一个 NioEventLoop 实例，这个时候我们就进入到 NioEventLoop 了。</p>
<p>NioEventLoop 的 register(channel) 方法实现在它的父类 <strong>SingleThreadEventLoop</strong> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> register(<span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(channel, <span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码实例化了一个 Promise，将当前 channel 带了进去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">&quot;promise&quot;</span>);</span><br><span class="line">    <span class="comment">// promise 关联了 channel，channel 持有 Unsafe 实例，register 操作就封装在 Unsafe 中</span></span><br><span class="line">    promise.channel().unsafe().register(<span class="built_in">this</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到 channel 中关联的 Unsafe 实例，然后调用它的 register 方法：</p>
<blockquote>
<p>我们说过，Unsafe 专门用来封装底层实现，当然这里也没那么“底层”</p>
</blockquote>
<p>// AbstractChannel#<strong>AbstractUnsafe</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将这个 eventLoop 实例设置给这个 channel，从此这个 channel 就是有 eventLoop 的了</span></span><br><span class="line">    <span class="comment">// 我觉得这一步其实挺关键的，因为后续该 channel 中的所有异步操作，都要提交给这个 eventLoop 来执行</span></span><br><span class="line">    AbstractChannel.<span class="built_in">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果发起 register 动作的线程就是 eventLoop 实例中的线程，那么直接调用 register0(promise)</span></span><br><span class="line">    <span class="comment">// 对于我们来说，它不会进入到这个分支，</span></span><br><span class="line">    <span class="comment">//     之所以有这个分支，是因为我们是可以 unregister，然后再 register 的，后面再仔细看</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，提交任务给 eventLoop，eventLoop 中的线程会负责调用 register0(promise)</span></span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>到这里，我们要明白，NioEventLoop 中是还没有实例化 Thread 实例的。</p>
</blockquote>
<p>这几步涉及到了好几个类：NioEventLoop、Promise、Channel、Unsafe 等，大家要仔细理清楚它们的关系。</p>
<p>对于我们前面过来的 register 操作，其实提交到 eventLoop 以后，就直接返回 promise 实例了，剩下的register0 是异步操作，它由 NioEventLoop 实例来完成。</p>
<p>我们这边先不继续往里分析 register0(promise) 方法，先把前面欠下的 NioEventLoop 中的线程介绍清楚，然后再回来介绍这个 register0 方法。</p>
<blockquote>
<p>Channel 实例一旦 register 到了 NioEventLoopGroup 实例中的某个 NioEventLoop 实例，那么后续该 Channel 的所有操作，都是由该 NioEventLoop 实例来完成的。</p>
<p>这个也非常简单，因为 Selector 实例是在 NioEventLoop 实例中的，Channel 实例一旦注册到某个 Selector 实例中，当然也只能在这个实例中处理 NIO 事件。</p>
</blockquote>
<h3 id="NioEventLoop-工作流程"><a href="#NioEventLoop-工作流程" class="headerlink" title="NioEventLoop 工作流程"></a>NioEventLoop 工作流程</h3><p>前面，我们在分析线程池的实例化的时候说过，NioEventLoop 中并没有启动 Java 线程。这里我们来仔细分析下在 register 过程中调用的 <strong>eventLoop.execute(runnable)</strong> 这个方法，这个代码在父类 SingleThreadEventExecutor 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 判断添加任务的线程是否就是当前 EventLoop 中的线程</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">inEventLoop</span> <span class="operator">=</span> inEventLoop();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加任务到之前介绍的 taskQueue 中，</span></span><br><span class="line">    <span class="comment">// 	如果 taskQueue 满了(默认大小 16)，根据我们之前说的，默认的策略是抛出异常</span></span><br><span class="line">    addTask(task);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">        <span class="comment">// 如果不是 NioEventLoop 内部线程提交的 task，那么判断下线程是否已经启动，没有的话，就启动线程</span></span><br><span class="line">        startThread();</span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原来启动 NioEventLoop 中的线程的方法在这里。</p>
<p>另外，上节我们说的 register 操作进到了 taskQueue 中，所以它其实是被归类到了非 IO 操作的范畴。</p>
</blockquote>
<p>下面是 startThread 的源码，判断线程是否已经启动来决定是否要进行启动操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="built_in">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                doStartThread();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">                STATE_UPDATER.set(<span class="built_in">this</span>, ST_NOT_STARTED);</span><br><span class="line">                PlatformDependent.throwException(cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们按照前面的思路，根据线程没有启动的情况，来看看 doStartThread() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doStartThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> thread == <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 这里的 executor 大家是不是有点熟悉的感觉，它就是一开始我们实例化 NioEventLoop 的时候传进来的 ThreadPerTaskExecutor 的实例。它是每次来一个任务，创建一个线程的那种 executor。</span></span><br><span class="line">    <span class="comment">// 一旦我们调用它的 execute 方法，它就会创建一个新的线程，所以这里终于会创建 Thread 实例</span></span><br><span class="line">    executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 看这里，将 “executor” 中创建的这个线程设置为 NioEventLoop 的线程！！！</span></span><br><span class="line">            thread = Thread.currentThread();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            updateLastExecutionTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行 SingleThreadEventExecutor 的 run() 方法，它在 NioEventLoop 中实现了</span></span><br><span class="line">                SingleThreadEventExecutor.<span class="built_in">this</span>.run();</span><br><span class="line">                success = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Unexpected exception from an event executor: &quot;</span>, t);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// ... 我们直接忽略掉这里的代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面线程启动以后，会执行 NioEventLoop 中的 run() 方法，这是一个<strong>非常重要</strong>的方法，这个方法肯定是没那么容易结束的，必然是像 JDK 线程池的 Worker 那样，不断地循环获取新的任务的。它需要不断地做 select 操作和轮询 taskQueue 这个队列。</p>
<p>我们先来简单地看一下它的源码，这里先不做深入地介绍：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 代码嵌套在 for 循环中</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// selectStrategy 终于要派上用场了</span></span><br><span class="line">            <span class="comment">// 它有两个值，一个是 CONTINUE 一个是 SELECT</span></span><br><span class="line">            <span class="comment">// 针对这块代码，我们分析一下。</span></span><br><span class="line">            <span class="comment">// 1. 如果 taskQueue 不为空，也就是 hasTasks() 返回 true，</span></span><br><span class="line">            <span class="comment">// 		那么执行一次 selectNow()，该方法不会阻塞</span></span><br><span class="line">            <span class="comment">// 2. 如果 hasTasks() 返回 false，那么执行 SelectStrategy.SELECT 分支，</span></span><br><span class="line">            <span class="comment">//    进行 select(...)，这块是带阻塞的</span></span><br><span class="line">            <span class="comment">// 这个很好理解，就是按照是否有任务在排队来决定是否可以进行阻塞</span></span><br><span class="line">            <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                    <span class="comment">// 如果 !hasTasks()，那么进到这个 select 分支，这里 select 带阻塞的</span></span><br><span class="line">                    select(wakenUp.getAndSet(<span class="literal">false</span>));</span><br><span class="line">                    <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                        selector.wakeup();</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 默认地，ioRatio 的值是 50</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ioRatio</span> <span class="operator">=</span> <span class="built_in">this</span>.ioRatio;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 ioRatio 设置为 100，那么先执行 IO 操作，然后在 finally 块中执行 taskQueue 中的任务</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1. 执行 IO 操作。因为前面 select 以后，可能有些 channel 是需要处理的。</span></span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 2. 执行非 IO 任务，也就是 taskQueue 中的任务</span></span><br><span class="line">                    runAllTasks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果 ioRatio 不是 100，那么根据 IO 操作耗时，限制非 IO 操作耗时</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioStartTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行 IO 操作</span></span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 根据 IO 操作消耗的时间，计算执行非 IO 操作（runAllTasks）可以用多少时间.</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioTime</span> <span class="operator">=</span> System.nanoTime() - ioStartTime;</span><br><span class="line">                    runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Always handle shutdown even if the loop processing threw an exception.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                closeAll();</span><br><span class="line">                <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码是 NioEventLoop 的核心，这里介绍两点：</p>
<ol>
<li>首先，会根据 hasTasks() 的结果来决定是执行 selectNow() 还是 select(oldWakenUp)，这个应该好理解。如果有任务正在等待，那么应该使用无阻塞的 selectNow()，如果没有任务在等待，那么就可以使用带阻塞的 select 操作。</li>
<li>ioRatio 控制 IO 操作所占的时间比重：<ul>
<li>如果设置为 100%，那么先执行 IO 操作，然后再执行任务队列中的任务。</li>
<li>如果不是 100%，那么先执行 IO 操作，然后执行 taskQueue 中的任务，但是需要控制执行任务的总时间。也就是说，非 IO 操作可以占用的时间，通过 ioRatio 以及这次 IO 操作耗时计算得出。</li>
</ul>
</li>
</ol>
<p>我们这里先不要去关心 select(oldWakenUp)、processSelectedKeys() 方法和 runAllTasks(…) 方法的细节，只要先理解它们分别做什么事情就可以了。</p>
<p>回过神来，我们前面在 register 的时候提交了 register 任务给 NioEventLoop，这是 NioEventLoop 接收到的第一个任务，所以这里会实例化 Thread 并且启动，然后进入到 NioEventLoop 中的 run 方法。</p>
<h3 id="继续-register"><a href="#继续-register" class="headerlink" title="继续 register"></a>继续 register</h3><p>我们回到前面的 register0(promise) 方法，我们知道，这个 register 任务进入到了 NioEventLoop 的 taskQueue 中，然后会启动 NioEventLoop 中的线程，该线程会轮询这个 taskQueue，然后执行这个 register 任务。</p>
<p>注意，此时执行该方法的是 eventLoop 中的线程：</p>
<p>// AbstractChannel</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register0</span><span class="params">(ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		...</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">firstRegistration</span> <span class="operator">=</span> neverRegistered;</span><br><span class="line">        <span class="comment">// *** 进行 JDK 底层的操作：Channel 注册到 Selector 上 ***</span></span><br><span class="line">        doRegister();</span><br><span class="line">        </span><br><span class="line">        neverRegistered = <span class="literal">false</span>;</span><br><span class="line">        registered = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 到这里，就算是 registered 了</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这一步也很关键，因为这涉及到了 ChannelInitializer 的 init(channel)</span></span><br><span class="line">        <span class="comment">// 我们之前说过，init 方法会将 ChannelInitializer 内部添加的 handlers 添加到 pipeline 中</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置当前 promise 的状态为 success</span></span><br><span class="line">        <span class="comment">//   因为当前 register 方法是在 eventLoop 中的线程中执行的，需要通知提交 register 操作的线程</span></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当前的 register 操作已经成功，该事件应该被 pipeline 上</span></span><br><span class="line">        <span class="comment">//   所有关心 register 事件的 handler 感知到，往 pipeline 中扔一个事件</span></span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里 active 指的是 channel 已经打开</span></span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="comment">// 如果该 channel 是第一次执行 register，那么 fire ChannelActive 事件</span></span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                <span class="comment">// 该 channel 之前已经 register 过了，</span></span><br><span class="line">                <span class="comment">// 这里让该 channel 立马去监听通道中的 OP_READ 事件</span></span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先说掉上面的 doRegister() 方法，然后再说 pipeline。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">selected</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 附 JDK 中 Channel 的 register 方法：</span></span><br><span class="line">            <span class="comment">// public final SelectionKey register(Selector sel, int ops, Object att) &#123;...&#125;</span></span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这里做了 JDK 底层的 register 操作，将 SocketChannel(或 ServerSocketChannel) 注册到 Selector 中，并且可以看到，这里的监听集合设置为了 <strong>0</strong>，也就是什么都不监听。</p>
<blockquote>
<p>当然，也就意味着，后续一定有某个地方会需要修改这个 selectionKey 的监听集合，不然啥都干不了</p>
</blockquote>
<p>我们重点来说说 <strong>pipeline</strong> 操作，我们之前在介绍 NioSocketChannel 的 pipeline 的时候介绍到，我们的 pipeline 现在长这个样子：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/20.png" alt="20"></p>
<blockquote>
<p>现在，我们将看到这里会把 LoggingHandler 和 EchoClientHandler 添加到 pipeline。</p>
</blockquote>
<p>我们继续看代码，register 成功以后，执行了以下操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pipeline.invokeHandlerAddedIfNeeded();</span><br></pre></td></tr></table></figure>

<p>大家可以跟踪一下，这一步会执行到 pipeline 中 ChannelInitializer 实例的 handlerAdded 方法，在这里会执行它的 init(context) 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.channel().isRegistered()) &#123;</span><br><span class="line">        initChannel(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们看下 initChannel(ctx)，这里终于来了我们之前介绍过的 init(channel) 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (initMap.putIfAbsent(ctx, Boolean.TRUE) == <span class="literal">null</span>) &#123; <span class="comment">// Guard against re-entrance.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 将把我们自定义的 handlers 添加到 pipeline 中</span></span><br><span class="line">            initChannel((C) ctx.channel());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 将 ChannelInitializer 实例从 pipeline 中删除</span></span><br><span class="line">            remove(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们前面也说过，ChannelInitializer 的 init(channel) 被执行以后，那么其内部添加的 handlers 会进入到 pipeline 中，然后上面的 finally 块中将 ChannelInitializer 的实例从 pipeline 中删除，那么此时 pipeline 就算建立起来了，如下图：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/21.png" alt="21"></p>
<blockquote>
<p>其实这里还有个问题，如果我们在 ChannelInitializer 中添加的是一个 ChannelInitializer 实例呢？大家可以考虑下这个情况。</p>
</blockquote>
<p>pipeline 建立了以后，然后我们继续往下走，会执行到这一句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pipeline.fireChannelRegistered();</span><br></pre></td></tr></table></figure>

<p>我们只要摸清楚了 fireChannelRegistered() 方法，以后碰到其他像 fireChannelActive()、fireXxx() 等就知道怎么回事了，它们都是类似的。我们来看看这句代码会发生什么：</p>
<p>// DefaultChannelPipeline</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title function_">fireChannelRegistered</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 注意这里的传参是 head</span></span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelRegistered(head);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，我们往 pipeline 中扔了一个 <strong>channelRegistered</strong> 事件，这里的 register 属于 Inbound 事件，pipeline 接下来要做的就是执行 pipeline 中的 Inbound 类型的 handlers 中的 channelRegistered() 方法。</p>
<p>从上面的代码，我们可以看出，往 pipeline 中扔出 channelRegistered 事件以后，第一个处理的 handler 是 <strong>head</strong>。</p>
<p>接下来，我们还是跟着代码走，此时我们来到了 pipeline 的第一个节点 <strong>head</strong> 的处理中：</p>
<p>// AbstractChannelHandlerContext</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// next 此时是 head</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeChannelRegistered</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">    <span class="comment">// 执行 head 的 invokeChannelRegistered()</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRegistered();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                next.invokeChannelRegistered();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，这里会先执行 head.invokeChannelRegistered() 方法，而且是放到 NioEventLoop 中的 taskQueue 中执行的：</p>
<p>// AbstractChannelHandlerContext</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeChannelRegistered</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// handler() 方法此时会返回 head</span></span><br><span class="line">            ((ChannelInboundHandler) handler()).channelRegistered(<span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            notifyHandlerException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fireChannelRegistered();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们去看 head 的 channelRegistered 方法：</p>
<p>// HeadContext</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1. 这一步是 head 对于 channelRegistered 事件的处理。没有我们要关心的</span></span><br><span class="line">    invokeHandlerAddedIfNeeded();</span><br><span class="line">    <span class="comment">// 2. 向后传播 Inbound 事件</span></span><br><span class="line">    ctx.fireChannelRegistered();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 head 会执行 fireChannelRegister() 方法：</p>
<p>// AbstractChannelHandlerContext</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelHandlerContext <span class="title function_">fireChannelRegistered</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这里很关键</span></span><br><span class="line">    <span class="comment">// findContextInbound() 方法会沿着 pipeline 找到下一个 Inbound 类型的 handler</span></span><br><span class="line">    invokeChannelRegistered(findContextInbound());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：pipeline.fireChannelRegistered() 是将 channelRegistered 事件抛到 pipeline 中，pipeline 中的 handlers 准备处理该事件。而 context.fireChannelRegistered() 是一个 handler 处理完了以后，向后传播给下一个 handler。</p>
<p>它们两个的方法名字是一样的，但是来自于不同的类。</p>
</blockquote>
<p>findContextInbound() 将找到下一个 Inbound 类型的 handler，然后又是重复上面的几个方法。</p>
<blockquote>
<p>我觉得上面这块代码没必要太纠结，总之就是从 head 中开始，依次往下寻找所有 Inbound handler，执行其 channelRegistered(ctx) 操作。</p>
</blockquote>
<p>说了这么多，我们的 register 操作算是真正完成了。</p>
<p>下面，我们回到 initAndRegister 这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们上面说完了这行</span></span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> config().group().register(channel);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果在 register 的过程中，发生了错误</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 源码中说得很清楚，如果到这里，说明后续可以进行 connect() 或 bind() 了，因为两种情况：</span></span><br><span class="line">    <span class="comment">// 1. 如果 register 动作是在 eventLoop 中发起的，那么到这里的时候，register 一定已经完成</span></span><br><span class="line">    <span class="comment">// 2. 如果 register 任务已经提交到 eventLoop 中，也就是进到了 eventLoop 中的 taskQueue 中，</span></span><br><span class="line">    <span class="comment">//    由于后续的 connect 或 bind 也会进入到同一个 eventLoop 的 queue 中，所以一定是会先 register 成功，才会执行 connect 或 bind</span></span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要知道，不管是服务端的 NioServerSocketChannel 还是客户端的 NioSocketChannel，在 bind 或 connect 时，都会先进入 initAndRegister 这个方法，所以我们上面说的那些，对于两者都是通用的。</p>
<p>大家要记住，register 操作是非常重要的，要知道这一步大概做了哪些事情，register 操作以后，将进入到 bind 或 connect 操作中。</p>
<h2 id="connect-过程和-bind-过程分析"><a href="#connect-过程和-bind-过程分析" class="headerlink" title="connect 过程和 bind 过程分析"></a>connect 过程和 bind 过程分析</h2><p>上面我们介绍的 register 操作非常关键，它建立起来了很多的东西，它是 Netty 中 NioSocketChannel 和 NioServerSocketChannel 开始工作的起点。</p>
<p>这一节，我们来说说 register 之后的 connect 操作和 bind 操作。这节非常简单。</p>
<h3 id="connect-过程分析"><a href="#connect-过程分析" class="headerlink" title="connect 过程分析"></a>connect 过程分析</h3><p>对于客户端 NioSocketChannel 来说，前面 register 完成以后，就要开始 connect 了，这一步将连接到服务端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">doResolveAndConnect</span><span class="params">(<span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里完成了 register 操作</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> regFuture.channel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里我们不去纠结 register 操作是否 isDone()</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!regFuture.isSuccess()) &#123;</span><br><span class="line">            <span class="keyword">return</span> regFuture;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 看这里</span></span><br><span class="line">        <span class="keyword">return</span> doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里大家自己一路点进去，我就不浪费篇幅了。最后，我们会来到 AbstractChannel 的 connect 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">connect</span><span class="params">(SocketAddress remoteAddress, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.connect(remoteAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，connect 操作是交给 pipeline 来执行的。进入 pipeline 中，我们会发现，connect 这种 Outbound 类型的操作，是从 pipeline 的 tail 开始的：</p>
<blockquote>
<p>前面我们介绍的 register 操作是 Inbound 的，是从 head 开始的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title function_">connect</span><span class="params">(SocketAddress remoteAddress, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tail.connect(remoteAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是 pipeline 的操作了，从 tail 开始，执行 pipeline 上的 Outbound 类型的 handlers 的 connect(…) 方法，那么真正的底层的 connect 的操作发生在哪里呢？还记得我们的 pipeline 的图吗？</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/22.png" alt="22"></p>
<p>从 tail 开始往前找 out 类型的 handlers，每经过一个 handler，都执行里面的 connect() 方法，最后会到 head 中，因为 head 也是 Outbound 类型的，我们需要的 connect 操作就在 head 中，它会负责调用 unsafe 中提供的 connect 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HeadContext</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(</span></span><br><span class="line"><span class="params">        ChannelHandlerContext ctx,</span></span><br><span class="line"><span class="params">        SocketAddress remoteAddress, SocketAddress localAddress,</span></span><br><span class="line"><span class="params">        ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    unsafe.connect(remoteAddress, localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们来看一看 connect 在 unsafe 类中所谓的底层操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractNioChannel.AbstractNioUnsafe</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">		......</span><br><span class="line">            </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">wasActive</span> <span class="operator">=</span> isActive();</span><br><span class="line">        <span class="comment">// 大家自己点进去看 doConnect 方法</span></span><br><span class="line">        <span class="comment">// 这一步会做 JDK 底层的 SocketChannel connect，然后设置 interestOps 为 SelectionKey.OP_CONNECT</span></span><br><span class="line">        <span class="comment">// 返回值代表是否已经连接成功</span></span><br><span class="line">        <span class="keyword">if</span> (doConnect(remoteAddress, localAddress)) &#123;</span><br><span class="line">            <span class="comment">// 处理连接成功的情况</span></span><br><span class="line">            fulfillConnectPromise(promise, wasActive);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            connectPromise = promise;</span><br><span class="line">            requestedRemoteAddress = remoteAddress;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面这块代码，在处理连接超时的情况，代码很简单</span></span><br><span class="line">            <span class="comment">// 这里用到了 NioEventLoop 的定时任务的功能，这个我们之前一直都没有介绍过，因为我觉得也不太重要</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">connectTimeoutMillis</span> <span class="operator">=</span> config().getConnectTimeoutMillis();</span><br><span class="line">            <span class="keyword">if</span> (connectTimeoutMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                connectTimeoutFuture = eventLoop().schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="type">ChannelPromise</span> <span class="variable">connectPromise</span> <span class="operator">=</span> AbstractNioChannel.<span class="built_in">this</span>.connectPromise;</span><br><span class="line">                        <span class="type">ConnectTimeoutException</span> <span class="variable">cause</span> <span class="operator">=</span></span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">ConnectTimeoutException</span>(<span class="string">&quot;connection timed out: &quot;</span> + remoteAddress);</span><br><span class="line">                        <span class="keyword">if</span> (connectPromise != <span class="literal">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;</span><br><span class="line">                            close(voidPromise());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            promise.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">if</span> (future.isCancelled()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (connectTimeoutFuture != <span class="literal">null</span>) &#123;</span><br><span class="line">                            connectTimeoutFuture.cancel(<span class="literal">false</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        connectPromise = <span class="literal">null</span>;</span><br><span class="line">                        close(voidPromise());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        promise.tryFailure(annotateConnectException(t, remoteAddress));</span><br><span class="line">        closeIfClosed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上面的 doConnect 方法返回 false，那么后续是怎么处理的呢？</p>
<p>在上一节介绍的 register 操作中，channel 已经 register 到了 selector 上，只不过将 interestOps 设置为了 0，也就是什么都不监听。</p>
<p>而在上面的 doConnect 方法中，我们看到它在调用底层的 connect 方法后，会设置 interestOps 为 <code>SelectionKey.OP_CONNECT</code>。</p>
<p>剩下的就是 NioEventLoop 的事情了，还记得 NioEventLoop 的 run() 方法吗？也就是说这里的 connect 成功以后，这个 TCP 连接就建立起来了，后续的操作会在 <code>NioEventLoop.run()</code> 方法中被 <code>processSelectedKeys()</code> 方法处理掉。</p>
<h3 id="bind-过程分析"><a href="#bind-过程分析" class="headerlink" title="bind 过程分析"></a>bind 过程分析</h3><p>说完 connect 过程，我们再来简单看下 bind 过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class="line">    <span class="comment">// **前面说的 initAndRegister**</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> initAndRegister();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        <span class="comment">// register 动作已经完成，那么执行 bind 操作</span></span><br><span class="line">        <span class="type">ChannelPromise</span> <span class="variable">promise</span> <span class="operator">=</span> channel.newPromise();</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后一直往里看，会看到，bind 操作也是要由 pipeline 来完成的：</p>
<p>// AbstractChannel</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bind 操作和 connect 一样，都是 Outbound 类型的，所以都是 tail 开始：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title function_">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tail.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的 bind 操作又到了 head 中，由 head 来调用 unsafe 提供的 bind 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(</span></span><br><span class="line"><span class="params">        ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    unsafe.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>感兴趣的读者自己去看一下 unsafe 中的 bind 方法，非常简单，bind 操作也不是什么异步方法，我们就介绍到这里了。</p>
<p>本节非常简单，就是想和大家介绍下 Netty 中各种操作的套路。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 数据结构 网络模型</title>
    <url>/2024/08/13/redis-source-code/</url>
    <content><![CDATA[<h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><h3 id="动态字符串SDS"><a href="#动态字符串SDS" class="headerlink" title="动态字符串SDS"></a>动态字符串SDS</h3><p>我们都知道Redis中保存的Key是字符串，value往往是字符串或者字符串的集合。可见字符串是Redis中最常用的一种数据结构。</p>
<p>不过Redis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题：<br>获取字符串长度的需要通过运算<br>非二进制安全<br>不可修改<br>Redis构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称SDS。<br>例如，我们执行命令：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653984583289.png" alt="1653984583289"></p>
<p>那么Redis将在底层创建两个SDS，其中一个是包含“name”的SDS，另一个是包含“虎哥”的SDS。</p>
<p>Redis是C语言实现的，其中SDS是一个结构体，源码如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653984624671.png" alt="1653984624671"></p>
<p>例如，一个包含字符串“name”的sds结构如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653984648404.png" alt="1653984648404"></p>
<p>SDS之所以叫做动态字符串，是因为它具备动态扩容的能力，例如一个内容为“hi”的SDS：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653984787383.png" alt="1653984787383"></p>
<p>假如我们要给SDS追加一段字符串“,Amy”，这里首先会申请新内存空间：</p>
<ul>
<li><p>如果新字符串小于1M，则新空间为扩展后字符串长度的两倍+1；</p>
</li>
<li><p>如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1。</p>
</li>
<li><p>称为内存预分配，减少分配次数，且二进制安全。</p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653984822363.png" alt="1653984822363"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653984838306.png" alt="1653984838306"></p>
<h3 id="Intset"><a href="#Intset" class="headerlink" title="Intset"></a>Intset</h3><h4 id="复习C语言数据类型"><a href="#复习C语言数据类型" class="headerlink" title="复习C语言数据类型"></a>复习C语言数据类型</h4><blockquote>
<p><code>uint32_t</code> 是一种数据类型定义，常用于 C 和 C++ 语言中。它表示一个<strong>32位无符号整数</strong>类型，具体含义如下：</p>
<ol>
<li><strong>u</strong>：表示“unsigned”，即无符号。</li>
<li><strong>int</strong>：表示“整数”。</li>
<li><strong>32</strong>：表示占用的位数，即32位。</li>
<li><strong>_t</strong>：表示类型（type），是标准库中的约定后缀，用于区别基本数据类型的固定大小版本。</li>
</ol>
<p><strong><code>uint32_t</code>的特点：</strong></p>
<ul>
<li><strong>取值范围</strong>：因为是无符号的，它可以存储从 0 到 (2^{32} - 1) 的整数，即 0 到 4,294,967,295。</li>
<li><strong>固定宽度</strong>：<code>uint32_t</code> 由标准库 <code>stdint.h</code>（C99 标准）或 <code>cstdint</code>（C++11 标准）提供，确保跨平台的一致性。在不同平台和编译器上，它总是占用 32 位（4 字节）的存储空间，因此适用于需要精确控制数据大小的场景，如嵌入式编程和网络协议设计。</li>
</ul>
<p><strong>用法示例：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> num = <span class="number">4294967295</span>; <span class="comment">// 最大值 4,294,967,295</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;num = %u\n&quot;</span>, num);</span><br></pre></td></tr></table></figure>

<p>这种类型定义可以确保在不同硬件架构下，程序行为的一致性，是一种便携的写法。</p>
</blockquote>
<blockquote>
<p><code>int8_t</code> 是 C 和 C++ 语言中定义的一种数据类型，表示一个<strong>8位有符号整数</strong>。它也是在 <code>stdint.h</code>（C99 标准）或 <code>cstdint</code>（C++11 标准）中定义的类型，常用于需要精确控制整数大小的场景。下面是它的具体含义：</p>
<ol>
<li><strong>int</strong>：表示整数类型。</li>
<li><strong>8</strong>：表示这个整数类型占用 8 位（1 字节）。</li>
<li><strong>_t</strong>：是类型（type）的后缀，用于区别标准库中的固定宽度整数类型。</li>
</ol>
<p><strong><code>int8_t</code> 的特点：</strong></p>
<ul>
<li><strong>取值范围</strong>：因为是有符号整数，它的取值范围是 -128 到 127。<ul>
<li>负数范围：-128 到 -1</li>
<li>正数范围：0 到 127</li>
</ul>
</li>
<li><strong>固定宽度</strong>：<code>int8_t</code> 代表固定宽度的8位整数，不受平台影响，因此在不同编译器和硬件上始终占用 8 位（1 字节）。这种特性在嵌入式系统、网络协议和文件格式处理中很重要，因为它可以确保数据的大小和布局不变。</li>
</ul>
<p><strong>用法示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int8_t</span> temperature = <span class="number">-30</span>; <span class="comment">// 设置温度为 -30 摄氏度</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Temperature: %d\n&quot;</span>, temperature);</span><br></pre></td></tr></table></figure>

<p><code>int8_t</code> 和 <code>uint8_t</code>（8 位无符号整数）都是用于表示小范围的整数类型，通常在内存有限的系统中或者精确到字节操作的场景中广泛使用。</p>
</blockquote>
<h4 id="IntSet实现"><a href="#IntSet实现" class="headerlink" title="IntSet实现"></a>IntSet实现</h4><p>IntSet是Redis中set集合的一种实现方式，基于整数数组来实现，并且具备长度可变、有序等特征。<br>结构如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653984923322.png" alt="1653984923322"></p>
<p>其中的encoding包含三种模式，表示存储的整数大小不同：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653984942385.png" alt="1653984942385"></p>
<p>为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中，结构如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985149557.png" alt="1653985149557"></p>
<p>现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：<br>encoding：4字节<br>length：4字节<br>contents：2字节 * 3  = 6字节</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985197214.png" alt="1653985197214"></p>
<h5 id="有序与唯一"><a href="#有序与唯一" class="headerlink" title="有序与唯一"></a>有序与唯一</h5><p>我们向该其中添加一个数字：50000，这个数字超出了int16_t的范围，intset会自动升级编码方式到合适的大小。<br>以当前案例来说流程如下：</p>
<ul>
<li>升级编码为INTSET_ENC_INT32, 每个整数占4字节，并按照新的编码方式及元素个数扩容数组</li>
<li>倒序依次将数组中的元素拷贝到扩容后的正确位置</li>
<li>将待添加的元素放入数组末尾</li>
<li>最后，将inset的encoding属性改为INTSET_ENC_INT32，将length属性改为4</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985276621.png" alt="1653985276621"></p>
<p>源码如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985304075.png" alt="1653985304075"></p>
<p>普通插入：如果编码没有越界，先在set中查找，查找的过程中进行pos的赋值，大于max，pos=length，小于最小值，pos = 0，然后开始二分查找，pos的结果就是最后的mid/left ，查到就不插入，查不到就能进行插入</p>
<h5 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985327653.png" alt="1653985327653"></p>
<p>升级：新元素肯定在队首或队尾，倒序遍历把旧元素整体搬运，最后将新元素插入</p>
<h4 id="复习C语言指针"><a href="#复习C语言指针" class="headerlink" title="复习C语言指针"></a>复习C语言指针</h4><blockquote>
<p>指针: 本质就是一块连续内存区域的头地址。</p>
<p>字符数组: <code>char *p = &#123;&#39;b&#39;,&#39;r&#39;,&#39;a&#39;,&#39;i&#39;,&#39;n&#39;,&#39;\0&#39;&#125;;</code> 指针变量p指向字符数组(的头地址)</p>
<p>字符串数组: <code>char *array[] = &#123;&quot;abandon&quot;,&quot;brain&quot;,&quot;certain&quot;&#125;;</code> array是一个指针数组的头地址（指针的地址，也就是指针的指针——二级指针）</p>
<p>二级指针: <code>char **q = array;</code> q是指向指针的指针，也就是二级指针之间的直接赋值。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Intset可以看做是特殊的整数数组，具备一些特点：</p>
<ul>
<li>Redis会确保Intset中的元素唯一、有序</li>
<li>具备类型升级机制，可以节省内存空间</li>
<li>底层采用二分查找方式来查询</li>
</ul>
<h3 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h3><p>我们知道Redis是一个键值型（Key-Value Pair）的数据库，我们可以根据键实现快速的增删改查。而键与值的映射关系正是通过Dict来实现的。<br>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985396560.png" alt="1653985396560"> </p>
<p>当我们向Dict添加键值对时，Redis首先根据key计算出hash值（h），然后利用 h &amp; sizemask来计算元素应该存储到数组中的哪个索引位置。我们存储k1=v1，假设k1的哈希值h =1，则1&amp;3 =1，因此k1=v1要存储到数组角标1位置。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985497735.png" alt="1653985497735"></p>
<p>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985570612.png" alt="1653985570612"></p>
<h4 id="size-2-n"><a href="#size-2-n" class="headerlink" title="size = 2^n^"></a>size = 2^n^</h4><p><mark>size<mark></p>
<ul>
<li><p>求余操作实际上就是截取低位，十进制如果除以10的n次方就是直接截取低位，而对于计算机二进制明显更有效率，所以截取二进制的低n位</p>
</li>
<li><p>size = 2^n^ sizemask = 2^n^ - 1</p>
</li>
<li><p>Hash % size 相当于截取自己的低n位，而要想获取低n位，最简单的办法就是拿n个1跟Hash进行与操作</p>
</li>
<li><p>Hash &amp; sizemask  = Hash % size</p>
</li>
<li><p>当哈希表的大小是2的n次方时，哈希函数能够更好地将数据分布在哈希表的各个位置上，从而减少哈希冲突的概率。<code>capacity - 1</code> 的二进制表示全部为 1（如 15 为 1111），这样能让低位的哈希值充分参与运算，最大程度分散数据，降低冲突概率。</p>
</li>
<li><p><strong>负载因子调整</strong>： 在很多哈希表实现中（如Java的 <code>HashMap</code> 或 <code>Redis</code>），当负载因子超过一定阈值时，哈希表的大小会动态扩展。如果哈希表的大小是2的n次方，那么扩展时的大小也会是2的n次方（如从 16 扩展到 32），这使得扩展过程更加简单且高效。</p>
</li>
<li><p>最小是4 <code>DICT_HT_INITIAL_SIZE</code> </p>
</li>
</ul>
<h4 id="Entry-Table-Dict-数据结构"><a href="#Entry-Table-Dict-数据结构" class="headerlink" title="Entry Table Dict 数据结构"></a>Entry Table Dict 数据结构</h4><p><mark>dictEntry<mark></p>
<ul>
<li>dictEntry是自定义的一个数据结构，dictEntry *p 表示一个指向dictEntry的指针，指向分配给一个entry的连续内存区域的头地址，dictEntry是最底层的键值对元素</li>
</ul>
<p><mark>dictTable<mark></p>
<ul>
<li>dictEntry **table 就表示二级指针，这个指针指向entry指针，又因为指针指向的区域都是一片连续的内存区域，所以就是指针数组。dictTable本质是entry数组，根据key把键值对存到数组的对应索引处。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985586543.png" alt="1653985586543"></p>
<ul>
<li>发生冲突，采用链地址法解决</li>
</ul>
<p><mark>dict<mark> </p>
<ul>
<li>dict里有两个hashTable </li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985640422.png" alt="1653985640422"></p>
<ul>
<li>type 哈希函数的类型</li>
<li>ht 两张hashtable，多出的一张表用于rehash时数据的暂存</li>
<li>rehashidx，pauserehash rehash过程标记</li>
</ul>
<h4 id="Dict的伸缩"><a href="#Dict的伸缩" class="headerlink" title="Dict的伸缩"></a>Dict的伸缩</h4><p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。</p>
<p><mark>扩容<mark>：Dict在每次新增键值对时都会检查负载因子（LoadFactor = used/size） ，满足以下两种情况时会触发扩容：</p>
<ul>
<li>哈希表的<code>LoadFactor&gt;= 1</code>，并且服务器没有执行 BGSAVE(RDB持久化) 或者 BGREWRITEAOF(AOF持久化) 等后台进程；</li>
<li>哈希表的<code>LoadFactor &gt; 5</code>； </li>
</ul>
<p>扩容实际上扩到比used+1大的第一个2^n^ </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985716275.png" alt="1653985716275"></p>
<p><mark>收缩<mark>：SIZE&gt;4 &amp;&amp; LoadFactor &lt; 0.1 (used*100避免浮点运算 <code>HASHTABLE_MIN_FILL=10</code> )</p>
<p>实际上容量为比used大的第一个2^n^ （<code>used&gt;=4</code>）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241113202920178.png" alt="image-20241113202920178"></p>
<p><mark>DICTEXPAND<mark>这些实际上是申请了一个新的数组，如果不是初始化，还要rehash将旧数据装到新的数组中</p>
<p>rehashidx = 0，表示这个dict开始rehash</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241113205217079.png" alt="image-20241113205217079"></p>
<h4 id="Dict的渐进式rehash"><a href="#Dict的渐进式rehash" class="headerlink" title="Dict的渐进式rehash"></a><strong>Dict的渐进式rehash</strong></h4><p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必<mark>须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash<mark>。过程是这样的：</p>
<ul>
<li>计算新hash表的<code>realSize</code>，值取决于当前要做的是扩容还是收缩：<ul>
<li>如果是扩容，则<code>realSize</code>为第一个大于等于dict.ht[0].used + 1的2^n</li>
<li>如果是收缩，则<code>realSize</code>为第一个大于等于dict.ht[0].used的2^n （不得小于4）</li>
</ul>
</li>
<li>按照新的<code>realSize</code>申请内存空间，创建dictht，并赋值给dict.ht[1]</li>
<li>设置dict.<code>rehashidx</code> = 0，标示开始rehash</li>
<li><del>将dict.ht[0]中的每一个dictEntry都rehash到dict.ht[1]</del> </li>
<li><mark>在rehash过程中，增删改查操作都会检查dict是否处于rehash状态（rehashidx）<mark>新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht[0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash逐渐进行慢慢变成空数组</li>
<li>将dict.ht[1]赋值给dict.ht[0]，</li>
<li>给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存，并将<code>rehashidx</code>赋值为-1，代表rehash结束</li>
</ul>
<p>整个过程可以描述成：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985824540.png" alt="1653985824540"></p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>Dict的结构：</p>
<ul>
<li>类似java的HashTable，底层是数组加链表来解决哈希冲突（链地址法）</li>
<li>Dict包含两个哈希表，ht[0]平常用，ht[1]用来rehash</li>
</ul>
<p>Dict的伸缩：</p>
<ul>
<li>当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容</li>
<li>当LoadFactor小于0.1时，Dict收缩</li>
<li>扩容大小为第一个大于等于 <code>used + 1</code> 的2^n^</li>
<li>收缩大小为第一个大于等于 <code>used</code> 的2^n^ </li>
<li>Dict采用**<mark>渐进式<mark>**rehash，每次访问Dict时执行一次rehash</li>
<li>rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表</li>
</ul>
<h3 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h3><p><a href="https://juejin.cn/post/7093145133368999943">深入分析redis之quicklist，不一样的ziplist使用方式？ - 掘金 (juejin.cn)</a></p>
<p>ZipList 是一种特殊的“双端链表” ，由一系列特殊编码的<mark>连续内存块<mark>（不需要通过指针寻址）组成。可以在任意一端进行压入/弹出操作, 并且该操作的时间复杂度为 O(1)。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985987327.png" alt="1653985987327"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986020491.png" alt="1653986020491"></p>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>类型</strong></th>
<th><strong>长度</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td>4 字节</td>
<td>记录整个压缩列表占用的内存字节数</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td>4 字节</td>
<td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，可以确定表尾节点的地址。</td>
</tr>
<tr>
<td>zllen</td>
<td>uint16_t</td>
<td>2 字节</td>
<td>记录了压缩列表包含的节点个数。 最大值为UINT16_MAX （65534），如果超过这个值，此处会记录为65535，但节点的真实数量需要遍历整个压缩列表才能计算得出。</td>
</tr>
<tr>
<td>entry</td>
<td>列表节点</td>
<td>不定</td>
<td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td>
</tr>
<tr>
<td>zlend</td>
<td>uint8_t</td>
<td>1 字节</td>
<td>特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</td>
</tr>
</tbody></table>
<h4 id="ZipListEntry"><a href="#ZipListEntry" class="headerlink" title="ZipListEntry"></a><strong>ZipListEntry</strong></h4><p>ZipList 中的Entry并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16个字节，浪费内存。而是采用了下面的结构：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986055253.png" alt="1653986055253"></p>
<ul>
<li><p>previous_entry_length：前一节点的长度，占1个或5个字节。</p>
<ul>
<li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li>
<li>如果前一节点的长度大于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</li>
</ul>
</li>
<li><p>encoding：编码属性，记录content的数据类型（字符串还是整数）以及长度，占用1个、2个或5个字节</p>
</li>
<li><p>contents：负责保存节点的数据，可以是字符串或整数</p>
</li>
</ul>
<p><strong>正向遍历</strong>：current + sizeof(previous_entry_length) + sizeof(encoding) + encoding.contentLength</p>
<p><strong>逆向遍历</strong>：current - previous_entry_length</p>
<h5 id="大小端存储"><a href="#大小端存储" class="headerlink" title="大小端存储"></a>大小端存储</h5><p>ZipList中所有<mark>存储长度的数值：tlbytes,tltail,tllen,previous_entry_length<mark> 均采用<mark>小端字节序<mark>即低位字节在前，高位字节在后。例如：数值0x1234，采用小端字节序后实际存储值为：0x3412 </p>
<blockquote>
<p>LSB（Least Significant Byte）和MSB（Most Significant Byte）分别表示数据的最低有效字节和最高有效字节。它们在数据存储和处理时起到重要作用，尤其在大端字节序和小端字节序的不同存储方式中。</p>
<ul>
<li><strong>LSB（最低有效字节）</strong>：存储数据时，代表数据的最低有效字节，即值最小的字节。通常对应数据的最低位。</li>
<li><strong>MSB（最高有效字节）</strong>：存储数据时，代表数据的最高有效字节，即值最大的字节。通常对应数据的最高位。</li>
</ul>
<p>假设我们有一个4字节（32位）整数<code>0x12345678</code>，它的二进制表示为：</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="number">0001</span> <span class="number">0010</span> <span class="number">0011</span> <span class="number">0100</span> <span class="number">0101</span> <span class="number">0110</span> <span class="number">0111</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>我们将这个值从内存地址<code>0x1000</code>开始存储，来看不同字节序下 LSB 和 MSB 的位置。</p>
<p><strong>小端字节序存储</strong></p>
<p>在小端模式下，LSB 存放在最低地址，MSB 存放在最高地址。也就是说，低地址存放低位字节，高地址存放高位字节。从最低位开始存。</p>
<table>
<thead>
<tr>
<th>地址(Hex)</th>
<th>数据</th>
</tr>
</thead>
<tbody><tr>
<td>0x1000</td>
<td>78</td>
</tr>
<tr>
<td>0x1001</td>
<td>56</td>
</tr>
<tr>
<td>0x1002</td>
<td>34</td>
</tr>
<tr>
<td>0x1003</td>
<td>12</td>
</tr>
</tbody></table>
<p>在这种情况下，存储顺序为 <code>78 56 34 12</code>。</p>
<ul>
<li><p><strong>便于数值操作</strong>：在小端模式下，最低有效字节存放在最低地址，因此读取数值时，从低地址开始逐字节读取即可，省去了对字节顺序的额外处理。对于需要频繁数值计算的处理器（如x86架构），这种字节序更高效。</p>
</li>
<li><p><strong>简化某些数据类型的转换</strong>：例如，将16位的<code>short</code>扩展成32位的<code>int</code>，只需将高位填零，不需要移动低位数据。</p>
</li>
<li><p><strong>人类阅读不直观</strong>：小端模式存储的数据不符合从高到低的阅读习惯，直接查看数据时可能显得混乱。</p>
</li>
</ul>
<p><strong>大端字节序存储</strong></p>
<p>在大端模式下，MSB 存放在最低地址，LSB 存放在最高地址。也就是说，低地址存放高位字节，高地址存放低位字节。从最高位开始存</p>
<table>
<thead>
<tr>
<th>地址（Hex）</th>
<th>数据</th>
</tr>
</thead>
<tbody><tr>
<td>0x1000</td>
<td>12</td>
</tr>
<tr>
<td>0x1001</td>
<td>34</td>
</tr>
<tr>
<td>0x1002</td>
<td>56</td>
</tr>
<tr>
<td>0x1003</td>
<td>78</td>
</tr>
</tbody></table>
<p>在这种情况下，存储顺序为 <code>12 34 56 78</code>。</p>
<ul>
<li><strong>符合人类阅读习惯</strong>：大端模式将最高有效字节放在低地址，类似于人类阅读从高位到低位的顺序，因此直接查看数据更直观。</li>
<li><strong>统一网络字节序</strong>：大端字节序是网络协议的标准（网络字节序），在跨平台通信时无需转换，适用于网络应用。</li>
<li><strong>计算复杂度稍高</strong>：对于低地址优先访问的处理器，大端模式的数值计算可能需要更多的字节重排操作，不如小端模式高效。</li>
</ul>
</blockquote>
<h5 id="Encoding编码—记录content长度"><a href="#Encoding编码—记录content长度" class="headerlink" title="Encoding编码—记录content长度"></a>Encoding编码—记录content长度</h5><p>ZipListEntry中的encoding编码分为字符串和整数两种：</p>
<ul>
<li>字符串：如果encoding是以“00”、“01”或者“10”开头，则证明content是字符串，不同encoding表示不同的字符串长度</li>
</ul>
<table>
<thead>
<tr>
<th><strong>编码</strong>（bit）</th>
<th><strong>编码长度</strong></th>
<th><strong>字符串大小</strong></th>
</tr>
</thead>
<tbody><tr>
<td>| 00pppppp |</td>
<td>1 bytes</td>
<td>&lt;= 63 bytes</td>
</tr>
<tr>
<td>| 01pppppp | qqqqqqqq |</td>
<td>2 bytes</td>
<td>&lt;= 16383 bytes</td>
</tr>
<tr>
<td>| 10000000 | qqqqqqqq | rrrrrrrr | ssssssss | tttttttt |</td>
<td>5 bytes</td>
<td>&lt;= 4294967295 bytes</td>
</tr>
</tbody></table>
<p>例如，我们要保存字符串：“ab”和 “bc”</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986172002.png" alt="1653986172002"></p>
<p>tlbytes,tltail,tllen </p>
<p>ZipListEntry中的encoding编码分为字符串和整数两种：</p>
<ul>
<li>整数：如果encoding是以“11”开始，则证明content是整数，且encoding固定只占用1个字节,不同的encoding表示不同数据类型，也就知道了长度</li>
</ul>
<table>
<thead>
<tr>
<th><strong>编码</strong></th>
<th><strong>编码长度</strong></th>
<th><strong>整数类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td>11000000</td>
<td>1</td>
<td>int16_t（2 bytes）</td>
</tr>
<tr>
<td>11010000</td>
<td>1</td>
<td>int32_t（4 bytes）</td>
</tr>
<tr>
<td>11100000</td>
<td>1</td>
<td>int64_t（8 bytes）</td>
</tr>
<tr>
<td>11110000</td>
<td>1</td>
<td>24位有符整数(3 bytes)</td>
</tr>
<tr>
<td>11111110</td>
<td>1</td>
<td>8位有符整数(1 bytes)</td>
</tr>
<tr>
<td>1111xxxx</td>
<td>1</td>
<td>直接在xxxx位置存数，范围从0001~1101，减1后结果为实际值（0到12）节约内存的极致</td>
</tr>
</tbody></table>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986282879.png" alt="1653986282879"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986217182.png" alt="1653986217182"></p>
<h4 id="ZipList的连锁更新问题"><a href="#ZipList的连锁更新问题" class="headerlink" title="ZipList的连锁更新问题"></a>ZipList的连锁更新问题</h4><p>ZipList的每个Entry都包含previous_entry_length来记录上一个节点的大小，长度是1个或5个字节：<br>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值<br>如果前一节点的长度大于等于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据<br>现在，假设我们有N个连续的、长度为250~253字节之间的entry，因此entry的previous_entry_length属性用1个字节即可表示，如图所示：正好插入一个254字节的entry导致后面的previousLen全部都变化了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986328124.png" alt="1653986328124"></p>
<p>ZipList这种特殊情况下产生的连续多次空间扩展操作称之为连锁更新（Cascade Update）。新增、删除都可能导致连锁更新的发生。</p>
<p>频繁申请、销毁内存  性能开销很大</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p><strong>ZipList特性：</strong></p>
<p>优点：</p>
<ul>
<li>压缩列表的可以看做一种连续内存空间的”双向链表”，不使用指针，所以不是真正意义上的链表</li>
<li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低。</li>
</ul>
<p>缺点：</p>
<ul>
<li>逐个遍历，如果列表数据量tllen过多，导致链表过长，可能影响查询性能</li>
<li>可能会发生频繁的内存申请销毁导致频繁内核态切换，资源开销较大</li>
<li>增或删较大数据时有可能发生连续更新问题</li>
</ul>
<p><strong>ziplist</strong> 的不足主要在于当 ziplist 中元素个数过多，它的查找效率就会降低。而且如果在 ziplist 里新增或修改数据，ziplist 占用的内存空间还需要<strong>重新分配</strong>；更糟糕的是，ziplist 新增某个元素或修改某个元素时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起<strong>连锁更新</strong>问题，导致每个元素的空间都要重新分配，这就会导致 ziplist 的访问性能下降。</p>
<h3 id="QuickList（双端链表-压缩列表）"><a href="#QuickList（双端链表-压缩列表）" class="headerlink" title="QuickList（双端链表+压缩列表）"></a>QuickList（双端链表+压缩列表）</h3><p><a href="https://juejin.cn/post/7093145133368999943">深入分析redis之quicklist，不一样的ziplist使用方式？ - 掘金 (juejin.cn)</a> </p>
<p>问题1：ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。怎么办？</p>
<p>​    答：为了缓解这个问题，我们必须限制ZipList的长度和entry大小。</p>
<p>问题2：但是我们要存储大量数据，超出了ZipList最佳的上限该怎么办？</p>
<p>​    答：我们可以创建多个ZipList来<mark>分片<mark>存储数据。</p>
<p>问题3：数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？</p>
<p>​    答：Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，只不过链表中的每个节点都是一个ZipList。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986474927.png" alt="1653986474927"></p>
<p>为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：list-max-ziplist-size来限制。<br>如果值为正，则代表ZipList的允许的entry个数的最大值<br>如果值为负，则代表ZipList的最大内存大小，分5种情况：</p>
<ul>
<li>-1：每个ZipList的内存占用不能超过4kb</li>
<li>-2：每个ZipList的内存占用不能超过8kb</li>
<li>-3：每个ZipList的内存占用不能超过16kb</li>
<li>-4：每个ZipList的内存占用不能超过32kb</li>
<li>-5：每个ZipList的内存占用不能超过64kb</li>
</ul>
<p>其默认值为 -2：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986642777.png" alt="1653986642777"></p>
<p>以下是QuickList的和QuickListNode的结构源码：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986667228.png" alt="1653986667228"></p>
<p>我们接下来用一段流程图来描述当前的这个结构</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986718554.png" alt="1653986718554"></p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>QuickList的特点：</p>
<ul>
<li>是一个节点为ZipList的双端链表</li>
<li>节点采用ZipList，解决了传统链表的内存占用问题</li>
<li>控制了ZipList大小，解决连续内存空间申请效率问题</li>
<li>中间节点可以压缩，进一步节省了内存</li>
</ul>
<h3 id="Listpack"><a href="#Listpack" class="headerlink" title="Listpack"></a>Listpack</h3><p><a href="https://segmentfault.com/a/1190000041670843">Redis7代码分析阅读总结一：listpack - 个人文章 - SegmentFault 思否</a></p>
<p><a href="https://juejin.cn/post/7093530299866284045">深入分析redis之listpack，取代ziplist? - 掘金 (juejin.cn)</a></p>
<p>解决了ZipList的连锁更新问题</p>
<h3 id="SkipList（加强链表）"><a href="#SkipList（加强链表）" class="headerlink" title="SkipList（加强链表）"></a>SkipList（加强链表）</h3><p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：</p>
<ul>
<li>元素按照SCORE值升序排列存储</li>
<li>节点可能包含多个指针，指针跨度不同。</li>
</ul>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986771309.png" alt="1653986771309"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986813240.png" alt="1653986813240"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986877620.png" alt="1653986877620"></p>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>SkipList的特点：</p>
<ul>
<li><p>跳跃表是一个双向链表，每个节点都包含score和ele值（sds字符串）</p>
</li>
<li><p>节点按照score值排序，score值一样则按照ele字典排序。</p>
</li>
<li><p>每个节点都可以包含多层指针，<mark>层数是1到32之间的随机数<mark> 这种<strong>随机</strong>性避免了平衡树中频繁的旋转或重构操作。</p>
<ul>
<li><strong>抛硬币法</strong>：抛硬币法是一种经典的随机算法，假设每次抛硬币有 50% 的概率使当前节点新增一层，直到硬币正面朝上或达到最大层数。该算法实现简单且符合概率分布。</li>
<li><strong>概率分布法</strong>：概率分布法采用伪随机数生成器，预先设置一个层数分布表，以确保生成的层数具有严格的概率性分布。相较于抛硬币法，概率分布法更为精准，能够进一步优化跳表的性能。</li>
</ul>
</li>
<li><p>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</p>
</li>
<li><p>增删改查效率与红黑树基本一致，实现却更简单</p>
</li>
</ul>
<h4 id="跳表-vs-Trees"><a href="#跳表-vs-Trees" class="headerlink" title="跳表 vs Trees"></a>跳表 vs Trees</h4><h5 id="AVL-Tree-vs-SkipList"><a href="#AVL-Tree-vs-SkipList" class="headerlink" title="AVL Tree vs SkipList"></a>AVL Tree vs SkipList</h5><p>平衡树：AVL Tree 的插入、删除和查询的时间复杂度和跳表一样都是 <strong>O(log n)</strong> 。但是每一次插入或者删除操作都需要保证整颗树左右节点的绝对平衡，只要不平衡就要通过旋转操作来保持平衡，这个过程是比较耗时的。</p>
<p>而跳表是一种可以用来代替平衡树的数据结构。跳表使用概率平衡而不是严格强制的平衡，因此，跳表中的插入和删除算法比平衡树的等效算法简单得多，速度也快得多。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/202401222005312.png" alt="img"></p>
<h5 id="RB-Tree-vs-SkipList"><a href="#RB-Tree-vs-SkipList" class="headerlink" title="RB Tree vs SkipList"></a>RB Tree vs SkipList</h5><p>红黑树：Red Black Tree 也是一种自平衡二叉查找树，它的查询性能略微逊色于 AVL 树，但插入和删除效率更高。红黑树的插入、删除和查询的时间复杂度和跳表一样都是 <strong>O(log n)</strong> 。红黑树是一个<strong>黑平衡树</strong>，即从任意节点到另外一个叶子叶子节点，它所经过的黑节点是一样的。当对它进行插入操作时，需要通过旋转和染色（红黑变换）来保证黑平衡。不过，相较于 AVL 树为了维持平衡的开销要小一些。关于红黑树的详细介绍，可以查看这篇文章：<a href="https://javaguide.cn/cs-basics/data-structure/red-black-tree.html">红黑树</a>。</p>
<p>跳表的实现也更简单一些。并且，按照区间来查找数据这个操作，红黑树的效率没有跳表高。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/202401222005709.png" alt="img"></p>
<h5 id="B-Tree-vs-SkipList"><a href="#B-Tree-vs-SkipList" class="headerlink" title="B+ Tree vs SkipList"></a>B+ Tree vs SkipList</h5><p>B+树更适合作为数据库和文件系统中常用的索引结构之一，它的核心思想是通过可能少的 IO 定位到尽可能多的索引来获得查询数据。Redis对于文件IO不敏感，只需按照概率进行随机维护即可，节约内存。而且使用跳表实现 zset 时相较前者来说更简单一些，在进行插入时只需通过索引将数据插入到链表中合适的位置再随机维护一定高度的索引即可，也不需要像 B+树那样插入时发现失衡时还需要对节点分裂与合并。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/202401222005649.png" alt="img"></p>
<h5 id="Redis作者的理由"><a href="#Redis作者的理由" class="headerlink" title="Redis作者的理由"></a>Redis作者的理由</h5><p>1、它们不是很占用内存。这主要取决于你。改变节点拥有给定层数的概率的参数，会使它们比 B 树更节省内存。</p>
<p>2、有序集合经常是许多 ZRANGE 或 ZREVRANGE 操作的目标，也就是说，以链表的方式遍历跳表。通过这种操作，跳表的缓存局部性至少和其他类型的平衡树一样好。</p>
<p>3、它们更容易实现、调试等等。例如，由于跳表的简单性，我收到了一个补丁（已经在 Redis 主分支中），用增强的跳表实现了 O(log(N))的 ZRANK。它只需要对代码做很少的修改。</p>
<h3 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h3><p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象，源码如下：</p>
<p>1、什么是redisObject：<br>从Redis的使用者的角度来看，⼀个Redis节点包含多个database（非cluster模式下默认是16个，cluster模式下只能是1个），而一个database维护了从key space到object space的映射关系。这个映射关系的key是string类型，⽽value可以是多种数据类型，比如：<br>string, list, hash、set、sorted set等。我们可以看到，<strong>key的类型固定是string，而value可能的类型是多个</strong>。<br>⽽从Redis内部实现的⾓度来看，database内的这个映射关系是<strong>用⼀个dict</strong>来维护的。dict的key固定用⼀种数据结构来表达就够了，这就是动态字符串sds。而value则比较复杂，为了在同⼀个dict内能够存储不同类型的value，这就需要⼀个通⽤的数据结构，这个通用的数据结构就是robj，全名是redisObject。</p>
<p>一个database对应一个dict，其中entry就是key(string)和value(五种基本数据结构类型)的对应关系</p>
<p>需要用RedisObject囊括value</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986956618.png" alt="1653986956618"></p>
<p>Redis的编码方式</p>
<p>Redis中会根据存储的数据类型不同，选择不同的编码方式，共包含11种不同类型：</p>
<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th><strong>编码方式</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>OBJ_ENCODING_RAW</td>
<td>raw编码动态<mark>字符串<mark></td>
</tr>
<tr>
<td>1</td>
<td>OBJ_ENCODING_INT</td>
<td>long类型的整数的<mark>字符串<mark></td>
</tr>
<tr>
<td>2</td>
<td>OBJ_ENCODING_HT</td>
<td>hash表（<mark>字典dict<mark>）</td>
</tr>
<tr>
<td>3</td>
<td>OBJ_ENCODING_ZIPMAP</td>
<td>已废弃</td>
</tr>
<tr>
<td>4</td>
<td>OBJ_ENCODING_LINKEDLIST</td>
<td>双端链表</td>
</tr>
<tr>
<td>5</td>
<td>OBJ_ENCODING_ZIPLIST</td>
<td><mark>压缩列表<mark></td>
</tr>
<tr>
<td>6</td>
<td>OBJ_ENCODING_INTSET</td>
<td><mark>整数集合<mark></td>
</tr>
<tr>
<td>7</td>
<td>OBJ_ENCODING_SKIPLIST</td>
<td><mark>跳表<mark></td>
</tr>
<tr>
<td>8</td>
<td>OBJ_ENCODING_EMBSTR</td>
<td>embstr的动态<mark>字符串<mark></td>
</tr>
<tr>
<td>9</td>
<td>OBJ_ENCODING_QUICKLIST</td>
<td><mark>快速列表<mark></td>
</tr>
<tr>
<td>10</td>
<td>OBJ_ENCODING_STREAM</td>
<td>Stream流</td>
</tr>
</tbody></table>
<p>五种数据结构</p>
<p>Redis中会根据存储的数据类型不同，选择不同的编码方式。每种数据类型的使用的编码方式如下：</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>编码方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td>OBJ_STRING</td>
<td>int、embstr、raw</td>
</tr>
<tr>
<td>OBJ_LIST</td>
<td>LinkedList和ZipList(3.2以前)、QuickList（3.2以后）</td>
</tr>
<tr>
<td>OBJ_SET</td>
<td>intset、HT</td>
</tr>
<tr>
<td>OBJ_ZSET</td>
<td>ZipList、HT、SkipList</td>
</tr>
<tr>
<td>OBJ_HASH</td>
<td>ZipList、HT</td>
</tr>
</tbody></table>
<h3 id="String（RAW-EMBSTR-INT）"><a href="#String（RAW-EMBSTR-INT）" class="headerlink" title="String（RAW / EMBSTR / INT）"></a>String（RAW / EMBSTR / INT）</h3><p>String是Redis中最常见的数据存储类型：</p>
<ul>
<li><p>其基本编码方式是<mark>ENCODING_RAW<mark>，基于简单动态字符串（SDS）实现，存储上限为512mb。</p>
</li>
<li><p>如果存储的SDS长度<mark>小于44<mark>字节，则会采用<mark>ENCODING_EMBSTR<mark>(Embedded String)编码，此时object head与SDS是一段连续空间。申请内存时只需要调用一次内存分配函数，<mark>效率更高。<mark></p>
<ul>
<li>底层采用Jemalloc分配内存，2^n^效率更高，4+8+44+4 = 64</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241114163342533.png" alt="image-20241114163342533"></li>
</ul>
</li>
</ul>
<p>底层实现⽅式：动态字符串 SDS 或 long </p>
<p>String的内部存储结构⼀般是SDS（Simple Dynamic String，可以动态扩展内存）</p>
<p>但是如果⼀个String类型的value的值是数字，那么Redis内部会把它转成long类型来存储，从⽽减少内存的使用。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653987103450.png" alt="1653987103450"></p>
<p>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用<mark>ENCODING_INT<mark>编码：直接将数据保存在RedisObject的ptr指针位置（刚好8字节），不再需要SDS了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653987159575.png" alt="1653987159575"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653987202522.png" alt="1653987202522"></p>
<p>确切地说，String在Redis中是⽤⼀个robj来表示的。</p>
<p>用来表示String的robj可能编码成3种内部表⽰：OBJ_ENCODING_RAW，OBJ_ENCODING_EMBSTR，OBJ_ENCODING_INT。<br>其中前两种编码使⽤的是sds来存储，最后⼀种OBJ_ENCODING_INT编码直接把string存成了long型。<br>在对string进行incr, decr等操作的时候，如果它内部是OBJ_ENCODING_INT编码，那么可以直接行加减操作；如果它内部是OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR编码，那么Redis会先试图把sds存储的字符串转成long型，如果能转成功，再进行加减操作。对⼀个内部表示成long型的string执行append, setbit, getrange这些命令，针对的仍然是string的值（即⼗进制表示的字符串），而不是针对内部表⽰的long型进⾏操作。比如字符串”32”，如果按照字符数组来解释，它包含两个字符，它们的ASCII码分别是0x33和0x32。当我们执行命令setbit key 7 0的时候，相当于把字符0x33变成了0x32，这样字符串的值就变成了”22”。⽽如果将字符串”32”按照内部的64位long型来解释，那么它是0x0000000000000020，在这个基础上执⾏setbit位操作，结果就完全不对了。因此，在这些命令的实现中，会把long型先转成字符串再进行相应的操作。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241114163612101.png" alt="image-20241114163612101"></p>
<p>总结：字符串尽量控制在44字节以内</p>
<h3 id="List（QUICKLIST）"><a href="#List（QUICKLIST）" class="headerlink" title="List（QUICKLIST）"></a>List（QUICKLIST）</h3><p>Redis的List类型可以从首、尾操作列表中的元素：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653987240622.png" alt="1653987240622"></p>
<p>哪一个数据结构能满足上述特征？</p>
<ul>
<li>LinkedList ：普通链表，可以从双端访问，内存占用较高，内存碎片较多</li>
<li>ZipList ：压缩列表，可以从双端访问，内存占用低，存储上限低</li>
<li>QuickList：LinkedList + ZipList，可以从双端访问，内存占用较低，包含多个ZipList，存储上限高</li>
</ul>
<h4 id="RedisObject-结构"><a href="#RedisObject-结构" class="headerlink" title="RedisObject 结构"></a>RedisObject 结构</h4><p>Redis的List结构类似一个双端链表，可以从首、尾操作列表中的元素：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241114164451953.png" alt="image-20241114164451953"></p>
<p>在3.2版本之前，Redis采用ZipList和LinkedList来实现List，当元素数量小于512并且元素大小小于64字节时采用ZipList编码，超过则采用LinkedList编码。</p>
<p>在3.2版本之后，Redis统一采用QuickList来实现List：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653987313461.png" alt="1653987313461"></p>
<h4 id="创建与插入"><a href="#创建与插入" class="headerlink" title="创建与插入"></a>创建与插入</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241114174543958-1731774561497-3.png" alt="image-20241114174543958"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241114174533836.png" alt="image-20241114174533836"></p>
<h3 id="Set（INTSET-HT）"><a href="#Set（INTSET-HT）" class="headerlink" title="Set（INTSET / HT）"></a>Set（INTSET / HT）</h3><p>Set是Redis中的单列集合，满足下列特点：</p>
<ul>
<li>不保证有序性</li>
<li>保证元素唯一</li>
<li>求交集、并集、差集</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653987342550.png" alt="1653987342550"></p>
<p>可以看出，Set对查询元素的效率要求非常高，思考一下，什么样的数据结构可以满足？<br>HashTable，也就是Redis中的<mark>Dict<mark>，不过Dict是双列集合（可以存键、值对）</p>
<p>同一个key计算的索引肯定一样，所以也能确保key唯一</p>
<p>Set是Redis中的集合，不一定确保元素有序，可以满足元素唯一、查询效率要求极高。</p>
<ul>
<li>为了查询效率和唯一性，set采用HT编码（Dict）。Dict中的key用来存储元素，value统一为null。</li>
<li>当存储的所有数据都是整数，并且元素数量不超过set-max-intset-entries时，Set会采用IntSet编码，以节省内存</li>
</ul>
<h4 id="RedisObject-结构-1"><a href="#RedisObject-结构-1" class="headerlink" title="RedisObject 结构"></a>RedisObject 结构</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653987454403.png" alt="1653987454403"></p>
<h4 id="创建或插入对编码的影响"><a href="#创建或插入对编码的影响" class="headerlink" title="创建或插入对编码的影响"></a>创建或插入对编码的影响</h4><p><mark>根据创建set时添加的第一个元素判断使用哪种编码格式<mark> 如果是intset编码，需要根据插入的元素判断是否转换数据结构</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653987388177.png" alt="1653987388177"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241114180238855.png" alt="image-20241114180238855"></p>
<h3 id="ZSET（SKIPLIST-HT-ZIPLIST）"><a href="#ZSET（SKIPLIST-HT-ZIPLIST）" class="headerlink" title="ZSET（SKIPLIST+HT / ZIPLIST）"></a>ZSET（SKIPLIST+HT / ZIPLIST）</h3><p>ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值：</p>
<ul>
<li>可以根据score值排序后</li>
<li>member必须唯一</li>
<li>可以根据member查询分数</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653992091967.png" alt="1653992091967"></p>
<h4 id="RedisObject-结构-2"><a href="#RedisObject-结构-2" class="headerlink" title="RedisObject 结构"></a>RedisObject 结构</h4><p>因此，zset底层数据结构必须满足键值存储、键必须唯一、可排序这几个需求。之前学习的哪种编码结构可以满足？</p>
<ul>
<li>SkipList：可以排序，并且可以同时存储score和ele值（member）</li>
<li>HT（Dict）：可以键值存储，并且可以根据key找value(SCORE)</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653992121692.png" alt="1653992121692"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653992172526.png" alt="1653992172526"></p>
<p>当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存。因此zset还会采用ZipList结构来节省内存，不过需要同时满足两个条件。</p>
<ul>
<li>元素数量小于zset_max_ziplist_entries，默认值128</li>
<li>每个元素都小于zset_max_ziplist_value字节，默认值64</li>
</ul>
<p>ziplist本身没有排序功能，而且没有键值对的概念，因此需要有zset通过编码实现：</p>
<ul>
<li>ZipList是连续内存，因此score和element是紧挨在一起的两个entry， element在前，score在后</li>
<li>score越小越接近队首，score越大越接近队尾，按照score值升序排列</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653992299740.png" alt="1653992299740"></p>
<h4 id="创建或插入对编码的影响-1"><a href="#创建或插入对编码的影响-1" class="headerlink" title="创建或插入对编码的影响"></a>创建或插入对编码的影响</h4><p><mark>创建redisobject时，就会根据参数判断采用哪种结构，之后每次插入都会做判断是否需要更改编码类型<mark>  </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653992238097.png" alt="1653992238097"></p>
<h3 id="Hash（HT-ZIPLIST）"><a href="#Hash（HT-ZIPLIST）" class="headerlink" title="Hash（HT / ZIPLIST）"></a>Hash（HT / ZIPLIST）</h3><p>hash结构如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653992339937.png" alt="1653992339937"></p>
<p>zset集合如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653992360355.png" alt="1653992360355"></p>
<p>Hash结构与Redis中的Zset非常类似：</p>
<ul>
<li>都是键值存储</li>
<li>都需求根据键获取值</li>
<li>键必须唯一</li>
</ul>
<p>区别如下：</p>
<ul>
<li>zset的键是member，值是score；hash的键和值都是任意值</li>
<li>zset要根据score排序；hash则无需排序</li>
</ul>
<h4 id="RedisObject-结构-3"><a href="#RedisObject-结构-3" class="headerlink" title="RedisObject 结构"></a>RedisObject 结构</h4><p>因此，Hash底层采用的编码与Zset也基本一致，只需要把排序有关的SkipList去掉即可</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653992413406.png" alt="1653992413406"></p>
<p>Hash结构默认采用ZipList编码，用以节省内存。 ZipList中相邻的两个entry 分别保存field和value </p>
<p>随着数据的增加，底层的ziplist就可能会转成dict，具体配置如下：</p>
<ul>
<li><p>hash-max-ziplist-entries 512 元素个数</p>
</li>
<li><p>hash-max-ziplist-value 64 元素大小</p>
</li>
</ul>
<p>当满足上面两个条件其中之⼀的时候，Redis就使⽤dict字典来实现hash。<br>Redis的hash之所以这样设计，是因为当ziplist变得很⼤的时候，它有如下几个缺点：</p>
<ul>
<li>每次插⼊或修改引发的realloc操作会有更⼤的概率造成内存拷贝，从而降低性能。</li>
<li>⼀旦发生内存拷贝，内存拷贝的成本也相应增加，因为要拷贝更⼤的⼀块数据。</li>
<li>当ziplist数据项过多的时候，在它上⾯查找指定的数据项就会性能变得很低，因为ziplist上的查找需要进行遍历。</li>
</ul>
<p>ziplist这种结构并不擅长做修改操作。⼀旦数据发⽣改动，就会引发内存realloc，可能导致内存拷贝。</p>
<h4 id="创建或插入对编码的影响-2"><a href="#创建或插入对编码的影响-2" class="headerlink" title="创建或插入对编码的影响"></a>创建或插入对编码的影响</h4><p><mark>创建redisobject默认采用ZIPLIST，之后根据元素大小做判断是否需要转换成DICT，在真正插入后判断长度是否需要转换成DICT<mark> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241117001037075.png" alt="image-20241117001037075"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241117003843384.png" alt="image-20241117003843384"></p>
<h2 id="Redis网络模型"><a href="#Redis网络模型" class="headerlink" title="Redis网络模型"></a>Redis网络模型</h2><h3 id="用户空间和内核态空间"><a href="#用户空间和内核态空间" class="headerlink" title="用户空间和内核态空间"></a>用户空间和内核态空间</h3><p>服务器大多都采用Linux系统，这里我们以Linux为例来讲解:</p>
<p>ubuntu和Centos 都是Linux的发行版，发行版可以看成对linux包了一层壳，任何Linux发行版，其系统内核都是Linux。我们的应用都需要通过Linux内核与硬件交互</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653844970346.png" alt="1653844970346"></p>
<p>用户的应用，比如redis，mysql等其实是没有办法去执行访问我们操作系统的硬件的，所以我们可以通过发行版的这个壳子去访问内核，再通过内核去访问计算机硬件</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653845147190.png" alt="1653845147190"></p>
<p>计算机硬件包括，如cpu，内存，网卡等等，内核（通过寻址空间）可以操作硬件的，但是内核需要不同设备的驱动，有了这些驱动之后，内核就可以去对计算机硬件去进行 内存管理，文件系统的管理，进程的管理等等</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653896065386.png" alt="1653896065386"></p>
<p>我们想要用户的应用来访问，计算机就必须要通过对外暴露的一些接口，才能访问到，从而简介的实现对内核的操控，但是内核本身上来说也是一个应用，所以他本身也需要一些内存，cpu等设备资源，用户应用本身也在消耗这些资源，如果不加任何限制，用户去操作随意的去操作我们的资源，就有可能导致一些冲突，甚至有可能导致我们的系统出现无法运行的问题，因此我们需要把用户和<strong>内核隔离开</strong></p>
<p>进程的寻址空间划分成两部分：<strong>内核空间、用户空间</strong></p>
<p>什么是寻址空间呢？我们的应用程序也好，还是内核空间也好，都是没有办法直接去物理内存的，而是通过分配一些虚拟内存映射到物理内存中，我们的内核和应用程序去访问虚拟内存的时候，就需要一个虚拟地址，这个地址是一个无符号的整数，比如一个32位的操作系统，他的带宽就是32，他的虚拟地址就是2的32次方，也就是说他寻址的范围就是0~2的32次方， 这片寻址空间对应的就是2的32个字节，就是4GB，这个4GB，会有3个GB分给用户空间，会有1GB给内核系统</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653896377259.png" alt="1653896377259"></p>
<p>在linux中，他们权限分成两个等级，0和3，用户空间只能执行受限的命令（Ring3），而且不能直接调用系统资源，必须通过内核提供的接口来访问内核空间可以执行特权命令（Ring0），调用一切系统资源，所以一般情况下，用户的操作是运行在用户空间，而内核运行的数据是在内核空间的，而有的情况下，一个应用程序需要去调用一些特权资源，去调用一些内核空间的操作，所以此时他俩需要在用户态和内核态之间进行切换。</p>
<p>比如：</p>
<p>Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区：</p>
<p>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</p>
<p>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</p>
<p>针对这个操作：我们的用户在写读数据时，会去向内核态申请，想要读取内核的数据，而内核数据要去等待驱动程序从硬件上读取数据，当从磁盘上加载到数据之后，内核会将数据写入到内核的缓冲区中，然后再将数据拷贝到用户态的buffer中，然后再返回给应用程序，整体而言，速度慢，就是这个原因，为了加速，我们希望read也好，还是wait for data也最好都不要等待，或者时间尽量的短。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653896687354.png" alt="1653896687354"></p>
<h3 id="TCP-Socket"><a href="#TCP-Socket" class="headerlink" title="TCP Socket"></a>TCP Socket</h3><p><a href="https://zhuanlan.zhihu.com/p/464268288">网络编程：Socket 是如何创建的？ - 知乎 (zhihu.com)</a></p>
<h4 id="Socket-定义"><a href="#Socket-定义" class="headerlink" title="Socket 定义"></a>Socket 定义</h4><p>Socket：应用程序通过socket提供的接口将网络传输的工作交给linux内核，内核通过驱动程序操作网卡，接受网卡发来的信息。</p>
<p><code>socket</code> 是一个 <strong>编程接口</strong>（API），它本身并不属于网络协议栈的某一层，但它主要用于操作 <strong>传输层</strong>（如 TCP 和 UDP）以及网络层（如原始套接字）的通信，它本身不是传输层或应用层的一部分，而是一个编程抽象，用于简化应用程序访问网络的过程。</p>
<ul>
<li><strong>Socket API</strong> 是操作系统提供的接口，用于应用程序与网络协议栈交互。</li>
<li>它允许开发者使用 <strong>传输层协议（TCP/UDP）</strong> 或更底层的协议（如 IP）进行网络通信。</li>
<li>因此，虽然 Socket 本身不属于传输层或应用层，但它主要作用于 <strong>传输层协议</strong>，并为应用层提供访问网络的工具。</li>
</ul>
<p><strong>按照使用的协议可以分为</strong>：</p>
<ul>
<li><p><strong>传输层：</strong></p>
<ul>
<li>使用 <code>TCP</code> 协议时，<code>TCP Socket</code> 提供可靠的面向连接的数据传输。</li>
<li>使用 <code>UDP</code> 协议时，<code>UDP Socket</code> 提供无连接、不可靠的数据传输。</li>
</ul>
</li>
<li><p><strong>网络层：</strong></p>
<ul>
<li>使用原始套接字（Raw Socket）时，可以直接处理 IP 包，适用于网络工具如 ping 和 traceroute。</li>
</ul>
</li>
<li><p>应用程序通过 Socket 来发送和接收数据，但具体的数据传输和可靠性保障是由 <strong>传输层协议（如 TCP/UDP）</strong> 实现的</p>
</li>
</ul>
<h4 id="Socket-类型"><a href="#Socket-类型" class="headerlink" title="Socket 类型"></a>Socket 类型</h4><ul>
<li><strong>主动Socket</strong> socket()默认创建的socket类型，客户端向服务端建立连接需要的socket</li>
<li><strong>监听Socket</strong> listen()将主动socket转换成监听socket，用于监听客户端的连接请求。是服务端独有的，将伴随服务端的整个生命周期。</li>
<li><strong>已连接Socket</strong> 通过系统库函数accept()获取的已建立连接的socket，该socket是用于客户端和服务端数据读写的通道，已连接socket是服务器独有的，生命周期为 客户端和服务端的维持的连接时长，当断开连接，生命周期结束。</li>
</ul>
<p>一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p>
<h4 id="Socket-相关函数"><a href="#Socket-相关函数" class="headerlink" title="Socket 相关函数"></a>Socket 相关函数</h4><p>socket, bind, connect, listen, accept….</p>
<blockquote>
<ul>
<li><p><code>socket</code>:创建socket，规定各项参数，不能随意组合，socket()创建的socket默认是一个主动类型的，参数如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241115195114618.png" alt="image-20241115195114618"></p>
</li>
<li><p><code>bind</code>: 将IP和端口号绑定到socket上，如果不绑定，客户端会通过connect随机分配，服务端会通过listen随机分配，服务端需要的是一个明确的地址信息，所以必须提前绑定好端口。</p>
</li>
<li><p><code>connect</code>: 客户端通过connect向服务端发起连接请求。</p>
</li>
<li><p><code>listen</code>: 将socket变为被动类型（监听Socket）监听客户的连接请求。</p>
</li>
<li><p><code>accept</code>: 服务端监听到连接请求之后，在3次成功握手之后成功建立连接。1个<strong>监听Socket</strong>维护2个连接队列（全连接established和半连接syn_rcvd），accept会从全连接队列中拿出一个已连接的Socket进行处理，如果还没有完成，就要阻塞等待直到全链接队列有可用的socket。拿到已连接Socket之后就可以开始网络I/O，类同普通文件的读写I/O。当连接可用时，创建的套接字就可以从请求连接的进程中读取数据。</p>
<ul>
<li>accept() 调用创建一个与监听socket具有相同属性的新socketFD，并将其返回给调用者caller。如果队列没有挂起的连接请求，accept() 会阻塞调用者，除非socket处于非阻塞模式（Non-Blocking）。如果没有连接请求排队并且套接字处于非阻塞模式，则accept()返回-1并将错误代码设置为<mark>EWOULDBLOCK<mark>。新的socketFD不能用于接受新连接。原来的监听socket仍然可以接受更多的连接请求。</li>
<li>accept的第一个参数为服务器的socketFD，是服务器开始调用socket()函数生成的，称为监听socketFD；<br>而accept函数返回的是已连接的socketFD。两个套接字不一样。</li>
</ul>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241115202937962.png" alt="image-20241115202937962"></p>
<p>连接双方的IP地址和端口构成一个四元组，唯一标记一个客户端，将其作为Key，存到哈希表里，值就是sockfd，下次连接时重新从哈希表里取出来即可。        </p>
<ul>
<li><code>send/recv read/write</code>: 读写操作会先写到缓冲区中</li>
</ul>
<p><strong>怎么观察 socket 缓冲区</strong> </p>
<p>如果想要查看 socket 缓冲区，可以在linux环境下执行 <code>netstat -nt</code> 命令。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># netstat -nt</span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        <span class="number">0</span>     <span class="number">60</span> <span class="number">172.22</span><span class="number">.66</span><span class="number">.69</span>:<span class="number">22</span>         <span class="number">122.14</span><span class="number">.220</span><span class="number">.252</span>:<span class="number">59889</span>    ESTABLISHED</span><br></pre></td></tr></table></figure>

<p>这上面表明了，这里有一个协议（Proto）类型为 TCP 的连接，同时还有本地（Local Address）和远端（Foreign Address）的IP信息，状态（State）是已连接（Established） 还有<strong>Send-Q 是发送缓冲区</strong>，下面的数字60是指，当前还有60 Byte在发送缓冲区中未发送。而 <strong>Recv-Q 代表接收缓冲区</strong>，此时是空的，数据都被应用进程接收干净了。</p>
<p><a href="https://blog.csdn.net/qcrao/article/details/120278587">动画图解 socket 缓冲区的那些事儿-CSDN博客</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241116154258525.png" alt="image-20241116154258525"></p>
</blockquote>
<h4 id="Socket-与文件系统、内核的调用关系"><a href="#Socket-与文件系统、内核的调用关系" class="headerlink" title="Socket 与文件系统、内核的调用关系"></a>Socket 与文件系统、内核的调用关系</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241115193558676.png" alt="image-20241115193558676"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241115193416185.png" alt="image-20241115193416185"></p>
<h4 id="Socket-就绪之前"><a href="#Socket-就绪之前" class="headerlink" title="Socket 就绪之前"></a>Socket 就绪之前</h4><p>从ESTABLISHED tcp connection 到 就绪 之前：</p>
<p>TCP是面向连接的协议，通过三次握手建立连接后，会进行一些必要的初始化：</p>
<p><strong>（1）TCP状态维护</strong></p>
<ul>
<li><strong>接收和发送缓冲区准备</strong>：双方为这个连接分配缓冲区，准备接收或发送数据。</li>
<li><strong>连接状态记录</strong>：内核中的Socket结构会记录新连接的相关信息，如对端的IP地址、端口、协议状态等。</li>
</ul>
<p><strong>（2）SSL/TLS握手（如适用）</strong></p>
<p>如果通信使用了加密（如HTTPS），在TCP连接建立后会进行SSL/TLS握手。此过程包括：</p>
<ul>
<li>协商协议版本和加密算法。</li>
<li>交换密钥。</li>
<li>验证身份。</li>
</ul>
<p><strong>（3）应用层协议的初始化</strong></p>
<p>在TCP连接建立后，通常需要按照应用层协议（如HTTP、FTP、WebSocket等）定义的逻辑进行数据交互的初始化。例如：</p>
<ul>
<li>HTTP/1.1会发送<code>GET</code>或<code>POST</code>请求。</li>
<li>WebSocket会升级协议，通过<code>Upgrade</code>头进行握手。</li>
</ul>
<p><strong>（4）延迟与阻塞等待</strong></p>
<p>如果一端发送了数据而另一端未及时处理，连接可能处于阻塞或等待状态。例如：</p>
<ul>
<li><strong>服务端等待客户端请求</strong>。  </li>
<li><strong>客户端等待服务端响应</strong>。  </li>
</ul>
<h3 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h3><h4 id="阻塞IO-BIO"><a href="#阻塞IO-BIO" class="headerlink" title="阻塞IO (BIO)"></a>阻塞IO (BIO)</h4><p>在《UNIX网络编程》一书中，总结归纳了5种IO模型：</p>
<ul>
<li>阻塞IO（Blocking IO）</li>
<li>非阻塞IO（Nonblocking IO）</li>
<li>IO多路复用（IO Multiplexing）</li>
<li>信号驱动IO（Signal Driven IO）</li>
<li>异步IO（Asynchronous IO）</li>
</ul>
<p>应用程序想要去读取数据，他是无法直接去读取磁盘/网卡数据的，他需要先到内核里边去等待内核操作硬件拿到数据，这个过程就是1，是需要等待的，等到内核从磁盘上把数据加载出来之后，再把这个数据写给用户的缓存区，这个过程是2，如果是阻塞IO，那么整个过程中，用户从发起读请求开始，一直到读取到数据，都是一个阻塞状态。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653897115346.png" alt="1653897115346"></p>
<p>具体流程如下图：</p>
<p>用户去读取数据时，会去先发起recvform一个命令，去尝试从内核上加载数据，如果内核没有数据，那么用户就会等待，此时内核会去从硬件上读取数据，内核读取数据之后，会把数据拷贝到用户态，并且返回ok，整个过程，都是阻塞等待的，这就是阻塞IO</p>
<p>总结如下：</p>
<p>顾名思义，阻塞IO就是两个阶段都必须阻塞等待：</p>
<p>阶段一：receivefrom（阻塞）</p>
<ul>
<li>用户进程尝试读取数据（比如网卡数据）</li>
<li>此时数据尚未到达，内核需要等待数据</li>
<li>此时用户进程也处于阻塞状态</li>
</ul>
<p>阶段二：copy（阻塞）</p>
<ul>
<li>数据到达并拷贝到内核缓冲区，代表已就绪</li>
<li>将内核数据拷贝到用户缓冲区</li>
<li>拷贝过程中，用户进程依然阻塞等待</li>
<li>拷贝完成，用户进程解除阻塞，处理数据</li>
</ul>
<p>可以看到，阻塞IO模型中，用户进程在两个阶段都是阻塞状态。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653897270074.png" alt="1653897270074"></p>
<h4 id="非阻塞IO-NIO"><a href="#非阻塞IO-NIO" class="headerlink" title="非阻塞IO (NIO)"></a>非阻塞IO (NIO)</h4><p>顾名思义，非阻塞IO的recvfrom操作会立即返回结果而不是阻塞用户进程。</p>
<p>阶段一：recvfrom（非阻塞）</p>
<ul>
<li>用户进程尝试读取数据（比如网卡数据）</li>
<li>此时数据尚未到达，内核需要等待数据</li>
<li>返回异常给用户进程</li>
<li>用户进程拿到error后，再次尝试读取</li>
<li>循环往复，直到数据就绪</li>
</ul>
<p>阶段二：copy（阻塞）</p>
<ul>
<li>将内核数据拷贝到用户缓冲区</li>
<li>拷贝过程中，用户进程依然阻塞等待</li>
<li>拷贝完成，用户进程解除阻塞，处理数据</li>
<li>可以看到，非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增。</li>
</ul>
<p>用户应用进行IO操作，调用监听socket的accept()获取已连接socket进行IO操作，如果accept获取不到已连接的socket则直接返回-1(EWOULDBLOCK)，获取成功则返回已连接的socket的socketFD</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653897490116.png" alt="1653897490116"></p>
<h4 id="IO多路复用-IO-Multiplexing"><a href="#IO多路复用-IO-Multiplexing" class="headerlink" title="IO多路复用 (IO Multiplexing)"></a>IO多路复用 (IO Multiplexing)</h4><p>无论是阻塞IO还是非阻塞IO，用户应用在一阶段都需要调用recvfrom来获取数据，差别在于无数据时的处理方案：</p>
<p>如果调用recvfrom时，恰好没有数据，阻塞IO会使CPU阻塞，非阻塞IO使CPU空转，都不能充分发挥CPU的作用。<br>如果调用recvfrom时，恰好有数据，则用户进程可以直接进入第二阶段，读取并处理数据</p>
<p>所以怎么看起来以上两种方式性能都不好</p>
<p>而在单线程情况下，只能依次处理IO事件，如果正在处理的IO事件恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有IO事件都必须等待，性能自然会很差。</p>
<p>就比如服务员给顾客点餐，<strong>分两步</strong>：</p>
<ul>
<li>顾客思考要吃什么（服务员这边等待数据就绪）</li>
<li>顾客想好了，开始点餐（服务员开始真正读取数据）</li>
</ul>
<p>要提高效率有几种办法？</p>
<p>方案一：增加更多服务员（多线程）：上下文切换消耗资源 PASS<br>方案二：不排队，谁想好了吃什么（数据就绪了），服务员就给谁点餐（用户应用就去读取数据）OKAY</p>
<p>那么问题来了：用户进程如何知道内核中数据是否就绪呢？</p>
<p>所以接下来就需要详细的来解决多路复用模型是如何知道到底怎么知道内核数据是否就绪的问题了</p>
<p>这个问题的解决依赖于提出的：Socket FD</p>
<p>文件描述符（File Descriptor）：简称FD，是一个从0 开始的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）。</p>
<blockquote>
<p>一个进程对应一个<code>task_struct</code>，一个<code>task_struct</code>中有一个<code>file_struct</code>，一个<code>file_struct</code>中有一个<code>fdt</code>(file descriptor table文件描述符表) <code>fdt</code>中就有一个<code>fd_array</code>（fd数组）数组索引为fd，内容就是指向<code>file</code>的指针</p>
</blockquote>
<p>通过FD，我们的网络模型可以利用一个线程监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</p>
<p>阶段一：</p>
<ul>
<li>用户进程调用select，指定要监听的FD集合</li>
<li>核监听FD对应的多个socket</li>
<li>任意一个或多个socket数据就绪则返回readable（可读）</li>
<li>此过程中用户进程阻塞</li>
</ul>
<p>阶段二：</p>
<ul>
<li>用户进程找到就绪的socket</li>
<li>依次调用recvfrom读取数据</li>
<li>内核将数据拷贝到用户空间</li>
<li>用户进程处理数据。</li>
</ul>
<p>当用户去读取数据的时候，不再去直接调用recvfrom了，而是调用select的函数，select函数会将需要监听的数据交给内核，由内核去检查这些数据是否就绪了，如果说这个数据就绪了，就会通知应用程序数据就绪，然后来读取数据，再从内核中把数据拷贝给用户态，完成数据处理，如果N多个FD一个都没处理完，此时就进行等待。</p>
<p>BIO模式只能查看一个socket，SocketA准备就绪了，但是用户进程在阻塞等待SocketB的数据，这就是无效的等待。</p>
<p>IO Multiplexing可以减少空等空转空轮询，提高性能</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653898691736.png" alt="1653898691736"></p>
<p>数据就绪返回readable，用户进程调用recvfrom处理数据。</p>
<p>IO多路复用是利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过监听FD的方式、通知的方式又有多种实现，常见的有：select，poll，epoll。其中select和pool相当于是当被监听的数据准备好之后，他会把你监听的FD数组整个数据都发给你，你需要到整个FD中去找，哪些是处理好了的，需要通过遍历的方式，所以性能也并不是那么好。而epoll，则相当于内核准备好了之后，他会把准备好的数据，直接发给你，省去了遍历的动作。</p>
<h5 id="IO多路复用-select函数"><a href="#IO多路复用-select函数" class="headerlink" title="IO多路复用-select函数"></a>IO多路复用-select函数</h5><p><a href="https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#select-poll">select/poll</a> </p>
<h6 id="select-流程"><a href="#select-流程" class="headerlink" title="select 流程"></a>select 流程</h6><p>select是Linux最早是由的I/O多路复用技术：</p>
<p>简单说，就是我们把需要处理的数据封装成FD，然后在用户态时创建一个fd的集合（这个集合的大小是要监听的那个FD的最大值+1，但是大小整体是有限制的 ），这个集合的长度大小是有限制的，同时在这个集合中，标明出来我们要控制哪些数据，比如要监听的数据，是1,2,5三个数据，此时会执行select函数，<strong>遍历数组把需要监听的FD置1</strong>（直到nfds fd上限），然后<mark>将整个FDSet拷贝到内核态<mark>，内核态会去<strong>遍历用户态传递过来的数据</strong>，如果发现这里边都数据都没有就绪，就休眠。</p>
<p>直到有数据准备好时，就会被唤醒，唤醒之后，<strong>再次遍历一遍</strong>，看看谁准备好了，将没有准备好的数据置0，<mark>最后再次将这个FDSet拷贝回用户态<mark>，此时用户态就知道有人准备好了（readable），但对于用户态而言，并不知道谁处理好了，所以用户态<strong>也需要去进行遍历</strong>，然后找到被置1（准备就绪）的节点，再去发起receivefrom读写请求，我们会发现，这种模式下他虽然比阻塞IO和非阻塞IO好，但是依然有些麻烦的事情， 比如说频繁的传递fd集合，频繁的去遍历FD等问题</p>
<p>bitmap： __fd_mask = 32bits  FDSet共1024个bit位。</p>
<p>把fd的状态映射到单个bit位上面，很大程度上节省了内存空间，但是也导致用户态不知道谁准备好了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653900022580.png" alt="1653900022580"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241114211029023.png" alt="image-20241114211029023"></p>
<h6 id="select-返回值"><a href="#select-返回值" class="headerlink" title="select 返回值"></a><strong>select 返回值</strong></h6><blockquote>
<ul>
<li><strong>大于0</strong>：表示有文件描述符准备好了。返回值是就绪的文件描述符的数量，也就是有多少个文件描述符在监视的时间内发生了事件（例如：可以读、可以写、异常等）。</li>
<li><strong>0</strong>：表示在指定的时间内没有文件描述符准备好，即超时。</li>
<li>-1：表示发生了错误，errno 中会设置为相应的错误码。常见的错误包括：<ul>
<li><code>EBADF</code>：传递给 <code>select</code> 的某些文件描述符无效。</li>
<li><code>EINTR</code>：调用被信号中断。</li>
<li><code>EINVAL</code>：某个参数无效（例如 <code>nfds</code> 负值）。</li>
</ul>
</li>
</ul>
</blockquote>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>整个流程涉及到两次用户态与内核态之间的拷贝，频繁切换，一共需要2次「拷贝」fdSet</li>
<li>返回值只是就绪的节点个数，然而select并不知道是具体哪个节点就绪，还需要重新遍历，一共需要2次「遍历」</li>
<li>fd_Set 最多监听1024个</li>
</ul>
<h5 id="IO多路复用-poll函数"><a href="#IO多路复用-poll函数" class="headerlink" title="IO多路复用-poll函数"></a>IO多路复用-poll函数</h5><p>poll模式对select模式做了简单改进，但性能提升不明显，部分关键代码如下：</p>
<p>IO流程：</p>
<ul>
<li>创建pollfd数组，向其中添加关注的fd信息，数组大小自定义</li>
<li>调用poll函数，将pollfd数组拷贝到内核空间，转链表存储，无上限</li>
<li>内核遍历fd，判断是否就绪</li>
<li>数据就绪或超时后，拷贝pollfd数组到用户空间，返回就绪fd数量n</li>
<li>用户进程判断n是否大于0,大于0则遍历pollfd数组，找到就绪的fd</li>
</ul>
<p><strong>与select对比：</strong></p>
<ul>
<li>select模式中的fd_set大小固定为1024，而pollfd在内核中采用链表，理论上无上限</li>
<li>监听FD越多，每次遍历消耗时间也越久，性能反而会下降</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653900721427.png" alt="1653900721427"></p>
<h5 id="IO多路复用-epoll函数（event-poll-事件轮询）"><a href="#IO多路复用-epoll函数（event-poll-事件轮询）" class="headerlink" title="IO多路复用-epoll函数（event poll 事件轮询）"></a>IO多路复用-epoll函数（event poll 事件轮询）</h5><p><a href="https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#epoll">epoll</a></p>
<p><mark>核心：事件轮询<mark></p>
<h6 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h6><p>创建eventpoll结构，包含以下两个结构：</p>
<p>1、监听红黑树-&gt; 记录要监听的FD rb_root</p>
<p>2、就绪链表-&gt;记录就绪的FD list_head</p>
<p>紧接着，调用<code>epoll_ctl</code>操作，将要监听的数据添加到红黑树上去，并且给对应的每个fd设置一个监听函数，这个函数会在fd数据就绪时触发，把对应就绪的fd数据添加到就绪链表中</p>
<p>3、调用<code>epoll_wait</code>函数</p>
<p>就去等待，在用户态创建一个空的<code>events</code>数组，当就绪之后，我们的回调函数会把数据添加到<code>list_head</code>中去，当调用这个函数的时候，会去检查list_head，当然这个过程需要参考配置的等待时间，可以等一定时间，也可以一直等， 如果在此过程中，检查到了list_head中有数据会将数据添加到链表中，此时将数据放入到events数组中，并且返回对应的事件数量，用户态的此时收到响应后，从events中拿到对应准备好的数据的节点（SocketFD），再去调用方法从Socket拿数据。</p>
<p><a href="https://zh.wikipedia.org/zh-cn/%E5%8F%A5%E6%9F%84">句柄 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241114221957536.png" alt="image-20241114221957536"></p>
<p>最后返回的依然是数量，但是只需要拷贝已就绪的FD，开销大大减小，并且不用遍历</p>
<h6 id="回调函数与事件驱动"><a href="#回调函数与事件驱动" class="headerlink" title="回调函数与事件驱动"></a>回调函数与事件驱动</h6><blockquote>
<p>回调函数：将函数作为参数传入，Java中是函数式接口的实现类，C中是函数指针</p>
<p>事件驱动：以状态的转换作为事件发生的标志，事件发生会触发回调函数的执行。而事件是多种多样的，这就要求执行的函数不能写死，需要实现充分的解耦</p>
<p><a href="https://www.runoob.com/w3cnote/c-callback-function.html">C 语言回调函数详解 | 菜鸟教程 (runoob.com)</a> </p>
</blockquote>
<h5 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h5><p>select模式存在的三个问题：</p>
<ul>
<li>能监听的FD<mark>最大不超过<mark>1024</li>
<li><mark>每次<mark>select都需要把<mark>所有<mark>要监听的FD都拷贝到内核空间</li>
<li>每次都要<mark>遍历所有<mark>FD来判断就绪状态</li>
</ul>
<p>poll模式的问题：</p>
<ul>
<li>poll利用链表解决了select中监听FD上限的问题，但依然要遍历所有FD，如果监听较多，性能会下降</li>
</ul>
<p>epoll模式中如何解决这些问题的？</p>
<ul>
<li>基于epoll实例中的红黑树保存要监听的FD，理论上无上限，而且增删改查效率都非常高</li>
<li>每个FD只需要执行一次epoll_ctl添加到红黑树，以后每次epol_wait无需传递任何参数，无需重复拷贝FD到内核空间</li>
<li>利用ep_poll_callback机制来监听FD状态，无需遍历所有FD，因此性能不会随监听的FD数量增多而下降</li>
</ul>
<p>epoll 是解决 C10K 问题的利器，通过两个方面解决了 select/poll 的问题。</p>
<ul>
<li>epoll 在内核里使用「红黑树」来关注进程所有待检测的 Socket，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)，通过对这棵黑红树的管理，不需要像 select/poll 在每次操作时都传入整个 Socket 集合，减少了内核和用户空间大量的数据拷贝和内存分配。</li>
<li>epoll 使用事件驱动的机制，内核里维护了一个「链表」来记录就绪事件，只将有事件发生的 Socket 集合传递给应用程序，不需要像 select/poll 那样轮询扫描整个集合（包含有和无事件的 Socket ），大大提高了检测的效率。</li>
</ul>
<h5 id="epoll中的ET和LT"><a href="#epoll中的ET和LT" class="headerlink" title="epoll中的ET和LT"></a>epoll中的ET和LT</h5><p>当FD有数据可读时，我们调用epoll_wait（或者select、poll）可以得到通知。但是事件通知的模式有两种：</p>
<ul>
<li>LevelTriggered：简称LT，也叫做水平触发。只要某个FD中有数据可读，每次调用epoll_wait都会得到通知。</li>
<li>EdgeTriggered：简称ET，也叫做边沿触发。只有在某个FD有状态变化时，调用epoll_wait才会被通知。</li>
</ul>
<p>举个栗子：</p>
<ul>
<li>假设一个客户端socket对应的FD已经注册到了epoll实例中</li>
<li>客户端socket发送了2kb的数据</li>
<li>服务端调用epoll_wait，得到通知说FD就绪</li>
<li>服务端从FD读取了1kb数据回到步骤3（再次调用epoll_wait，形成循环）</li>
</ul>
<p>结论</p>
<p>如果我们采用LT模式，因为FD中仍有1kb数据，则第⑤步依然会返回结果，并且得到通知<br>如果我们采用ET模式，因为第③步已经消费了FD可读事件，第⑤步FD状态没有变化，因此epoll_wait不会返回，数据无法读取，客户端响应超时。</p>
<h6 id="LT-ET-的底层实现"><a href="#LT-ET-的底层实现" class="headerlink" title="LT ET 的底层实现"></a>LT ET 的底层实现</h6><p><code>ep_send_events ep_scan_ready_list ep_send_events_proc</code></p>
<p>读写就绪的事件会触发回调函数把FD添加至链表中，wait函数将就绪节点从链表断开之后将内容拷贝回用户态。</p>
<p>读取之后，如果FD仍然是就绪的状态（没有读完），内核会根据LT或ET做出不同的行为：</p>
<p><strong>LT</strong> 会把仍就绪的节点加回去，确保下次wait还能读到链表的内容，同一个就绪的事件反复通知。（状态 state）</p>
<p><strong>ET</strong> 不会加回去，只有一次IO机会，没读完也不会通知，同一就绪的事件只通知一次。（状态的变化 state transitions）</p>
<p>如果ET要实现LT效果，需要在拷贝完以后手动调用ctl(before wait)修改的时候检查FD节点，将其重新添加会队列</p>
<h6 id="ET的优势"><a href="#ET的优势" class="headerlink" title="ET的优势"></a>ET的优势</h6><p>ET结合NIO能够确保一次性读完Socket中的数据，减少epoll_wait的调用次数，提高效率</p>
<p>LT因为会保留就绪链表上的节点，因此多个进程阻塞在epoll_wait的系统调用时，会将他们全部唤醒，即惊群</p>
<p><a href="https://zhuanlan.zhihu.com/p/385410196">深入浅出 Linux 惊群：现象、原因和解决方案 - 知乎 (zhihu.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s/xxjCrFH1361iG-srfNL9_Q">再谈 Linux epoll 惊群问题的原因和解决方案 (qq.com)</a> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果“就绪链表”上仍有未处理的epi，且有进程阻塞在epoll句柄的睡眠队列，则唤醒它！</span></span><br><span class="line"><span class="comment">//(这将是LT惊群的根源)</span></span><br><span class="line"><span class="comment">//ET将链表清空，LT将链表重新加回去</span></span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">        wake_up_locked(&amp;ep-&gt;wq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>epoll</code> 中，事件（event）是通过 <code>epoll_event</code> 结构体来定义和处理的。<code>epoll</code> 的事件分类主要基于 I/O 操作的类型（例如：可读、可写等），它们可以通过 <code>epoll_ctl</code> 函数注册，之后通过 <code>epoll_wait</code> 等函数来等待这些事件的发生。</p>
<h5 id="epoll-事件分类"><a href="#epoll-事件分类" class="headerlink" title="epoll 事件分类"></a>epoll 事件分类</h5><p><code>epoll</code> 支持多种事件类型，主要有以下几种：</p>
<ol>
<li><strong><code>EPOLLIN</code> - 可读事件</strong></li>
</ol>
<ul>
<li><p><strong>描述</strong>：表示指定的文件描述符（如 socket）可供读取数据。</p>
</li>
<li><p><strong>适用场景</strong>：当一个 socket 有数据可读时，<code>epoll</code> 会触发此事件。</p>
</li>
<li><p><strong>使用场景</strong>：服务器通常使用此事件来检测客户端是否有数据发送过来。</p>
<p><strong>例子</strong>：</p>
<ul>
<li>对于 TCP socket，<code>EPOLLIN</code> 事件表示客户端发送了数据，服务器可以使用 <code>recv()</code> 函数读取数据。</li>
<li>对于 监听 socket，<code>EPOLLIN</code> 表示有客户端发起了连接请求，服务器可以调用 <code>accept()</code> 来接受连接。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong><code>EPOLLOUT</code> - 可写事件</strong> </li>
</ol>
<ul>
<li><p><strong>描述</strong>：表示指定的文件描述符（如 socket）可以写入数据。</p>
</li>
<li><p><strong>适用场景</strong>：当 socket 可以安全地写入数据时，<code>epoll</code> 会触发此事件。</p>
</li>
<li><p><strong>使用场景</strong>：客户端在发送大量数据时，可能需要等待 socket 可写。此时，<code>epoll</code> 通过 <code>EPOLLOUT</code> 事件通知应用程序可以写入数据了。</p>
<p><strong>例子</strong>：</p>
<ul>
<li>如果一个 socket 处于阻塞状态，等待写缓冲区可用，<code>EPOLLOUT</code> 会被触发，表示可以开始写入数据。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong><code>EPOLLERR</code> - 错误事件</strong></li>
</ol>
<ul>
<li><p><strong>描述</strong>：表示文件描述符发生了错误。</p>
</li>
<li><p><strong>适用场景</strong>：如果连接发生了错误或出错事件（如网络中断），<code>epoll</code> 会触发此事件。</p>
</li>
<li><p><strong>使用场景</strong>：应用程序通常会检查 <code>EPOLLERR</code> 事件来处理错误情况，如关闭连接或执行错误恢复。</p>
<p><strong>例子</strong>：</p>
<ul>
<li>当 socket 发生网络错误，或者远程主机不可达时，<code>EPOLLERR</code> 会被触发。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong><code>EPOLLHUP</code> - 挂起事件（Hangup）</strong></li>
</ol>
<ul>
<li><p><strong>描述</strong>：表示文件描述符发生挂起（通常表示连接关闭）。</p>
</li>
<li><p><strong>适用场景</strong>：当连接被关闭，或者流中的另一端挂起时，<code>epoll</code> 会触发此事件。</p>
</li>
<li><p><strong>使用场景</strong>：客户端或服务器检测到连接关闭时，通常会处理此事件并清理资源。</p>
<p><strong>例子</strong>：</p>
<ul>
<li>当客户端断开连接时，服务器会收到 <code>EPOLLHUP</code> 事件。此时，服务器应关闭对应的 socket。</li>
</ul>
</li>
</ul>
<ol start="5">
<li><strong><code>EPOLLRDHUP</code> - 远程挂起事件</strong></li>
</ol>
<ul>
<li><strong>描述</strong>：表示对端关闭了连接。该事件是对 <code>EPOLLHUP</code> 的补充，专门用于表示对端关闭连接时的事件。</li>
<li><strong>适用场景</strong>：它是为了处理 <strong>TCP</strong> 连接中远程关闭（例如客户端关闭连接）时的特定事件。</li>
<li><strong>使用场景</strong>：与 <code>EPOLLHUP</code> 类似，应用程序通常通过这个事件来检测到对端已关闭连接，并可以进行相应处理。</li>
</ul>
<ol start="6">
<li><strong><code>EPOLLET</code> - 边缘触发（Edge Triggered）</strong></li>
</ol>
<ul>
<li><strong>描述</strong>：<code>EPOLLET</code> 是边缘触发模式，意味着当文件描述符的状态发生变化时，事件会被触发一次。边缘触发模式相比于传统的水平触发（Level Triggered），能够更加高效地处理 I/O 操作。</li>
<li><strong>适用场景</strong>：在高性能场景中使用，可以避免对文件描述符的重复检查。应用程序需要保证不会丢失事件，并且需要轮询所有事件，直到事件处理完成。</li>
<li><strong>使用场景</strong>：通常与 <code>EPOLLIN</code>、<code>EPOLLOUT</code> 等事件一同使用。</li>
</ul>
<ol start="7">
<li><strong><code>EPOLLONESHOT</code> - 单次触发</strong></li>
</ol>
<ul>
<li><strong>描述</strong>：表示文件描述符只会被触发一次事件。处理完事件后，<code>epoll</code> 会自动停止监视该文件描述符，直到再次通过 <code>epoll_ctl</code> 显式注册为监听状态。</li>
<li><strong>适用场景</strong>：用于那些只需要处理一次事件的场景，如处理某个特定的请求，处理完后不再关心该文件描述符。</li>
<li><strong>使用场景</strong>：一般用于一个事件只处理一次的情况，可以减少事件触发的次数，提高效率。</li>
</ul>
<ol start="8">
<li><strong><code>EPOLLPRI</code> - 优先事件</strong></li>
</ol>
<ul>
<li><strong>描述</strong>：表示文件描述符上发生了高优先级的事件。通常这种事件的优先级高于常规的 I/O 事件。</li>
<li><strong>适用场景</strong>：通常用于处理信号量、优先级消息队列等场景。</li>
</ul>
<ol start="9">
<li><strong><code>EPOLLWAKEUP</code> - 唤醒事件</strong></li>
</ol>
<ul>
<li><strong>描述</strong>：表示 <code>epoll</code> 实例在事件等待期间需要被唤醒。</li>
<li><strong>适用场景</strong>：适用于在多线程环境中希望从 <code>epoll_wait()</code> 等待事件的线程外部唤醒的情况。</li>
</ul>
<p><strong>组合使用的方式</strong></p>
<p><code>epoll</code> 事件通常可以组合使用，以满足更复杂的场景。例如，应用程序可以同时监视 <strong><code>EPOLLIN</code></strong> 和 **<code>EPOLLOUT</code>**，这样就可以同时处理读和写事件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">ev.events = EPOLLIN | EPOLLOUT | EPOLLERR;  <span class="comment">// 监听读、写和错误事件</span></span><br><span class="line">ev.data.fd = fd;</span><br><span class="line">epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br></pre></td></tr></table></figure>

<h5 id="基于epoll的服务端流程"><a href="#基于epoll的服务端流程" class="headerlink" title="基于epoll的服务端流程"></a>基于epoll的服务端流程</h5><p><a href="https://zhuanlan.zhihu.com/p/384098769">从内核看epoll的实现（基于5.9.9） - 知乎 (zhihu.com)</a></p>
<ol>
<li>服务器通过前文提到的listen()将普通的socket转换成专门用来监听的socket(Listened Socket)</li>
<li>服务端会去调用epoll_create，创建一个epoll实例，epoll实例中包含两个数据</li>
</ol>
<ul>
<li>红黑树（为空）：rb_root 用来去记录需要被监听的FD(Socket)</li>
<li>链表（为空）：list_head，用来存放已经就绪的FD<ul>
<li>创建好了之后，会去调用epoll_ctl函数，此函数将需要监听的数据添加到rb_root中去，并且对当前这些存在于红黑树的节点设置回调函数，（同时设置要监听什么类型的事件）当这些被监听的数据一旦准备完成，就会被调用，而调用的结果就是将红黑树的fd添加到list_head中去(但是此时并没有完成)</li>
</ul>
</li>
</ul>
<ol start="3">
<li>当第二步完成后，就会调用epoll_wait函数，这个函数会去校验是否有数据准备完毕（因为数据一旦准备就绪，就会被回调函数添加到list_head中），wait一段时间后(可配置)，如果等待超时，则返回无数据，如果有，则进一步判断当前是什么事件：</li>
</ol>
<ul>
<li>如果是<strong>监听Socket</strong>的FD发生了EPOLLIN事件，则调用accept() 获取已建立的TCP连接，开始准备IO。</li>
<li>如果是<strong>已连接Socket</strong>的EPOLLIN事件，则正常读取socket的数据</li>
</ul>
<p><strong>网络套接字</strong>：在使用 <code>epoll</code> 时，最常见的就是网络套接字（如 TCP 套接字）的数据就绪。具体来说，数据就绪意味着：</p>
<ul>
<li><strong>可读事件（<code>EPOLLIN</code>）</strong>：当套接字有数据可读时，<code>epoll_wait</code> 会返回，表明应用程序可以从套接字中读取数据。</li>
<li><strong>可写事件（<code>EPOLLOUT</code>）</strong>：当套接字可写时，即缓冲区有足够空间发送数据时，<code>epoll_wait</code> 会返回，表明应用程序可以向套接字写入数据。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653902845082.png" alt="1653902845082"></p>
<h4 id="信号驱动IO-Signal-Driven-IO"><a href="#信号驱动IO-Signal-Driven-IO" class="headerlink" title="信号驱动IO (Signal Driven IO)"></a>信号驱动IO (Signal Driven IO)</h4><p>信号驱动IO是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。</p>
<p>阶段一：</p>
<ul>
<li>用户进程调用sigaction，注册信号处理函数</li>
<li>内核返回成功，开始监听FD</li>
<li>用户进程不阻塞等待，可以执行其它业务</li>
<li>当内核数据就绪后，回调用户进程的SIGIO处理函数</li>
</ul>
<p>阶段二：</p>
<ul>
<li>收到SIGIO回调信号</li>
<li>调用recvfrom，读取</li>
<li>内核将数据拷贝到用户空间</li>
<li>用户进程处理数据</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653911776583.png" alt="1653911776583"></p>
<p>当有大量IO操作时，信号较多，SIGIO处理函数不能及时处理可能导致信号队列溢出，而且内核空间与用户空间的频繁信号交互性能也较低。</p>
<p>与NIO要做区分：NIO会一直空轮询，SIGIO只会询问一次。</p>
<h4 id="异步IO-Asynchronous-IO"><a href="#异步IO-Asynchronous-IO" class="headerlink" title="异步IO (Asynchronous IO)"></a>异步IO (Asynchronous IO)</h4><p>这种方式，不仅仅是用户态在试图读取数据后，不阻塞，而且当内核的数据准备完成后，也不会阻塞</p>
<p>他会由内核将所有数据处理完成后，由内核将数据写入到用户态中，然后才算完成，所以性能极高，不会有任何阻塞，全部都由内核完成，可以看到，异步IO模型中，用户进程在两个阶段都是非阻塞状态。</p>
<p>缺陷：高并发下，内核中积累的IO任务很多，消耗太多系统资源从而导致崩溃，所以要求限流机制。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653911877542.png" alt="1653911877542"></p>
<h4 id="五种IO模型对比"><a href="#五种IO模型对比" class="headerlink" title="五种IO模型对比"></a>五种IO模型对比</h4><p>最后用一幅图，来说明他们之间的区别</p>
<p>同步IO or 异步IO 取决于从内核拷贝到用户空间时是否阻塞</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653912219712.png" alt="1653912219712"></p>
<h3 id="Redis-单线程？"><a href="#Redis-单线程？" class="headerlink" title="Redis 单线程？"></a>Redis 单线程？</h3><h4 id="到底是单线程还是多线程？"><a href="#到底是单线程还是多线程？" class="headerlink" title="到底是单线程还是多线程？"></a>到底是单线程还是多线程？</h4><ul>
<li>如果仅仅聊Redis的核心业务部分（命令处理），答案是单线程</li>
<li>如果是聊整个Redis，那么答案就是多线程</li>
</ul>
<p>在Redis版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：</p>
<ul>
<li>Redis v4.0：引入多线程异步处理一些耗时较长的任务，例如异步删除命令unlink(另开一个线程删除bigKey)</li>
<li>Redis v6.0：在核心网络模型中引入 多线程，进一步提高对于多核CPU的利用率</li>
</ul>
<p>因此，对于Redis的核心网络模型，在Redis 6.0之前确实都是单线程。是利用epoll（Linux系统）这样的IO多路复用技术在事件循环中不断处理客户端情况。</p>
<h4 id="为什么Redis要选择单线程？"><a href="#为什么Redis要选择单线程？" class="headerlink" title="为什么Redis要选择单线程？"></a><strong>为什么Redis要选择单线程？</strong></h4><ul>
<li>抛开持久化不谈，Redis是<strong>纯内存</strong>操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升。</li>
<li>多线程会导致过多的上下文切换，带来不必要的开销</li>
<li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣</li>
</ul>
<h3 id="Reactor-Event-driven-I-O-Model"><a href="#Reactor-Event-driven-I-O-Model" class="headerlink" title="Reactor: Event-driven I/O Model"></a>Reactor: Event-driven I/O Model</h3><h4 id="AE-事件库"><a href="#AE-事件库" class="headerlink" title="AE 事件库"></a>AE 事件库</h4><p>C/C++ 指针与引用</p>
<blockquote>
<table>
<thead>
<tr>
<th>运算符</th>
<th>用途</th>
<th>使用对象</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>.</code></td>
<td>访问对象的成员 C++</td>
<td>非指针对象</td>
<td><code>obj.value</code>, <code>obj.print()</code></td>
</tr>
<tr>
<td><code>-&gt;</code></td>
<td>通过指针访问对象的成员C</td>
<td>指针对象</td>
<td><code>ptr-&gt;value</code>, <code>ptr-&gt;print()</code></td>
</tr>
<tr>
<td><code>::</code></td>
<td>访问特定作用域中的成员 C++</td>
<td>命名空间、类、全局作用域等</td>
<td><code>std::cout</code>, <code>ClassName::member</code></td>
</tr>
</tbody></table>
<p><code>int&amp; ref = x;</code>引用变量，得到x的引用，交给ref引用。（only in c++，弱化版指针）</p>
<p><code>int* ptr = &amp;x;</code>指针变量，取x的地址，赋值给ptr指针。</p>
<p><code>int val = x;</code> 普通变量，将x的值复制到val中。</p>
<p>访问x： ref 或 *ptr</p>
</blockquote>
<p><em>A simple Event-driven programming library</em> </p>
<p><a href="https://blog.csdn.net/androidlushangderen/article/details/40474815">Redis源码分析（二十）— ae事件驱动_aeCreateEventLoop setSize-CSDN博客</a></p>
<p>Redis做了跨平台整合，把不同OS的IO多路复用函数封装到统一的API中——AE</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241116140955535.png" alt="image-20241116140955535"></p>
<blockquote>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241116145235220.png" alt="image-20241116145235220"></p>
<ol>
<li>创建监听socket，并开始监听这个socket，acceptTcpHandler用于监听通信socket的可读事件的回调函数</li>
<li>设置<code>beforeSleepProcessor</code>，用于sleep之前的一些准备工作，一旦开始epoll_wait如果没有就绪就会sleep。</li>
<li>在<code>aeProcessEvents</code>中处理事件，首先调用<code>beforeSleep</code>，然后开始<code>epoll_wait</code>等待就绪socketFD</li>
<li>拿到就绪的socketFD集合之后，遍历处理，分别调用对应的不同的事件处理器(每个socket事件类型不同，处理器也不同)</li>
</ol>
</blockquote>
<h4 id="IO多路复用-命令处理模型"><a href="#IO多路复用-命令处理模型" class="headerlink" title="IO多路复用+命令处理模型"></a>IO多路复用+命令处理模型</h4><h5 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h5><blockquote>
<p><code>acceptTcpHandler</code>：TCP连接建立处理器</p>
<ul>
<li>大名鼎鼎的accept函数返回已经建立连接的socket FD，</li>
<li>然后会创建一个connection关联此socket，监听socketFD可读事件，把命令读取处理器（回调函数）绑定到socketFD上</li>
<li>随后才能开始socket的IO操作</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241116150329753.png" alt="image-20241116150329753"></p>
<p><code>readQueryFromClient:</code>命令读取处理器</p>
<ul>
<li>获取命令：client（绑定了socketFD）具备读写缓冲区，从缓冲区中获取字节流，转换成SDS字符串并存入client-&gt;argv[] </li>
<li>处理命令：命令由多个SDS构成，从缓冲区中读取之后存入一个ARGV数组中，<code>set name Jack</code> lookUpCommand 先要读取命令的类型，然后通过查找<code>set -&gt; setCommand(client *c)（指针）</code>的映射表来确定要执行命令的具体函数，随后proc执行回调函数。这里也体现出回调函数的优越性：充分解耦。</li>
<li>返回命令：addReply将执行结果作为SDS写到缓冲区中，满则写入链表。</li>
<li>写回命令：最后将客户端加入待写出的队列中。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241116153602252.png" alt="image-20241116153602252"></p>
<p><code>sendReplyFromClient</code>: 执行结果写回处理器</p>
<p>之前的beforeSleep，在正式开始监听事件之前，会遍历上文的待写队列，</p>
<p>监听待写client的socketFD可写事件，然后把写回处理器（回调函数）绑定到socketFD上，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241116162517768.png" alt="image-20241116162517768"></p>
</blockquote>
<h5 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h5><p>简单来说，在正式监听之前首先要<strong>注册</strong>不同的事件，将其绑定到特定socket上，事件真正发生以后会触发处理器回调函数</p>
<table>
<thead>
<tr>
<th align="center">事件名称</th>
<th align="center">监听socket 可读</th>
<th align="center">已连接socket 可读</th>
<th align="center">已连接socket 可写</th>
</tr>
</thead>
<tbody><tr>
<td align="center">绑定时机</td>
<td align="center">创建监听socket时(createSocketAcceptHandler)</td>
<td align="center">创建已连接socket时(acceptTcpHandler)</td>
<td align="center">监听开始前(beforeSleep)</td>
</tr>
<tr>
<td align="center">绑定对象</td>
<td align="center">监听socket</td>
<td align="center">已连接socket</td>
<td align="center">待写队列中的已连接socket</td>
</tr>
<tr>
<td align="center">处理器</td>
<td align="center">acceptTcpHandler (创建TCP连接)</td>
<td align="center">readQueryFromClient (读取处理命令)</td>
<td align="center">sendReplyToClient (写回)</td>
</tr>
</tbody></table>
<h5 id="Redis-单线程网络模型"><a href="#Redis-单线程网络模型" class="headerlink" title="Redis 单线程网络模型"></a>Redis 单线程网络模型</h5><p>IO Multiplexing + Event Distributing = <code>eventLoop</code> -&gt; <code>beforeSleep</code> -&gt; <code>aeApiPoll</code>(<code>epoll_wait</code>)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653982278727.png" alt="1653982278727"></p>
<p>当我们的客户端想要去连接我们服务器，会去先到IO多路复用模型去进行排队，会有一个连接应答处理器，他会去接受读请求，然后又把读请求注册到具体模型中去，此时这些建立起来的连接，如果是客户端请求处理器去进行执行命令时，他会去把数据读取出来，然后把数据放入到client中， client去解析当前的命令转化为redis认识的命令，接下来就开始处理这些命令，从redis中的command中找到这些命令，然后就真正的去操作对应的数据了，当数据操作完成后，会去找到命令回复处理器，再由他将数据写出。</p>
<p>简</p>
<h4 id="多线程网络模型——解决网络IO瓶颈"><a href="#多线程网络模型——解决网络IO瓶颈" class="headerlink" title="多线程网络模型——解决网络IO瓶颈"></a>多线程网络模型——解决网络IO瓶颈</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241116173420995.png" alt="image-20241116173420995"></p>
<p>原来的性能瓶颈出现在网络IO，从IO流中读取信息比较耗时，因此将读取命令和写回结果的任务派发给子线程</p>
<p>但是真正执行命令的过程并不是瓶颈（基于内存已经很快了）所以命令执行依然是单线程 </p>
<p><a href="https://blog.csdn.net/ldw201510803006/article/details/124365838#:~:text=%E6%88%91%E4%BB%AC%E5%85%88%E6%9D%A5%E7%9C%8B%E7%9C%8B%EF%BC%8C%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%9C%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E9%98%B6%E6%AE%B5%EF%BC%9A">高性能网络编程之 Reactor 网络模型（彻底搞懂）_reactor网络模型-CSDN博客</a> </p>
<p><a href="https://juejin.cn/post/7124667316637270046#heading-11">Redis中的Reactor模型介绍Reactor模型，并对比Redis 6.0之前的单线程模型 与 Redis 6.0 - 掘金 (juejin.cn)</a> </p>
<h2 id="Redis通信协议"><a href="#Redis通信协议" class="headerlink" title="Redis通信协议"></a>Redis通信协议</h2><h3 id="RESP协议"><a href="#RESP协议" class="headerlink" title="RESP协议"></a>RESP协议</h3><p>Redis是一个C/S架构的软件，通信一般分两步（不包括pipeline和PubSub）：</p>
<ol>
<li>客户端（Client）向服务端（Server）发送一条命令</li>
<li>服务端解析并执行命令，返回响应结果给客户端</li>
</ol>
<p>因此客户端发送命令的格式、服务端响应结果的格式必须有一个规范，这个规范就是通信协议。(B/S架构为HTTP协议)</p>
<p><a href="https://blog.csdn.net/freee12/article/details/114411950">FTP、TFTP、HTTP、SMTP、DHCP、Telnet、DNS、SNMP(网络协议：应用层协议）-CSDN博客</a></p>
<p>Redis采用RESP（Redis Serialization Protocol）协议：</p>
<ul>
<li><p>Redis 1.2版本引入了RESP协议</p>
</li>
<li><p>Redis 2.0版本中成为与Redis服务端通信的标准，称为RESP2</p>
</li>
<li><p>Redis 6.0版本中，从RESP2升级到了RESP3协议，增加了更多数据类型并且支持6.0的新特性–客户端缓存</p>
</li>
</ul>
<p>但目前，默认使用的依然是RESP2协议，也是我们要学习的协议版本（以下简称RESP）。</p>
<p>在RESP中，通过首字节的字符来区分不同数据类型，常用的数据类型包括5种：</p>
<p>单行字符串：首字节是 ‘+’ ，后面跟上单行字符串，以CRLF（ “\r\n” ）结尾。例如返回”OK”： “+OK\r\n”</p>
<p>错误（Errors）：首字节是 ‘-’ ，与单行字符串格式一样，只是字符串是异常信息，例如：”-Error message\r\n”</p>
<p>数值：首字节是 ‘:’ ，后面跟上数字格式的字符串，以CRLF结尾。例如：”:10\r\n”</p>
<p>多行字符串：首字节是 ‘$’ ，表示二进制安全的字符串，最大支持512MB：</p>
<p>如果大小为0，则代表空字符串：”$0\r\n\r\n”</p>
<p>如果大小为-1，则代表不存在：”$-1\r\n”</p>
<p>数组：首字节是 ‘*’，后面跟上数组元素个数，再跟上元素，元素数据类型不限:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653982993020.png" alt="1653982993020"></p>
<h3 id="基于Socket自定义Redis客户端"><a href="#基于Socket自定义Redis客户端" class="headerlink" title="基于Socket自定义Redis客户端"></a>基于Socket自定义Redis客户端</h3><p>Redis支持TCP通信，因此我们可以使用Socket来模拟客户端，与Redis服务端建立连接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Socket s;</span><br><span class="line">    <span class="keyword">static</span> PrintWriter writer;</span><br><span class="line">    <span class="keyword">static</span> BufferedReader reader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.建立连接</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;192.168.150.101&quot;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">6379</span>;</span><br><span class="line">            s = <span class="keyword">new</span> <span class="title class_">Socket</span>(host, port);</span><br><span class="line">            <span class="comment">// 2.获取输出流、输入流</span></span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(s.getOutputStream(), StandardCharsets.UTF_8));</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream(), StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.发出请求</span></span><br><span class="line">            <span class="comment">// 3.1.获取授权 auth 123321</span></span><br><span class="line">            sendRequest(<span class="string">&quot;auth&quot;</span>, <span class="string">&quot;123321&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2.set name 虎哥</span></span><br><span class="line">            sendRequest(<span class="string">&quot;set&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">            <span class="comment">// 4.解析响应</span></span><br><span class="line">            obj = handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2.set name 虎哥</span></span><br><span class="line">            sendRequest(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="comment">// 4.解析响应</span></span><br><span class="line">            obj = handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2.set name 虎哥</span></span><br><span class="line">            sendRequest(<span class="string">&quot;mget&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;num&quot;</span>, <span class="string">&quot;msg&quot;</span>);</span><br><span class="line">            <span class="comment">// 4.解析响应</span></span><br><span class="line">            obj = handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 5.释放连接</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (reader != <span class="literal">null</span>) reader.close();</span><br><span class="line">                <span class="keyword">if</span> (writer != <span class="literal">null</span>) writer.close();</span><br><span class="line">                <span class="keyword">if</span> (s != <span class="literal">null</span>) s.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">handleResponse</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 读取首字节</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prefix</span> <span class="operator">=</span> reader.read();</span><br><span class="line">        <span class="comment">// 判断数据类型标示</span></span><br><span class="line">        <span class="keyword">switch</span> (prefix) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="comment">// 单行字符串，直接读一行</span></span><br><span class="line">                <span class="keyword">return</span> reader.readLine();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="comment">// 异常，也读一行</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(reader.readLine());</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>: <span class="comment">// 数字</span></span><br><span class="line">                <span class="keyword">return</span> Long.parseLong(reader.readLine());</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;$&#x27;</span>: <span class="comment">// 多行字符串</span></span><br><span class="line">                <span class="comment">// 先读长度</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.parseInt(reader.readLine());</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 再读数据,读len个字节。我们假设没有特殊字符，所以读一行（简化）</span></span><br><span class="line">                <span class="keyword">return</span> reader.readLine();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> readBulkString();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;错误的数据格式！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">readBulkString</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取数组大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.parseInt(reader.readLine());</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义集合，接收多个元素</span></span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(len);</span><br><span class="line">        <span class="comment">// 遍历，依次读取每个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            list.add(handleResponse());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set name 虎哥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendRequest</span><span class="params">(String ... args)</span> &#123;</span><br><span class="line">        writer.println(<span class="string">&quot;*&quot;</span> + args.length);</span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">            writer.println(<span class="string">&quot;$&quot;</span> + arg.getBytes(StandardCharsets.UTF_8).length);</span><br><span class="line">            writer.println(arg);</span><br><span class="line">        &#125;</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Redis内存回收"><a href="#Redis内存回收" class="headerlink" title="Redis内存回收"></a>Redis内存回收</h2><h3 id="过期key处理"><a href="#过期key处理" class="headerlink" title="过期key处理"></a>过期key处理</h3><p>Redis之所以性能强，最主要的原因就是基于内存存储。然而单节点的Redis其内存大小不宜过大，会影响持久化或主从同步性能。<br>我们可以通过修改配置文件来设置Redis的最大内存：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653983341150.png" alt="1653983341150"></p>
<p>当内存使用达到上限时，就无法存储更多数据了。为了解决这个问题，Redis提供了一些策略实现内存回收：</p>
<p>内存过期策略</p>
<p>在学习Redis缓存的时候我们说过，可以通过expire命令给Redis的key设置TTL（存活时间）：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653983366243.png" alt="1653983366243"></p>
<p>可以发现，当key的TTL到期以后，再次访问name返回的是nil，说明这个key已经不存在了，对应的内存也得到释放。从而起到内存回收的目的。</p>
<h4 id="RedisDB-结构"><a href="#RedisDB-结构" class="headerlink" title="RedisDB 结构"></a>RedisDB 结构</h4><p>Redis本身是一个典型的key-value内存存储数据库，因此所有的key、value都保存在之前学习过的Dict结构中。不过在其db结构体中，有两个Dict：一个用来记录key-value；另一个用来记录key-TTL。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653983423128.png" alt="redisDb 结构体"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653983606531.png" alt="1653983606531"></p>
<p>这里有两个问题需要我们思考：<br>Redis是如何知道一个key是否过期呢？</p>
<p>利用两个Dict分别记录key-value对及key-ttl对</p>
<p>是不是TTL到期就立即删除了呢？</p>
<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a><strong>惰性删除</strong></h4><p>惰性删除：顾明思议并不是在TTL到期后就立刻删除，而是在访问一个key的时候，检查该key的存活时间，如果已经过期才执行删除。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653983652865.png" alt="1653983652865"></p>
<h4 id="周期删除"><a href="#周期删除" class="headerlink" title="周期删除"></a><strong>周期删除</strong></h4><p>周期删除：通过一个定时任务，周期性的抽样部分过期的key，然后执行删除。执行周期有两种：</p>
<ul>
<li>Redis服务初始化函数initServer()中设置定时任务，按照server.hz的频率来执行过期key清理，模式为SLOW</li>
<li>Redis的每个事件循环前会调用beforeSleep()函数，执行过期key清理，模式为FAST</li>
</ul>
<p>SLOW模式规则：低频 高时长</p>
<ul>
<li>执行频率受server.hz影响，默认为10，即每秒执行10次，每个执行周期100ms。</li>
<li>执行清理耗时不超过一次执行周期的25%.默认slow模式耗时不超过25ms</li>
<li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</li>
<li>如果没达到时间上限（25ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li>
</ul>
<p>FAST模式规则（过期key比例小于10%不执行 ）    高频 低时长</p>
<ul>
<li>执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms</li>
<li>执行清理耗时不超过1ms</li>
<li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期<br>如果没达到时间上限（1ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li>
</ul>
<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>RedisKey的TTL记录方式：</p>
<ul>
<li>在RedisDB中通过一个Dict记录每个Key的TTL时间</li>
</ul>
<p>过期key的删除策略：</p>
<ul>
<li><p>惰性清理：每次查找key时判断是否过期，如果过期则删除</p>
</li>
<li><p>定期清理：定期抽样部分key，判断是否过期，如果过期则删除。</p>
</li>
</ul>
<p>定期清理的两种模式：</p>
<ul>
<li><p>SLOW模式执行频率默认为10，每次不超过25ms，低频高时长</p>
</li>
<li><p>FAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms，高频低时长</p>
</li>
</ul>
<h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>内存淘汰：就是当Redis内存使用达到设置的上限时，主动挑选部分key删除以释放更多内存的流程。Redis会在处理客户端命令的方法processCommand()中尝试做内存淘汰：（时机：调用真正的 回调函数之前）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653983978671.png" alt="1653983978671"></p>
<h4 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h4><p>Redis支持8种不同策略来选择要删除的key：</p>
<ul>
<li><p>noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。</p>
</li>
<li><p>volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</p>
</li>
<li><p>allkeys-random：对全体key ，随机进行淘汰。也就是直接从db-&gt;dict中随机挑选。</p>
</li>
<li><p>volatile-random：对设置了TTL的key ，随机进行淘汰。也就是从db-&gt;expires中随机挑选。</p>
</li>
<li><p>allkeys-lru： 对全体key，基于LRU算法进行淘汰</p>
</li>
<li><p>volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰</p>
</li>
<li><p>allkeys-lfu： 对全体key，基于LFU算法进行淘汰</p>
</li>
<li><p>volatile-lfu： 对设置了TTL的key，基于LFI算法进行淘汰</p>
</li>
</ul>
<h4 id="LRU-LFU"><a href="#LRU-LFU" class="headerlink" title="LRU LFU"></a>LRU LFU</h4><p>比较容易混淆的有两个：</p>
<ul>
<li>LRU（Least Recently Used），最少最近使用。最后一次访问时间越小则淘汰优先级越高。</li>
<li>LFU（Least Frequently Used），最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。</li>
</ul>
<p>Redis的数据都会被封装为RedisObject结构：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653984029506.png" alt="1653984029506"></p>
<p>LFU的访问次数之所以叫做逻辑访问次数，是因为并不是每次key被访问都计数，而是通过运算：</p>
<ul>
<li>生成0~1之间的随机数R</li>
<li>计算 (旧次数 * lfu_log_factor + 1)，记录为P</li>
<li>如果 R &lt; P ，则计数器 + 1，且最大不超过255</li>
<li>访问次数会随时间衰减，距离上一次访问时间每隔 lfu_decay_time 分钟，计数器 -1</li>
</ul>
<ul>
<li>Redis 在键的元数据中为每个键维护一个 <code>LFU 信息</code>，它是一个 8 位的字段。</li>
<li>这个字段的两个部分：<ul>
<li><strong>前 6 位</strong>（称为 <code>log-based counter</code>）：表示键的访问频率。</li>
<li><strong>后 2 位</strong>：存储时间相关信息，用于对计数的衰减。</li>
</ul>
</li>
</ul>
<p>Redis 的访问计数器设计为 <strong>对数型增长</strong>，原因是避免计数器线性增长带来的溢出问题，同时降低热点数据被频繁访问的影响。</p>
<p>Redis 定期对计数值进行衰减，确保长期未访问的键逐渐失去其高计数值。</p>
<ul>
<li>衰减机制使用 Redis 的 <code>LFU_DECAY_TIME</code> 参数控制，默认值为 1 分钟。</li>
<li>每次访问键时，Redis 检查上次更新计数的时间。如果超过 <code>LFU_DECAY_TIME</code>，就会减少计数值。</li>
</ul>
<p>$$<br>\text{新计数} = \text{旧计数} \times (0.5)^{\frac{\text{时间差}}{\text{LFU_DECAY_TIME}}}<br>$$</p>
<p><strong>计算淘汰优先级</strong></p>
<p>在淘汰键时，Redis 根据 LFU 计数选择淘汰候选：</p>
<ul>
<li>计数值越低，淘汰优先级越高。</li>
<li>如果计数值相同，Redis 会根据其他元数据（如键的创建时间）来辅助决定。</li>
</ul>
<p>Redis 提供了以下两种与 LFU 相关的内存淘汰策略：</p>
<ol>
<li><code>volatile-lfu</code>：从设置了过期时间的键中使用 LFU 策略淘汰。</li>
<li><code>allkeys-lfu</code>：从所有键中使用 LFU 策略淘汰。</li>
</ol>
<p>可以在 <code>redis.conf</code> 文件中设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">maxmemory-policy allkeys-lfu</span><br></pre></td></tr></table></figure>

<p>Redis 的 LFU 实现基于紧凑的计数器设计，并通过概率增长与时间衰减结合，达到高效的淘汰效果。它是 Redis 用于管理内存淘汰的重要策略之一，适合高访问频率场景下的优化。</p>
<h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653984085095.png" alt="1653984085095"></p>
<p>淘汰池子，加入抽样调查key，</p>
<p>淘汰规则：按照idleTime升序排序，值大的优先淘汰</p>
<p>LRU LFU TTL 都是值越小越应该淘汰，因此idleTime优先淘汰值大的</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>nio</tag>
        <tag>redis</tag>
        <tag>skiplist</tag>
        <tag>zset</tag>
        <tag>hash</tag>
        <tag>dict</tag>
        <tag>reactor</tag>
        <tag>socket</tag>
        <tag>io-multiplexing</tag>
        <tag>epoll</tag>
        <tag>内存淘汰</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 分布式应用</title>
    <url>/2024/08/14/redis-advanced/</url>
    <content><![CDATA[<h1 id="——分布式缓存——"><a href="#——分布式缓存——" class="headerlink" title="——分布式缓存——"></a>——分布式缓存——</h1><p>– 基于Redis集群解决单机Redis存在的问题</p>
<p>单机的Redis存在四大问题：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725144240631.png" alt="image-20210725144240631"></p>
<h1 id="一、Redis持久化"><a href="#一、Redis持久化" class="headerlink" title="一、Redis持久化"></a>一、Redis持久化</h1><p>Redis有两种持久化方案：</p>
<ul>
<li>RDB持久化</li>
<li>AOF持久化</li>
</ul>
<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照（<mark>SNAPSHOT<mark>）。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p>
<p>执行时机</p>
<p>RDB持久化在四种情况下会执行：</p>
<ul>
<li>执行save命令</li>
<li>执行bgsave命令</li>
<li>Redis停机时</li>
<li>触发RDB条件时</li>
</ul>
<p><strong>1）save命令</strong></p>
<p>执行下面的命令，可以立即执行一次RDB：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725144536958.png" alt="image-20210725144536958"></p>
<p>save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</p>
<p><strong>2）bgsave命令</strong></p>
<p>下面的命令可以异步执行RDB：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725144725943.png" alt="image-20210725144725943"></p>
<p>这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</p>
<p><strong>3）停机时</strong></p>
<p>Redis停机时会执行一次save命令，实现RDB持久化。</p>
<p><strong>4）触发RDB条件</strong></p>
<p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 900秒内，如果至少有1个key发生变化，则自动执行bgsave ， 如果是save &quot;&quot; 则表示:禁用RDB</span></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000 </span></span><br></pre></td></tr></table></figure>

<p>RDB的其它配置也可以在redis.conf文件中设置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘不值钱</span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># RDB文件名称</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb  </span></span><br><span class="line"><span class="comment"># 文件保存的路径目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">./ </span></span><br></pre></td></tr></table></figure>

<h3 id="RDB-原理"><a href="#RDB-原理" class="headerlink" title="RDB 原理"></a>RDB 原理</h3><p>bgsave开始时会 <strong>fork</strong> 主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p>
<p>fork采用的是copy-on-write技术：写入时复制</p>
<ul>
<li>当主进程执行读操作时，访问共享内存；</li>
<li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725151319695.png" alt="image-20210725151319695"></p>
<p>如果在RDB过程中，修改了所有的数据，那么redis占用内存将直接<mark>翻倍<mark></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="RDB方式bgsave的基本流程？"><a href="#RDB方式bgsave的基本流程？" class="headerlink" title="RDB方式bgsave的基本流程？"></a>RDB方式bgsave的基本流程？</h4><ul>
<li>fork主进程得到一个子进程，共享内存空间</li>
<li>子进程读取内存数据并写入新的RDB文件</li>
<li>用新RDB文件替换旧的RDB文件</li>
</ul>
<h4 id="RDB会在什么时候执行？save-60-1000代表什么含义？"><a href="#RDB会在什么时候执行？save-60-1000代表什么含义？" class="headerlink" title="RDB会在什么时候执行？save 60 1000代表什么含义？"></a>RDB会在什么时候执行？save 60 1000代表什么含义？</h4><ul>
<li>默认是服务停止时</li>
<li>代表60秒内至少执行1000次修改则触发RDB</li>
</ul>
<h4 id="RDB的缺点？"><a href="#RDB的缺点？" class="headerlink" title="RDB的缺点？"></a>RDB的缺点？</h4><ul>
<li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li>
<li>fork子进程、压缩、写出RDB文件都比较耗时，仅仅修改save命令的第一个参数不会提高RDB执行的效率</li>
</ul>
<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><h3 id="AOF-原理"><a href="#AOF-原理" class="headerlink" title="AOF 原理"></a>AOF 原理</h3><p>AOF全称为<mark>Append Only File<mark>（追加文件）。Redis处理的<mark>每一个写命令<mark>都会记录在AOF文件，可以看做是命令日志文件。(binlog in MySQL)。AOF是执行命令之后写入，binlog是执行之前写入</p>
<ul>
<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>
<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>
<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>
<li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725151543640.png" alt="image-20210725151543640"></p>
<h3 id="AOF-配置"><a href="#AOF-配置" class="headerlink" title="AOF 配置"></a>AOF 配置</h3><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否开启AOF功能，默认是no</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># AOF文件的名称</span></span><br><span class="line"><span class="attr">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure>

<p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 表示每执行一次写命令，立即记录到AOF文件</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">always </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">everysec </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">no</span></span><br></pre></td></tr></table></figure>

<p>三种策略对比：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725151654046.png" alt="image-20210725151654046"></p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241117220311689.png" alt="image-20241117220311689" style="zoom: 50%;" />

<h3 id="AOF-步骤"><a href="#AOF-步骤" class="headerlink" title="AOF 步骤"></a>AOF 步骤</h3><p><strong>命令追加（append）</strong>：所有的写命令会追加到 AOF 缓冲区中。</p>
<p><strong>文件写入（write）</strong>：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用<code>write</code>函数（系统调用），<code>write</code>将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。写入系统内核缓冲区之后直接返回（仅仅是写到缓冲区），不会立即同步到硬盘。虽然提高了效率，但也带来了数据丢失的风险。同步硬盘操作通常依赖于系统调度机制，Linux 内核通常为 30s 同步一次，具体值取决于写出的数据量和 I/O 缓冲区的状态。</p>
<p><strong>文件同步（fsync）</strong>：AOF 缓冲区根据对应的持久化方式（ <code>fsync</code> 策略）向硬盘做同步操作。这一步需要调用 <code>fsync</code> 函数（系统调用）， <code>fsync</code> 针对单个文件操作，对其进行强制硬盘同步，<code>fsync</code> 将阻塞直到写入磁盘完成后返回，保证了数据持久化。强制刷新系统内核缓冲区（同步到到磁盘），确保写磁盘操作结束才会返回。</p>
<p><strong>文件重写（rewrite）</strong>：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</p>
<p><strong>重启加载（load）</strong>：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aof-work-process.png"></p>
<p>从 Redis 7 开始，Redis 使用了 <strong>Multi Part AOF</strong> 机制。顾名思义，Multi Part AOF 就是将原来的单个 AOF 文件拆分成多个 AOF 文件。在 Multi Part AOF 中，AOF 文件被分为三种类型，分别为：</p>
<ul>
<li>BASE：表示基础 AOF 文件，它一般由子进程通过重写产生，该文件最多只有一个。</li>
<li>INCR：表示增量 AOF 文件，它一般会在 AOFRW 开始执行时被创建，该文件可能存在多个。</li>
<li>HISTORY：表示历史 AOF 文件，它由 BASE 和 INCR AOF 变化而来，每次 AOFRW 成功完成时，本次 AOFRW 之前对应的 BASE 和 INCR AOF 都将变为 HISTORY，HISTORY 类型的 AOF 会被 Redis 自动删除。</li>
</ul>
<h3 id="AOF-文件重写"><a href="#AOF-文件重写" class="headerlink" title="AOF 文件重写"></a>AOF 文件重写</h3><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行<code>bgrewriteaof</code>命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725151729118.png" alt="image-20210725151729118"></p>
<p>如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p>
<p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p>
<p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p>
<ol>
<li>增长百分比阈值</li>
<li>文件体积大小阈值</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span></span><br><span class="line"><span class="attr">auto-aof-rewrite-percentage</span> <span class="string">100</span></span><br><span class="line"><span class="comment"># AOF文件体积最小多大以上才触发重写 </span></span><br><span class="line"><span class="attr">auto-aof-rewrite-min-size</span> <span class="string">64mb </span></span><br></pre></td></tr></table></figure>

<h3 id="AOF-校验机制了解吗？"><a href="#AOF-校验机制了解吗？" class="headerlink" title="AOF 校验机制了解吗？"></a><a href="#aof-%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97">AOF 校验机制了解吗？</a></h3><p>AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。这个机制的原理其实非常简单，就是通过使用一种叫做 <strong>校验和（checksum）</strong> 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。因此，Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和（计算的时候会把最后一行保存校验和的内容给忽略点），从而判断 AOF 文件是否完整。如果发现文件有问题，Redis 就会拒绝启动并提供相应的错误信息。AOF 校验机制十分简单有效，可以提高 Redis 数据的可靠性。</p>
<hr>
<p>著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：<a href="https://javaguide.cn/database/redis/redis-persistence.html">https://javaguide.cn/database/redis/redis-persistence.html</a></p>
<h2 id="RDB与AOF对比"><a href="#RDB与AOF对比" class="headerlink" title="RDB与AOF对比"></a>RDB与AOF对比</h2><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p>
<ul>
<li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。</li>
<li>AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725151940515.png" alt="image-20210725151940515"></p>
<p>Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</p>
<p>Redis 7.0 版本之后，AOF 重写机制得到了优化改进。具体方法是采用 base（全量数据）+inc（增量数据）独立文件存储的方式，彻底解决内存和 IO 资源的浪费，同时也支持对历史 AOF 文件的保存管理，结合 AOF 文件中的时间信息还可以实现 PITR 按时间点恢复（阿里云企业版 Tair 已支持），这进一步增强了 Redis 的数据可靠性，满足用户数据回档等需求。</p>
<p><a href="https://mp.weixin.qq.com/s/RnoPPL7jiFSKkx3G4p57Pg">从Redis7.0发布看Redis的过去与未来 (qq.com)</a> </p>
<h1 id="二、Redis主从集群：应对高并发读"><a href="#二、Redis主从集群：应对高并发读" class="headerlink" title="二、Redis主从集群：应对高并发读"></a>二、Redis主从集群：应对高并发读</h1><p>Redis 通过 Replica/Slave 从节点机制 完成主从复制与读写分离</p>
<h2 id="搭建主从架构"><a href="#搭建主从架构" class="headerlink" title="搭建主从架构"></a>搭建主从架构</h2><p>主从复制：单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725152037611.png" alt="image-20210725152037611"></p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建三个文件夹，将redis.conf复制过去</span></span><br><span class="line"><span class="built_in">mkdir</span> 7001 7002 7003</span><br><span class="line"><span class="built_in">cp</span> redis-6.2.6/redis.conf 7001</span><br><span class="line"><span class="built_in">cp</span> redis-6.2.6/redis.conf 7002</span><br><span class="line"><span class="built_in">cp</span> redis-6.2.6/redis.conf 7003</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改redis.conf中的port、dir</span></span><br><span class="line">sed -i -e <span class="string">&#x27;s/6379/7001/g&#x27;</span> -e <span class="string">&#x27;s/dir .\//dir \/root\/redissetup\/7001\//g&#x27;</span> 7001/redis.conf</span><br><span class="line">sed -i -e <span class="string">&#x27;s/6379/7002/g&#x27;</span> -e <span class="string">&#x27;s/dir .\//dir \/root\/redissetup\/7002\//g&#x27;</span> 7002/redis.conf</span><br><span class="line">sed -i -e <span class="string">&#x27;s/6379/7003/g&#x27;</span> -e <span class="string">&#x27;s/dir .\//dir \/root\/redissetup\/7003\//g&#x27;</span> 7003/redis.conf</span><br><span class="line"><span class="comment"># 添加主从配置ip</span></span><br><span class="line">sed -i <span class="string">&#x27;1a replica-announce-ip localhost&#x27;</span> 7001/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;1a replica-announce-ip localhost&#x27;</span> 7002/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;1a replica-announce-ip localhost&#x27;</span> 7003/redis.conf</span><br><span class="line"><span class="comment"># 添加主从配置端口号 和 主节点的密码</span></span><br><span class="line">sed -i <span class="string">&#x27;1i slaveof 127.0.0.1 7001&#x27;</span> 7002/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;2i masterauth 123321&#x27;</span> 7002/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;1i slaveof 127.0.0.1 7001&#x27;</span> 7003/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;2i masterauth 123321&#x27;</span> 7003/redis.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动redis-server</span></span><br><span class="line">redis-server -p 7001/redis.conf</span><br><span class="line">redis-server -p 7002/redis.conf</span><br><span class="line">redis-server -p 7003/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动命令行</span></span><br><span class="line">redis-cli -p 7001</span><br><span class="line">redis-cli -p 7002</span><br><span class="line">redis-cli -p 7003</span><br><span class="line"></span><br><span class="line">INFO replication <span class="comment">#显示主从信息</span></span><br></pre></td></tr></table></figure>



<h2 id="主从数据同步原理"><a href="#主从数据同步原理" class="headerlink" title="主从数据同步原理"></a>主从数据同步原理</h2><h3 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h3><p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将master节点的所有数据都拷贝给slave节点，流程：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725152222497.png" alt="image-20210725152222497"></p>
<p>这里有一个问题，master如何得知slave是第一次来连接呢？？</p>
<p>有几个概念，可以作为判断依据：</p>
<ul>
<li><strong>Replication Id</strong>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid<mark>（表示主从关系）<mark> </li>
<li><strong>offset</strong>：偏移量，随着记录在repl_backlog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。<mark>（表示数据版本）<mark></li>
</ul>
<p>因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。</p>
<p>因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。</p>
<p>master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。</p>
<p>master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。</p>
<p>因此，<strong>master判断一个节点是否是第一次同步的依据，就是看replid是否一致</strong>。</p>
<p>如图：AOF + RDB</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725152700914.png" alt="image-20210725152700914"></p>
<p>完整流程描述：</p>
<ol>
<li><p>slave节点请求同步，发送replid + offset</p>
</li>
<li><p>master节点判断replid，发现不一致，则进行全量同步返回master的replid + offset</p>
<ul>
<li>master将完整内存数据生成RDB（bgsave）发送RDB到slave</li>
<li>slave清空本地数据，加载master的RDB</li>
<li>master将RDB期间的命令记录在repl_backlog，并持续将repl_backlog的命令发送给slave</li>
</ul>
</li>
<li><p>master节点判断replid，发现一致，并且offset较小</p>
<ul>
<li>去repl_backlog中取得offset之后的数据，将repl_backlog的命令发送给slave</li>
</ul>
</li>
<li><p>slave执行接收到的命令，保持与master之间的同步</p>
</li>
</ol>
<h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><p>全量同步需要先做RDB，然后将RDB文件通过网络传输给slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做<strong>增量同步</strong></p>
<p>什么是增量同步？就是只更新slave与master存在差异的部分数据。如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725153201086.png" alt="image-20210725153201086"></p>
<p>那么master怎么知道slave与自己的数据差异在哪里呢?</p>
<h3 id="repl-backlog原理"><a href="#repl-backlog原理" class="headerlink" title="repl_backlog原理"></a>repl_backlog原理</h3><p>master怎么知道slave与自己的数据差异在哪里呢?</p>
<p>这就要说到全量同步时的repl_backlog文件了。</p>
<p>这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖。</p>
<p>repl_backlog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725153359022.png" alt="image-20210725153359022"> </p>
<p>slave与master的offset之间的差异，就是slave需要增量拷贝的数据了。</p>
<p>随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725153524190.png" alt="image-20210725153524190"> </p>
<p>直到数组被填满：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725153715910.png" alt="image-20210725153715910"> </p>
<p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。</p>
<p>但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725153937031.png" alt="image-20210725153937031"> </p>
<p>slave : 5 master 110(10) 10-100错过的数据还在，错过了105-110(5-10)的数据</p>
<p>如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725154155984.png" alt="image-20210725154155984"> </p>
<p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725154216392.png" alt="image-20210725154216392"></p>
<h2 id="主从同步优化"><a href="#主从同步优化" class="headerlink" title="主从同步优化"></a>主从同步优化</h2><p>主从同步可以保证主从数据的一致性，非常重要。</p>
<p>可以从以下几个方面来优化Redis主从就集群：</p>
<ul>
<li><p>提高全量同步的性能</p>
<ul>
<li><p>在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。（磁盘慢，网络快）</p>
</li>
<li><p>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO（RDB 小）</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>适当提高repl_backlog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步(OFFSET_MAX)</li>
<li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力（减少压力）</li>
</ul>
<p>主从从架构图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725154405899.png" alt="image-20210725154405899"></p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><h3 id="简述全量同步和增量同步区别？"><a href="#简述全量同步和增量同步区别？" class="headerlink" title="简述全量同步和增量同步区别？"></a>简述全量同步和增量同步区别？</h3><ul>
<li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_backlog，逐个发送给slave。</li>
<li>增量同步：slave提交自己的offset到master，master获取repl_backlog中从offset之后的命令给slave</li>
</ul>
<h3 id="什么时候执行全量同步？"><a href="#什么时候执行全量同步？" class="headerlink" title="什么时候执行全量同步？"></a>什么时候执行全量同步？</h3><ul>
<li>slave节点第一次连接master节点时</li>
<li>slave节点断开时间太久，repl_backlog中的offset已经被覆盖时</li>
</ul>
<h3 id="什么时候执行增量同步？"><a href="#什么时候执行增量同步？" class="headerlink" title="什么时候执行增量同步？"></a>什么时候执行增量同步？</h3><ul>
<li>slave节点断开又恢复，并且在repl_backlog中能找到offset时</li>
</ul>
<h1 id="三、Redis哨兵集群：保证主从高可用性"><a href="#三、Redis哨兵集群：保证主从高可用性" class="headerlink" title="三、Redis哨兵集群：保证主从高可用性"></a>三、Redis哨兵集群：保证主从高可用性</h1><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。</p>
<h2 id="哨兵原理"><a href="#哨兵原理" class="headerlink" title="哨兵原理"></a>哨兵原理</h2><h3 id="集群结构和作用"><a href="#集群结构和作用" class="headerlink" title="集群结构和作用"></a>集群结构和作用</h3><p>哨兵的结构如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725154528072.png" alt="image-20210725154528072"></p>
<p>哨兵的作用如下：</p>
<ul>
<li><strong>监控</strong>：Sentinel 会不断检查您的master和slave是否按预期工作 </li>
<li><strong>自动故障恢复（转移）</strong>：如果master故障，Sentinel会<mark>将一个slave提升为master<mark>。当故障实例恢复后也以新的master为主</li>
<li><strong>通知</strong>：Sentinel充当Redis<mark>客户端的服务发现来源<mark>，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li>
</ul>
<h3 id="集群监控状态原理：心跳机制"><a href="#集群监控状态原理：心跳机制" class="headerlink" title="集群监控状态原理：心跳机制"></a>集群监控状态原理：心跳机制</h3><p>Sentinel基于<mark>心跳机制<mark>监测服务状态，每隔<mark>1秒<mark>向集群的每个实例<mark>发送ping命令<mark>：</p>
<p>•主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</p>
<p>•客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725154632354.png" alt="image-20210725154632354"></p>
<h3 id="集群故障恢复原理：选举机制"><a href="#集群故障恢复原理：选举机制" class="headerlink" title="集群故障恢复原理：选举机制"></a>集群故障恢复原理：选举机制</h3><p>一旦发现master故障，sentinel需要在slave中选择一个作为新的master，选择依据是这样的：</p>
<ul>
<li><strong>与master断开时间</strong>：首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</li>
<li><strong>优先级</strong>：然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</li>
<li><strong>offset</strong>：如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li>
<li><strong>运行id</strong>：最后是判断slave节点的运行id大小，越小优先级越高。每个 redis 节点启动时都有一个 40 字节随机字符串作为运行 id。</li>
</ul>
<p>当选出一个新的master后，该如何实现切换呢？</p>
<p>流程如下：</p>
<ul>
<li>sentinel给备选的slave1节点发送<code>slaveof no one</code>命令，让该节点成为master</li>
<li>sentinel给所有其它slave发送slaveof 127.0.0.1 7002(也就是slave1) 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</li>
<li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725154816841.png" alt="image-20210725154816841"></p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><h4 id="Sentinel的三个作用是什么？"><a href="#Sentinel的三个作用是什么？" class="headerlink" title="Sentinel的三个作用是什么？"></a>Sentinel的三个作用是什么？</h4><ul>
<li>监控</li>
<li>故障转移</li>
<li>通知</li>
</ul>
<h4 id="Sentinel如何判断一个redis实例是否健康？"><a href="#Sentinel如何判断一个redis实例是否健康？" class="headerlink" title="Sentinel如何判断一个redis实例是否健康？"></a>Sentinel如何判断一个redis实例是否健康？</h4><ul>
<li>每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线</li>
<li>如果大多数sentinel都认为实例主观下线，则判定服务下线</li>
</ul>
<h4 id="故障转移步骤有哪些？"><a href="#故障转移步骤有哪些？" class="headerlink" title="故障转移步骤有哪些？"></a>故障转移步骤有哪些？</h4><ul>
<li>首先选定一个slave作为新的master，执行slaveof no one</li>
<li>然后让所有节点(包括故障节点)都执行slaveof 新master</li>
<li>修改故障节点配置，添加slaveof 新master</li>
</ul>
<h2 id="搭建哨兵集群：master宕机案例"><a href="#搭建哨兵集群：master宕机案例" class="headerlink" title="搭建哨兵集群：master宕机案例"></a>搭建哨兵集群：master宕机案例</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119171035000.png" alt="image-20241119171035000"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119171850683.png" alt="image-20241119171850683"></p>
<p>从节点连不上主节点</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119172740595.png" alt="image-20241119172740595"></p>
<p>哨兵选举一个slave作为新的master</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119172833310.png" alt="image-20241119172833310"></p>
<p>被选中的slave变成master</p>
<h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。</p>
<p>下面，我们通过一个测试来实现RedisTemplate集成哨兵机制。</p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>在项目的pom文件中引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置Redis哨兵集群地址"><a href="#配置Redis哨兵集群地址" class="headerlink" title="配置Redis哨兵集群地址"></a>配置Redis哨兵集群地址</h3><p>然后在配置文件application.yml中指定redis的sentinel相关信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    sentinel:</span><br><span class="line">      master: mymaster</span><br><span class="line">      nodes:</span><br><span class="line">        - <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">27001</span><span class="comment">//哨兵一号</span></span><br><span class="line">        - <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">27002</span></span><br><span class="line">        - <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">27003</span></span><br></pre></td></tr></table></figure>

<p>哨兵的启动配置文件里已经有了主节点的一切信息，IP+PORT+quorum+name，只需要引入哨兵就能启用集群</p>
<h3 id="配置读写分离"><a href="#配置读写分离" class="headerlink" title="配置读写分离"></a>配置读写分离</h3><p>在项目的启动类中，添加一个新的bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="title function_">clientConfigurationBuilderCustomizer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个bean中配置的就是读写策略，包括四种：</p>
<ul>
<li>MASTER：从主节点读取</li>
<li>MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica</li>
<li>REPLICA：从slave（replica）节点读取</li>
<li><mark>REPLICA _PREFERRED<mark>：优先从slave（replica）节点读取，所有的slave都不可用才读取master</li>
</ul>
<p>每个节点都会建立连接，读取时会按照读写分离的策略读。</p>
<h1 id="四、Redis分片集群：应对高并发写、海量数据存储"><a href="#四、Redis分片集群：应对高并发写、海量数据存储" class="headerlink" title="四、Redis分片集群：应对高并发写、海量数据存储"></a>四、Redis分片集群：应对高并发写、海量数据存储</h1><p>Redis Cluster 解决了哨兵机制的弊端：每个实例全量存储，木桶效应，提供动态的横向扩展，</p>
<h2 id="纵向-横向扩展"><a href="#纵向-横向扩展" class="headerlink" title="纵向/横向扩展"></a>纵向/横向扩展</h2><p>纵向也可以多节点，纵/横的标准是：是否所有节点的存储内容都一样</p>
<p>究竟选择scale-up（纵向）还是scale-out（横向）架构,主要考虑以下因素：</p>
<table>
<thead>
<tr>
<th align="center">成本</th>
<th align="left">Scale-up架构只有容量升级的成本，不会增加控制器或基础设施的开销。如果我们主要衡量每GB存储的单位价格，scale-up的扩展方式无疑更便宜一些</th>
</tr>
</thead>
<tbody><tr>
<td align="center">容量</td>
<td align="left">两种解决方案都可以满足容量需求，但scale-up架构也许会有些限制，主要取决于单个系统最大支持多少个磁盘数量和多大的容量</td>
</tr>
<tr>
<td align="center">性能</td>
<td align="left">Scale-out架构在性能上具有扩展潜力，在多个存储控制器下，IOPS处理能力和吞吐带宽都可以聚合。虽然节点之间的通信会引发延迟，但那是部署时的细节问题</td>
</tr>
<tr>
<td align="center">管理</td>
<td align="left">Scale-up架构本身就是以单一系统的方式来进行管理的。而Scale-out架构通常有聚合管理的能力，但每个厂商提供的产品可能会有所不同</td>
</tr>
<tr>
<td align="center">复杂性</td>
<td align="left">Scale-up架构的存储相对简单，而scale-out架构的系统会更复杂一些，毕竟每个节点都需要管理</td>
</tr>
<tr>
<td align="center">可用性</td>
<td align="left">多个节点可以提供更好的可用性，假使有一个部件故障或失效，系统也不至于整体宕机。这一点与具体的实施方案也有关系</td>
</tr>
</tbody></table>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119184050478.png" alt="Scale-UP 纵向扩展"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119184124945.png" alt="Scale-OUT 横向扩展"></p>
<h2 id="搭建分片集群"><a href="#搭建分片集群" class="headerlink" title="搭建分片集群"></a>搭建分片集群</h2><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p>
<ul>
<li><p><mark>海量数据存储问题<mark></p>
</li>
<li><p><mark>高并发写的问题<mark></p>
</li>
</ul>
<p>使用横向扩展分片集群可以解决上述问题，如图:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725155747294.png" alt="分片集群"></p>
<p>分片集群特征：</p>
<ul>
<li><p>集群中有多个master，每个master保存不同数据</p>
</li>
<li><p>每个master都可以有多个slave节点（高可用）</p>
</li>
<li><p>slave 不对外提供读服务，主要用来保障 master 的高可用，做数据的热备份，当 master 出现故障的时候替代它。</p>
</li>
<li><p>master之间通过ping监测彼此健康状态（全员哨兵）</p>
</li>
<li><p>客户端请求可以访问集群任意节点，最终都会被自动路由转发到正确节点（自动路由）</p>
</li>
</ul>
<p>本质就是多个主从集群的互相监控，不需要另外sentinel的监控，不过此时的slave</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 开启集群功能</span></span><br><span class="line"><span class="attr">cluster-enabled</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># 集群的配置文件名称，不需要我们创建，由redis自己维护</span></span><br><span class="line"><span class="attr">cluster-config-file</span> <span class="string">/root/redissetup/6379/nodes.conf</span></span><br><span class="line"><span class="comment"># 节点心跳失败的超时时间</span></span><br><span class="line"><span class="attr">cluster-node-timeout</span> <span class="string">5000</span></span><br><span class="line"><span class="comment"># 持久化</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">/root/redissetup/6379</span></span><br><span class="line"></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># 主从ip地址</span></span><br><span class="line"><span class="attr">replica-announce-ip</span> <span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment"># 保护模式</span></span><br><span class="line"><span class="attr">protected-mode</span> <span class="string">no</span></span><br><span class="line"></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 日志记录</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">/root/redissetup/6379/run.log</span></span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t sed -i <span class="string">&#x27;s/6379/&#123;&#125;/g&#x27;</span> &#123;&#125;/redis.conf</span><br><span class="line"><span class="comment"># 编辑端口号</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-server &#123;&#125;/redis.conf</span><br><span class="line"><span class="comment"># 开启服务器实例</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas 1 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:8001 127.0.0.1:8002 127.0.0.1:8003</span><br><span class="line"><span class="comment"># 开启分片集群功能</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119193312708.png" alt="image-20241119193312708"></p>
<p>6/(1+1) = 3</p>
<p>！！！！！！！！</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119201022033.png" alt="image-20241119201022033"></p>
<p>启动一定加 -c</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119203336515.png" alt="image-20241119203336515"></p>
<p>查看节点状况</p>
<h2 id="散列插槽"><a href="#散列插槽" class="headerlink" title="散列插槽"></a>散列插槽</h2><h3 id="插槽原理"><a href="#插槽原理" class="headerlink" title="插槽原理"></a>插槽原理</h3><p>Redis Cluster 并没有使用一致性哈希，采用的是 哈希槽分区 ，每一个键值对都属于一个 hash slot（哈希槽） 。</p>
<p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725155820320.png" alt="image-20210725155820320"></p>
<p>数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p>
<ul>
<li><mark>key中包含”{}”，且“{}”中至少包含1个字符，“{}”中的部分是有效部分<mark> </li>
<li>key中不包含“{}”，整个key都是有效部分</li>
</ul>
<p>例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119201236259.png" alt="image-20241119201236259"> </p>
<p>如图，在7001这个节点执行set a 1时，对a做hash运算，对16384取余，得到的结果是15495，因此要存储到7003节点。</p>
<p>到了7003后，执行<code>get num</code>时，对num做hash运算，对16384取余，得到的结果是2765，因此需要切换到7001节点</p>
<p>当客户端发送命令请求的时候，需要</p>
<ul>
<li>先根据 key 找到的对应的哈希槽，</li>
<li>然后再查询哈希槽和节点的映射关系，即可找到目标节点。 </li>
</ul>
<h3 id="哈希槽数目为什么选择-16384？"><a href="#哈希槽数目为什么选择-16384？" class="headerlink" title="哈希槽数目为什么选择 16384？"></a>哈希槽数目为什么选择 16384？</h3><p><code>CRC16</code>算法产生的hash值有16bit，该算法可以产生2^16-=65536个值。换句话说，值是分布在0~65535之间。那作者在做<code>mod</code>运算的时候，为什么不<code>mod</code>65536，而选择<code>mod</code>16384？</p>
<p>哈希槽的数量选择 16384 而不是 65536 的主要原因：</p>
<ul>
<li>哈希槽太大会导致心跳包（包括slots信息）太大，消耗太多带宽； </li>
<li>哈希槽总数越少，对存储哈希槽信息的 bitmap 压缩效果越好； </li>
<li>Redis Cluster 的主节点通常不会扩展太多，16384 个哈希槽已经足够用了。</li>
</ul>
<p>一致性哈希理论上可以有2^32^个节点，实际上不会有那么多，</p>
<p>正常的心跳包会携带一个节点的完整配置，它会以幂等的方式更新旧的配置，这意味着心跳包会附 带当前节点的负责的哈希槽的信息。假设哈希槽采用 16384 ,则占空间 2k(16384/8)。假设哈希槽 采用 65536， 则占空间 8k(65536/8)，这是令人难以接受的内存占用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 省略部分字段</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 本节点负责的哈希槽信息,16384/8 个 char 数组，一共为16384bit</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> myslots[CLUSTER_SLOTS/<span class="number">8</span>];</span><br><span class="line">    <span class="comment">// 集群的状态</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> state;</span><br><span class="line">    <span class="comment">// 消息的内容</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">clusterMsgData</span> <span class="title">data</span>;</span></span><br><span class="line">&#125; clusterMsg;</span><br></pre></td></tr></table></figure>

<p>可以看到哈希槽是使用槽位数/8 使用一个char数组来表示，这里实际就是通过 bitmap 这种数据结构维护的哈希槽信息，每一个 bit 代表一个哈希槽，每个 bit 只能 存储 0/1 。如果该位为 1，表示这个哈希槽是属于这个节点。</p>
<p>虽说 Redis Cluster 可以扩展到 1000 个节点，但强烈不推荐这样做，应尽量避免集群中的节点过多。这 是因为 Redis Cluster 中的各个节点基于 Gossip 协议 来进行通信共享信息，当节点过多时，<strong>Gossip</strong> 协议的效率会显著下降，通信成本剧增。请注意，在小簇中，位图将很难压缩，因为当 N 很小时，位图将具有插槽/N 位设置，这是位设置的很大百分比。</p>
<h3 id="为什么不采用一致性哈希？"><a href="#为什么不采用一致性哈希？" class="headerlink" title="为什么不采用一致性哈希？"></a>为什么不采用一致性哈希？</h3><p>一致性哈希：为了防止节点和数据绑定，将整个哈希结果构造为一个2^32的域，服务器名称也在域中，根据key的哈希结果和服务器的位置关系判断应该访问哪个服务器。（狭义上）</p>
<p>为啥redis cluster 不设置 2的32次方个槽位呢？主要是考虑节点数在1000的规模左右，而使用 <strong>Gossip</strong> 去中心一致性协议，数据包不能太大，16K 个二进制位 2K字节已经很大了。</p>
<p>Redis 选择哈希插槽，是因为其设计目标（强一致性、高可用性）与哈希插槽的特性高度契合，而一致性哈希更适合对扩展性要求更高、允许最终一致性的场景（如缓存系统）。</p>
<ul>
<li><p>一致性hash 哈希环顺时针映射 优先考虑的是： 如何实现 最少的节点数据发生数据迁移。</p>
<p>一致性hash 哈希环上面，只有被干掉的节点顺时针方向最近的那一个节点涉及到数据迁移；其他间隔较远的节点，不涉及到数据迁移。迁移范围仅限环上相邻节点间的键。</p>
</li>
<li><p>redis cluster 哈希槽静态映射 优先考虑的是： 如何 实现数据的均匀。</p>
<p>槽位是逻辑单位，节点是物理单位，二者通过配置文件或集群协议关联。<strong>映射关系由集群元数据控制</strong>（如 Redis Cluster 的 Gossip 协议同步），客户端需缓存槽位分布表。</p>
<p>redis cluster 各个节点都会参与数据迁移，优先保证各个redis节点承担同样的访问压力。</p>
</li>
<li><p>同时，redis cluster 哈希槽静态映射还有一个优点，<mark>手动迁移<mark>。</p>
<p>redis cluster 可以自动分配，也可以根据节点的性能（比如Memory大小） 手动的调整slot的分配。</p>
</li>
</ul>
<h3 id="如何判断某个key应该在哪个实例？"><a href="#如何判断某个key应该在哪个实例？" class="headerlink" title="如何判断某个key应该在哪个实例？"></a>如何判断某个key应该在哪个实例？</h3><ul>
<li>将16384个插槽分配到不同的实例</li>
<li>根据key的有效部分计算哈希值，对16384取余</li>
<li>余数作为插槽，寻找插槽所在实例即可</li>
</ul>
<h3 id="如何将同一类数据固定的保存在同一个实例？"><a href="#如何将同一类数据固定的保存在同一个实例？" class="headerlink" title="如何将同一类数据固定的保存在同一个实例？"></a>如何将同一类数据固定的保存在同一个实例？</h3><p>不同节点之间的切换比较耗时，所以同类的key尽量存在同一个节点上面</p>
<ul>
<li>这一类数据使用相同的有效部分，例如key都以{typeId}为前缀</li>
</ul>
<p><mark>要清楚的一点：<mark>数据不存在hash插槽上，因此也不存在哈希冲突这一说，key映射到某个哈希插槽仅仅说明它属于XX节点，将来相同key也会去找相同的节点，仅此而已。</p>
<h2 id="集群伸缩：插槽迁移"><a href="#集群伸缩：插槽迁移" class="headerlink" title="集群伸缩：插槽迁移"></a>集群伸缩：插槽迁移</h2><p>redis-cli –cluster提供了很多操作集群的命令，可以通过下面方式查看：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725160138290.png" alt="image-20210725160138290"></p>
<p>比如，添加节点的命令：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725160448139.png" alt="image-20210725160448139"></p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>需求：向集群中添加一个新的master节点，并向其中存储 num = 10</p>
<ul>
<li>启动一个新的redis实例，端口为7004</li>
<li>添加7004到之前的集群，并作为一个master节点</li>
<li>给7004节点分配插槽，使得num这个key可以存储到7004实例</li>
</ul>
<p>这里需要两个新的功能：</p>
<ul>
<li>添加一个节点到集群中</li>
<li>将部分插槽分配到新插槽</li>
</ul>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><h4 id="创建新的redis实例"><a href="#创建新的redis实例" class="headerlink" title="创建新的redis实例"></a>创建新的redis实例</h4><p>创建一个文件夹：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> 7004</span><br></pre></td></tr></table></figure>

<p>拷贝配置文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> redis.conf /7004</span><br></pre></td></tr></table></figure>

<p>修改配置文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sed /s/6379/7004/g 7004/redis.conf</span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server 7004/redis.conf</span><br></pre></td></tr></table></figure>



<h4 id="添加新节点到redis"><a href="#添加新节点到redis" class="headerlink" title="添加新节点到redis"></a>添加新节点到redis</h4><p>添加节点的语法如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725160448139.png" alt="image-20210725160448139"></p>
<p>执行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster add-node  127.0.0.1:7004 127.0.0.1:7001</span><br></pre></td></tr></table></figure>



<p>通过命令查看集群状态：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></table></figure>



<p>如图，7004加入了集群，并且默认是一个master节点：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161007099.png" alt="image-20210725161007099"></p>
<p>但是，可以看到7004节点的插槽数量为0，因此没有任何数据可以存储到7004上</p>
<h4 id="转移插槽"><a href="#转移插槽" class="headerlink" title="转移插槽"></a>转移插槽</h4><p>每个数据都有对应的插槽编号，可以根据编号查出数据</p>
<p>我们要将num存储到7004节点，因此需要先看看num的插槽是多少：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161241793.png" alt="image-20210725161241793"></p>
<p>如上图所示，num的插槽为2765.</p>
<p>我们可以将0~3000的插槽从7001转移到7004，命令格式如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161401925.png" alt="image-20210725161401925"></p>
<p>具体命令如下：</p>
<p>建立连接：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161506241.png" alt="image-20210725161506241"></p>
<p>得到下面的反馈：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161540841.png" alt="image-20210725161540841"></p>
<p>询问要移动多少个插槽，我们计划是3000个：新的问题来了：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161637152.png" alt="image-20210725161637152"></p>
<p>那个node来接收这些插槽？？显然是7004，那么7004节点的id是多少呢？</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161731738.png" alt="image-20210725161731738"></p>
<p>复制这个id，然后拷贝到刚才的控制台后：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161817642.png" alt="image-20210725161817642"></p>
<p>这里询问，你的插槽是从哪里移动过来的？</p>
<ul>
<li>all：代表全部，也就是三个节点各转移一部分</li>
<li>具体的id：目标节点的id</li>
<li>done：没有了</li>
</ul>
<p>这里我们要从7001获取，因此填写7001的id：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725162030478.png" alt="image-20210725162030478"></p>
<p>填完后，点击done，这样插槽转移就准备好了：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725162101228.png" alt="image-20210725162101228"></p>
<p>确认要转移吗？输入yes：然后，通过命令查看结果：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725162145497.png" alt="image-20210725162145497"> </p>
<p>可以看到： </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725162224058.png" alt="image-20210725162224058"></p>
<p>目的达成。</p>
<h3 id="迁移流程：集群节点的数据结构"><a href="#迁移流程：集群节点的数据结构" class="headerlink" title="迁移流程：集群节点的数据结构"></a>迁移流程：集群节点的数据结构</h3><p>每个节点都有一个对应的clusterNode clusterState结构</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E6%97%A0%E6%A0%87%E9%A2%98.jpg"></p>
<p>存储的时候，会根据key计算哈希，这是key到哈希槽位的映射，</p>
<p>迁移的时候，如果遍历整个数据库，分别计算哈希，效率低下，因此节点自身用一个跳表slots_to_key维护槽位到key的映射，score是槽位号，member是key值    </p>
<p><a href="https://www.cnblogs.com/sulishihupan/p/14538864.html">Redis–集群Cluster（槽指派、重新分片） - 苏黎世湖畔 - 博客园 (cnblogs.com)</a> </p>
<p>假设将 <code>0-3000</code> 插槽从节点 A 迁移至节点 B：</p>
<ol>
<li>节点 A 标记为 <code>MIGRATING</code>，表示它即将释放这些插槽。节点 B 标记为 <code>IMPORTING</code>，表示它即将接管这些插槽。</li>
<li>通知所有节点，让客户端感知到这些插槽的迁移状态，确保客户端请求能够动态路由到正确的节点。</li>
</ol>
<h2 id="故障转移：全员哨兵"><a href="#故障转移：全员哨兵" class="headerlink" title="故障转移：全员哨兵"></a>故障转移：全员哨兵</h2><p>clusterState结构中，有一个nodes，指向其他节点，因此能够实现全员哨兵</p>
<p>有了 Redis Cluster 之后，不需要专门部署 Sentinel 集群服务了。Redis Cluster 相当于是内置了 Sentinel 机制，Redis Cluster 内部的各个 Redis 节点通过 <a href="https://zhuanlan.zhihu.com/p/463455831">Gossip 协议</a>互相探测健康状态，在故障时可 以自动切换。</p>
<p>集群初始状态是这样的：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210727161152065.png" alt="image-20210727161152065"></p>
<p>其中7001、7002、7003都是master，我们计划让7002宕机。</p>
<h3 id="自动故障转移"><a href="#自动故障转移" class="headerlink" title="自动故障转移"></a>自动故障转移</h3><p>当集群中有一个master宕机会发生什么呢？</p>
<p>直接停止一个redis实例，例如7002：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli -p 7002 shutdown</span><br></pre></td></tr></table></figure>

<p>1）首先是该实例与其它实例失去连接</p>
<p>2）然后是疑似宕机：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725162319490.png" alt="image-20210725162319490"></p>
<p>3）最后是确定下线，自动提升一个slave为新的master：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725162408979.png" alt="image-20210725162408979"></p>
<p>4）当7002再次启动，就会变为一个slave节点了：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210727160803386.png" alt="image-20210727160803386"></p>
<h3 id="手动故障转移"><a href="#手动故障转移" class="headerlink" title="手动故障转移"></a>手动故障转移</h3><p>利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725162441407.png" alt="image-20210725162441407"></p>
<p>这种failover命令可以指定三种模式：</p>
<ul>
<li>缺省：默认的流程，如图1~6歩</li>
<li>force：省略了对offset的一致性校验</li>
<li>takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见</li>
</ul>
<p><strong>案例需求</strong>：在7002这个slave节点执行手动故障转移，重新夺回master地位</p>
<p>步骤如下：</p>
<p>1）利用redis-cli连接7002这个节点</p>
<p>2）执行cluster failover命令</p>
<p>如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210727160037766.png" alt="image-20210727160037766"></p>
<p>效果：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210727161152065.png" alt="image-20210727161152065"></p>
<h2 id="客户端访问分片集群"><a href="#客户端访问分片集群" class="headerlink" title="客户端访问分片集群"></a>客户端访问分片集群</h2><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：</p>
<p>1）引入redis的starter依赖</p>
<p>2）配置分片集群地址</p>
<p>3）配置读写分离</p>
<p>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">cluster:</span></span><br><span class="line">      <span class="attr">nodes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:7001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:7002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:7003</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8003</span></span><br></pre></td></tr></table></figure>

<h3 id="客户端访问时集群正在迁移数据"><a href="#客户端访问时集群正在迁移数据" class="headerlink" title="客户端访问时集群正在迁移数据"></a>客户端访问时集群正在迁移数据</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119212106075.png" alt="image-20241119212106075"></p>
<h4 id="ASK"><a href="#ASK" class="headerlink" title="ASK"></a>ASK</h4><ol>
<li>客户端发送请求命令，如果请求的 key 对应的哈希槽还在当前节点，就直接响应客户端的请求。如果客户端请求的 key 对应的哈希槽当前正在迁移至新的节点，就会返回<code>-ASK</code> 重定向错误，告知客户端要将请求发送到哈希槽被迁移到的目标节点。</li>
<li>客户端收到<code>-ASK</code>重定向错误后，将会临时（一次性）重定向，自动向目标节点发送一条 ASKING 命令。也就是说，接收到 ASKING 命令的节点会强制执行一次请求，下次再来需要重新提前发送 ASKING 命令。</li>
<li>ASK 重定向并不会同步更新客户端缓存的哈希槽分配信息，也就是说，客户端对正在迁移的相同哈希槽的请求依然会发送到原节点而不是目标节点。</li>
</ol>
<h4 id="MOVED"><a href="#MOVED" class="headerlink" title="MOVED"></a>MOVED</h4><ol>
<li>当客户端请求的 key 对应的哈希槽迁移完成，就会返回 -MOVED 重定向错误，告知客户端当前哈希槽是由哪个节点负责，客户端向目标节点发送请求并更新缓存的哈希槽分配信息。</li>
</ol>
<h4 id="客户端缓存插槽与节点映射表"><a href="#客户端缓存插槽与节点映射表" class="headerlink" title="客户端缓存插槽与节点映射表"></a>客户端缓存插槽与节点映射表</h4><p>当 Redis 客户端连接到集群时，会通过 <code>CLUSTER SLOTS</code> 命令从 Redis 获取插槽与节点的对应关系。客户端将这张表缓存起来，用于后续操作中快速定位目标节点，而无需每次操作都向服务器查询。减少了每次请求都需要额外的网络交互来查询插槽分布，增加延迟。</p>
<p>缓存后，客户端可以直接根据键快速定位目标节点并发送请求。</p>
<h1 id="——多级缓存——"><a href="#——多级缓存——" class="headerlink" title="——多级缓存——"></a>——多级缓存——</h1><h1 id="一、什么是多级缓存"><a href="#一、什么是多级缓存" class="headerlink" title="一、什么是多级缓存"></a>一、什么是多级缓存</h1><p>传统的缓存策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821075259137.png" alt="image-20210821075259137"></p>
<p>存在下面的问题：</p>
<p>•请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈</p>
<p>•Redis缓存失效时，会对数据库产生冲击</p>
<p>多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能：</p>
<ul>
<li>浏览器访问静态资源时，优先读取浏览器本地缓存</li>
<li>访问非静态资源（ajax查询数据）时，访问服务端</li>
<li>请求到达Nginx后，优先读取Nginx本地缓存</li>
<li>如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）</li>
<li>如果Redis查询未命中，则查询Tomcat</li>
<li>请求进入Tomcat后，优先查询JVM进程缓存</li>
<li>如果JVM进程缓存未命中，则查询数据库</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821075558137.png" alt="image-20210821075558137"></p>
<p>在多级缓存架构中，Nginx内部需要编写本地缓存查询、Redis查询、Tomcat查询的业务逻辑，因此这样的nginx服务不再是一个<strong>反向代理服务器</strong>，而是一个编写<strong>业务的Web服务器了</strong>。</p>
<p>因此这样的业务Nginx服务也需要搭建集群来提高并发，再有专门的nginx服务来做反向代理，如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821080511581.png" alt="image-20210821080511581"></p>
<p>另外，我们的Tomcat服务将来也会部署为集群模式：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821080954947.png" alt="image-20210821080954947"></p>
<p>可见，多级缓存的关键有两个：</p>
<ul>
<li><p>一个是在nginx中编写业务，实现nginx本地缓存、Redis、Tomcat的查询</p>
</li>
<li><p>另一个就是在Tomcat中实现JVM进程缓存</p>
</li>
</ul>
<p>其中Nginx编程则会用到OpenResty框架结合Lua这样的语言。</p>
<h1 id="二、JVM进程缓存"><a href="#二、JVM进程缓存" class="headerlink" title="二、JVM进程缓存"></a>二、JVM进程缓存</h1><p>为了演示多级缓存的案例，我们先准备一个商品查询的业务。</p>
<h2 id="导入案例"><a href="#导入案例" class="headerlink" title="导入案例"></a>导入案例</h2><p>参考课前资料的：《案例导入说明.md》</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821081418456.png" alt="image-20210821081418456"> </p>
<h2 id="初识Caffeine"><a href="#初识Caffeine" class="headerlink" title="初识Caffeine"></a>初识Caffeine</h2><p>缓存在日常开发中启动至关重要的作用，由于是存储在内存中，数据的读取速度是非常快的，能大量减少对数据库的访问，减少数据库的压力。我们把缓存分为两类：</p>
<ul>
<li>分布式缓存，例如Redis：<ul>
<li>优点：存储容量更大、可靠性更好、可以在集群间共享</li>
<li>缺点：访问缓存有网络开销</li>
<li>场景：缓存数据量较大、可靠性要求较高、需要在集群间共享</li>
</ul>
</li>
<li>进程本地缓存，例如HashMap、GuavaCache：<ul>
<li>优点：读取本地内存，没有网络开销，速度更快</li>
<li>缺点：存储容量有限、可靠性较低、无法共享</li>
<li>场景：性能要求较高，缓存数据量较小</li>
</ul>
</li>
</ul>
<p>我们今天会利用Caffeine框架来实现JVM进程缓存。</p>
<p><strong>Caffeine</strong>是一个基于Java8开发的，提供了近乎最佳命中率的高性能的本地缓存库。目前Spring内部的缓存使用的就是Caffeine。GitHub地址：<a href="https://github.com/ben-manes/caffeine">https://github.com/ben-manes/caffeine</a></p>
<p>Caffeine的性能非常好，下图是官方给出的性能对比：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821081826399.png" alt="image-20210821081826399"></p>
<p>可以看到Caffeine的性能遥遥领先！</p>
<p>缓存使用的基本API：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBasicOps</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 构建cache对象</span></span><br><span class="line">    Cache&lt;String, String&gt; cache = Caffeine.newBuilder().build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存数据</span></span><br><span class="line">    cache.put(<span class="string">&quot;gf&quot;</span>, <span class="string">&quot;迪丽热巴&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">gf</span> <span class="operator">=</span> cache.getIfPresent(<span class="string">&quot;gf&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;gf = &quot;</span> + gf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取数据，包含两个参数：</span></span><br><span class="line">    <span class="comment">// 参数一：缓存的key</span></span><br><span class="line">    <span class="comment">// 参数二：Lambda表达式，表达式参数就是缓存的key，方法体是查询数据库的逻辑</span></span><br><span class="line">    <span class="comment">// 优先根据key查询JVM缓存，如果未命中，则执行参数二的Lambda表达式</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">defaultGF</span> <span class="operator">=</span> cache.get(<span class="string">&quot;defaultGF&quot;</span>, key -&gt; &#123;</span><br><span class="line">        <span class="comment">// 根据key去数据库查询数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;柳岩&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;defaultGF = &quot;</span> + defaultGF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>Caffeine既然是缓存的一种，肯定需要有缓存的清除策略，不然的话内存总会有耗尽的时候。</p>
<p>Caffeine提供了三种缓存驱逐策略：</p>
<ul>
<li><p><strong>基于容量</strong>：设置缓存的数量上限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建缓存对象</span></span><br><span class="line">Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">1</span>) <span class="comment">// 设置缓存大小上限为 1</span></span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>基于时间</strong>：设置缓存的有效时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建缓存对象</span></span><br><span class="line">Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    <span class="comment">// 设置缓存有效期为 10 秒，从最后一次写入开始计时 </span></span><br><span class="line">    .expireAfterWrite(Duration.ofSeconds(<span class="number">10</span>)) </span><br><span class="line">    .build();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong>基于引用</strong>：设置缓存为软引用或弱引用，利用GC来回收缓存数据。性能较差，不建议使用。</p>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>：在默认情况下，当一个缓存元素过期的时候，Caffeine不会自动立即将其清理和驱逐。而是在一次读或写操作后，或者在空闲时间完成对失效数据的驱逐。</p>
</blockquote>
<h2 id="实现JVM进程缓存"><a href="#实现JVM进程缓存" class="headerlink" title="实现JVM进程缓存"></a>实现JVM进程缓存</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>利用Caffeine实现下列需求：</p>
<ul>
<li>给根据id查询商品的业务添加缓存，缓存未命中时查询数据库</li>
<li>给根据id查询商品库存的业务添加缓存，缓存未命中时查询数据库</li>
<li>缓存初始大小为100</li>
<li>缓存上限为10000</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>首先，我们需要定义两个Caffeine的缓存对象，分别保存商品、库存的缓存数据。</p>
<p>在item-service的<code>com.heima.item.config</code>包下定义<code>CaffeineConfig</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Caffeine;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.ItemStock;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaffeineConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cache&lt;Long, Item&gt; <span class="title function_">itemCache</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Caffeine.newBuilder()</span><br><span class="line">                .initialCapacity(<span class="number">100</span>)</span><br><span class="line">                .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cache&lt;Long, ItemStock&gt; <span class="title function_">stockCache</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Caffeine.newBuilder()</span><br><span class="line">                .initialCapacity(<span class="number">100</span>)</span><br><span class="line">                .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后，修改item-service中的<code>com.heima.item.web</code>包下的ItemController类，添加缓存逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;item&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemService itemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemStockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;Long, Item&gt; itemCache;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;Long, ItemStock&gt; stockCache;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...其它略</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemCache.get(id, key -&gt; itemService.query()</span><br><span class="line">                .ne(<span class="string">&quot;status&quot;</span>, <span class="number">3</span>).eq(<span class="string">&quot;id&quot;</span>, key)</span><br><span class="line">                .one()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/stock/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ItemStock <span class="title function_">findStockById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stockCache.get(id, key -&gt; stockService.getById(key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="三、Lua语法入门"><a href="#三、Lua语法入门" class="headerlink" title="三、Lua语法入门"></a>三、Lua语法入门</h1><p>Nginx编程需要用到Lua语言，因此我们必须先入门Lua的基本语法。</p>
<h2 id="初识Lua"><a href="#初识Lua" class="headerlink" title="初识Lua"></a>初识Lua</h2><p>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。官网：<a href="https://www.lua.org/">https://www.lua.org/</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821091437975.png" alt="image-20210821091437975"></p>
<p>Lua经常嵌入到C语言开发的程序中，例如游戏开发、游戏插件等。</p>
<p>Nginx本身也是C语言开发，因此也允许基于Lua做拓展。</p>
<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>CentOS7默认已经安装了Lua语言环境，所以可以直接运行Lua代码。</p>
<p>1）在Linux虚拟机的任意目录下，新建一个hello.lua文件</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821091621308.png" alt="image-20210821091621308"></p>
<p>2）添加下面的内容</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)  </span><br></pre></td></tr></table></figure>



<p>3）运行</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821091638140.png" alt="image-20210821091638140"></p>
<h2 id="变量和循环"><a href="#变量和循环" class="headerlink" title="变量和循环"></a>变量和循环</h2><p>学习任何语言必然离不开变量，而变量的声明必须先知道数据的类型。</p>
<h3 id="Lua的数据类型"><a href="#Lua的数据类型" class="headerlink" title="Lua的数据类型"></a>Lua的数据类型</h3><p>Lua中支持的常见数据类型包括：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821091835406.png" alt="image-20210821091835406"></p>
<p>另外，Lua提供了type()函数来判断一个变量的数据类型：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821091904332.png" alt="image-20210821091904332"></p>
<h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><p>Lua声明变量的时候无需指定数据类型，而是用local来声明变量为局部变量：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 声明字符串，可以用单引号或双引号，</span></span><br><span class="line"><span class="keyword">local</span> str = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">-- 字符串拼接可以使用 ..</span></span><br><span class="line"><span class="keyword">local</span> str2 = <span class="string">&#x27;hello&#x27;</span> .. <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="comment">-- 声明数字</span></span><br><span class="line"><span class="keyword">local</span> num = <span class="number">21</span></span><br><span class="line"><span class="comment">-- 声明布尔类型</span></span><br><span class="line"><span class="keyword">local</span> flag = <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<p>Lua中的table类型既可以作为数组，又可以作为Java中的map来使用。数组就是特殊的table，key是数组角标而已：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 声明数组 ，key为角标的 table</span></span><br><span class="line"><span class="keyword">local</span> arr = &#123;<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;lua&#x27;</span>&#125;</span><br><span class="line"><span class="comment">-- 声明table，类似java的map</span></span><br><span class="line"><span class="keyword">local</span> map =  &#123;name=<span class="string">&#x27;Jack&#x27;</span>, age=<span class="number">21</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Lua中的数组角标是从1开始，访问的时候与Java中类似：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 访问数组，lua数组的角标从1开始</span></span><br><span class="line"><span class="built_in">print</span>(arr[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>Lua中的table可以用key来访问：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 访问table</span></span><br><span class="line"><span class="built_in">print</span>(map[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(map.name)</span><br></pre></td></tr></table></figure>



<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>对于table，我们可以利用for循环来遍历。不过数组和普通table遍历略有差异。</p>
<p>遍历数组：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 声明数组 key为索引的 table</span></span><br><span class="line"><span class="keyword">local</span> arr = &#123;<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;lua&#x27;</span>&#125;</span><br><span class="line"><span class="comment">-- 遍历数组</span></span><br><span class="line"><span class="keyword">for</span> index,value <span class="keyword">in</span> <span class="built_in">ipairs</span>(arr) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(index, value) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>遍历普通table</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 声明map，也就是table</span></span><br><span class="line"><span class="keyword">local</span> map = &#123;name=<span class="string">&#x27;Jack&#x27;</span>, age=<span class="number">21</span>&#125;</span><br><span class="line"><span class="comment">-- 遍历table</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> <span class="built_in">pairs</span>(map) <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(key, value) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>







<h2 id="条件控制、函数"><a href="#条件控制、函数" class="headerlink" title="条件控制、函数"></a>条件控制、函数</h2><p>Lua中的条件控制和函数声明与Java类似。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>定义函数的语法：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名<span class="params">( argument1, argument2..., argumentn)</span></span></span><br><span class="line">    <span class="comment">-- 函数体</span></span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>例如，定义一个函数，用来打印数组：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArr</span><span class="params">(arr)</span></span></span><br><span class="line">    <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">ipairs</span>(arr) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h3><p>类似Java的条件控制，例如if、else语法：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 布尔表达式为 true 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="comment">--[ 布尔表达式为 false 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>与java不同，布尔表达式中的逻辑运算是基于英文单词：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821092657918.png" alt="image-20210821092657918"></p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>需求：自定义一个函数，可以打印table，当参数为nil时，打印错误信息</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArr</span><span class="params">(arr)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> arr <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;数组不能为空！&#x27;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">ipairs</span>(arr) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>





<h1 id="四、实现多级缓存"><a href="#四、实现多级缓存" class="headerlink" title="四、实现多级缓存"></a>四、实现多级缓存</h1><p>多级缓存的实现离不开Nginx编程，而Nginx编程又离不开OpenResty。</p>
<h2 id="安装OpenResty"><a href="#安装OpenResty" class="headerlink" title="安装OpenResty"></a>安装OpenResty</h2><p>OpenResty® 是一个基于 Nginx的高性能 Web 平台，用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。具备下列特点：</p>
<ul>
<li>具备Nginx的完整功能</li>
<li>基于Lua语言进行扩展，集成了大量精良的 Lua 库、第三方模块</li>
<li>允许使用Lua<strong>自定义业务逻辑</strong>、<strong>自定义库</strong></li>
</ul>
<p>官方网站： <a href="https://openresty.org/cn/">https://openresty.org/cn/</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821092902946.png" alt="image-20210821092902946"></p>
<p>安装Lua可以参考课前资料提供的《安装OpenResty.md》：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821092941139.png" alt="image-20210821092941139"> </p>
<h2 id="OpenResty快速入门"><a href="#OpenResty快速入门" class="headerlink" title="OpenResty快速入门"></a>OpenResty快速入门</h2><p>我们希望达到的多级缓存架构如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/yeVDlwtfMx.png" alt="yeVDlwtfMx"></p>
<p>其中：</p>
<ul>
<li><p>windows上的nginx用来做反向代理服务，将前端的查询商品的ajax请求代理到OpenResty集群</p>
</li>
<li><p>OpenResty集群用来编写多级缓存业务</p>
</li>
</ul>
<h3 id="反向代理流程"><a href="#反向代理流程" class="headerlink" title="反向代理流程"></a>反向代理流程</h3><p>现在，商品详情页使用的是假的商品数据。不过在浏览器中，可以看到页面有发起ajax请求查询真实商品数据。</p>
<p>这个请求如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821093144700.png" alt="image-20210821093144700"></p>
<p>请求地址是localhost，端口是80，就被windows上安装的Nginx服务给接收到了。然后代理给了OpenResty集群：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821094447709.png" alt="image-20210821094447709"></p>
<p>我们需要在OpenResty中编写业务，查询商品数据并返回到浏览器。</p>
<p>但是这次，我们先在OpenResty接收请求，返回假的商品数据。</p>
<h3 id="OpenResty监听请求"><a href="#OpenResty监听请求" class="headerlink" title="OpenResty监听请求"></a>OpenResty监听请求</h3><p>OpenResty的很多功能都依赖于其目录下的Lua库，需要在nginx.conf中指定依赖库的目录，并导入依赖：</p>
<p>1）添加对OpenResty的Lua模块的加载</p>
<p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，在其中的http下面，添加下面代码：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#lua 模块</span></span><br><span class="line"><span class="attribute">lua_package_path</span> <span class="string">&quot;/usr/local/openresty/lualib/?.lua;;&quot;</span>;</span><br><span class="line"><span class="comment">#c模块     </span></span><br><span class="line"><span class="attribute">lua_package_cpath</span> <span class="string">&quot;/usr/local/openresty/lualib/?.so;;&quot;</span>;  </span><br></pre></td></tr></table></figure>



<p>2）监听/api/item路径</p>
<p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，在nginx.conf的server下面，添加对/api/item这个路径的监听：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span>  /api/item &#123;</span><br><span class="line">    <span class="comment"># 默认的响应类型</span></span><br><span class="line">    <span class="attribute">default_type</span> application/json;</span><br><span class="line">    <span class="comment"># 响应结果由lua/item.lua文件来决定</span></span><br><span class="line">    <span class="attribute">content_by_lua_file</span> lua/item.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个监听，就类似于SpringMVC中的<code>@GetMapping(&quot;/api/item&quot;)</code>做路径映射。</p>
<p>而<code>content_by_lua_file lua/item.lua</code>则相当于调用item.lua这个文件，执行其中的业务，把结果返回给用户。相当于java中调用service。</p>
<h3 id="编写item-lua"><a href="#编写item-lua" class="headerlink" title="编写item.lua"></a>编写item.lua</h3><p>1）在<code>/usr/loca/openresty/nginx</code>目录创建文件夹：lua</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821100755080.png" alt="image-20210821100755080"></p>
<p>2）在<code>/usr/loca/openresty/nginx/lua</code>文件夹下，新建文件：item.lua</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821100801756.png" alt="image-20210821100801756"></p>
<p>3）编写item.lua，返回假数据</p>
<p>item.lua中，利用ngx.say()函数返回数据到Response中</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">ngx.say(<span class="string">&#x27;&#123;&quot;id&quot;:10001,&quot;name&quot;:&quot;SALSA AIR&quot;,&quot;title&quot;:&quot;RIMOWA 21寸托运箱拉杆箱 SALSA AIR系列果绿色 820.70.36.4&quot;,&quot;price&quot;:17900,&quot;image&quot;:&quot;https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp&quot;,&quot;category&quot;:&quot;拉杆箱&quot;,&quot;brand&quot;:&quot;RIMOWA&quot;,&quot;spec&quot;:&quot;&quot;,&quot;status&quot;:1,&quot;createTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;updateTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;stock&quot;:2999,&quot;sold&quot;:31290&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>4）重新加载配置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>



<p>刷新商品页面：<a href="http://localhost/item.html?id=1001%EF%BC%8C%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E6%95%88%E6%9E%9C%EF%BC%9A">http://localhost/item.html?id=1001，即可看到效果：</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821101217089.png" alt="image-20210821101217089"></p>
<h2 id="请求参数处理"><a href="#请求参数处理" class="headerlink" title="请求参数处理"></a>请求参数处理</h2><p>上一节中，我们在OpenResty接收前端请求，但是返回的是假数据。</p>
<p>要返回真实数据，必须根据前端传递来的商品id，查询商品信息才可以。</p>
<p>那么如何获取前端传递的商品参数呢？</p>
<h3 id="获取参数的API"><a href="#获取参数的API" class="headerlink" title="获取参数的API"></a>获取参数的API</h3><p>OpenResty中提供了一些API用来获取不同类型的前端请求参数：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821101433528.png" alt="image-20210821101433528"></p>
<h3 id="获取参数并返回"><a href="#获取参数并返回" class="headerlink" title="获取参数并返回"></a>获取参数并返回</h3><p>在前端发起的ajax请求如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821101721649.png" alt="image-20210821101721649"></p>
<p>可以看到商品id是以路径占位符方式传递的，因此可以利用正则表达式匹配的方式来获取ID</p>
<p>1）获取商品id</p>
<p>修改<code>/usr/loca/openresty/nginx/nginx.conf</code>文件中监听/api/item的代码，利用正则表达式获取ID：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ /api/item/(\d+)</span> &#123;</span><br><span class="line">    <span class="comment"># 默认的响应类型</span></span><br><span class="line">    <span class="attribute">default_type</span> application/json;</span><br><span class="line">    <span class="comment"># 响应结果由lua/item.lua文件来决定</span></span><br><span class="line">    <span class="attribute">content_by_lua_file</span> lua/item.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2）拼接ID并返回</p>
<p>修改<code>/usr/loca/openresty/nginx/lua/item.lua</code>文件，获取id并拼接到结果中返回：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取商品id</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 拼接并返回</span></span><br><span class="line">ngx.say(<span class="string">&#x27;&#123;&quot;id&quot;:&#x27;</span> .. id .. <span class="string">&#x27;,&quot;name&quot;:&quot;SALSA AIR&quot;,&quot;title&quot;:&quot;RIMOWA 21寸托运箱拉杆箱 SALSA AIR系列果绿色 820.70.36.4&quot;,&quot;price&quot;:17900,&quot;image&quot;:&quot;https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp&quot;,&quot;category&quot;:&quot;拉杆箱&quot;,&quot;brand&quot;:&quot;RIMOWA&quot;,&quot;spec&quot;:&quot;&quot;,&quot;status&quot;:1,&quot;createTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;updateTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;stock&quot;:2999,&quot;sold&quot;:31290&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>3）重新加载并测试</p>
<p>运行命令以重新加载OpenResty配置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>



<p>刷新页面可以看到结果中已经带上了ID：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821102235467.png" alt="image-20210821102235467"> </p>
<h2 id="查询Tomcat"><a href="#查询Tomcat" class="headerlink" title="查询Tomcat"></a>查询Tomcat</h2><p>拿到商品ID后，本应去缓存中查询商品信息，不过目前我们还未建立nginx、redis缓存。因此，这里我们先根据商品id去tomcat查询商品信息。我们实现如图部分：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821102610167.png" alt="image-20210821102610167"></p>
<p>需要注意的是，我们的OpenResty是在虚拟机，Tomcat是在Windows电脑上。两者IP一定不要搞错了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821102959829.png" alt="image-20210821102959829"></p>
<h3 id="发送http请求的API"><a href="#发送http请求的API" class="headerlink" title="发送http请求的API"></a>发送http请求的API</h3><p>nginx提供了内部API用以发送http请求：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> resp = ngx.location.capture(<span class="string">&quot;/path&quot;</span>,&#123;</span><br><span class="line">    method = ngx.HTTP_GET,   <span class="comment">-- 请求方式</span></span><br><span class="line">    args = &#123;a=<span class="number">1</span>,b=<span class="number">2</span>&#125;,  <span class="comment">-- get方式传参数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>返回的响应内容包括：</p>
<ul>
<li>resp.status：响应状态码</li>
<li>resp.header：响应头，是一个table</li>
<li>resp.body：响应体，就是响应数据</li>
</ul>
<p>注意：这里的path是路径，并不包含IP和端口。这个请求会被nginx内部的server监听并处理。</p>
<p>但是我们希望这个请求发送到Tomcat服务器，所以还需要编写一个server来对这个路径做反向代理：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /path &#123;</span><br><span class="line">    <span class="comment"># 这里是windows电脑的ip和Java服务端口，需要确保windows防火墙处于关闭状态</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.150.1:8081; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>原理如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821104149061.png" alt="image-20210821104149061"></p>
<h3 id="封装http工具"><a href="#封装http工具" class="headerlink" title="封装http工具"></a>封装http工具</h3><p>下面，我们封装一个发送Http请求的工具，基于ngx.location.capture来实现查询tomcat。</p>
<p>1）添加反向代理，到windows的Java服务</p>
<p>因为item-service中的接口都是/item开头，所以我们监听/item路径，代理到windows上的tomcat服务。</p>
<p>修改 <code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，添加一个location：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /item &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.150.1:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以后，只要我们调用<code>ngx.location.capture(&quot;/item&quot;)</code>，就一定能发送请求到windows的tomcat服务。</p>
<p>2）封装工具类</p>
<p>之前我们说过，OpenResty启动时会加载以下两个目录中的工具文件：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821104857413.png" alt="image-20210821104857413"></p>
<p>所以，自定义的http工具也需要放到这个目录下。</p>
<p>在<code>/usr/local/openresty/lualib</code>目录下，新建一个common.lua文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /usr/local/openresty/lualib/common.lua</span><br></pre></td></tr></table></figure>

<p>内容如下:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 封装函数，发送http请求，并解析响应</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_http</span><span class="params">(path, params)</span></span></span><br><span class="line">    <span class="keyword">local</span> resp = ngx.location.capture(<span class="built_in">path</span>,&#123;</span><br><span class="line">        method = ngx.HTTP_GET,</span><br><span class="line">        args = params,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 记录错误信息，返回404</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;http请求查询失败, path: &quot;</span>, <span class="built_in">path</span> , <span class="string">&quot;, args: &quot;</span>, args)</span><br><span class="line">        ngx.<span class="built_in">exit</span>(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> resp.body</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 将方法导出</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;  </span><br><span class="line">    read_http = read_http</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure>



<p>这个工具将read_http函数封装到_M这个table类型的变量中，并且返回，这类似于导出。</p>
<p>使用的时候，可以利用<code>require(&#39;common&#39;)</code>来导入该函数库，这里的common是函数库的文件名。</p>
<p>3）实现商品查询</p>
<p>最后，我们修改<code>/usr/local/openresty/lua/item.lua</code>文件，利用刚刚封装的函数库实现对tomcat的查询：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 引入自定义common工具模块，返回值是common中返回的 _M</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&quot;common&quot;</span>)</span><br><span class="line"><span class="comment">-- 从 common中获取read_http这个函数</span></span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 根据id查询商品</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_http(<span class="string">&quot;/item/&quot;</span>.. id, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 根据id查询商品库存</span></span><br><span class="line"><span class="keyword">local</span> itemStockJSON = read_http(<span class="string">&quot;/item/stock/&quot;</span>.. id, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>



<p>这里查询到的结果是json字符串，并且包含商品、库存两个json字符串，页面最终需要的是把两个json拼接为一个json：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821110441222.png" alt="image-20210821110441222"></p>
<p>这就需要我们先把JSON变为lua的table，完成数据整合后，再转为JSON。</p>
<h3 id="CJSON工具类"><a href="#CJSON工具类" class="headerlink" title="CJSON工具类"></a>CJSON工具类</h3><p>OpenResty提供了一个cjson的模块用来处理JSON的序列化和反序列化。</p>
<p>官方地址： <a href="https://github.com/openresty/lua-cjson/">https://github.com/openresty/lua-cjson/</a></p>
<p>1）引入cjson模块：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span> <span class="string">&quot;cjson&quot;</span></span><br></pre></td></tr></table></figure>



<p>2）序列化：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> obj = &#123;</span><br><span class="line">    name = <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    age = <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">-- 把 table 序列化为 json</span></span><br><span class="line"><span class="keyword">local</span> json = cjson.encode(obj)</span><br></pre></td></tr></table></figure>



<p>3）反序列化：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> json = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;jack&quot;, &quot;age&quot;: 21&#125;&#x27;</span></span><br><span class="line"><span class="comment">-- 反序列化 json为 table</span></span><br><span class="line"><span class="keyword">local</span> obj = cjson.decode(json);</span><br><span class="line"><span class="built_in">print</span>(obj.name)</span><br></pre></td></tr></table></figure>





<h3 id="实现Tomcat查询"><a href="#实现Tomcat查询" class="headerlink" title="实现Tomcat查询"></a>实现Tomcat查询</h3><p>下面，我们修改之前的item.lua中的业务，添加json处理功能：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导入common函数库</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&#x27;common&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="comment">-- 导入cjson库</span></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">&#x27;cjson&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 根据id查询商品</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_http(<span class="string">&quot;/item/&quot;</span>.. id, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 根据id查询商品库存</span></span><br><span class="line"><span class="keyword">local</span> itemStockJSON = read_http(<span class="string">&quot;/item/stock/&quot;</span>.. id, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSON转化为lua的table</span></span><br><span class="line"><span class="keyword">local</span> item = cjson.decode(itemJSON)</span><br><span class="line"><span class="keyword">local</span> stock = cjson.decode(stockJSON)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 组合数据</span></span><br><span class="line">item.stock = stock.stock</span><br><span class="line">item.sold = stock.sold</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把item序列化为json 返回结果</span></span><br><span class="line">ngx.say(cjson.encode(item))</span><br></pre></td></tr></table></figure>



<h3 id="基于ID负载均衡"><a href="#基于ID负载均衡" class="headerlink" title="基于ID负载均衡"></a>基于ID负载均衡</h3><p>刚才的代码中，我们的tomcat是单机部署。而实际开发中，tomcat一定是集群模式：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821111023255.png" alt="image-20210821111023255"></p>
<p>因此，OpenResty需要对tomcat集群做负载均衡。</p>
<p>而默认的负载均衡规则是轮询模式，当我们查询/item/10001时：</p>
<ul>
<li>第一次会访问8081端口的tomcat服务，在该服务内部就形成了JVM进程缓存</li>
<li>第二次会访问8082端口的tomcat服务，该服务内部没有JVM缓存（因为JVM缓存无法共享），会查询数据库</li>
<li>…</li>
</ul>
<p>你看，因为轮询的原因，第一次查询8081形成的JVM缓存并未生效，直到下一次再次访问到8081时才可以生效，缓存命中率太低了。</p>
<p>怎么办？</p>
<p>如果能让同一个商品，每次查询时都访问同一个tomcat服务，那么JVM缓存就一定能生效了。</p>
<p>也就是说，我们需要根据商品id做负载均衡，而不是轮询。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>nginx提供了基于请求路径做负载均衡的算法：</p>
<p>nginx根据请求路径做hash运算，把得到的数值对tomcat服务的数量取余，余数是几，就访问第几个服务，实现负载均衡。</p>
<p>例如：</p>
<ul>
<li>我们的请求路径是 /item/10001</li>
<li>tomcat总数为2台（8081、8082）</li>
<li>对请求路径/item/1001做hash运算求余的结果为1</li>
<li>则访问第一个tomcat服务，也就是8081</li>
</ul>
<p>只要id不变，每次hash运算结果也不会变，那就可以保证同一个商品，一直访问同一个tomcat服务，确保JVM缓存生效。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，实现基于ID做负载均衡。</p>
<p>首先，定义tomcat集群，并设置基于路径做负载均衡：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> tomcat-cluster &#123;</span><br><span class="line">    <span class="attribute">hash</span> <span class="variable">$request_uri</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.150.1:8081</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.150.1:8082</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，修改对tomcat服务的反向代理，目标指向tomcat集群：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /item &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://tomcat-cluster;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新加载OpenResty</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>





<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>启动两台tomcat服务：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821112420464.png" alt="image-20210821112420464"></p>
<p>同时启动：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821112444482.png" alt="image-20210821112444482"> </p>
<p>清空日志后，再次访问页面，可以看到不同id的商品，访问到了不同的tomcat服务：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821112559965.png" alt="image-20210821112559965"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821112637430.png" alt="image-20210821112637430"></p>
<h2 id="Redis缓存预热"><a href="#Redis缓存预热" class="headerlink" title="Redis缓存预热"></a>Redis缓存预热</h2><p>Redis缓存会面临冷启动问题：</p>
<p><strong>冷启动</strong>：服务刚刚启动时，Redis中并没有缓存，如果所有商品数据都在第一次查询时添加缓存，可能会给数据库带来较大压力。</p>
<p><strong>缓存预热</strong>：在实际开发中，我们可以利用大数据统计用户访问的热点数据，在项目启动时将这些热点数据提前查询并保存到Redis中。</p>
<p>我们数据量较少，并且没有数据统计相关功能，目前可以在启动时将所有数据都放入缓存中。</p>
<p>1）利用Docker安装Redis</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 -d redis redis-server --appendonly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>



<p>2）在item-service服务中引入Redis依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>3）配置Redis地址</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>



<p>4）编写初始化类</p>
<p>缓存预热需要在项目启动时完成，并且必须是拿到RedisTemplate之后。</p>
<p>这里我们利用InitializingBean接口来实现，因为InitializingBean可以在对象被Spring创建并且成员变量全部注入后执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.ItemStock;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemService;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemStockService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisHandler</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemService itemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemStockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">MAPPER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 初始化缓存</span></span><br><span class="line">        <span class="comment">// 1.查询商品信息</span></span><br><span class="line">        List&lt;Item&gt; itemList = itemService.list();</span><br><span class="line">        <span class="comment">// 2.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (Item item : itemList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(item);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:id:&quot;</span> + item.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询商品库存信息</span></span><br><span class="line">        List&lt;ItemStock&gt; stockList = stockService.list();</span><br><span class="line">        <span class="comment">// 4.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (ItemStock stock : stockList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(stock);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:stock:id:&quot;</span> + stock.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="查询Redis缓存"><a href="#查询Redis缓存" class="headerlink" title="查询Redis缓存"></a>查询Redis缓存</h2><p>现在，Redis缓存已经准备就绪，我们可以再OpenResty中实现查询Redis的逻辑了。如下图红框所示：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821113340111.png" alt="image-20210821113340111"></p>
<p>当请求进入OpenResty之后：</p>
<ul>
<li>优先查询Redis缓存</li>
<li>如果Redis缓存未命中，再查询Tomcat</li>
</ul>
<h3 id="封装Redis工具"><a href="#封装Redis工具" class="headerlink" title="封装Redis工具"></a>封装Redis工具</h3><p>OpenResty提供了操作Redis的模块，我们只要引入该模块就能直接使用。但是为了方便，我们将Redis操作封装到之前的common.lua工具库中。</p>
<p>修改<code>/usr/local/openresty/lualib/common.lua</code>文件：</p>
<p>1）引入Redis模块，并初始化Redis对象</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导入redis</span></span><br><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span>(<span class="string">&#x27;resty.redis&#x27;</span>)</span><br><span class="line"><span class="comment">-- 初始化redis</span></span><br><span class="line"><span class="keyword">local</span> red = redis:new()</span><br><span class="line">red:set_timeouts(<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>



<p>2）封装函数，用来释放Redis连接，其实是放入连接池</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 关闭redis连接的工具方法，其实是放入连接池</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">close_redis</span><span class="params">(red)</span></span></span><br><span class="line">    <span class="keyword">local</span> pool_max_idle_time = <span class="number">10000</span> <span class="comment">-- 连接的空闲时间，单位是毫秒</span></span><br><span class="line">    <span class="keyword">local</span> pool_size = <span class="number">100</span> <span class="comment">--连接池大小</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = red:set_keepalive(pool_max_idle_time, pool_size)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;放入redis连接池失败: &quot;</span>, err)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>3）封装函数，根据key查询Redis数据</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询redis的方法 ip和port是redis地址，key是查询的key</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_redis</span><span class="params">(ip, port, key)</span></span></span><br><span class="line">    <span class="comment">-- 获取一个连接</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = red:connect(ip, port)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;连接redis失败 : &quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 查询redis</span></span><br><span class="line">    <span class="keyword">local</span> resp, err = red:get(key)</span><br><span class="line">    <span class="comment">-- 查询失败处理</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis失败: &quot;</span>, err, <span class="string">&quot;, key = &quot;</span> , key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">--得到的数据为空处理</span></span><br><span class="line">    <span class="keyword">if</span> resp == ngx.null <span class="keyword">then</span></span><br><span class="line">        resp = <span class="literal">nil</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis数据为空, key = &quot;</span>, key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    close_redis(red)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>4）导出</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将方法导出</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;  </span><br><span class="line">    read_http = read_http,</span><br><span class="line">    read_redis = read_redis</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure>



<p>完整的common.lua：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导入redis</span></span><br><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span>(<span class="string">&#x27;resty.redis&#x27;</span>)</span><br><span class="line"><span class="comment">-- 初始化redis</span></span><br><span class="line"><span class="keyword">local</span> red = redis:new()</span><br><span class="line">red:set_timeouts(<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭redis连接的工具方法，其实是放入连接池</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">close_redis</span><span class="params">(red)</span></span></span><br><span class="line">    <span class="keyword">local</span> pool_max_idle_time = <span class="number">10000</span> <span class="comment">-- 连接的空闲时间，单位是毫秒</span></span><br><span class="line">    <span class="keyword">local</span> pool_size = <span class="number">100</span> <span class="comment">--连接池大小</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = red:set_keepalive(pool_max_idle_time, pool_size)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;放入redis连接池失败: &quot;</span>, err)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询redis的方法 ip和port是redis地址，key是查询的key</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_redis</span><span class="params">(ip, port, key)</span></span></span><br><span class="line">    <span class="comment">-- 获取一个连接</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = red:connect(ip, port)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;连接redis失败 : &quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 查询redis</span></span><br><span class="line">    <span class="keyword">local</span> resp, err = red:get(key)</span><br><span class="line">    <span class="comment">-- 查询失败处理</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis失败: &quot;</span>, err, <span class="string">&quot;, key = &quot;</span> , key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">--得到的数据为空处理</span></span><br><span class="line">    <span class="keyword">if</span> resp == ngx.null <span class="keyword">then</span></span><br><span class="line">        resp = <span class="literal">nil</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis数据为空, key = &quot;</span>, key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    close_redis(red)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装函数，发送http请求，并解析响应</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_http</span><span class="params">(path, params)</span></span></span><br><span class="line">    <span class="keyword">local</span> resp = ngx.location.capture(<span class="built_in">path</span>,&#123;</span><br><span class="line">        method = ngx.HTTP_GET,</span><br><span class="line">        args = params,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 记录错误信息，返回404</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;http查询失败, path: &quot;</span>, <span class="built_in">path</span> , <span class="string">&quot;, args: &quot;</span>, args)</span><br><span class="line">        ngx.<span class="built_in">exit</span>(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> resp.body</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 将方法导出</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;  </span><br><span class="line">    read_http = read_http,</span><br><span class="line">    read_redis = read_redis</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure>





<h3 id="实现Redis查询"><a href="#实现Redis查询" class="headerlink" title="实现Redis查询"></a>实现Redis查询</h3><p>接下来，我们就可以去修改item.lua文件，实现对Redis的查询了。</p>
<p>查询逻辑是：</p>
<ul>
<li>根据id查询Redis</li>
<li>如果查询失败则继续查询Tomcat</li>
<li>将查询结果返回</li>
</ul>
<p>1）修改<code>/usr/local/openresty/lua/item.lua</code>文件，添加一个查询函数：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导入common函数库</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&#x27;common&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="keyword">local</span> read_redis = common.read_redis</span><br><span class="line"><span class="comment">-- 封装查询函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, path, params)</span></span></span><br><span class="line">    <span class="comment">-- 查询本地缓存</span></span><br><span class="line">    <span class="keyword">local</span> val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, key)</span><br><span class="line">    <span class="comment">-- 判断查询结果</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)</span><br><span class="line">        <span class="comment">-- redis查询失败，去查询http</span></span><br><span class="line">        val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>2）而后修改商品查询、库存查询的业务：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821114528954.png" alt="image-20210821114528954"></p>
<p>3）完整的item.lua代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导入common函数库</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&#x27;common&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="keyword">local</span> read_redis = common.read_redis</span><br><span class="line"><span class="comment">-- 导入cjson库</span></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">&#x27;cjson&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装查询函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, path, params)</span></span></span><br><span class="line">    <span class="comment">-- 查询本地缓存</span></span><br><span class="line">    <span class="keyword">local</span> val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, key)</span><br><span class="line">    <span class="comment">-- 判断查询结果</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)</span><br><span class="line">        <span class="comment">-- redis查询失败，去查询http</span></span><br><span class="line">        val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询商品信息</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_data(<span class="string">&quot;item:id:&quot;</span> .. id,  <span class="string">&quot;/item/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 查询库存信息</span></span><br><span class="line"><span class="keyword">local</span> stockJSON = read_data(<span class="string">&quot;item:stock:id:&quot;</span> .. id, <span class="string">&quot;/item/stock/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSON转化为lua的table</span></span><br><span class="line"><span class="keyword">local</span> item = cjson.decode(itemJSON)</span><br><span class="line"><span class="keyword">local</span> stock = cjson.decode(stockJSON)</span><br><span class="line"><span class="comment">-- 组合数据</span></span><br><span class="line">item.stock = stock.stock</span><br><span class="line">item.sold = stock.sold</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把item序列化为json 返回结果</span></span><br><span class="line">ngx.say(cjson.encode(item))</span><br></pre></td></tr></table></figure>





<h2 id="Nginx本地缓存"><a href="#Nginx本地缓存" class="headerlink" title="Nginx本地缓存"></a>Nginx本地缓存</h2><p>现在，整个多级缓存中只差最后一环，也就是nginx的本地缓存了。如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821114742950.png" alt="image-20210821114742950"></p>
<h3 id="本地缓存API"><a href="#本地缓存API" class="headerlink" title="本地缓存API"></a>本地缓存API</h3><p>OpenResty为Nginx提供了<strong>shard dict</strong>的功能，可以在nginx的多个worker之间共享数据，实现缓存功能。</p>
<p>1）开启共享字典，在nginx.conf的http下添加配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 共享字典，也就是本地缓存，名称叫做：item_cache，大小150m</span></span><br><span class="line"><span class="attribute">lua_shared_dict</span> item_cache <span class="number">150m</span>; </span><br></pre></td></tr></table></figure>



<p>2）操作共享字典：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取本地缓存对象</span></span><br><span class="line"><span class="keyword">local</span> item_cache = ngx.shared.item_cache</span><br><span class="line"><span class="comment">-- 存储, 指定key、value、过期时间，单位s，默认为0代表永不过期</span></span><br><span class="line">item_cache:set(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">-- 读取</span></span><br><span class="line"><span class="keyword">local</span> val = item_cache:get(<span class="string">&#x27;key&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="实现本地缓存查询"><a href="#实现本地缓存查询" class="headerlink" title="实现本地缓存查询"></a>实现本地缓存查询</h3><p>1）修改<code>/usr/local/openresty/lua/item.lua</code>文件，修改read_data查询函数，添加本地缓存逻辑：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导入共享词典，本地缓存</span></span><br><span class="line"><span class="keyword">local</span> item_cache = ngx.shared.item_cache</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装查询函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, expire, path, params)</span></span></span><br><span class="line">    <span class="comment">-- 查询本地缓存</span></span><br><span class="line">    <span class="keyword">local</span> val = item_cache:get(key)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;本地缓存查询失败，尝试查询Redis， key: &quot;</span>, key)</span><br><span class="line">        <span class="comment">-- 查询redis</span></span><br><span class="line">        val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, key)</span><br><span class="line">        <span class="comment">-- 判断查询结果</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">            ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)</span><br><span class="line">            <span class="comment">-- redis查询失败，去查询http</span></span><br><span class="line">            val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 查询成功，把数据写入本地缓存</span></span><br><span class="line">    item_cache:set(key, val, expire)</span><br><span class="line">    <span class="comment">-- 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>





<p>2）修改item.lua中查询商品和库存的业务，实现最新的read_data函数：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821115108528.png" alt="image-20210821115108528"></p>
<p>其实就是多了缓存时间参数，过期后nginx缓存会自动删除，下次访问即可更新缓存。</p>
<p>这里给商品基本信息设置超时时间为30分钟，库存为1分钟。</p>
<p>因为库存更新频率较高，如果缓存时间过长，可能与数据库差异较大。</p>
<p>3）完整的item.lua文件：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导入common函数库</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&#x27;common&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="keyword">local</span> read_redis = common.read_redis</span><br><span class="line"><span class="comment">-- 导入cjson库</span></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">&#x27;cjson&#x27;</span>)</span><br><span class="line"><span class="comment">-- 导入共享词典，本地缓存</span></span><br><span class="line"><span class="keyword">local</span> item_cache = ngx.shared.item_cache</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装查询函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, expire, path, params)</span></span></span><br><span class="line">    <span class="comment">-- 查询本地缓存</span></span><br><span class="line">    <span class="keyword">local</span> val = item_cache:get(key)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;本地缓存查询失败，尝试查询Redis， key: &quot;</span>, key)</span><br><span class="line">        <span class="comment">-- 查询redis</span></span><br><span class="line">        val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, key)</span><br><span class="line">        <span class="comment">-- 判断查询结果</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">            ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)</span><br><span class="line">            <span class="comment">-- redis查询失败，去查询http</span></span><br><span class="line">            val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 查询成功，把数据写入本地缓存</span></span><br><span class="line">    item_cache:set(key, val, expire)</span><br><span class="line">    <span class="comment">-- 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询商品信息</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_data(<span class="string">&quot;item:id:&quot;</span> .. id, <span class="number">1800</span>,  <span class="string">&quot;/item/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 查询库存信息</span></span><br><span class="line"><span class="keyword">local</span> stockJSON = read_data(<span class="string">&quot;item:stock:id:&quot;</span> .. id, <span class="number">60</span>, <span class="string">&quot;/item/stock/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSON转化为lua的table</span></span><br><span class="line"><span class="keyword">local</span> item = cjson.decode(itemJSON)</span><br><span class="line"><span class="keyword">local</span> stock = cjson.decode(stockJSON)</span><br><span class="line"><span class="comment">-- 组合数据</span></span><br><span class="line">item.stock = stock.stock</span><br><span class="line">item.sold = stock.sold</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把item序列化为json 返回结果</span></span><br><span class="line">ngx.say(cjson.encode(item))</span><br></pre></td></tr></table></figure>





<h1 id="五、缓存同步"><a href="#五、缓存同步" class="headerlink" title="五、缓存同步"></a>五、缓存同步</h1><p>大多数情况下，浏览器查询到的都是缓存数据，如果缓存数据与数据库数据存在较大差异，可能会产生比较严重的后果。</p>
<p>所以我们必须保证数据库数据、缓存数据的一致性，这就是缓存与数据库的同步。</p>
<h2 id="数据同步策略"><a href="#数据同步策略" class="headerlink" title="数据同步策略"></a>数据同步策略</h2><p>缓存数据同步的常见方式有三种：</p>
<p><strong>设置有效期</strong>：给缓存设置有效期，到期后自动删除。再次查询时更新</p>
<ul>
<li>优势：简单、方便</li>
<li>缺点：时效性差，缓存过期之前可能不一致</li>
<li>场景：更新频率较低，时效性要求低的业务</li>
</ul>
<p><strong>同步双写</strong>：在修改数据库的同时，直接修改缓存</p>
<ul>
<li>优势：时效性强，缓存与数据库强一致</li>
<li>缺点：有代码侵入，耦合度高；</li>
<li>场景：对一致性、时效性要求较高的缓存数据</li>
</ul>
<p><strong>异步通知：</strong>修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据</p>
<ul>
<li>优势：低耦合，可以同时通知多个缓存服务</li>
<li>缺点：时效性一般，可能存在中间不一致状态</li>
<li>场景：时效性要求一般，有多个服务需要同步</li>
</ul>
<p>而异步实现又可以基于MQ或者Canal来实现：</p>
<p>1）基于MQ的异步通知：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821115552327.png" alt="image-20210821115552327"></p>
<p>解读：</p>
<ul>
<li>商品服务完成对数据的修改后，只需要发送一条消息到MQ中。</li>
<li>缓存服务监听MQ消息，然后完成对缓存的更新</li>
</ul>
<p>依然有少量的代码侵入。</p>
<p>2）基于Canal的通知</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821115719363.png" alt="image-20210821115719363"></p>
<p>解读：</p>
<ul>
<li>商品服务完成商品修改后，业务直接结束，没有任何代码侵入</li>
<li>Canal监听MySQL变化，当发现变化后，立即通知缓存服务</li>
<li>缓存服务接收到canal通知，更新缓存</li>
</ul>
<p>代码零侵入</p>
<h2 id="安装Canal"><a href="#安装Canal" class="headerlink" title="安装Canal"></a>安装Canal</h2><h3 id="认识Canal"><a href="#认识Canal" class="headerlink" title="认识Canal"></a>认识Canal</h3><p>**Canal [kə’næl]**，译意为水道/管道/沟渠，canal是阿里巴巴旗下的一款开源项目，基于Java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费。GitHub的地址：<a href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p>
<p>Canal是基于mysql的主从同步来实现的，MySQL主从同步的原理如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821115914748.png" alt="image-20210821115914748"></p>
<ul>
<li>1）MySQL master 将数据变更写入二进制日志( binary log），其中记录的数据叫做binary log events</li>
<li>2）MySQL slave 将 master 的 binary log events拷贝到它的中继日志(relay log)</li>
<li>3）MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据</li>
</ul>
<p>而Canal就是把自己伪装成MySQL的一个slave节点，从而监听master的binary log变化。再把得到的变化信息通知给Canal的客户端，进而完成对其它数据库的同步。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821115948395.png" alt="image-20210821115948395"></p>
<h3 id="安装Canal-1"><a href="#安装Canal-1" class="headerlink" title="安装Canal"></a>安装Canal</h3><p>安装和配置Canal参考课前资料文档：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821120017324.png" alt="image-20210821120017324"> </p>
<h2 id="监听Canal"><a href="#监听Canal" class="headerlink" title="监听Canal"></a>监听Canal</h2><p>Canal提供了各种语言的客户端，当Canal监听到binlog变化时，会通知Canal的客户端。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821120049024.png" alt="image-20210821120049024"></p>
<p>我们可以利用Canal提供的Java客户端，监听Canal通知消息。当收到变化的消息时，完成对缓存的更新。</p>
<p>不过这里我们会使用GitHub上的第三方开源的canal-starter客户端。地址：<a href="https://github.com/NormanGyllenhaal/canal-client">https://github.com/NormanGyllenhaal/canal-client</a></p>
<p>与SpringBoot完美整合，自动装配，比官方客户端要简单好用很多。</p>
<h3 id="引入依赖："><a href="#引入依赖：" class="headerlink" title="引入依赖："></a>引入依赖：</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.javatool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>canal-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="编写配置："><a href="#编写配置：" class="headerlink" title="编写配置："></a>编写配置：</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">canal:</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">heima</span> <span class="comment"># canal的集群名字，要与安装canal时设置的名称一致</span></span><br><span class="line">  <span class="attr">server:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:11111</span> <span class="comment"># canal服务地址</span></span><br></pre></td></tr></table></figure>



<h3 id="修改Item实体类"><a href="#修改Item实体类" class="headerlink" title="修改Item实体类"></a>修改Item实体类</h3><p>通过@Id、@Column、等注解完成Item与数据库表字段的映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Transient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;tb_item&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;<span class="comment">//商品id</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//商品名称</span></span><br><span class="line">    <span class="keyword">private</span> String title;<span class="comment">//商品标题</span></span><br><span class="line">    <span class="keyword">private</span> Long price;<span class="comment">//价格（分）</span></span><br><span class="line">    <span class="keyword">private</span> String image;<span class="comment">//商品图片</span></span><br><span class="line">    <span class="keyword">private</span> String category;<span class="comment">//分类名称</span></span><br><span class="line">    <span class="keyword">private</span> String brand;<span class="comment">//品牌名称</span></span><br><span class="line">    <span class="keyword">private</span> String spec;<span class="comment">//规格</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;<span class="comment">//商品状态 1-正常，2-下架</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;<span class="comment">//创建时间</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;<span class="comment">//更新时间</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> Integer sold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="编写监听器"><a href="#编写监听器" class="headerlink" title="编写监听器"></a>编写监听器</h3><p>通过实现<code>EntryHandler&lt;T&gt;</code>接口编写监听器，监听Canal消息。注意两点：</p>
<ul>
<li>实现类通过<code>@CanalTable(&quot;tb_item&quot;)</code>指定监听的表信息</li>
<li>EntryHandler的泛型是与表对应的实体类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.canal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.config.RedisHandler;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.annotation.CanalTable;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.handler.EntryHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CanalTable(&quot;tb_item&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemHandler</span> <span class="keyword">implements</span> <span class="title class_">EntryHandler</span>&lt;Item&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisHandler redisHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;Long, Item&gt; itemCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="comment">// 写数据到JVM进程缓存</span></span><br><span class="line">        itemCache.put(item.getId(), item);</span><br><span class="line">        <span class="comment">// 写数据到redis</span></span><br><span class="line">        redisHandler.saveItem(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Item before, Item after)</span> &#123;</span><br><span class="line">        <span class="comment">// 写数据到JVM进程缓存</span></span><br><span class="line">        itemCache.put(after.getId(), after);</span><br><span class="line">        <span class="comment">// 写数据到redis</span></span><br><span class="line">        redisHandler.saveItem(after);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="comment">// 删除数据到JVM进程缓存</span></span><br><span class="line">        itemCache.invalidate(item.getId());</span><br><span class="line">        <span class="comment">// 删除数据到redis</span></span><br><span class="line">        redisHandler.deleteItemById(item.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这里对Redis的操作都封装到了RedisHandler这个对象中，是我们之前做缓存预热时编写的一个类，内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.ItemStock;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemService;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemStockService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisHandler</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemService itemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemStockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">MAPPER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 初始化缓存</span></span><br><span class="line">        <span class="comment">// 1.查询商品信息</span></span><br><span class="line">        List&lt;Item&gt; itemList = itemService.list();</span><br><span class="line">        <span class="comment">// 2.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (Item item : itemList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(item);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:id:&quot;</span> + item.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询商品库存信息</span></span><br><span class="line">        List&lt;ItemStock&gt; stockList = stockService.list();</span><br><span class="line">        <span class="comment">// 4.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (ItemStock stock : stockList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(stock);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:stock:id:&quot;</span> + stock.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveItem</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(item);</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:id:&quot;</span> + item.getId(), json);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteItemById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;item:id:&quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="——最佳实践——"><a href="#——最佳实践——" class="headerlink" title="——最佳实践——"></a>——最佳实践——</h1><p><strong>今日内容</strong></p>
<blockquote>
<ul>
<li>Redis键值设计</li>
<li>批处理优化</li>
<li>服务端优化</li>
<li>集群最佳实践</li>
</ul>
</blockquote>
<h1 id="一、Redis键值设计"><a href="#一、Redis键值设计" class="headerlink" title="一、Redis键值设计"></a>一、Redis键值设计</h1><h2 id="优雅的key结构"><a href="#优雅的key结构" class="headerlink" title="优雅的key结构"></a>优雅的key结构</h2><p>Redis的Key虽然可以自定义，但最好遵循下面的几个最佳实践约定：</p>
<ul>
<li>遵循基本格式：[业务名称]:[数据名]:[id]</li>
<li>长度不超过44字节</li>
<li>不包含特殊字符</li>
</ul>
<p>例如：我们的登录业务，保存用户信息，其key可以设计成如下格式：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521120213631.png" alt="image-20220521120213631"></p>
<p>这样设计的好处：</p>
<ul>
<li>可读性强</li>
<li>避免key冲突</li>
<li>方便管理</li>
<li>更节省内存： key是string类型，底层编码包含int、embstr和raw三种。embstr在小于44字节使用，采用连续内存空间，内存占用更小。当字节数大于44字节时，会转为raw模式存储，在raw模式下，内存空间不是连续的，而是采用一个指针指向了另外一段内存空间，在这段空间里存储SDS内容，这样空间不连续，访问的时候性能也就会收到影响，还有可能产生内存碎片</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521122320482.png" alt="image-20220521122320482"></p>
<h2 id="拒绝BigKey"><a href="#拒绝BigKey" class="headerlink" title="拒绝BigKey"></a>拒绝BigKey</h2><p>BigKey通常以Key的大小和Key中成员的数量来综合判定，例如：</p>
<ul>
<li>Key本身的数据量过大：一个String类型的Key，它的值为5 MB</li>
<li>Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个</li>
<li>Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1,000个但这些成员的Value（值）总大小为100 MB</li>
</ul>
<p>那么如何判断元素的大小呢？redis也给我们提供了命令</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521124650117.png" alt="image-20220521124650117"></p>
<p>推荐值：</p>
<ul>
<li>单个key的value小于10KB</li>
<li>对于集合类型的key，建议元素数量小于1000</li>
</ul>
<h3 id="BigKey的危害"><a href="#BigKey的危害" class="headerlink" title="BigKey的危害"></a>BigKey的危害</h3><ul>
<li>网络阻塞<ul>
<li>对BigKey执行读请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis实例，乃至所在物理机变慢</li>
</ul>
</li>
<li>数据倾斜<ul>
<li>BigKey所在的Redis实例内存使用率远超其他实例，无法使数据分片的内存资源达到均衡</li>
</ul>
</li>
<li>Redis阻塞<ul>
<li>对元素较多的hash、list、zset等做运算会耗时较旧，使主线程被阻塞</li>
</ul>
</li>
<li>CPU压力<ul>
<li>对BigKey的数据序列化和反序列化会导致CPU的使用率飙升，影响Redis实例和本机其它应用</li>
</ul>
</li>
</ul>
<h3 id="如何发现BigKey"><a href="#如何发现BigKey" class="headerlink" title="如何发现BigKey"></a>如何发现BigKey</h3><h4 id="redis-cli-–bigkeys"><a href="#redis-cli-–bigkeys" class="headerlink" title="redis-cli –bigkeys"></a>redis-cli –bigkeys</h4><p>利用redis-cli提供的–bigkeys参数，可以遍历分析所有key，并返回Key的整体统计信息与每个数据的Top1的big key</p>
<p>命令：<code>redis-cli -a 密码 --bigkeys</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521133359507.png" alt="image-20220521133359507"></p>
<h4 id="scan扫描"><a href="#scan扫描" class="headerlink" title="scan扫描"></a>scan扫描</h4><p>自己编程，利用scan扫描Redis中的所有key，利用strlen、hlen等命令判断key的长度（此处不建议使用MEMORY USAGE）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521133703245.png" alt="image-20220521133703245"></p>
<p>scan 命令调用完后每次会返回2个元素，第一个是下一次迭代的光标，第一次光标会设置为0，当最后一次scan 返回的光标等于0时，表示整个scan遍历结束了，第二个返回的是List，一个匹配的key的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.heima.jedis.util.JedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="comment">// jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span></span><br><span class="line">        jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">        <span class="comment">// 2.设置密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.选择库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">STR_MAX_LEN</span> <span class="operator">=</span> <span class="number">10</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">HASH_MAX_LEN</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testScan</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 扫描并获取一部分key</span></span><br><span class="line">            ScanResult&lt;String&gt; result = jedis.scan(cursor);</span><br><span class="line">            <span class="comment">// 记录cursor</span></span><br><span class="line">            cursor = result.getCursor();</span><br><span class="line">            List&lt;String&gt; list = result.getResult();</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历</span></span><br><span class="line">            <span class="keyword">for</span> (String key : list) &#123;</span><br><span class="line">                <span class="comment">// 判断key的类型</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> jedis.type(key);</span><br><span class="line">                <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;string&quot;</span>:</span><br><span class="line">                        len = jedis.strlen(key);</span><br><span class="line">                        maxLen = STR_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;hash&quot;</span>:</span><br><span class="line">                        len = jedis.hlen(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;list&quot;</span>:</span><br><span class="line">                        len = jedis.llen(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;set&quot;</span>:</span><br><span class="line">                        len = jedis.scard(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;zset&quot;</span>:</span><br><span class="line">                        len = jedis.zcard(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (len &gt;= maxLen) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;Found big key : %s, type: %s, length or size: %d %n&quot;</span>, key, type, len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!cursor.equals(<span class="string">&quot;0&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三方工具"><a href="#第三方工具" class="headerlink" title="第三方工具"></a>第三方工具</h4><ul>
<li>利用第三方工具，如 Redis-Rdb-Tools 分析RDB快照文件，全面分析内存使用情况</li>
<li><a href="https://github.com/sripathikrishnan/redis-rdb-tools">https://github.com/sripathikrishnan/redis-rdb-tools</a></li>
</ul>
<h4 id="网络监控"><a href="#网络监控" class="headerlink" title="网络监控"></a>网络监控</h4><ul>
<li>自定义工具，监控进出Redis的网络数据，超出预警值时主动告警</li>
<li>一般阿里云搭建的云服务器就有相关监控页面</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521140415785.png" alt="image-20220521140415785"></p>
<h3 id="如何删除BigKey"><a href="#如何删除BigKey" class="headerlink" title="如何删除BigKey"></a>如何删除BigKey</h3><p>BigKey内存占用较多，即便时删除这样的key也需要耗费很长时间，导致Redis主线程阻塞，引发一系列问题。</p>
<ul>
<li>redis 3.0 及以下版本<ul>
<li>如果是集合类型，则遍历BigKey的元素，先逐个删除子元素，最后删除BigKey</li>
</ul>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521140621204.png" alt="image-20220521140621204"></p>
<ul>
<li>Redis 4.0以后<ul>
<li>Redis在4.0后提供了异步删除的命令：unlink</li>
</ul>
</li>
</ul>
<h2 id="恰当的数据类型"><a href="#恰当的数据类型" class="headerlink" title="恰当的数据类型"></a>恰当的数据类型</h2><h3 id="存储一个User对象，我们有三种存储方式："><a href="#存储一个User对象，我们有三种存储方式：" class="headerlink" title="存储一个User对象，我们有三种存储方式："></a>存储一个User对象，我们有三种存储方式：</h3><h4 id="json字符串"><a href="#json字符串" class="headerlink" title="json字符串"></a>json字符串</h4><table>
<thead>
<tr>
<th align="center">user:1</th>
<th align="center">{“name”: “Jack”, “age”: 21}</th>
</tr>
</thead>
</table>
<p>优点：实现简单粗暴</p>
<p>缺点：数据耦合，不够灵活</p>
<h4 id="字段打散"><a href="#字段打散" class="headerlink" title="字段打散"></a>字段打散</h4><table>
<thead>
<tr>
<th align="center">user:1:name</th>
<th align="center">Jack</th>
</tr>
</thead>
<tbody><tr>
<td align="center">user:1:age</td>
<td align="center">21</td>
</tr>
</tbody></table>
<p>优点：可以灵活访问对象任意字段</p>
<p>缺点：占用空间大、没办法做统一控制</p>
<h4 id="hash（推荐）"><a href="#hash（推荐）" class="headerlink" title="hash（推荐）"></a>hash（推荐）</h4><table>
    <tr>
        <td rowspan="2">user:1</td>
        <td>name</td>
        <td>jack</td>
    </tr>
    <tr>
        <td>age</td>
        <td>21</td>
    </tr>
</table>



<p>优点：底层使用ziplist，空间占用小，可以灵活访问对象的任意字段</p>
<p>缺点：代码相对复杂</p>
<h3 id="假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？"><a href="#假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？" class="headerlink" title="假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？"></a>假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？</h3><table>
    <tr style="color:red">
        <td>key</td>
        <td>field</td>
        <td>value</td>
    </tr>
    <tr>
        <td rowspan="3">someKey</td>
        <td>id:0</td>
        <td>value0</td>
    </tr>
    <tr>
        <td>.....</td>
        <td>.....</td>
    </tr>
    <tr>
        <td>id:999999</td>
        <td>value999999</td>
    </tr>
</table>



<p>存在的问题：</p>
<ul>
<li>hash的entry数量超过500时，会使用哈希表而不是ZipList，内存占用较多<ul>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521142943350.png" alt="image-20220521142943350"></li>
</ul>
</li>
<li>可以通过hash-max-ziplist-entries配置entry上限。但是如果entry过多就会导致BigKey问题</li>
</ul>
<h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>拆分为string类型</p>
<table>
    <tr style="color:red">
        <td>key</td>
        <td>value</td>
    </tr>
    <tr>
        <td>id:0</td>
        <td>value0</td>
    </tr>
    <tr>
        <td>.....</td>
        <td>.....</td>
    </tr>
    <tr>
        <td>id:999999</td>
        <td>value999999</td>
    </tr>
</table>



<p>存在的问题：</p>
<ul>
<li>string结构底层没有太多内存优化，内存占用较多</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521143458010.png" alt="image-20220521143458010"></p>
<ul>
<li>想要批量获取这些数据比较麻烦</li>
</ul>
<h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>拆分为小的hash，将 id / 100 作为key， 将id % 100 作为field，这样每100个元素为一个Hash</p>
<table>
    <tr style="color:red">
        <td>key</td>
        <td>field</td>
        <td>value</td>
    </tr>
    <tr>
        <td rowspan="3">key:0</td>
        <td>id:00</td>
        <td>value0</td>
    </tr>
    <tr>
        <td>.....</td>
        <td>.....</td>
    </tr>
    <tr>
        <td>id:99</td>
        <td>value99</td>
    </tr>
    <tr>
        <td rowspan="3">key:1</td>
        <td>id:00</td>
        <td>value100</td>
    </tr>
    <tr>
        <td>.....</td>
        <td>.....</td>
    </tr>
    <tr>
        <td>id:99</td>
        <td>value199</td>
    </tr>
    <tr>
        <td colspan="3">....</td>
    </tr>
    <tr>
        <td rowspan="3">key:9999</td>
        <td>id:00</td>
        <td>value999900</td>
    </tr>
    <tr>
        <td>.....</td>
        <td>.....</td>
    </tr>
    <tr>
        <td>id:99</td>
        <td>value999999</td>
    </tr>
</table>



<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521144339377.png" alt="image-20220521144339377"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.heima.jedis.util.JedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Pipeline;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="comment">// jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span></span><br><span class="line">        jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">        <span class="comment">// 2.设置密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.选择库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSetBigKey</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">650</span>; i++) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;hello_&quot;</span> + i, <span class="string">&quot;world!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.hmset(<span class="string">&quot;m2&quot;</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testBigHash</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;key_&quot;</span> + i, <span class="string">&quot;value_&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.hmset(<span class="string">&quot;test:big:hash&quot;</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testBigString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            jedis.set(<span class="string">&quot;test:str:key_&quot;</span> + i, <span class="string">&quot;value_&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSmallHash</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hashSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(hashSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (i - <span class="number">1</span>) / hashSize;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> i % hashSize;</span><br><span class="line">            map.put(<span class="string">&quot;key_&quot;</span> + v, <span class="string">&quot;value_&quot;</span> + v);</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="number">0</span>) &#123;</span><br><span class="line">                jedis.hmset(<span class="string">&quot;test:small:hash_&quot;</span> + k, map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Key的最佳实践<ul>
<li>固定格式：[业务名]:[数据名]:[id]</li>
<li>足够简短：不超过44字节</li>
<li>不包含特殊字符</li>
</ul>
</li>
<li>Value的最佳实践：<ul>
<li>合理的拆分数据，拒绝BigKey</li>
<li>选择合适数据结构</li>
<li>Hash结构的entry数量不要超过1000</li>
<li>设置合理的超时时间</li>
</ul>
</li>
</ul>
<h1 id="二、批处理优化"><a href="#二、批处理优化" class="headerlink" title="二、批处理优化"></a>二、批处理优化</h1><h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><h3 id="我们的客户端与redis服务器是这样交互的"><a href="#我们的客户端与redis服务器是这样交互的" class="headerlink" title="我们的客户端与redis服务器是这样交互的"></a>我们的客户端与redis服务器是这样交互的</h3><p>单个命令的执行流程</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521151459880.png" alt="image-20220521151459880"></p>
<p>N条命令的执行流程</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521151524621.png" alt="image-20220521151524621"></p>
<p>redis处理指令是很快的，主要花费的时候在于网络传输。于是乎很容易想到将多条指令批量的传输给redis</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521151902080.png" alt="image-20220521151902080"></p>
<h3 id="MSet"><a href="#MSet" class="headerlink" title="MSet"></a>MSet</h3><p>Redis提供了很多Mxxx这样的命令，可以实现批量插入数据，例如：</p>
<ul>
<li>mset</li>
<li>hmset</li>
</ul>
<p>利用mset批量插入10万条数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMxx</span><span class="params">()</span> &#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2000</span>];</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        j = (i % <span class="number">1000</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        arr[j] = <span class="string">&quot;test:key_&quot;</span> + i;</span><br><span class="line">        arr[j + <span class="number">1</span>] = <span class="string">&quot;value_&quot;</span> + i;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            jedis.mset(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time: &quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Pipeline-1"><a href="#Pipeline-1" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>MSET虽然可以批处理，但是却只能操作部分数据类型，因此如果有对复杂数据类型的批处理需要，建议使用Pipeline</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPipeline</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 放入命令到管道</span></span><br><span class="line">        pipeline.set(<span class="string">&quot;test:key_&quot;</span> + i, <span class="string">&quot;value_&quot;</span> + i);</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 每放入1000条命令，批量执行</span></span><br><span class="line">            pipeline.sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time: &quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集群下的批处理"><a href="#集群下的批处理" class="headerlink" title="集群下的批处理"></a>集群下的批处理</h2><p>如MSET或Pipeline这样的批处理需要在一次请求中携带多条命令，而此时如果Redis是一个集群，那批处理命令的多个key必须落在一个插槽中，否则就会导致执行失败。大家可以想一想这样的要求其实很难实现，因为我们在批处理时，可能一次要插入很多条数据，这些数据很有可能不会都落在相同的节点上，这就会导致报错了</p>
<p>这个时候，我们可以找到4种解决方案</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653126446641.png" alt="1653126446641"></p>
<p>第一种方案：串行执行，所以这种方式没有什么意义，当然，执行起来就很简单了，缺点就是耗时过久。</p>
<p>第二种方案：串行slot，简单来说，就是执行前，客户端先计算一下对应的key的slot，一样slot的key就放到一个组里边，不同的，就放到不同的组里边，然后对每个组执行pipeline的批处理，他就能串行执行各个组的命令，这种做法比第一种方法耗时要少，但是缺点呢，相对来说复杂一点，所以这种方案还需要优化一下</p>
<p>第三种方案：并行slot，相较于第二种方案，在分组完成后串行执行，第三种方案，就变成了并行执行各个命令，所以他的耗时就非常短，但是实现呢，也更加复杂。</p>
<p>第四种：hash_tag，redis计算key的slot的时候，其实是根据key的有效部分来计算的，通过这种方式就能一次处理所有的key，这种方式耗时最短，实现也简单，但是如果通过操作key的有效部分，那么就会导致所有的key都落在一个节点上，产生数据倾斜的问题，所以我们推荐使用第三种方式。</p>
<h3 id="串行化执行代码实践"><a href="#串行化执行代码实践" class="headerlink" title="串行化执行代码实践"></a>串行化执行代码实践</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisClusterTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JedisCluster jedisCluster;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">        HashSet&lt;HostAndPort&gt; nodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7001</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7002</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7003</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8001</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8002</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8003</span>));</span><br><span class="line">        jedisCluster = <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(nodes, poolConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testMSet</span><span class="params">()</span> &#123;</span><br><span class="line">        jedisCluster.mset(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>, <span class="string">&quot;sex&quot;</span>, <span class="string">&quot;male&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testMSet2</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;Male&quot;</span>);</span><br><span class="line">        <span class="comment">//对Map数据进行分组。根据相同的slot放在一个分组</span></span><br><span class="line">        <span class="comment">//key就是slot，value就是一个组</span></span><br><span class="line">        Map&lt;Integer, List&lt;Map.Entry&lt;String, String&gt;&gt;&gt; result = map.entrySet()</span><br><span class="line">                .stream()</span><br><span class="line">                .collect(Collectors.groupingBy(</span><br><span class="line">                        entry -&gt; ClusterSlotHashUtil.calculateSlot(entry.getKey()))</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">//串行的去执行mset的逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Map.Entry&lt;String, String&gt;&gt; list : result.values()) &#123;</span><br><span class="line">            String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[list.size() * <span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                j = i&lt;&lt;<span class="number">2</span>;</span><br><span class="line">                Map.Entry&lt;String, String&gt; e = list.get(<span class="number">0</span>);</span><br><span class="line">                arr[j] = e.getKey();</span><br><span class="line">                arr[j + <span class="number">1</span>] = e.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">            jedisCluster.mset(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedisCluster != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedisCluster.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring集群环境下批处理代码"><a href="#Spring集群环境下批处理代码" class="headerlink" title="Spring集群环境下批处理代码"></a>Spring集群环境下批处理代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">testMSetInCluster</span><span class="params">()</span> &#123;</span><br><span class="line">     Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">     map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;Female&quot;</span>);</span><br><span class="line">     stringRedisTemplate.opsForValue().multiSet(map);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     List&lt;String&gt; strings = stringRedisTemplate.opsForValue().multiGet(Arrays.asList(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;sex&quot;</span>));</span><br><span class="line">     strings.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>原理分析</strong></p>
<p>在RedisAdvancedClusterAsyncCommandsImpl 类中</p>
<p>首先根据slotHash算出来一个partitioned的map，map中的key就是slot，而他的value就是对应的对应相同slot的key对应的数据</p>
<p>通过 RedisFuture<String> mset = super.mset(op);进行异步的消息发送</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RedisFuture&lt;String&gt; <span class="title function_">mset</span><span class="params">(Map&lt;K, V&gt; map)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, List&lt;K&gt;&gt; partitioned = SlotHash.partition(codec, map.keySet());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (partitioned.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.mset(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, RedisFuture&lt;String&gt;&gt; executions = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, List&lt;K&gt;&gt; entry : partitioned.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;K, V&gt; op = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        entry.getValue().forEach(k -&gt; op.put(k, map.get(k)));</span><br><span class="line"></span><br><span class="line">        RedisFuture&lt;String&gt; mset = <span class="built_in">super</span>.mset(op);</span><br><span class="line">        executions.put(entry.getKey(), mset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MultiNodeExecution.firstOfAsync(executions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、服务器端优化"><a href="#三、服务器端优化" class="headerlink" title="三、服务器端优化"></a>三、服务器端优化</h1><h2 id="持久化配置"><a href="#持久化配置" class="headerlink" title="持久化配置"></a>持久化配置</h2><p>Redis的持久化虽然可以保证数据安全，但也会带来很多额外的开销，因此持久化请遵循下列建议：</p>
<ul>
<li>用来做缓存的Redis实例尽量不要开启持久化功能</li>
<li>建议关闭RDB持久化功能，使用AOF持久化</li>
<li>利用脚本定期在slave节点做RDB，实现数据备份</li>
<li>设置合理的rewrite阈值，避免频繁的bgrewrite</li>
<li>配置no-appendfsync-on-rewrite = yes，禁止在rewrite期间做aof，避免因AOF引起的阻塞</li>
<li>部署有关建议：<ul>
<li>Redis实例的物理机要预留足够内存，应对fork和rewrite</li>
<li>单个Redis实例内存上限不要太大，例如4G或8G。可以加快fork的速度、减少主从同步、数据迁移压力</li>
<li>不要与CPU密集型应用部署在一起</li>
<li>不要与高硬盘负载应用一起部署。例如：数据库、消息队列</li>
</ul>
</li>
</ul>
<h2 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h2><h3 id="什么是慢查询"><a href="#什么是慢查询" class="headerlink" title="什么是慢查询"></a>什么是慢查询</h3><p>并不是很慢的查询才是慢查询，而是：在Redis执行时耗时超过某个阈值的命令，称为慢查询。</p>
<p>慢查询的危害：由于Redis是单线程的，所以当客户端发出指令后，他们都会进入到redis底层的queue来执行，如果此时有一些慢查询的数据，就会导致大量请求阻塞，从而引起报错，所以我们需要解决慢查询问题。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653129590210.png" alt="1653129590210"></p>
<p>慢查询的阈值可以通过配置指定：</p>
<p>slowlog-log-slower-than：慢查询阈值，单位是微秒。默认是10000，建议1000</p>
<p>慢查询会被放入慢查询日志中，日志的长度有上限，可以通过配置指定：</p>
<p>slowlog-max-len：慢查询日志（本质是一个队列）的长度。默认是128，建议1000</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653130457771.png" alt="1653130457771"></p>
<p>修改这两个配置可以使用：config set命令：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653130475979.png" alt="1653130475979"></p>
<h3 id="如何查看慢查询"><a href="#如何查看慢查询" class="headerlink" title="如何查看慢查询"></a>如何查看慢查询</h3><p>知道了以上内容之后，那么咱们如何去查看慢查询日志列表呢：</p>
<ul>
<li>slowlog len：查询慢查询日志长度</li>
<li>slowlog get [n]：读取n条慢查询日志</li>
<li>slowlog reset：清空慢查询列表</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653130858066.png" alt="1653130858066"></p>
<h2 id="命令及安全配置"><a href="#命令及安全配置" class="headerlink" title="命令及安全配置"></a>命令及安全配置</h2><p> 安全可以说是服务器端一个非常重要的话题，如果安全出现了问题，那么一旦这个漏洞被一些坏人知道了之后，并且进行攻击，那么这就会给咱们的系统带来很多的损失，所以我们这节课就来解决这个问题。</p>
<p>Redis会绑定在0.0.0.0:6379，这样将会将Redis服务暴露到公网上，而Redis如果没有做身份认证，会出现严重的安全漏洞.<br>漏洞重现方式：<a href="https://cloud.tencent.com/developer/article/1039000">https://cloud.tencent.com/developer/article/1039000</a></p>
<p>为什么会出现不需要密码也能够登录呢，主要是Redis考虑到每次登录都比较麻烦，所以Redis就有一种ssh免秘钥登录的方式，生成一对公钥和私钥，私钥放在本地，公钥放在redis端，当我们登录时服务器，再登录时候，他会去解析公钥和私钥，如果没有问题，则不需要利用redis的登录也能访问，这种做法本身也很常见，但是这里有一个前提，前提就是公钥必须保存在服务器上，才行，但是Redis的漏洞在于在不登录的情况下，也能把秘钥送到Linux服务器，从而产生漏洞</p>
<p>漏洞出现的核心的原因有以下几点：</p>
<ul>
<li>Redis未设置密码</li>
<li>利用了Redis的config set命令动态修改Redis配置</li>
<li>使用了Root账号权限启动Redis</li>
</ul>
<p>所以：如何解决呢？我们可以采用如下几种方案</p>
<p>为了避免这样的漏洞，这里给出一些建议：</p>
<ul>
<li>Redis一定要设置密码</li>
<li>禁止线上使用下面命令：keys、flushall、flushdb、config set等命令。可以利用rename-command禁用。</li>
<li>bind：限制网卡，禁止外网网卡访问</li>
<li>开启防火墙</li>
<li>不要使用Root账户启动Redis</li>
<li>尽量不是有默认的端口</li>
</ul>
<h2 id="Redis内存划分和内存配置"><a href="#Redis内存划分和内存配置" class="headerlink" title="Redis内存划分和内存配置"></a>Redis内存划分和内存配置</h2><p>当Redis内存不足时，可能导致Key频繁被删除、响应时间变长、QPS不稳定等问题。当内存使用率达到90%以上时就需要我们警惕，并快速定位到内存占用的原因。</p>
<p><strong>有关碎片问题分析</strong></p>
<p>Redis底层分配并不是这个key有多大，他就会分配多大，而是有他自己的分配策略，比如8,16,20等等，假定当前key只需要10个字节，此时分配8肯定不够，那么他就会分配16个字节，多出来的6个字节就不能被使用，这就是我们常说的 碎片问题</p>
<p><strong>进程内存问题分析：</strong></p>
<p>这片内存，通常我们都可以忽略不计</p>
<p><strong>缓冲区内存问题分析：</strong></p>
<p>一般包括客户端缓冲区、AOF缓冲区、复制缓冲区等。客户端缓冲区又包括输入缓冲区和输出缓冲区两种。这部分内存占用波动较大，所以这片内存也是我们需要重点分析的内存问题。</p>
<table>
<thead>
<tr>
<th><strong>内存占用</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>数据内存</td>
<td>是Redis最主要的部分，存储Redis的键值信息。主要问题是BigKey问题、内存碎片问题</td>
</tr>
<tr>
<td>进程内存</td>
<td>Redis主进程本身运⾏肯定需要占⽤内存，如代码、常量池等等；这部分内存⼤约⼏兆，在⼤多数⽣产环境中与Redis数据占⽤的内存相⽐可以忽略。</td>
</tr>
<tr>
<td>缓冲区内存</td>
<td>一般包括客户端缓冲区、AOF缓冲区、复制缓冲区等。客户端缓冲区又包括输入缓冲区和输出缓冲区两种。这部分内存占用波动较大，不当使用BigKey，可能导致内存溢出。</td>
</tr>
</tbody></table>
<p>于是我们就需要通过一些命令，可以查看到Redis目前的内存分配状态：</p>
<ul>
<li>info memory：查看内存分配的情况</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653132073570.png" alt="1653132073570"></p>
<ul>
<li>memory xxx：查看key的主要占用情况</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653132098823.png" alt="1653132098823"></p>
<p>接下来我们看到了这些配置，最关键的缓存区内存如何定位和解决呢？</p>
<p>内存缓冲区常见的有三种：</p>
<ul>
<li>复制缓冲区：主从复制的repl_backlog_buf，如果太小可能导致频繁的全量复制，影响性能。通过replbacklog-size来设置，默认1mb</li>
<li>AOF缓冲区：AOF刷盘之前的缓存区域，AOF执行rewrite的缓冲区。无法设置容量上限</li>
<li>客户端缓冲区：分为输入缓冲区和输出缓冲区，输入缓冲区最大1G且不能设置。输出缓冲区可以设置</li>
</ul>
<p>以上复制缓冲区和AOF缓冲区 不会有问题，最关键就是客户端缓冲区的问题</p>
<p>客户端缓冲区：指的就是我们发送命令时，客户端用来缓存命令的一个缓冲区，也就是我们向redis输入数据的输入端缓冲区和redis向客户端返回数据的响应缓存区，输入缓冲区最大1G且不能设置，所以这一块我们根本不用担心，如果超过了这个空间，redis会直接断开，因为本来此时此刻就代表着redis处理不过来了，我们需要担心的就是输出端缓冲区</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653132410073.png" alt="1653132410073"></p>
<p>我们在使用redis过程中，处理大量的big value，那么会导致我们的输出结果过多，如果输出缓存区过大，会导致redis直接断开，而默认配置的情况下， 其实他是没有大小的，这就比较坑了，内存可能一下子被占满，会直接导致咱们的redis断开，所以解决方案有两个</p>
<p>1、设置一个大小</p>
<p>2、增加我们带宽的大小，避免我们出现大量数据从而直接超过了redis的承受能力</p>
<h2 id="集群优化-集群-or-主从"><a href="#集群优化-集群-or-主从" class="headerlink" title="集群优化 集群 or 主从"></a>集群优化 集群 or 主从</h2><p>集群虽然具备高可用特性，能实现自动故障恢复，但是如果使用不当，也会存在一些问题：</p>
<ul>
<li><p>集群完整性问题</p>
</li>
<li><p>集群带宽问题</p>
</li>
<li><p>数据倾斜问题</p>
</li>
<li><p>客户端性能问题</p>
</li>
<li><p>命令的集群兼容性问题</p>
</li>
<li><p>lua和事务问题</p>
</li>
<li><p><em>问题1、在Redis的默认配置中，如果发现任意一个插槽不可用，则整个集群都会停止对外服务：</em>* </p>
</li>
</ul>
<p>大家可以设想一下，如果有几个slot不能使用，那么此时整个集群都不能用了，我们在开发中，其实最重要的是可用性，所以需要把如下配置修改成no，即有slot不能使用时，我们的redis集群还是可以对外提供服务</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653132740637.png" alt="1653132740637"></p>
<p><strong>问题2、集群带宽问题</strong></p>
<p>集群节点之间会不断的互相Ping来确定集群中其它节点的状态。每次Ping携带的信息至少包括：</p>
<ul>
<li>插槽信息</li>
<li>集群状态信息</li>
</ul>
<p>集群中节点越多，集群状态信息数据量也越大，10个节点的相关信息可能达到1kb，此时每次集群互通需要的带宽会非常高，这样会导致集群中大量的带宽都会被ping信息所占用，这是一个非常可怕的问题，所以我们需要去解决这样的问题</p>
<p><strong>解决途径：</strong></p>
<ul>
<li>避免大集群，集群节点数不要太多，最好少于1000，如果业务庞大，则建立多个集群。</li>
<li>避免在单个物理机中运行太多Redis实例</li>
<li>配置合适的cluster-node-timeout值</li>
</ul>
<p><strong>问题3、命令的集群兼容性问题</strong></p>
<p>有关这个问题咱们已经探讨过了，当我们使用批处理的命令时，redis要求我们的key必须落在相同的slot上，然后大量的key同时操作时，是无法完成的，所以客户端必须要对这样的数据进行处理，这些方案我们之前已经探讨过了，所以不再这个地方赘述了。</p>
<p><strong>问题4、lua和事务的问题</strong></p>
<p>lua和事务都是要保证原子性问题，如果你的key不在一个节点，那么是无法保证lua的执行和事务的特性的，所以在集群模式是没有办法执行lua和事务的</p>
<p><strong>那我们到底是集群还是主从</strong></p>
<p>单体Redis（主从Redis）已经能达到万级别的QPS，并且也具备很强的高可用特性。如果主从能满足业务需求的情况下，所以如果不是在万不得已的情况下，尽量不搭建Redis集群</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>主从</tag>
        <tag>分片</tag>
        <tag>集群</tag>
        <tag>redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Web 前端</title>
    <url>/2024/09/09/web-frontend/</url>
    <content><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p><strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage </p>
<p>结构：HTML</p>
<p><a href="https://www.runoob.com/html/html-tutorial.html">HTML 教程 | 菜鸟教程 (runoob.com)</a> </p>
<p><a href="https://zh.wikipedia.org/wiki/HTML">HTML - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">HTML（超文本标记语言） | MDN (mozilla.org)</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926154402465.png" alt="image-20240926154402465"></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="基础标签"><a href="#基础标签" class="headerlink" title="基础标签"></a>基础标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926165557803.png" alt="image-20240926165557803"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926170603004.png" alt="image-20240926170603004"></p>
<h3 id="图片，音视频标签"><a href="#图片，音视频标签" class="headerlink" title="图片，音视频标签"></a>图片，音视频标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926170628097.png" alt="image-20240926170628097"></p>
<p>height weight 有 px 和百分比两种写法 src路径</p>
<p>URL 统一资源定位符 ../ 代表上一级目录 </p>
<h3 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926171504599.png" alt="image-20240926171504599"></p>
<p>a href=”url” </p>
<h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926171804215.png" alt="image-20240926171804215"></p>
<h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926171833199.png" alt="image-20240926171833199"></p>
<p>边框宽度+空白区间宽度</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926172249995.png" alt="image-20240926172249995"></p>
<h3 id="布局标签"><a href="#布局标签" class="headerlink" title="布局标签"></a>布局标签</h3><div></div>


<p>div块级标签，占一整行</p>
<p>span 只占据自己的空间</p>
<h3 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926193335810.png" alt="image-20240926193335810"></p>
<p>提交表单：方式get/post </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926193711640.png" alt="image-20240926193711640"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926194217797.png" alt="image-20240926194217797"></p>
<p><strong>点击框外文本就能让框处于被选中的状态</strong>：</p>
<p>如果要随着表单一起提交，就要起一个name</p>
<p>用<strong>label</strong>标签把用户名包裹起来，给输入框起一个唯一的id, label for “id” </p>
<p><strong>radio</strong>：单选按钮，让其name相同达到互斥效果，给他赋值value让服务器接收到有效信息</p>
<p>hidden 修改商品信息，id隐藏在表单里面,提交表单会上传</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928193146331.png" alt="image-20240928193146331"></p>
<p>submit reset button 如果要指定按钮名字 value</p>
<select>
    <option>123</option>
     <option>4567</option>
</select>


<p>textarea cols支持的列数 rows支持的行数</p>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>表现：CSS</p>
<p><a href="https://www.runoob.com/css/css-tutorial.html">CSS 教程 | 菜鸟教程 (runoob.com)</a> </p>
<p><a href="https://zh.wikipedia.org/wiki/CSS">CSS - 维基百科，自由的百科全书 (wikipedia.org) </a> </p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS：层叠样式表 | MDN (mozilla.org)</a></p>
<h2 id="导入HTML"><a href="#导入HTML" class="headerlink" title="导入HTML"></a>导入HTML</h2><p>在head标签中导入</p>
<p>内联，内部，外部</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926201958367.png" alt="image-20240926201958367"></p>
<p><code>&lt;link href=&quot;css路径&quot; rel=&quot;stylesheet&quot;&gt;</code></p>
<h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926202419738.png" alt="image-20240926202419738"></p>
<p>name唯一 class不唯一</p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>行为：javascript</p>
<p>什么是JS？</p>
<p><a href="https://www.runoob.com/js/js-tutorial.html">JavaScript 教程 | 菜鸟教程 (runoob.com)</a></p>
<p><a href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript">JavaScript——动态客户端脚本语言 - 学习 Web 开发 | MDN (mozilla.org)</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926202813408.png" alt="image-20240926202813408"></p>
<p>改变HTML 交互性</p>
<p>引入方式：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929131050714.png" alt="image-20240929131050714"></p>
<p>内部脚本,一般放在body下面</p>
<p>外部脚本, 不支持自闭合</p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul>
<li>区分大小写，分号可有可无</li>
<li>单行，多行注释</li>
<li>大括号表示代码块</li>
</ul>
<h3 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h3><ul>
<li>(window.)alert()弹出警告</li>
<li>document.write() 写入HTML页面</li>
<li>console.log() 写入浏览器控制台</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>var是变量，弱类型语言，可以存放不同类型的值</p>
<p>作用域：全局变量而且可以重复声明定义</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929132314244.png" alt="image-20240929132314244"></p>
<p>let 作用域只在代码块之内 局部变量 不可重复定义</p>
<p>const 常量</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929132717037.png" alt="image-20240929132717037"></p>
<p>number boolean string 空（null）默认初始值（undefined）</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929132954368.png" alt="image-20240929132954368"></p>
<p>全等于(===) 类型不一样返回false，更加严格</p>
<p>等于（==）判断类型是否一样，如果不一样则转换类型，然后才比较值</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>转为number：</p>
<ul>
<li>string<ul>
<li><code>var str = &quot;20&quot;   parseInt(str)</code></li>
<li>字面值转为数字，如果字面值不是数字，转为NaN</li>
</ul>
</li>
<li>boolean <ul>
<li>true-&gt;1 false-&gt;0</li>
</ul>
</li>
</ul>
<p>转成boolean</p>
<ul>
<li>number： 0和NaN转为false</li>
<li>string：空字符串转为false</li>
<li>null&amp;undefined：转为false</li>
</ul>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>if  switch  while  do while  </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929135023368.png" alt="image-20240929135023368"></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>关键字：function</li>
<li>返回值类型：不需要，直接return</li>
<li>参数列表：不用写参数类型</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929135258270.png" alt="image-20240929135258270"></p>
<p>实际调用可以有很多实参，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929135611640.png" alt="image-20240929135611640"></p>
<p>add(1,2) = 3</p>
<p>add(1)  = NaN</p>
<h2 id="JavaScript-对象"><a href="#JavaScript-对象" class="headerlink" title="JavaScript 对象"></a>JavaScript 对象</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">//访问数组</span></span><br><span class="line">arr1[<span class="number">1</span>]=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>与java不同，js的数组是集合，变长，变类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//变长</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr3[<span class="number">5</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//索引为5的元素被赋值为10, 中间空出来的是undefined</span></span><br><span class="line"><span class="comment">//变类型</span></span><br><span class="line">arr3[<span class="number">10</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>长度：length</p>
<p>增：push(10) 加入值为10的元素</p>
<p>删：splice(0,3)从索引0开始，删除3个元素</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>length:长度</p>
<p>trim(): 去除字符串两端的空白字符</p>
<p>charAt(i):返回指定位置的字符</p>
<p>indexOf(c) 返回字符第一次出现的索引</p>
<h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;ZS&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">23</span>,</span><br><span class="line">    <span class="attr">eat</span>:<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;eat&quot;</span>+a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">eat</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>浏览器对象模型</p>
<p>Navigator Screen</p>
<h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><ul>
<li>窗口对象，使用window获取</li>
<li><code>alert()</code> 警告</li>
<li><code>confirm(&quot;对话框内容&quot;)</code> 确认/取消对话框<ul>
<li>有返回值，返回的是一个boolean</li>
</ul>
</li>
<li><code>setInterval(function,ms)</code> 定时器，循环执行function</li>
<li><code>setTimeout(function,ms)</code> 倒计时，只有一次</li>
</ul>
<p>根据变化的数字，产生固定个数的值，取模</p>
<h5 id="history"><a href="#history" class="headerlink" title="history"></a>history</h5><ul>
<li><p>通过window调取，window可省略</p>
</li>
<li><p><code>history.back()</code>加载前一个URL</p>
</li>
<li><p><code>history.forward()</code>加载下一个URL</p>
</li>
</ul>
<h5 id="location"><a href="#location" class="headerlink" title="location"></a>location</h5><ul>
<li>通过window调取，可省略</li>
<li><code>location.href</code> 设置当前的URL，可以实现跳转</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929143103867.png" alt="image-20240929143103867"></p>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>文档对象模型 W3C指定的XML HTML的规则</p>
<p>查文档</p>
<h4 id="document"><a href="#document" class="headerlink" title="document"></a>document</h4><h5 id="获取Element"><a href="#获取Element" class="headerlink" title="获取Element"></a>获取Element</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929143507450.png" alt="image-20240929143507450"></p>
<ul>
<li>id: 每个元素唯一的id</li>
<li>tagName: 标签名</li>
<li>class: 同类的，一个元素可以有多个类，一个类可以有多个元素</li>
<li>name: 用于radio checkbox 和 form表单 提交将输入的值发送</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;submit.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">value</span>=<span class="string">&quot;apple&quot;</span>&gt;</span> Apple</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">value</span>=<span class="string">&quot;banana&quot;</span>&gt;</span> Banana</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">value</span>=<span class="string">&quot;orange&quot;</span>&gt;</span> Orange</span><br></pre></td></tr></table></figure>

<h5 id="element通用方法"><a href="#element通用方法" class="headerlink" title="element通用方法"></a>element通用方法</h5><ul>
<li><p>element.<strong>style</strong> 获取style标签</p>
<ul>
<li>element.style.color = “red” 设置元素的style中 color属性为red</li>
<li></li>
</ul>
</li>
<li><p>element.<strong>innerHTML</strong> 改变两个标签内部的文本内容</p>
</li>
</ul>
<p>checkbox.<strong>checked</strong>=true 复选框设置为勾选  </p>
<h2 id="事件监听-EventListener"><a href="#事件监听-EventListener" class="headerlink" title="事件监听 EventListener"></a>事件监听 EventListener</h2><p>事件：发生在HTML元素上的事件，比如按钮被电击，鼠标移到元素之上，按下键盘按键</p>
<p>监听：侦测到事件，执行某些代码</p>
<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><h4 id="HTML标签的属性绑定"><a href="#HTML标签的属性绑定" class="headerlink" title="HTML标签的属性绑定"></a>HTML标签的属性绑定</h4><p>耦合度太高</p>
<h4 id="DOM元素属性绑定"><a href="#DOM元素属性绑定" class="headerlink" title="DOM元素属性绑定"></a>DOM元素属性绑定</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929145651893.png" alt="image-20240929145651893"></p>
<p>属性和函数绑定</p>
<h3 id="常见的事件"><a href="#常见的事件" class="headerlink" title="常见的事件"></a>常见的事件</h3><p><code>onblur</code>: 失去焦点</p>
<p><code>onfocus</code>: 获得焦点</p>
<p><code>onchange</code>:文本改变</p>
<p><code>onkeydown</code>: 按键</p>
<p><code>onmouseover</code>: 鼠标移动到指定对象上</p>
<p><code>onmouseout</code>：鼠标离开指定对象</p>
<p><code>onsubmit</code>: 表单验证，绑定的函数要有返回值，如果返回true则表单会被提交</p>
<p>核心宗旨：把一些交互逻辑更多地放到浏览器这边，减少服务端的压力</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929152143546.png" alt="image-20240929152143546"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929153455050.png" alt="image-20240929153455050"></p>
<p>绑定函数和事件</p>
<h1 id="Regex"><a href="#Regex" class="headerlink" title="Regex"></a>Regex</h1><p><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a href="https://www.runoob.com/regexp/regexp-tutorial.html">正则表达式 – 教程 | 菜鸟教程 (runoob.com)</a></p>
<p><a href="https://regex101.com/">regex101: build, test, and debug regex</a> </p>
<p><strong>正则表达式（Regular Expression, regex）</strong>是一种用来描述和匹配字符串模式的工具，其原理基于形式语言和自动机理论。以下是正则表达式的主要原理和工作机制：</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ol>
<li><strong>字符匹配</strong>：正则表达式中的普通字符（如 <code>a</code>, <code>b</code>, <code>1</code>, <code>2</code>）直接匹配自身。例如，正则表达式 <code>abc</code> 将匹配字符串 “abc”。</li>
<li><strong>元字符和转义</strong>：元字符（如 <code>.</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>|</code>、<code>()</code>、<code>[]</code>、<code>&#123;&#125;</code>）有特殊含义。若要匹配这些字符本身，需要使用转义字符 <code>\</code>。例如，<code>\.</code> 匹配字符 <code>.</code>。</li>
<li><strong>字符类</strong>：使用方括号 <code>[]</code> 定义字符类，可以匹配其中任意一个字符。例如，<code>[abc]</code> 匹配 <code>a</code>、<code>b</code> 或 <code>c</code>。</li>
<li><strong>预定义字符类</strong>：常见的预定义字符类包括 <code>\d</code>（数字），<code>\w</code>（字母、数字或下划线），<code>\s</code>（空白字符），等价于 <code>[0-9]</code>、<code>[a-zA-Z0-9_]</code>、<code>[ \t\n\r\f\v]</code>。</li>
<li><strong>量词</strong>：量词用来指定匹配次数。例如，<code>*</code>（0 次或多次），<code>+</code>（1 次或多次），<code>?</code>（0 次或 1 次），<code>&#123;n&#125;</code>（恰好 n 次），<code>&#123;n,&#125;</code>（至少 n 次），<code>&#123;n,m&#125;</code>（n 到 m 次）。</li>
<li><strong>边界匹配</strong>：边界匹配符包括 <code>^</code>（行首），<code>$</code>（行尾），<code>\b</code>（单词边界），<code>\B</code>（非单词边界）。</li>
<li><strong>分组和捕获</strong>：使用圆括号 <code>()</code> 将正则表达式的一部分进行分组，可以进行捕获以便后续引用。例如，<code>(\d&#123;3&#125;)-(\d&#123;3&#125;)</code> 匹配 “123-456” 并捕获 “123” 和 “456”。</li>
<li><strong>选择和替代</strong>：使用管道符 <code>|</code> 表示选择，匹配左边或右边的表达式。例如，<code>a|b</code> 匹配 <code>a</code> 或 <code>b</code>。</li>
</ol>
<h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><ol>
<li><strong>编译</strong>：正则表达式首先被编译成一种内部表示形式。这个编译过程将解析正则表达式字符串，并将其转换为一个有限状态自动机（Finite State Machine, FSM）。</li>
<li><strong>匹配过程</strong>：<ul>
<li><strong>DFA（确定性有限自动机）</strong>：DFA 每个状态都有确定的转换，即每一个输入字符都会导致状态的唯一确定转换。DFA 的匹配过程效率高，但状态数可能较多。</li>
<li><strong>NFA（非确定性有限自动机）</strong>：NFA 允许从一个状态可以有多条转换边，匹配过程可能需要回溯。NFA 的构建比较简单，但匹配过程效率可能较低。</li>
</ul>
</li>
<li><strong>引擎</strong>：<ul>
<li><strong>NFA 引擎</strong>：基于回溯算法，尝试每一种可能的路径，直到找到匹配或失败。大多数现代正则表达式引擎（如 Perl、Python、JavaScript 等）使用 NFA 引擎。</li>
<li><strong>DFA 引擎</strong>：不使用回溯，直接通过状态转换进行匹配，通常速度较快，但实现较为复杂且内存消耗较大。</li>
</ul>
</li>
</ol>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li><strong>字符串查找和替换</strong>：在文本编辑器、IDE 等工具中，通过正则表达式进行复杂的搜索和替换操作。</li>
<li><strong>数据验证</strong>：验证输入数据的格式，如邮箱地址、电话号码等。</li>
<li><strong>文本处理</strong>：如日志解析、数据抽取等。</li>
</ul>
<p>通过对正则表达式的理解和应用，可以高效地进行字符串处理和模式匹配，极大地提高文本处理的灵活性和效率。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929153836955-1727921863704-1.png" alt="image-20240929153836955"></p>
<p>JS 正则表达式对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;^\\w&#123;6,12&#125;$&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^\w&#123;6,12&#125;$/</span></span><br><span class="line"></span><br><span class="line">regex.<span class="title function_">test</span>(str) <span class="comment">//正则表达式</span></span><br></pre></td></tr></table></figure>



<ul>
<li><code>\d</code>: 数字</li>
<li><code>\D</code>: 除了数字以外的字符</li>
<li><code>\s</code>:空白字符</li>
<li><code>\w</code>:字母+下划线+数字</li>
<li><code>[ ]</code>匹配单个字符 字符集合</li>
<li><code>[^1-3A-Z]</code>匹配一个除了1-3和大写字母的字符</li>
<li>尖角^只有在方框内部才是取反的意思。在外部表示匹配开头，<code>^abc</code>表示作为开头的abc，<code>BCD$</code>就是作为结尾的BCD<ul>
<li>匹配总共需要三个参数：要处理的字符串，匹配模式和正则表达式本身，可以看出处理的文本本身就是一个字符串。</li>
<li>如果没有多行匹配，^和$只会作用于<strong>整个文本</strong>的开头和结尾</li>
<li>multiline模式会匹配每一行</li>
</ul>
</li>
<li><code>/...../g</code>表示不要搜索一次就返回，去掉只显示第一个匹配的</li>
<li><code>/...../m</code>表示多行匹配</li>
<li><code>/...../i</code>表示忽略大小写</li>
<li><code>\b</code>:表示单词边界 <code>\bin</code>表示in在单词开头 <code>in\b</code>表示in在单词末尾</li>
<li><code>\B</code>:表示单词内部 <code>\Bin\B</code>表示in在单词中间 <code>\Bin</code>表示匹配前面有东西的in</li>
<li><code>.$</code>表示属于结尾的任意字符</li>
<li><code>\.$</code>表示属于结尾的点号</li>
</ul>
<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><ul>
<li><code>at+</code> atttt atttt 加号表示a t(重复一次或者多次)</li>
<li><code>at*</code> atttt atttt 星号表示a t(重复0次或者多次)</li>
<li><code>at?</code> at a 问号表示零次或者一次</li>
<li><code>at&#123;3,5&#125;</code> attt 表示t重复了3到5次</li>
<li><code>at&#123;3,&#125;</code> attt 表示t重复了3次以上 </li>
</ul>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul>
<li><code>(at)&#123;3&#125;</code> at整体重复了3次</li>
<li><code>(P|p)iece</code> Piece和piece</li>
<li><code>(d&#123;4&#125;)[-/_.](d&#123;1,2&#125;)[-/_.](d&#123;1,2&#125;)</code> 匹配年月日并且分成三组$1$2$3分别代表123组可以使用替换</li>
<li>如果不想分其中一个组<code>?:</code>表示仅代表一个整体不参与分组</li>
</ul>
<p>在 Java 的正则表达式中，如果你想忽略大小写匹配，可以使用以下几种方法：</p>
<h2 id="Java中忽略大小写的使用"><a href="#Java中忽略大小写的使用" class="headerlink" title="Java中忽略大小写的使用"></a>Java中忽略大小写的使用</h2><h3 id="使用-Pattern-CASE-INSENSITIVE-标志"><a href="#使用-Pattern-CASE-INSENSITIVE-标志" class="headerlink" title="使用 Pattern.CASE_INSENSITIVE 标志"></a>使用 <code>Pattern.CASE_INSENSITIVE</code> 标志</h3><p>通过调用 <code>Pattern.compile</code> 方法并传递 <code>Pattern.CASE_INSENSITIVE</code> 标志，可以忽略大小写。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译正则表达式时指定忽略大小写</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex, Pattern.CASE_INSENSITIVE);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(text);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-i-内联标志"><a href="#使用-i-内联标志" class="headerlink" title="使用 (?i) 内联标志"></a>使用 <code>(?i)</code> 内联标志</h3><p>在正则表达式的开头加上 <code>(?i)</code> 也可以忽略大小写。这是内联标志，不需要使用 <code>Pattern.compile</code>。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;(?i)hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (text.matches(regex)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>Pattern.CASE_INSENSITIVE</code></strong> 标志是在编译正则表达式时通过代码设置忽略大小写。</li>
<li><strong><code>(?i)</code></strong> 是在正则表达式内部直接指定忽略大小写，简单方便。</li>
</ul>
<h1 id="AJAX-JSON-个人笔记-Java-Web-服务端-pdf"><a href="#AJAX-JSON-个人笔记-Java-Web-服务端-pdf" class="headerlink" title="[AJAX, JSON](./个人笔记/Java Web 服务端.pdf)"></a>[AJAX, JSON](./个人笔记/Java Web 服务端.pdf)</h1><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p><a href="https://cn.vuejs.org/">Vue.js - 渐进式 JavaScript 框架 | Vue.js (vuejs.org)</a></p>
<h2 id="优点、原理"><a href="#优点、原理" class="headerlink" title="优点、原理"></a>优点、原理</h2><ul>
<li>免除DOM操作，简化书写</li>
<li>基于MVVM思想，双向绑定数据，使view能够绑定model的数据，而不是model变了</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929223353641.png" alt="image-20240929223353641"></p>
<p>model: plain JavaScript Objects     view: 模板</p>
<p>model，也就是数据，通过vue实例绑定到view上，model一更新，view上也会立即更新，</p>
<p>view，模板，通过vue实例的domListener，监听发生的dom事件，比如输入，通过listener将model处的数据实时更新。</p>
<p>数据全存在vm上，view能看到vm所有的数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929231110532.png" alt="image-20240929231110532"></p>
<p>在之前的JSON案例中，填写表单时，表单数据是model，<strong>在提交的时候</strong>，还要用<strong>繁琐的dom操作</strong>获取输入框中的值再赋给model。vue能在输入的时候就赋值给对象，如果从服务器接收到数据也能实时更新。</p>
<h2 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h2><p><a href=".%5C%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%5CHTML%5Cindex.html">index.html</a></p>
<p><strong>Vue3</strong> </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hello-vue&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>//div元素 唯一id为hello-vue 归属于demo类</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span>//v-model双向绑定,这个view中的值是多少, vue实例中数据就是多少</span><br><span class="line">&#123;&#123; message &#125;&#125;//插值表达式。这是 Vue.js 的模板语法，用于将 Vue 实例中的数据绑定到页面上。</span><br><span class="line">			 //vue实例中的数据变化时,这里也跟着变化。</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">HelloVueApp</span>=&#123; <span class="comment">//此处创建了一个自定义JS对象</span></span></span><br><span class="line"><span class="language-javascript">	<span class="title function_">data</span>(<span class="params"></span>)&#123;<span class="comment">//data是一个无参的函数,返回值是一个对象，里面包含了model数据</span></span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">message</span>: <span class="string">&#x27;Hello,Vue!&#x27;</span><span class="comment">//数据初值是Hello,Vue!字符串</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">	&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">HelloVueApp</span>).<span class="title function_">mount</span>(<span class="string">&quot;#hello-vue&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="comment">//Vue.createApp() 方法用于创建一个 Vue 应用实例，参数是一个包含组件选项的对象（这里是 HelloVueApp）。</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//.mount(&#x27;#hello-vue&#x27;) 方法将 Vue 应用实例挂载到页面中具有 id=&quot;hello-vue&quot; 的 DOM 元素上。</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令是带有前缀 <strong>v-</strong> 的特殊属性，用于在模板中表达逻辑。</p>
<p><strong>v-bind</strong>: 动态绑定一个或多个特性，或一个组件 prop。将 Vue 实例的数据绑定到 HTML 元素的属性上</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>简写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-if</strong>: 条件渲染。根据表达式的值来条件性地渲染元素或组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;seen&quot;</span>&gt;</span>Now you see me<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-for</strong>: 列表渲染。 用于根据数组或对象的属性值来循环渲染元素或组件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.text &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">//v-for=迭代对象 相当于增强for循环 </span><br><span class="line">//key帮助 Vue 在渲染列表时识别每个元素的唯一性。</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">HelloVueApp</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">items</span>: [ <span class="comment">//items数组包含多个匿名对象，这些匿名对象id和text两个属性</span></span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;Item 1&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&#x27;Item 2&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">text</span>: <span class="string">&#x27;Item 3&#x27;</span> &#125;</span></span><br><span class="line"><span class="language-javascript">      ]</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">HelloVueApp</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-model</strong>: 实现表单数据双向绑定：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;edit me&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-on</strong>: 事件监听器。 用于在 HTML 元素上绑定事件监听器，使其能够触发 Vue 实例中的方法或函数。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>简写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-show</strong>: 用于根据表达式的值来条件性地显示或隐藏元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hello-vue&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;showMessage = !showMessage&quot;</span>&gt;</span>显示/隐藏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">&quot;showMessage&quot;</span>&gt;</span>Hello Vue!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">HelloVueApp</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">showMessage</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">HelloVueApp</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#hello-vue&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>v-on指令能够监听事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">v-<span class="attr">on</span>:click=<span class="string">&quot;methodName&quot;</span></span><br><span class="line">@click=<span class="string">&quot;methodName&quot;</span></span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;counter += 1&quot;</span>&gt;</span>增加 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> app = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">counter</span>: <span class="number">0</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(app).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="案例简化-JavaScript中的this指针与回调函数"><a href="#案例简化-JavaScript中的this指针与回调函数" class="headerlink" title="案例简化-JavaScript中的this指针与回调函数"></a>案例简化-JavaScript中的this指针与回调函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//script</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">VueApp</span> = &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="attr">brands</span>:[]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">        axios.<span class="title function_">get</span>(<span class="string">&quot;http://localhost:8080/selectAllServlet&quot;</span>)</span><br><span class="line">         .<span class="title function_">then</span>(<span class="function">(<span class="params">resp</span>)=&gt;</span>&#123;<span class="variable language_">this</span>.<span class="property">brands</span> = resp.<span class="property">data</span>;&#125;);</span><br><span class="line">        <span class="comment">//brands是集合,用v-for遍历</span></span><br><span class="line">        <span class="comment">//回调函数是作为参数传递给另一个函数的函数，目的是在特定事件或条件发生时被调用。它通常用于异步操作、事件处理和在特定时机执行代码。箭头函数不会根据调用者创建this，只会寻找域中含有的this指针，mounted的this就是Vue实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">    	<span class="attr">show</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&quot;clicked&quot;</span>);<span class="comment">//跟提交的按钮绑定</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">createVueApp</span>(<span class="title class_">VueApp</span>).<span class="title function_">mount</span>(#app)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href=".%5C%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%5CHTML%5CanoymousThis.html">JavaScript中的this指针</a> 另外一种是在mounted中先定义一个var _this = this，这样_this 一定指代的是Vue实例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>单个复选框：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checked&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>多个复选框：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;runoob&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Runoob&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;runoob&quot;</span>&gt;</span>Runoob<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;google&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Google&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;google&quot;</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;taobao&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Taobao&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;taobao&quot;</span>&gt;</span>taobao<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>选择的值为: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> app = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      checked : <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">checkedNames</span>: []</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(app).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h1><p><a href="https://element.eleme.cn/#/zh-CN">Element - 网站快速成型工具</a></p>
<p>Vue组件库，可以快速构建网页</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930212139910.png" alt="image-20240930212139910"></p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930224145033.png" alt="image-20240930224145033"></p>
<h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930224317166.png" alt="image-20240930224317166"></p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930224538591.png" alt="image-20240930224538591"></p>
<p>对话框+表单</p>
]]></content>
      <categories>
        <category>web development</category>
      </categories>
      <tags>
        <tag>regex</tag>
        <tag>vue</tag>
        <tag>javascript</tag>
        <tag>html</tag>
        <tag>css</tag>
        <tag>element-ui</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Netty 的 RPC 框架</title>
    <url>/2025/02/03/rpc-interpretation/</url>
    <content><![CDATA[<h1 id="基于-Netty-的-RPC-框架"><a href="#基于-Netty-的-RPC-框架" class="headerlink" title="基于 Netty 的 RPC 框架"></a>基于 Netty 的 RPC 框架</h1><p>实现要点： </p>
<ul>
<li>实现了 Netty <a href="#%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6">心跳机制</a>，保持连接。客户端<a href="#%E6%8C%87%E6%95%B0%E9%80%80%E9%81%BF">指数退避</a>重试连接，服务端用线程池处理请求。可选 HTTP 和 Socket。</li>
<li>实现了自定义 RPC <a href="#protocol">通信协议</a>，<a href="#codec">自定义编解码器和拆包解码器</a>解决粘包和半包，实现了 Kryo 等5种<a href="#serialization">序列化方式</a>。</li>
<li><a href="#center">注册中心</a>支持 Nacos 与 Zookeeper，服务发现支持本地缓存、实时监听。除利用健康检查机制外，下线服务还会主动通知注册中心注销，实现优雅下线。支持一致性哈希等3种<a href="#loadbalance">负载均衡</a>算法。</li>
<li>集成 SpringBoot。通过<a href="#annotation">自定义注解</a>，提供者自动扫描并注册服务 Bean，消费者自动注入<a href="#proxy">代理对象</a>。自定义 starter 实现<a href="#autoconfig">自动装配</a>。</li>
<li>参考 Dubbo 实现 <a href="#spi">SPI</a>，支持<a href="#spi1">序列化</a>、<a href="#spi2">服务发现</a>等的动态扩展，实现与类型解耦的<a href="#cache">单例缓存</a>，减少大量冗余的对象创建。</li>
</ul>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/项目架构图.png" alt="项目架构图" style="zoom:67%;" />

<p><code>consumer</code>模块：服务的消费者，依赖于 <code>rpc-client-spring-boot-starter</code> 模块；</p>
<p><code>provider-api</code>模块：服务提供者暴露的API；</p>
<p><code>provider</code>模块：服务的提供者，依赖于 <code>rpc-server-spring-boot-starter</code> 模块：</p>
<p><code>rpc-client-spring-boot</code>模块：rpc 客户端模块，封装客户端发起的请求过程，提供服务发现、动态代理，网络通信等功能；</p>
<p><code>rpc-client-spring-boot-stater</code>模块：是<code>rpc-client-spring-boot</code>的stater模块，负责引入相应依赖进行自动配置；</p>
<p><code>rpc-framework-core</code>模块：是rpc核心依赖，提供负载均衡、服务注册发现、消息协议、消息编码解码、序列化算法；</p>
<p><code>rpc-server-spring-boot</code>模块：rpc 服务端模块，负责启动服务，接受和处理RPC请求，提供服务发布、反射调用等功能；</p>
<p><code>rpc-server-spring-boot-stater</code>模块：是<code>rpc-server-spring-boot</code>的stater模块，负责引入相应依赖进行自动配置；</p>
<span id="more"></span>

<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC 又称远程过程调用（Remote Procedure Call），用于解决分布式系统中服务之间的调用问题。通俗地讲，就是开发者能够像调用本地方法一样调用远程的服务。一个最基本的RPC框架的基本架构如下图所示：</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/简单RPC架构图.png" alt="简单RPC架构图" style="zoom: 45%;" />

<p>RPC框架一般必须包含三个组件，分别是<strong>客户端、服务端</strong>以及<strong>注册中心</strong>，一次完整的 RPC 调用流程一般为：</p>
<ol>
<li>服务端启动服务后，将他提供的服务列表发布到注册中心（服务注册）；</li>
<li>客户端会向注册中心订阅相关的服务地址（服务订阅）；</li>
<li>客户端通常会利用本地代理模块 Proxy 向服务端发起远程过程调用，Proxy 负责将调用的方法、参数等数据转化为网络字节流；</li>
<li>客户端从服务列表中根据负载均衡策略选择一个服务地址，并将数据通过网络发送给服务端；</li>
<li>服务端得到数据后，调用对应的服务，然后将结果通过网络返回给客户端。</li>
</ol>
<h2 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h2><p>成熟的 RPC 框架一般会提供四种调用方式，分别为同步 Sync、异步 Future、回调 Callback和单向 Oneway。RPC 框架的性能和吞吐量与合理使用调用方式是息息相关的，下面我们逐一介绍下四种调用方式的实现原理。</p>
<ul>
<li>Sync 同步调用。客户端线程发起 RPC 调用后，当前线程会一直阻塞，直至服务端返回结果或者处理超时异常。Sync 同步调用一般是 RPC 框架默认的调用方式，为了保证系统可用性，客户端设置合理的超时时间是非常重要的。虽说 Sync 是同步调用，但是客户端线程和服务端线程并不是同一个线程，实际在 RPC 框架内部还是异步处理的。Sync 同步调用的过程如下图所示。</li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Sync同步调用.png" alt="Sync同步调用" style="zoom:67%;" />

<ul>
<li>Future 异步调用。客户端发起调用后不会再阻塞等待，而是拿到 RPC 框架返回的 Future 对象，调用结果会被服务端缓存，客户端自行决定后续何时获取返回结果。当客户端主动获取结果时，该过程是阻塞等待的。Future 异步调用过程如下图所示。</li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Future异步调用.png" alt="Future异步调用" style="zoom:67%;" />

<ul>
<li>Callback 回调调用。如下图所示，客户端发起调用时，将 Callback 对象传递给 RPC 框架，无须同步等待返回结果，直接返回。当获取到服务端响应结果或者超时异常后，再执行用户注册的 Callback 回调。所以 Callback 接口一般包含 onResponse 和 onException 两个方法，分别对应成功返回和异常返回两种情况。</li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Callback回调调用.png" alt="Callback回调调用" style="zoom:67%;" />

<ul>
<li>Oneway 单向调用。客户端发起请求之后直接返回，忽略返回结果。Oneway 方式是最简单的，具体调用过程如下图所示。</li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Onway单向调用.png" alt="Onway单向调用" style="zoom:67%;" />

<p>四种调用方式都各有优缺点，很难说异步方式一定会比同步方式效果好，在不用的业务场景可以按需选取更合适的调用方式。</p>
<p><strong>这是一个同步调用的 RPC 框架。</strong> </p>
<h2 id="framework-core"><a href="#framework-core" class="headerlink" title="framework-core"></a><mark>framework-core</mark></h2><p><strong>config</strong> 线程池配置类 <strong>factory</strong> 单例工厂和线程池工厂</p>
<p>服务消费方包装好 <code>RpcRequest</code>，做完服务发现之后发送网络请求，使用 <code>Promise</code>来进行异步请求的同步等待 <code>await(timeout)</code>与收到 <code>RpcResponse</code>之后的 <code>setSuccess(rpcMessage)</code>。</p>
<p>服务提供方收到 <code>RpcRequest</code>，根据服务名称在本地注册中心找到实现类，执行调用，返回结果封装在 <code>RpcResponse</code>内。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250423123418951.png" alt="责任链"></p>
<h3 id="common（消息体定义、注册信息）"><a href="#common（消息体定义、注册信息）" class="headerlink" title="common（消息体定义、注册信息）"></a><span id="protocol">common（消息体定义、注册信息）</span></h3><p>包括消息体的三种类型，以及注册中心提供的服务信息 <code>ServiceInfo</code>。</p>
<ul>
<li><code>RpcRequest</code> 包含 服务名称（服务名+版本）、方法名、参数类型、参数</li>
<li><code>RpcResponse</code> 包含 返回值、发生异常时的异常信息</li>
<li><code>HeartBeatMessage</code> 包含字符串（PING/PONG）</li>
<li><code>ServiceInfo</code> 应用名称、服务名称、版本号、服务提供方主机地址、端口号。</li>
</ul>
<h3 id="utils（ServiceUtil）"><a href="#utils（ServiceUtil）" class="headerlink" title="utils（ServiceUtil）"></a>utils（ServiceUtil）</h3><p><code>String serviceKey(String serviceName, String version)</code> 根据服务名称和版本号生成注册服务的key</p>
<p><code>Map toMap(ServiceInfo serviceInfo)</code> 将ServiceInfo转换成Map 用于nacos注册</p>
<p><code>ServiceInfo toServiceInfo（Map map）</code> 将Map转换成ServiceInfo 用于nacos发现</p>
<blockquote>
<p>nacos instance 的metadata是一个map，键和值都是字符串。</p>
<p>port是 int 类型，Gson 解析出 8080 会变成 Number 类型 8080.0 变成Double，因此要把8080转成字符串。</p>
<p><code>map.put(&quot;port&quot;, serviceInfo.getPort().toString());</code> </p>
<p><code>map.put(&quot;port&quot;, Integer.parseInt(map.getOrDefault(&quot;port&quot;, &quot;0&quot;).toString()))</code> </p>
</blockquote>
<h3 id="enums（消息头参数）"><a href="#enums（消息头参数）" class="headerlink" title="enums（消息头参数）"></a>enums（消息头参数）</h3><ul>
<li><code>MessageStatus</code> <code>code</code>=01 代表成功/失败</li>
<li><code>MessageType</code> <code>type</code>=01表示正常的请求与响应 23表示心跳的ping 与pong</li>
<li><code>SerializationType</code>  <code>type</code> = 0-4 分别对应5种序列化算法，可以根据输入的序列化算法名称匹配对应的序列化方式，默认为Hessian，也可根据type匹配。</li>
</ul>
<h3 id="protocol-constant（协议定义相关）"><a href="#protocol-constant（协议定义相关）" class="headerlink" title="protocol/constant（协议定义相关）"></a>protocol/constant（协议定义相关）</h3><p>既然 RPC 是远程调用，必然离不开网络通信协议。客户端在向服务端发起调用之前，需要考虑采用何种方式将调用信息进行编码，并传输到服务端。因为 RPC 框架对性能有非常高的要求，所以通信协议应该越简单越好，这样可以减少编解码的性能损耗。RPC 框架可以基于不同的协议实现，大部分主流 RPC 框架会选择 TCP、HTTP 协议，出名的 gRPC 框架使用的则是 HTTP2。TCP、HTTP、HTTP2 都是稳定可靠的，但其实使用 UDP 协议也是可以的，具体看业务使用的场景。成熟的 RPC 框架能够支持多种协议，例如阿里开源的 Dubbo 框架被很多互联网公司广泛使用，其中可插拔的协议支持是 Dubbo 的一大特色，这样不仅可以给开发者提供多种不同的选择，而且为接入异构系统提供了便利。</p>
<ul>
<li><code>RpcMessage</code> 封装好的 Rpc 协议信息<ul>
<li><code>MessageHeader header</code> 消息头</li>
<li><code>Object body</code> 携带的消息内容（可能是 <code>RpcRequest</code>，<code>RpcResponse</code>，也可能是心跳 <code>HeartBeatMessage</code>）</li>
</ul>
</li>
<li><code>MessageHeader</code>  消息头<ul>
<li>4B 魔数 1B 版本号  均有<strong>默认填充</strong> </li>
<li>1B <code>serializerType</code></li>
<li>1B <code>messageType</code> </li>
<li>1B <code>messageStatus</code> </li>
<li>4B <code>serialNumber</code> 有一个原子变量，每get一次就自增</li>
<li>4B <code>length</code> </li>
<li><strong>Builder 建造者模式</strong> 链式构造 build</li>
</ul>
</li>
</ul>
<blockquote>
<p>设计模式：建造者模式</p>
<ul>
<li><strong>解决复杂对象的构造问题</strong>：当一个对象需要多个参数（尤其包含大量可选参数）时，传统构造方法会变得臃肿且难以维护。</li>
<li><strong>避免“重叠构造器”反模式</strong>：无需编写多个不同参数组合的构造函数。</li>
<li><strong>防止对象的不一致状态</strong>：确保对象在构造完成后处于完整且一致的状态。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">优势</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>参数灵活</strong></td>
<td align="left">可选参数可自由组合，避免编写多个重载构造函数。</td>
</tr>
<tr>
<td align="left"><strong>代码可读性高</strong></td>
<td align="left">链式调用清晰表达参数含义（如 <code>.age(30).email(&quot;...&quot;)</code>）。</td>
</tr>
<tr>
<td align="left"><strong>对象状态一致性</strong></td>
<td align="left">通过 <code>build()</code> 方法统一校验参数，确保对象构造完成后合法且完整。</td>
</tr>
<tr>
<td align="left"><strong>与不可变对象兼容</strong></td>
<td align="left">适合构建不可变（<code>final</code>）对象，所有参数在构造时一次性设置。</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="serialization（序列化相关）"><a href="#serialization（序列化相关）" class="headerlink" title="serialization（序列化相关）"></a><span id="serialization"><mark>serialization（序列化相关）</mark></span></h3><p>客户端和服务端在通信过程中需要传输哪些数据呢？这些数据又该如何编解码呢？如果采用 TCP 协议，你需要将调用的接口、方法、请求参数、调用属性等信息序列化成二进制字节流传递给服务提供方，服务端接收到数据后，再把二进制字节流反序列化得到调用信息，然后利用反射的原理调用对应方法，最后将返回结果、返回码、异常信息等返回给客户端。所谓序列化和反序列化就是将对象转换成二进制流以及将二进制流再转换成对象的过程。因为网络通信依赖于字节流，而且这些请求信息都是不确定的，所以一般会选用通用且高效的序列化算法。比较常用的序列化算法有 FastJson、Kryo、Hessian、Protobuf 等，这些第三方序列化算法都比 Java 原生的序列化操作都更加高效。Dubbo 支持多种序列化算法，并定义了 Serialization 接口规范，所有序列化算法扩展都必须实现该接口，其中默认使用的是 Hessian 序列化算法。</p>
<p>序列化对于远程调用的响应速度、吞吐量、网络带宽消耗等同样也起着至关重要的作用，是我们提升分布式系统性能的最关键因素之一。</p>
<p>判断一个编码框架的优劣主要从以下几个方面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 是否支持跨语言，支持语种是否丰富</span><br><span class="line">2. 编码后的码流</span><br><span class="line">3. 编解码的性能</span><br><span class="line">4. 类库是否小巧，API使用是否方便</span><br><span class="line">5. 使用者开发的工作量和难度。</span><br></pre></td></tr></table></figure>



<ul>
<li><code>Serialization</code> 接口，定义了 <code>serialize()</code>和 <code>deserialize()</code> 两个方法 共有5个实现（Gson、Kryo、JDK、Protostuff、Hessian）使用 SPI 标注，表示这个类是可扩展的（可插拔）</li>
<li><code>SerializationFactory</code> 工厂模式，使用工厂方法创建序列化实例。</li>
</ul>
<blockquote>
<p>设计模式：工厂模式</p>
<ul>
<li>提供了一种创建对象的方式，使得创建对象的过程与使用对象的过程分离。</li>
<li>工厂模式提供了一种创建对象的方式，而无需指定要创建的具体类。</li>
<li>通过使用工厂模式，可以将对象的创建逻辑封装在一个工厂类中，而不是在客户端代码中直接实例化对象，这样可以提高代码的可维护性和可扩展性。</li>
</ul>
</blockquote>
<p><strong>Gson</strong>：默认不支持class序列化，需要自己实现</p>
<p><strong>Kryo</strong>：Kryo 线程不安全，所以使用 ThreadLocal 保存 kryo 对象</p>
<p><strong>Protostuff</strong>：提前分配好 LinkedBuffer，避免每次进行序列化都需要重新分配 buffer 内存空间</p>
<p>序列化无需双方约定，只需要客户端规定好就可以，写入MessageHeader以后，双方的codec自己会根据对应字段选择相同的序列化/反序列化方式。</p>
<p>五种序列化算法的比较如下：</p>
<table>
<thead>
<tr>
<th>序列化算法</th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Kryo</strong></td>
<td>速度快，序列化后体积小</td>
<td>跨语言支持较复杂</td>
</tr>
<tr>
<td><strong>Hessian</strong></td>
<td>默认支持跨语言</td>
<td>较慢</td>
</tr>
<tr>
<td><strong>Protostuff</strong></td>
<td>速度快，基于protobuf</td>
<td>需静态编译</td>
</tr>
<tr>
<td><strong>Json</strong></td>
<td>使用方便</td>
<td>性能一般</td>
</tr>
<tr>
<td><strong>Jdk</strong></td>
<td>使用方便，可序列化所有类</td>
<td>速度慢，占空间</td>
</tr>
</tbody></table>
<p>性能对比图，单位为 nanos：</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/序列化性能对比.png" alt="序列化性能对比" style="zoom:100%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/序列化性能比较.png" alt="序列化性能比较图" style="zoom:100%;" />

<h3 id="exception（异常）"><a href="#exception（异常）" class="headerlink" title="exception（异常）"></a>exception（异常）</h3><p>定义了RPCException和SerializeException来封装框架的异常</p>
<h3 id="codec（编解码、粘包处理）"><a href="#codec（编解码、粘包处理）" class="headerlink" title="codec（编解码、粘包处理）"></a><span id="codec"><mark>codec（编解码、粘包处理）</mark></span></h3><p><code>MessageToByteEncoder&lt;T&gt;</code> 负责编码 <code>ByteToMessageDecoder</code> 负责解码</p>
<ul>
<li><p>在 Netty 的 Pipeline 中，通常将两者结合使用：</p>
<ol>
<li><code>LengthFieldBasedFrameDecoder</code>：解决粘包/半包， 提取完整帧。</li>
<li><code>MessageToMessageCodec</code>：拆分后的数据帧（如<code>ByteBuf</code>）与业务对象转换。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ch.pipeline()</span><br><span class="line">  <span class="comment">// 第一步：处理粘包/半包，输出完整ByteBuf帧</span></span><br><span class="line">  .addLast(<span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>))</span><br><span class="line">  <span class="comment">// 第二步：将ByteBuf解码为Java对象</span></span><br><span class="line">  .addLast(<span class="keyword">new</span> <span class="title class_">MyMessageCodec</span>())</span><br><span class="line">  <span class="comment">// 第三步：处理业务逻辑</span></span><br><span class="line">  .addLast(<span class="keyword">new</span> <span class="title class_">BusinessHandler</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>SharableRpcMessageCodec</code></p>
<ul>
<li>可共享的 Rpc 消息编码解码器，继承自 <code>MessageToMessageCodec&lt;ByteBuf, RpcMessage&gt;</code> 重写其 <code>encode(ctx, msg, out)</code> 与 <code>decode(ctx, msg, out)</code> 方法。使用此编解码器必须配合 <code>RpcFrameDecoder</code> 进行使用， 以保证得到完整的数据包。不同于 <code>io.netty.handler.codec.ByteToMessageCodec</code> 的编解码器，共享编解码器无需 保存 <code>ByteBuf</code> 的状态信息。</li>
<li>为了支持多线程共享，编解码器 Handler 应该是 <strong>无状态或线程安全</strong> 的。<code>@Sharable</code> 是 <strong>Netty 框架</strong>中一个重要的注解，用于标记 <code>ChannelHandler</code> 是否可以被多个 <code>Channel</code>（连接）<strong>安全共享</strong>。（默认情况下会为每一个Channel创建一个新的Handler实例，不能复用）<ul>
<li>仅当 <code>Handler</code> <strong>无状态</strong>或<strong>线程安全</strong>时，才应添加 <code>@Sharable</code>：</li>
<li><strong>统计类 Handler</strong>（如监控请求总数、连接数）。</li>
<li><strong>无状态 Handler</strong>（不保存任何与特定 <code>Channel</code> 相关的数据）。</li>
<li><strong>工具类 Handler</strong>（如日志记录、编解码器等）。</li>
</ul>
</li>
<li>入：<code>Bytebuf</code> -&gt; <code>RpcMessage</code> （解码）：先判断魔数，然后是版本号，之后是其余的字段，根据信息构造出消息头，然后根据消息类型反序列化消息体，rpc请求和响应的消息分别对应的是 <code>RpcRequest</code> 和 <code>RpcResponse</code>，心跳对应的是 <code>String</code> ，将这些信息拼成一个 <code>RpcMessage</code>，传递到下一个出站处理器</li>
<li>出：<code>RpcMessage</code>-&gt; <code>Bytebuf</code> （编码）：消息头发出时根据 <code>RpcMessage</code> 的消息头直接发送协议的对应字段，发到 <code>length</code> 以后暂停，将 <code>body</code> 序列化成为<code>byte</code> 数组，之后设置消息头的长度字段，然后将长度字段也写入，最后将消息体发出，传递到下一个出站处理器</li>
</ul>
</li>
<li><p><code>RpcFrameDecoder</code> </p>
</li>
<li><p>粘包：发送 abc def，接收 abcdef</p>
</li>
</ul>
<ul>
<li>原因<ul>
<li>应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）</li>
<li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包</li>
<li>Nagle 算法：会造成粘包</li>
</ul>
</li>
</ul>
<ul>
<li>半包：发送 abcdef，接收 abc def</li>
</ul>
<ul>
<li>原因<ul>
<li>应用层：接收方 ByteBuf 小于实际发送数据量</li>
<li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</li>
<li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li>
</ul>
</li>
</ul>
<ul>
<li>粘包拆包编码器，固定长度的帧解码器，通过约定用定长字节表示接下来数据的长度。非共享，保存 <code>ByteBuf</code> 的状态信息。继承自 <code>LengthFieldBasedFrameDecoder</code> </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RpcFrameDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">1024</span>, <span class="number">12</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxFrameLength    数据帧的最大长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lengthFieldOffset 长度域的偏移字节数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lengthFieldLength 长度域所占的字节数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RpcFrameDecoder</span><span class="params">(<span class="type">int</span> maxFrameLength, <span class="type">int</span> lengthFieldOffset, <span class="type">int</span> lengthFieldLength)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(maxFrameLength, lengthFieldOffset, lengthFieldLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解决方案</p>
<ul>
<li>短连接：发一次数据包建立一次连接，这样连接建立到连接断开之间就是一次消息边界，缺点是效率低；</li>
<li>固定长度：每一条消息采用固定长度，缺点是浪费空间；</li>
<li>分隔符：每一条消息采用分隔符，例如 \n ，缺点是需要转义；</li>
<li>消息长度+消息内容：每一条消息分为 header 和 body，header 中包含 body 的长度（推荐）；</li>
</ul>
</li>
<li><p>TCP 是无边界的字节流，考虑到 RPC 框架特性，排除了固定长度/分隔符/channel短连接，采用消息长度+消息体的模式。不同 <code>Channel</code>之间肯定会互相干扰，因此不能使用 <code>@Sharable</code> 注解</p>
</li>
</ul>
<h3 id="loadbalance（负载均衡）"><a href="#loadbalance（负载均衡）" class="headerlink" title="loadbalance（负载均衡）"></a><span id="loadbalance"><mark>loadbalance（负载均衡）</mark></span></h3><p>本项目实现了 Random、RoundRobin、ConsistentHash 三种负载均衡算法</p>
<p>在分布式系统中，服务提供者和服务消费者都会有多台节点，如何保证服务提供者所有节点的负载均衡呢？客户端在发起调用之前，需要感知有多少服务端节点可用，然后从中选取一个进行调用。客户端需要拿到服务端节点的状态信息，并根据不同的策略实现负载均衡算法。负载均衡策略是影响 RPC 框架吞吐量很重要的一个因素，下面我们介绍几种最常用的负载均衡策略。</p>
<ul>
<li>Round-Robin 轮询。Round-Robin 是最简单有效的负载均衡策略，并没有考虑服务端节点的实际负载水平，而是依次轮询服务端节点。</li>
<li>Weighted Round-Robin 权重轮询。对不同负载水平的服务端节点增加权重系数，这样可以通过权重系数降低性能较差或者配置较低的节点流量。权重系数可以根据服务端负载水平实时进行调整，使集群达到相对均衡的状态。</li>
<li>Least Connections 最少连接数。客户端根据服务端节点当前的连接数进行负载均衡，客户端会选择连接数最少的一台服务器进行调用。Least Connections 策略只是服务端其中一种维度，我们可以演化出最少请求数、CPU 利用率最低等其他维度的负载均衡方案。</li>
<li>Consistent Hash 一致性 Hash。目前主流推荐的负载均衡策略，Consistent Hash 是一种特殊的 Hash 算法，在服务端节点扩容或者下线时，尽可能保证客户端请求还是固定分配到同一台服务器节点。Consistent Hash 算法是采用哈希环来实现的，通过 Hash 函数将对象和服务器节点放置在哈希环上，一般来说服务器可以选择 IP + Port 进行 Hash，然后为对象选择对应的服务器节点，在哈希环中顺时针查找距离对象 Hash 值最近的服务器节点。</li>
</ul>
<p>此外，负载均衡算法可以是多种多样的，客户端可以记录例如健康状态、连接数、内存、CPU、Load 等更加丰富的信息，根据综合因素进行更好地决策。</p>
<ul>
<li><code>LoadBalance</code> 接口定义了 <code>ServiceInfo select(List&lt;ServiceInfo&gt; invokers, RpcRequest request)</code> ，SPI 注解表示可扩展。</li>
<li><code>AbstractLoadBalance</code> 实现了 <code>select</code> 考虑到 无invokers、单invokers 的情况，体现了 模版方法 的设计模式，让实现类自己实现 <code>doSelect</code> 方法。</li>
</ul>
<blockquote>
<p>设计模式：模板方法 （示例：HttpServlet 的 service() 方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">    <span class="keyword">if</span> (method.equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他如 PUT、DELETE 等也可以类似处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>本项目实现了 Random、RoundRobin、ConsistentHash 三种负载均衡算法</p>
<p>在分布式系统中，服务提供者和服务消费者都会有多台节点，如何保证服务提供者所有节点的负载均衡呢？客户端在发起调用之前，需要感知有多少服务端节点可用，然后从中选取一个进行调用。客户端需要拿到服务端节点的状态信息，并根据不同的策略实现负载均衡算法。负载均衡策略是影响 RPC 框架吞吐量很重要的一个因素，下面我们介绍几种最常用的负载均衡策略。</p>
<ul>
<li>Round-Robin 轮询。Round-Robin 是最简单有效的负载均衡策略，并没有考虑服务端节点的实际负载水平，而是依次轮询服务端节点。</li>
<li>Weighted Round-Robin 权重轮询。对不同负载水平的服务端节点增加权重系数，这样可以通过权重系数降低性能较差或者配置较低的节点流量。权重系数可以根据服务端负载水平实时进行调整，使集群达到相对均衡的状态。</li>
<li>Least Connections 最少连接数。客户端根据服务端节点当前的连接数进行负载均衡，客户端会选择连接数最少的一台服务器进行调用。Least Connections 策略只是服务端其中一种维度，我们可以演化出最少请求数、CPU 利用率最低等其他维度的负载均衡方案。</li>
<li>Consistent Hash 一致性 Hash。目前主流推荐的负载均衡策略，Consistent Hash 是一种特殊的 Hash 算法，在服务端节点扩容或者下线时，尽可能保证客户端请求还是固定分配到同一台服务器节点。Consistent Hash 算法是采用哈希环来实现的，通过 Hash 函数将对象和服务器节点放置在哈希环上，一般来说服务器可以选择 IP + Port 进行 Hash，然后为对象选择对应的服务器节点，在哈希环中顺时针查找距离对象 Hash 值最近的服务器节点。</li>
</ul>
<p>此外，负载均衡算法可以是多种多样的，客户端可以记录例如健康状态、连接数、内存、CPU、Load 等更加丰富的信息，根据综合因素进行更好地决策。</p>
</blockquote>
<h3 id="discovery-registry"><a href="#discovery-registry" class="headerlink" title="discovery/registry"></a><span id="centor"><mark>discovery/registry</mark></span></h3><p>在分布式系统中，不同服务之间应该如何通信呢？传统的方式可以通过 HTTP 请求调用、保存服务端的服务列表等，这样做需要开发者主动感知到服务端暴露的信息，系统之间耦合严重。为了更好地将客户端和服务端解耦，以及实现服务优雅上线和下线，于是注册中心就出现了。</p>
<p>在 RPC 框架中，主要是使用注册中心来实现服务注册和发现的功能。服务端节点上线后自行向注册中心注册服务列表，节点下线时需要从注册中心将节点元数据信息移除。客户端向服务端发起调用时，自己负责从注册中心获取服务端的服务列表，然后在通过负载均衡算法选择其中一个服务节点进行调用。以上是最简单直接的服务端和客户端的发布和订阅模式，不需要再借助任何中间服务器，性能损耗也是最小的。</p>
<p>现在思考一个问题，服务在下线时需要从注册中心移除元数据，那么注册中心怎么才能感知到服务下线呢？我们最先想到的方法就是节点主动通知的实现方式，当节点需要下线时，向注册中心发送下线请求，让注册中心移除自己的元数据信息。但是如果节点异常退出，例如断网、进程崩溃等，那么注册中心将会一直残留异常节点的元数据，从而可能造成服务调用出现问题。</p>
<p>为了避免上述问题，实现服务优雅下线比较好的方式是采用主动通知 + 心跳检测的方案。除了主动通知注册中心下线外，还需要增加节点与注册中心的心跳检测功能，这个过程也叫作探活。心跳检测可以由节点或者注册中心负责，例如注册中心可以向服务节点每 60s 发送一次心跳包，如果 3 次心跳包都没有收到请求结果，可以任务该服务节点已经下线。</p>
<p>由此可见，采用注册中心的好处是可以解耦客户端和服务端之间错综复杂的关系，并且能够实现对服务的动态管理。服务配置可以支持动态修改，然后将更新后的配置推送到客户端和服务端，无须重启任何服务。</p>
<p>心跳检测：</p>
<p>Nacos: 客户端默认5秒发送一次心跳，服务端15s未收到心跳会将实例标记为不健康，超过30s就会删除实例</p>
<p>ZK: 临时节点（Ephemeral）本身就具备心跳检测特性，超时后节点自动删除（默认40s）</p>
<h4 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h4><blockquote>
<p>Nacos 是阿里开源的一站式服务发现、配置管理和服务管理平台。它可以作为注册中心使用，也支持配置中心功能，是服务治理的核心组件之一，类似于 Eureka、Consul、Zookeeper。<em>适合AP，高可用，健康检查机制更加可靠</em></p>
</blockquote>
<table>
<thead>
<tr>
<th>特性</th>
<th>Nacos</th>
<th>Eureka</th>
<th>Consul</th>
<th>Zookeeper</th>
</tr>
</thead>
<tbody><tr>
<td>CAP 理论倾向</td>
<td>AP(+CP)</td>
<td>AP</td>
<td>CP</td>
<td>CP</td>
</tr>
<tr>
<td>支持健康检查</td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>支持配置中心</td>
<td>✅</td>
<td>❌</td>
<td>部分</td>
<td>❌</td>
</tr>
<tr>
<td>UI 管理界面</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>动态感知能力</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌（延迟）</td>
</tr>
</tbody></table>
<p><strong>服务注册</strong>（Service Registration）：一个服务启动后把自己的信息（如 IP、端口等）注册到 Nacos。</p>
<p><strong>服务发现</strong>（Service Discovery）：别的服务通过服务名从 Nacos 查询到这个服务的实例信息，然后进行调用。</p>
<p><mark>Nacos 注册中心的核心功能（命名服务 NamingService）</mark></p>
<p>在微服务架构中，服务的实例通常是动态变化的（可能会横向扩展、下线），不能写死 IP 和端口。使用命名服务的好处是：</p>
<ul>
<li>动态管理服务实例</li>
<li>实现服务的自动上下线</li>
<li>支持客户端负载均衡</li>
<li>解耦服务之间的调用</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>Zookeeper</th>
<th>Nacos</th>
<th>Eureka</th>
<th>Consul</th>
</tr>
</thead>
<tbody><tr>
<td>CAP 理论倾向</td>
<td><strong>CP</strong></td>
<td>AP</td>
<td>AP</td>
<td>CP</td>
</tr>
<tr>
<td>强一致性</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>服务宕机会下线</td>
<td>✅（临时节点）</td>
<td>✅（心跳）</td>
<td>❌（延迟）</td>
<td>✅</td>
</tr>
<tr>
<td>Watcher 机制</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>配置中心功能</td>
<td>❌</td>
<td>✅</td>
<td>❌</td>
<td>有限</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>服务（Service）</td>
<td>一个服务的逻辑名，如 <code>user-service</code></td>
</tr>
<tr>
<td>实例（Instance）</td>
<td>服务的一个具体实现，如 <code>user-service 192.168.1.10:8080 healthy metadata</code></td>
</tr>
<tr>
<td>命名空间（Namespace）</td>
<td>用于服务隔离，可以做多环境管理，比如开发、测试、生产环境</td>
</tr>
<tr>
<td>分组（Group）</td>
<td>用于对服务进行逻辑分组，默认是 <code>DEFAULT_GROUP</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NamingService</span> <span class="variable">naming</span> <span class="operator">=</span> NacosFactory.createNamingService(<span class="string">&quot;127.0.0.1:8848&quot;</span>);</span><br><span class="line"><span class="comment">// 注册服务</span></span><br><span class="line">naming.registerInstance(<span class="string">&quot;user-service&quot;</span>, <span class="string">&quot;192.168.1.100&quot;</span>, <span class="number">8080</span>);</span><br><span class="line"><span class="comment">// 获取服务实例列表</span></span><br><span class="line">List&lt;Instance&gt; instances = naming.getAllInstances(<span class="string">&quot;user-service&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure>

<h4 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h4><blockquote>
<p>Zookeeper 是一个开源的<strong>分布式协调框架</strong>，用于实现分布式系统中的统一配置管理、命名服务、分布式锁、主从选举等功能。在微服务体系中，它也可以作为注册中心使用，比如 Dubbo 体系就常用 ZK。<em>CP，强一致性，不过临时节点删除可能有一点延迟</em> </p>
</blockquote>
<table>
<thead>
<tr>
<th>功能点</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>服务注册</td>
<td>服务提供者在 ZooKeeper 的 <code>/services/&#123;serviceName&#125;/providers</code> 路径下创建<mark>临时节点</mark>（Ephemeral Node），节点内容为服务元数据。</td>
</tr>
<tr>
<td>服务发现</td>
<td>消费者监听 <code>/services/&#123;serviceName&#125;/providers</code> 的子节点变化（<mark>Watcher</mark> 机制），实时获取服务列表。</td>
</tr>
<tr>
<td>健康检查</td>
<td>依赖<mark>临时节点</mark>的机制，服务宕机/断连节点会自动消失。</td>
</tr>
<tr>
<td>动态感知</td>
<td>使用 Watcher 机制，监听节点变化自动感知上下线，通过 Watcher 通知消费者刷新本地缓存。</td>
</tr>
<tr>
<td>数据一致性</td>
<td>强一致性（CP系统），适合对一致性要求高的场景。</td>
</tr>
</tbody></table>
<p>ZooKeeper 的 Watcher 机制保证消费者在节点增删时立即收到通知，触发本地缓存更新。</p>
<p>若 ZooKeeper 会话超时，消费者需重新注册 Watcher 并全量拉取数据。</p>
<p>缓存当前服务列表的快照，并在 Watcher 回调中对比差异，实现增量更新。</p>
<h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><ul>
<li><p><code>ServiceDiscovery</code> 接口</p>
<ul>
<li><code>ServiceInfo discover(RpcRequest request)</code> 服务发现</li>
<li><code>default List&lt;ServiceInfo&gt; getServices(String serviceName)</code> 返回所有服务提供方</li>
<li><code>void destroy()</code> 摧毁连接</li>
</ul>
</li>
<li><p><code>NacosServiceDiscovery</code> </p>
<ul>
<li><p><code>LoadBalance loadBalance</code> 负载均衡算法</p>
</li>
<li><p><code>Map&lt;String, List&lt;ServiceInfo&gt;&gt; serviceMap</code> 本地缓存</p>
</li>
<li><p>构造器：提供负载均衡算法，nacos 地址</p>
</li>
<li><p><code>void destroy()</code> 关闭 命名服务</p>
</li>
<li><p><code>ServiceInfo discover(RpcRequest request)</code> 调用<code>getServices()</code>得到服务信息传给负载均衡器返回结果</p>
</li>
<li><p><code>List&lt;ServiceInfo&gt; getServices(String serverName)</code> </p>
<p>先看看缓存里有没有，没有就从NamingService里获取<code>List&lt;Instances&gt;</code>，通过stream映射到<code>List&lt;ServiceInfo&gt;</code>，将list作为服务名对应的值加到本地缓存里面。与此同时，订阅 NamingEvent，<code>subscribe(String serviceName, EventListener el)</code> 实现 <code>EventListener</code> 的 <code>onEvent(Event e)</code>，<code>Event</code> 转成 <code>NamingEvent</code>，从 NamingEvent 获取服务信息<code>getInstances</code>，更新至本地缓存。</p>
</li>
</ul>
</li>
<li><p><code>ZookeeperServiceDiscovery</code> </p>
<ul>
<li><p><code>ServiceDiscovery&lt;ServiceInfo&gt; serviceDiscovery</code> Curator 提供的服务发现组件</p>
</li>
<li><p><code>Map&lt;String, List&lt;ServiceInfo&gt;&gt; serviceMap</code></p>
<p>将服务列表缓存到本地内存，当服务发生变化时，由 serviceCache 进行服务列表更新操作，当 zk 挂掉时，将保存当前服务列表以便继续提供服务。</p>
</li>
<li><p><code>Map&lt;String, ServiceCache&lt;ServiceInfo&gt;&gt; serviceCacheMap</code>  </p>
<p>将在zk中的服务数据缓存至本地，并监听服务变化，实时更新缓存<br>服务本地缓存，将服务缓存到本地并增加 watch 事件，当远程服务发生改变时自动更新服务缓存</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>构造器：提供负载均衡算法，zk地址，使用curator构建servicediscovery</p>
</li>
<li><p><code>void destroy()</code> 关闭缓存，关闭服务发现中心，关闭客户端</p>
</li>
</ul>
<ul>
<li><code>ServiceInfo discover(RpcRequest request)</code> 调用<code>getServices()</code>得到服务信息传给负载均衡器返回结果</li>
</ul>
<ul>
<li><p><code>List&lt;ServiceInfo&gt; getServices(String serverName)</code> </p>
<p>先查本地缓存，没有就构建缓存 <code>ServiceCache&lt;ServiceInfo&gt;</code>（这个是实时更新的缓存），使用建造者模式赋值服务名称。添加缓存事件监听器 <code>ServiceCacheListener</code>：重写 <code>cacheChanged()</code>，一旦缓存发生改变，就<code>getInstances</code> 获取 <code>List&lt;ServiceInstance&lt;ServiceInfo&gt;&gt;</code> 通过 <code>getPayload()</code> 获取<code>ServiceInfo</code>。连接状态改变只打印信息。将&lt;服务名，对应的实时缓存&gt;存到 <code>ServiceCacheMap</code> 里面，也存到本地缓存里面。</p>
</li>
</ul>
<h4 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h4><ul>
<li><code>ServiceRegistry</code><ul>
<li><code>register(ServiceInfo info)</code> 注册</li>
<li><code>unregister(ServiceInfo info)</code> 注销</li>
<li><code>destroy()</code> 摧毁连接</li>
</ul>
</li>
<li><code>NacosServiceRegistry</code> <ul>
<li>注册：构建 <code>Instance</code>，将 <code>ServiceInfo</code> 转为 <code>Map</code> 作为其 metadata 进行注册</li>
<li>注销：构建 <code>Instance</code>，将 <code>ServiceInfo</code> 转为 <code>Map</code> 作为其 metadata 进行注销</li>
</ul>
</li>
<li><code>ZookeeperServiceRegistry</code><ul>
<li>注册：将 <code>ServiceInfo</code> 构建为 <code>ServiceInstance&lt;ServiceInfo&gt;</code> ，然后进行注册</li>
<li>注销：将 <code>ServiceInfo</code> 构建为 <code>ServiceInstance&lt;ServiceInfo&gt;</code> ，然后进行注销</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Nacos 直接拿 <code>NamingService</code> 使用就可以，<code>Instance</code> 中的 <strong>metadata</strong> 是 <code>ServiceInfo</code> 转换成的 Map</p>
<ul>
<li>服务发现的时候，数据来源就是 <code>NamingService</code> 本身。</li>
</ul>
<p>ZK 需要手动用 Curator API 构造注册中心， <code>ServiceInstance&lt;ServiceInfo&gt;</code> 的 <strong>payload</strong> 是 <code>ServiceInfo</code> </p>
<ul>
<li>服务发现的时候，数据主要来源是本地的实时缓存 <code>ServiceCache&lt;ServiceInfo&gt;</code>。</li>
</ul>
<h3 id="extension-（SPI）"><a href="#extension-（SPI）" class="headerlink" title="extension （SPI）"></a><span id="spi">extension （SPI）</span></h3><p>已实现，参考Dubbo部分源码，实现了自定义的SPI机制，目前仅支持根据接口类型加载配置文件中的所有具体的扩展实现类，并且可以根据指定的key获取特定的实现类，具体实现类逻辑在 <code>com.wxy.rpc.core.extension.ExtensionLoader</code> 中。</p>
<p>服务存储目录在 <code>resource/META-INF/extensions</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protostuff=com.wxy.rpc.core.serialization.protostuff.ProtostuffSerialization</span><br><span class="line">kryo=com.wxy.rpc.core.serialization.kryo.KryoSerialization</span><br><span class="line">json=com.wxy.rpc.core.serialization.json.JsonSerialization</span><br><span class="line">jdk=com.wxy.rpc.core.serialization.jdk.JdkSerialization</span><br><span class="line">hessian=com.wxy.rpc.core.serialization.hessian.HessianSerialization</span><br></pre></td></tr></table></figure>

<p>与类解耦的单例生成器 Holder。</p>
<h4 id="ExtensionLoader"><a href="#ExtensionLoader" class="headerlink" title="ExtensionLoader"></a><span id="cache">ExtensionLoader</span></h4><p>ExtensionLoader 通过一系列map缓存减少无用的对象创建：</p>
<p><code>Map&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; classToLoaderMap</code>  loader缓存（接口，loader）</p>
<ul>
<li>关联方法：<code>ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type)</code> type必须有SPI注解才能返回对应的Loader</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250426001316156.png" alt="单例缓存"></p>
<h4 id="ExtensionFactory"><a href="#ExtensionFactory" class="headerlink" title="ExtensionFactory"></a>ExtensionFactory</h4><p>然后使用工厂类，先根据type获取loader，然后根据name得到对象。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250426001516610.png" alt="Factory" style="zoom:50%;" />

<h4 id="AutoConfiguration"><a href="#AutoConfiguration" class="headerlink" title="AutoConfiguration"></a>AutoConfiguration</h4><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250426001729767.png" alt="自动装配类" style="zoom:50%;" />

<p>如图，单例工厂，从配置读取 <code>key</code>，然后让加载器加载 <code>key</code> 对应的实现类。</p>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a><span id="spi1">序列化</span></h4><p>序列化全程不需要以bean的形式出现，因为<code>framework-core</code>内部不好移动代码。</p>
<p>客户端需要从配置文件读取方式名来获取编号写入消息头（<code>key-&gt;type</code>）。编解码器需要按照消息头的编号获取方式名（<code>type-&gt;key</code>）然后借此拿到实例（<code>key-&gt;object</code>）。而<code>key-&gt;object</code>的映射就是SPI做的事情。</p>
<p>在工厂类的静态代码块中使用反射框架 Reflections 填充<code>key,type</code>的互相映射。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250502004542885.png" alt="image-20250502004542885"></p>
<h4 id="服务注册-发现"><a href="#服务注册-发现" class="headerlink" title="服务注册/发现"></a><span id="spi2">服务注册/发现</span></h4><p>原先的策略：registryAddr作为 ServiceRegistry 实现类的构造器参数，构造器里开启客户端。但是发现如果从ExtensionFactory里面拿对象，确实是解耦了，但是在bean方法里根本无法注入registryAddr给ServiceRegistry，而且spi只支持空参构造。因此改换思路，要实现完全解耦，就需要将接口改成抽象类，这样ServiceRegistry的子类（实现类）就能拿到参数开启客户端了，另开一个方法独自开启客户端。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250502004633513.png" alt="image-20250502004633513"></p>
<h2 id="server-spring-boot"><a href="#server-spring-boot" class="headerlink" title="server-spring-boot"></a>server-spring-boot</h2><h3 id="store"><a href="#store" class="headerlink" title="store"></a><mark>store</mark></h3><p><code>LocalServiceCache</code> 服务提供者的本地注册中心</p>
<p>从调用信息 RpcRequest 中解析出的服务名映射到本地实现类.class <code>ConcurrentHashMap</code></p>
<p><code>static addService(String serviceName, Object obj)</code>  添加服务</p>
<p><code>static Object getService(String serviceName)</code>  获得服务</p>
<p><code>static void removeService(Object obj)</code> 移除服务</p>
<h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a><mark>handler</mark></h3><p><code>RpcRequestHandler</code> 执行调用的核心</p>
<p><code>Object handleRpcRequest(RpcRequest request)</code></p>
<p>从本地注册中心 <code>LocalServiceCache</code> 获取服务，通过反射执行调用，返回结果。</p>
<h3 id="transport"><a href="#transport" class="headerlink" title="transport"></a>transport</h3><p><code>RpcServer</code> 接口 定义了 <code>start(Integer port)</code> 方法，有三个实现（Http、Netty、Socket）</p>
<h4 id="http"><a href="#http" class="headerlink" title="http"></a><span id="httpserver">http</span></h4><p><code>HttpRpcRequestHandler</code> 处理器，单例模式，责任链模式，相当于回调函数 核心方法 <code>handler.handle(req, resp)</code> 将 <code>RpcRequestHandler</code> 的结果以及异常封装到 <code>RpcResponse</code> 中，发回到序列化流中。</p>
<p><code>HttpRpcServer</code> 启动 tomcat ，主要是设置好 Servlet</p>
<p><code>DispatcherServlet</code> 分发 Servlet，前端控制器模式，使用线程池处理，来一个请求就开一个线程，关于参数：IO密集型 为 cpuNum *2 ，cpu密集型应为 cpuNum + 1 </p>
<p><a href="#httpclient">http 客户端</a> </p>
<h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a><span id="socketserver">socket</span></h4><p><code>SocketRpcServer</code> 启动 ServerSocket bind 端口，在死循环中 accept 还被阻塞，只要服务端socket不关闭（抛出 IOException），就会一直在循环里。除非关闭serversocket/网络问题。建立连接就在线程池开一个任务。</p>
<p><code>SocketRpcRequestHandler</code> 实现了 <code>Runnable</code> 接口，将 <code>RpcRequestHandler</code> 的结果以及异常封装到 <code>RpcResponse</code> 中，发回到序列化流中。</p>
<p><a href="#socketclient">socket 客户端</a> </p>
<h4 id="netty"><a href="#netty" class="headerlink" title="netty"></a><span id="nettyserver">netty</span></h4><p><a href="#nettyclient">netty 客户端</a> </p>
<p><code>NettyRpcRequestHandler</code> </p>
<blockquote>
<p>继承自 <code>SimpleChannelInboundHandler&lt;RpcMessage&gt;</code> 表示入站处理器处理RpcMessage。</p>
<p>只接收你想要的类型（即泛型指定的类型）；</p>
<p>消息处理完之后，<strong>自动释放 ByteBuf</strong>，避免内存泄漏（比 <code>ChannelInboundHandlerAdapter</code> 更安全）。</p>
</blockquote>
<p>重写了 <code>channelRead0</code> 方法。相当于进入一个消息的处理器。<strong>新开一个任务提交到线程池</strong>：先判断消息类型，如果是心跳请求PING，那么就设置回复的RpcMessage为心跳响应，然后设置好头部信息，消息体为 PONG。剩下的就是客户端的Rpc请求了，像其他方法一样将RpcRequest提取出来交给handler处理，设置好type status body 就发到下一个处理器（codec）。</p>
<p><code>ctx.writeAndFlush(responseRpcMessage).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</code></p>
<p><code>finally:  ReferenceCountUtil.release(msg);</code> 防止内存泄露</p>
<p><mark>心跳检测</mark>：<code>userEventTriggered</code> 用户自定义事件，当触发读空闲(<code>IdleState.READER_IDLE</code>)时，也就是 30s 没有读的内容，就自动关闭【客户端channel】连接 </p>
<p><code>NettyRpcServer</code></p>
<ul>
<li><p><code>EventLoopGroup</code> 每个 <code>EventLoopGroup</code> 默认使用多个线程（CPU 核数 * 2）</p>
<blockquote>
<p>Netty 的线程模型是什么？为什么要用 boss/worker 分离？</p>
<p>Netty 使用的是 <strong>Reactor 多线程模型</strong>，将连接处理和读写事件分离，避免阻塞。</p>
<ul>
<li><code>bossGroup</code> 负责处理 <strong>accept（连接建立）</strong> 事件 将接受的连接注册到 Worker Group 的某个线程上，通常1-2个线程即可</li>
<li><code>workerGroup</code> 负责处理 <strong>read/write（数据通信）</strong> 事件，执行实际的业务处理，通常 为 cpu core *2 </li>
</ul>
<p>这样设计可以保证即使某个连接在业务处理时耗时较长，也不会阻塞新连接的接入，提高并发性能和系统的稳定性。</p>
</blockquote>
</li>
<li><p><code>ServerBootstrap</code> 启动类 配置参数</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">serverBootstrap.group(boss, worker) <span class="comment">// 指定线程组 group(parentGroup, childGroup)</span></span><br><span class="line">.channel(NioServerSocketChannel.class) <span class="comment">// 指定服务端 Channel 类型</span></span><br><span class="line">.childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>) <span class="comment">// 关闭 Nagle 算法，更及时发送数据</span></span><br><span class="line">.childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>) <span class="comment">// TCP 底层心跳机制（不是业务层心跳，2小时）</span></span><br><span class="line">.option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)<span class="comment">/* 表示用于临时存放完成三次握手的请求的队列的最大长度,</span></span><br><span class="line"><span class="comment">    								   	若连接建立频繁，服务器处理创建新连接较慢，可适当调大 */</span></span><br><span class="line">    </span><br><span class="line">.handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG)) <span class="comment">// ParentGroup 的处理器，记录日志</span></span><br><span class="line">    </span><br><span class="line">.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<span class="comment">// 客户端首次请求，为此连接分配一个</span></span><br><span class="line">    <span class="meta">@Override</span>                                          <span class="comment">// 新的SocketChannel (lazy init)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//  心跳机制，30s内没有收到客户端的请求就关闭连接，会触发一个 IdleState#READER_IDLE 事件</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS));</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">RpcFrameDecoder</span>());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SharableRpcMessageCodec</span>());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyRpcRequestHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 绑定端口，同步等待绑定成功 生命周期 bind </span></span><br><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(inetAddress, port).sync();</span><br><span class="line">log.debug(<span class="string">&quot;Rpc server add &#123;&#125; started on the port &#123;&#125;.&quot;</span>, inetAddress, port);</span><br><span class="line"><span class="comment">// 等待服务端监听端口关闭，如果不写这句，主线程会直接退出，Netty 服务就被销毁了。</span></span><br><span class="line">channelFuture.channel().closeFuture().sync();</span><br><span class="line"><span class="comment">// 这里 netty 已经封装好了异步接受逻辑，bind通常用sync等待一次，然后监听channel的关闭即可。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>EventLoop</code> 事件处理单元 <code>ChannelHandler</code>  业务处理逻辑 <code>ChannelPipeline</code>  处理器链</p>
<p><code>ByteBuf</code>  高效字节容器</p>
<p><code>Channel</code>  网络连接通道</p>
<p><code>NioServerSocketChannel</code> 用于 boss 的Channel，<code>SocketChannel</code> 用于 worker </p>
</blockquote>
<p>Netty 的 <code>ChannelPipeline</code> 是一个基于责任链模式的事件处理链，每个请求或响应都会从一个 handler 流向下一个 handler，形成链式处理。</p>
<p><code>[字节流] -&gt; ([心跳检测]) -&gt; [帧解码器] -&gt; [消息解码器] -&gt; [业务处理器]</code> </p>
<p><span id="心跳机制"></span></p>
<table>
<thead>
<tr>
<th>Handler 名称</th>
<th>作用说明</th>
<th>方向</th>
</tr>
</thead>
<tbody><tr>
<td><code>IdleStateHandler</code></td>
<td>空闲连接检测（30 秒无读事件会触发 READER_IDLE）实现应用层心跳机制（比 TCP 更灵活）更适合业务层快速检测连接状态</td>
<td>入站</td>
</tr>
<tr>
<td><code>RpcFrameDecoder</code></td>
<td>拆包/粘包处理，按协议规则拆出完整消息帧</td>
<td>入站</td>
</tr>
<tr>
<td><code>SharableRpcMessageCodec</code></td>
<td>编解码器，将 ByteBuf ↔ 自定义消息（RpcMessage）相互转换</td>
<td>双向</td>
</tr>
<tr>
<td><code>NettyRpcRequestHandler</code></td>
<td>业务逻辑处理器，处理请求、调用本地服务、写回响应</td>
<td>入站</td>
</tr>
</tbody></table>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250423123418951.png" alt="责任链"></p>
<p><a href="#nettyclient">netty 客户端</a></p>
<h2 id="client-spring-boot"><a href="#client-spring-boot" class="headerlink" title="client-spring-boot"></a>client-spring-boot</h2><h3 id="common"><a href="#common" class="headerlink" title="common"></a>common</h3><p><code>RequestMetadata</code> 封装请求，有 RpcMessage serverAddr port timeout 字段。</p>
<h3 id="handler-1"><a href="#handler-1" class="headerlink" title="handler"></a>handler</h3><p><code>RpcResponseHandler</code> 继承自 <code>SimpleChannelInboundHandler&lt;RpcMessage&gt;</code> </p>
<blockquote>
<p><strong>Netty 中的 Promise 机制</strong> </p>
<p>RPC 是远程调用，发送请求和得到响应的过程属于异步操作，Promise 机制用来解决 “客户端怎么知道哪个响应对应哪个请求？怎么挂起等待，又怎么唤醒？”的问题。</p>
<p>Netty 提供的 <code>DefaultPromise&lt;V&gt;</code> 是一个线程安全的对象，用来异步地接收并处理计算结果。你可以把它理解为一个 <strong>可手动完成的 Future</strong>。它有几个特点：</p>
<ul>
<li>在请求发送后立刻返回，不阻塞</li>
<li>把结果放入 Promise 中，调用方通过 <code>promise.get()</code> 或回调拿到结果</li>
<li>由响应处理器来手动调用 <code>promise.setSuccess(response)</code> 来填充结果</li>
</ul>
<p>实践中通常会用一个 <code>Map&lt;requestId, Promise&lt;RpcResponse&gt;&gt;</code> 保存请求对应的 Promise。具体流程如下：</p>
<ol>
<li><strong>发送请求之前：</strong><ul>
<li>创建一个 <code>DefaultPromise&lt;RpcResponse&gt;</code> 对象</li>
<li>存入全局请求池（Map）中：<code>promises.put(requestId, promise)</code></li>
</ul>
</li>
<li><strong>接收响应时：</strong><ul>
<li>从请求池里通过 <code>requestId</code> 找到对应的 <code>Promise</code></li>
<li>执行 <code>promise.setSuccess(response)</code>，通知结果已经到了</li>
</ul>
</li>
<li><strong>调用方阻塞等待结果（可选）：</strong><ul>
<li><code>promise.get()</code> 或 <code>promise.await()</code></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 发请求之前保存 promise</span></span><br><span class="line">DefaultPromise&lt;RpcResponse&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutor);</span><br><span class="line">RpcResponsePool.put(requestId, promise);</span><br><span class="line">channel.writeAndFlush(rpcMessage);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 接收响应时设置结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcMessage msg)</span> &#123;</span><br><span class="line">    <span class="type">RpcResponse</span> <span class="variable">response</span> <span class="operator">=</span> (RpcResponse) msg.getBody();</span><br><span class="line">    Promise&lt;RpcResponse&gt; promise = RpcResponsePool.remove(response.getRequestId()); <span class="comment">// 防内存泄露</span></span><br><span class="line">    <span class="keyword">if</span> (promise != <span class="literal">null</span>) &#123;</span><br><span class="line">        promise.setSuccess(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 获取结果</span></span><br><span class="line"><span class="type">RpcResponse</span> <span class="variable">result</span> <span class="operator">=</span> promise.get();</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>Map&lt;Integer, Promise&lt;RpcMessage&gt;&gt; UNPROCESSED_RPC_RESPONSES</code> 未处理的响应请求，跟 sequenceId 相对应</p>
<p><code>channelRead0</code> 如果是 <code>RpcResponse</code>，从map中拿出对应的响应，如果响应中没有异常，代表 <code>Promise</code> 成功。如果是心跳回应，则记录日志。</p>
<p><code>userEventTriggered(ctx, Object evt)</code> 用户自定义事件处理器，处理写空闲（<code>WRITE_IDLE</code>），当检测到写空闲15s 以后自动发送一个心跳检测数据包。如果 <code>evt</code> 是 <code>IdleStateEvent</code>，那么就构建一个 心跳检查的 RpcMessage，这里使用 Kryo 序列化以达到最好的效果。</p>
<h3 id="transport-1"><a href="#transport-1" class="headerlink" title="transport"></a>transport</h3><p><code>RpcClient</code> </p>
<p><code>RpcMessage sendRpcRequest(RequestMetadata requestMetadata)</code>  </p>
<h4 id="http-1"><a href="#http-1" class="headerlink" title="http"></a><span id="httpclient">http</span></h4><p><code>sendRpcRequest(RequestMetadata requestMetadata)</code> </p>
<p>根据 RequestMetadata，拿出 RpcMessage，取出 RpcRequest 并通过 Http 连接序列化发送，阻塞等待读取 RpcResponse，读取之后封装为 RpcMessage返回。</p>
<p><code>HttpRpcClient 发送和接受的数据为：RpcRequest，Response</code> </p>
<p><a href="#httpserver">http 服务端</a> </p>
<h4 id="socket-1"><a href="#socket-1" class="headerlink" title="socket"></a><span id="socketclient">socket</span></h4><p><code>sendRpcRequest(RequestMetadata requestMetadata)</code>   socket connect 获取数据</p>
<p><code>SocketRpcClient 发送和接受的数据为：RpcRequest, RpcResponse</code></p>
<p><a href="#socketserver">socket 服务端</a> </p>
<h4 id="netty-1"><a href="#netty-1" class="headerlink" title="netty"></a><span id="nettyclient">netty</span></h4><table>
<thead>
<tr>
<th>场景</th>
<th>你的职责</th>
</tr>
</thead>
<tbody><tr>
<td>Channel 断开</td>
<td>触发 <code>channelInactive()</code> 或 <code>exceptionCaught()</code> 时，尝试<strong>重连</strong></td>
</tr>
<tr>
<td>连接池中拿到无效 Channel</td>
<td>检查 <code>channel.isActive()</code>，如果无效：<strong>close 并重新连接</strong></td>
</tr>
<tr>
<td>心跳失败或无响应</td>
<td>在 <code>IdleStateHandler</code> 的事件中<strong>关闭旧连接并重建</strong></td>
</tr>
<tr>
<td>重试次数限制</td>
<td>设置最大重试次数，避免死循环</td>
</tr>
</tbody></table>
<blockquote>
<p><code>ChannelProvider</code> 获取Channel的工具类</p>
<ul>
<li><code>Map&lt;String, Channel&gt; channels</code> 存储 channel 对象，key 为 ip:port</li>
<li><code>get(host,port)</code> 取出 活跃的 channel，不活跃的/null 从map移除</li>
<li><code>get(inetSocketAddress)</code> 同上</li>
<li><code>set(host,port,channel)</code> 将 host:port 与 Channel 映射</li>
</ul>
</blockquote>
<p><code>NettyRpcClient</code> </p>
<p><code>BootStrap</code> 启动类，注册 NioSocketChannel 超时时间，5s连接超时。handler 设置为 15s写空闲的IdleStateHandler，粘包拆包解码器、codec、ResponseHandler 。提供 ChannelProvider 工具类</p>
<p><code>EventLoopGroup</code> 每个事件循环对象对应一个线程，维护一个 Selector，用来处理io事件</p>
<p><code>getChannel(inetSocketAddress)</code>首先从map中获取，获取不到就主动去连接 <code>doConnect</code></p>
<p><code>doConnect(inetSocketAddress)</code> ：</p>
<p>方式1：</p>
<p>随后sync()同步阻塞等待 channel 的 closeFuture()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// connect 会返回一个 异步的 ChannelFuture</span></span><br><span class="line"><span class="comment">// sync() 同步等待异步connect连接成功 </span></span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(inetSocketAddress).sync().channel();</span><br><span class="line"><span class="comment">// 同步阻塞等待异步关闭完成</span></span><br><span class="line">channel.closeFuture().sync();</span><br></pre></td></tr></table></figure>

<p>方式2：</p>
<p><span id="指数退避">指数退避重连</span>，使用 CompletetableFuture 阻塞获取 channel，future 成功时返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> Channel <span class="title function_">doConnectWithRetry</span><span class="params">(InetSocketAddress inetSocketAddress, <span class="type">int</span> remainingRetries)</span>&#123;</span><br><span class="line">    CompletableFuture&lt;Channel&gt; cf = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">    bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener)future -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (remainingRetries &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> calculateRetryDelay(remainingRetries);</span><br><span class="line">                log.info(<span class="string">&quot;Retrying connection to &#123;&#125; in &#123;&#125; ms&quot;</span>, inetSocketAddress, delay);</span><br><span class="line">                eventLoopGroup.schedule(() -&gt; doConnectWithRetry(inetSocketAddress, remainingRetries - <span class="number">1</span>), delay, TimeUnit.MILLISECONDS); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Failed to connect to &#123;&#125; after &#123;&#125; retries&quot;</span>, inetSocketAddress, MAX_RETRIES);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;Connected to &#123;&#125; successfully&quot;</span>, inetSocketAddress);</span><br><span class="line">            cf.complete(future.channel());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> cf.get();</span><br><span class="line">    channel.closeFuture().addListener(future -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;The client has been disconnected from server [&#123;&#125;].&quot;</span>, inetSocketAddress.toString());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> channel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">calculateRetryDelay</span><span class="params">(<span class="type">int</span> remainingRetries)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">attempt</span> <span class="operator">=</span> MAX_RETRIES - remainingRetries + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">long</span>) (Math.pow(<span class="number">2</span>, attempt) * <span class="number">500</span>); <span class="comment">// 指数退避基础500ms</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后是</p>
<p><code>sendRpcRequest()</code> ：</p>
<p>根据requestMetadata获取channel对象<code>getChannel()</code>。</p>
<p><code>promise = DefaultPromise&lt;&gt;(channel.eventLoop());</code></p>
<p>获取sequenceId，将promise存入map，把rpcMessage写入channel（异步的）addListener。</p>
<p>对于timeout，使用 promise 的 await 方法。isSuccess 则调用 getNow() 返回响应结果 RpcMessage。</p>
<p><a href="#nettyserver">netty 服务端</a> </p>
<h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a><span id="proxy"><mark>proxy</mark></span></h3><p>代理对象生成过程：</p>
<ol>
<li><p>首先需要一个得到代理对象的工厂类，里面有一个工厂方法返回的就是代理对象。</p>
</li>
<li><p>如何创建代理对象：</p>
<p>JDK：<code>Proxy.newInstance(目标接口类加载器, 目标接口的数组, 实现InvocationHandler接口的invoke方法)</code></p>
<p>CGLIB: <code>Enhancer.create(目标类, 实现MethodInterceptor接口的intercept方法)</code></p>
</li>
<li><p>记住 <code>invoke</code> 和 <code>intercept</code> 就是拿着 <code>method</code>和 <code>args</code>为所欲为，当然也可以在实现类自己加参数，工厂类自己也要加参数</p>
</li>
<li><p>如果你想得到代理对象，那么就调用工厂类的工厂方法。</p>
</li>
</ol>
<p>RPC 框架怎么做到像调用本地接口一样调用远端服务呢？这必须依赖动态代理来实现。需要创建一个代理对象，在代理对象中完成数据报文编码，然后发起调用发送数据给服务提供方，以此屏蔽 RPC 框架的调用细节。因为代理类是在运行时生成的，所以代理类的生成速度、生成的字节码大小都会影响 RPC 框架整体的性能和资源消耗，所以需要慎重选择动态代理的实现方案。动态代理比较主流的实现方案有以下几种：JDK 动态代理、Cglib、Javassist、ASM、Byte Buddy，我们简单做一个对比和介绍。</p>
<ul>
<li>JDK 动态代理。在运行时可以动态创建代理类，但是 JDK 动态代理的功能比较局限，代理对象必须实现一个接口，否则抛出异常。因为代理类会继承 Proxy 类，然而 Java 是不支持多重继承的，只能通过接口实现多态。JDK 动态代理所生成的代理类是接口的实现类，不能代理接口中不存在的方法。JDK 动态代理是通过反射调用的形式代理类中的方法，比直接调用肯定是性能要慢的。</li>
<li>Cglib 动态代理。Cglib 是基于 ASM 字节码生成框架实现的，通过字节码技术生成的代理类，所以代理类的类型是不受限制的。而且 Cglib 生成的代理类是继承于被代理类，所以可以提供更加灵活的功能。在代理方法方面，Cglib 是有优势的，它采用了 FastClass 机制，为代理类和被代理类各自创建一个 Class，这个 Class 会为代理类和被代理类的方法分配 index 索引，FastClass 就可以通过 index 直接定位要调用的方法，并直接调用，这是一种空间换时间的优化思路。</li>
<li>Javassist 和 ASM。二者都是 Java 字节码操作框架，使用起来难度较大，需要开发者对 Class 文件结构以及 JVM 都有所了解，但是它们都比反射的性能要高。Byte Buddy 也是一个字节码生成和操作的类库，Byte Buddy 功能强大，相比于 Javassist 和 ASM，Byte Buddy 提供了更加便捷的 API，用于创建和修改 Java 类，无须理解字节码的格式，而且 Byte Buddy 更加轻量，性能更好。</li>
</ul>
<h4 id="代理实例工厂"><a href="#代理实例工厂" class="headerlink" title="代理实例工厂"></a>代理实例工厂</h4><p>建立一个本地的代理对象缓存，不用每次都重新new代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientStubProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery discovery;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClient rpcClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClientProperties properties;</span><br><span class="line">    <span class="comment">// 本地代理对象缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; proxyMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">(Class&lt;T&gt; clazz, String version)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) proxyMap.computeIfAbsent(ServiceUtil.serviceKey(clazz.getName(), version), serviceName -&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果目标类是一个接口或者 是 java.lang.reflect.Proxy 的子类 则默认使用 JDK 动态代理</span></span><br><span class="line">            <span class="keyword">if</span> (clazz.isInterface() || Proxy.isProxyClass(clazz)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Proxy.newProxyInstance(clazz.getClassLoader(),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;clazz&#125;, <span class="comment">// 注意，这里的接口是 clazz 本身（即，要代理的实现类所实现的接口）</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ClientStubInvocationHandler</span>(discovery, rpcClient, properties, serviceName));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 使用 CGLIB 动态代理</span></span><br><span class="line">                <span class="keyword">return</span> Enhancer.create(clazz, </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ClientStubMethodInterceptor</span>(discovery, rpcClient, properties, serviceName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cglib"><a href="#cglib" class="headerlink" title="cglib"></a>cglib</h4><p>重写 MethodInterceptor 中的 intercept() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientStubMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery serviceDiscovery;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClient rpcClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClientProperties properties;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String serviceName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">return</span> RemoteMethodCall.remoteCall(serviceDiscovery, rpcClient, serviceName, properties, method, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="jdk"><a href="#jdk" class="headerlink" title="jdk"></a>jdk</h4><p>重写 InvocationHandler 中的 invoke() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientStubInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery serviceDiscovery;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClient rpcClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClientProperties properties;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String serviceName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">return</span> RemoteMethodCall.remoteCall(serviceDiscovery, rpcClient, serviceName, properties, method, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RemoteMethodCall-发起-RPC-的公共方法"><a href="#RemoteMethodCall-发起-RPC-的公共方法" class="headerlink" title="RemoteMethodCall 发起 RPC 的公共方法"></a>RemoteMethodCall 发起 RPC 的公共方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">remoteCall</span><span class="params">(ServiceDiscovery serviceDiscovery, RpcClient rpcClient, String serviceName, 	</span></span><br><span class="line"><span class="params">                                RpcClientProperties properties, Method method, Object[] args)</span>&#123;</span><br><span class="line">    <span class="type">MessageHeader</span> <span class="variable">header</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageHeader</span>().build(properties.getSerialization());</span><br><span class="line">    <span class="comment">// 构建 RpcRequest: serviceName, methodName, parameterTypes, args</span></span><br><span class="line">    <span class="comment">// 构建 RpcMessage</span></span><br><span class="line">    <span class="comment">// 服务发现：得到负载均衡后返回的服务信息 serviceInfo</span></span><br><span class="line">    <span class="comment">// 根据 serviceInfo, properties, 与 rpcMessage 构建 RequestMetadata</span></span><br><span class="line">    <span class="comment">// client 调用 sendRpcRequest(rpcMetadata) 返回的 rpcMessage</span></span><br><span class="line">    <span class="comment">// rpcMessage 解包出 rpcResponse 提取 value 返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Spring-部分"><a href="#Spring-部分" class="headerlink" title="Spring 部分"></a>Spring 部分</h1><p>服务端的Spring：</p>
<p><mark>需要按照是否有@RpcService注解进行 Bean 的注册。谁能注册？谁来执行注册？（手动实现Scanner以BeanDefinitionRegistrar），然后把被注解的bean加入本地缓存map，准备执行 RequestHandler</mark> </p>
<p>客户端的Spring：</p>
<p><mark>所有的 bean 都已经注册并导入好了，唯一的问题是 RestController 里面，出现 HelloService 字段，需要将其进行替换为代理对象！</mark> </p>
<h2 id="Review-Spring-Bean-生命周期一览"><a href="#Review-Spring-Bean-生命周期一览" class="headerlink" title="Review: Spring Bean 生命周期一览"></a>Review: Spring Bean 生命周期一览</h2><h3 id="IoC-容器启动过程"><a href="#IoC-容器启动过程" class="headerlink" title="IoC 容器启动过程"></a><mark>IoC 容器启动过程</mark></h3><ol>
<li><p>Spring IoC 启动入口：<code>AnnotationConfigApplicationContext</code> 或 Spring Boot 的 <code>SpringApplication.run(...)</code> </p>
</li>
<li><p>加载配置类（带 <code>@Configuration</code>、<code>@ComponentScan</code>、<code>@Import</code> 等注解）</p>
</li>
<li><p> <strong>扫描、注册阶段</strong> （由 <code>ClassPathBeanDefinitionScanner</code> 完成）</p>
</li>
</ol>
<ul>
<li>扫描被 <code>@ComponentScan</code> 指定的包</li>
<li>找到带注解的类（如 <code>@Component</code>、<code>@Service</code>、<code>@Controller</code>）</li>
<li>解析为 <code>BeanDefinition</code>，使用 <code>BeanDefinitionRegistry</code> 将其注册进<code>beanDefinitionMap</code>还未创建对象。<ul>
<li>修改Bean定义：执行所有 <code>BeanFactoryPostProcessor</code> 的实现类（如 <code>PropertySourcesPlaceholderConfigurer</code>），允许对 <code>BeanDefinition</code> 进行修改（例如替换占位符）。</li>
<li><strong>提前实例化处理器</strong>：注册 <code>BeanPostProcessor</code> 实现类（如 <code>AutowiredAnnotationBeanPostProcessor</code>），这些处理器需在普通Bean之前初始化，以便后续处理其他Bean的创建。</li>
<li>初始化消息源以及事件广播器</li>
</ul>
</li>
</ul>
<ol start="4">
<li><p><strong>实例化阶段</strong>（容器对于单例且非懒加载的 Bean）</p>
<p>对每个要使用的 Bean：</p>
<ul>
<li><p>（主要是针对懒加载或者<code>Scope = prototype</code>）存在性检查：Scope判断（若为单例则检查到单例缓存）以及循环依赖判断（如果当前正在创建就从单例缓存获取原始对象）</p>
</li>
<li><p><strong>实例化</strong>：从 <code>BeanDefinitionRegistry</code> 获取<code> BeanDefinition</code>，包含类名、作用域、初始化方法等元数据。检查是否存在未满足的依赖（如通过<code>@DependsOn</code>指定的前置依赖，或者<code>@Order</code>加载顺序）最后<strong>实例化</strong>对象（通过反射或者工厂方法调用<code>Constructor</code>创建原始对象）</p>
</li>
<li><p><strong>依赖注入</strong>： <code>@Autowired/@Resource</code> 递归调用<code>getBean()</code>获取依赖bean，通过三级缓存（<code>singletonFactories</code>、<code>earlySingletonObjects</code>、<code>singletonObjects</code>）提前暴露对象引用，解决setter的循环依赖。设置好属性。</p>
</li>
<li><p>Aware 接口回调：如果实现了 <code>XXXAware</code> 接口，则通过 <code>setXXX</code> 注入容器底层信息。如名称，类加载器等</p>
</li>
<li><p><code>BeanPostProcessor</code>: 每个bean在构建的过程中，Spring都会遍历所有的<code>BeanPostProcessor</code>的实现类，调用实现类中的方法，入参为构建好的bean。要实现无感的对bean的处理必须使用 <code>BeanPostProcessor</code>。</p>
<table>
<thead>
<tr>
<th>方法（按照先后顺序）</th>
<th>方法所属</th>
</tr>
</thead>
<tbody><tr>
<td>1. <code>Object postProcessBeforeInitialization()</code></td>
<td><code>BeanPostProcessor</code></td>
</tr>
<tr>
<td>2. <code>@PostConstruct</code> 标注的方法</td>
<td>JSR-250 规定</td>
</tr>
<tr>
<td>3. <code>void afterPropertiesSet()</code></td>
<td><code>InitializingBean</code></td>
</tr>
<tr>
<td>4. <code>init()</code></td>
<td><code>@Bean (initMethod =  init)</code></td>
</tr>
<tr>
<td>5. <code>Object postProcessAfterInitialization()</code></td>
<td><code>BeanPostProcessor</code></td>
</tr>
</tbody></table>
<p> <strong>5 是 AOP 动态代理的关键阶段</strong>：Spring 在这里可能会返回代理对象替代原对象</p>
</li>
</ul>
</li>
<li><p><strong>完成容器启动</strong>：触发 <code>ContextRefreshedEvent</code>，通知监听器容器已就绪。<strong>此时可以通过 <code>getBean()</code> 获取单例 Bean</strong>，如果是懒加载或者<code>Scope = prototype</code>的则会在主动调用 <code>getBean()</code> 的时候才实例化。</p>
</li>
</ol>
<h3 id="Bean-生命周期"><a href="#Bean-生命周期" class="headerlink" title="Bean 生命周期"></a>Bean 生命周期</h3><ol>
<li><p>Bean 实例化(仅为构造出对象)</p>
<ul>
<li><strong>触发条件</strong>：①容器启动 ②首次请求 Bean 时 <code>getBean() 或者依赖注入</code>。</li>
<li><strong>方式</strong>：通过构造函数或工厂方法创建 Bean 的实例。</li>
<li><strong>异常</strong>：若依赖无法解析或构造函数抛出异常，Bean 创建失败。</li>
</ul>
</li>
<li><p>属性赋值 Populate Properties</p>
<ul>
<li><strong>依赖注入</strong>：通过 <code>@Autowired</code>、<code>@Resource</code>、XML 配置等方式注入属性。</li>
<li>处理 <code>@Value</code>：解析并注入 SpEL 表达式或占位符的值。</li>
</ul>
</li>
<li><p>Aware 接口回调 与 <code>BeanPostProcessor </code>前置处理、初始化、后置处理。</p>
</li>
<li><p>就绪状态</p>
<ul>
<li>Bean 完全初始化，可被应用程序使用。</li>
<li><strong>Singleton Bean</strong> 会被缓存，后续请求直接获取。</li>
<li><strong>Prototype Bean</strong> 每次请求创建新实例（无后续销毁步骤）。</li>
</ul>
</li>
<li><p>Bean 对象销毁回调</p>
<ul>
<li><p><code>@PreDestroy</code> JSR-250</p>
</li>
<li><p><code>destroy()-&gt;</code>  DisposableBean</p>
</li>
<li><p><code>close()</code> @Bean (destroyMethod =  close)</p>
</li>
</ul>
</li>
<li><p>Bean 对象销毁</p>
<ul>
<li><strong>触发条件</strong>：容器关闭时（如 <code>close()</code> 方法调用）。</li>
<li><strong>作用域影响</strong>：仅 Singleton Bean 会执行销毁回调，Prototype Bean 需手动清理。</li>
</ul>
</li>
</ol>
<h3 id="SpringBoot-启动"><a href="#SpringBoot-启动" class="headerlink" title="SpringBoot 启动"></a>SpringBoot 启动</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringApplication.run()</span><br><span class="line">    ├── 创建 SpringApplication</span><br><span class="line">    ├── prepareEnvironment</span><br><span class="line">    ├── createApplicationContext <span class="comment">// 创建应用上下文</span></span><br><span class="line">    ├── refresh() <span class="comment">// AbstractApplicationContext#refresh() 方法 启动 IOC 容器</span></span><br><span class="line">        ├── postProcessBeanFactory(beanFactory)</span><br><span class="line">        ├── prepareBeanFactory(beanFactory)</span><br><span class="line">        ├── invokeBeanFactoryPostProcessors(beanFactory)</span><br><span class="line">        ├── registerBeanPostProcessors, initMessageSource/initEventMulticaster </span><br><span class="line">        ├── onRefresh (Web容器启动)</span><br><span class="line">        ├── registerListeners</span><br><span class="line">        ├── finishBeanFactoryInitialization <span class="comment">// 初始化所有非懒加载单例 Bean </span></span><br><span class="line">        └── finishRefresh (发布ContextRefreshedEvent)</span><br><span class="line">    ├── 调用 CommandLineRunner.run(String... args) ApplicationRunner(String... args)</span><br><span class="line">    └── ApplicationReady</span><br></pre></td></tr></table></figure>

<p><a href="#boot">由此可见 CommandLineRunner 是在容器启动完成以后执行的。可以实现这个接口的 run 方法来注入参数。</a></p>
<h2 id="Spring-扫描自定义注解"><a href="#Spring-扫描自定义注解" class="headerlink" title="Spring 扫描自定义注解"></a><span id="annotation">Spring 扫描自定义注解</span></h2><h3 id="RpcComponentScan-：扫描、注册-RpcService的类，实例化时将其加入本地缓存"><a href="#RpcComponentScan-：扫描、注册-RpcService的类，实例化时将其加入本地缓存" class="headerlink" title="@RpcComponentScan ：扫描、注册@RpcService的类，实例化时将其加入本地缓存"></a><code>@RpcComponentScan</code> ：扫描、注册<code>@RpcService</code>的类，实例化时将其加入本地缓存</h3><p>扫描、注册的具体过程：</p>
<ol>
<li>扫描到 <code>@Configuration</code> 配置类，又扫到了 <code>@Import(RpcBeanDefinitionRegistrar.class)</code> </li>
<li>通过 <code>RpcBeanDefinitionRegistrar</code> 的 <code>registerBeanDefinitions(AnnotationMetadata data, BeanDefinitionRegistry registry)</code> 进行动态注册，其中 <code>data</code> 参数为被@Import注解 的类（这里是注解<code>@RpcComponentScan</code>）解析出要扫描的包路径，<code>registry</code> 为注册bean的核心。在里面 new 一个 <code>RpcClassPathBeanDefinitionScanner(registry, RpcService.class)</code> 在其构造函数里添加针对 RpcService.class 的 TypeFilter。</li>
<li>设置好 scanner 的 <code>resourceloader</code>，增强代码健壮性。调用 scanner 的 <code>scan(basePackages)</code> 方法，此方法会在内部调用 scanner 的 <code>registry</code> 进行 bean 的注册。</li>
</ol>
<h4 id="定义-BeanDefinition-扫描器"><a href="#定义-BeanDefinition-扫描器" class="headerlink" title="定义 BeanDefinition 扫描器"></a>定义 BeanDefinition 扫描器</h4><blockquote>
<p><code>ClassPathBeanDefinitionScanner</code> 是 Spring 框架中的一个类，用于从指定的类路径中扫描符合条件的类，并将其注册为 Spring 容器中的 Bean 定义。</p>
<p>主要功能：</p>
<ul>
<li>扫描类路径：根据指定的包路径，扫描类路径下的所有类。</li>
<li>过滤条件：通过过滤器（如注解过滤器、类型过滤器等）筛选出符合条件的类。</li>
<li>注册 Bean 定义：将符合条件的类的元信息（<code>BeanDefinition</code>）注册到 Spring 容器中。核心：<code>BeanDefinitionRegistry</code></li>
</ul>
<p>核心用途：</p>
<ul>
<li>用于实现自定义注解扫描和动态注册 Bean。</li>
<li>常见于 Spring 的扩展机制中，例如自定义注解的扫描器。</li>
</ul>
<p>工作流程：</p>
<ol>
<li><p>指定需要扫描的包路径<code>basePackages</code>。</p>
</li>
<li><p>配置过滤器（如只扫描带有特定注解的类）。 <code>addIncludeFilter(TypeFilter tf)</code> </p>
</li>
<li><blockquote>
<p>TypeFilter 接口需要实现<code>boolean match(MetadataReader reader, MetadataReaderFactory factory)</code> </p>
</blockquote>
</li>
<li><p>调用 <code>scan(String... basePackages)</code> 方法，扫描并注册符合条件的类。</p>
</li>
</ol>
</blockquote>
<p><code>RpcClassPathBeanDefinitionScanner</code> 继承了 <code>ClassPathBeanDefinitionScanner</code> </p>
<p>构造函数调用 <code>this.addIncludeFilter(new AnnotationTypeFilter(this.annotationType));</code> 注册想要扫描的注解类。通过 父类的 scan 方法扫包</p>
<hr>
<h4 id="使用-Import-注解结合-Registrar-动态注册-BeanDefinition"><a href="#使用-Import-注解结合-Registrar-动态注册-BeanDefinition" class="headerlink" title="使用 @Import 注解结合 Registrar 动态注册 BeanDefinition"></a>使用 @Import 注解结合 Registrar 动态注册 BeanDefinition</h4><blockquote>
<p><code>@Import</code>注解</p>
<ul>
<li>Allows for importing <code>@Configuration</code> classes, <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ImportSelector.html"><code>ImportSelector</code></a> and <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ImportBeanDefinitionRegistrar.html"><code>ImportBeanDefinitionRegistrar</code></a> implementations, as well as regular <strong>component</strong> classes</li>
</ul>
<p><strong>将一个类或多个类注入到 Spring 的 IOC 容器中</strong>，等价于在配置类中手动用 <code>@Bean</code> 或 <code>@ComponentScan</code> 注册。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20250423120651325.png" alt="三种等价的导入方式" style="zoom: 35%;" />

<p><code>ImportBeanDefinitionRegistrar</code>   它通常与 <code>@Import</code> 注解一起使用，允许开发者在 Spring 容器启动时通过编程方式向容器中动态注册 Bean。</p>
<ul>
<li>动态注册 Bean：通过实现 <code>ImportBeanDefinitionRegistrar</code>接口，可以在运行时根据需要向 Spring 容器中注册 Bean。</li>
<li>扩展 Spring 配置：允许开发者在 Spring 的配置阶段插入自定义逻辑，动态调整 Bean 的定义和注册。</li>
</ul>
<p><code>ImportSelector</code> 例如 <code>AutoConfigurationImportSelector</code> 实现自动装配的核心</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(MyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableMyFeature &#123;&#125;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(</span></span><br><span class="line"><span class="params">            AnnotationMetadata importingClassMetadata, // 被<span class="meta">@Import</span>注解的类，这里是 EnableMyFeature 接口的信息（关键）</span></span><br><span class="line"><span class="params">            BeanDefinitionRegistry registry  // 用于注册 Bean 定义的注册表，开发者可以通过它向容器中动态添加 Bean</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(MyService.class);</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;myService&quot;</span>, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableMyFeature</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如上，相当于在底层手动注册了一个类到IoC容器中。</p>
<p>Spring 的 <code>ConfigurationClassPostProcessor</code> 在处理 <code>@Import</code> 时，<strong>会检查被导入的类是否实现了 <code>Aware</code> 接口（如 <code>EnvironmentAware</code>、<code>ResourceLoaderAware</code>、<code>BeanFactoryAware</code> 等）</strong>，并会调用对应的方法注入你需要的对象（resourceLoader environment beanFactoryAware）等。为了以防万一，让自定义的Registerar实现ResourceLoaderAware，重写其setLoader，设置好scanner以后再扫描</p>
</blockquote>
<p>自定义 Rpc 组件扫描注解<br><code>RpcComponentScan</code> 注解用 <code>@Import</code> 引入了 <code>RpcBeanDefinitionRegistrar</code> 类，而这个类是一个 <code>ImportBeanDefinitionRegistrar</code> 的实现类， Spring 容器在解析该类型的 Bean 时会调用其 <code>importBeanDefRegistrar.registerBeanDefinitions(AnnotationMetadata, BeanDefinitionRegistry)</code> 方法， 将 <code>@RpcComponentScan</code> 注解上的信息提取成 <code>AnnotationMetadata</code> 以及容器注册器对象作为此方法的参数，这个就是自定义注解式组件扫描的关键逻辑。</p>
<p>metadata.getAnnotationAttributes(RpcComponent.class.getName()) 返回 RpcComponent 注解的属性和值(basePackages)，是一个map。从attributes中提取basePackages的值。未指定则扫描被注解类所在的包。随后构建一个扫描器，添加针对自定义注解的过滤器，开始扫描（注册）</p>
<hr>
<h4 id="Bean-处理器"><a href="#Bean-处理器" class="headerlink" title="Bean 处理器"></a>Bean 处理器</h4><p>@RpcService 注解</p>
<p><code>RpcServerBeanPostProcessor</code> 实现了 BeanPostProcessor</p>
<p>有服务注册、RpcServer、以及RpcServerProperties 3个字段。</p>
<p><code>public Object postProcessAfterInitialization(Object bean, String beanName)</code> 重写此方法配置好服务 Bean： 如果当前的bean被RpcService注解标注（也就是服务类的实现类），获取其注解的值，得到其暴露的接口的对象，由此得到接口名字，和版本拼接形成服务名，再根据properties配置构建好 ServiceInfo，<strong>然后进行服务注册，在本地缓存map加入服务bean</strong>.</p>
<p>还实现了 CommandLineRunner：新开一个线程启动服务器，增加关闭勾子强制清除注册中心的连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; rpcServer.start(properties.getPort())).start();</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 当服务关闭之后，将服务从 注册中心 上清除（关闭连接）</span></span><br><span class="line">            serviceRegistry.destroy();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RpcReference：利用反射把-Bean-的字段替换成代理对象"><a href="#RpcReference：利用反射把-Bean-的字段替换成代理对象" class="headerlink" title="@RpcReference：利用反射把 Bean 的字段替换成代理对象"></a><code>@RpcReference</code>：利用反射把 Bean 的字段替换成代理对象</h3><p>定义了<strong>接口类型</strong>、版本号、<strong>负载均衡</strong>、<strong>超时时间</strong>、mock，可以在字段、方法、注解上面使用</p>
<p>自动配置：除去负载均衡、服务发现、客户端类型，还有<strong>代理工厂</strong>、RpcClientBeanPostProcessor、RpcClientExitDisposableBean（这些都是需要注入 bean 的参数的）</p>
<p>客户端这边唯一的问题是 RestController 里面，出现 HelloService 字段，需要将其进行替换为代理对象。</p>
<p>如果字段被 @RpcReference 注解，那么就从注解中提取相关信息（接口全限定名+版本号），交给代理工厂生产代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    Field[] fields = bean.getClass().getDeclaredFields();</span><br><span class="line">    <span class="comment">// 遍历所有属性</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">        <span class="comment">// 判断是否被 RpcReference 注解标注</span></span><br><span class="line">        <span class="keyword">if</span> (field.isAnnotationPresent(RpcReference.class)) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);<span class="comment">// 关闭安全检查 因为是 private</span></span><br><span class="line">            field.set(bean, proxy); <span class="comment">// 设置域的值为代理对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="SpringBoot-自动装配：自动装配框架内部的-Bean"><a href="#SpringBoot-自动装配：自动装配框架内部的-Bean" class="headerlink" title="SpringBoot 自动装配：自动装配框架内部的 Bean"></a><span id="autoconfig">SpringBoot 自动装配：自动装配框架内部的 Bean</span></h2><p>自动装配基于自动装配类，所以要把所有的bean都用bean方法的形式注册到容器中。</p>
<p>包括之前讲的 服务发现、服务注册、代理工厂、BeanPostProcessor、ConfigurationProperties等。</p>
<p>Bean 方法不需要使用Autowired在参数上注解！！！！</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><a href="https://javaguide.cn/system-design/framework/spring/spring-boot-auto-assembly-principles.html">SpringBoot 自动装配原理详解</a> </p>
<p>自动装配可以简单理解为：<strong>通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。</strong></p>
<ul>
<li>没有 Spring Boot 的时候，我们写一个 RestFul Web 服务，还首先需要自己写 Configuration 配置类，写 Bean 方法。</li>
<li>但有了 SpringBoot，只需要引入依赖，启动 SpringBootApplication 即可。</li>
</ul>
<blockquote>
<p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的<code>META-INF/spring.factories</code>文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SpringBoot 2.x  在 META-INF/spring.factories </span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">com.example.rpc.RpcServerAutoConfiguration</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># SpringBoot 3 在 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</span></span><br><span class="line"><span class="attr">com.example.rpc.RpcServerAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<p>没有 Spring Boot 的情况下，如果我们需要引入第三方依赖，需要手动配置，非常麻烦。但是，Spring Boot 中，我们直接引入一个 starter 即可。比如你想要在项目中使用 redis 的话，直接在项目中引入对应的 starter 即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>引入 starter 之后，我们通过少量注解和一些简单的配置就能使用第三方组件提供的功能了。</p>
</blockquote>
<h3 id="原理浅析"><a href="#原理浅析" class="headerlink" title="原理浅析"></a>原理浅析</h3><p>机制核心 @EnableAutoConfiguration (@SpringBootApplication 的一部分) </p>
<p>底层通过 @Import(AutoConfigurationImportSelector.class) 加载所有自动配置类（通过 spring.factories 找到） 这个ImportSelector很重要，通过 selectImport</p>
<p>方法扫描获取所有符合条件的类的全限定类名，将这些类注册到 IoC 容器。核心调用路径如下：</p>
<p><code>selectImport-&gt;getAutoConfigurationEntry-&gt;getCandidateConfigurations-&gt;SpringFactoriesLoader.loadFactoryNames-&gt;loadSpringFactories</code> 不光是这个依赖下的<code>META-INF/spring.factories</code>被读取到，所有 Spring Boot Starter 下的<code>META-INF/spring.factories</code>都会被读取到。后边会根据条件进行逐层筛选。</p>
<h3 id="示例-创建-starter"><a href="#示例-创建-starter" class="headerlink" title="示例 创建 starter"></a>示例 创建 starter</h3><blockquote>
<p>引入 starter-validation</p>
<p>@Validated注解加到类上，下面这些注解可以用到 字段、参数</p>
<p>@NotBlank @Email  @Min(1)  @Max(91)</p>
<p>@Pattern(regexp = “^[a-zA-Z0-9]{8,16}$”,message = “用户名只能是长度在8至16”      + “之间的包含数字和大小写字母的字符串”)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;rpc.server&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcServerProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String address;<span class="keyword">private</span> Integer port;<span class="keyword">private</span> String appName;</span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;zookeeper|nacos&quot;, message = &quot;必须是 nacos或者zookeeper&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String registry;</span><br><span class="line">    <span class="keyword">private</span> String transport;<span class="keyword">private</span> String registryAddr;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcServerProperties</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">        <span class="built_in">this</span>.port = <span class="number">8080</span>;</span><br><span class="line">        <span class="built_in">this</span>.appName = <span class="string">&quot;provider-1&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.registry = <span class="string">&quot;zookeeper&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.transport = <span class="string">&quot;netty&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.registryAddr = <span class="string">&quot;127.0.0.1:2181&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pojo 类 + @ConfigurationProperties注解，可在 application.yml 中按照前缀配置属性。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">rpc.server.app-name</span>=<span class="string">provider-1</span></span><br><span class="line"><span class="attr">rpc.server.port</span>=<span class="string">9991</span></span><br><span class="line"><span class="attr">rpc.server.registry</span>=<span class="string">zookeeper</span></span><br><span class="line"><span class="attr">rpc.server.registry-addr</span>=<span class="string">39.108.66.202:2181</span></span><br><span class="line"><span class="attr">rpc.server.transport</span>=<span class="string">netty</span></span><br><span class="line"><span class="comment"># 设置指定包下的日志显示级别 INFO/DEBUG/WARNING/OFF</span></span><br><span class="line"><span class="attr">logging.level.com.wxy.rpc</span>=<span class="string">info</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>@ConditionalOnProperty</code></td>
<td>属性Property，满足一定的条件才生效</td>
</tr>
<tr>
<td><code>@ConditionalOnMissingBean</code></td>
<td>只有没有这个类型的 Bean 时才生效 (用户自定义实现了Bean方法，可以替换这个自动装配的)</td>
</tr>
<tr>
<td><code>@ConditionalOnClass</code></td>
<td>类路径下有某个类才生效</td>
</tr>
<tr>
<td><code>@ConditionalOnBean</code></td>
<td>依赖的 Bean 存在才生效</td>
</tr>
<tr>
<td><code>@Primary</code></td>
<td>多个同类的 Bean 存在时首选注入</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RpcServerProperties.class)</span> <span class="comment">// 绑定 pojo 作为 properties</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcServerAutoConfiguration</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RpcServerProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.server&quot;, name = &quot;registry&quot;, havingValue = &quot;zookeeper&quot;, matchIfMissing = true)</span><span class="comment">// property 的 registry 字段的 value = zookeeper 才生效，如果配置项不存在也会生效</span></span><br><span class="line">    <span class="keyword">public</span> ServiceRegistry <span class="title function_">serviceRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(properties.get)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ZookeeperServiceRegistry</span>(properties.getRegistryAddr());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.server&quot;, name = &quot;registry&quot;, havingValue = &quot;nacos&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ServiceRegistry <span class="title function_">nacosServiceRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NacosServiceRegistry</span>(properties.getRegistryAddr());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(&#123;ServiceRegistry.class, RpcServer.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> RpcServerBeanPostProcessor <span class="title function_">rpcServerBeanPostProcessor</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Autowired</span> ServiceRegistry serviceRegistry,</span></span><br><span class="line"><span class="params">		<span class="meta">@Autowired</span> RpcServer rpcServer,</span></span><br><span class="line"><span class="params">        <span class="meta">@Autowired</span> RpcServerProperties properties)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RpcServerBeanPostProcessor</span>(serviceRegistry, rpcServer, properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：添加 <code>spring-boot-starter-data-redis</code> 后，可直接注入 <code>RedisTemplate</code>。</p>
<table>
<thead>
<tr>
<th align="left">特征</th>
<th align="left">Starter 模块</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>命名</strong></td>
<td align="left">以 <code>-spring-boot-starter</code> 结尾</td>
</tr>
<tr>
<td align="left"><strong>依赖</strong></td>
<td align="left">包含 <code>spring-boot-autoconfigure</code></td>
</tr>
<tr>
<td align="left"><strong>自动配置</strong></td>
<td align="left">有 <code>@AutoConfiguration</code> 类，并注册到 <code>spring.factories</code> 或 <code>AutoConfiguration.imports</code></td>
</tr>
<tr>
<td align="left"><strong>配置属性</strong></td>
<td align="left">包含 <code>@ConfigurationProperties</code> 类</td>
</tr>
<tr>
<td align="left"><strong>功能入口</strong></td>
<td align="left">提供开箱即用的 Bean，无需用户手动配置。可通过 <code>application.properties</code> 或 <code>@Bean</code> 覆盖 Starter 的默认配置。</td>
</tr>
</tbody></table>
<ol>
<li><p>实现自动配置类 AutoConfiguration </p>
</li>
<li><p>按照 SpringBoot 版本将配置类的全限定名引入指定路径下。</p>
</li>
<li><p>新建 starter 模块，添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 必须依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可选：配置注解处理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 你的模块核心实现 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rpc-server-spring-boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="项目使用"><a href="#项目使用" class="headerlink" title="项目使用"></a>项目使用</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li>操作系统：Windows + Linux</li>
<li>集成开发工具：IntelliJ IDEA</li>
<li>项目技术栈：SpringBoot 2.5.2 + JDK 1.8 + Netty 4.1.65.Final</li>
<li>项目依赖管理工具：Maven 4.0.0</li>
<li>注册中心：Zookeeeper 3.7.1</li>
</ul>
<h2 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h2><ul>
<li>启动 Zookeeper 服务器：进入到zk的bin目录，输入命令 <code>./zkServer.sh</code></li>
<li>启动 provider 模块 ProviderApplication</li>
<li>启动 consumer 模块 ConsumerApplication</li>
<li>测试：浏览器输入 <a href="http://localhost:8080/hello/zhangsan">http://localhost:8080/hello/zhangsan</a> ，成功返回：<code>hello, zhangsan</code>，rpc 调用成功。</li>
<li>调用接口 100 次耗时 26ms，调用 10_0000 次耗时 25164 ms。</li>
</ul>
<h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><p><strong><a href="https://zhuanlan.zhihu.com/p/434083702">JMH</a></strong></p>
<p><code>JMH</code>即<code>Java Microbenchmark Harness</code>，是<code>Java</code>用来做基准测试的一个工具，该工具由<code>OpenJDK</code>提供并维护，测试结果可信度高。</p>
<p>相对于 Jmeter、ab ，它通过编写代码的方式进行压测，在特定场景下会更能评估某项性能。</p>
<p>本次通过使用 JMH 来压测 RPC 的性能（官方也是使用JMH压测）</p>
<p>启动 10000 个线程同时访问 sayHello 接口，总共进行 3 轮测试，测试结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Benchmark                                          Mode     Cnt      Score       Error  Units</span><br><span class="line">BenchmarkTest.testSayHello                        thrpt       3  29288.573 ± 20780.318  ops/s</span><br><span class="line">BenchmarkTest.testSayHello                         avgt       3      0.532 ±     6.159   s/op</span><br><span class="line">BenchmarkTest.testSayHello                       sample  395972      0.382 ±     0.002   s/op</span><br><span class="line">BenchmarkTest.testSayHello:testSayHello·p0.00    sample              0.003               s/op</span><br><span class="line">BenchmarkTest.testSayHello:testSayHello·p0.50    sample              0.318               s/op</span><br><span class="line">BenchmarkTest.testSayHello:testSayHello·p0.90    sample              0.387               s/op</span><br><span class="line">BenchmarkTest.testSayHello:testSayHello·p0.95    sample              0.840               s/op</span><br><span class="line">BenchmarkTest.testSayHello:testSayHello·p0.99    sample              2.282               s/op</span><br><span class="line">BenchmarkTest.testSayHello:testSayHello·p0.999   sample              2.470               s/op</span><br><span class="line">BenchmarkTest.testSayHello:testSayHello·p0.9999  sample              2.496               s/op</span><br><span class="line">BenchmarkTest.testSayHello:testSayHello·p1.00    sample              2.508               s/op</span><br><span class="line">BenchmarkTest.testSayHello                           ss       3      0.118 ±     0.051   s/op</span><br></pre></td></tr></table></figure>

<p>测试曲线图：</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/rpc10000并发测试结果.png">

<p>同时，在同样的条件下，启动 5000（1w个电脑会卡死） 个线程同时对 <strong>Dubbo2.7.14</strong> 发起 RPC 调用，得到的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Benchmark                                       Mode     Cnt      Score      Error  Units</span><br><span class="line">StressTest.testSayHello                        thrpt       3  41549.866 ± 9703.455  ops/s</span><br><span class="line">StressTest.testSayHello                         avgt       3      0.119 ±    0.034   s/op</span><br><span class="line">StressTest.testSayHello                       sample  611821      0.123 ±    0.001   s/op</span><br><span class="line">StressTest.testSayHello:testSayHello·p0.00    sample              0.042              s/op</span><br><span class="line">StressTest.testSayHello:testSayHello·p0.50    sample              0.119              s/op</span><br><span class="line">StressTest.testSayHello:testSayHello·p0.90    sample              0.129              s/op</span><br><span class="line">StressTest.testSayHello:testSayHello·p0.95    sample              0.139              s/op</span><br><span class="line">StressTest.testSayHello:testSayHello·p0.99    sample              0.195              s/op</span><br><span class="line">StressTest.testSayHello:testSayHello·p0.999   sample              0.446              s/op</span><br><span class="line">StressTest.testSayHello:testSayHello·p0.9999  sample              0.455              s/op</span><br><span class="line">StressTest.testSayHello:testSayHello·p1.00    sample              0.456              s/op</span><br><span class="line">StressTest.testSayHello                           ss       3      0.058 ±    0.135   s/op</span><br></pre></td></tr></table></figure>



<p><strong>结果</strong>：<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/dubbo5000并发测试结果.png"></p>
<table>
<thead>
<tr>
<th></th>
<th>RPC</th>
<th>RPC</th>
<th>Dubbo2.7.14</th>
</tr>
</thead>
<tbody><tr>
<td>并发数</td>
<td>10000</td>
<td>5000</td>
<td>5000</td>
</tr>
<tr>
<td>TPS</td>
<td>29288</td>
<td>31675</td>
<td>41549</td>
</tr>
<tr>
<td>RTT</td>
<td>95% 8ms</td>
<td>xxx</td>
<td>95% 50ms</td>
</tr>
<tr>
<td>AVGTime/OP</td>
<td>0.532</td>
<td>0.532</td>
<td>0.119</td>
</tr>
<tr>
<td>OOM</td>
<td>无</td>
<td>无</td>
<td>无</td>
</tr>
</tbody></table>
<p>对比了 jmeter、Apache-Benmark（ab）、jmh 这三个压测工具，个人比较推荐使用jmh，原因有：</p>
<ul>
<li>jmh压测简单，只需要引入依赖，声明注解</li>
<li>准确性高，目前大多数性能压测都是使用jmh</li>
<li>缺点就是代码入侵</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>netty</tag>
        <tag>spring</tag>
        <tag>spring-boot</tag>
        <tag>annotation</tag>
        <tag>自动装配</tag>
        <tag>动态代理</tag>
        <tag>spi</tag>
        <tag>bean-lifecyle</tag>
        <tag>bean-registry</tag>
        <tag>负载均衡</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>Java SE</title>
    <url>/2024/10/01/se-java/</url>
    <content><![CDATA[<h1 id="面向对象、基本语法"><a href="#面向对象、基本语法" class="headerlink" title="面向对象、基本语法"></a>面向对象、基本语法</h1><p>一个java文件内只能有1个public class 且public class名字需与文件名相同</p>
<p>生成类文件的名字=class名，几个类几个名字</p>
<p>运行的时候是按照类运行的，因此一个java文件里不同的类可以有不同的main</p>
<h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><p>在刷算法题时，Java 的常用包可以帮助你解决各种问题。以下是一些常见的包：</p>
<ol>
<li><p><strong>基础包</strong>（默认无需导入，属于 <code>java.lang</code>，直接使用）：</p>
<ul>
<li><code>java.lang</code>：包含基础类如 <code>String</code>, <code>Math</code>, <code>Integer</code>, <code>System</code>，它们是自动导入的，不需要显式导入。</li>
</ul>
</li>
<li><p><strong>集合框架</strong>：</p>
<ul>
<li><code>java.util.*</code>：包括大多数数据结构和集合类，常用于算法题：<ul>
<li><code>ArrayList</code>, <code>LinkedList</code>：动态数组和链表。</li>
<li><code>HashMap</code>, <code>TreeMap</code>, <code>LinkedHashMap</code>：哈希表和有序映射。</li>
<li><code>HashSet</code>, <code>TreeSet</code>：哈希集合和有序集合。</li>
<li><code>PriorityQueue</code>：优先队列（常用于堆排序、最小堆、最大堆）。</li>
<li><code>Stack</code>：栈结构。</li>
<li><code>Deque</code>, <code>ArrayDeque</code>：双端队列。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>并发包</strong>：</p>
<ul>
<li><code>java.util.concurrent.*</code>：多线程工具和并发数据结构。</li>
</ul>
</li>
<li><p><strong>数学计算</strong>：</p>
<ul>
<li><code>java.math.BigInteger</code> 和 <code>java.math.BigDecimal</code>：用于处理大整数和高精度小数。</li>
<li><code>java.util.Random</code>：生成随机数。</li>
</ul>
</li>
<li><p><strong>输入输出</strong>（用于处理大规模输入输出）：</p>
<ul>
<li><code>java.io.*</code>：包括 <code>BufferedReader</code>、<code>InputStreamReader</code> 等，常用于高效输入读取。</li>
<li><code>java.util.Scanner</code>：常用于简单的控制台输入。</li>
</ul>
</li>
<li><p><strong>时间处理</strong>：</p>
<ul>
<li><code>java.time.*</code>：处理日期和时间类（如果题目涉及日期计算）。</li>
</ul>
</li>
</ol>
<h3 id="常用导入："><a href="#常用导入：" class="headerlink" title="常用导入："></a>常用导入：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">// 通用集合框架</span></span><br><span class="line"><span class="keyword">import</span> java.math.*;  <span class="comment">// 高精度数学计算</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;    <span class="comment">// 文件、输入输出</span></span><br></pre></td></tr></table></figure>

<p>这些包涵盖了绝大多数算法题目需要的工具和数据结构。如果你有特定类型的题目或需求，也可以进一步讨论合适的导入包。</p>
<h2 id="基本数据类型-2024-9-9"><a href="#基本数据类型-2024-9-9" class="headerlink" title="基本数据类型 2024.9.9"></a>基本数据类型 2024.9.9</h2><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><p>char <strong>2</strong> byte</p>
<p>路径 \\ 转义字符</p>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>0x hex 、 0 oct    byte short int long </p>
<p>整数全部是int型，数字超出int范围后面要加L <code>long number = 666666666666L  </code></p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>4e3 ⇔ 4000 这是一个浮点数 默认为double </p>
<p>float 32  double 64 </p>
<p>浮点数全部是double型，数字如果是float型后边必须要加上f</p>
<p>double类型不能给float类型赋值。 char 型可以兼容整型，也可以看成16位整型</p>
<table>
<thead>
<tr>
<th align="left"><strong>数据类型</strong></th>
<th align="left"><strong>默认值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">0L</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">0.0f</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">0.0d</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">‘\u0000’</td>
</tr>
<tr>
<td align="left">String (or any object)</td>
<td align="left">null</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">false</td>
</tr>
</tbody></table>
<h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><ul>
<li><p>隐式(自动) 基本数据类型中除了boolean其他都兼容</p>
<ul>
<li>byte, short, char -&gt;int-&gt;long-&gt;float-&gt;double</li>
<li>byte+short 在表达式中参与运算自动提升为int 小类型自动转换成大类型</li>
<li></li>
</ul>
</li>
<li><p>强制转换</p>
<ul>
<li><p>小数转换成整数，保留整数部分 <code>double a = 1.2 </code> <code>int b = (int) a</code>  </p>
</li>
<li><p>四舍五入</p>
</li>
</ul>
</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> Math.PI;</span><br><span class="line">pi = pi * <span class="number">10000</span> + <span class="number">0.5</span>;</span><br><span class="line">pi = (<span class="type">int</span>)pi;</span><br><span class="line">pi = pi / <span class="number">10000</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">pi_2</span> <span class="operator">=</span> Math.PI;</span><br><span class="line"><span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> Math.round(pi_2 * <span class="number">10000</span>);</span><br><span class="line">pi_2 = i / <span class="number">10000.0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li>比较运算符 H <strong>instanceof</strong> Human H是否属于Human类型</li>
</ul>
<ul>
<li><p><strong>位运算符</strong> （整数） &gt;&gt;&gt; </p>
</li>
<li><p><strong>自增自减</strong>  i++ 的值等于i      ++i的值等于i+1</p>
</li>
<li><p><strong>取模</strong> 值只跟被模数有关 </p>
</li>
<li><p><strong>扩展赋值运算符</strong>：包含强制类型转换</p>
</li>
<li><p><strong>逻辑运算符</strong> </p>
<ul>
<li><p>&amp;&amp; 第一个false 不会判断 优先级较高</p>
</li>
<li><p>||  第一个true不会判断剩下的</p>
</li>
<li><p>^ 异或 相同false 不同true</p>
</li>
</ul>
</li>
</ul>
<h2 id="API-from-JDK"><a href="#API-from-JDK" class="headerlink" title="API from JDK"></a>API from JDK</h2><h3 id="Switch语句简化"><a href="#Switch语句简化" class="headerlink" title="Switch语句简化"></a>Switch语句简化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">dayName</span> <span class="operator">=</span> <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> -&gt; <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> -&gt; <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span> -&gt; <span class="string">&quot;Wednesday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span> -&gt; <span class="string">&quot;Thursday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span> -&gt; <span class="string">&quot;Friday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span> -&gt; <span class="string">&quot;Saturday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span> -&gt; <span class="string">&quot;Sunday&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid day: &quot;</span> + day);</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(dayName); <span class="comment">// 输出: Wednesday</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JDK12开始引入的写法，可以避免贯穿效应，并能直接在后面执行一个语句或者返回一个值</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;asd&quot;</span> <span class="comment">//常量池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(字符数组、字节数组)<span class="comment">//一般的堆</span></span><br></pre></td></tr></table></figure>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><code>str.toCharArray()</code>  返回一个字符数组</p>
<p><code>str.charAt(2)</code>   返回str[2]的字符</p>
<p><code>str1.equals(str2)</code> s1与s2是否相同</p>
<p><code>str1.equalsIgnoreCase(str2)</code> s1与s2是否相同 <strong>忽略大小写</strong> </p>
<p><code>str.substring(0,8)</code> 字符串截断</p>
<p><code>str.replace(x,y)</code> 将x替换成y</p>
<p><code>str.contains(&quot;Java&quot;)</code> 是否包含Java</p>
<p><code>str.startsWith(&quot;A&quot;)</code> 是否以A开头</p>
<p><code>str.split(&#39;,&#39;)</code> Split with PERIOD ‘,’</p>
<p><code>int compareToIgnoreCase(String str)</code> 按照字典顺序比较两个字符串，忽略大小写</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><p>用str = “aaa” 的方式，会把字符串存在<strong>字符常量池</strong>，内容相同只存储一份</p>
</li>
<li><p>用str = new String(“aaa”)的方式，每一次都new一个新对象存在堆中</p>
</li>
<li><p><strong>String是不可变对象</strong>，不可变性（Immutability）的含义 </p>
</li>
<li><p>只要对String进行操作，就要<u>创建新的字符串对象</u>，而非修改原有字符串。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">str = str + <span class="string">&quot; World&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>str + &quot; World&quot;</code> 实际上创建了一个新的 <code>String</code> 对象，包含 “Hello World”，而原来的 <code>&quot;Hello&quot;</code> 对象仍然存在于内存中，并没有被修改。<code>str</code> 变量此时指向了这个新的对象。为什么 <code>String</code> 是不可变的？</p>
<ol>
<li><p><strong>安全性（Security）</strong>：不可变的对象可以避免在多个线程之间共享数据时的并发问题。由于 <code>String</code> 的值不会被改变，因此可以安全地在多个地方或多个线程中使用，而不必担心被其他代码修改。</p>
</li>
<li><p><strong>性能优化（String Pool）</strong>：Java 中有一个叫做 <strong>字符串常量池（String Pool）</strong> 的机制，当你创建一个 <code>String</code> 对象时，如果该字符串值已经存在于常量池中，那么不会重新创建对象，而是复用已有的对象。不可变性确保了这个机制的有效性，因为相同的 <code>String</code> 实例永远不会被修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>s1</code> 和 <code>s2</code> 实际上引用了常量池中的同一个 <code>String</code> 对象。</p>
<p><strong>3.  哈希值缓存</strong>：由于 <code>String</code> 对象不可变，它的哈希值只需要计算一次，可以缓存下来以提高哈希表操作的效率（如在 <code>HashMap</code> 中用作键）。如果 <code>String</code> 是可变的，那么它的哈希值也会随之变化，影响哈希表的正确性。 </p>
</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240910180312621.png" alt="image-20240910180312621"></p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>大小可变的 <strong>容器</strong>，auto extension </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240910193135775.png" alt="image-20240910193135775"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>add 方法可重载 <code>add(Object o);</code> </p>
<p>注意 remove 方法会让整体左移，元素对应的索引会变化，会影响遍历的索引</p>
<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>)  <span class="comment">//0-9</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>,<span class="number">31</span>)  <span class="comment">// [10,31) 不包含31</span></span><br></pre></td></tr></table></figure>

<h3 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> sc.nextInt();</span><br></pre></td></tr></table></figure>

<h2 id="数组-2024-9-10"><a href="#数组-2024-9-10" class="headerlink" title="数组 2024.9.10"></a>数组 2024.9.10</h2><h3 id="静态数组"><a href="#静态数组" class="headerlink" title="静态数组"></a>静态数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] data1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] data2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">//简化写法</span></span><br></pre></td></tr></table></figure>

<p>引用数据类型 引用相当于是对象的地址</p>
<h3 id="动态数组（非动态长度）"><a href="#动态数组（非动态长度）" class="headerlink" title="动态数组（非动态长度）"></a>动态数组（非动态长度）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] data1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p><code>double 0.0</code> <code>int 0 </code> <code>boolean false </code> <code>String null</code> (<u>引用数据类型</u>) </p>
<p>new一个对象，就会在堆上创建空间，然后将空间的地址传给栈中的引用</p>
<h3 id="引用数据类型做参数"><a href="#引用数据类型做参数" class="headerlink" title="引用数据类型做参数"></a>引用数据类型做参数</h3><p>引用相当于封装好的指针，只能指向对象，可以通过它对<strong>对象</strong>进行操作，引用数据类型做参数，实际上是一个引用的拷贝，通过它可以操作对象，但是不能通过修改它来让真实的引用指向一个新的对象。修改对象就行了，没事修改人家引用干啥呢！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Personnel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modifyPerson</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        person = <span class="keyword">new</span> <span class="title class_">Person</span>();  <span class="comment">// 修改引用，指向新的对象  不可以</span></span><br><span class="line">        person.name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.name = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        modifyPerson(p);</span><br><span class="line">        System.out.println(p);  <span class="comment">// 仍然输出 &quot;Bob&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java的参数都是值传递，也就是副本传递。main 中 p的值始终不变， 进入modify方法之后，一开始person也是p的值，但是无法通过更改person的指向 来 更改p的指向</p>
<h3 id="方法的重载："><a href="#方法的重载：" class="headerlink" title="方法的重载："></a><strong>方法的重载</strong>：</h3><p>必须要有不同的<strong>参数列表</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">function</span><span class="params">(String... args)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">function</span><span class="params">(String [] args)</span>;</span><br></pre></td></tr></table></figure>

<p>这两种方法是等价的</p>
<h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><ul>
<li><p>类名大写</p>
</li>
<li><p>不用赋初值</p>
</li>
<li><p>xx.java 中只能有一个public class 且名字必须叫xx 可以有多个class</p>
</li>
<li><p>对象失去引用，将成为垃圾无法被操作</p>
</li>
<li><p>this 用在<strong>方法内</strong> 用于拿到当前的对象 调用方法的时候this会自动接收当前对象的引用(防止对象的成员变量和方法内部的变量名称相同产生冲突)</p>
</li>
</ul>
<h3 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h3><p>构造函数，可重载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">double</span> score)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建对象的同时完成初始化赋值</li>
<li>不写构造函数会自动生成无参构造</li>
<li>如果定义了有参构造，<strong>不会自动生成</strong>无参构造了</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>合理隐藏，合理暴露，考虑安全性</p>
<p>public(any)&gt;protected(继承类)&gt;friendly(同一package的类)&gt;private(只有当前类才有资格访问)</p>
<h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><ul>
<li>变量私有，方法公开（get set 右键快捷生成）</li>
<li>必有公开的无参构造</li>
<li><strong>实体类</strong>负责数据存取，处理数据交给<strong>业务类</strong>来完成</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentOperator</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Student student;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">StudentOperator</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.student = student;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JavaBean-vs-POJO"><a href="#JavaBean-vs-POJO" class="headerlink" title="JavaBean vs. POJO"></a>JavaBean vs. POJO</h3><p>JavaBean 和 POJO 的区别主要在于它们的用途和规范化程度：</p>
<ol>
<li><p><strong>JavaBean</strong>：</p>
<ul>
<li><strong>定义</strong>：JavaBean 是一种特殊的 Java 类，通常遵循严格的规范。它主要用于开发可复用的组件，尤其是在 Java EE 应用程序中，JavaBean 被广泛用于数据传输对象（DTO）、表单数据和企业级应用中。</li>
<li><strong>规范</strong>：<ul>
<li>必须有一个<strong>无参构造函数</strong>。</li>
<li>所有的属性（成员变量）必须是<strong>私有的</strong>（<code>private</code>），并通过<strong>getter</strong> 和 <strong>setter</strong> 方法进行访问。</li>
<li>必须实现 <strong>Serializable</strong> 接口（可选，但常见）。</li>
</ul>
</li>
<li><strong>应用场景</strong>：JavaBean 常用于 Java EE（例如 JSP、Servlet）中与视图层交互的数据封装，也可用于一些持久层框架如 Hibernate 和 Spring。</li>
</ul>
</li>
<li><p>**POJO (Plain Old Java Object)**：</p>
<ul>
<li><strong>定义</strong>：POJO 是一个普通的 Java 对象，没有任何特殊的要求或规范。它是最普通的 Java 类，通常只用来封装数据，避免依赖特定的框架或库。</li>
<li><strong>规范</strong>：没有严格的要求，可以有构造函数、任意修饰符的属性，甚至没有 getter 和 setter 方法。</li>
<li><strong>应用场景</strong>：POJO 被广泛用于各种场景中，特别是作为轻量级的数据承载类。它不依赖于任何框架的 API，目的是使代码更加简洁和易于维护。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：</p>
<ul>
<li><strong>JavaBean</strong> 是一种受规范约束的 POJO，适合组件开发和框架集成。</li>
<li><strong>POJO</strong> 是一个没有任何限制或依赖的 Java 类，更加灵活自由。</li>
</ul>
<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>局部变量：方法内 一般在栈中</p>
<p>成员变量：一般在类的声明中表现</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240910144323152.png" alt="image-20240910144323152"></p>
<p>out</p>
<h2 id="OOP-Advanced-2024-9-11"><a href="#OOP-Advanced-2024-9-11" class="headerlink" title="OOP Advanced 2024.9.11"></a>OOP Advanced 2024.9.11</h2><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><h4 id="修饰成员变量：类变量"><a href="#修饰成员变量：类变量" class="headerlink" title="修饰成员变量：类变量"></a>修饰成员变量：类变量</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> String name;<span class="comment">//所有类共享 （类变量）</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接通过类名访问：<code>Student.name = &quot;袁华&quot;</code> 只有一份 </p>
<ul>
<li>应用场景：某个数据只要一份（记住自己创建了多少个用户对象了）希望能够被共享、修改</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911105822932.png" alt="image-20240911105822932"></p>
<h4 id="类方法：属于类的方法"><a href="#类方法：属于类的方法" class="headerlink" title="类方法：属于类的方法"></a>类方法：属于类的方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printHelloworld</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line">Student.printHelloworld();</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911110754007.png" alt="image-20240911110754007"></p>
<ul>
<li>应用场景：工具类 提高代码复 用率</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911111331657.png" alt="image-20240911111331657"></p>
<h4 id="其他注意"><a href="#其他注意" class="headerlink" title="其他注意"></a>其他注意</h4><ul>
<li>static 方法 可以直接访问 static 成员变量 ，<u>不能访</u>问实例变量，不能有<strong>this</strong> </li>
<li>实例 方法 可以直接访问 static 成员变量和实例变量、方法，可以有<strong>this</strong> </li>
</ul>
<h5 id="应用：静态代码块-实例代码块"><a href="#应用：静态代码块-实例代码块" class="headerlink" title="应用：静态代码块 实例代码块"></a>应用：<strong>静态代码块 实例代码块</strong></h5><p>静态代码块：<mark>类加载的同时<mark>会加载静态代码块但只有一次，适用于静态变量的初始化</p>
<p>实例代码块：<mark>创建对象的时候<mark>执行，并在构造器<mark>之前<mark>执行，适用于非静态变量的初始化</p>
<h4 id="设计模式：单例"><a href="#设计模式：单例" class="headerlink" title="设计模式：单例"></a>设计模式：单例</h4><ul>
<li><p>一个类有且只有一个对象，创建对象之前就自己有了11:112311</p>
</li>
<li><p>私有构造器</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();<span class="comment">//自有，记住一个对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">A</span><span class="params">()</span>&#123;&#125;<span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title function_">getObject</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911114322070.png" alt="image-20240911114322070"> 上图为拿到一个<strong>对象</strong> <strong>以后</strong>才开始创建对象</p>
<h3 id="继承-extends"><a href="#继承-extends" class="headerlink" title="继承 extends"></a>继承 extends</h3><p>关键字：extends<code>public class B extends A</code> B能继承A的非私有成员和方法</p>
<h4 id="子类的访问"><a href="#子类的访问" class="headerlink" title="子类的访问"></a>子类的访问</h4><ul>
<li>子类不能直接访问父类的私有成员，但是他们<strong>仍然存在于子类对象中</strong>，父类的私有成员子类用get set方法可以完成访问或修改 /  (或者用父类的构造器)</li>
<li>父亲的私人物品儿子不能直接动，但是儿子能通过父亲认可的方法接触</li>
<li>子类方法中同名变量\方法的处理：优先调用方法中声明 的变量，<strong>this</strong>可以调用子类在方法外声明的，<strong>super</strong>可以调用父类声明的</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911115852654.png" alt="image-20240911115852654"></p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>本类</th>
<th>同一包的其他类(包括同一包的子类)</th>
<th>其他包的子类</th>
<th>其他包的其他类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>OK</td>
<td><strong>NO</strong></td>
<td><strong>NO</strong></td>
<td><strong>NO</strong></td>
</tr>
<tr>
<td>缺省</td>
<td>OK</td>
<td>OK</td>
<td><strong>NO</strong></td>
<td><strong>NO</strong></td>
</tr>
<tr>
<td>protected</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td><strong>NO</strong></td>
</tr>
<tr>
<td>public</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
</tr>
</tbody></table>
<ul>
<li><p>注意这些都是在对应的类 <strong>内部</strong> 才起作用 </p>
</li>
<li><p>java 单继承 ， 多层继承 ， 不支持多继承</p>
</li>
<li><p>所有类默认继承自<code>Object</code>类</p>
</li>
</ul>
<h4 id="子类的方法重写"><a href="#子类的方法重写" class="headerlink" title="子类的方法重写"></a>子类的方法重写</h4><ul>
<li><p>子类将父类的方法保持参数列表相同进行重写</p>
</li>
<li><p>用<code>@Override</code> 注解</p>
</li>
<li><p>子类的访问权限必须大于父类</p>
</li>
<li><p><code>private</code> 和 <code>static</code> 不能重写 </p>
</li>
<li><p>应用：println(A) 默认调用的是<code>A.toString()</code> 这是一个Object类的函数，返回地址信息，如果在A类重写toString函数就能改变,可以使用右键快捷生成toString函数</p>
</li>
</ul>
<h4 id="子类的构造器"><a href="#子类的构造器" class="headerlink" title="子类的构造器"></a>子类的<u>构造器</u></h4><ul>
<li><p>调用子类的构造器之前，自动调用父类的无参构造，默认存在<code>super()</code> </p>
</li>
<li><p>如果父类没有无参构造（有了有参构造），子类的构造器无法调用<code>super()</code> 就会报错，所以要在子类的构造器中手动调用 <code>super(name)</code>有参构造 </p>
</li>
<li><p>原因：子类中虽然不能直接操作父类的private成员，但是同样也是要有这些成员的，而且要避免一直调用父类的get set方法，那么子类构造时就要用<strong>父类的构造器</strong> 对父类的private成员进行初始化，再回来把对象里包含子类这部分数据赋值。</p>
</li>
<li><p>有参构造的重载：本来有三个参数，如果只接受两个参数，对其余的一个参数进行缺省设定，<code>this()</code> 就能调用本类的无参构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>(name, age, <span class="string">&quot;heima&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String schoolName)</span>&#123;</span><br><span class="line">	<span class="built_in">super</span>(name, age);</span><br><span class="line">	<span class="built_in">this</span>.schoolName = schoolName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>this()和super()不能同时出现在构造器中，都必须放在第一行</p>
</li>
</ul>
<h3 id="多态-polymorphism"><a href="#多态-polymorphism" class="headerlink" title="多态 polymorphism"></a>多态 polymorphism</h3><ul>
<li><p><strong>对象多态</strong>：父类的引用类型变量 可以指向子类的对象</p>
</li>
<li><p><strong>行为多态</strong>：子类中和父类<strong>同名(重写)的方法</strong>，在多态调用时采用子类的方法(new的是Teacher的无参构造)</p>
</li>
<li><p>编译看的是左边引用的类型，但是实际运行起来看的是右边的构造函数，但是多态 <strong>不包括</strong> 成员变量 Person p = new Student() </p>
</li>
<li><p>右边对象是解耦合的，比如前面用的是Student后边想换成Person可以直接换掉</p>
</li>
<li><p>用父类的引用形参能接受一切子类的对象</p>
<ul>
<li>多态下不能使用子类的 <strong>独有功能</strong>  <ul>
<li>Method1 父类中定义一个抽象方法</li>
<li>Method2 instanceof判定ifelse</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="多态的类型转换"><a href="#多态的类型转换" class="headerlink" title="多态的类型转换"></a><strong>多态的类型转换</strong></h4><p><strong>auto</strong> : <code>People p = new Teacher();</code> 小的自动转成大的</p>
<p><strong>force</strong>: <code>Teacher t = (Teacher)p;</code>大的必须强制才能转成小的 </p>
<p>编译阶段有继承或者实现关系就不会报错，但是运行会报<code>ClassCastException</code></p>
<p>Teacher有<code>teach() </code>Student 有<code>test()</code> ， 一个父类的引用person是无法调用他们的，必须类型转换</p>
<ul>
<li><p>但是如果p实际上是Student类，是无法强制转换成Teacher类的，引出 <code>instanceof</code> 运算符，结果是一个boolean类型的变量。</p>
</li>
<li><p>用父类的引用形参接受子类的对象，p instanceof Teacher = true 那么调用Teacher的独有功能，否则调用Student的独有功能</p>
</li>
</ul>
<h3 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h3><p>final 加在class上 类不能被继承， final加在方法上不能被重写，加在变量上 变量必须且仅能赋值一次   </p>
<p>static final 修饰的成员变量 String SCHOOL_NAME = “HEIMA” 相当于是 <strong>常量</strong></p>
<p>常量和直接用字面量性能一样</p>
<h3 id="抽象类-abstract-关键字"><a href="#抽象类-abstract-关键字" class="headerlink" title="抽象类 abstract 关键字"></a>抽象类 abstract 关键字</h3><ul>
<li><strong>抽象方法</strong> 只有方法签名，不能有具体的方法实现</li>
<li><strong>不能创建对象</strong> 只能作为父类让子类继承</li>
<li>如果一个类从抽象父类继承而来，除非重写完所有上一代的抽象方法，否则这个类也必须是抽象类</li>
<li>更好支持多态，父类知道子类都要做某个行为，但每个子类做的情况又不一样，父类就定义抽象方法，交给子类重写实现</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911172104015.png" alt="image-20240911172104015"></li>
</ul>
<h4 id="设计模式：模版方法"><a href="#设计模式：模版方法" class="headerlink" title="设计模式：模版方法"></a>设计模式：模版方法</h4><p>解决了什么问题：两个类的方法有大量的重复代码，仅仅有部分不同。</p>
<p>老师和学生都要写同一片作文，开头结尾相同，正文部分不一样，A B都需要<code>write()</code>且大量重复，抽象父类Father可以在<code>write()</code>写好重复的部分，插入抽象方法<code>body()</code>  并且父类的<code>write()</code>可以加<code>final</code>关键字，保证不被继承</p>
<h3 id="接口-interface-关键字"><a href="#接口-interface-关键字" class="headerlink" title="接口 interface 关键字"></a>接口 interface 关键字</h3><p>实现类 实现 接口  重写所有抽象方法</p>
<ul>
<li><p>方法 默认 <code>public</code> <code>abstract</code> </p>
</li>
<li><p>变量 默认 <code>public</code> <code> static</code> <code>final</code>（常量）</p>
</li>
<li><p>接口 不能 实例化，不能被类继承，可被类实现，可被接口继承</p>
</li>
<li><p>弥补单继承，可实现多接口(类似多继承)，一个类可以拥有更多的 能力(某专业方面的能力)</p>
</li>
<li><p>面向接口编程，业务实现的切换灵活，解耦，AB都实现了接口Driver Driver某一天想换人，直接new B就可以，AB都实现了drive方法。你是司机，你就必须会开车，这样的话想换司机只需要换人就可以，不需要额外增加方法 <code>Driver driver = new A();</code> <code>Driver driver = new B();</code> </p>
</li>
<li><p>同一个功能的多套方案：建立一个接口，用接口的抽象方法表示要实现的功能，然后分别做多个接口的实现类，把抽象方法具体化</p>
</li>
<li><p>JDK 8 new:  均非抽象方法，</p>
<ul>
<li>默认方法 default 接口 <strong>实现类的对象</strong> 才可以调用 用public修饰</li>
<li>私有方法 private 只有在接口 <strong>内部</strong> 才能访问</li>
<li>静态方法 static   只能通过 <strong>接口名调用</strong> 用public修饰 </li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911221630071.png" alt="image-20240911221630071"></li>
</ul>
<p>外部软件包访问本包接口，需要将接口设置为public</p>
</li>
</ul>
<h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><table>
<thead>
<tr>
<th align="left">区别点</th>
<th align="left">重载方法(同一个类)</th>
<th align="left">重写方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">参数列表</td>
<td align="left">必须修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">返回类型</td>
<td align="left">可以修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">异常</td>
<td align="left">可以修改</td>
<td align="left">可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td align="left">访问</td>
<td align="left">可以修改</td>
<td align="left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
</tbody></table>
<h3 id="内部类-9-12"><a href="#内部类-9-12" class="headerlink" title="内部类 9.12"></a>内部类 9.12</h3><ul>
<li><p>创建内部类对象：<code>Outer.Inner in = new Outer().new Inner();</code> 外部类.内部类</p>
<ul>
<li>内部类的方法访问内部类的成员变量 <code>this</code></li>
<li>Outer.this 返回外部类对象</li>
</ul>
</li>
<li><p>JDK16开始 可以定义内部类的静态成员</p>
</li>
<li><p>静态内部类：<code>public static class</code></p>
<ul>
<li><code>Outer.Inner in = new Outer.Inner();</code> </li>
<li>不需要创建外部对象就能获得内部类</li>
<li>可以访问外部类的静态成员</li>
</ul>
</li>
</ul>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><ul>
<li>本质上是一个子类，会立即创建出一个子类对象出来</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.cry();</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Animal这个抽象类不能实例化，在后面加一个大括号，然后在其中实现抽象方法，这样就创建了一个子类对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Swimming</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swimming</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Swim!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">    go(s1); <span class="comment">//输出 Swim！</span></span><br><span class="line">    go(<span class="keyword">new</span> <span class="title class_">Swimming</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Swim!2nd&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;)<span class="comment">//输出Swim！2nd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(Swimming s)</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;Go!&quot;</span>);</span><br><span class="line">	s.swim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Swimming</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>应用：快速创建子类对象，用于（interface）实现类对象作形参的情况 一般是被动去用</li>
<li>JFrame API: <code>button.addActionListener(ActionListener act)</code> <code>ActionListener</code> is an interface</li>
</ul>
<h3 id="枚举-enum-关键字"><a href="#枚举-enum-关键字" class="headerlink" title="枚举 enum 关键字"></a>枚举 enum 关键字</h3><ul>
<li><p> 特殊的class ，私有的构造器，只能创建固定数量的实例(对象)</p>
</li>
<li><p>如果有抽象方法，对象必须实现方法</p>
</li>
<li><p>遍历 for-each语句 没有索引，不能修改元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> number: numbers)&#123;</span><br><span class="line">	System.out.prinln(number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912125835772.png" alt="image-20240912125835772"></p>
</li>
</ul>
<p>枚举变量实际是常对象，用public static final 修饰，创建了X,Y,Z三个常对象，调用的是无参的构造器，也可以自己写有参构造器， </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912130046257.png" alt="image-20240912130046257"></p>
<h4 id="设计模式：单例-1"><a href="#设计模式：单例-1" class="headerlink" title="设计模式：单例"></a>设计模式：单例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">C</span>&#123;X;&#125;<span class="comment">//单例</span></span><br></pre></td></tr></table></figure>

<h4 id="信息标注"><a href="#信息标注" class="headerlink" title="信息标注"></a>信息标注</h4><p>常量输入的信息不受约束，用枚举做信息标注更好</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912131648801.png" alt="image-20240912131648801"></p>
<p>枚举做形参，方法内直接写出对应的枚举即可</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul>
<li><p>相当于是类做参数</p>
</li>
<li><p><code>ArrayList</code> 没有指出泛型，默认是<code>Object</code>对象</p>
</li>
<li><p><code>ArrayList&lt;String&gt;</code> 只能接受<code>String</code>类型的数据</p>
</li>
<li><p><code>ArrayList&lt;T extends Animal&gt;</code> 只能接受<code>Animal</code>子类</p>
</li>
<li><p><code>ArrayList&lt;T implements Driver&gt;</code> 只能接受<code>Driver</code>实现类</p>
</li>
<li><p>把数据类型作为参数传递给类型变量，相当于缺省，然后对类的成员进行赋值</p>
</li>
<li><p><em>使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组(<code>Object[] arr</code>)排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。</em> </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Data</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span>;</span><br><span class="line">	ArrayList&lt;T&gt; <span class="title function_">getByName</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">Data</span>&lt;Teacher&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Teacher teacher)</span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ArrayList&lt;Teacher&gt; <span class="title function_">getByName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//泛型接口</span></span><br></pre></td></tr></table></figure>

<ul>
<li>泛型方法 用<code>&lt;E&gt;</code>修饰，表明方法中存在缺省<strong>类型</strong> class E，可能在参数列表中，也可能在返回值中，也可能在具体的实现中 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span>&#123;</span><br><span class="line">      <span class="comment">// 输出数组元素            </span></span><br><span class="line">    <span class="keyword">for</span> ( E element : inputArray )&#123;     </span><br><span class="line">            System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">    &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912141719516.png" alt="image-20240912141719516"></p>
<ul>
<li><p>定义的时候在返回值前加泛型，单纯使用可以在ArrayList加通配符</p>
<ul>
<li><code>public static &lt;T&gt; void go (ArrayList&lt;T&gt; cars)</code> </li>
<li><code>public static void go (ArrayList&lt;?&gt; cars)</code> </li>
<li><code>&lt;?&gt;</code>表示能接收一切类型的ArrayList </li>
<li><code>&lt;? extends Car&gt;</code>表示能接收Car以及Car子类的ArrayList，也叫上限</li>
<li><code>&lt;? super Car&gt;</code>表示能接收Car以及Car父类的ArrayList ，也叫下限</li>
</ul>
</li>
<li><p><strong>泛型擦除：</strong> 编译阶段工作，class字节码文件中并不存在泛型，都是将 Object 对象 强转为 E 类型</p>
</li>
<li><p>泛型<strong>不支持基本数据类型</strong>，Integer Double 类型解决</p>
</li>
</ul>
<h2 id="API-from-JDK-2024-9-12"><a href="#API-from-JDK-2024-9-12" class="headerlink" title="API from JDK 2024.9.12"></a>API from JDK 2024.9.12</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><ul>
<li><p>Java Object 类是所有类的父类，也就是说 Java 的所有类都继承了 Object，<strong>子类可以使用 Object 的所有方法</strong>。</p>
</li>
<li><p>Object 类位于 java.lang 包中，编译时会自动导入，我们创建一个类时，如果没有明确继承一个父类，那么它就会自动继承 Object，成为 Object 的子类。</p>
</li>
<li><p><code>toString() 返回字符串形式</code> 可重写,以返回对象的内容</p>
</li>
<li><p><code>equals(Object o) 返回boolean </code>   判断对象是否相等 默认比较 <strong>地址</strong> 可重写成 比较两个的内容是否一样</p>
<ul>
<li>先判断地址是否一样</li>
<li>再判断是不是null/是不是同一个类</li>
<li>再判断变量是否相等 <code>return this.age == student.age &amp;&amp; Objects.equals(this.name,student.name)</code>  </li>
</ul>
</li>
<li><p><code>protected o clone()</code> 复制一个完全相同的Object对象，内容相同，属于<strong>浅拷贝</strong> 调用子类方法需要强转 。我们用的类跟Object源文件不在一个包下，所以子类要用<code>clone()</code>必须要重写，通过子类<code>super</code>间接调用父类Object的<code>clone()</code>。并且子类必须是接口<code>Cloneable</code>的实现类.</p>
</li>
<li><p>浅拷贝：<strong>对象中包含的其他对象</strong>，依然指向同一个对象(相当于直接把对象的地址也复制过去了) </p>
</li>
<li><p>深拷贝：浅拷贝+对象中包含的对象单独浅拷贝<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912230730643.png" alt="image-20240912230730643"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> (Animal)<span class="built_in">super</span>.clone();</span><br><span class="line">        a.arr = a.arr.clone();<span class="comment">//数组内部没有其他的对象，</span></span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h3><ul>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912233304677.png" alt="image-20240912233304677"></p>
</li>
<li><p>equals方法是为了避免空指针异常，s1.equals()，s1 = null 会报NullPointerException</p>
</li>
<li><p>```<br>public static boolean equals(Object a, Object b){</p>
<pre><code>return (a==b)||(a != null &amp;&amp; a.equals(b))
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 包装类 </span><br><span class="line"></span><br><span class="line">int -&gt; Integer      char -&gt;Character</span><br><span class="line"></span><br><span class="line">泛型和集合不支持基本数据类型，用包装类替代，有自动装箱和自动拆箱机制</span><br><span class="line"></span><br><span class="line">- `Integer.toString()` 将Integer对象转换成字符串 i.toString();</span><br><span class="line">- `Integer.toString(int i)` 将23这个数字转换成字符串 静态方法 </span><br><span class="line">  - arr[i] + &quot;&quot; 数字+空串也可以转换成字符串</span><br><span class="line">- `Double.parseDouble(String str)` 将str转换成 double 静态方法</span><br><span class="line">- `Double.valueOf(String str)` 将str转换成 double 静态方法</span><br><span class="line">- println 能加则加，不能加就一起输出</span><br><span class="line"></span><br><span class="line">### StringBuilder</span><br><span class="line"></span><br><span class="line">![image-20240913000059749](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913000059749.png)</span><br><span class="line"></span><br><span class="line">- StringBuilder重写了toString()  </span><br><span class="line">- append返回对象本身，可以链式调用，s.append(1).append(2).append(&quot;!23213&quot;);</span><br><span class="line">- reverse、length</span><br><span class="line">- 操作字符串建议使用StringBuilder 是可变对象 效率更高</span><br><span class="line">- 线程不安全。</span><br><span class="line"></span><br><span class="line">### StringBuffer</span><br><span class="line"></span><br><span class="line">- 线程安全</span><br><span class="line"></span><br><span class="line">### StringJoiner</span><br><span class="line"></span><br><span class="line">- 格式化拼接，方便快捷</span><br><span class="line"></span><br><span class="line">![image-20240913001740989](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913001740989.png)</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static String getArr(int[] arr)&#123; //返回数组</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        sb.append(&quot;[&quot;);</span><br><span class="line">        for(int i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">            sb.append(arr[i]);</span><br><span class="line">            if(i!=arr.length-1)&#123;</span><br><span class="line">                sb.append(&quot;,&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(&quot;]&quot;);</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">public static String getArr(int[] arr)&#123; //返回数组</span><br><span class="line">        StringJoiner sj = new StringJoiner(&quot;,&quot;,&quot;[&quot;,&quot;]&quot;);</span><br><span class="line">		for(int i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">            sj.add(arr[i]+&quot;&quot;);</span><br><span class="line">        &#125;       </span><br><span class="line">        return sj.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Math-2024-9-13"><a href="#Math-2024-9-13" class="headerlink" title="Math 2024.9.13"></a>Math 2024.9.13</h3><p>工具类，静态方法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913134448095.png" alt="image-20240913134448095"></p>
<p>abs ceil floor round</p>
<h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p>工具类 静态方法</p>
<p><code>System.exit(0) </code> 人为停机</p>
<p><code>System.currentTimeMillis()</code> 返回毫秒值 统计程序时间</p>
<h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><ul>
<li>java程序所在的运行环境</li>
<li><strong>单例类</strong> 构造器私有，声明一个public static final</li>
<li>exit exec</li>
</ul>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><ul>
<li><p><code>public BigDecimal(String val)</code>构造器 将double转成String类型然后付给BigDecimal</p>
</li>
<li><p><code>public static BigDecimal valueOf(double val)</code> 直接接一个double，据此创建一个BigDecimal对象（推荐）</p>
</li>
<li><p>divide(另一个BD对象，精确位数，舍入模式)</p>
<ul>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913140854393.png" alt="image-20240913140854393"></p>
</li>
<li><table>
<thead>
<tr>
<th>UP</th>
<th>DOWN</th>
<th>CEILING</th>
<th>FLOOR</th>
<th>HALF_UP</th>
<th>HALF_DOWN</th>
</tr>
</thead>
<tbody><tr>
<td>远离0方向</td>
<td>接近0方向</td>
<td>向上取整</td>
<td>向下取整</td>
<td>四舍五入</td>
<td>五舍六入</td>
</tr>
</tbody></table>
</li>
<li><p>HALF_EVEN 若（<strong>舍入位大于</strong>5）或者（<strong>舍入位等于</strong>5<strong>且前一位为奇数</strong>），则对舍入部分的前一位数字加1；若（<strong>舍入位小于</strong>5）或者（<strong>舍入位等于</strong>5且前一位为偶数），则直接舍弃。</p>
</li>
</ul>
</li>
<li><p>转成<code>double d =  bigdecimal.doubleValue()</code></p>
</li>
</ul>
<h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913164633885.png" alt="image-20240913164633885"></p>
<h5 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h5><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><ul>
<li><p><code>toString([] arr)</code> 返回一个数组字符串，每个元素调用<code>toString()</code>转换成字符串，用<code>[,,,]</code>拼接成一个总字符串</p>
</li>
<li><p> <code>copyOfRange([] arr, from, to)</code> 返回值为数组， 内容为arr中索引 <strong>[from, to)</strong> 的部分</p>
</li>
<li><p><code>copyOf([] arr, int newlength)</code> 返回值为数组，内容为arr的内容，长度为newlength，不够的用0补齐，索引超出的截断</p>
</li>
<li><p><code>setAll</code>  第二个参数是接口<code>IntToDoubleFunction</code>的实现对象，重写了<code>applyAsDouble(int value)</code>方法，value是数组的索引，返回对数组中内容进行操作的结果，图中是将数组内容乘以0.8。这个对象传进来以后，对数组进行遍历，都用<code>applyAsDouble</code>的方法进行操作。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913170741004.png" alt="image-20240913170741004"></p>
</li>
<li><p><code>sort([] arr)</code> 对arr升序排序(默认升序)</p>
</li>
<li><p><code>asList()</code>:只能加<strong>引用类型</strong>，基本数据类型需要改成包装类，并且返回的<code>List</code>是不能运用<code>add remove clear</code>方法的，这个<code>list</code>是<code>AbstractList</code>的子类，如果要访问<code>utils</code>只能将返回的这个<code>List</code>添加到<code>new ArrayList&lt;&gt;()</code>作为有参构造</p>
</li>
</ul>
<h4 id="对象数组如何排序？-Comparable-Comparator-—匿名内部类实现函数式接口"><a href="#对象数组如何排序？-Comparable-Comparator-—匿名内部类实现函数式接口" class="headerlink" title="对象数组如何排序？ Comparable Comparator —匿名内部类实现函数式接口"></a>对象数组如何排序？ Comparable Comparator —匿名内部类实现函数式接口</h4><p><strong>自己指定比较规则</strong> </p>
<ul>
<li><p>方法1：对象类实现<code>Comparable&lt;E&gt;</code>这个泛型接口，类中重写<code>int compareTo(E e)</code> 方法，将E改为自己的对象类型。</p>
<ul>
<li>约定，左边大于右边 return 正整数，小于 return 负整数，等于 return 0;（升序排序）</li>
<li><code>return this.age - o.age</code>  注意返回值是int double可以调用<code>Double.compare(o1.height, o2.height)</code></li>
<li>调用<code>Arrays.sort(students)</code>即可</li>
</ul>
</li>
<li><p>方法2：实现<code>Comparator</code>这个泛型接口，运用</p>
<ul>
<li><p>sort有一个重载函数，第一个参数是对象数组<code>T[] arr</code>，第二个参数是<code>Comparator&lt;? super T&gt; comparator</code></p>
</li>
<li><p>泛型接口做参数用匿名内部类实现，类中重写<code>int compare(T o1,T o2)</code>方法，同时注意返回的是int</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Students&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(o1.height,o2.height);<span class="comment">//升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>ArrayList有自己的sort方法，实现同Comparator，可以免去泛型的指定</li>
</ul>
<h4 id="Lambda-表达式—简化匿名内部类"><a href="#Lambda-表达式—简化匿名内部类" class="headerlink" title="Lambda 表达式—简化匿名内部类"></a><strong>Lambda 表达式—简化匿名内部类</strong></h4><ul>
<li>简化匿名内部类的写法，并且只能简化函数式接口(只有一个抽象方法的接口)，表示该接口的一个实现</li>
<li>@FunctionalInterface</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Swimming</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swimming</span>()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		System.out.println(name + <span class="string">&quot;is a swimmer~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Swimming</span> <span class="variable">s</span> <span class="operator">=</span> (name) -&gt; &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;is a swimmer~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913220402634.png" alt="image-20240913220402634"></p>
</li>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913220414015.png" alt="image-20240913220414015"></p>
</li>
<li><p>参数类型可省略不写，无参数也要空括号</p>
</li>
<li><p>如果只有一个参数，参数列表的括号可以省略不写</p>
</li>
<li><p>如果实现的抽象方法只有一行代码，可以省略大括号，同时也要省略<code>;</code>，若这一行是<code>return</code>语句，return也不能写</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(o1.age(),o2.age());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Arrays.sort(students, (Student o1,Student o2)-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> Double.compare(o1.age(),o2.age());</span><br><span class="line">&#125;);</span><br><span class="line">Arrays.sort(students, (o1,o2)-&gt;&#123;<span class="keyword">return</span> Double.compare(o1.age(),o2.age());&#125;);</span><br><span class="line">Arrays.sort(students, (o1,o2)-&gt;Double.compare(o1.age(),o2.age());</span><br></pre></td></tr></table></figure>

<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p><a href="https://blog.csdn.net/ShuSheng0007/article/details/107562812">秒懂Java之方法引用（method reference）详解-CSDN博客</a></p>
<p>Lambda的简化 对于参数列表和返回值相同的情况</p>
<h5 id="类的静态方法引用-类的实例方法引用（对象本身并不作为参数）"><a href="#类的静态方法引用-类的实例方法引用（对象本身并不作为参数）" class="headerlink" title="类的静态方法引用/类的实例方法引用（对象本身并不作为参数）"></a>类的静态方法引用/类的实例方法引用（对象本身并不作为参数）</h5><ul>
<li><p>静态方法引用: 调用静态方法，不需要实例，前缀是类名</p>
</li>
<li><p>实例方法引用: 调用已经存在的对象的实例方法，对象本身并不是参数，方法引用前缀是具体的对象</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;E&gt;&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(E o1, E o2)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompareByData</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compareByAge</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Double.compare(o1.getAge(),o2.getAge());</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareByAgeDesc</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Double.compare(o2.getAge(),o1.getAge());</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> compareBy</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(students, (o1,o2)-&gt;CompareByData.compareByAge(o1,o2));<span class="comment">//lambda</span></span><br><span class="line">Arrays.sort(students, CompareByData::compareByAge);<span class="comment">//静态方法引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">CompareByData</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompareByData</span>();</span><br><span class="line">Arrays.sort(students, (o1,o2)-&gt;com.compareByAgeDesc(o1,o2));<span class="comment">//lambda</span></span><br><span class="line">Arrays.sort(students, com::compareByAgeDesc);<span class="comment">//实例方法引用,com并不是参数</span></span><br></pre></td></tr></table></figure>

<h5 id="类的实例方法引用-对象本身作为参数"><a href="#类的实例方法引用-对象本身作为参数" class="headerlink" title="类的实例方法引用(对象本身作为参数)"></a>类的实例方法引用(对象本身作为参数)</h5><ul>
<li>调用实例方法，对象本身作为参数传进来，方法引用前缀为类名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(names, (String o1,String o2)-&gt;o1.compareToIgnoreCase(o2));</span><br><span class="line">Arrays.sort(names, String::compareToIgnoreCase);<span class="comment">//compareToIgnoreCase本身是String的一个实例方法</span></span><br><span class="line">    </span><br><span class="line">lqw.lt((User o1)-&gt;o1.getAge());</span><br><span class="line">lqw.lt(User::getAge, <span class="number">10</span>);<span class="comment">//getAge是User的一个实例方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>传入的对象o1是实例方法的调用者，其余的参数都是这个方法的参数</li>
</ul>
<h5 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h5><ul>
<li>Lambda表达式如果只是在创建一个对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Student <span class="title function_">getStudent</span><span class="params">(String name, <span class="type">int</span> age, BiFunction&lt;String, Integer, Student&gt; biFunction)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> biFunction.apply(name, age);</span><br><span class="line">&#125;</span><br><span class="line">BiFunction&lt;String, Integer, Student&gt; s1 = <span class="keyword">new</span> <span class="title class_">BiFunction</span>&lt;String, Integer, Student&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Student <span class="title function_">apply</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>(name, age);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//lambda表达式</span></span><br><span class="line">    BiFunction&lt;String, Integer, Student&gt; s2 = (name, age) -&gt; <span class="keyword">new</span> <span class="title class_">Student</span>(name, age);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//对应的方法引用</span></span><br><span class="line">    BiFunction&lt;String, Integer, Student&gt; s3 = Student::<span class="keyword">new</span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h5 id="方法引用-Lambda作为参数，可以在前面加上实现的函数式接口形参名，增强可读性"><a href="#方法引用-Lambda作为参数，可以在前面加上实现的函数式接口形参名，增强可读性" class="headerlink" title="方法引用/Lambda作为参数，可以在前面加上实现的函数式接口形参名，增强可读性"></a>方法引用/Lambda作为参数，可以在前面加上实现的函数式接口形参名，增强可读性</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(names, (Comparator&lt;? <span class="built_in">super</span> String&gt;) String::compareToIgnoreCase);</span><br><span class="line">Arrays.sort(names, String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure>



<h2 id="Regex-正则表达式"><a href="#Regex-正则表达式" class="headerlink" title="Regex 正则表达式"></a>Regex 正则表达式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">qqCode</span> <span class="operator">=</span> <span class="string">&quot;12812415&quot;</span>;</span><br><span class="line">System.out.println(qqCode.matches(<span class="string">&quot;[1-9]\\d&#123;5-19&#125;&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="Exception-异常处理"><a href="#Exception-异常处理" class="headerlink" title="Exception 异常处理"></a>Exception 异常处理</h2><p><code>Error</code>属于严重异常</p>
<p>运行时异常<code>RuntimeException</code></p>
<p>编译时异常，不解决是无法运行的</p>
<h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240914213155516.png" alt="image-20240914213155516"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行时异常</span></span><br><span class="line"><span class="comment">//自定义异常对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeIllegalRuntimeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalRuntimeException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalRuntimeException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(....) &#123;...&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeIllegalRuntimeException</span>(<span class="string">&quot;Your age is illegal!&quot;</span>);</span><br><span class="line">    &#125;<span class="comment">//抛出一个异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        saveAge(<span class="number">123</span>);<span class="comment">//函数执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)&#123;<span class="comment">//catch 用来接受可能抛出的异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译时异常 强烈提醒检查</span></span><br><span class="line"><span class="comment">//自定义异常对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeIllegalException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveAge</span><span class="params">(<span class="type">int</span> age)</span> <span class="keyword">throws</span> AgeIllegalException&#123;<span class="comment">//接收方法内部可能抛出的异常</span></span><br><span class="line">    <span class="keyword">if</span>(....) &#123;...&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeIllegalException</span>(<span class="string">&quot;Your age is illegal!&quot;</span>);<span class="comment">//一开始会报错,throws抛出</span></span><br><span class="line">    &#125;<span class="comment">//抛出一个异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        saveAge(<span class="number">183</span>);<span class="comment">//函数执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)&#123;<span class="comment">//catch 用来接受可能抛出的异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><code>throws</code>:用于方法的声明当方法内部抛出指定类型的异常时，该异常会被传递给<strong>调用该方法的代码</strong>，并在该代码中处理异常</p>
<p><code>try-catch</code>:试图接收并处理异常</p>
<p><code>throw</code>:用于在当前方法中抛出一个异常，当代码执行到某个条件下无法继续正常执行时，可以使用 <strong>throw</strong> 关键字抛出异常，以告知调用者当前代码的执行状态</p>
<ul>
<li>底层异常往外抛,最外层接受并记录,响应给用户</li>
<li>最外层接收,并在底层尝试修复<ul>
<li><code>sc.nextDouble()</code>接收一个<code>double</code>类型,如果乱输aafads就会在运行时自动抛出错误给外层</li>
<li>只需要将外层调用的<code>try-catch</code>块用<code>while(true)</code>围起来即可</li>
</ul>
</li>
</ul>
<h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><h2 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h2><h3 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h3><p>file&amp;directory</p>
<ul>
<li><code>File(String pathname)</code>:有参构造, <code>pathname</code>路径分隔符<code> / \\ File.separator</code> <ul>
<li>绝对路径</li>
<li>相对路径：默认起始位置是工程目录<code>(模块)file-io-app\\src\\itheima.txt</code></li>
</ul>
</li>
<li><code>f1.length()</code>:返回文件,文件夹大小 字节数 文件夹是存储文件夹内部的一些文件信息</li>
<li><code>f3.exists()</code>:是否存在</li>
<li><code>f3.isFile()</code>:是否是文件</li>
<li><code>f3.isDirectory()</code>:是否是文件夹</li>
<li><code>f3.getName()</code>:获取文件名称，包含后缀</li>
<li><code>f3.lastModified()</code>:返回long 最后修改的时间</li>
<li><code>f1.getPath()</code>获取创建对象时输入的路径</li>
<li><code>f1.getAbsolutePath()</code>获取文件的绝对路径</li>
</ul>
<ul>
<li><code>f1.createNewFile()</code>:不存在才创建，存在就创建失败，返回<code>false</code>  没找到路径会报错</li>
<li><code>f1.mkdir()</code>:不存在才创建，存在就创建失败，返回<code>false</code> 只能创建一级目录</li>
<li><code>f1.mkdirs()</code>:可以创建多级目录，返回结果</li>
<li><code>f1.delete()</code>:删除文件、空文件夹，返回结果</li>
</ul>
<ul>
<li><code>f1.list()</code>:当前<strong>文件夹</strong>内的<strong>一级文件名称</strong>返回<code>String[]</code> 也包含文件夹</li>
<li><code>f1.listFiles()</code>:返回当前<strong>文件夹</strong>内的<strong>一级文件对象</strong>，返回文件对象数组<code>File[]</code>，也包含文件夹<ul>
<li>文件、路径不存在、无权限访问的文件夹 <code>return null</code></li>
<li>空文件夹返回长度为0的File数组</li>
<li>隐藏文件也显示</li>
</ul>
</li>
<li><code>renameTo(new File(file.getParent(), newName))</code> 改名，file是目录下子文件,<code>substring(from,to)</code>是截取<code>[from,to)</code>,<code>substring(from)</code>是截取<code>[from,最后]</code></li>
</ul>
<h4 id="文件搜索、非空文件夹删除"><a href="#文件搜索、非空文件夹删除" class="headerlink" title="文件搜索、非空文件夹删除"></a>文件搜索、非空文件夹删除</h4><p>递归，数学问题最好写出表达式</p>
<p>eg 猴子一天吃一半还要再吃一个，10天剩余1个。前9天各自吃了多少？</p>
<p>$f(x)$代表第x天的桃子数量，题干可得出$f(x)/2+1 = f(x+1), f(10)=1$ 直接写递归函数即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNumberOfPeach</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">10</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*getNumberOfPeach(n+<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="C:\Users\Lenovo\IdeaProjects\MyFirstProject\src\com\it\IOtest\FileTestDemo.java">文件搜索、非空文件夹删除</a> </p>
<p><a href="C:\Users\Lenovo\IdeaProjects\MyFirstProject\src\com\it\IOtest\RecursiveDemo.java">递归练习</a> </p>
<h3 id="字符集（前置）"><a href="#字符集（前置）" class="headerlink" title="字符集（前置）"></a>字符集（前置）</h3><p>ASCII: 首位是0，使用1个字节存储英文数字</p>
<p>GBK: 1个中文字符编码成2个字节，兼容ASCII，并且对汉字规定第一个字节的第一位必须是1，与ASCII字符做区分</p>
<p>Unicode: </p>
<ul>
<li><p>UTF-32 4个字节表示一个字符</p>
</li>
<li><p>UTF-8 </p>
<ul>
<li>可变长编码方案 可以有1B 2B 3B 4B 四种长度 </li>
<li>兼容ASCII，汉字字符占3B</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916165638204.png" alt="image-20240916165638204"></li>
</ul>
</li>
<li><p>Encode Decode Identical</p>
</li>
<li><p>String提供了一些API，为字符串提供了编码和解码操作，以字节数组的形式<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916170250587.png" alt="image-20240916170250587"></p>
</li>
</ul>
<h3 id="IO流-字节流-amp-字符流"><a href="#IO流-字节流-amp-字符流" class="headerlink" title="IO流:字节流&amp;字符流"></a>IO流:字节流&amp;字符流</h3><ul>
<li><code>InputStream</code>:字节输入流:以内存为基准，来自磁盘文件/网络中的数据以字节的形式读入到内存中去的流</li>
<li><code>OutputStream</code>:字节输出流:以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流</li>
<li><code>Reader</code>:字符输入流:以内存为基准，来自磁盘文件/网络中的数据以字符的形式读入到内存中去的流，</li>
<li><code>Writer</code>:字符输出流:以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916171717591.png" alt="image-20240916171717591"></p>
<h4 id="FileInputStream-字节流"><a href="#FileInputStream-字节流" class="headerlink" title="FileInputStream 字节流"></a>FileInputStream 字节流</h4><ul>
<li>从文件一个字节一个字节地读取数据到内存中</li>
<li><code>InputStream is = new FileInputStream(&quot;........&quot;)</code></li>
<li><code>FileInputStream(String name)</code>:打开实际文件的连接创建文件字节输入流，也可用<code>File file</code>做形参，<code>String</code>重载会自动帮你转成file对象。</li>
<li>一次读取一个 <code>int read()</code> 读取一个字节并返回，无数据返回-1 <ul>
<li>改进：循环<code>(b=is.read())!=-1</code></li>
<li>调用系统硬件资源，性能较差</li>
<li>一次读一个，无法解决非ASCII的乱码</li>
<li>流使用系统资源，使用完记得关闭！<code>is.close()</code></li>
</ul>
</li>
<li>一次读取多个 <code>int read(byte[] buffer)</code> 用<code>buffer</code>字节数组装字节，字节数组的长度代表每次读取的字节数，返回每次读取的字节数（<code>buffer</code>可能会装不满）无数据返回-1<ul>
<li><code>buffer</code>字节数组要转换成字符串，转成<code>String</code>可以设定转的部分，<code>String(buffer, 0, len)</code>确保如实把<strong>这次</strong>读到的内容转为字符串 <code>len</code>为<code>read</code>的返回值 </li>
<li>性能得到了提升，汉字仍然乱码，会强行截断汉字</li>
</ul>
</li>
<li>一次读取全部<ul>
<li><code>int read(byte[] buffer)</code>buffer大小和文件的大小字节数相同</li>
<li><code>byte[] readAllBytes()</code> <code>is.readAllBytes()</code> </li>
<li>文件过大会导致内存溢出，字节数组过大，所以字节流不适合读文本，更适合做数据转移，比如文件复制</li>
</ul>
</li>
</ul>
<h4 id="FileOutputStream-字节流"><a href="#FileOutputStream-字节流" class="headerlink" title="FileOutputStream 字节流"></a>FileOutputStream 字节流</h4><ul>
<li>从内存一个字节一个字节地输出到文件中，目标文件自动生成</li>
<li><code>OutputStream os = new FileOutputStream(&quot;........&quot;)</code> 写文件（覆盖）</li>
<li><code>OutputStream os = new FileOutputStream(&quot;........&quot;, true)</code> 写文件（追加）<ul>
<li>换行：<code>&quot;\r\n&quot;</code> 将其转换成<code>bytes[]</code> 再<code>write</code></li>
</ul>
</li>
<li><code>os.write(int b)</code>把b写入文件 还是以字节形式</li>
<li><code>os.write(byte[] b)</code>把字节数组b写入文件</li>
<li><code>os.write(byte[] b,int off,int len)</code>把b写入文件, <code>off</code>表示起始的字节数组索引，<code>len</code>表示要写入的字节长度，3个汉字一共9字节</li>
</ul>
<h5 id="case-文件复制"><a href="#case-文件复制" class="headerlink" title="case: 文件复制"></a>case: 文件复制</h5><p>总结：字节流适合拷贝一切文件，因为一切文件的内容都是以字节形式存储的，一字不漏地转移所有字节，就不会出现问题</p>
<h4 id="释放资源的方式"><a href="#释放资源的方式" class="headerlink" title="释放资源的方式"></a>释放资源的方式</h4><p>原来：中间出现异常，就无法释放资源（关闭字节流）</p>
<h5 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论try是否正常执行，一定执行finally，除非JVM终止<code>System.exit(0)</code></p>
<p>finally可以无视<code>return</code>语句 一定执行一次，如果finally是return，原函数接受的就一定是finally里边的值，所以最好不要在finally里面return</p>
<p>在程序执行完成后进行资源的释放操作，finally不能访问try块里面的内容</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916200213214.png" alt="image-20240916200213214">先在try块外定义流，然后try块内对流进行操作，finally块内关闭流，关闭流因为系统不知道之前是否开流会报错，用try catch块包围起来即可<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916200719319.png" alt="image-20240916200719319"></p>
<p><strong>臃肿</strong></p>
<h5 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>（</span><br><span class="line">	<span class="comment">//资源的定义;</span></span><br><span class="line">	<span class="comment">//资源的定义;</span></span><br><span class="line">）&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能放置资源对象, 资源都会实现AutoClosable接口，资源放进去会自动调用close方法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916201402673.png" alt="image-20240916201402673"></p>
<h4 id="FileReader-字符流"><a href="#FileReader-字符流" class="headerlink" title="FileReader 字符流"></a>FileReader 字符流</h4><ul>
<li>把文件数据以字符形式读到内存中去</li>
<li>构造器与<code>FileInputStream</code>类似 <code>Reader fr = new FileReader(String filename)</code></li>
<li><code>int read() </code>每次读取一个字符并返回</li>
<li><code>int read(char[] buffer) </code>每次读取多个字符并返回，返回此次读取字符的个数</li>
</ul>
<h4 id="FileWriter-字符流"><a href="#FileWriter-字符流" class="headerlink" title="FileWriter 字符流"></a>FileWriter 字符流</h4><ul>
<li>把字符数据写到文件中去,目标文件自动生成</li>
<li>构造器与<code>FileOutputStream</code>类似 <code>Writer fw = new FileWriter(String filename)</code>可以参数后加true表示追加</li>
<li><code>void write(int c)</code>写一个字符出去</li>
<li><code>void write(String str)</code>写一个字符串出去</li>
<li><code>void write(String str,int pos,int len)</code> 写字符串从<code>pos</code>开始长度为<code>len</code></li>
<li><code>void write(char[] buffer)</code>写一个字符数组</li>
<li><code>void write(char[] buffer,int pos,int len)</code>写字符数组从<code>pos</code>开始长度为<code>len</code></li>
<li>注意事项<ul>
<li>字符输出流写出数据以后，必须刷新流或者关闭流（包含刷新）才能生效。<code>flush() close()</code> 因为对文件操作比较耗费系统资源，所以都是先从管道写到缓冲区，写完之后一次性写到文件中去。</li>
</ul>
</li>
</ul>
<h3 id="IO流-缓冲流"><a href="#IO流-缓冲流" class="headerlink" title="IO流:缓冲流"></a>IO流:缓冲流</h3><p>对原始流进行包装，提高原始流读写数据的性能</p>
<h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><p>开辟缓冲区，不用一次一次写 <strong>8KB缓冲池</strong> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916231524970.png" alt="image-20240916231524970"></p>
<p>减少调用系统资源的次数</p>
<p><code>InputStream bis = new BufferedInputStream(InputStream is)</code></p>
<p><code>OutputStream bos = new BufferedOutputStream(OutputStream os)</code></p>
<p>方法和原始类一样，性能有所提高，有参构造可以自定义缓冲区大小，默认8192</p>
<h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h4><p>自带8K的字符缓冲池</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916232037970.png" alt="image-20240916232037970"></p>
<p><code>BufferedReader br = new BufferedReader(Reader r)</code> </p>
<p>不使用多态写法：新增了独有的功能</p>
<p>新增功能 <code>String readLine()</code> 读一整行，直到换行符，返回这行的内容，没有返回<code>null</code></p>
<p><code>BufferedWriter bw = new BufferedWriter(Writer r)</code> </p>
<p>新增功能：<code>void newLine()</code>换行</p>
<h3 id="原始-amp-缓冲流对比"><a href="#原始-amp-缓冲流对比" class="headerlink" title="原始&amp;缓冲流对比"></a>原始&amp;缓冲流对比</h3><ul>
<li>低级字节流一个一个字节的赋值，慢的简直让人无法忍受，直接淘汰! X</li>
<li>低级字节流一个一个字节数组的形式复制，速度较慢! </li>
<li>缓冲流按照一个一个字节的形式复制，速度较慢 X</li>
<li>缓冲流按照一个一个字节数组的形式复制，速度极快，推荐使用!</li>
<li>性能与字节数组的大小强相关，32MB最大，用空间换时间</li>
<li>与缓冲区的大小也有关</li>
</ul>
<p>并行&amp;多线程 异步IO 内存映射技术 减少系统调用 不要一个字节一个字节地输入</p>
<h3 id="字符转换流"><a href="#字符转换流" class="headerlink" title="字符转换流"></a>字符转换流</h3><h4 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h4><p><code>Reader isr = new InputStreamReader(InputStream is, String charset)</code> 把<strong>原始<mark>字节流<mark>is</strong>按照charset设定转换成对应字符输入流</p>
<p>新的字符输入流可以继续用<code>BufferedReader</code>包装</p>
<h4 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h4><p>控制写出去的字符集编码</p>
<ul>
<li><code>str.getBytes(&quot;GBK&quot;)</code></li>
<li>字符输出转换流</li>
</ul>
<h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p>PrintStream：是<strong>字节输出流</strong>的实现类</p>
<p>PrintWriter：是<strong>字符输出流</strong>的实现类 内部包装缓冲流</p>
<p><strong>方便高效</strong>，所见即所得</p>
<p>构造器：</p>
<ul>
<li><code>PrintStream(OutputStream os/File file/String filename)</code> 直接链接+包装原始流</li>
<li><code>PrintStream(String filename, Charset charset)</code> <code>Charset.forName(&quot;GBK&quot;)</code>能返回GBK的Charset</li>
<li><code>PrintStream(OutputStream os, boolean autoFlush, String charset)</code> 字符集可有可无</li>
<li><strong><code>ps.println()</code>:打印一行东西</strong></li>
<li><code>ps.write()</code>写int字节 字节数组 字节数组的一部分</li>
</ul>
<p>自身没有追加功能，只能包装<code>true输出流</code>:</p>
<p><code>PrintStream ps = PrintStream(new FileOutputStream(filename,true))</code> </p>
<p><code>PrintWriter pw = PrintWriter(new FileWriter(filename,true))</code>  </p>
<h4 id="拓展：Redirecting-PrintStream-PrintWriter"><a href="#拓展：Redirecting-PrintStream-PrintWriter" class="headerlink" title="拓展：Redirecting PrintStream/PrintWriter"></a>拓展：Redirecting PrintStream/PrintWriter</h4><p><code>System.out.println()</code> out实际上就是一个打印流，是指向控制台的</p>
<p><code>System.setOut(PrintStream ps)</code> 把系统的out设定到指定的打印流ps中</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917153902713.png" alt="image-20240917153902713"></p>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p><code>DataInputStream</code>:字节输入流的实现</p>
<p>构造器：包装低级的字节输入流 </p>
<p><code>dos.writeInt(int a)</code> 写出去a，包括数据类型</p>
<p><code>dis.readUTF()</code> 读进来字符串并返回 UTF-8</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917154727844.png" alt="image-20240917154727844"></p>
<h3 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h3><p><a href="..%5CSerialization.md">序列化</a> </p>
<p> 字节流实现类<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917154853819.png" alt="image-20240917154853819"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917154908066.png" alt="image-20240917154908066"></p>
<p><strong>First Step</strong> 创建对象字节输出流 包装原始字节输出流:</p>
<p><code>ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream)</code></p>
<p><strong>Second Step</strong> 调用 writeObject(具体对象)方法 </p>
<p>对象的类要**<code>implements</code> <code>Serializable</code>** 接口！</p>
<p><strong>Third Step</strong> 创建对象字节输入流 包装原始字节输入流</p>
<p><code>ObjectInputStream ois = new ObjectInputStream(new FileInputStream)</code> </p>
<h4 id="拓展：对象中某些变量不想参与序列化"><a href="#拓展：对象中某些变量不想参与序列化" class="headerlink" title="拓展：对象中某些变量不想参与序列化"></a>拓展：对象中某些变量不想参与序列化</h4><p><code>private </code> <code>transient</code> <code> String password;</code> transient关键字</p>
<h4 id="拓展：一次序列化多个对象"><a href="#拓展：一次序列化多个对象" class="headerlink" title="拓展：一次序列化多个对象"></a>拓展：一次序列化多个对象</h4><p>将对象存入ArrayList中，对ArrayList进行序列化</p>
<h3 id="IO框架"><a href="#IO框架" class="headerlink" title="IO框架"></a>IO框架</h3><p>框架：把编写好的类和接口编译成class形式，压缩成.jar结尾的文件发行</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917162151321.png" alt="image-20240917162151321"></p>
<h2 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h2><p>存储有关系的数据作为系统的配置文件</p>
<h3 id="properties-属性文件"><a href="#properties-属性文件" class="headerlink" title=".properties 属性文件"></a>.properties 属性文件</h3><ul>
<li>存储键值对数据</li>
<li>键不重复</li>
</ul>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917163605651.png" alt="image-20240917163605651"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建属性对象，加载文件内容</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filename));</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建字符串集合，接收属性对象返回的键集合</span></span><br><span class="line">Set&lt;String&gt; keys = properties.stringPropertyNames();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历键集合，通过属性对象和键找到value</span></span><br><span class="line"><span class="keyword">for</span>(String key : keys)&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(key);</span><br><span class="line">	properties.forEach((k,v)-&gt;System.out.println(k + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917164532330.png" alt="image-20240917164532330"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.setProperty(<span class="string">&quot;asd&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;dfg&quot;</span>,<span class="string">&quot;213&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;hjk&quot;</span>,<span class="string">&quot;321&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">comments</span> <span class="operator">=</span> <span class="string">&quot;I have saved many users!!!&quot;</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">properties.store(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filename), comments);</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>



<h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><p>E<strong>X</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage</p>
<p>根标签 只有一个</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917170133400.png" alt="image-20240917170133400"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917170306289.png" alt="image-20240917170306289"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917170346202.png" alt="image-20240917170346202"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917170514649.png" alt="image-20240917170514649"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917185127560.png" alt="image-20240917185127560"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917185753893.png" alt="image-20240917185753893">好</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul>
<li>系统执行信息方便记录到指定的位置（控制台，文件，数据库）</li>
<li>随时用开关控制日志启停，不需要修改源代码</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917191534986.png" alt="image-20240917191534986"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917191744756.png" alt="image-20240917191744756"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917192232262.png" alt="image-20240917192232262"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917192328808.png" alt="image-20240917192328808"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917192715641.png" alt="image-20240917192715641"></p>
<p><code>&lt;pattern&gt; &lt;/pattern&gt;</code> 日志格式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917192956963.png" alt="image-20240917192956963"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917193034517.png" alt="image-20240917193034517"></p>
<p>文件拆分规则，保证每个不超过1MB，过去的压缩成1MB的gz文件</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917193427486.png" alt="image-20240917193427486"></p>
<p>控制日志输出情况</p>
<p>日志级别 trace&lt; <strong>debug</strong> &lt; info &lt; warn &lt; error </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917193721056.png" alt="image-20240917193721056"></p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><ul>
<li><code>java.net.*</code></li>
</ul>
<p>CS BS架构</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918155511067-1726751033487-55.png" alt="image-20240918155511067"></p>
<h2 id="网络通信基本概念"><a href="#网络通信基本概念" class="headerlink" title="网络通信基本概念"></a>网络通信基本概念</h2><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>设备在网络的地址，唯一标识</p>
<p><strong>IPv4:</strong> 32bit 点分十进制表示法    <strong>IPv6:</strong> 128bit 冒号分16进制表示法</p>
<p><strong>域名</strong>代表IP，<strong>DNS服务器</strong>会记录域名的真实IP</p>
<p><strong>公网IP</strong>：链接互联网 <strong>内网IP</strong>：局域网，内部使用</p>
<p>**<code>localhost = 127.0.0.1</code>**：代表本机IP，只会寻找当前所在的主机</p>
<p><strong><code>ping IP地址</code></strong> </p>
<h4 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h4><p>常用方法：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918160540846-1726751033487-56.png" alt="image-20240918160540846"></p>
<p><code>getByName()</code>: 根据主机名 返回IP地址对象</p>
<p><code>isReachable(int ms)</code> 相当于ping命令</p>
<h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><p>端口，应用程序在设备的地址，唯一标识</p>
<p>16bit 0-65535</p>
<p>0-1023: 预定义占用，周知端口</p>
<p>1024-49151: 注册端口</p>
<p>49152-65535: 动态分配</p>
<p>同一设备不能有两个程序的端口号一样</p>
<h3 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a>protocol</h3><p>协议，应用程序之间进行通信的规则</p>
<p>OSI 网络参考模型</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918161423219-1726751033487-57.png" alt="image-20240918161423219"></p>
<p>TCP/IP 事实上的国际标准</p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p><strong>U</strong>ser <strong>D</strong>atagram <strong>P</strong>rotocol</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918161816467-1726751033487-58.png" alt="image-20240918161816467"></p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p><strong>T</strong>ransmission <strong>C</strong>ontrol <strong>P</strong>rotocol</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918161923650-1726751033487-59.png" alt="image-20240918161923650"></p>
<h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h4><p>第一次握手：客户端发消息，服务器收到消息，服务器知道客户端发消息没问题。</p>
<p>第二次握手：服务端发消息，客户端收到消息，客户端知道服务端收消息没问题，发消息也没问题。</p>
<p>第三次握手：客户端根据上一次握手的内容再次发出确认信息，服务器端收到信息，说明客户端收消息没问题。</p>
<p>全双工：双方都要确认对方同时具备收发信息的能力</p>
<p>不可靠信道上实现可靠的传输</p>
<p><strong>B 收到了 A 发来的消息，B 因此判断 A 具备发送能力</strong>：</p>
<ul>
<li>这个理解是正确的。当 B 收到 A 发送的 <code>SYN</code> 报文时，B 可以判断 A 具有发送消息的能力。A 通过发送 <code>SYN</code> 表示自己希望建立连接，并告诉 B 自己的初始序列号。</li>
<li>但需要注意的是，B 仅能判断 A 能发送数据，尚无法确定 A 能正确接收 B 发送的消息（即 A 的接收能力）。</li>
</ul>
<p><strong>A 收到了 B 发回的消息，A 判断 B 具备收发信息能力</strong>：</p>
<ul>
<li><strong>发送能力</strong>：正确。当 A 收到 B 发回的 <code>SYN-ACK</code> 消息后，A 可以确认 B 具备发送能力，因为 B 能够发送 <code>SYN-ACK</code> 报文。</li>
<li><strong>接收能力</strong>：A 也可以推断 B 具备接收能力，因为 B 不仅发送了 <code>SYN-ACK</code>，还包含了对 A 的 <code>SYN</code> 的确认（<code>ACK</code>），说明 B 成功接收了 A 的 <code>SYN</code> 报文。</li>
<li>因此，通过 B 的 <code>SYN-ACK</code> 报文，A 可以确认 B 既能够发送，也能够接收消息。</li>
</ul>
<p><strong>B 收到了 A 发回的信息，B 因此判断 A 具备接收能力，连接建立</strong>：</p>
<ul>
<li>这个理解也基本正确。当 B 收到 A 的 <code>ACK</code> 报文后，B 可以确认 A 的接收能力，因为 A 收到了 B 的 <code>SYN-ACK</code> 并发回了 <code>ACK</code>。如果 A 无法接收数据，就无法正确回应 B 的 <code>SYN-ACK</code> 报文。</li>
<li>至此，B 确定 A 既能发送也能接收，双方通信能力都得到确认，连接可以正式建立。</li>
</ul>
<ul>
<li>在 TCP 三次握手过程中，双方都通过序列号和确认号来确认彼此的发送和接收能力，确保连接是双向可靠的。</li>
<li>三次握手的过程确保了双方的<strong>发送能力</strong>和<strong>接收能力</strong>都正常，连接才会被建立。</li>
<li>你对各个步骤的理解是对的，只需要记住，每一步都不仅仅是确认对方的发送能力，还需要通过确认号和响应确认对方的接收能力。</li>
</ul>
<h4 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h4><ol>
<li>客户端发完数据，发出断连请求</li>
<li>服务器还没处理完最后的数据，先发一个消息，让客户端稍等</li>
<li>处理完数据后，服务器再发一个消息确认断开连接</li>
<li>客户端正式断开连接</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918213236026-1726751033487-61.png" alt="image-20240918213236026"></p>
<h2 id="Java-UDP"><a href="#Java-UDP" class="headerlink" title="Java UDP"></a><a href="jetbrains://idea/navigate/reference?project=MyFirstProject&fqn=com.it.netTest.UDP.Client">Java UDP</a></h2><ul>
<li><code>java.net.DatagramSocket</code> <code>java.net.DatagramPacket</code> </li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918213602137-1726751033487-60.png" alt="image-20240918213602137"></li>
<li>创建DS对象，创建DP对象用于封装数据，DP对象里有字节数组，字节数组长度，目标IP,目标端口，客户端调用send方法发送数据包。</li>
<li>创建DS对象(端口号)，创建DP对象用于接收数据，DP对象里的数组长度64KB，然后服务段调用receive方法接收数据包。数据包调用getLength方法获取实际接收数据包的大小，以便正确输出数据包内数组的内容。</li>
<li>getAddress()可以拿到客户端IP地址</li>
<li>getPort()可以拿到客户端端口</li>
</ul>
<h2 id="Java-TCP"><a href="#Java-TCP" class="headerlink" title="Java TCP"></a><a href="jetbrains://idea/navigate/reference?project=MyFirstProject&path=com/JavaSE/netTest/tcp/Server.java">Java TCP</a></h2><p><code>java.net.Socket</code> <code>java.net.ServerSocket</code></p>
<p>服务端和客户端通过<code>socket</code>对象之间建立的管道进行通信，数据通过管道也就是流进行传输，而UDP是通过发送单个<code>datagram</code>数据报的形式，不需要建立联系，不需要建立稳定的管道</p>
<ul>
<li><p>客户端：    </p>
<ul>
<li>创建<code>Socket sk = new Socket(hostname, port)</code> 数据目的地的端口号</li>
<li><code>OutputStream os = sk.getOutputStream();</code> 把<code>socket</code>的流拿到</li>
<li><code>DataOutputStream dos = new DataOutputStream(os)</code> 对原始的流进行包装</li>
<li><code>dos.writeUTF(&quot;String sth&quot;)</code> </li>
<li>关闭<code>dos</code> 关闭<code>socket</code> </li>
</ul>
</li>
<li><p>服务端</p>
<ul>
<li>创建 <code>ServerSocket ss = new ServerSocket( port)</code> 注册端口，跟客户端里面的端口一样</li>
<li><code>Socket socket = ss.accept()</code> 等待客户端发来socket连接请求，端到端，这两个socket内容其实是一样的。</li>
<li><code>DataInputStream dis = new DataInputStream(socket.getInputStream());</code>用数据流包装原始的输入流</li>
<li><code>dis.readUTF().sout</code></li>
</ul>
</li>
</ul>
<p>支持一发一收 多发多收，因为只能是一个socket对应一个socket，是端到端的，要实现跟其他socket的通信只能断开连接，所以引入多线程，接到socket就开一个新线程，继续监听socket，用while循环实现。</p>
<p>要实现群聊，服务器可以用一个集合储存socket，如果某个socket收到了消息，就遍历集合发给所有socket（同客户端的发送代码）客户端建立socket对象之后，在while循环内部出不来，要监听</p>
<p>BrowserServer架构 Server要提供的内容必须符合HTTP规范</p>
<h1 id="单元测试框架"><a href="#单元测试框架" class="headerlink" title="单元测试框架"></a>单元测试框架</h1><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240919211712463.png" alt="image-20240919211712463"></p>
<p>检测抛出异常</p>
<h2 id="断言机制"><a href="#断言机制" class="headerlink" title="断言机制"></a>断言机制</h2><p>Assert.assertEquals() bug提示 <strong>期望值</strong> 实际值 </p>
<h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>可以一键进行所有测试，一键自动化测试</p>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>@Test 测试方法</p>
<p>@Before(BeforeEach) 每个测试前要跑的方法</p>
<p>@BeforeClass(All) 修饰静态方法，所有测试方法之前，最先 这两个是初始化</p>
<p>@After(AfterEach) 每个测试执行完要跑的方法</p>
<p>@AfterClass(All) 修饰静态方法，所有测试方法之后，最后 这两个是释放资源</p>
<p>如果是每一个测试方法都需要一个独立的资源，就用before</p>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="annotation"><a href="#annotation" class="headerlink" title="annotation"></a>annotation</h2><p>让其他程序根据注解来决定怎么执行该程序</p>
<p><code>@Override</code>:让IDE判断方法是否重写成功 </p>
<p><code>@Test</code>: 让测试框架知道这个是测试方法</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest1&#123;</span><br><span class="line">    String <span class="title function_">aaa</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">bbb</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">    String[] ccc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//value 属于特殊属性，可以只写值</span></span><br><span class="line"><span class="comment">//有 default 可以不用赋值</span></span><br><span class="line"><span class="comment">//没 default 必须赋值，带变量名和等号</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyTest1</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">aaa</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">bbb</span><span class="params">()</span>&#123;<span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">true</span>;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String[] ccc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质是接口，都继承了Annotation接口</p>
<p><code>@MyTest1(aaa=&quot;123&quot;,bbb=false, ccc=&#123;&quot;str&quot;,&quot;asd&quot;&#125;)</code> 是一个实现类对象</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>修饰注解的注解, 在自定义注解的上面 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240919214219300.png" alt="image-20240919214219300"></p>
<h2 id="解析注解"><a href="#解析注解" class="headerlink" title="解析注解"></a>解析注解</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240919214508991.png" alt="image-20240919214508991"></p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>模拟框架 解析注解，然后执行 模拟<a href="jetbrains://idea/navigate/reference?project=MyFirstProject&fqn=org.JavaSE.AdvancedTest.Annotation.JUnitSimulator">JUnitSimulator(Toolbox 引用)</a>识别并执行有特定注解的方法</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>加载类，允许用编程的方式，解剖类中的各种成分（万物皆对象）</p>
<p>比如ide中创建一个对象，对象引用后加一个点就能显示可以调用的方法，说明这个类实现的方法已经提前加载好了</p>
<h2 id="加载方法"><a href="#加载方法" class="headerlink" title="加载方法"></a>加载方法</h2><ol>
<li><p>加载类，获取 <code>Class</code> 对象</p>
<ul>
<li><code>Class c = 类名.class</code> </li>
<li><code>Class.forName(全名)</code>  </li>
<li><code>Class c = 对象.getClass()</code> </li>
<li><code>getName() 全名带包名 getSimpleName() 简名</code></li>
<li><code>getMethod() getConstructor() getField()</code> </li>
</ul>
</li>
<li><p>获取类的构造器 <code>Constructor</code> 对象，主调是 <code>Class 对象</code></p>
<ul>
<li><code>getConstructors</code> 只有 public <strong>返回数组</strong></li>
<li><code>getDeclaredConstructors</code> 存在就能拿到</li>
<li><code>getConstructor(形参的类型对象)</code> 只有public 拿一个</li>
<li><code>getDeclaredConstructor(形参的类型对象)</code> 存在就能拿到 拿1个</li>
</ul>
<ul>
<li>下面的主调是构造器对象</li>
<li><code>getParameterCount</code>几个参数</li>
<li><code>newInstance(...参数)</code> 返回<code>object</code> 强转为对象，如果私有构造器会报错</li>
<li><code>setAccessible(true)</code> 暴力反射，禁止检查访问权限</li>
</ul>
</li>
<li><p>获取类的成员变量 <code>Field</code> 对象</p>
<ul>
<li><code>getFields</code> <code>getDeclaredFields</code> </li>
<li><code>getField(name)</code> <code>getDeclaredField(name)</code></li>
<li>下面主调是<code>Field</code>对象</li>
<li><code>set(对象, 值)</code> <code>get(对象)</code> 赋值 取值</li>
<li><code>setAccessible</code> 暴力反射</li>
</ul>
</li>
<li><p>获取类的成员方法 <code>Method</code> 对象</p>
<ul>
<li><code>getMethods</code> <code>getDeclaredMethods</code></li>
<li><code>getMethod(name, String.class, int.class) </code>返回值</li>
<li>下面主调是<code>method</code></li>
<li><code>getName getParameterConut getReturnType</code></li>
<li><code>invoke(对象, 参数)</code> 返回object 强转为返回值类型</li>
<li><code>setAccesible</code></li>
</ul>
</li>
</ol>
<h2 id="作用、应用场景"><a href="#作用、应用场景" class="headerlink" title="作用、应用场景"></a>作用、应用场景</h2><ul>
<li>得到类的全部成分</li>
<li>破坏封装性</li>
<li>做框架</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920001226903.png" alt="image-20240920001226903"></p>
<p>接收任意对象，接到对象，用反射获取class对象，获取全部成员变量，遍历他们，把他们的属性写出到文件中</p>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>框架的核心技术，一个类有很多方法，需要加载资源，而代理可以代替类执行这些操作。</p>
<p>Spring AOP技术使用了JDK动态代理和CGLIB动态代理两种方式，在不改变原始方法的前提下对功能进行增强。</p>
<h2 id="JDK-动态代理——反射"><a href="#JDK-动态代理——反射" class="headerlink" title="JDK 动态代理——反射"></a>JDK 动态代理——反射</h2><ul>
<li>JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求<strong>代理对象和目标对象实现同样的接口</strong>（兄弟两个拜把子模式），目标对象和代理对象是平等地位的。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920112517946.jpg" alt="image-20240920112517946"></p>
<p>对于一个UserServiceImpl，要生成它的代理对象，为了能创建一个跟UserServiceImpl拥有同名方法的代理Proxy，<mark>这个类必须实现一个接口UserService，并且拥有Impl的全部方法<mark>，然后把Impl传给生成代理的方法。</p>
<p>接口能将原来的实现对象的方 法抽象化（或者部分抽象） 方便代理进行重写，代理重写完具体的执行逻辑，返回的还是这个接口的实现对象，相当于是把原来的实现对象包装了一下，完美地把对象的职责转移到了代理身上，业务对象。减少代码冗余和多余的资源调用</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023232822938.png" alt="image-20241023232822938"></p>
<h2 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h2><p>通过<strong>继承被代理的目标类</strong>（认干爹模式）实现代理，所以不需要目标类实现接口。</p>
<p><strong>CGLIB 通过动态生成一个需要被代理类的子类（即被代理类作为父类），该子类重写被代理类的所有不是 final 修饰的方法，并在子类中采用方法拦截的技术拦截父类所有的方法调用，进而织入横切逻辑，</strong> 目标对象是代理对象的父类。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib-nodeps<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023232711967.png" alt="image-20241023232711967"></p>
<h1 id="Hutool-Usage"><a href="#Hutool-Usage" class="headerlink" title="Hutool Usage"></a>Hutool Usage</h1><h2 id="BeanUtil"><a href="#BeanUtil" class="headerlink" title="BeanUtil"></a>BeanUtil</h2><h3 id="bean和Map转换"><a href="#bean和Map转换" class="headerlink" title="bean和Map转换"></a>bean和Map转换</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,Object&gt;BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">                 CopyOptions.create().setFieldValueEditor((fieldName,fieldValue)-&gt;fieldValue.toString()));</span><br><span class="line"></span><br><span class="line">BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(),<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h2 id="JSONUtil"><a href="#JSONUtil" class="headerlink" title="JSONUtil"></a>JSONUtil</h2><h3 id="JSON和对象互转"><a href="#JSON和对象互转" class="headerlink" title="JSON和对象互转"></a>JSON和对象互转</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(shop);</span><br><span class="line"></span><br><span class="line">shop = JSONUtil.toBean(jsonStr,Shop.class);</span><br></pre></td></tr></table></figure>

<h3 id="JSON和数组互转"><a href="#JSON和数组互转" class="headerlink" title="JSON和数组互转"></a>JSON和数组互转</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonArrayStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(list);</span><br><span class="line"></span><br><span class="line"><span class="type">JSONArray</span> <span class="variable">jsonArray</span> <span class="operator">=</span> JSONUtil.parseArray(jsonArrayStr);</span><br><span class="line">shopTypeList = JSONUtil.toList(jsonArray, ShopType.class);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>jdk</category>
      </categories>
      <tags>
        <tag>annotation</tag>
        <tag>动态代理</tag>
        <tag>oop</tag>
        <tag>io</tag>
        <tag>java-net</tag>
        <tag>reflection</tag>
        <tag>utils</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2024/09/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h1><h2 id="饿汉"><a href="#饿汉" class="headerlink" title="饿汉"></a>饿汉</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;<span class="keyword">return</span> instance;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程安全，但是可能造成资源的浪费</p>
<h2 id="懒汉-双重校验锁-DCL"><a href="#懒汉-双重校验锁-DCL" class="headerlink" title="懒汉 双重校验锁 DCL"></a><u><strong>懒汉 双重校验锁 DCL</strong></u></h2><ol>
<li>懒汉（延迟初始化） 要素：无参构造私有，进行判断<strong>「线程不安全」</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>原来的实现容易出现线程安全问题，改进：<code>getInstance()</code>变成 <code>synchronized</code> 方法。<ul>
<li><p><strong>锁范围太大</strong>：性能差，同步开销大。正常的执行路径不需要同步，只需要在创建实例的时候进行锁定即可。</p>
<ul>
<li><p>锁对象的选择：<strong>两个不相关的方法不要使用同一把锁</strong>。<strong>并且要注意不能出现死锁互相等待</strong>。</p>
</li>
<li><p>class：适用于保护静态变量或者类级别的共享资源，如果是为了保护某个对象的状态，就应该使用this。</p>
</li>
<li><p>this可能的问题：这边在内部使用this调用task.dosth()，另一边一个完全无关的业务使用 task做锁。</p>
</li>
<li><p>死锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Friend</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Friend</span><span class="params">(String name)</span> &#123;<span class="built_in">this</span>.name = name;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bow</span><span class="params">(Friend other)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; 正在向 &quot;</span> + other.name + <span class="string">&quot; 鞠躬&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟执行延迟</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            other.bowBack(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bowBack</span><span class="params">(Friend other)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; 正在回礼 &quot;</span> + other.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 死锁：a和b同时向对方bow，先都锁住了自己，bowBack的时候就会造成互相等待</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>未二次判空</strong>：线程 A 通过了条件判断，获取了锁，开始创建实例，就在同时，线程B也通过判断等待锁释放，在线程 A 出来之后线程B又进去创建了一次。</p>
</li>
<li><p><strong>指令重排序</strong>：Java 允许指令重排序，创建对象可以分为 1. 分配内存地址 2. 在这块内存地址创建对象 3. 将 对象的引用 instance 指向这块地址。如果2 3的顺序颠倒，线程 A 进去之后在完全创建对象之前就将 instance 置为 非null，线程B就会以为别人已经创建好了，直接返回 instance 引用，线程B拿到以后就开始使用，其中就会随机发生空指针或者状态异常等其他难以复现调试的bug。引入 volatile，表示这个变量不允许指令重排，且线程对它的写入会立刻对其他线程可见。避免发生拿到错误对象的情况</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance; <span class="comment">// 1. 禁止指令重排序</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton.class)&#123;<span class="comment">// 2. 锁的范围缩小</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;<span class="comment">// 3. 二次判空</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适用场景：</p>
<ul>
<li><strong>单例模式</strong>：延迟初始化全局唯一的对象。</li>
<li><strong>高并发资源初始化</strong>：如数据库连接池、线程池等。</li>
<li><strong>框架中的扩展点加载</strong>：如 Dubbo 的 <code>ExtensionLoader</code> 按需加载扩展类。</li>
</ul>
<h2 id="双重校验锁-与类解耦"><a href="#双重校验锁-与类解耦" class="headerlink" title="双重校验锁 (与类解耦)"></a><u>双重校验锁 (与类解耦)</u></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> T instance;</span><br><span class="line">    <span class="keyword">private</span> Supplier&lt;T&gt; supplier;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Holder</span><span class="params">(Supplier&lt;T&gt; supplier)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.supplier = supplier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = supplier.get();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变种</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> T instance;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span>&#123;</span><br><span class="line">        instance = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">// 在外部实现</span></span><br></pre></td></tr></table></figure>



<h2 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举 enum"></a><u><strong>枚举 enum</strong></u></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>天然线程安全，并且能够防止反射攻击</p>
<h2 id="Holder-静态内部类-（利用类加载机制）"><a href="#Holder-静态内部类-（利用类加载机制）" class="headerlink" title="Holder 静态内部类 （利用类加载机制）"></a><u><strong>Holder 静态内部类 （利用类加载机制）</strong></u></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Holder 在 Singleton 加载时并不会被加载，只有第一次调用 <code>getInstance()</code> 才会加载 Holder，然后创建单例。</p>
<h2 id="CAS-自旋"><a href="#CAS-自旋" class="headerlink" title="CAS 自旋"></a>CAS 自旋</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReference&lt;Singleton&gt; instance = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Singleton</span> <span class="variable">current</span> <span class="operator">=</span> instance.get();</span><br><span class="line">            <span class="keyword">if</span> (current != <span class="literal">null</span>) <span class="keyword">return</span> current;</span><br><span class="line">            current = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">if</span> (instance.compareAndSet(<span class="literal">null</span>, current)) &#123; <span class="comment">// 期望值为 null，设置值为 current</span></span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>无锁，非阻塞，线程安全。实现较为复杂，追求极致性能才考虑</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Web 后端 Java</title>
    <url>/2024/09/05/web-backend/</url>
    <content><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p><strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol </p>
<p>TCPIP协议四层架构的最上层 规定了服务器和浏览器之间传输数据的规则</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP">HTTP | MDN (mozilla.org)</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">超文本传输协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>基于TCP，面向连接，安全</li>
<li>基于请求-响应模型：1Request 1Response</li>
<li>HTTP是无状态协议，对事务处理没有记忆能力，每次RR都是独立的<ul>
<li>多次请求之间不能共享数据，java用会话技术（cookie session）解决这个问题</li>
<li>优点：速度快</li>
</ul>
</li>
</ul>
<h2 id="请求数据格式"><a href="#请求数据格式" class="headerlink" title="请求数据格式"></a><a href="#request">请求数据格式</a></h2><p><strong>请求行</strong>：第一行，<code>GET</code>(请求方式) 后面的<code>/</code>表示请求资源的路径，HTTP/1.1表示协议版本</p>
<p><strong>请求头</strong>：第二行开始 key: value形式</p>
<p><strong>请求体</strong>：POST请求的最后一部分，存放请求参数</p>
<p>GET请求参数在请求行中，没有请求体，参数大小有限制(URL长度限制) POST请求的参数在请求体中，参数大小无限制</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926220614547.png" alt="image-20240926220614547"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926221417729.png" alt="image-20240926221417729"></p>
<p><strong>Host</strong>: 请求的主机名</p>
<p><strong>User-Agent</strong>: 浏览器版本</p>
<p><strong>Accept</strong>: 浏览器能接受的资源类型，如text/* image/* */* </p>
<p><strong>Accept-Language</strong>: 浏览器的偏好语言</p>
<p><strong>Accept-Encoding</strong>: 浏览器支持的压缩类型</p>
<h2 id="响应数据格式"><a href="#响应数据格式" class="headerlink" title="响应数据格式"></a>响应数据格式</h2><p><strong>响应行</strong>：响应数据的第一行，HTTP/1.1表示协议版本，下一个是响应状态码，OK表示状态码描述</p>
<p><strong>响应头</strong>：keyvalue</p>
<p><strong>响应体</strong>：最后一部分，存放响应数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926221630980.png" alt="image-20240926221630980"></p>
<p><strong>Content-Type</strong>：响应内容类型，比如text/html image/jpeg</p>
<p><strong>Content-Length</strong>：响应内容长度（bytes）</p>
<p><strong>Content-Encoding</strong>：响应压缩算法 gzip等</p>
<p><strong>Cache-Control</strong>: 指示客户端如何缓存，例如max-age=300 表示最多缓存300s</p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926222005460.png" alt="image-20240926222005460"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926222320894.png" alt="image-20240926222320894"></p>
<p>200 OK 404资源不存在 500 服务器异常</p>
<p>Java程序中，如果直接用自带的javawebsocketAPI 代码会变得异常繁琐，要注意请求和响应的格式要求，因此要用web服务器软件进行开发—-Tomcat</p>
<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>Apache Tomcat web服务器是一个应用程序，封装http协议，不用对协议进行直接操作。类似的还有jetty，weblogic，ibm webSphere，部署web项目到服务器中</p>
<p><a href="https://zhuanlan.zhihu.com/p/61596145">JavaEE的13种核心技术规范： - 知乎 (zhihu.com)</a></p>
<p><a href="https://tomcat.apache.org/">Apache Tomcat® - Welcome!</a> </p>
<h2 id="创建Web项目"><a href="#创建Web项目" class="headerlink" title="创建Web项目"></a>创建Web项目</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927151450747.png" alt="image-20240927151450747"></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">Web-&gt;META-INF()</span><br><span class="line">     WEB-INF -&gt;classes(java文件夹和resources文件夹合并)</span><br><span class="line">     	     -&gt;lib(依赖jar包)</span><br><span class="line">             -&gt;web.xml(web项目的配置文件)</span><br><span class="line">     webapp中除了WEB-INF的其他文件</span><br></pre></td></tr></table></figure>



<p>using 骨架</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927151529348.png" alt="image-20240927151529348"></p>
<p>packaging 默认jar 改成web项目用的war </p>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>动态资源web开发技术</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927162801770.png" alt="image-20240927162801770"></p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927163054997.png" alt="image-20240927163054997"></p>
<p>servlet对象，service方法由web服务器tomcat创建</p>
<p>WebServlet继承了Servlet接口</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927174147654.png" alt="image-20240927174147654"></p>
<ol>
<li>默认情况 servlet对象第一次被访问就被创建，通过改变loadOnStartup参数可以改变优先级</li>
<li>容器（tomcat）通过init方法初始化对象，只需要调用一次</li>
<li>每次请求servlet 容器都会调用servlet的service方法</li>
</ol>
<h2 id="Servlet-接口"><a href="#Servlet-接口" class="headerlink" title="Servlet 接口"></a>Servlet 接口</h2><p>定义了五个抽象方法：</p>
<ol>
<li><p><code>init(ServletConfig conf)</code>：默认情况下，servlet第一次被访问，容器创建servlet对象时，会调用init，只调用一次。改变WebServlet注解的参数loadOnStartup，可以控制在创建服务器的时候就创建servlet对象。</p>
</li>
<li><p><code>service(ServletRequest req,ServletResponse res)</code>: 每一次访问servlet就调用一次</p>
</li>
<li><p><code>destroy()</code>: 内存释放、服务器关闭时调用，只有一次</p>
</li>
<li><p><code>ServletConfig getServletConfig()</code>: servletconfig是容器调用init方法传进来的参数,可以在demo类中声明一个config成员变量，在init中赋值，然后在getConfig方法中返回</p>
</li>
<li><p><code>String getServletInfo() </code>: copyright information</p>
</li>
</ol>
<h2 id="Servlet-体系"><a href="#Servlet-体系" class="headerlink" title="Servlet 体系"></a>Servlet 体系</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927180225035.png" alt="image-20240927180225035"></p>
<p>Http doGet doPost</p>
<p>根据请求方式的不同分别处理，因为get的参数在请求行中，post的参数在请求体中。</p>
<p>httpservlet是servlet的实现类，实际上把service方法重写，接收请求参数req，如果req中是get方式，就执行doGet，如果是post就执行doPost  子类只需要重写doGetdoPost方法即可</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927181319844.png" alt="image-20240927181319844"></p>
<p>源码分析：原来的service方法重载，参数变成httpservletrequest和httpservletresponse ，原版的请求参数传进来，强制转换成httpservletrequest，然后吊用自己写好的重载service方法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927181753064.png" alt="image-20240927181753064"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927181825881.png" alt="image-20240927181825881"></p>
<h2 id="urlPattern"><a href="#urlPattern" class="headerlink" title="urlPattern"></a>urlPattern</h2><h3 id="一个servlet可以配置多个访问路径"><a href="#一个servlet可以配置多个访问路径" class="headerlink" title="一个servlet可以配置多个访问路径"></a>一个servlet可以配置多个访问路径</h3><p>urlPatterns = {“”,””}</p>
<h3 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927183113407.png" alt="image-20240927183113407"></p>
<ol>
<li>精确匹配 （优先级比目录匹配高）</li>
<li>目录匹配，通配符</li>
<li>扩展名匹配，<code>*.do</code> <code>aaa.do bbb.do</code>都可以访问，注意不能有斜杠</li>
<li>任意匹配，<code>/</code>优先级低于<code>/*</code><ul>
<li>/是tomcat默认生成的一个servlet，启动以后自动创建，是用来访问静态资源的</li>
<li>很危险，不要用</li>
</ul>
</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927183710215.png" alt="image-20240927183710215"></p>
<h3 id="web-xml配置"><a href="#web-xml配置" class="headerlink" title="web.xml配置"></a>web.xml配置</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927183912074.png" alt="image-20240927183912074"></p>
<h1 id="Request-amp-Response"><a href="#Request-amp-Response" class="headerlink" title="Request&amp;Response"></a>Request&amp;Response</h1><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927184223066.png" alt="image-20240927184223066"></p>
<p>request 获取请求数据</p>
<p>response 设置响应时的数据</p>
<p>request中含有用户输入的参数，response可以根据这个参数设置响应的数据，这样就完成了和用户交互的基本过程</p>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><h3 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927184637027.png" alt="image-20240927184637027"></p>
<p>ServletRequest和HttpServletRequest都是接口，不能实例化，定义了一些抽象方法作为规范。</p>
<p>我们的 servlet 重写了 service()方法的方法体，浏览器访问时，tomcat就要调用servlet的service方法。tomcat作为servlet容器，<strong>要解析请求报文，将其封装成req对象</strong>，送到servlet的service方法处作为参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是tomcat的程序</span></span><br><span class="line"><span class="comment">//tomcat做的是解析报文封装请求的操作，具体如何利用请求做出什么样的响应，则是开发者的工作</span></span><br><span class="line"><span class="type">MyServlet</span> <span class="variable">myServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyServlet</span>();</span><br><span class="line">myServlet.init()<span class="comment">//开发者重写</span></span><br><span class="line">myServlet.service(req,res)<span class="comment">//开发者重写</span></span><br></pre></td></tr></table></figure>

<p>所以Tomcat对接口进行了实现，查J2EE API</p>
<h3 id="获取请求数据"><a href="#获取请求数据" class="headerlink" title="获取请求数据"></a>获取请求数据</h3><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927192106826.png" alt="image-20240927192106826"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927192310996.png" alt="image-20240927192310996"></p>
<h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927192340229.png" alt="image-20240927192340229"></p>
<p>getHeader根据name来获取对应的信息</p>
<p>getHeader(“User-Agent”) 输出Mozilla/5.0 Chrome/91.0.4472.106</p>
<h4 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927192426370.png" alt="image-20240927192426370"></p>
<p>统一获取请求参数的方式？从而统一doGet和doPost方法内的代码</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927195026912.png" alt="image-20240927195026912"></p>
<p>getParameterMap 获取参数map 结构如上</p>
<p>getParameter 根据名称获取参数值</p>
<p>getParameterValues 根据名称获取参数值</p>
<h4 id="获取参数中文乱码"><a href="#获取参数中文乱码" class="headerlink" title="获取参数中文乱码"></a>获取参数中文乱码</h4><h5 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h5><p>设置输入流的字符集</p>
<p>底层是获取字符输入流BufferReader，所以<code>setCharacterEncoding(&quot;UTF-8&quot;)</code></p>
<h5 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h5><p>底层是字符串形式</p>
<p>浏览器发出请求的时候，会把中文字符转成URL编码，tomcat需要进行URL解码</p>
<h5 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h5><p>字符串按照编码方式转为二进制，每个字节转换为两个十六进制数，在前面加上%                                            </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927214608765.png" alt="image-20240927214608765"></p>
<p>Tomcat底层将URL编码 解码为ISO-8859-1</p>
<h3 id="Forward-请求转发"><a href="#Forward-请求转发" class="headerlink" title="Forward 请求转发"></a>Forward 请求转发</h3><p>服务器内部资源跳转方式，转发的资源之间共享数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928140710653.png" alt="image-20240928140710653"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928140736371.png" alt="image-20240928140736371"></p>
<p>请求内部有参数（map形式），来源URL等信息</p>
<ul>
<li><code>setAttribute(String name, Object o)</code>把数据o 存到request域中，以key为键    </li>
<li><code>removeAttribute(String name)</code> 根据key删除键值对</li>
<li><code>Object getAttribute(String name)</code>根据key获取数据</li>
</ul>
<ul>
<li>地址栏路径不发生变化；</li>
<li>只能转发到服务器内部的资源；</li>
<li>浏览器发送一次请求，多个资源共享request数据</li>
<li>高效率</li>
</ul>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928142749615.png" alt="image-20240928142749615"></p>
<h3 id="设置响应数据"><a href="#设置响应数据" class="headerlink" title="设置响应数据"></a>设置响应数据</h3><ol>
<li>响应行：设置状态码</li>
<li>响应头：设置键值对</li>
<li>响应体：通过输出流输出数据</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928142944677.png" alt="image-20240928142944677"></p>
<h3 id="Redirect-重定向"><a href="#Redirect-重定向" class="headerlink" title="Redirect 重定向"></a>Redirect 重定向</h3><p>资源跳转方式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928143039892.png" alt="image-20240928143039892"></p>
<p>状态码 <strong>302</strong> 响应头：location: 虚拟目录/demo6</p>
<p><code>sendRedirect(String url)</code>发送重定向响应</p>
<p><code>setStatus(302)</code> </p>
<p><code>setHeader(&quot;location&quot;,&quot;https://www.google.com&quot;)</code> </p>
<p><code>setHeader(&quot;Content-type&quot;,&quot;text/html&quot;)</code> </p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>地址栏路径发生变化；</li>
<li>转发任意资源；</li>
<li>浏览器发送两次请求，不能在多个资源用request共享数据</li>
<li>效率低</li>
</ul>
<h4 id="路径问题-动态获取虚拟目录"><a href="#路径问题-动态获取虚拟目录" class="headerlink" title="路径问题 动态获取虚拟目录"></a>路径问题 动态获取虚拟目录</h4><p>如果浏览器使用，需要加虚拟目录</p>
<p>服务端使用就不需要加了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928145151848.png" alt="image-20240928145151848"></p>
<p>虚拟目录可以动态变化，所以尽量减少硬编码，减少耦合性</p>
<p>可以用<code>request</code>的<code>getContextPath()</code> 获取虚拟目录</p>
<h3 id="设置响应数据-1"><a href="#设置响应数据-1" class="headerlink" title="设置响应数据"></a>设置响应数据</h3><h4 id="字符数据"><a href="#字符数据" class="headerlink" title="字符数据"></a>字符数据</h4><p><code>getWriter().write(String s) </code>写入数据到资源中</p>
<p><code>setContentType(&quot;text/html;charset=utf-8&quot;)</code>   </p>
<p>细节：不用关闭流</p>
<p>乱码可以用响应头设置编码，tomcat8不乱码</p>
<h4 id="字节数据"><a href="#字节数据" class="headerlink" title="字节数据"></a>字节数据</h4><p>ServletOutputStream = request.getOutputStream()</p>
<h2 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h2><p>用来创建与数据库的连接会话,只需要一个即可，所以运用单例的设计模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryUtils</span>&#123;</span><br><span class="line">    SqlSessionFactory factory;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">    SqlSessionFactory <span class="title function_">getSqlSessionFactory</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h2 id="入门-1"><a href="#入门-1" class="headerlink" title="入门"></a>入门</h2><p>Java Server Pages 静态的页面嵌入动态的代码 简化开发</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928175143005.png" alt="image-20240928175143005"></p>
<p>JSP本质是servlet，把写标签等繁琐的工作交给jsp技术</p>
<h3 id="JSP脚本"><a href="#JSP脚本" class="headerlink" title="JSP脚本"></a>JSP脚本</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928175642020.png" alt="image-20240928175642020"></p>
<ol>
<li><p>service方法是访问到这个资源的时候调用</p>
</li>
<li><p>out.print() 是printWriter 调用的</p>
</li>
<li><p>被生成的jsp类直接包含</p>
</li>
</ol>
<p>截断java代码，中间插入html标签是可以的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928180319108.png" alt="image-20240928180319108"></p>
<p>出现HTML标签的地方可以理解为java程序代替你输入这些标签，最简单的字面意义上的代替功能，因此截断也没什么关系</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928180738621.png" alt="image-20240928180738621"></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928180843640.png" alt="image-20240928180843640"></p>
<h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928181558853.png" alt="image-20240928181558853"></p>
<h2 id="JSTL-标签库"><a href="#JSTL-标签库" class="headerlink" title="JSTL 标签库"></a>JSTL 标签库</h2><p><mark><strong>#{}</strong><mark></p>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928182101658.png" alt="image-20240928182101658"></p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928182210315.png" alt="image-20240928182210315"></p>
<p>brand.id 不是访问成员变量，是要调用get方法</p>
<p>自动调用getId()</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928182800258.png" alt="image-20240928182800258"></p>
<p>varStatus 计数器</p>
<p>status.count是计数从1开始，status.index是从1开始</p>
<h4 id="普通for循环"><a href="#普通for循环" class="headerlink" title="普通for循环"></a>普通for循环</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928183033816.png" alt="image-20240928183033816"></p>
<p>Java虚拟机负责存储变量信息，jsp只负责展示与变量相关的信息，因此不用重启服务器，</p>
<h2 id="Servlet-JSP开发"><a href="#Servlet-JSP开发" class="headerlink" title="Servlet+JSP开发"></a>Servlet+JSP开发</h2><p><strong>业务逻辑层</strong>本质上是对dao层的封装，包括创建session，创建mapper，mapper调用dao方法，事务等。</p>
<p>每个servlet都是资源，浏览器能够通过网址或者表单的形式发出请求，servlet根据request的参数进行一系列业务逻辑操作，将返回的结果转发给jsp页面。</p>
<p>jsp本质也是一个servlet，将请求中的参数打印出来的同时还能生成html标签，浏览器就能通过html标签解析出网页。</p>
<p>在修改页面改了一个数据，提交表单到updateServlet，updateServlet进行业务操作，完成后，把包含参数的请求转发到 浏览所有数据 的showAll.jsp页面，jsp本质是servlet，负责打印标签和数据。</p>
<h1 id="MVC-设计模式"><a href="#MVC-设计模式" class="headerlink" title="MVC 设计模式"></a>MVC 设计模式</h1><p><strong>Model</strong>：接受Controller发出的指令，与数据库交互，增删改查，返回数据给Controller</p>
<p><strong>View</strong>：接受Controller发出的数据（Model给的）渲染页面，返回HTML页面给Controller</p>
<p><strong>Controller</strong>：接受客户端的数据请求，返回给客户端HTML页面，同时与model和view交流，充当Model和View之间的桥梁。</p>
<p>Model和View之间一个是处理数据，一个是呈现数据，二者可以专注于各自的事情</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240919202449018-1727923726251-1.png" alt="image-20240919202449018"></p>
<p>Servlet controller </p>
<p>JSP View </p>
<p>JavaBean Model </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928183538077-1727923726251-2.png" alt="image-20240928183538077"></p>
<p>三层架构</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928183903472-1727923726251-3.png" alt="image-20240928183903472"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928183924963-1727923726251-4.png" alt="image-20240928183924963"></p>
<h1 id="Cookie-amp-Session-amp-JWT"><a href="#Cookie-amp-Session-amp-JWT" class="headerlink" title="Cookie&amp;Session&amp;JWT"></a>Cookie&amp;Session&amp;JWT</h1><h2 id="会话跟踪技术"><a href="#会话跟踪技术" class="headerlink" title="会话跟踪技术"></a>会话跟踪技术</h2><p>浏览器打开一个网站就是会话建立的过程，其中可以<strong>包含多次请求和响应</strong>，服务段需要区分不同的会话，判断多次请求是否来自统一浏览器，以便在同一次会话的<strong>多次请求之间，共享数据。</strong></p>
<p><strong>HTTP协议是无状态</strong>的，为了最佳的请求响应效率，牺牲了存储记忆数据的功能，每次请求都被视作新的请求，因此要跟踪回话实现会话内数据共享。</p>
<p>本质是将数据存储在一端</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928201532521.png" alt="image-20240928201532521"></p>
<p>客户端：<strong>Cookie</strong> </p>
<p>服务端：<strong>Session</strong> </p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>客户端的会话技术，保存数据到客户端，每次请求都携带cookie数据进行访问。客户端的记忆</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928202227465.png" alt="image-20240928202227465"></p>
<p>响应的时候setcookie，请求的时候带着cookie</p>
<h3 id="发送cookie"><a href="#发送cookie" class="headerlink" title="发送cookie"></a>发送cookie</h3><p>创建Cookie，设置键值对</p>
<p>response调用addCookie方法发送cookie</p>
<h3 id="获取cookie"><a href="#获取cookie" class="headerlink" title="获取cookie"></a>获取cookie</h3><p>request对象调用getCookies 接收cookies</p>
<p>for循环遍历，getName和getValue</p>
<h2 id="cookie的原理"><a href="#cookie的原理" class="headerlink" title="cookie的原理"></a>cookie的原理</h2><p><strong>基于HTTP协议</strong></p>
<p>响应的时候，做好cookie传回去，<strong>响应头</strong>setCookie:username=zs</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928204006874.png" alt="image-20240928204006874"></p>
<p>浏览器再次请求的时候，<strong>请求头</strong>中cookie:username=zs</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928204020606.png" alt="image-20240928204020606"></p>
<h3 id="cookie使用细节"><a href="#cookie使用细节" class="headerlink" title="cookie使用细节"></a>cookie使用细节</h3><h4 id="存活时间"><a href="#存活时间" class="headerlink" title="存活时间"></a>存活时间</h4><p><strong>默认</strong>存储在浏览器内存中，关闭浏览器会释放内存，销毁cookie</p>
<p>setMaxAge(int seconds) 正数：写入浏览器硬盘，到时间自动删除；负数：写入内存，自动销毁；零：删除对应cookie</p>
<p>30天内免登录</p>
<p>cookie是键值对 </p>
<h4 id="cookie存储中文"><a href="#cookie存储中文" class="headerlink" title="cookie存储中文"></a>cookie存储中文</h4><p>可以把字符串用URL编码</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928205018701.png" alt="image-20240928205018701"></p>
<p>服务端的记忆功能</p>
<p>request.getSession();</p>
<p>set Attribute 存到session域中</p>
<p>get Attribute</p>
<p>session是键值对集合，存储在服务器</p>
<p><strong>Session基于Cookie实现</strong> </p>
<p>如何保证多个浏览器不是同一个session？发送一个sessionID的cookie，作为唯一标识，浏览器请求的时候会带着cookie。响应的时候创建一个session，把浏览器唯一对应的session对象id作为cookie发过去，再次请求的时候带着sessionid作为cookie就能找到对应的session对象去存储</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928210309806.png" alt="image-20240928210309806"></p>
<p>识别sessionid如果已经创建过了就不再创建</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928210431476.png" alt="image-20240928210431476"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928210448553.png" alt="image-20240928210448553"></p>
<h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><h4 id="session-钝化、活化"><a href="#session-钝化、活化" class="headerlink" title="session 钝化、活化"></a>session 钝化、活化</h4><p>钝化：服务器正常关闭，tomcat自动把session存到硬盘</p>
<p>活化：服务器开启，从session文件读取</p>
<p>浏览器关闭后中断会话，session不是同一个</p>
<h4 id="session-销毁"><a href="#session-销毁" class="headerlink" title="session 销毁"></a>session 销毁</h4><ul>
<li>自动销毁web.xml sessionconfig 时间默认为30分钟</li>
<li>手动销毁：登出</li>
</ul>
<h2 id="Cookie-vs-Session"><a href="#Cookie-vs-Session" class="headerlink" title="Cookie vs. Session"></a>Cookie vs. Session</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928220229036.png" alt="image-20240928220229036"></p>
<p>安全性，长期存储</p>
<p>cookie保证用户在未登录情况下的身份识别</p>
<p>session存储用户登录以后的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928225946421.png" alt="image-20240928225946421"></p>
<h3 id="登录系统DEMO"><a href="#登录系统DEMO" class="headerlink" title="登录系统DEMO:"></a>登录系统DEMO:</h3><p>login.jsp页面</p>
<p>登录成功存储用户信息，并且要重定向到另一个brand.jsp页面，两次会话共享信息，考虑安全性，session</p>
<p>登录失败，转发回登录页面，把错误 信息加进request域中，jsp登录页面显示的是错误信息</p>
<p>记住用户登录信息：登录成功并且勾选了复选框（发送复选框的value参数，Object.equals或是”1”.equals（remember））创建username和password的cookie并发送到浏览器。修改login.jsp：拿到请求中的cookies，分别把响应的数据填到页面的username和password中。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928223745507.png" alt="image-20240928223745507"></p>
<h3 id="用户注册DEMO"><a href="#用户注册DEMO" class="headerlink" title="用户注册DEMO:"></a>用户注册DEMO:</h3><p>reg.jsp </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928223916558.png" alt="image-20240928223916558"></p>
<p>if(布尔表达式){</p>
<p>}</p>
<p>return 布尔表达式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928231442349.png" alt="image-20240928231442349"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928231455396.png" alt="image-20240928231455396"></p>
<p>展示验证码：servlet输出的验证码作为img src显示在HTML静态页面上，写js脚本把点击事件设置成重新请求一次，每次请求的路径不同 (?号后面加时间)，防止浏览器缓存</p>
<p>生成验证码和提交注册表单一共需要两次请求，是不同的servlet在处理，所以服务器要在生成的时候将验证码存到session中，提交注册表单的时候再次从session中访问数据看是否一致。存到cookie中会直接被抓取然后攻击，失去了验证码的功能</p>
<p>if else if直接return就不用else了</p>
<p>checkcodeServlet 生成code，输出到自己的输出流中  </p>
<h2 id="Token-Json-Web-Token"><a href="#Token-Json-Web-Token" class="headerlink" title="Token(Json Web Token)"></a>Token(<u>J</u>son <u>W</u>eb <u>T</u>oken)</h2><p><a href="https://developer.aliyun.com/article/995894#comment">JWT详细讲解(保姆级教程)-阿里云开发者社区 (aliyun.com)</a></p>
<h3 id="token-cookie-session"><a href="#token-cookie-session" class="headerlink" title="token cookie session"></a>token cookie session</h3><h4 id="Cookie-1"><a href="#Cookie-1" class="headerlink" title="Cookie"></a>Cookie</h4><p>本质是键值对，客户端发起请求，服务端响应会把包含着用户信息的set-cookie 加入响应头，客户端收到set-cookie，下次发送请求，请求头中会带着包含相同内容的cookie，服务端只需要根据cookie响应对应用户的资源。</p>
<p>局限：数据直接存放在浏览器端内存，安全性差，</p>
<p>优化：把set-cookie内容除了正常的cookie内容再加一段报文鉴别码，使用服务器自己的私钥进行签名，</p>
<p>优点：存储期限长</p>
<h4 id="Session-1"><a href="#Session-1" class="headerlink" title="Session"></a>Session</h4><p>以cookie为基础，本质是一个对象，每个session可以通过唯一的sessionID进行访问，客户端发起请求，服务端会把包含着sessionID信息的set-cookie响应给客户端，客户端下次发送请求，请求头中会带着包含着sessionID信息的cookie，服务端根据sessionID找到对应的session，响应对应用户的资源</p>
<p>优点：数据完全存储在服务端内存，安全性很高，</p>
<p>缺点：</p>
<p>最重要的是，session只支持单体服务器，session拷贝效率低，</p>
<p>默认不支持跨域名，但是不同域名可能是会共享用户信息的，</p>
<p>因此在集群部署，分布式应用，前后端分离的背景下，session已经不再适用</p>
<h4 id="JsonWebToken"><a href="#JsonWebToken" class="headerlink" title="JsonWebToken"></a>JsonWebToken</h4><p>base64: 将原来的字符串二进制化，然后重新分成每6位一组，6位对应有64个索引，分别对应0-9和所有大小写英文字母</p>
<p>用户信息保存在浏览器端内存，本质就是一条加密字符串。</p>
<h5 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h5><p>RSA—单向陷门函数：加密数字5，公钥是7,33 ，<strong>5</strong>^7^ mod 33 = <mark>14<mark>，解密使用公钥，x^7^ mod 33 = <mark>14<mark> 的数字有无数个，也就无法推算出具体的x，只能穷举。如果有了私钥3,33，<mark>14<mark>^3^ mod 33 = <strong>5</strong> 很容易就能算出原数字5</p>
<p>加密和解密都用同一种算法，但不是逆向。</p>
<p><strong>签名算法：</strong> </p>
<p>HS256：$A+H(A,K)$ 签发和验证都使用同一个密钥，只适用于单体应用。H表示密钥拼接在报文后进行哈希。S表示SHA256</p>
<p>RS256, ES256：$A+D(H(A))$ 签发用私钥，验证用公钥，适合分布式架构，安全性更高。R,E分别表示RSA与ECDSA，S表示SHA256。</p>
<h5 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h5><p>header(base64-encoded).payload(base64-encoded).signature(HMACSHA256-encoded)</p>
<ul>
<li>header 用于定义token类型以及加密算法（非对称），用base64编码，相当于明文</li>
<li>payload 用于装载要传输的用户数据，用base64编码，相当于明文<ul>
<li>附加一些预定义声明</li>
<li>iss: 签发者issuer</li>
<li>sub: jwt所面向的用户subject</li>
<li>aud: 接收jwt的一方audience</li>
<li>iat: jwt的签发时间 issued at</li>
<li>exp: jwt的过期时间，必须大于签发时间  expire</li>
<li>nbf: 定义在什么时间之前，该jwt都是不可用的. not valid before</li>
<li>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击 jwtid</li>
</ul>
</li>
</ul>
<p><code>注意:对于已签名的Token，这些信息虽然受到保护，不会被篡改，但任何人都可以阅读。除非加密，否则不要将机密信息放在 JWT 的有效负载或头元素中。</code> </p>
<ul>
<li>signature = HS256…(header(base64)+payload(base64)+secret)私钥 ，用header指定的算法进行加密，鉴权核心</li>
</ul>
<p>用户请求通过鉴权成功，<strong>服务端通过私钥签发JWT字符串</strong>，通过响应返回给用户，用户后续请求会在请求头中添加一个authorization:token的键值对。</p>
<p>再次请求，鉴权成功，然后将JWT根据secret进行解密，验证此JWT是否有效。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241030152447734.png" alt="image-20241030152447734"></p>
<p>假如其他人偶然间拿到了JWT，然后篡改JWT，服务器拿私钥解密JWT，会发现信息被篡改。</p>
<h1 id="Filter-amp-Listener"><a href="#Filter-amp-Listener" class="headerlink" title="Filter&amp;Listener"></a>Filter&amp;Listener</h1><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>拦截资源请求</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928234937677.png" alt="image-20240928234937677"></p>
<h3 id="入门-2"><a href="#入门-2" class="headerlink" title="入门"></a>入门</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928235049041.png" alt="image-20240928235049041"></p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929000311150.png" alt="image-20240929000311150"></p>
<p>先访问完资源，然后执行放行后的逻辑</p>
<p>放行前对request进行处理，放行后对response进行处理</p>
<h3 id="使用细节-1"><a href="#使用细节-1" class="headerlink" title="使用细节"></a>使用细节</h3><h4 id="拦截路径"><a href="#拦截路径" class="headerlink" title="拦截路径"></a>拦截路径</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929000603427.png" alt="image-20240929000603427"></p>
<p>拦截的是具体的资源，不是说filter访问哪个路径</p>
<h4 id="Filter链"><a href="#Filter链" class="headerlink" title="Filter链"></a>Filter链</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929000822547.png" alt="image-20240929000822547"></p>
<p>执行顺序：类名字符串自然排序</p>
<h4 id="案例：登录验证才可以访问"><a href="#案例：登录验证才可以访问" class="headerlink" title="案例：登录验证才可以访问"></a>案例：登录验证才可以访问</h4><p>第一次请求，没有登录，跳转到登录页面</p>
<p>filter要看是否登录，登录成功就把username pswd存到客户端session中，下一次请求的时候就验证session是否有值，没有值就继续</p>
<p>从服务端获取用户的session，session存储登录密码，如果session</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929011626311.png" alt="image-20240929011626311"></p>
<p>针对某个资源设置filter，第一次访问被拒绝，<strong>转发</strong>到login页面，此时网址不会变化，就会把这个资源的网址缓存成login页面的样式，login成功以后如果再次访问这个资源，会展示login页面，只有刷新一下才能解决这个问题</p>
<h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929121700747.png" alt="image-20240929121700747"></p>
<h1 id="HTML-CSS-JavaScript-Java-Web-前端-md"><a href="#HTML-CSS-JavaScript-Java-Web-前端-md" class="headerlink" title="[HTML+CSS+JavaScript](.\Java Web 前端.md)"></a>[HTML+CSS+JavaScript](.\Java Web 前端.md)</h1><h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a><span id=ajax>AJAX</span></h1><p>异步JS和XML <strong>A</strong>synchronous <strong>J</strong>avaScript <strong>A</strong>nd <strong>X</strong>ML </p>
<p><strong>AJAX作用1：与服务器交换数据，前后端分离</strong></p>
<ul>
<li>Servlet+JSP开发：HTML是静态的，要想展示动态的数据必须要让servlet根据请求中的参数来手动打印页面（JSP），服务端负担较重</li>
<li>AJAX+HTML: 替换JSP页面 ，AJAX给服务器<strong>发送请求</strong>，<strong>获取服务器响应</strong>的数据，展示给浏览器</li>
</ul>
<p><strong>AJAX作用2：异步交互</strong></p>
<p>不刷新<strong>整个页</strong>面也能与服务器交换数据，更新部分网页，如搜索联想，用户名是否可用校验</p>
<p>用户名按照一定的规则：直接本地编写js脚本即可，如果用户名不能和已有的重复，还应该发送请求，接收服务器响应回来的结果（数据库中是否重名）</p>
<h2 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929161209624.png" alt="image-20240929161209624"></p>
<p>异步操作使 用户可以在等待响应的同时继续与页面互动，这使得应用程序更具响应性</p>
<p>不用刷新整个页面，只跟服务器请求需要的数据，而不是整个页面，AJAX可以减少服务器的负担和网络流量，提高响应速度。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929161455819.png" alt="image-20240929161455819"></p>
<p>URL 全路径，前后端完全分离</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929161832460.png" alt="image-20240929161832460"></p>
<h2 id="异步请求案例"><a href="#异步请求案例" class="headerlink" title="异步请求案例"></a><span id="request">异步请求案例</span></h2><p>现在有这样一个需求，在浏览器填完了一个用户名，要把用户名发送到服务器的某个servlet，servlet根据用户名查询是否重复，并把数据传回到浏览器。</p>
<p>首先应该让失焦事件绑定函数，函数中要查询用户名。</p>
<p>设置 提示重复字句的style属性为不可见（正常情况下不可见）ajax根据传回的数据为true or false，改变 提示重复字句的style属性，如果是，则设置可见，如果否，则设置不可见。</p>
<p>具体流程？可以通过以下步骤：</p>
<h2 id="前端发送请求"><a href="#前端发送请求" class="headerlink" title="前端发送请求"></a>前端发送请求</h2><p>使用 JavaScript（比如 <code>XMLHttpRequest</code> 或 Fetch API）发送请求：</p>
<ul>
<li><strong>GET 方法</strong>（URL 参数字符串）：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>).<span class="property">value</span>;</span><br><span class="line">xhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://example.com/checkUsername?username=&quot;</span> + <span class="built_in">encodeURIComponent</span>(username));</span><br><span class="line">xhttp.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>POST 方法</strong>（请求体）：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>).<span class="property">value</span>;</span><br><span class="line">xhttp.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;http://example.com/checkUsername&quot;</span>);</span><br><span class="line">xhttp.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">xhttp.<span class="title function_">send</span>(<span class="string">&quot;username=&quot;</span> + <span class="built_in">encodeURIComponent</span>(username));</span><br></pre></td></tr></table></figure>

<h3 id="服务器端处理"><a href="#服务器端处理" class="headerlink" title="服务器端处理"></a>服务器端处理</h3><p>在 Servlet 中处理请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="comment">// 查询数据库检查用户名是否重复</span></span><br><span class="line">    <span class="comment">// 返回结果到浏览器</span></span><br><span class="line">    response.setPatameter...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    doGet(request,response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h3><ul>
<li><strong>GET</strong>：参数通过 URL 传递，适合获取数据，但不适合传递敏感信息，因为 URL 可见，且请求长度有限。</li>
<li><strong>POST</strong>：参数通过请求体传递，适合发送大量数据或敏感信息。</li>
</ul>
<p>要探究本质，就要解析他们的**<mark>报文<mark>**  </p>
<p>GET：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /search?query=java&amp;page=2 HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>POST：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /search HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">?query=java&amp;page=2 </span><br></pre></td></tr></table></figure>

<p>这些都是一个个字符串而已，发送的时候设置URL和参数本质上都是拼字符串，然后把整段报文发给服务。Servlet 接收请求，解析报文，拿到参数，仅此而已。填写表单的时候也一样，form标签的action属性就是要发送请求的目标，输入参数，提交的时候，就相当于填写好了目标URL，既然目标确定了。浏览器会解析内容，写好报文，发送给目标，那么浏览器是如何确定要发送给谁呢？浏览器确定请求的目标地址（即请求的 URL）是通过 URL 来实现的。以下是这一过程的基本步骤：以GET请求为例：</p>
<h3 id="目标URL的填写"><a href="#目标URL的填写" class="headerlink" title="目标URL的填写"></a>目标URL的填写</h3><p>用户在浏览器中提交表单（例如，点击“提交”按钮），这会触发一个请求。表单的 <code>action</code> 属性指定了要发送请求的 URL。浏览器会将表单数据编码为查询字符串，并附加到 <code>action</code> URL 后面作为要访问的目标。</p>
<h3 id="解析-URL"><a href="#解析-URL" class="headerlink" title="解析 URL"></a>解析 URL</h3><p>浏览器解析这个 URL，分解成几个部分：</p>
<ul>
<li><strong>协议</strong>：<code>http</code></li>
<li><strong>主机名</strong>：<code>www.example.com</code></li>
<li><strong>路径</strong>：<code>/search</code></li>
<li><strong>查询字符串</strong>：<code>?query=java</code></li>
</ul>
<h3 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h3><p>浏览器会通过 DNS（域名系统）将主机名转换为相应的 IP 地址，以便找到目标服务器。例如，<code>www.example.com</code> 可能会被解析为 <code>192.0.2.1</code>。</p>
<h3 id="建立-TCP-连接"><a href="#建立-TCP-连接" class="headerlink" title="建立 TCP 连接"></a>建立 TCP 连接</h3><p>浏览器与目标服务器建立 TCP 连接，通常使用 HTTP 端口（默认为 80，HTTPS 为 443）。</p>
<h3 id="构造请求报文"><a href="#构造请求报文" class="headerlink" title="构造请求报文"></a>构造请求报文</h3><p>一旦连接建立，浏览器会根据表单数据构造 HTTP 请求报文，包括请求行、请求头和请求体。</p>
<h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>浏览器通过已建立的 TCP 连接，将构造好的请求报文发送到服务器的指定 IP 地址。</p>
<h3 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h3><p>服务器接收到请求后，会根据请求的路径和参数来处理请求，最终返回相应的响应数据。</p>
<p>发出请求实际上就是浏览器访问目标URL</p>
<p>表单：action就是目标URL，如果是get请求，浏览器会将目标url加上参数。随后解析url，得出目标IP，根据这些参数生成请求报文发送到目标IP。</p>
<h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>axios是对js 的封装</p>
<p><a href="https://www.axios-http.cn/">Axios中文文档 | Axios中文网 (axios-http.cn)</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929192249373.png" alt="image-20240929192249373"></p>
<p>method url data</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929192732304.png" alt="image-20240929192732304"></p>
<p>链式编程</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(url).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">resp</span>)&#123;</span><br><span class="line">    <span class="comment">//具体用响应干什么？</span></span><br><span class="line">&#125;)</span><br><span class="line">axios.<span class="title function_">post</span>(url,data).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">resp</span>)&#123;</span><br><span class="line">    <span class="comment">//具体用响应干什么？</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>resp：</p>
<p>①data :实际响应回来的数据</p>
<p>②headers :响应头信息</p>
<p>③status :响应状态码</p>
<p>④statusText:响应状态信息</p>
<p>特色：自动将data对象序列化为json字符串，再自动将响应数据中的json转回js自定义对象</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929210844535.png" alt="image-20240929210844535"></p>
<p>解构赋值：then({data}) 只取resp的data字段</p>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p><strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation js对象表示法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929194822398.png" alt="image-20240929194822398"></p>
<p>字段名要用双引号括起来，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">    <span class="string">&quot;key1&quot;</span>:value1,</span><br><span class="line">    <span class="string">&quot;key2&quot;</span>:value2</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//json.key1 访问value1</span></span><br><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">    <span class="attr">key1</span>:value1,</span><br><span class="line">    <span class="attr">key2</span>:value2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这两个对象的主要区别在于属性名的引号使用。在第一个对象中，所有属性名都用双引号包围，而在第二个对象中，属性名没有引号。根据 JavaScript 的语法，属性名可以不加引号（如果是有效的标识符），但如果包含特殊字符或空格，就需要加引号。功能上，它们是等价的。</p>
<p>axios发送自定义对象会自动转成json的形式</p>
<h2 id="JSON数据和Java对象转换"><a href="#JSON数据和Java对象转换" class="headerlink" title="JSON数据和Java对象转换"></a>JSON数据和Java对象转换</h2><p>Fastjson 高性能JSON库。</p>
<p>导入fastjson坐标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line"><span class="comment">//对象tostring</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> JSON.parseObject(user, User.class);</span><br><span class="line"><span class="comment">//解析出对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/json;charset=utf-8&quot;</span>);</span><br><span class="line">response.getWriter().write(jsonString)</span><br></pre></td></tr></table></figure>

<h2 id="案例：增删改查"><a href="#案例：增删改查" class="headerlink" title="案例：增删改查"></a>案例：增删改查</h2><p><strong>查询</strong>：把axios发送请求接收响应数据并打印数据的过程 封装成一个函数，跟onload（brandSelect页面加载完成）绑定。</p>
<p>axios+html 接收servlet响应，打印表格</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929200621197.png" alt="image-20240929200621197"></p>
<p>axios这边接收到json，也就是resp.data 是对象的集合，所以用for循环遍历，由于是打印，所以可以用id锚定表格的标签，每遍历一次就累加字符串一次，最后一起写入表格标签的innerHTML中。</p>
<p><strong>新增品牌</strong>：</p>
<p>表单提交的操作是一个同步请求，同步请求是直接发送参数字段，而且需要重新加载页面才能生效，利用不上js的异步高效性，所以提交按钮应该设置成普通button，进行异步操作</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929203719660.png" alt="image-20240929203719660"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929204058611.png" alt="image-20240929204058611"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929204235548.png" alt="image-20240929204235548"></p>
<p>获取表单数据，字符串直接赋值，复选框的结果用checked表示，因为这是两个复选框，名字都叫status，所以返回的是一个元素数组，对这个数组进行便利，被选中的就把自己的value赋给对象。</p>
<p>axios发送自定义对象会自动转成json的形式，直接把封装好的自定义对象添加到axios的data参数中即可</p>
<p>函数绑定提交按钮的onclick事件，设定js函数把表单填入的内容封装成json对象（即为前面的操作），发送ajax请求给addServlet。</p>
<p><strong>addServlet</strong>处，<u>getParameter不能接收json数据</u>，所以应该用<u>getReader.readLine读取字符串</u>，然后把json字符串转成pojo对象，执行添加操作，返回操作成功与否，作为响应数据发出。</p>
<p>axios接收响应数据，如果操作成功，就跳转到第一步做出来的加载html页面中</p>
<p>增删改用post 查用get </p>
<h1 id="Vue-Servlet-开发"><a href="#Vue-Servlet-开发" class="headerlink" title="Vue+Servlet 开发"></a>Vue+Servlet 开发</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul>
<li><strong>Vue</strong>：前端的JS骨架，model view双向绑定，渲染网页</li>
<li><strong>axios</strong>：AJAX请求发送</li>
<li><strong>Element</strong> <strong>UI</strong>：CSS组件库，基于Vue</li>
</ul>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ul>
<li><strong>Web层</strong>：Servlet调用Service层的方法查询，结果转为JSON，响应JSON数据发给客户端</li>
<li><strong>Service层</strong>：BrandService定义selectAll方法，获取sqlSession对象，调用BrandMapper执行SQL语句</li>
<li><strong>DAO层</strong>：BrandMapper定义selectAll方法，方法体为MyBatis执行某条具体的SQL语句</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002150928236.png" alt="image-20241002150928236"></p>
<h2 id="服务端优化"><a href="#服务端优化" class="headerlink" title="服务端优化"></a>服务端优化</h2><h3 id="Service-优化"><a href="#Service-优化" class="headerlink" title="Service 优化"></a>Service 优化</h3><h4 id="Service-接口定义"><a href="#Service-接口定义" class="headerlink" title="Service 接口定义"></a>Service 接口定义</h4><ul>
<li>定义 <strong>BrandService</strong> 接口：定义一些业务的抽象方法，实现类中实现业务方法，在servlet中创建好业务实现对象，这样就解除了service层和servlet层的耦合性</li>
</ul>
<h4 id="ServiceImpl-接口实现"><a href="#ServiceImpl-接口实现" class="headerlink" title="ServiceImpl 接口实现"></a>ServiceImpl 接口实现</h4><ul>
<li>在实现类中，先创建好唯一的的factory工厂，然后在方法中开启sqlSession，执行SQL语句</li>
</ul>
<h4 id="优化结果"><a href="#优化结果" class="headerlink" title="优化结果"></a>优化结果</h4><ul>
<li><strong>UserService:</strong></li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164617150.png" alt="image-20241002164617150"></li>
<li><strong>UserServiceImpl:</strong></li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164523529.png" alt="image-20241002164523529"></li>
</ul>
<h3 id="Servlet-优化"><a href="#Servlet-优化" class="headerlink" title="Servlet 优化"></a>Servlet 优化</h3><h4 id="业务实现类的创建"><a href="#业务实现类的创建" class="headerlink" title="业务实现类的创建"></a>业务实现类的创建</h4><p>为了增强项目的组织度，会进行业务整合，在BrandServlet中，创建一个BrandService的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BrandServlet</span>&#123;</span><br><span class="line">	<span class="type">BrandService</span> <span class="variable">brandService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrandServiceImpl1</span>();</span><br><span class="line">    <span class="comment">//调用service的方法</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="业务功能整合"><a href="#业务功能整合" class="headerlink" title="业务功能整合"></a>业务功能整合</h4><p>一个实体类的一个功能就要新创建一个Servlet，不易管理，要把一个实体类的所有功能都放在一个servlet中。（BrandServlet，UserServlet）通过/brand/*   /user/*来访问上述两个servlet。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002135939524.png" alt="image-20241002135939524"></p>
<ul>
<li>如图，原先<code>HttpServlet</code>的<code>service</code>方法根据请求的方式（<code>getMethod</code>）进行方法的分发（<code>doGe</code>t或<code>doPost</code>）</li>
<li>现在要根据请求的路径来进行方法的分发，因此<code>BrandServlet</code>不能直接继承<code>HttpServlet</code>，要创建一个<code>BaseServlet</code>继承<code>HttpServlet</code>，重写其<code>service</code>方法，根据路径分发方法。同理<code>UserServlet</code>也直接继承<code>Base</code></li>
<li>获取到请求路径的最后一部分（最后一个<code>/</code>之后的内容）就是请求的方法名</li>
<li>方法名称有了还要找<code>对应servlet</code>的字节码文件，<code>baseServlet</code>没有<code>@WebServlet</code>注解，也就不会直接访问了，到时候被访问的应该是<code>BrandServlet</code>和<code>UserServlet</code>这两个子类，子类继承父类的<code>service</code>方法，所以<code>service</code>方法中的<code>this.getClass</code>就能理所应当地拿到子类的字节码文件。</li>
<li>因为<code>BrandServlet</code>和<code>UserServlet </code>都是要先执行<code>service(req,resp)</code>方法，接收<code>request</code>参数和<code>response</code>参数，如果要执行具体的<code>selectAll</code>业务方法，就要在反射调用方法的时候把参数加上，同时在<code>子类servlet</code>中，业务方法接受的参数全部统一成<code>req</code>和<code>resp</code>。</li>
</ul>
<p>如此一来，就能实现：</p>
<ol>
<li>访问<code>/brand/selectAll</code>路径，</li>
<li>调用重写过后的<code>service(HttpServletRequest req,HttpServletResponse resp)</code> 能获取方法名和字节码文件</li>
<li>根据方法名和参数类型（<code>methodName, HttpServletRequest req.class, HttpServletResponse.class</code>）获取Method对象，</li>
<li><code>method.invoke(this, req, resp)</code>，实现业务整合</li>
</ol>
<h4 id="优化结果-1"><a href="#优化结果-1" class="headerlink" title="优化结果"></a>优化结果</h4><ul>
<li><strong>BaseServlet:</strong></li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164451103.png" alt="image-20241002164451103"></li>
<li><strong>UserServlet:</strong> </li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164355800.png" alt="image-20241002164355800"></li>
</ul>
<h3 id="优化后的后端结构"><a href="#优化后的后端结构" class="headerlink" title="优化后的后端结构"></a>优化后的后端结构</h3><p>后端的DAO, Service, Web层分开 各司其职，减少了耦合度</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164240142.png" alt="image-20241002164240142" style="zoom: 50%;" />



<h2 id="其他细节"><a href="#其他细节" class="headerlink" title=" 其他细节 "></a><span id="mybatis"> 其他细节 </span></h2><h3 id="MyBatis-模糊查询"><a href="#MyBatis-模糊查询" class="headerlink" title="MyBatis 模糊查询"></a>MyBatis 模糊查询</h3><h4 id="39-password-39-不行？-39-password-39-行？"><a href="#39-password-39-不行？-39-password-39-行？" class="headerlink" title="&#39;%#{password}%&#39;不行？&#39;%${password}%&#39;行？"></a><code>&#39;%#&#123;password&#125;%&#39;</code>不行？<code>&#39;%$&#123;password&#125;%&#39;</code>行？</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002225509824.png" alt="image-20241002225509824"></p>
<p>${password}就是最简单的文本替换，直接拼接字符串，也不会类型转换（输入参数<code>that</code>会直接拼接成<code>and password like that</code> 很显然少了引号）连SQL都无法注入<code>&#39; OR &#39;1&#39; = &#39;1</code> <code>and password like &#39; OR &#39;1&#39; = &#39;1</code> （语法错误）自然，模糊匹配就变成<code>&#39;%that%&#39;</code>了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002230031380.png" alt="image-20241002230031380"></p>
<p>预编译占位符#{password}会把整个password转换成字符串，输入参数<code>&#39; OR &#39;1&#39; = &#39;1</code>会帮你转义成<code>\&#39; OR \&#39;1\&#39; = \&#39;1</code> 还会贴心地给两边加上引号<code>and password like &#39;\&#39; OR \&#39;1\&#39; = \&#39;1&#39;</code></p>
<p>因此，#{password}本身就自带引号，模糊匹配会解析成<code>&#39;%&#39;that&#39;%&#39;</code> 完全的语法错误。</p>
<h4 id="应该怎么用"><a href="#应该怎么用" class="headerlink" title="应该怎么用"></a>应该怎么用</h4><p>既然返回的是带引号的字符串，可以用拼接字符串函数，也可以用空格把这三个字符串分开</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002231938685.png" alt="image-20241002231938685"></p>
<h3 id="MyBatis-分页查询"><a href="#MyBatis-分页查询" class="headerlink" title="MyBatis 分页查询"></a>MyBatis 分页查询</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002234502508.png" alt="image-20241002234502508"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003001119464.png" alt="image-20241003001119464"></p>
<h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><p>分页查询要两个参数，这一页从哪一行开始和每页显示的条数</p>
<p>前端传递给后台 当前页码和每页显示条数，(当前页码-1)*每行显示条数就是这一页开始的一行</p>
<p>PageBean封装 总条数 和 这一页的查询结果List&lt;User&gt; </p>
<p>list用于显示，总条数返回给前端</p>
<h4 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h4><p>前端刷新表格的操作：发出自己的两个属性，收到PageBean中的rows和totalCount</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003003901994.png" alt="image-20241003003901994"></p>
<p>前端点击页码的操作，设置自身的两个属性，同时刷新表格</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003004044018.png" alt="image-20241003004044018"></p>
<h3 id="插入重复的键——事务回滚"><a href="#插入重复的键——事务回滚" class="headerlink" title="插入重复的键——事务回滚"></a>插入重复的键——事务回滚</h3><p>username是unique 且 not null 的，所以不能重复，在提交表单的时候，如果输入重复数据，就会导致事务提交失败，这是就会出现异常，<strong>如果出现异常不处理</strong>，会一直导致故障。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003005454880.png" alt="image-20241003005454880"></p>
<p>使用try catch 如果出现异常，就调用rollback，同时return false，响应</p>
<p>前端收到响应，会根据结果弹出提示，成功或者失败</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003005659475.png" alt="image-20241003005659475"></p>
<h3 id="优化后的前端结构"><a href="#优化后的前端结构" class="headerlink" title="优化后的前端结构"></a>优化后的前端结构</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003004606856.png" alt="image-20241003004606856"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003004711700.png" alt="image-20241003004711700"></p>
<p>加入了表格loading动画，刷新按钮，以及删除和插入的结果提示</p>
]]></content>
      <categories>
        <category>web development</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>http</tag>
        <tag>servlet</tag>
        <tag>tomcat</tag>
        <tag>jsp</tag>
        <tag>mvc</tag>
        <tag>json</tag>
        <tag>authentication</tag>
        <tag>jwt</tag>
        <tag>session&amp;cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring IOC 容器源码分析(转自JavaDoop)</title>
    <url>/2018/09/07/spring-ioc/</url>
    <content><![CDATA[<p>Spring 最重要的概念是 IOC 和 AOP，本篇文章其实就是要带领大家来分析下 Spring 的 IOC 容器。既然大家平时都要用到 Spring，怎么可以不好好了解 Spring 呢？阅读本文并不能让你成为 Spring 专家，不过一定有助于大家理解 Spring 的很多概念，帮助大家排查应用中和 Spring 相关的一些问题。</p>
<p>本文采用的源码版本是 4.3.11.RELEASE，算是 5.0.x 前比较新的版本了。为了降低难度，本文所说的所有的内容都是基于 xml 的配置的方式，实际使用已经很少人这么做了，至少不是纯 xml 配置，不过从理解源码的角度来看用这种方式来说无疑是最合适的。</p>
<p>阅读建议：读者至少需要知道怎么配置 Spring，了解 Spring 中的各种概念，少部分内容我还假设读者使用过 SpringMVC。本文要说的 IOC 总体来说有两处地方最重要，一个是创建 Bean 容器，一个是初始化 Bean，如果读者觉得一次性看完本文压力有点大，那么可以按这个思路分两次消化。读者不一定对 Spring 容器的源码感兴趣，也许附录部分介绍的知识对读者有些许作用。</p>
<p>希望通过本文可以让读者不惧怕阅读 Spring 源码，也希望大家能反馈表述错误或不合理的地方。</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>先看下最基本的启动 Spring 容器的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:applicationfile.xml&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码就可以利用配置文件来启动一个 Spring 容器了，请使用 maven 的小伙伴直接在 dependencies 中加上以下依赖即可，个人比较反对那些不知道要添加什么依赖，然后把 Spring 的所有相关的东西都加进来的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">4.3</span><span class="number">.11</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。</p>
</blockquote>
<p>多说一句，很多开发者入门就直接接触的 SpringMVC，对 Spring 其实不是很了解，Spring 是渐进式的工具，并不具有很强的侵入性，它的模块也划分得很合理，即使你的应用不是 web 应用，或者之前完全没有使用到 Spring，而你就想用 Spring 的依赖注入这个功能，其实完全是可以的，它的引入不会对其他的组件产生冲突。</p>
<p>废话说完，我们继续。<code>ApplicationContext context = new ClassPathXmlApplicationContext(...)</code> 其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext。当然，除了 ClassPathXmlApplicationContext 以外，我们也还有其他构建 ApplicationContext 的方案可供选择，我们先来看看大体的继承结构是怎么样的：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/spring-context/1.png" alt="1"></p>
<blockquote>
<p>读者可以大致看一下类名，源码分析的时候不至于找不着看哪个类，因为 Spring 为了适应各种使用场景，提供的各个接口都可能有很多的实现类。对于我们来说，就是揪着一个完整的分支看完。</p>
<p>当然，读本文的时候读者也不必太担心，每个代码块分析的时候，我都会告诉读者我们在说哪个类第几行。</p>
</blockquote>
<p>我们可以看到，ClassPathXmlApplicationContext 兜兜转转了好久才到 ApplicationContext 接口，同样的，我们也可以使用绿颜色的 <strong>FileSystemXmlApplicationContext</strong> 和 <strong>AnnotationConfigApplicationContext</strong> 这两个类。</p>
<p><strong>1、FileSystemXmlApplicationContext</strong> 的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。</p>
<p><strong>2、AnnotationConfigApplicationContext</strong> 是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。</p>
<p>不过本文旨在帮助大家理解整个构建流程，所以决定使用 ClassPathXmlApplicationContext 进行分析。</p>
<p>我们先来一个简单的例子来看看怎么实例化 ApplicationContext。</p>
<p>首先，定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    String <span class="title function_">getMessage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义接口实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们在 <strong>resources</strong> 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml 就可以了：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span> <span class="attr">default-autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.javadoop.example.MessageServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，我们就可以跑起来了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 用我们的配置文件来启动一个 ApplicationContext</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:application.xml&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        System.out.println(<span class="string">&quot;context 启动成功&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式</span></span><br><span class="line">        <span class="type">MessageService</span> <span class="variable">messageService</span> <span class="operator">=</span> context.getBean(MessageService.class);</span><br><span class="line">        <span class="comment">// 这句将输出: hello world</span></span><br><span class="line">        System.out.println(messageService.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动 Spring 的 ApplicationContext ？也就是我们今天要分析的 IOC 的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。</p>
<h2 id="BeanFactory-简介"><a href="#BeanFactory-简介" class="headerlink" title="BeanFactory 简介"></a>BeanFactory 简介</h2><p>BeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。</p>
<p>初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的 ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/spring-context/2.png" alt="2"></p>
<p>我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext 往下的继承结构前面一张图说过了，这里就不重复了。这张图呢，背下来肯定是不需要的，有几个重点和大家说明下就好。</p>
<ol>
<li>ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的。</li>
<li>ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。</li>
<li>AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。</li>
<li>ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到。</li>
<li>请先不用花时间在其他的接口和类上，先理解我说的这几点就可以了。</li>
</ol>
<p>然后，请读者打开编辑器，翻一下 BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory、ApplicationContext 这几个接口的代码，大概看一下各个接口中的方法，大家心里要有底，限于篇幅，我就不贴代码介绍了。</p>
<h2 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h2><p>下面将会是冗长的代码分析，记住，一定要自己打开源码来看，不然纯看是很累的。</p>
<p>第一步，我们肯定要从 ClassPathXmlApplicationContext 的构造方法说起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">AbstractXmlApplicationContext</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Resource[] configResources;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(ApplicationContext parent)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="type">boolean</span> refresh, ApplicationContext parent)</span></span><br><span class="line">      <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">    <span class="comment">// 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)</span></span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">      refresh(); <span class="comment">// 核心方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，就是 <code>refresh()</code>，这里简单说下为什么是 refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext 建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。</p>
<p>往下看，refresh() 方法里面调用了那么多方法，就知道肯定不简单了，请读者先看个大概，细节之后会详细说。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span></span><br><span class="line">      <span class="comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span></span><br><span class="line">      <span class="comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">      <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">      <span class="comment">// 这块待会会展开说</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span></span><br><span class="line">         <span class="comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span></span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></span><br><span class="line">         <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">         <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 重点，重点，重点</span></span><br><span class="line">         <span class="comment">// 初始化所有的 singleton beans</span></span><br><span class="line">         <span class="comment">//（lazy-init 的除外）</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 把异常往外抛</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面，我们开始一步步来肢解这个 refresh() 方法。</p>
<h3 id="创建-Bean-容器前的准备工作"><a href="#创建-Bean-容器前的准备工作" class="headerlink" title="创建 Bean 容器前的准备工作"></a>创建 Bean 容器前的准备工作</h3><p>这个比较简单，直接看代码中的几个注释即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 记录启动时间，</span></span><br><span class="line">   <span class="comment">// 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型</span></span><br><span class="line">   <span class="built_in">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">   <span class="built_in">this</span>.closed.set(<span class="literal">false</span>);</span><br><span class="line">   <span class="built_in">this</span>.active.set(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">&quot;Refreshing &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize any placeholder property sources in the context environment</span></span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 校验 xml 配置文件</span></span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.earlyApplicationEvents = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;ApplicationEvent&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建-Bean-容器，加载并注册-Bean"><a href="#创建-Bean-容器，加载并注册-Bean" class="headerlink" title="创建 Bean 容器，加载并注册 Bean"></a>创建 Bean 容器，加载并注册 Bean</h3><p>我们回到 refresh() 方法中的下一行 obtainFreshBeanFactory()。</p>
<p>注意，<strong>这个方法是全文最重要的部分之一</strong>，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。</p>
<p>当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean 实例并未在这一步生成。</p>
<p>// AbstractApplicationContext.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等</span></span><br><span class="line">   refreshBeanFactory();</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 返回刚刚创建的 BeanFactory</span></span><br><span class="line">   <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>// AbstractRefreshableApplicationContext.java 120</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="comment">// 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory</span></span><br><span class="line">   <span class="comment">// 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前</span></span><br><span class="line">   <span class="comment">// ApplicationContext 是否有 BeanFactory</span></span><br><span class="line">   <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。</span></span><br><span class="line">      <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> createBeanFactory();</span><br><span class="line">      <span class="comment">// 用于 BeanFactory 的序列化，我想不部分人应该都用不到</span></span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 下面这两个方法很重要，别跟丢了，具体细节之后说</span></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span></span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 加载 Bean 到 BeanFactory 中</span></span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">         <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>看到这里的时候，我觉得读者就应该站在高处看 ApplicationContext 了，ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。</p>
</blockquote>
<p>我们说说为什么选择实例化 <strong>DefaultListableBeanFactory</strong> ？前面我们说了有个很重要的接口 ConfigurableListableBeanFactory，它实现了 BeanFactory 下面一层的所有三个接口，我把之前的继承图再拿过来大家再仔细看一下：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/spring-context/3.png" alt="3"></p>
<p>我们可以看到 ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory 还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这边会使用这个类来实例化的原因。</p>
<blockquote>
<p>如果你想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到这个类。那我们怎么在运行时获得这个实例呢？</p>
<p>之前我们说过 ApplicationContext 接口能获取到 AutowireCapableBeanFactory，就是最右上角那个，然后它向下转型就能得到 DefaultListableBeanFactory 了。</p>
<p>那怎么拿到 ApplicationContext 实例呢？如果你不会，说明你没用过 Spring。</p>
</blockquote>
<p>在继续往下之前，我们需要先了解 BeanDefinition。<strong>我们说 BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？</strong></p>
<p>这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。</p>
<p>所以，如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。</p>
<blockquote>
<p>BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。</p>
</blockquote>
<h4 id="BeanDefinition-接口定义"><a href="#BeanDefinition-接口定义" class="headerlink" title="BeanDefinition 接口定义"></a>BeanDefinition 接口定义</h4><p>我们来看下 BeanDefinition 的接口定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinition</span> <span class="keyword">extends</span> <span class="title class_">AttributeAccessor</span>, BeanMetadataElement &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 我们可以看到，默认只提供 sington 和 prototype 两种，</span></span><br><span class="line">   <span class="comment">// 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，</span></span><br><span class="line">   <span class="comment">// 不过，它们属于基于 web 的扩展。</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">SCOPE_SINGLETON</span> <span class="operator">=</span> ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">   <span class="type">String</span> <span class="variable">SCOPE_PROTOTYPE</span> <span class="operator">=</span> ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 比较不重要，直接跳过吧</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_APPLICATION</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_SUPPORT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">ROLE_INFRASTRUCTURE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍</span></span><br><span class="line">   <span class="comment">// 一句话就是：继承父 Bean 的配置信息而已</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setParentName</span><span class="params">(String parentName)</span>;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 获取父 Bean</span></span><br><span class="line">   String <span class="title function_">getParentName</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 设置 Bean 的类名称，将来是要通过反射来生成实例的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setBeanClassName</span><span class="params">(String beanClassName)</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 获取 Bean 的类名称</span></span><br><span class="line">   String <span class="title function_">getBeanClassName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 设置 bean 的 scope</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setScope</span><span class="params">(String scope)</span>;</span><br><span class="line"></span><br><span class="line">   String <span class="title function_">getScope</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置是否懒加载</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setLazyInit</span><span class="params">(<span class="type">boolean</span> lazyInit)</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isLazyInit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</span></span><br><span class="line">   <span class="comment">// 是 depends-on=&quot;&quot; 属性设置的值。</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setDependsOn</span><span class="params">(String... dependsOn)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回该 Bean 的所有依赖</span></span><br><span class="line">   String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</span></span><br><span class="line">   <span class="comment">// 如果根据名称注入，即使这边设置了 false，也是可以的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setAutowireCandidate</span><span class="params">(<span class="type">boolean</span> autowireCandidate)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 该 Bean 是否可以注入到其他 Bean 中</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isAutowireCandidate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setPrimary</span><span class="params">(<span class="type">boolean</span> primary)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否是 primary 的</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isPrimary</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录</span></span><br><span class="line">   <span class="comment">// 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setFactoryBeanName</span><span class="params">(String factoryBeanName)</span>;</span><br><span class="line">   <span class="comment">// 获取工厂名称</span></span><br><span class="line">   String <span class="title function_">getFactoryBeanName</span><span class="params">()</span>;</span><br><span class="line">   <span class="comment">// 指定工厂类中的 工厂方法名称</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setFactoryMethodName</span><span class="params">(String factoryMethodName)</span>;</span><br><span class="line">   <span class="comment">// 获取工厂类中的 工厂方法名称</span></span><br><span class="line">   String <span class="title function_">getFactoryMethodName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造器参数</span></span><br><span class="line">   ConstructorArgumentValues <span class="title function_">getConstructorArgumentValues</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span></span><br><span class="line">   MutablePropertyValues <span class="title function_">getPropertyValues</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 singleton</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 prototype</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isPrototype</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span></span><br><span class="line">   <span class="comment">// 常用于作为 父bean 用于继承，其实也很少用......</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isAbstract</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">getRole</span><span class="params">()</span>;</span><br><span class="line">   String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">   String <span class="title function_">getResourceDescription</span><span class="params">()</span>;</span><br><span class="line">   BeanDefinition <span class="title function_">getOriginatingBeanDefinition</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个 BeanDefinition 其实已经包含很多的信息了，暂时不清楚所有的方法对应什么东西没关系，希望看完本文后读者可以彻底搞清楚里面的所有东西。</p>
<p>这里接口虽然那么多，但是没有类似 getInstance() 这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例到哪里去了呢？别着急，这个要很后面才能讲到。</p>
</blockquote>
<p>有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory() 方法中的剩余部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br></pre></td></tr></table></figure>

<p>虽然只有两个方法，但路还很长啊。。。</p>
<h4 id="customizeBeanFactory"><a href="#customizeBeanFactory" class="headerlink" title="customizeBeanFactory"></a>customizeBeanFactory</h4><p>customizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.allowBeanDefinitionOverriding != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 是否允许 Bean 定义覆盖</span></span><br><span class="line">      beanFactory.setAllowBeanDefinitionOverriding(<span class="built_in">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.allowCircularReferences != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 是否允许 Bean 间的循环依赖</span></span><br><span class="line">      beanFactory.setAllowCircularReferences(<span class="built_in">this</span>.allowCircularReferences);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanDefinition 的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p>
<p>循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。</p>
<p>默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。</p>
<p>至于这两个属性怎么配置？我在附录中进行了介绍，尤其对于覆盖问题，很多人都希望禁止出现 Bean 覆盖，可是 Spring 默认是不同文件的时候可以覆盖的。</p>
<p>之后的源码中还会出现这两个属性，读者有个印象就可以了，它们不是非常重要。</p>
<h4 id="加载-Bean-loadBeanDefinitions"><a href="#加载-Bean-loadBeanDefinitions" class="headerlink" title="加载 Bean: loadBeanDefinitions"></a>加载 Bean: loadBeanDefinitions</h4><p>接下来是最重要的 loadBeanDefinitions(beanFactory) 方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。</p>
<p>读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。</p>
<p>// AbstractXmlApplicationContext.java 80</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">   <span class="comment">// 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader</span></span><br><span class="line">   <span class="type">XmlBeanDefinitionReader</span> <span class="variable">beanDefinitionReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Configure the bean definition reader with this context&#x27;s</span></span><br><span class="line">   <span class="comment">// resource loading environment.</span></span><br><span class="line">   beanDefinitionReader.setEnvironment(<span class="built_in">this</span>.getEnvironment());</span><br><span class="line">   beanDefinitionReader.setResourceLoader(<span class="built_in">this</span>);</span><br><span class="line">   beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> <span class="title class_">ResourceEntityResolver</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，</span></span><br><span class="line">   <span class="comment">// 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧</span></span><br><span class="line">   initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">   <span class="comment">// 重点来了，继续往下</span></span><br><span class="line">   loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在还在这个类中，接下来用刚刚初始化的 Reader 开始来加载 xml 配置，这块代码读者可以选择性跳过，不是很重要。也就是说，下面这个代码块，读者可以很轻松地略过。</p>
<p>// AbstractXmlApplicationContext.java 120</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">   Resource[] configResources = getConfigResources();</span><br><span class="line">   <span class="keyword">if</span> (configResources != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 往下看</span></span><br><span class="line">      reader.loadBeanDefinitions(configResources);</span><br><span class="line">   &#125;</span><br><span class="line">   String[] configLocations = getConfigLocations();</span><br><span class="line">   <span class="keyword">if</span> (configLocations != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 2</span></span><br><span class="line">      reader.loadBeanDefinitions(configLocations);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   Assert.notNull(resources, <span class="string">&quot;Resource array must not be null&quot;</span>);</span><br><span class="line">   <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 注意这里是个 for 循环，也就是每个文件是一个 resource</span></span><br><span class="line">   <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">      <span class="comment">// 继续往下看</span></span><br><span class="line">      counter += loadBeanDefinitions(resource);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 最后返回 counter，表示总共加载了多少的 BeanDefinition</span></span><br><span class="line">   <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader 303</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> <span class="title class_">EncodedResource</span>(resource));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader 314</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource.getResource());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 用一个 ThreadLocal 来存放配置文件资源</span></span><br><span class="line">   Set&lt;EncodedResource&gt; currentResources = <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">   <span class="keyword">if</span> (currentResources == <span class="literal">null</span>) &#123;</span><br><span class="line">      currentResources = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;EncodedResource&gt;(<span class="number">4</span>);</span><br><span class="line">      <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">            <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line">         <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 核心部分是这里，往下面看</span></span><br><span class="line">         <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         inputStream.close();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">            <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      currentResources.remove(encodedResource);</span><br><span class="line">      <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">         <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还在这个文件中，第 388 行</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这里就不看了，将 xml 文件转换为 Document 对象</span></span><br><span class="line">      <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line">      <span class="comment">// 继续</span></span><br><span class="line">      <span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 还在这个文件中，第 505 行</span></span><br><span class="line"><span class="comment">// 返回值：返回从当前配置文件加载了多少数量的 Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   <span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line">   <span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line">   <span class="comment">// 这里</span></span><br><span class="line">   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">   <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader 90</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.readerContext = readerContext;</span><br><span class="line">   logger.debug(<span class="string">&quot;Loading bean definitions&quot;</span>);</span><br><span class="line">   <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> doc.getDocumentElement();</span><br><span class="line">   <span class="comment">// 从 xml 根节点开始解析文件</span></span><br><span class="line">   doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;         </span><br></pre></td></tr></table></figure>

<p>经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。下面开始从根节点开始解析：</p>
<h5 id="doRegisterBeanDefinitions："><a href="#doRegisterBeanDefinitions：" class="headerlink" title="doRegisterBeanDefinitions："></a>doRegisterBeanDefinitions：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader 116</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> &#123;</span><br><span class="line">   <span class="comment">// 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义，</span></span><br><span class="line">   <span class="comment">// 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题，</span></span><br><span class="line">   <span class="comment">// 因为 &lt;beans /&gt; 内部是可以定义 &lt;beans /&gt; 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 &lt;beans /&gt; 节点，从源码分析的角度，我们当做根节点就好了</span></span><br><span class="line">   <span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">   <span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      <span class="comment">// 这块说的是根节点 &lt;beans ... profile=&quot;dev&quot; /&gt; 中的 profile 是否是当前环境需要的，</span></span><br><span class="line">      <span class="comment">// 如果当前环境配置的 profile 不包含此 profile，那就直接 return 了，不对此 &lt;beans /&gt; 解析</span></span><br><span class="line">      <span class="comment">// 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">profileSpec</span> <span class="operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">         <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">               logger.info(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                     <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   preProcessXml(root); <span class="comment">// 钩子</span></span><br><span class="line">   <span class="comment">// 往下看</span></span><br><span class="line">   parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line">   postProcessXml(root); <span class="comment">// 钩子</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>preProcessXml(root) 和 postProcessXml(root) 是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，我们直接跳过。</p>
<p>这里涉及到了 profile 的问题，对于不了解的读者，我在附录中对 profile 做了简单的解释，读者可以参考一下。</p>
<p>接下来，看核心解析方法 parseBeanDefinitions(root, this.delegate) :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，</span></span><br><span class="line"><span class="comment">// 其他的属于 custom 的</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">         <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">         <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            <span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">            <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">               <span class="comment">// 解析 default namespace 下面的几个元素</span></span><br><span class="line">               parseDefaultElement(ele, delegate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 解析其他 namespace 的元素</span></span><br><span class="line">               delegate.parseCustomElement(ele);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      delegate.parseCustomElement(root);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码，我们可以看到，对于每个配置来说，分别进入到 parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele); 这两个分支了。</p>
<p>parseDefaultElement(ele, delegate) 代表解析的节点是 <code>&lt;import /&gt;</code>、<code>&lt;alias /&gt;</code>、<code>&lt;bean /&gt;</code>、<code>&lt;beans /&gt;</code> 这几个。</p>
<blockquote>
<p>这里的四个标签之所以是 <strong>default</strong> 的，是因为它们是处于这个 namespace 下定义的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.springframework.org/schema/beans</span><br></pre></td></tr></table></figure>

<p>又到初学者科普时间，不熟悉 namespace 的读者请看下面贴出来的 xml，这里的第二行 <strong>xmlns</strong> 就是咯。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">          http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而对于其他的标签，将进入到 delegate.parseCustomElement(element) 这个分支。如我们经常会使用到的 <code>&lt;mvc /&gt;</code>、<code>&lt;task /&gt;</code>、<code>&lt;context /&gt;</code>、<code>&lt;aop /&gt;</code>等。</p>
<p>这些属于扩展，如果需要使用上面这些 ”非 default“ 标签，那么上面的 xml 头部的地方也要引入相应的 namespace 和 .xsd 文件的路径，如下所示。同时代码中需要提供相应的 parser 来解析，如 MvcNamespaceHandler、TaskNamespaceHandler、ContextNamespaceHandler、AopNamespaceHandler 等。</p>
<p>假如读者想分析 <code>&lt;context:property-placeholder location=&quot;classpath:xx.properties&quot; /&gt;</code> 的实现原理，就应该到 ContextNamespaceHandler 中找答案。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/mvc   </span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/mvc/spring-mvc.xsd  </span></span></span><br><span class="line"><span class="string"><span class="tag">       &quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">default-autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同理，以后你要是碰到 <code>&lt;dubbo /&gt;</code> 这种标签，那么就应该搜一搜是不是有 DubboNamespaceHandler 这个处理类。</p>
</blockquote>
<p>回过神来，看看处理 default 标签的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;import /&gt; 标签</span></span><br><span class="line">      importBeanDefinitionResource(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;alias /&gt; 标签定义</span></span><br><span class="line">      <span class="comment">// &lt;alias name=&quot;fromName&quot; alias=&quot;toName&quot;/&gt;</span></span><br><span class="line">      processAliasRegistration(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;bean /&gt; 标签定义，这也算是我们的重点吧</span></span><br><span class="line">      processBeanDefinition(ele, delegate);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 如果碰到的是嵌套的 &lt;beans /&gt; 标签，需要递归</span></span><br><span class="line">      doRegisterBeanDefinitions(ele);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果每个标签都说，那我不吐血，你们都要吐血了。我们挑我们的重点 <code>&lt;bean /&gt;</code> 标签出来说。</p>
<h5 id="processBeanDefinition-解析-bean-标签"><a href="#processBeanDefinition-解析-bean-标签" class="headerlink" title="processBeanDefinition 解析 bean 标签"></a>processBeanDefinition 解析 bean 标签</h5><p>下面是 processBeanDefinition 解析 <code>&lt;bean /&gt;</code> 标签：</p>
<p>// DefaultBeanDefinitionDocumentReader 298</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">   <span class="comment">// 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看</span></span><br><span class="line">   <span class="type">BeanDefinitionHolder</span> <span class="variable">bdHolder</span> <span class="operator">=</span> delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">               bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Send registration event.</span></span><br><span class="line">      getReaderContext().fireComponentRegistered(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(bdHolder));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续往下看怎么解析之前，我们先看下 <strong><code>&lt;bean /&gt;</code></strong> 标签中可以定义哪些属性：</p>
<table>
<thead>
<tr>
<th>Property</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>类的全限定名</td>
</tr>
<tr>
<td>name</td>
<td>可指定 id、name(用逗号、分号、空格分隔)</td>
</tr>
<tr>
<td>scope</td>
<td>作用域</td>
</tr>
<tr>
<td>constructor arguments</td>
<td>指定构造参数</td>
</tr>
<tr>
<td>properties</td>
<td>设置属性的值</td>
</tr>
<tr>
<td>autowiring mode</td>
<td>no(默认值)、byName、byType、 constructor</td>
</tr>
<tr>
<td>lazy-initialization mode</td>
<td>是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了)</td>
</tr>
<tr>
<td>initialization method</td>
<td>bean 属性设置完成后，会调用这个方法</td>
</tr>
<tr>
<td>destruction method</td>
<td>bean 销毁后的回调方法</td>
</tr>
</tbody></table>
<p>上面表格中的内容我想大家都非常熟悉吧，如果不熟悉，那就是你不够了解 Spring 的配置了。</p>
<p>简单地说就是像下面这样子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name1, name2, name3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.javadoop.ExampleBean&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;cleanup&quot;</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 可以用下面三种形式指定构造参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;years&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- property 的几种情况 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;beanOne&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;anotherExampleBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;beanTwo&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;yetAnotherBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;integerProperty&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，除了上面举例出来的这些，还有 factory-bean、factory-method、<code>&lt;lockup-method /&gt;</code>、<code>&lt;replaced-method /&gt;</code>、<code>&lt;meta /&gt;</code>、<code>&lt;qualifier /&gt;</code> 这几个，大家是不是熟悉呢？自己检验一下自己对 Spring 中 bean 的了解程度。</p>
<p>有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。</p>
<p>// BeanDefinitionParserDelegate 428</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinitionHolder <span class="title function_">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BeanDefinitionHolder <span class="title function_">parseBeanDefinitionElement</span><span class="params">(Element ele, BeanDefinition containingBean)</span> &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">   <span class="type">String</span> <span class="variable">nameAttr</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">   List&lt;String&gt; aliases = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">      </span><br><span class="line">   <span class="comment">// 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组，</span></span><br><span class="line">   <span class="comment">// 当然，如果你不定义 name 属性的话，就是空的了</span></span><br><span class="line">   <span class="comment">// 我在附录中简单介绍了一下 id 和 name 的配置，大家可以看一眼，有个20秒就可以了</span></span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> id;</span><br><span class="line">   <span class="comment">// 如果没有指定id, 那么用别名列表的第一个名字作为beanName</span></span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">      beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">               <span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (containingBean == <span class="literal">null</span>) &#123;</span><br><span class="line">      checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,</span></span><br><span class="line">   <span class="comment">// 细节后面细说，先知道下面这行结束后，一个 BeanDefinition 实例就出来了。</span></span><br><span class="line">   <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 到这里，整个 &lt;bean /&gt; 标签就算解析结束了，一个 BeanDefinition 就形成了。</span></span><br><span class="line">   <span class="keyword">if</span> (beanDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生</span></span><br><span class="line">      <span class="comment">// 如果读者不感兴趣的话，我觉得不需要关心这块代码，对本文源码分析来说，这些东西不重要</span></span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (containingBean != <span class="literal">null</span>) &#123;<span class="comment">// 按照我们的思路，这里 containingBean 是 null 的</span></span><br><span class="line">               beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                     beanDefinition, <span class="built_in">this</span>.readerContext.getRegistry(), <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 如果我们不定义 id 和 name，那么我们引言里的那个例子：</span></span><br><span class="line">               <span class="comment">//   1. beanName 为：com.javadoop.example.MessageServiceImpl#0</span></span><br><span class="line">               <span class="comment">//   2. beanClassName 为：com.javadoop.example.MessageServiceImpl</span></span><br><span class="line">              </span><br><span class="line">               beanName = <span class="built_in">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">               </span><br><span class="line">               <span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> beanDefinition.getBeanClassName();</span><br><span class="line">               <span class="keyword">if</span> (beanClassName != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                     beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                     !<span class="built_in">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                  <span class="comment">// 把 beanClassName 设置为 Bean 的别名</span></span><br><span class="line">                  aliases.add(beanClassName);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               logger.debug(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            error(ex.getMessage(), ele);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">      <span class="comment">// 返回 BeanDefinitionHolder</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDefinition, beanName, aliasesArray);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们再看看怎么根据配置创建 BeanDefinition 实例的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractBeanDefinition <span class="title function_">parseBeanDefinitionElement</span><span class="params">(</span></span><br><span class="line"><span class="params">      Element ele, String beanName, BeanDefinition containingBean)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="title class_">BeanEntry</span>(beanName));</span><br><span class="line"></span><br><span class="line">   <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">         parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了</span></span><br><span class="line">      <span class="type">AbstractBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中</span></span><br><span class="line">      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line">    </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素，</span></span><br><span class="line"><span class="comment">       * 解析出来以后的信息都放到 bd 的属性中</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 解析 &lt;meta /&gt;</span></span><br><span class="line">      parseMetaElements(ele, bd);</span><br><span class="line">      <span class="comment">// 解析 &lt;lookup-method /&gt;</span></span><br><span class="line">      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">      <span class="comment">// 解析 &lt;replaced-method /&gt;</span></span><br><span class="line">      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">    <span class="comment">// 解析 &lt;constructor-arg /&gt;</span></span><br><span class="line">      parseConstructorArgElements(ele, bd);</span><br><span class="line">      <span class="comment">// 解析 &lt;property /&gt;</span></span><br><span class="line">      parsePropertyElements(ele, bd);</span><br><span class="line">      <span class="comment">// 解析 &lt;qualifier /&gt;</span></span><br><span class="line">      parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">      bd.setResource(<span class="built_in">this</span>.readerContext.getResource());</span><br><span class="line">      bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> bd;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">      error(<span class="string">&quot;Bean class [&quot;</span> + className + <span class="string">&quot;] not found&quot;</span>, ele, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">      error(<span class="string">&quot;Class that bean class [&quot;</span> + className + <span class="string">&quot;] depends on not found&quot;</span>, ele, err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      error(<span class="string">&quot;Unexpected failure during bean definition parsing&quot;</span>, ele, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.parseState.pop();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，我们已经完成了根据 <code>&lt;bean /&gt;</code> 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。</p>
<p>我们回到解析 <code>&lt;bean /&gt;</code> 的入口方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">   <span class="comment">// 将 &lt;bean /&gt; 节点转换为 BeanDefinitionHolder，就是上面说的一堆</span></span><br><span class="line">   <span class="type">BeanDefinitionHolder</span> <span class="variable">bdHolder</span> <span class="operator">=</span> delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">   <span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果有自定义属性的话，进行相应的解析，先忽略</span></span><br><span class="line">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 我们把这步叫做 注册Bean 吧</span></span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">               bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 注册完成后，发送事件，本文不展开说这个</span></span><br><span class="line">      getReaderContext().fireComponentRegistered(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(bdHolder));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家再仔细看一下这块吧，我们后面就不回来说这个了。这里已经根据一个 <code>&lt;bean /&gt;</code> 标签产生了一个 BeanDefinitionHolder 的实例，这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息，注意，我们的关注点始终在 BeanDefinition 上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinitionHolder</span> <span class="keyword">implements</span> <span class="title class_">BeanMetadataElement</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BeanDefinition beanDefinition;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String[] aliases;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>然后我们准备注册这个 BeanDefinition，最后，把这个注册事件发送出去。</p>
<p>下面，我们开始说说注册 Bean 吧。</p>
<h5 id="注册-Bean"><a href="#注册-Bean" class="headerlink" title="注册 Bean"></a>注册 Bean</h5><p>// BeanDefinitionReaderUtils 143</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> definitionHolder.getBeanName();</span><br><span class="line">   <span class="comment">// 注册这个 Bean</span></span><br><span class="line">   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了</span></span><br><span class="line">   String[] aliases = definitionHolder.getAliases();</span><br><span class="line">   <span class="keyword">if</span> (aliases != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">         <span class="comment">// alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，</span></span><br><span class="line">         <span class="comment">// 获取的时候，会先将 alias 转换为 beanName，然后再查找</span></span><br><span class="line">         registry.registerAlias(beanName, alias);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。</p>
<p>// DefaultListableBeanFactory 793</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">   Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">   Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(...);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding</span></span><br><span class="line">   BeanDefinition oldBeanDefinition;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中</span></span><br><span class="line">   oldBeanDefinition = <span class="built_in">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 处理重复名称的 Bean 定义的情况</span></span><br><span class="line">   <span class="keyword">if</span> (oldBeanDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">         <span class="comment">// 如果不允许覆盖的话，抛异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(beanDefinition.getResourceDescription()...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">         <span class="comment">// log...用框架定义的 Bean 覆盖用户自定义的 Bean </span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">         <span class="comment">// log...用新的 Bean 覆盖旧的 Bean</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 覆盖</span></span><br><span class="line">      <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 判断是否已经有其他的 Bean 开始初始化了.</span></span><br><span class="line">      <span class="comment">// 注意，&quot;注册Bean&quot; 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，</span></span><br><span class="line">      <span class="comment">// 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans</span></span><br><span class="line">      <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">         <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">            <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(<span class="built_in">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">            updatedDefinitions.addAll(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line">            updatedDefinitions.add(beanName);</span><br><span class="line">            <span class="built_in">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">               Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;String&gt;(<span class="built_in">this</span>.manualSingletonNames);</span><br><span class="line">               updatedSingletons.remove(beanName);</span><br><span class="line">               <span class="built_in">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 最正常的应该是进到这个分支。</span></span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition</span></span><br><span class="line">         <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">         <span class="comment">// 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字</span></span><br><span class="line">         <span class="built_in">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">         <span class="comment">// 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，</span></span><br><span class="line">         <span class="comment">// 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的</span></span><br><span class="line">         <span class="comment">// 手动指的是通过调用以下方法注册的 bean ：</span></span><br><span class="line">         <span class="comment">//     registerSingleton(String beanName, Object singletonObject)</span></span><br><span class="line">         <span class="comment">// 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面&quot;手动&quot;注册一些 Bean，</span></span><br><span class="line">         <span class="comment">// 如 &quot;environment&quot;、&quot;systemProperties&quot; 等 bean，我们自己也可以在运行时注册 Bean 到容器中的</span></span><br><span class="line">         <span class="built_in">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这个不重要，在预初始化的时候会用到，不必管它。</span></span><br><span class="line">      <span class="built_in">this</span>.frozenBeanDefinitionNames = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (oldBeanDefinition != <span class="literal">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">      resetBeanDefinition(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下，到这里已经初始化了 Bean 容器，<code>&lt;bean /&gt;</code> 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。</p>
<p>——— 分割线 ———</p>
<p>到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。</p>
<h3 id="Bean-容器实例化完成后"><a href="#Bean-容器实例化完成后" class="headerlink" title="Bean 容器实例化完成后"></a>Bean 容器实例化完成后</h3><p>说到这里，我们回到 refresh() 方法，我重新贴了一遍代码，看看我们说到哪了。是的，我们才说完 obtainFreshBeanFactory() 方法。</p>
<p>考虑到篇幅，这里开始大幅缩减掉没必要详细介绍的部分，大家直接看下面的代码中的注释就好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span></span><br><span class="line">      <span class="comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span></span><br><span class="line">      <span class="comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">      <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">      <span class="comment">// 这块待会会展开说</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span></span><br><span class="line">         <span class="comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span></span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);          </span><br><span class="line">         </span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></span><br><span class="line">         <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">         <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 重点，重点，重点</span></span><br><span class="line">         <span class="comment">// 初始化所有的 singleton beans</span></span><br><span class="line">         <span class="comment">//（lazy-init 的除外）</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成，不展开</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 把异常往外抛</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="准备-Bean-容器-prepareBeanFactory"><a href="#准备-Bean-容器-prepareBeanFactory" class="headerlink" title="准备 Bean 容器: prepareBeanFactory"></a>准备 Bean 容器: prepareBeanFactory</h3><p>之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean。</p>
<p>这里简单介绍下 prepareBeanFactory(factory) 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configure the factory&#x27;s standard context characteristics,</span></span><br><span class="line"><span class="comment"> * such as the context&#x27;s ClassLoader and post-processors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the BeanFactory to configure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   <span class="comment">// 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，</span></span><br><span class="line">   <span class="comment">// 这里设置为加载当前 ApplicationContext 类的类加载器</span></span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 设置 BeanExpressionResolver</span></span><br><span class="line">   beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> <span class="title class_">StandardBeanExpressionResolver</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> <span class="title class_">ResourceEditorRegistrar</span>(<span class="built_in">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 添加一个 BeanPostProcessor，这个 processor 比较简单：</span></span><br><span class="line">   <span class="comment">// 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，</span></span><br><span class="line">   <span class="comment">// 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware</span></span><br><span class="line">   <span class="comment">// 注意：它不仅仅回调 ApplicationContextAware，</span></span><br><span class="line">   <span class="comment">//   还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationContextAwareProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，</span></span><br><span class="line">   <span class="comment">// Spring 会通过其他方式来处理这些依赖。</span></span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，</span></span><br><span class="line"><span class="comment">    * 之前我们说过，&quot;当前 ApplicationContext 持有一个 BeanFactory&quot;，这里解释了第一行。</span></span><br><span class="line"><span class="comment">    * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource</span></span><br><span class="line"><span class="comment">    * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext</span></span><br><span class="line"><span class="comment">    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="built_in">this</span>);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="built_in">this</span>);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，</span></span><br><span class="line">   <span class="comment">// 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它</span></span><br><span class="line">   <span class="comment">// tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样，</span></span><br><span class="line">   <span class="comment">//    感兴趣的读者请参考我写的关于 AspectJ 的另一篇文章 https://www.javadoop.com/post/aspectj</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">      <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从下面几行代码我们可以知道，Spring 往往很 &quot;智能&quot; 就是因为它会帮我们默认注册一些有用的 bean，</span></span><br><span class="line"><span class="comment">    * 我们也可以选择覆盖</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 如果没有定义 &quot;environment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果没有定义 &quot;systemProperties&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果没有定义 &quot;systemEnvironment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这块代码中，Spring 对一些特殊的 bean 进行了处理，读者如果暂时还不能消化它们也没有关系，慢慢往下看。</p>
<h3 id="初始化所有的-singleton-beans"><a href="#初始化所有的-singleton-beans" class="headerlink" title="初始化所有的 singleton beans"></a>初始化所有的 singleton beans</h3><p>我们的重点当然是 <code>finishBeanFactoryInitialization(beanFactory);</code> 这个巨头了，这里会负责初始化所有的 singleton beans。</p>
<p>注意，后面的描述中，我都会使用<strong>初始化</strong>或<strong>预初始化</strong>来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。</p>
<p>我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 <code>environment</code>、<code>systemProperties</code> 等。</p>
<p>剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。</p>
<p>// AbstractApplicationContext.java 834</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化剩余的 singleton beans</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了</span></span><br><span class="line">   <span class="comment">// 什么，看代码这里没有初始化 Bean 啊！</span></span><br><span class="line">   <span class="comment">// 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">      beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">   <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">   <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">      beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> <span class="title class_">StringValueResolver</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> String <span class="title function_">resolveStringValue</span><span class="params">(String strVal)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 先初始化 LoadTimeWeaverAware 类型的 Bean</span></span><br><span class="line">   <span class="comment">// 之前也说过，这是 AspectJ 相关的内容，放心跳过吧</span></span><br><span class="line">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">   <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">      getBean(weaverAwareName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">   beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，</span></span><br><span class="line">   <span class="comment">// 肯定不希望这个时候还出现 bean 定义解析、加载、注册。</span></span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 开始初始化</span></span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类了，这个类大家应该都不陌生了吧。</p>
<h4 id="preInstantiateSingletons"><a href="#preInstantiateSingletons" class="headerlink" title="preInstantiateSingletons"></a>preInstantiateSingletons</h4><p>// DefaultListableBeanFactory 728</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// this.beanDefinitionNames 保存了所有的 beanNames</span></span><br><span class="line">   List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 合并父 Bean 中的配置，注意 &lt;bean id=&quot;&quot; class=&quot;&quot; parent=&quot;&quot; /&gt; 中的 parent，用的不多吧，</span></span><br><span class="line">      <span class="comment">// 考虑到这可能会影响大家的理解，我在附录中解释了一下 &quot;Bean 继承&quot;，不了解的请到附录中看一下</span></span><br><span class="line">      <span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 非抽象、非懒加载的 singletons。如果配置了 &#x27;abstract = true&#x27;，那是不需要初始化的</span></span><br><span class="line">      <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">         <span class="comment">// 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解)</span></span><br><span class="line">         <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">            <span class="comment">// FactoryBean 的话，在 beanName 前面加上 ‘&amp;’ 符号。再调用 getBean，getBean 方法别急</span></span><br><span class="line">            <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">            <span class="comment">// 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过</span></span><br><span class="line">            <span class="type">boolean</span> isEagerInit;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">               isEagerInit = AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Boolean&gt;() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="keyword">public</span> Boolean <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                     <span class="keyword">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                     ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">               </span><br><span class="line">               getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了</span></span><br><span class="line">            getBean(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化</span></span><br><span class="line">   <span class="comment">// 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">singletonInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="type">SmartInitializingSingleton</span> <span class="variable">smartSingleton</span> <span class="operator">=</span> (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">         <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Object&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                  smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们就进入到 getBean(beanName) 方法了，这个方法我们经常用来从 BeanFactory 中获取一个 Bean，而初始化的过程也封装到了这个方法里。</p>
<h4 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h4><p>在继续前进之前，读者应该具备 FactoryBean 的知识，如果读者还不熟悉，请移步附录部分了解 FactoryBean。</p>
<p>// AbstractBeanFactory 196</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="keyword">return</span> doGetBean(name, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，</span></span><br><span class="line"><span class="comment">// 已经初始化过了就从容器中直接返回，否则就先初始化再返回</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(</span></span><br><span class="line"><span class="params">      <span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span></span><br><span class="line">      <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="comment">// 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)，</span></span><br><span class="line">   <span class="comment">// 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 注意跟着这个，这个是返回值</span></span><br><span class="line">   Object bean; </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查下是不是已经创建过了</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)，</span></span><br><span class="line">   <span class="comment">// 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean</span></span><br><span class="line">   <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance，</span></span><br><span class="line">      <span class="comment">// 如果是 FactoryBean 的话，返回它创建的那个实例对象</span></span><br><span class="line">      <span class="comment">// (FactoryBean 知识，读者若不清楚请移步附录)</span></span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">         <span class="comment">// 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常，</span></span><br><span class="line">         <span class="comment">// 往往是因为陷入了循环引用</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查一下这个 BeanDefinition 在容器中是否存在</span></span><br><span class="line">      <span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory != <span class="literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">         <span class="comment">// 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">nameToLookup</span> <span class="operator">=</span> originalBeanName(name);</span><br><span class="line">         <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回父容器的查询结果</span></span><br><span class="line">            <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">            <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">         <span class="comment">// typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。</span></span><br><span class="line">         markBeanAsCreated(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 稍稍总结一下：</span></span><br><span class="line"><span class="comment">       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；</span></span><br><span class="line"><span class="comment">       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">         checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 先初始化依赖的所有 Bean，这个很好理解。</span></span><br><span class="line">         <span class="comment">// 注意，这里的依赖指的是 depends-on 中定义的依赖</span></span><br><span class="line">         String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">         <span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">               <span class="comment">// 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了</span></span><br><span class="line">               <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 注册一下依赖关系</span></span><br><span class="line">               registerDependentBean(dep, beanName);</span><br><span class="line">               <span class="comment">// 先初始化被依赖项</span></span><br><span class="line">               getBean(dep);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果是 singleton scope 的，创建 singleton 的实例</span></span><br><span class="line">         <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            sharedInstance = getSingleton(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="comment">// 执行创建 Bean，详情后面再说</span></span><br><span class="line">                     <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                     destroySingleton(beanName);</span><br><span class="line">                     <span class="keyword">throw</span> ex;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果是 prototype scope 的，创建 prototype 的实例</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">            <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               beforePrototypeCreation(beanName);</span><br><span class="line">               <span class="comment">// 执行创建 Bean</span></span><br><span class="line">               prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">               afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line">            <span class="keyword">if</span> (scope == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">                     beforePrototypeCreation(beanName);</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 执行创建 Bean</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterPrototypeCreation(beanName);</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName,</span><br><span class="line">                     <span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">                     ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了</span></span><br><span class="line">   <span class="keyword">if</span> (requiredType != <span class="literal">null</span> &amp;&amp; bean != <span class="literal">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">                  ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家应该也猜到了，接下来当然是分析 createBean 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException;</span><br></pre></td></tr></table></figure>

<p>第三个参数 args 数组代表创建实例需要的参数，不就是给构造方法用的参数，或者是工厂 Bean 的参数嘛，不过要注意，在我们的初始化阶段，args 是 null。</p>
<p>这回我们要到一个新的类了 AbstractAutowireCapableBeanFactory，看类名，AutowireCapable？类名是不是也说明了点问题了。</p>
<p>主要是为了以下场景，采用 @Autowired 注解注入属性值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.javadoop.example.MessageServiceImpl&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring 会处理这种情况。</p>
<p>好了，读者要知道这么回事就可以了，继续向前。</p>
<p>// AbstractAutowireCapableBeanFactory 447</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Central method of this class: creates a bean instance,</span></span><br><span class="line"><span class="comment"> * populates the bean instance, applies post-processors, etc.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doCreateBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 确保 BeanDefinition 中的 Class 被加载</span></span><br><span class="line">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">   <span class="keyword">if</span> (resolvedClass != <span class="literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="literal">null</span>) &#123;</span><br><span class="line">      mbdToUse = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(mbd);</span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 &lt;lookup-method /&gt; </span></span><br><span class="line">   <span class="comment">// 和 &lt;replaced-method /&gt;，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。</span></span><br><span class="line">   <span class="comment">// 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(),</span><br><span class="line">            beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理，</span></span><br><span class="line">      <span class="comment">// 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> bean; </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 重头戏，创建 bean</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建-Bean"><a href="#创建-Bean" class="headerlink" title="创建 Bean"></a>创建 Bean</h4><p>我们继续往里看 doCreateBean 这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Actually create the specified bean. Pre-creation processing has already happened</span></span><br><span class="line"><span class="comment"> * at this point, e.g. checking &#123;<span class="doctag">@code</span> postProcessBeforeInstantiation&#125; callbacks.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Differentiates between default bean instantiation, use of a</span></span><br><span class="line"><span class="comment"> * factory method, and autowiring a constructor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the merged bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args explicit arguments to use for constructor or factory method invocation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanCreationException if the bean could not be created</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateUsingFactoryMethod</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #autowireConstructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate the bean.</span></span><br><span class="line">   <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">      instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说</span></span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 &quot;bean 实例&quot;</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> (instanceWrapper != <span class="literal">null</span> ? instanceWrapper.getWrappedInstance() : <span class="literal">null</span>);</span><br><span class="line">   <span class="comment">// 类型</span></span><br><span class="line">   Class&lt;?&gt; beanType = (instanceWrapper != <span class="literal">null</span> ? instanceWrapper.getWrappedClass() : <span class="literal">null</span>);</span><br><span class="line">   mbd.resolvedTargetType = beanType;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor</span></span><br><span class="line">   <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的</span></span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">   <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">   <span class="comment">// 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">         isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">               <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      addSingletonFactory(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">            <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值</span></span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">      <span class="keyword">if</span> (exposedObject != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？</span></span><br><span class="line">         <span class="comment">// 这里就是处理 bean 初始化完成后的各种回调</span></span><br><span class="line">         exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">            exposedObject = earlySingletonReference;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">            String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">            Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;String&gt;(dependentBeans.length);</span><br><span class="line">            <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                  actualDependentBeans.add(dependentBean);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line">                     <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                     <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register bean as disposable.</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，我们已经分析完了 doCreateBean 方法，总的来说，我们已经说完了整个初始化流程。</p>
<p>接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。 </p>
<p>注意了，接下来的这三个方法要认真说那也是极其复杂的，很多地方我就点到为止了，感兴趣的读者可以自己往里看，最好就是碰到不懂的，自己写代码去调试它。</p>
<h5 id="创建-Bean-实例"><a href="#创建-Bean-实例" class="headerlink" title="创建 Bean 实例"></a>创建 Bean 实例</h5><p>我们先看看 createBeanInstance 方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> &#123;</span><br><span class="line">   <span class="comment">// 确保已经加载了此 class</span></span><br><span class="line">   Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 校验一下这个类的访问权限</span></span><br><span class="line">   <span class="keyword">if</span> (beanClass != <span class="literal">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="literal">null</span>)  &#123;</span><br><span class="line">      <span class="comment">// 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean</span></span><br><span class="line">      <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果不是第一次创建，比如第二次创建 prototype bean。</span></span><br><span class="line">   <span class="comment">// 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">resolved</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">autowireNecessary</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">if</span> (args == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">         <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="literal">null</span>) &#123;</span><br><span class="line">            resolved = <span class="literal">true</span>;</span><br><span class="line">            autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">      <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">         <span class="comment">// 构造函数依赖注入</span></span><br><span class="line">         <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 无参构造函数</span></span><br><span class="line">         <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断是否采用有参构造函数</span></span><br><span class="line">   Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">   <span class="keyword">if</span> (ctors != <span class="literal">null</span> ||</span><br><span class="line">         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">      <span class="comment">// 构造函数依赖注入</span></span><br><span class="line">      <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用无参构造函数</span></span><br><span class="line">   <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>挑个简单的<strong>无参构造函数</strong>构造实例来看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      Object beanInstance;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">BeanFactory</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">         beanInstance = AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">return</span> getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;, getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 实例化</span></span><br><span class="line">         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 包装一下，返回</span></span><br><span class="line">      <span class="type">BeanWrapper</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(beanInstance);</span><br><span class="line">      initBeanWrapper(bw);</span><br><span class="line">      <span class="keyword">return</span> bw;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">&quot;Instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，关键的地方在于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br></pre></td></tr></table></figure>

<p>这里会进行实际的实例化过程，我们进去看看:</p>
<p>// SimpleInstantiationStrategy 59</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">instantiate</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB,</span></span><br><span class="line">   <span class="comment">// 方法覆写 请参见附录&quot;方法注入&quot;中对 lookup-method 和 replaced-method 的介绍</span></span><br><span class="line">   <span class="keyword">if</span> (bd.getMethodOverrides().isEmpty()) &#123;</span><br><span class="line">      Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">      <span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">         constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">         <span class="keyword">if</span> (constructorToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">            <span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInstantiationException</span>(clazz, <span class="string">&quot;Specified class is an interface&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">                  constructorToUse = AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;Constructor&lt;?&gt;&gt;() &#123;</span><br><span class="line">                     <span class="meta">@Override</span></span><br><span class="line">                     <span class="keyword">public</span> Constructor&lt;?&gt; run() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="keyword">return</span> clazz.getDeclaredConstructor((Class[]) <span class="literal">null</span>);</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                  constructorToUse = clazz.getDeclaredConstructor((Class[]) <span class="literal">null</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInstantiationException</span>(clazz, <span class="string">&quot;No default constructor found&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 利用构造方法进行实例化</span></span><br><span class="line">      <span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。</span></span><br><span class="line">      <span class="comment">// tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持</span></span><br><span class="line">      <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，我们就算实例化完成了。我们开始说怎么进行属性注入。</p>
<h5 id="bean-属性注入"><a href="#bean-属性注入" class="headerlink" title="bean 属性注入"></a>bean 属性注入</h5><p>看完了 createBeanInstance(…) 方法，我们来看看 populateBean(…) 方法，该方法负责进行属性设值，处理依赖。</p>
<p>// AbstractAutowireCapableBeanFactory 1203</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> &#123;</span><br><span class="line">   <span class="comment">// bean 实例的所有属性都在这里了</span></span><br><span class="line">   <span class="type">PropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> mbd.getPropertyValues();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (bw == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值，</span></span><br><span class="line">   <span class="comment">// InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改，</span></span><br><span class="line">   <span class="comment">// 我也没找到有实际的使用，所以我们暂且忽略这块吧</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">continueWithPropertyPopulation</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="comment">// 如果返回 false，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理</span></span><br><span class="line">            <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">               continueWithPropertyPopulation = <span class="literal">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      <span class="type">MutablePropertyValues</span> <span class="variable">newPvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(pvs);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">         autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通过类型装配。复杂一些</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">         autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      pvs = newPvs;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">hasInstAwareBpps</span> <span class="operator">=</span> hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">needsDepCheck</span> <span class="operator">=</span> (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">      <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">         <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">               <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">               <span class="comment">// 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line">               <span class="comment">// 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究</span></span><br><span class="line">               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">               <span class="keyword">if</span> (pvs == <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">         checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 设置 bean 实例的属性值</span></span><br><span class="line">   applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="initializeBean"><a href="#initializeBean" class="headerlink" title="initializeBean"></a>initializeBean</h5><p>属性注入完成后，这一步其实就是处理各种回调了，这块代码比较简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">      AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Object&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;, getAccessControlContext());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调</span></span><br><span class="line">      invokeAwareMethods(beanName, bean);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line">   <span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      <span class="comment">// BeanPostProcessor 的 postProcessBeforeInitialization 回调</span></span><br><span class="line">      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 处理 bean 中定义的 init-method，</span></span><br><span class="line">      <span class="comment">// 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法</span></span><br><span class="line">      invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">            (mbd != <span class="literal">null</span> ? mbd.getResourceDescription() : <span class="literal">null</span>),</span><br><span class="line">            beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      <span class="comment">// BeanPostProcessor 的 postProcessAfterInitialization 回调</span></span><br><span class="line">      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家发现没有，BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method，是不是和读者原来的认知有点不一样了？</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="id-和-name"><a href="#id-和-name" class="headerlink" title="id 和 name"></a>id 和 name</h3><p>每个 Bean 在 Spring 容器中都有一个唯一的名字（beanName）和 0 个或多个别名（aliases）。</p>
<p>我们从 Spring 容器中获取 Bean 的时候，可以根据 beanName，也可以通过别名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beanFactory.getBean(<span class="string">&quot;beanName or alias&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在配置 <code>&lt;bean /&gt;</code> 的过程中，我们可以配置 id 和 name，看几个例子就知道是怎么回事了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageService&quot;</span> <span class="attr">name</span>=<span class="string">&quot;m1, m2, m3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.javadoop.example.MessageServiceImpl&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上配置的结果就是：beanName 为 messageService，别名有 3 个，分别为 m1、m2、m3。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;m1, m2, m3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.javadoop.example.MessageServiceImpl&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.javadoop.example.MessageServiceImpl&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>beanName 为：com.javadoop.example.MessageServiceImpl#0，</p>
<p>别名 1 个，为： com.javadoop.example.MessageServiceImpl</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.javadoop.example.MessageServiceImpl&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上配置的结果就是：beanName 为 messageService，没有别名。</p>
<h3 id="配置是否允许-Bean-覆盖、是否允许循环依赖"><a href="#配置是否允许-Bean-覆盖、是否允许循环依赖" class="headerlink" title="配置是否允许 Bean 覆盖、是否允许循环依赖"></a>配置是否允许 Bean 覆盖、是否允许循环依赖</h3><p>我们说过，默认情况下，allowBeanDefinitionOverriding 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p>
<p>可是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean 覆盖，因为万一出现这种情况，会增加我们排查问题的成本。</p>
<p>循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 allowCircularReferences 也是 null。</p>
<p>它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。</p>
<p>添加这两个属性的作者 Juergen Hoeller 在这个 <a href="https://jira.spring.io/browse/SPR-4374">jira</a> 的讨论中说明了怎么配置这两个属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoBeanOverridingContextLoader</span> <span class="keyword">extends</span> <span class="title class_">ContextLoader</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">customizeContext</span><span class="params">(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.customizeContext(servletContext, applicationContext);</span><br><span class="line">    <span class="type">AbstractRefreshableApplicationContext</span> <span class="variable">arac</span> <span class="operator">=</span> (AbstractRefreshableApplicationContext) applicationContext;</span><br><span class="line">    arac.setAllowBeanDefinitionOverriding(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyContextLoaderListener</span> <span class="keyword">extends</span> <span class="title class_">org</span>.springframework.web.context.ContextLoaderListener &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> ContextLoader <span class="title function_">createContextLoader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NoBeanOverridingContextLoader</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.javadoop.MyContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果以上方式不能满足你的需求，请参考这个链接：<a href="http://blog.csdn.net/zgmzyr/article/details/39380477">解决spring中不同配置文件中存在name或者id相同的bean可能引起的问题</a></p>
<h3 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h3><p>我们可以把不同环境的配置分别配置到单独的文件中，举个例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;development&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jdbc</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">&quot;classpath:com/bank/config/sql/test-data.sql&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;production&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">&quot;http://www.springframework.org/schema/jee&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">jndi-name</span>=<span class="string">&quot;java:comp/env/jdbc/datasource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>应该不必做过多解释了吧，看每个文件第一行的 profile=””。</p>
<p>当然，我们也可以在一个配置文件中使用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jdbc</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">&quot;http://www.springframework.org/schema/jee&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">&quot;classpath:com/bank/config/sql/test-data.sql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;production&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">jndi-name</span>=<span class="string">&quot;java:comp/env/jdbc/datasource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>理解起来也很简单吧。</p>
<p>接下来的问题是，怎么使用特定的 profile 呢？Spring 在启动的过程中，会去寻找 “spring.profiles.active” 的属性值，根据这个属性值来的。那怎么配置这个值呢？</p>
<p>Spring 会在这几个地方寻找 spring.profiles.active 的属性值：操作系统环境变量、JVM 系统变量、web.xml 中定义的参数、JNDI。</p>
<p>最简单的方式莫过于在程序启动的时候指定：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Dspring.profiles.active=&quot;profile1,profile2&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>profile 可以激活多个</p>
</blockquote>
<p>当然，我们也可以通过代码的形式从 Environment 中设置 profile：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">ctx.getEnvironment().setActiveProfiles(<span class="string">&quot;development&quot;</span>);</span><br><span class="line">ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);</span><br><span class="line">ctx.refresh(); <span class="comment">// 重启</span></span><br></pre></td></tr></table></figure>

<p>如果是 Spring Boot 的话更简单，我们一般会创建 application.properties、application-dev.properties、application-prod.properties 等文件，其中 application.properties 配置各个环境通用的配置，application-{profile}.properties 中配置特定环境的配置，然后在启动的时候指定 profile：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Dspring.profiles.active=prod -jar JavaDoop.jar</span><br></pre></td></tr></table></figure>

<p>如果是单元测试中使用的话，在测试类中使用 @ActiveProfiles 指定，这里就不展开了。</p>
<h3 id="工厂模式生成-Bean"><a href="#工厂模式生成-Bean" class="headerlink" title="工厂模式生成 Bean"></a>工厂模式生成 Bean</h3><p>请读者注意 factory-bean 和 FactoryBean 的区别。这节说的是前者，是说静态工厂或实例工厂，而后者是 Spring 中的特殊接口，代表一类特殊的 Bean，附录的下面一节会介绍 FactoryBean。</p>
<p>设计模式里，工厂方法模式分静态工厂和实例工厂，我们分别看看 Spring 中怎么配置这两个，来个代码示例就什么都清楚了。</p>
<p>静态工厂：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;examples.ClientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ClientService</span> <span class="variable">clientService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientService</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ClientService</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ClientService <span class="title function_">createInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例工厂：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceLocator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.DefaultServiceLocator&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">&quot;serviceLocator&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createClientServiceInstance&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">&quot;serviceLocator&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createAccountServiceInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultServiceLocator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ClientService</span> <span class="variable">clientService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AccountService</span> <span class="variable">accountService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClientService <span class="title function_">createClientServiceInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AccountService <span class="title function_">createAccountServiceInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>FactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    Class&lt;T&gt; <span class="title function_">getObjectType</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> Car car ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setCar</span><span class="params">(Car car)</span>&#123; <span class="built_in">this</span>.car = car;  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car 的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car 的复杂过程包装起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCarFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Car&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String make; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> year ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMake</span><span class="params">(String m)</span>&#123; <span class="built_in">this</span>.make =m ; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setYear</span><span class="params">(<span class="type">int</span> y)</span>&#123; <span class="built_in">this</span>.year = y; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">getObject</span><span class="params">()</span>&#123; </span><br><span class="line">      <span class="comment">// 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种</span></span><br><span class="line">      <span class="type">CarBuilder</span> <span class="variable">cb</span> <span class="operator">=</span> CarBuilder.car();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(year!=<span class="number">0</span>) cb.setYear(<span class="built_in">this</span>.year);</span><br><span class="line">      <span class="keyword">if</span>(StringUtils.hasText(<span class="built_in">this</span>.make)) cb.setMake( <span class="built_in">this</span>.make ); </span><br><span class="line">      <span class="keyword">return</span> cb.factory(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Class&lt;Car&gt; <span class="title function_">getObjectType</span><span class="params">()</span> &#123; <span class="keyword">return</span> Car.class ; &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看看装配的时候是怎么配置的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span> = <span class="string">&quot;com.javadoop.MyCarFactoryBean&quot;</span> <span class="attr">id</span> = <span class="string">&quot;car&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">&quot;make&quot;</span> <span class="attr">value</span> =<span class="string">&quot;Honda&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">&quot;year&quot;</span> <span class="attr">value</span> =<span class="string">&quot;1984&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span> = <span class="string">&quot;com.javadoop.Person&quot;</span> <span class="attr">id</span> = <span class="string">&quot;josh&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">&quot;car&quot;</span> <span class="attr">ref</span> = <span class="string">&quot;car&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。</p>
<p>说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean 依赖的越来越少了，更多时候，我们可能会采用 java  config 的方式来配置，这里有什么不一样呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarConfiguration</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="keyword">public</span> MyCarFactoryBean <span class="title function_">carFactoryBean</span><span class="params">()</span>&#123; </span><br><span class="line">      <span class="type">MyCarFactoryBean</span> <span class="variable">cfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCarFactoryBean</span>();</span><br><span class="line">      cfb.setMake(<span class="string">&quot;Honda&quot;</span>);</span><br><span class="line">      cfb.setYear(<span class="number">1984</span>);</span><br><span class="line">      <span class="keyword">return</span> cfb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">aPerson</span><span class="params">()</span>&#123; </span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">      <span class="comment">// 注意这里的不同</span></span><br><span class="line">    person.setCar(carFactoryBean().getObject());</span><br><span class="line">    <span class="keyword">return</span> person; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，其实我们的思路也很简单，把 MyCarFactoryBean 看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是 FactoryBean 和我们没关系。</p>
<h3 id="初始化-Bean-的回调"><a href="#初始化-Bean-的回调" class="headerlink" title="初始化 Bean 的回调"></a>初始化 Bean 的回调</h3><p>有以下四种方案：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleInitBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do some initialization work</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(initMethod = &quot;init&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Foo <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="销毁-Bean-的回调"><a href="#销毁-Bean-的回调" class="headerlink" title="销毁 Bean 的回调"></a>销毁 Bean 的回调</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleInitBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;cleanup&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title class_">DisposableBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do some destruction work (like releasing pooled connections)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(destroyMethod = &quot;cleanup&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Bar <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanup</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h3><p>既然文中说到了这个，顺便提一下好了。</p>
<p>最有用的场景就是，它用来将前端传过来的参数和后端的 controller 方法上的参数进行绑定的时候用。</p>
<p>像前端传过来的字符串、整数要转换为后端的 String、Integer 很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date 这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用 ConversionService 来进行转换。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.javadoop.learning.utils.StringToEnumConverterFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>ConversionService 接口很简单，所以要自定义一个 convert 的话也很简单。</p>
<p>下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。</p>
<p>来看一个很简单的例子，这样比什么都管用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringToDateConverter</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;String, Date&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">convert</span><span class="params">(String source)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DateUtils.parseDate(source, <span class="string">&quot;yyyy-MM-dd&quot;</span>, <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>, <span class="string">&quot;yyyy-MM-dd HH:mm&quot;</span>, <span class="string">&quot;HH:mm:ss&quot;</span>, <span class="string">&quot;HH:mm&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要注册这个 Bean 就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。</p>
<h3 id="Bean-继承"><a href="#Bean-继承" class="headerlink" title="Bean 继承"></a>Bean 继承</h3><p>在初始化 Bean 的地方，我们说过了这个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br></pre></td></tr></table></figure>

<p>这里涉及到的就是 <code>&lt;bean parent=&quot;&quot; /&gt;</code> 中的 parent 属性，我们来看看 Spring 中是用这个来干什么的。</p>
<p>首先，我们要明白，这里的继承和 java 语法中的继承没有任何关系，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。</p>
<p>Spring 中提供了继承自 AbstractBeanDefinition 的 <code>ChildBeanDefinition</code> 来表示 child bean。</p>
<p>看如下一个例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;inheritedTestBean&quot;</span> <span class="keyword">abstract</span>=<span class="string">&quot;true&quot;</span> class=<span class="string">&quot;org.springframework.beans.TestBean&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;parent&quot;</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;age&quot;</span> value=<span class="string">&quot;1&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;inheritsWithDifferentClass&quot;</span> class=<span class="string">&quot;org.springframework.beans.DerivedTestBean&quot;</span></span><br><span class="line">        parent=<span class="string">&quot;inheritedTestBean&quot;</span> init-method=<span class="string">&quot;initialize&quot;</span>&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;override&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>parent bean 设置了 <code>abstract=&quot;true&quot;</code> 所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。</p>
<p>child bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等。</p>
<p>当然，我不是说 parent bean 中的 abstract = true 在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans 的时候会忽略这个 bean。</p>
<p>比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问，这个 bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract = true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;inheritedTestBeanWithoutClass&quot;</span> <span class="keyword">abstract</span>=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;parent&quot;</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;age&quot;</span> value=<span class="string">&quot;1&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h3 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h3><p>一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，直接设置属性依赖就可以了。</p>
<p>但是，如果是 singleton 依赖 prototype 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的 bean。</p>
<p>一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从 BeanFactory 中取。这个也是大家最常用的方式了吧。怎么取，我就不介绍了，大部分 Spring 项目大家都会定义那么个工具类的。</p>
<p>另一种解决方案就是这里要介绍的通过使用 Lookup method。</p>
<h4 id="lookup-method"><a href="#lookup-method" class="headerlink" title="lookup-method"></a>lookup-method</h4><p>我们来看一下 Spring Reference 中提供的一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fiona.apple;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no more Spring imports!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Object commandState)</span> &#123;</span><br><span class="line">        <span class="comment">// grab a new instance of the appropriate Command interface</span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// okay... but where is the implementation of this method?</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title function_">createCommand</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xml 配置 <code>&lt;lookup-method /&gt;</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myCommand&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fiona.apple.AsyncCommand&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject dependencies here as required --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;commandManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fiona.apple.CommandManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">&quot;createCommand&quot;</span> <span class="attr">bean</span>=<span class="string">&quot;myCommand&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring 采用 <strong>CGLIB 生成字节码</strong>的方式来生成一个子类。我们定义的类不能定义为 final class，抽象方法上也不能加 final。</p>
<p>lookup-method 上的配置也可以采用注解来完成，这样就可以不用配置 <code>&lt;lookup-method /&gt;</code> 了，其他不变：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Object commandState)</span> &#123;</span><br><span class="line">        <span class="type">MyCommand</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup(&quot;myCommand&quot;)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title function_">createCommand</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，既然用了注解，要配置注解扫描：<code>&lt;context:component-scan base-package=&quot;com.javadoop&quot; /&gt;</code></p>
</blockquote>
<p>甚至，我们可以像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Object commandState)</span> &#123;</span><br><span class="line">        <span class="type">MyCommand</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> MyCommand <span class="title function_">createCommand</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的返回值用了 MyCommand，当然，如果 Command 只有一个实现类，那返回值也可以写 Command。</p>
</blockquote>
<h4 id="replaced-method"><a href="#replaced-method" class="headerlink" title="replaced-method"></a>replaced-method</h4><p>记住它的功能，就是替换掉 bean 中的一些方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyValueCalculator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">computeValue</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        <span class="comment">// some real code...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// some other methods...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法覆写，注意要实现 MethodReplacer 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReplacementComputeValue</span> <span class="keyword">implements</span> <span class="title class_">org</span>.springframework.beans.factory.support.MethodReplacer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">reimplement</span><span class="params">(Object o, Method m, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// get the input value, work with it, and return a computed result</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> (String) args[<span class="number">0</span>];</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置也很简单：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myValueCalculator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.z.MyValueCalculator&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义 computeValue 这个方法要被替换掉 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">replaced-method</span> <span class="attr">name</span>=<span class="string">&quot;computeValue&quot;</span> <span class="attr">replacer</span>=<span class="string">&quot;replacementComputeValue&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg-type</span>&gt;</span>String<span class="tag">&lt;/<span class="name">arg-type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">replaced-method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;replacementComputeValue&quot;</span> <span class="attr">class</span>=<span class="string">&quot;a.b.c.ReplacementComputeValue&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>arg-type 明显不是必须的，除非存在方法重载，这样必须通过参数类型列表来判断这里要覆盖哪个方法。</p>
</blockquote>
<h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>应该说 BeanPostProcessor 概念在 Spring 中也是比较重要的。我们看下接口定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">   Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">   Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看这个接口中的两个方法名字我们大体上可以猜测 bean 在初始化之前会执行 postProcessBeforeInitialization 这个方法，初始化完成之后会执行 postProcessAfterInitialization 这个方法。但是，这么理解是非常片面的。</p>
<p>首先，我们要明白，除了我们自己定义的 BeanPostProcessor 实现外，Spring 容器在启动时自动给我们也加了几个。如在获取 BeanFactory 的 obtainFactory() 方法结束后的 prepareBeanFactory(factory)，大家仔细看会发现，Spring 往容器中添加了这两个 BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector。</p>
<p>我们回到这个接口本身，读者请看第一个方法，这个方法接受的第一个参数是 bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为新的 bean 实例，所以，没事的话这里不能随便返回个 null。</p>
<p>那意味着什么呢？我们很容易想到的就是，我们这里可以对一些我们想要修饰的 bean 实例做一些事情。但是对于 Spring 框架来说，它会决定是不是要在这个方法中返回 bean 实例的代理，这样就有更大的想象空间了。</p>
<p>最后，我们说说如果我们自己定义一个 bean 实现 BeanPostProcessor 的话，它的执行时机是什么时候？</p>
<p>如果仔细看了代码分析的话，其实很容易知道了，在 bean 实例化完成、属性注入完成之后，会执行回调方法，具体请参见类 AbstractAutowireCapableBeanFactory#initBean 方法。</p>
<p>首先会回调几个实现了 Aware 接口的 bean，然后就开始回调 BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调 init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>按理说，总结应该写在附录前面，我就不讲究了。</p>
<p>在花了那么多时间后，这篇文章终于算是基本写完了，大家在惊叹 Spring 给我们做了那么多的事的时候，应该透过现象看本质，去理解 Spring 写得好的地方，去理解它的设计思想。</p>
<p>本文的缺陷在于对 Spring 预初始化 singleton beans 的过程分析不够，主要是代码量真的比较大，分支旁路众多。同时，虽然附录条目不少，但是庞大的 Spring 真的引出了很多的概念，希望日后有精力可以慢慢补充一些。</p>
<p>（全文完）</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化</title>
    <url>/2024/10/03/%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p><a href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html">序列化和反序列化 - 美团技术团队</a> </p>
<p>序列化乍眼一看似乎是多此一举，比如你在内存中创建了一个Person对象，你把内存中那块表示Person二进制数据原封不动地抠出来放到磁盘中，下次再原封不动地读入内存重构出Person对象不就行了吗，何必要进行序列化呢？</p>
<p>但事实并非那么简单，因为内存中的数据可能是<strong>非连续</strong>的。你所创建的Person对象可能有一个Name成员变量，它可能仅仅是一个指向另一片内存某块连续字符数组的<strong>指针</strong>。现实往往会更复杂，一个成员变量指针往往又指向其他的指针，使得一个简单的对象可能分布在你内存多个零散区域。而序列化，就是把这个对象的数据一层层连根拔起，将其打平成一块<strong>连续</strong>的数据。</p>
<p>我们知道一个对象往往包含很多信息，其成员可能有flaot, string, integer, 也可能是指向另一个对象的指针。比如JSON通过把以上的数据全部<strong>压平</strong>成字符串来进行传输，通过<strong>嵌套的字符串来替换原对象中的内存指针</strong>，来将不连续的数据重建为连续的数据。如果你说，我的对象不包含任何的引用变量或者指针，在内存中就是连续存储的。比如</p>
<p>Class Simple { int a=1; int b= 2} 或者 struct Simple {double a = 1.0;double b = 2.0;}</p>
<p>我还需要进行序列化吗？当然不必要，你可以把它这一块内存直接原封不动地丢进磁盘或网络，然后原封不动地取出来。这种情况极大降低<strong>时间</strong>消耗（几乎不花时间）也降低<strong>空间</strong>消耗（字符串存储效率往往低于二进制）。但是<a href="https://zhida.zhihu.com/search?content_id=318442694&content_type=Answer&match_order=8&q=%E5%BA%8F%E5%88%97%E5%8C%96&zhida_source=entity">序列化</a>依然有很多好处：</p>
<ul>
<li>如果序列化成字符串，可以手动对传输的数据进行<strong>修改</strong>或者<strong>校验</strong></li>
<li>如果序列化成字符串，机器用自己的方式解析字符串，避免**<a href="https://zhida.zhihu.com/search?content_id=318442694&content_type=Answer&match_order=1&q=%E5%A4%A7%E5%B0%8F%E7%AB%AF&zhida_source=entity">大小端</a>**不一致带来的冲突</li>
<li>即使是不序列化成字符串，其他一些独特的二进制序列化方式极大地缩小空间，比如一个长度为8的boolean的数组（原本需要8个byte)，可以压缩成一个<a href="https://zhida.zhihu.com/search?content_id=318442694&content_type=Answer&match_order=2&q=byte&zhida_source=entity">byte</a>再传输（每一个bit为一个boolean).</li>
</ul>
<h2 id="序列化组件"><a href="#序列化组件" class="headerlink" title="序列化组件"></a>序列化组件</h2><p>单方面的只把对象转成字节数组还不行，因为没有规则的字节数组我们是没办法把对象的本来面目还原回来的，所以我们必须在把对象转成字节数组的时候就制定一种规则（序列化），那么我们从IO流里面读出数据的时候再以这种规则把对象还原回来（反序列化）。</p>
<p>OSI七层协议模型中表示层（Presentation Layer）的主要功能是把应用层的对象转换成一段连续的二进制串，或者反过来，把二进制串转换成应用层的对象–这两个功能就是序列化和反序列化。</p>
<ul>
<li><strong>IDL</strong>（Interface description language）文件：参与通讯的各方需要对通讯的内容需要做相关的约定（Specifications）。为了建立一个与语言和平台无关的约定，这个约定需要采用与具体开发语言、平台无关的语言来进行描述。这种语言被称为接口描述语言（IDL），采用IDL撰写的协议约定称之为IDL文件。</li>
<li><strong>IDL Compiler</strong>：IDL文件中约定的内容为了在各语言和平台可见，需要有一个编译器，将IDL文件转换成各语言对应的动态库。</li>
<li><strong>Stub/Skeleton Lib</strong>：负责序列化和反序列化的工作代码。Stub是一段部署在分布式系统客户端的代码，一方面接收应用层的参数，并对其序列化后通过底层协议栈发送到服务端，另一方面接收服务端序列化后的结果数据，反序列化后交给客户端应用层；Skeleton部署在服务端，其功能与Stub相反，从传输层接收序列化参数，反序列化后交给服务端应用层，并将应用层的执行结果序列化后最终传送给客户端Stub。</li>
</ul>
<p><a href="https://zh.wikipedia.org/wiki/%E8%BC%89%E5%85%A5%E5%99%A8">加载器 - 维基百科，自由的百科全书</a> </p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E5%BC%8F%E5%BA%AB">函数库 - 维基百科，自由的百科全书</a></p>
<p><strong>动态库</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        func(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//func.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input i = %d\n&quot;</span>,i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc -o hello main.c func.c <span class="comment"># 静态链接</span></span><br><span class="line">./hello <span class="comment"># 运行可执行文件</span></span><br><span class="line">gcc -shared -o libfunc.so func.o  <span class="comment"># 生成动态库</span></span><br><span class="line">gcc -o my_program main.o -L. -lfunc  <span class="comment"># 动态链接</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=.:<span class="variable">$LD_LIBRARY_PATH</span>  <span class="comment"># 设置共享库路径</span></span><br><span class="line">./hello <span class="comment"># 运行可执行文件</span></span><br></pre></td></tr></table></figure>

<p>编译器在预处理阶段将include的头文件插入到源文件，然后编译成目标代码，后缀名.o 就是object, 也就相当于windows下编译的obj文件，该文件能被cpu直接执行的二进制代码。由编译器生成，具体的生成方法取决于不同的开发环境。</p>
<p><em><strong>链接</strong></em>：当我们的程序模块调用a另一个模块中b的函数（foo()）或变量时，在编译的阶段编译器并不知道函数foo的地址，所以暂时把调用foo的指令的目标地址搁置，等待最后链接的时候由连接器去将这些指令的目标地址修正。把目标文件和库一起链接成可执行文件。将.o文件与其他库文件进行静态链接就生成可执行文件，也就是把多个.o文件连接成一个可执行<a href="https://blog.csdn.net/vividonly/article/details/6399530">ELF文件</a>了</p>
<p>由于业务越来越复杂，导致程序的体积也越来越大，在多进程的操作系统中，可能同时存在成百上千各应用同时运行。每个应用中都会使用到<code>printf</code>、<code>scanf</code>、<code>strlen</code>等基础函数，链接的时候就需要把printf.o这个编译器内置的目标代码链接到hello.o中</p>
<p>那么不同的程序中一定会包含它们的指令部分。这就导致这些程序在磁盘保存时，都有这些基础函数的副本。运行时，也会将这些副本加载到对应进程的虚拟空间内存中去。这就导致了<strong>浪费磁盘和内存</strong>。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/29687bbe2bd05e8a45b046612cb765bf.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">序列化组件</th>
<th align="left">数据库组件</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">IDL</td>
<td align="left">DDL</td>
<td align="left">用于建表或者模型的语言</td>
</tr>
<tr>
<td align="left">DL file</td>
<td align="left">DB Schema</td>
<td align="left">表创建文件或模型文件</td>
</tr>
<tr>
<td align="left">Stub/Skeleton lib</td>
<td align="left">O/R mapping</td>
<td align="left">将class和Table或者数据模型进行映射</td>
</tr>
</tbody></table>
<p>IDL用于描述对象的结构，IDL编译器用于将IDL描述语言转化成</p>
<ul>
<li><strong>Client/Server</strong>：指的是应用层程序代码，他们面对的是IDL所生存的特定语言的class或struct。</li>
<li><strong>底层协议栈和互联网</strong>：序列化之后的数据通过底层的传输层、网络层、链路层以及物理层协议转换成数字信号在互联网中传递。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/a9bee91c.jpg"></p>
<p>序列化只是一种拆装组装对象的规则，那么这种规则肯定也可能有多种多样，比如现在常见的序列化方式有：</p>
<p><strong>JDK</strong>（非跨语言）、<strong>JSON</strong>、<strong>XML</strong>、<strong>Hessian</strong>、<strong>Kryo</strong>（不支持跨语言）、<strong>Thrift</strong>、<strong>Protobuf</strong>、<strong>FST</strong>（非跨语言）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String postcode;</span><br><span class="line">    <span class="keyword">private</span> String street;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer userid;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Address&gt; address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Java-Serializable"><a href="#Java-Serializable" class="headerlink" title="Java Serializable"></a>Java Serializable</h2><p>当创建了⼀个对象后，只要你需要它，它就可以⼀直存在；但是如果程序 退出，这个对象就不存在了。</p>
<p>虽然这乍看起来说得通，但在某些情况下， 如果程序不再运⾏，⽽对象仍然能够存在并且保留相关信息，会对我们⾮ 常有⽤。也就是说，在下次启动程序时，<strong>包含上次程序运⾏时信息</strong>的对象 还会在那⾥。我们可以通过将信息写⼊⽂件或数据库来实现此效果，但本着⼀切皆对象的宗旨，如果能将对象声明为持久性的，然后让编程语⾔⾃ 动为你处理所有的细节，会⽅便很多。</p>
<p>Java的对象序列化（object serialization）机制会接受实现了 <code>Serializable</code> 接⼝的任意对象，并将其转换成⼀个字节序列，便于以后 重新⽣成原始对象。它甚⾄可以通过⽹络⼯作，这意味着序列化机制会⾃ 动消除操作系统之间的差异。也就是说，你可以在Windows机器上创建⼀个对象、将其序列化，然后通过⽹络发送到UNIX机器上，它会在那⾥被正 确重建。你不需要担⼼不同机器上的数据表⽰、字节顺序或任何其他细节。 </p>
<p>对象序列化可以实现轻量级持久化（lightweight persistence）。持久化意味着对象存活于程序调⽤之间，其⽣命周期不是由程序是否在执⾏决 定的。通过获取⼀个可序列化的对象并将其写⼊磁盘，然后在重新调⽤程 序时恢复该对象，这样就产⽣了持久化的效果。之所以称其为“轻量级”， 是因为你不能使⽤某个“持久化”关键字定义⼀个对象，并让编程语⾔替你 处理⼀切细节。相反，你必须在程序中显式地序列化和反序列化对象。如 果需要更严格的持久化机制，请考虑使⽤像Hibernate这样的⼯具。 在语⾔中添加对象序列化，主要是为了⽀持两个功能。</p>
<ul>
<li>⾸先，Java的远程⽅法调⽤（remote method invocation, RMI）可以让存在于远程机器 上的对象表现得像存在本地机器上⼀样。当把消息发送给远程对象时，需 要对象序列化来传输参数和返回值。 </li>
<li>其次，JavaBeans也需要对象序列化（在撰写本书时，JavaBeans被认为 是⼀项失败的技术）。当使⽤Bean时，⼀般会在设计时配置其状态信息。 这个状态信息必须存储起来，然后在程序启动时恢复，对象序列化就被⽤ 来执⾏此任务。</li>
</ul>
<p>对象序列化⾥⼀个特别出彩的地⽅是，它不仅保存了对象的镜像，⽽且会 <strong>跟踪该对象包含的所有引⽤并保存</strong>这些引⽤对象的镜像，然后跟踪每个对象所包含的全部引⽤，以此类推。这有时称为单个对象可以连接到的“对象 ⽹络”，包括成员对象以及存储了对象引⽤的数组。如果你必须维护⾃⼰的 对象序列化⽅案，那么遍历所有这些链接的维护代码可能会极为复杂。不过，Java的对象序列化似乎完美地实现了这个⽬标。毫⽆疑问，它使⽤了 ⼀种遍历对象⽹络的优化算法。</p>
<p><strong>Serializable</strong>：</p>
<ul>
<li>实现<code>Serializable</code>接口的目的是为类可持久化，比如在网络传输或本地存储，为系统的分布和异构部署提供先决条件。若没有序列化，现在我们所熟悉的远程调用，对象数据库都不可能存在。</li>
<li>序列化⼀个对象很简单，只要对象实现了<code>Serializable</code>接⼝就可以。 <code>Serializable</code>是⼀个标签接⼝，没有⽅法。当序列化被添加到语⾔中 时，标准库⾥的许多类被更改以便可序列化，包括所有基本类型的包装 类、所有容器类，等等。甚⾄Class对象也是可以序列化的。</li>
<li>序列化对象的持久化需要一个<code>ObjectOutputStream</code>的字节流<code>writeObject()</code>，反序列化需要<code>ObjectInputStream</code>的<code>readObject()</code>，返回的是一个<code>Object</code>，因此需要强转类型。</li>
<li>反序列化后得到的对象确实包含了原始对象中的所有链接。 注意，在反序列化<code>Serializable</code>对象的过程中，我们没有调⽤任何构造 器，连⽆参构造器也没有调⽤。整个对象的数据都是从<code>InputStream</code>⾥恢复的。</li>
</ul>
<p><strong>Externalizable</strong>：</p>
<ul>
<li><p>所有正常的默认构造⾏为都会发⽣（包括在字段定义处的初始化），之后<code>readExternal()</code>被调⽤。请注意这⼀点，特别是所有默认的构造总是会发⽣，这样才能在<code>Externalizable</code>对象中产⽣正确的⾏为</p>
</li>
<li><p>一言以蔽之，不会存储具体的值，只会存储对象的骨架。在⽆参数构造器中没有初始化。这意味着，如果你没有在<code>readExternal()</code>中初始化s和i，那么s就 是null且i是零（对象的存储在其创建的第⼀步被擦除为零）。</p>
</li>
<li><p>因此，为了使序列化正常，不仅需要在<code>writeExternal()</code>⽅法⾥写⼊对象的重要数据（序列化机制不会默认为<code>Externalizable</code>对象写⼊任何成 员对象），⽽且需要在<code>readExternal()</code>⽅法中恢复该数据。起初这可能有点令⼈困惑，因为<code>Externalizable</code>对象的默认构造⾏为有可能使它看起来像存在某种⾃动存储和恢复⾏为，⽽这实际上是没有的。</p>
</li>
</ul>
<p><strong>static</strong>：</p>
<p>凡是被static修饰的字段是不会被序列化的因为序列化保存的是对象的状态而非类的状态，所以会忽略static静态域。</p>
<p><strong>transient</strong>: </p>
<ul>
<li>防⽌对象的敏感部分被序列化的⼀种⽅法是将你的类实现为 <code>Externalizable</code>，如前所⽰。这样就不会⾃动序列化任何内容了，你可以仅显式地序列化<code>writeExternal()</code>中的必要部分。 但是，如果你正在使⽤<code>Serializable</code>对象，则所有序列化都会⾃动发⽣。</li>
<li>为了控制这⼀点，可以使⽤<code>transient</code>关键字逐个字段地关闭序列化，它表⽰“不要费⼼保存或恢复这个字段——我会处理它的”。date和username是普通字段（不是<code>transient</code>的），因此会⾃动序列化。然⽽password是<code>transient</code>的，所以不会被存储到磁盘，序列化机制也不会尝试恢复它。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logon</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> `<span class="keyword">transient</span>` String password;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Logon</span><span class="params">(String name, String pwd)</span> &#123;</span><br><span class="line">        username = name;</span><br><span class="line">        password = pwd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当对象被恢复时，password字段为null。注意， toString()使⽤重载的+运算符组装了⼀个字符串对象，⽽其中的null 引⽤被⾃动转换成了字符串”null”。 你还可以看到date字段被存储到磁盘并从磁盘恢复，⽽不是重新⽣成。 Externalizable对象默认不存储⾃⾝的任何字段，因此<code>transient</code>关键字仅适⽤于Serializable对象。</li>
</ul>
<p><strong>serialVersionUID</strong>: </p>
<ul>
<li><p>在进行反序列化时，JVM会把传来的字节流中的<code>serialVersionUID</code>于本地相应实体类的<code>serialVersionUID</code>进行比较。如果相同说明可以反序列化，否则会出现反序列化版本不一致的异常<code>InvalidCastException</code></p>
</li>
<li><p>具体过程是这样的：序列化操作时会把系统当前类的<code>serialVersionUID</code>写入到序列化文件中，当反序列化时系统会自动检测文件中的<code>serialVersionUID</code>，判断它是否与当前类中的<code>serialVersionUID</code>一致。</p>
</li>
</ul>
<p><a href="https://blog.csdn.net/u014750606/article/details/80040130">java类中serialVersionUID的作用_seriaversionid 1l-CSDN博客</a> </p>
<ul>
<li><p>当实现<code>java.io.Serializable</code>接口中没有显示的定义<code>serialVersionUID</code>变量的时候，Java序列化机制会根据Class自动生成一个<code>serialVersionUID</code>作序列化版本比较用，这种情况下，如果class文件(类名,方法等)没有发生变化(增加空格，换行，增加注释等等)，就算再编译多次，<code>serialVersionUID</code>也不会变化的。</p>
</li>
<li><p>如果我们不希望通过编译来强制划分软件版本，即实现序列化接口的实体能够兼容先前版本，就需要显示的定义一个<code>serialVersionUID</code>，类型为<code>long</code>的变量。不修改这个变量值的序列化实体，都可以相互进行序列化和反序列化。</p>
</li>
<li><p>还强烈建议使用 <code>private</code> 修饰符显示声明<code> serialVersionUID</code>（如果可能），原因是这种声明仅应用于直接声明类 – <code>serialVersionUID</code> 字段作为继承成员没有用处。数组类不能声明一个明确的 <code>serialVersionUID</code>，因此它们总是具有默认的计算值，但是数组类没有匹配 <code>serialVersionUID</code> 值的要求。</p>
</li>
</ul>
<p><strong>序列化与继承</strong>：</p>
<p>序列化是以正向递归的形式进行的，如果父类实现了序列化那么其子类都将被序列化；子类实现了序列化而父类没实现序列化，那么只有子类的属性会进行序列化，而父类的属性是不会进行序列化的。</p>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>对象序列化的⼀个重要限制是，它仅适⽤于Java平台：只有Java程序可以 反序列化此类对象。⼀个更具互操作性的解决⽅案是将数据转换为XML格式，这使得它可以被各种平台和语⾔使⽤。 由于XML的流⾏，使⽤它编程有很多令⼈困惑的选项，包括与JDK⼀起分 发的javax.xml.*库。我选择使⽤Elliotte Rusty Harold的开源XOM库 （可从XOM⽹站下载并查看其⽂档），因为在使⽤Java⽣成并修改XML的 各种⽅式中，它似乎是最简单、最直接的。此外，XOM还强调了XML的正 确性。 例如，假设有⼀个包含名字和姓⽒的APerson对象，你希望将其序列化为 XML。下⾯的APerson类有⼀个getXML()⽅法，它使⽤XOM将APerson 的数据抽取并转换为XML的Element对象，还有⼀个接受Element对象的 构造器，可以提取相应的APerson数据（注意XML⽰例在它⾃⼰的⼦⽬录 中）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;xsd:complexType name=&#x27;Address&#x27;&gt;</span><br><span class="line">     &lt;xsd:attribute name=&#x27;city&#x27; type=&#x27;xsd:string&#x27; /&gt;</span><br><span class="line">     &lt;xsd:attribute name=&#x27;postcode&#x27; type=&#x27;xsd:string&#x27; /&gt;</span><br><span class="line">     &lt;xsd:attribute name=&#x27;street&#x27; type=&#x27;xsd:string&#x27; /&gt;</span><br><span class="line">&lt;/xsd:complexType&gt;</span><br><span class="line">&lt;xsd:complexType name=&#x27;UserInfo&#x27;&gt;</span><br><span class="line">     &lt;xsd:sequence&gt;</span><br><span class="line">     &lt;xsd:element name=&#x27;address&#x27; type=&#x27;tns:Address&#x27;/&gt;</span><br><span class="line">     &lt;xsd:element name=&#x27;address1&#x27; type=&#x27;tns:Address&#x27;/&gt; </span><br><span class="line">     &lt;/xsd:sequence&gt;</span><br><span class="line">     &lt;xsd:attribute name=&#x27;userid&#x27; type=&#x27;xsd:int&#x27; /&gt;</span><br><span class="line">     &lt;xsd:attribute name=&#x27;name&#x27; type=&#x27;xsd:string&#x27; /&gt; </span><br><span class="line">&lt;/xsd:complexType&gt;</span><br></pre></td></tr></table></figure>

<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;userid&quot;</span>:<span class="number">1</span>,</span><br><span class="line"> <span class="string">&quot;name&quot;</span>:<span class="string">&quot;messi&quot;</span>,</span><br><span class="line"> <span class="string">&quot;address&quot;</span>:</span><br><span class="line"> [</span><br><span class="line">     &#123;<span class="string">&quot;city&quot;</span>:<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;postcode&quot;</span>:<span class="string">&quot;1000000&quot;</span>,<span class="string">&quot;street&quot;</span>:<span class="string">&quot;wangjingdonglu&quot;</span>&#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Kryo"><a href="#Kryo" class="headerlink" title="Kryo"></a>Kryo</h2><p>Kryo是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</p>
<p>另外，Kryo 已经是一种非常成熟的序列化实现了，已经在Twitter、Groupon、Yahoo以及多个著名开源项目（如Hive、Storm）中广泛的使用。</p>
<p><a href="https://link.zhihu.com/?target=https://github.com/Snailclimb/guide-rpc-framework">guide-rpc-framework</a> 就是使用的 kyro 进行序列化，序列化和反序列化相关的代码如下：</p>
<p><img src="https://picx.zhimg.com/80/v2-c2d640eded6b96090704a79eaf2298ad_1440w.webp?source=1def8aca" alt="img"></p>
<p>Github 地址：<a href="https://link.zhihu.com/?target=https://github.com/EsotericSoftware/kryo">https://github.com/EsotericSoftware/kryo</a> 。</p>
<h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><p>Protobuf出自于Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的<a href="https://zhida.zhihu.com/search?content_id=471921064&content_type=Answer&match_order=1&q=%E5%BA%8F%E5%88%97%E5%8C%96%E4%BB%A3%E7%A0%81&zhida_source=entity">序列化代码</a>。这样虽然不然灵活，但是，另一方面导致protobuf没有序列化漏洞的风险。</p>
<blockquote>
<p>Protobuf包含序列化格式的定义、各种语言的库以及一个IDL编译器。正常情况下你需要定义proto文件，然后使用IDL编译器编译成你需要的语言</p>
</blockquote>
<p>一个简单的 proto 文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message Address</span><br><span class="line">&#123;</span><br><span class="line">	required string city=1;</span><br><span class="line">    	optional string postcode=2;</span><br><span class="line">    	optional string street=3;</span><br><span class="line">&#125;</span><br><span class="line">message UserInfo</span><br><span class="line">&#123;</span><br><span class="line">	required string userid=1;</span><br><span class="line">	required string name=2;</span><br><span class="line">	repeated Address address=3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pica.zhimg.com/80/v2-35121b76c4b3f29797ade34ad321ddd8_1440w.webp?source=1def8aca" alt="img"></p>
<p>Github地址：<a href="https://link.zhihu.com/?target=https://github.com/protocolbuffers/protobuf">https://github.com/protocolbuffers/protobuf</a>。</p>
<h2 id="ProtoStuff"><a href="#ProtoStuff" class="headerlink" title="ProtoStuff"></a>ProtoStuff</h2><p>由于Protobuf的易用性，它的哥哥 Protostuff 诞生了。</p>
<p>protostuff 基于Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。</p>
<p>Gihub地址：<a href="https://link.zhihu.com/?target=https://github.com/protostuff/protostuff">https://github.com/protostuff/protostuff</a>。</p>
<h2 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h2><p>hessian 是一个轻量级的,自定义描述的二进制RPC协议。hessian是一个比较老的序列化实现了，并且同样也是跨语言的。</p>
<p><img src="https://pic1.zhimg.com/80/v2-2d1938219e4ee344b331583866a6dc82_1440w.webp?source=1def8aca" alt="img"></p>
<p>以上描述的五种序列化和反序列化协议都各自具有相应的特点，适用于不同的场景：</p>
<p>1、对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP协议是一个值得考虑的方案。</p>
<p>2、基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选。对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON也是非常不错的选择。</p>
<p>3、对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发成本。</p>
<p>4、当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro之间具有一定的竞争关系。</p>
<p>5、对于T级别的数据的持久化应用场景，Protobuf和Avro是首要选择。如果持久化后的数据存储在Hadoop子项目里，Avro会是更好的选择。</p>
<p>6、由于Avro的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro是更好的选择。</p>
<p>7、对于持久层非Hadoop项目，以静态类型语言为主的应用场景，Protobuf会更符合静态类型语言工程师的开发习惯。</p>
<p>8、如果需要提供一个完整的RPC解决方案，Thrift是一个好的选择。</p>
<p>9、如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，Protobuf可以优先考虑。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>Web开发</strong>（特别是前后端通信）：JSON占主导地位。</li>
<li><strong>高性能需求</strong>：Protobuf和Thrift是更优的选择。</li>
<li><strong>大数据处理</strong>：Avro和MessagePack可能是合适的选择。</li>
<li><strong>复杂文档结构</strong>：XML仍然是标准选择。</li>
</ul>
<p>不同场景下的需求，决定了选择哪种序列化方法。</p>
]]></content>
      <categories>
        <category>jdk</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>并发集合框架</title>
    <url>/2024/10/28/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><h2 id="并发安全-Map"><a href="#并发安全-Map" class="headerlink" title="并发安全 Map"></a>并发安全 Map</h2><p><code>ConcurrentSkipListMap</code>: 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="JDK-1-7-Segment-ReentrantLock"><a href="#JDK-1-7-Segment-ReentrantLock" class="headerlink" title="JDK 1.7: Segment(ReentrantLock)"></a>JDK 1.7: Segment(ReentrantLock)</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java7_concurrenthashmap.png" alt="Java7 ConcurrentHashMap 存储结构"></p>
<p>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，</p>
<p>JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 继承自 <code>ReentrantLock</code>。每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</p>
<ul>
<li><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。</li>
<li><code>Segment</code> 数组中的每个元素包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 数组属于链表结构。</li>
</ul>
<p>首先将数据分为一段一段（这个“段”就是 <code>Segment</code>）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。</p>
<p><code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组，<code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>。 <code>Segment</code> 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。</p>
<p><code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p>
<p>JDK 1.7 最大并发度是 Segment 的个数，默认是 16</p>
<h4 id="JDK-1-8-Node-CAS-synchronized"><a href="#JDK-1-8-Node-CAS-synchronized" class="headerlink" title="JDK 1.8: Node+CAS+synchronized"></a>JDK 1.8: Node+CAS+synchronized</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构"></p>
<p>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是<mark>直接用 <code>Node</code></mark> 数组+链表+红黑树的数据结构来实现，并发控制使用 <mark><code>synchronized</code> 和 CAS</mark> 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p>
<p>JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</p>
<ul>
<li><p>每个 <strong>桶（bucket）</strong> 对应一个链表或红黑树，用于解决<strong>哈希冲突</strong>。</p>
</li>
<li><p>如果链表长度超过一定阈值（默认为 8），链表会自动转换为<strong>红黑树</strong>，提高查询效率。</p>
</li>
<li><p>红黑树的情况需要使用 <code>TreeNode</code>。当冲突链表达到一定长度时，链表会转换成红黑树。<code>TreeNode</code>是存储红黑树节点，被<code>TreeBin</code>包装。<code>TreeBin</code>通过<code>root</code>属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所以在 <code>ConcurrentHashMap</code> 中<code>TreeBin</code>通过<code>waiter</code>属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。</p>
</li>
</ul>
<p>JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</p>
<p><strong>链表的线程安全性</strong> </p>
<p>在 <strong>ConcurrentHashMap</strong> 中，链表本身不是直接加锁的，而是通过更细粒度的<strong>CAS（Compare-And-Swap）机制</strong>和<strong>自旋锁</strong>来保证线程安全：</p>
<ol>
<li><strong>插入节点</strong>时通过 CAS 更新表头或表尾。</li>
<li><strong>查询节点</strong>时允许并发读操作，而不会阻塞其他线程。</li>
<li><strong>扩容操作</strong>采用链表迁移的方式，通过分段迁移减少阻塞时间。</li>
</ol>
<h4 id="不保证复合操作原子性"><a href="#不保证复合操作原子性" class="headerlink" title="不保证复合操作原子性"></a>不保证复合操作原子性</h4><p><code>ConcurrentHashMap</code> 是线程安全的，意味着它可以保证多个线程同时对它进行读写操作时，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 <code>HashMap</code> 多线程操作导致死循环问题。但是，这并不意味着它可以保证所有的复合操作都是原子性的，一定不要搞混了！</p>
<p>复合操作是指由多个基本操作(如<code>put</code>、<code>get</code>、<code>remove</code>、<code>containsKey</code>等)组成的操作，例如先判断某个键是否存在<code>containsKey(key)</code>，然后根据结果进行插入或更新<code>put(key, value)</code>。这种操作在执行过程中可能会被其他线程打断，导致结果不符合预期。</p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p><code>Hashtable</code>(同一把锁) :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低</p>
<h2 id="并发安全-List"><a href="#并发安全-List" class="headerlink" title="并发安全 List"></a>并发安全 List</h2><h3 id="线程不安全-ArrayList"><a href="#线程不安全-ArrayList" class="headerlink" title="线程不安全 ArrayList"></a>线程不安全 ArrayList</h3><p>我们通常使用的ArrayList就是线程不安全的，举个简单的例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestList</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] <span class="keyword">args</span></span>)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.<span class="keyword">add</span>(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.<span class="keyword">out</span>.println(list);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并发修改异常</span></span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;4&quot;</span> java.util.ConcurrentModificationException</span><br><span class="line">   at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">909</span>)</span><br><span class="line">   at java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">859</span>)</span><br><span class="line">   at java.util.AbstractCollection.toString(AbstractCollection.java:<span class="number">461</span>)</span><br><span class="line">   at java.lang.String.valueOf(String.java:<span class="number">2994</span>)</span><br><span class="line">   at java.io.PrintStream.println(PrintStream.java:<span class="number">821</span>)</span><br><span class="line">   at com.hnguigu.<span class="keyword">unsafe</span>.TestList.lambda$main$<span class="number">0</span>(TestList.java:<span class="number">20</span>)</span><br><span class="line">   at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案，有以下几种！</strong></p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">concurrent</span>.<span class="property">CopyOnWriteArrayList</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestList</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解决方案</span></span><br><span class="line"><span class="comment">         * 1. List&lt;String&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line"><span class="comment">         * 2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span></span><br><span class="line"><span class="comment">         * 3. List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="title class_">List</span>&lt;<span class="title class_">String</span>&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                list.<span class="title function_">add</span>(<span class="variable constant_">UUID</span>.<span class="title function_">randomUUID</span>().<span class="title function_">toString</span>().<span class="title function_">substring</span>(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(list);</span><br><span class="line">            &#125;,<span class="title class_">String</span>.<span class="title function_">valueOf</span>(i)).<span class="title function_">start</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写入时复制（CopyOnWrite，简称COW）思想是计算机程序设计领域中的一种通用优化策略。</p>
<p>CopyOnWrite容器即写入时复制的容器。<strong>通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。</strong>这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<p>读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据。CopyOnWrite并发容器用于读多写少的并发场景。</p>
<blockquote>
<p>CopyOnWriteArrayList 比 Vector 厉害在哪里？</p>
</blockquote>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20221224114551267-580082797.png" alt="CopyOnWrite"></p>
<p>CopyOnWriteArrayList底层采用了Lock锁，是JDK层面的，效率高！</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20221223214340940-165732240.png" alt="VectorSource"></p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p>
<ul>
<li>CopyOnWriteArrayList 并发安全且性能比 Vector 好。Vector 是增删改查方法都加了synchronized 来保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降，而 CopyOnWriteArrayList 只是在增删改上加锁，但是读不加锁，在读方面的性能就好于 Vector。</li>
<li>线程安全的 <code>List</code>，在读多写少的场合性能非常好，远远好于 <code>Vector</code>。</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据一致性问题。这种实现只是保证数据的<strong>最终一致性</strong>，不能保证数据的<strong>实时一致性</strong>。在添加到拷贝数据而还没进行替换的时候，读到的仍然是旧数据。</li>
<li>内存占用问题。如果对象比较大，内存写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。 这个时候，我们应该考虑其他的容器，例如 ConcurrentHashMap。</li>
<li>由于实际使用中可能没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点 多，每次 add/set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种 操作分分钟引起故障。</li>
</ul>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>Vector底层采用了Synchronized加锁的方式，保证了数据的安全性，但是效率低下！</p>
<p>解释一下：Synchronized是Java内置的机制，是JVM层面的，效率低是因为底层操作依赖于操作系统，操作系统切换线程要从用户态切换到内核态，花费很多时间。</p>
<h2 id="并发安全-Set"><a href="#并发安全-Set" class="headerlink" title="并发安全 Set"></a>并发安全 Set</h2><h3 id="线程不安全-HashSet"><a href="#线程不安全-HashSet" class="headerlink" title="线程不安全 HashSet"></a>线程不安全 HashSet</h3><p>Set和List同样是多线程下不安全的集合类，同样会报并发修改异常！</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestSet</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] <span class="keyword">args</span></span>)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; <span class="keyword">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">set</span>.<span class="keyword">add</span>(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="keyword">set</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestSet</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] <span class="keyword">args</span></span>)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解决方案</span></span><br><span class="line"><span class="comment">         * set集合没有可替换的集合</span></span><br><span class="line"><span class="comment">         * 1. Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span></span><br><span class="line"><span class="comment">         * 2. Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Set&lt;String&gt; <span class="keyword">set</span> = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">set</span>.<span class="keyword">add</span>(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="keyword">set</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和面试官谈到这里，一般都会问hashSet的底层实现原理。<br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20221224125000674-1551081400.png" alt="hashSetSource"></p>
<p>底层其实就是用hashMap实现的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20221224125144809-649163275.png" alt="hashSetAdd"></p>
<p>HashSet底层使用了哈希表来支持的，特点：存储快 往HashSet添加元素的时候，HashSet会先调用元素的HashCode方法得到元素的哈希值，然后通过元素的哈希值经过异或移位等运算，就可以算出该元素在哈希表中的存储位置。如果算出的元素存储的位置目前没有任何元素存储，那么该元素可以直接存储在该位置上；如果算出的元素的存储位置上目前已经有了其他的元素，那么还会调用该元素的equals方法 ，与该位置的元素进行比较一次，如果过equals方法返回的是true，那么该位置上的元素就会被视为重复元素，不允许被添加，如果false，则允许添加。</p>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p><code>BlockingQueue</code> 是 Java 并发包（<code>java.util.concurrent</code>）中的一个接口，专门用于<strong>线程安全的生产者-消费者模型</strong>。它支持线程在队列为空或已满时自动阻塞，从而简化了多线程编程中的同步问题。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/arrayblockingqueue-class-diagram.png" alt="ArrayBlockingQueue 类图"></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>线程安全：<ul>
<li>内部使用锁和条件变量（Condition）实现线程安全操作。</li>
</ul>
</li>
<li>阻塞机制：<ul>
<li>当队列为空时，获取元素的线程会被阻塞，直到队列中有可用元素。</li>
<li>当队列已满时，添加元素的线程会被阻塞，直到队列有空间。</li>
</ul>
</li>
<li>常用场景：<ul>
<li><strong>生产者-消费者模型</strong>，生产者向队列中添加数据，消费者从队列中取数据。</li>
<li>控制线程执行顺序或流量，避免资源争抢。</li>
</ul>
</li>
</ol>
<p><code>BlockingQueue</code>: 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><code>ArrayBlockingQueue</code> </p>
<ul>
<li><strong>best performance</strong> </li>
<li>单lock 双condition 算法，必须显式设置容量</li>
<li>底层是数组，有界队列，如果我们要使用生产者-消费者模式，这是非常好的选择。</li>
</ul>
<p><code>LinkedBlockingQueue</code> / <code>LinkedBlockingDeque</code></p>
<ul>
<li>2 locks 2 conditions，默认Integer.MAX_VALUE</li>
<li>底层是链表，可以当做无界和有界队列来使用，所以大家不要以为它就是无界队列。</li>
</ul>
<p><code>SynchronousQueue</code></p>
<ul>
<li>每次插入操作必须等待一个取出操作，否则就会阻塞，适合高并发传递数据。</li>
<li>不允许null</li>
<li>本身不带有空间来存储任何元素，使用上可以选择公平模式和非公平模式。</li>
</ul>
<p><code>DelayQueue</code></p>
<ul>
<li>延时队列，只有到期的元素才能被取出，适合定时任务或延迟执行场景。</li>
<li>elements must implement <code>java.util.concurrent.Delayed</code> </li>
</ul>
<p><code>LinkedTransferQueue</code></p>
<ul>
<li>waits for consumer to consume the element (message passing need to be guaranteed)</li>
</ul>
<p><code>ConcurrentLinkedQueue</code>:</p>
<ul>
<li>高效的并发队列，使用链表实现。一个线程安全的 <code>LinkedList</code>，这是一个非阻塞队列。</li>
</ul>
<p><code>PriorityBlockingQueue</code></p>
<ul>
<li>concurrent version of <code>PriorityQueue</code></li>
<li>无界队列，基于数组，数据结构为二叉堆，数组第一个也是树的根节点总是最小值。</li>
<li>基于优先级堆实现的无界阻塞队列，元素按优先级排序，不保证 FIFO。</li>
</ul>
<h3 id="主要方法-put-take-offer-poll"><a href="#主要方法-put-take-offer-poll" class="headerlink" title="主要方法: put-take offer-poll"></a>主要方法: put-take offer-poll</h3><p>add、remove实际上是对offer的封装</p>
<ul>
<li><strong>插入元素：</strong><ul>
<li><code>put(E e)</code>：如果队列已满，阻塞等待空间。</li>
<li><code>offer(E e)</code>: 非阻塞插入<ul>
<li><code>offer(E e, long timeout, TimeUnit unit)</code>：带自旋的非阻塞插入</li>
</ul>
</li>
</ul>
</li>
<li><strong>取出元素：</strong> <ul>
<li><code>take()</code>：如果队列为空，阻塞等待数据。</li>
<li><code>poll()</code>: 非阻塞获取<ul>
<li><code>poll(long timeout, TimeUnit unit)</code>：带自旋的非阻塞获取</li>
</ul>
</li>
</ul>
</li>
<li><strong>检查队列状态：</strong><ul>
<li><code>size()</code>：返回当前元素数量。</li>
<li><code>remainingCapacity()</code>：返回剩余可用空间。</li>
</ul>
</li>
<li>队列数据迁移<ul>
<li><code>int elemCount = queue.drainTo(list);</code></li>
<li> <code>drainTo</code> 会一次性将队列中所有元素存放到列表，如果队列中有元素，且成功存到 list 中则 <code>drainTo</code> 会返回本次转移到 list 中的元素数，若队列为空，<code>drainTo</code> 则直接返回 0</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    queue.put(i); <span class="comment">// 阻塞插入</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Produced: &quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> queue.take(); <span class="comment">// 阻塞获取</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumed: &quot;</span> + value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>实际上就是生产者——消费者模式的具体实现</p>
<p>加锁访问共享区域，阻塞使用的是和锁相关的condition条件变量，细化了等待条件</p>
<p>condition.await    condition.signal/signalAll   就是使用了这个细节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#define MAXSIZE <span class="number">8</span></span><br><span class="line"><span class="type">int</span> buffer[MAXSIZE];</span><br><span class="line"><span class="type">int</span> <span class="variable">fill_ptr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">use_ptr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    buffer[fill_ptr] = value;</span><br><span class="line">	fill_ptr = (fill_ptr + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> buffer[use_ptr];</span><br><span class="line">    fill_ptr = (fill_ptr + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">cond_t notEmpty,notFull;</span><br><span class="line">mutex_t mutex;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; loops;i++)&#123;</span><br><span class="line">        mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(count == MAXSIZE)</span><br><span class="line">            cond_wait(&amp;notEmpty, &amp;mutex);</span><br><span class="line">    	put(i);</span><br><span class="line">        printf(<span class="string">&quot;producer:%d puts value:%d&quot;</span>, gettid(), i);</span><br><span class="line">        cond_signal((&amp;notFull);</span><br><span class="line">    	mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; loops;i++)&#123;</span><br><span class="line">        mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(count == <span class="number">0</span>)</span><br><span class="line">            cond_wait(&amp;isEmpty, &amp;mutex);</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> get();</span><br><span class="line">        printf(<span class="string">&quot;pid:%d gets value:%d&quot;</span>, gettid(), value);</span><br><span class="line">        cond_signal(&amp;isFull);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                    </span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>集合</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式也可以这么简单(转自JavaDoop)</title>
    <url>/2020/04/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Designing-Pattern"><a href="#Designing-Pattern" class="headerlink" title="Designing Pattern"></a>Designing Pattern</h1><p>一直想写一篇介绍设计模式的文章，让读者可以很快看完，而且一看就懂，看懂就会用，同时不会将各个模式搞混。自认为本文还是写得不错的😂😂😂，花了不少心思来写这文章和做图，力求让读者真的能看着简单同时有所收获。</p>
<p>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 <em>Gang of Four</em> (<em>GoF</em>) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。</p>
<p>有一些重要的设计原则在开篇和大家分享下，这些原则将贯通全文：</p>
<ol>
<li>面向接口编程，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。</li>
<li>职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。</li>
<li>对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。</li>
</ol>
<p><strong>创建型模式比较简单，但是会比较没有意思，结构型和行为型比较有意思。</strong></p>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>和名字一样简单，非常简单，直接上代码吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;noodle&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Food</span> <span class="variable">noodle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LanZhouNoodle</span>();</span><br><span class="line">            noodle.addSpicy(<span class="string">&quot;more&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> noodle;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;chicken&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Food</span> <span class="variable">chicken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HuangMenChicken</span>();</span><br><span class="line">            chicken.addCondiment(<span class="string">&quot;potato&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> chicken;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。</em></p>
<p>简单地说，简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。</p>
<blockquote>
<p>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。</p>
</blockquote>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line">    Food <span class="title function_">makeFood</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChineseFoodFactory</span> <span class="keyword">implements</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanFoodFactory</span> <span class="keyword">implements</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanFoodA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanFoodB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。</p>
<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 先选择一个具体的工厂</span></span><br><span class="line">        <span class="type">FoodFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodFactory</span>();</span><br><span class="line">        <span class="comment">// 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象</span></span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> factory.makeFood(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然都是调用 makeFood(“A”)  制作 A 类食物，但是，不同的工厂生产出来的完全不一样。</p>
<p>第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。</p>
<p><strong>核心在于，我们需要在第一步选好我们需要的工厂</strong>。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。</p>
<p>虽然简单，不过我也把所有的构件都画到一张图上，这样读者看着比较清晰：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/factory-1.png" alt="factory-1"></p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。</p>
<p>一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。</p>
<p>因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下图：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/abstract-factory-1.png" alt="factory-1"></p>
<p>这个时候的客户端调用是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到 Intel 的 CPU</span></span><br><span class="line"><span class="type">CPUFactory</span> <span class="variable">cpuFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntelCPUFactory</span>();</span><br><span class="line"><span class="type">CPU</span> <span class="variable">cpu</span> <span class="operator">=</span> intelCPUFactory.makeCPU();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到 AMD 的主板</span></span><br><span class="line"><span class="type">MainBoardFactory</span> <span class="variable">mainBoardFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AmdMainBoardFactory</span>();</span><br><span class="line"><span class="type">MainBoard</span> <span class="variable">mainBoard</span> <span class="operator">=</span> mainBoardFactory.make();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组装 CPU 和主板</span></span><br><span class="line"><span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(cpu, mainBoard);</span><br></pre></td></tr></table></figure>

<p>单独看 CPU 工厂和主板工厂，它们分别是前面我们说的<strong>工厂模式</strong>。这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。</p>
<p>但是，这种方式有一个问题，那就是如果 <strong>Intel 家产的 CPU 和 AMD 产的主板不能兼容使用</strong>，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。</p>
<p>下面就是我们要说的<strong>产品族</strong>的概念，它代表了组成某个产品的一系列附件的集合：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/abstract-factory-2.png" alt="abstract-factory-2"></p>
<p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/abstract-factory-3.png" alt="abstract-factory-3"></p>
<p>这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一步就要选定一个“大厂”</span></span><br><span class="line">    <span class="type">ComputerFactory</span> <span class="variable">cf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AmdFactory</span>();</span><br><span class="line">    <span class="comment">// 从这个大厂造 CPU</span></span><br><span class="line">    <span class="type">CPU</span> <span class="variable">cpu</span> <span class="operator">=</span> cf.makeCPU();</span><br><span class="line">    <span class="comment">// 从这个大厂造主板</span></span><br><span class="line">    <span class="type">MainBoard</span> <span class="variable">board</span> <span class="operator">=</span> cf.makeMainBoard();</span><br><span class="line">  	<span class="comment">// 从这个大厂造硬盘</span></span><br><span class="line">  	<span class="type">HardDisk</span> <span class="variable">hardDisk</span> <span class="operator">=</span> cf.makeHardDisk();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将同一个厂子出来的 CPU、主板、硬盘组装在一起</span></span><br><span class="line">    <span class="type">Computer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(cpu, board, hardDisk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>对修改关闭，对扩展开放</strong>这个设计原则。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式用得最多，错得最多。</p>
<p>饿汉模式最简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 首先，将 new Singleton() 堵死</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 瞎写一个静态方法。这里想说的是，如果我们只是要调用 Singleton.getDate(...)，</span></span><br><span class="line">    <span class="comment">// 本来是不想要生成 Singleton 实例的，不过没办法，已经生成了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">getDate</span><span class="params">(String mode)</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>很多人都能说出饿汉模式的缺点，可是我觉得生产过程中，很少碰到这种情况：你定义了一个单例的类，不需要其实例，可是你却把一个或几个你会用到的静态方法塞到这个类中。</p>
</blockquote>
<p>饱汉模式最容易出错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 首先，也是先堵死 new Singleton() 这条路</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 这一次判断也是必须的，不然会有并发问题</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>双重检查，指的是两次检查 instance 是否为 null。</p>
<p>volatile 在这里是需要的，希望能引起读者的关注。</p>
<p>很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。</p>
</blockquote>
<p>嵌套类最经典，以后大家就用它吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton3</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，很多人都会把这个<strong>嵌套类</strong>说成是<strong>静态内部类</strong>，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。</p>
</blockquote>
<p>最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。</p>
<p>虽然我们平时很少看到用枚举来实现单例，但是在 RxJava 的源码中，有很多地方都用了枚举来实现单例。</p>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>经常碰见的 XxxBuilder 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodBuilder</span>().a().b().c().build();</span><br><span class="line"><span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> Food.builder().a().b().c().build();</span><br></pre></td></tr></table></figure>

<p>套路就是先 new 一个 Builder，然后可以链式地调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了。</p>
<p>来一个中规中矩的建造者模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 下面是“一堆”的属性</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化，不然客户端就会直接调用构造方法了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(String name, String password, String nickName, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯，</span></span><br><span class="line">    <span class="comment">// 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserBuilder <span class="title function_">builder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserBuilder</span> &#123;</span><br><span class="line">        <span class="comment">// 下面是和 User 一模一样的一堆属性</span></span><br><span class="line">        <span class="keyword">private</span> String  name;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line">        <span class="keyword">private</span> String nickName;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">UserBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链式调用设置各个属性值，返回 this，即 UserBuilder</span></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">name</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">password</span><span class="params">(String password)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.password = password;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">nickName</span><span class="params">(String nickName)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">age</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。</span></span><br><span class="line">        <span class="comment">// 当然，可以在 “复制” 之前做点检验</span></span><br><span class="line">        <span class="keyword">public</span> User <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (name == <span class="literal">null</span> || password == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名和密码必填&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (age &lt;= <span class="number">0</span> || age &gt;= <span class="number">150</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;年龄不合法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 还可以做赋予”默认值“的功能</span></span><br><span class="line">          	<span class="keyword">if</span> (nickName == <span class="literal">null</span>) &#123;</span><br><span class="line">                nickName = name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(name, password, nickName, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心是：先把所有的属性都设置给 Builder，然后 build() 方法的时候，将这些属性<strong>复制</strong>给实际产生的对象。</p>
<p>看看客户端的调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">d</span> <span class="operator">=</span> User.builder()</span><br><span class="line">                .name(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;pAss12345&quot;</span>)</span><br><span class="line">                .age(<span class="number">25</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说实话，建造者模式的<strong>链式</strong>写法很吸引人，但是，多写了很多“无用”的 builder 的代码，感觉这个模式没什么用。不过，当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多。我们可以在 <strong>Builder 的构造方法</strong>中强制让调用者提供必填字段，还有，在 build() 方法中校验各个参数比在 User 的构造方法中校验，代码要优雅一些。</p>
<blockquote>
<p>题外话，强烈建议读者使用 lombok，用了 lombok 以后，上面的一大堆代码会变成如下这样:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String  name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>怎么样，省下来的时间是不是又可以干点别的了。</p>
</blockquote>
<p>当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，User 的 getter 方法不变，所有的 setter 方法都让其 <strong>return this</strong> 就可以了，然后就可以像下面这样调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>().setName(<span class="string">&quot;&quot;</span>).setPassword(<span class="string">&quot;&quot;</span>).setAge(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>很多人是这么用的，但是笔者觉得其实这种写法非常地不优雅，不是很推荐使用。</p>
</blockquote>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>这是我要说的创建型模式的最后一个设计模式了。</p>
<p>原型模式很简单：有一个原型<strong>实例</strong>，基于这个原型实例产生新的实例，也就是“克隆”了。</p>
<p>Object 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先<strong>实现 Cloneable 接口</strong>，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出 CloneNotSupportedException 异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。</p>
</blockquote>
<p>原型模式了解到这里我觉得就够了，各种变着法子说这种代码或那种代码是原型模式，没什么意义。</p>
<h3 id="创建型模式总结"><a href="#创建型模式总结" class="headerlink" title="创建型模式总结"></a>创建型模式总结</h3><p>创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是<strong>面向对象</strong>的代码，所以我们第一步当然是需要创建一个对象了。</p>
<p>简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。</p>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>前面创建型模式介绍了创建对象的一些设计模式，这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>第一个要介绍的代理模式是最常使用的模式之一了，用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。</p>
<p>既然说是<strong>代理</strong>，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。</p>
<blockquote>
<p>理解<strong>代理</strong>这个词，这个模式其实就简单了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FoodService</span> &#123;</span><br><span class="line">    Food <span class="title function_">makeChicken</span><span class="params">()</span>;</span><br><span class="line">    Food <span class="title function_">makeNoodle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">FoodService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeChicken</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="type">Food</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chicken</span>()</span><br><span class="line">        f.setChicken(<span class="string">&quot;1kg&quot;</span>);</span><br><span class="line">      	f.setSpicy(<span class="string">&quot;1g&quot;</span>);</span><br><span class="line">      	f.setSalt(<span class="string">&quot;3g&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeNoodle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Food</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Noodle</span>();</span><br><span class="line">        f.setNoodle(<span class="string">&quot;500g&quot;</span>);</span><br><span class="line">        f.setSalt(<span class="string">&quot;5g&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理要表现得“就像是”真实实现类，所以需要实现 FoodService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">FoodService</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 内部一定要有一个真实的实现类，当然也可以通过构造方法注入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">FoodService</span> <span class="variable">foodService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodServiceImpl</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeChicken</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们马上要开始制作鸡肉了&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，</span></span><br><span class="line">        <span class="comment">// 代理只是在核心代码前后做些“无足轻重”的事情</span></span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> foodService.makeChicken();</span><br><span class="line">      </span><br><span class="line">        System.out.println(<span class="string">&quot;鸡肉制作完成啦，加点胡椒粉&quot;</span>); <span class="comment">// 增强</span></span><br><span class="line">      	food.addCondiment(<span class="string">&quot;pepper&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeNoodle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备制作拉面~&quot;</span>);</span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> foodService.makeNoodle();</span><br><span class="line">        System.out.println(<span class="string">&quot;制作完成啦&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用，注意，我们要用代理来实例化接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里用代理类来实例化</span></span><br><span class="line"><span class="type">FoodService</span> <span class="variable">foodService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodServiceProxy</span>();</span><br><span class="line">foodService.makeChicken();</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.javadoop.com/blogimages/design-pattern/proxy-1.png" alt="proxy"></p>
<p>我们发现没有，代理模式说白了就是做 <strong>“方法包装”</strong> 或做 <strong>“方法增强”</strong>。在面向切面编程中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。</p>
<p>说到动态代理，又可以展开说，Spring 中实现动态代理有两种，一种是如果我们的类定义了接口，如 UserService 接口和 UserServiceImpl 实现，那么采用 JDK 的动态代理，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包，性能还不错。</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>说完代理模式，说适配器模式，是因为它们很相似，这里可以做个比较。</p>
<p>适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配。</p>
<p>适配器模式总体来说分三种：默认适配器模式、对象适配器模式、类适配器模式。先不急着分清楚这几个，先看看例子再说。</p>
<h4 id="默认适配器模式"><a href="#默认适配器模式" class="headerlink" title="默认适配器模式"></a>默认适配器模式</h4><p>首先，我们先看看最简单的适配器模式**默认适配器模式(Default Adapter)**是怎么样的。</p>
<p>我们用 Appache commons-io 包中的 FileAlterationListener 做例子，此接口定义了很多的方法，用于对文件或文件夹进行监控，一旦发生了对应的操作，就会触发相应的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FileAlterationListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryCreate</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryChange</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryDelete</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileChange</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此接口的一大问题是抽象方法太多了，如果我们要用这个接口，意味着我们要实现每一个抽象方法，如果我们只是想要监控文件夹中的<strong>文件创建</strong>和<strong>文件删除</strong>事件，可是我们还是不得不实现所有的方法，很明显，这不是我们想要的。</p>
<p>所以，我们需要下面的一个<strong>适配器</strong>，它用于实现上面的接口，但是<strong>所有的方法都是空方法</strong>，这样，我们就可以转而定义自己的类来继承下面这个类即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileAlterationListenerAdaptor</span> <span class="keyword">implements</span> <span class="title class_">FileAlterationListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDirectoryCreate</span><span class="params">(<span class="keyword">final</span> File directory)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDirectoryChange</span><span class="params">(<span class="keyword">final</span> File directory)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDirectoryDelete</span><span class="params">(<span class="keyword">final</span> File directory)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileChange</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们可以定义以下类，我们仅仅需要实现我们想实现的方法就可以了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileMonitor</span> <span class="keyword">extends</span> <span class="title class_">FileAlterationListenerAdaptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">        <span class="comment">// 文件创建</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">        <span class="comment">// 文件删除</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，上面说的只是适配器模式的其中一种，也是最简单的一种，无需多言。下面，再介绍<strong>“正统的”</strong>适配器模式。</p>
<h4 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h4><p>来看一个《Head First 设计模式》中的一个例子，我稍微修改了一下，看看怎么将鸡适配成鸭，这样鸡也能当鸭来用。因为，现在鸭这个接口，我们没有合适的实现类可以用，所以需要适配器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span>; <span class="comment">// 鸭的呱呱叫</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 飞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span>; <span class="comment">// 鸡的咕咕叫</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 飞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WildCock</span> <span class="keyword">implements</span> <span class="title class_">Cock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;咕咕叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸡也会飞哦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>鸭接口有 fly() 和 quare() 两个方法，鸡 Cock 如果要冒充鸭，fly() 方法是现成的，但是鸡不会鸭的呱呱叫，没有 quack() 方法。这个时候就需要适配了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CockAdapter</span> <span class="keyword">implements</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">  </span><br><span class="line">    Cock cock;</span><br><span class="line">    <span class="comment">// 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">CockAdapter</span><span class="params">(Cock cock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cock = cock;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 实现鸭的呱呱叫方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 内部其实是一只鸡的咕咕叫</span></span><br><span class="line">        cock.gobble();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        cock.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用很简单了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 有一只野鸡</span></span><br><span class="line">  	<span class="type">Cock</span> <span class="variable">wildCock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WildCock</span>();</span><br><span class="line">  	<span class="comment">// 成功将野鸡适配成鸭</span></span><br><span class="line">  	<span class="type">Duck</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CockAdapter</span>(wildCock);</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，大家也就知道了适配器模式是怎么回事了。无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的。</p>
<p>我们用一个图来简单说明下：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/adapter-1.png" alt="adapter-1"></p>
<p>上图应该还是很容易理解的，我就不做更多的解释了。下面，我们看看类适配模式怎么样的。</p>
<h4 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h4><p>废话少说，直接上图：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/adapter-2.png" alt="adapter-1"></p>
<p>看到这个图，大家应该很容易理解的吧，通过继承的方法，适配器自动获得了所需要的大部分方法。这个时候，客户端使用更加简单，直接 <code>Target t = new SomeAdapter();</code> 就可以了。</p>
<h4 id="适配器模式总结"><a href="#适配器模式总结" class="headerlink" title="适配器模式总结"></a>适配器模式总结</h4><ol>
<li><p>类适配和对象适配的异同</p>
<blockquote>
<p>一个采用继承，一个采用组合；</p>
<p>类适配属于静态实现，对象适配属于组合的动态实现，对象适配需要多实例化一个对象。</p>
<p>总体来说，对象适配用得比较多。</p>
</blockquote>
</li>
<li><p>适配器模式和代理模式的异同</p>
<p>比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/adapter-5.png" alt="adapter-5"></p>
</li>
</ol>
<h3 id="桥梁模式"><a href="#桥梁模式" class="headerlink" title="桥梁模式"></a>桥梁模式</h3><p>理解桥梁模式，其实就是理解代码抽象和解耦。</p>
<p>我们首先需要一个桥梁，它是一个接口，定义提供的接口方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是一系列实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedPen</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用红色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenPen</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用绿色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BluePen</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用蓝色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个抽象类，此类的实现类都需要使用 DrawAPI：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> DrawAPI drawAPI;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Shape</span><span class="params">(DrawAPI drawAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.drawAPI = drawAPI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义抽象类的子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 圆形</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> radius;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">int</span> radius, DrawAPI drawAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(drawAPI);</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        drawAPI.draw(radius, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 长方形</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, DrawAPI drawAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(drawAPI);</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        drawAPI.draw(<span class="number">0</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们来看客户端演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Shape</span> <span class="variable">greenCircle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">10</span>, <span class="keyword">new</span> <span class="title class_">GreenPen</span>());</span><br><span class="line">    <span class="type">Shape</span> <span class="variable">redRectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">4</span>, <span class="number">8</span>, <span class="keyword">new</span> <span class="title class_">RedPen</span>());</span><br><span class="line">    greenCircle.draw();</span><br><span class="line">    redRectangle.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能大家看上面一步步还不是特别清晰，我把所有的东西整合到一张图上：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/bridge-1.png" alt="bridge-1"></p>
<p>这回大家应该就知道抽象在哪里，怎么解耦了吧。桥梁模式的优点也是显而易见的，就是非常容易进行扩展。</p>
<blockquote>
<p>本节引用了<a href="https://www.tutorialspoint.com/design_pattern/bridge_pattern.htm">这里</a>的例子，并对其进行了修改。</p>
</blockquote>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>要把装饰模式说清楚明白，不是件容易的事情。也许读者知道 <strong>Java IO</strong> 中的几个类是典型的装饰模式的应用，但是读者不一定清楚其中的关系，也许看完就忘了，希望看完这节后，读者可以对其有更深的感悟。</p>
<p>首先，我们先看一个简单的图，看这个图的时候，了解下层次结构就可以了：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/decorator-1.png" alt="decorator-1"></p>
<p>我们来说说装饰模式的出发点，从图中可以看到，接口 <code>Component</code> 其实已经有了 <code>ConcreteComponentA</code> 和 <code>ConcreteComponentB</code> 两个实现类了，但是，如果我们要<strong>增强</strong>这两个实现类的话，我们就可以采用装饰模式，用具体的装饰器来<strong>装饰</strong>实现类，以达到增强的目的。</p>
<blockquote>
<p>从名字来简单解释下装饰器。既然说是装饰，那么往往就是<strong>添加小功能</strong>这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的多层包装方式，但是那样的话代码就复杂了。</p>
</blockquote>
<p>首先明白一些简单的概念，从图中我们看到，所有的具体装饰者们 <strong>ConcreteDecorator</strong>* 都可以作为 Component 来使用，因为它们都实现了 Component 中的所有接口。它们和 Component 实现类 ConcreteComponent* 的区别是，它们只是装饰者，起<strong>装饰</strong>作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中<strong>加了层皮来装饰</strong>而已。</p>
<blockquote>
<p>注意这段话中混杂在各个名词中的 Component 和 Decorator，别搞混了。</p>
</blockquote>
<p>下面来看看一个例子，先把装饰模式弄清楚，然后再介绍下 java io 中的装饰模式的应用。</p>
<p>最近大街上流行起来了“快乐柠檬”，我们把快乐柠檬的饮料分为三类：红茶、绿茶、咖啡，在这三大类的基础上，又增加了许多的口味，什么金桔柠檬红茶、金桔柠檬珍珠绿茶、芒果红茶、芒果绿茶、芒果珍珠红茶、烤珍珠红茶、烤珍珠芒果绿茶、椰香胚芽咖啡、焦糖可可咖啡等等，每家店都有很长的菜单，但是仔细看下，其实原料也没几样，但是可以搭配出很多组合，如果顾客需要，很多没出现在菜单中的饮料他们也是可以做的。</p>
<p>在这个例子中，红茶、绿茶、咖啡是最基础的饮料，其他的像金桔柠檬、芒果、珍珠、椰果、焦糖等都属于装饰用的。当然，在开发中，我们确实可以像门店一样，开发这些类：LemonBlackTea、LemonGreenTea、MangoBlackTea、MangoLemonGreenTea……但是，很快我们就发现，这样子干肯定是不行的，这会导致我们需要组合出所有的可能，而且如果客人需要在红茶中加双份柠檬怎么办？三份柠檬怎么办？</p>
<p>不说废话了，上代码。</p>
<p>首先，定义饮料抽象基类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">  	<span class="comment">// 返回描述</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">  	<span class="comment">// 返回价格</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是三个基础饮料实现类，红茶、绿茶和咖啡：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlackTea</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">  	<span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;红茶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenTea</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;绿茶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...<span class="comment">// 咖啡省略</span></span><br></pre></td></tr></table></figure>

<p>定义调料，也就是装饰者的基类，此类必须继承自 Beverage：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Condiment</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们来定义柠檬、芒果等具体的调料，它们属于装饰者，毫无疑问，这些调料肯定都需要继承调料 Condiment 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lemon</span> <span class="keyword">extends</span> <span class="title class_">Condiment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Beverage bevarage;</span><br><span class="line">    <span class="comment">// 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶，</span></span><br><span class="line">    <span class="comment">// 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Lemon</span><span class="params">(Beverage bevarage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bevarage = bevarage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 装饰</span></span><br><span class="line">        <span class="keyword">return</span> bevarage.getDescription() + <span class="string">&quot;, 加柠檬&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 装饰</span></span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">2</span>; <span class="comment">// 加柠檬需要 2 元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mango</span> <span class="keyword">extends</span> <span class="title class_">Condiment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Beverage bevarage;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mango</span><span class="params">(Beverage bevarage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bevarage = bevarage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bevarage.getDescription() + <span class="string">&quot;, 加芒果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">3</span>; <span class="comment">// 加芒果需要 3 元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...<span class="comment">// 给每一种调料都加一个类</span></span><br></pre></td></tr></table></figure>

<p>看客户端调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先，我们需要一个基础饮料，红茶、绿茶或咖啡</span></span><br><span class="line">    <span class="type">Beverage</span> <span class="variable">beverage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GreenTea</span>();</span><br><span class="line">    <span class="comment">// 开始装饰</span></span><br><span class="line">    beverage = <span class="keyword">new</span> <span class="title class_">Lemon</span>(beverage); <span class="comment">// 先加一份柠檬</span></span><br><span class="line">    beverage = <span class="keyword">new</span> <span class="title class_">Mongo</span>(beverage); <span class="comment">// 再加一份芒果</span></span><br><span class="line"></span><br><span class="line">    System.out.println(beverage.getDescription() + <span class="string">&quot; 价格：￥&quot;</span> + beverage.cost());</span><br><span class="line">    <span class="comment">//&quot;绿茶, 加柠檬, 加芒果 价格：￥16&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们需要 <strong>芒果-珍珠-双份柠檬-红茶</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Beverage</span> <span class="variable">beverage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mongo</span>(<span class="keyword">new</span> <span class="title class_">Pearl</span>(<span class="keyword">new</span> <span class="title class_">Lemon</span>(<span class="keyword">new</span> <span class="title class_">Lemon</span>(<span class="keyword">new</span> <span class="title class_">BlackTea</span>()))));</span><br></pre></td></tr></table></figure>

<p>是不是很变态？</p>
<p>看看下图可能会清晰一些：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/decorator-2.png" alt="decorator-2"></p>
<p>到这里，大家应该已经清楚装饰模式了吧。</p>
<p>下面，我们再来说说 java IO 中的装饰模式。看下图 InputStream 派生出来的部分类：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/decorator-3.png" alt="decorator-3"></p>
<p>我们知道 InputStream 代表了输入流，具体的输入来源可以是文件（FileInputStream）、管道（PipedInputStream）、数组（ByteArrayInputStream）等，这些就像前面奶茶的例子中的红茶、绿茶，属于基础输入流。</p>
<p>FilterInputStream 承接了装饰模式的关键节点，它的实现类是一系列装饰器，比如 BufferedInputStream 代表用缓冲来装饰，也就使得输入流具有了缓冲的功能，LineNumberInputStream 代表用行号来装饰，在操作的时候就可以取得行号了，DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的基本类型值。</p>
<p>当然，在 java IO 中，如果我们使用装饰器的话，就不太适合面向接口编程了，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LineNumberInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>这样的结果是，InputStream 还是不具有读取行号的功能，因为读取行号的方法定义在 LineNumberInputStream 类中。</p>
<p>我们应该像下面这样使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DataInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(</span><br><span class="line">  							<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">                              	<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;&quot;</span>)));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的。</p>
</blockquote>
<h3 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h3><p>门面模式（也叫外观模式，Facade Pattern）在许多源码中有使用，比如 slf4j 就可以理解为是门面模式的应用。这是一个简单的设计模式，我们直接上代码再说吧。</p>
<p>首先，我们定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义几个实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Circle::draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Rectangle::draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 画一个圆形</span></span><br><span class="line">  	<span class="type">Shape</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">  	circle.draw();</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 画一个长方形</span></span><br><span class="line">  	<span class="type">Shape</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">  	rectangle.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是我们常写的代码，我们需要画圆就要先实例化圆，画长方形就需要先实例化一个长方形，然后再调用相应的 draw() 方法。</p>
<p>下面，我们看看怎么用门面模式来让客户端调用更加友好一些。</p>
<p>我们先定义一个门面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeMaker</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Shape circle;</span><br><span class="line">   <span class="keyword">private</span> Shape rectangle;</span><br><span class="line">   <span class="keyword">private</span> Shape square;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ShapeMaker</span><span class="params">()</span> &#123;</span><br><span class="line">      circle = <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">      rectangle = <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">      square = <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">()</span>&#123;</span><br><span class="line">      circle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">()</span>&#123;</span><br><span class="line">      rectangle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawSquare</span><span class="params">()</span>&#123;</span><br><span class="line">      square.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看现在客户端怎么调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">ShapeMaker</span> <span class="variable">shapeMaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeMaker</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 客户端调用现在更加清晰了</span></span><br><span class="line">  shapeMaker.drawCircle();</span><br><span class="line">  shapeMaker.drawRectangle();</span><br><span class="line">  shapeMaker.drawSquare();		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>门面模式的优点显而易见，客户端不再需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。</p>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。</p>
<p>直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，同时还有下属员工集合（虽然可能集合为空），而下属员工和自己的结构是一样的，也有姓名、部门这些属性，同时也有他们的下属员工集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String dept;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> salary;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Employee&gt; subordinates; <span class="comment">// 下属</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name,String dept, <span class="type">int</span> sal)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.dept = dept;</span><br><span class="line">      <span class="built_in">this</span>.salary = sal;</span><br><span class="line">      subordinates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Employee e)</span> &#123;</span><br><span class="line">      subordinates.add(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Employee e)</span> &#123;</span><br><span class="line">      subordinates.remove(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getSubordinates</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> subordinates;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="string">&quot;Employee :[ Name : &quot;</span> + name + <span class="string">&quot;, dept : &quot;</span> + dept + <span class="string">&quot;, salary :&quot;</span> + salary+<span class="string">&quot; ]&quot;</span>);</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常，这种类需要定义 add(node)、remove(node)、getChildren() 这些方法。</p>
<p>这说的其实就是组合模式，这种简单的模式我就不做过多介绍了，相信各位读者也不喜欢看我写废话。</p>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>英文是 Flyweight Pattern，不知道是谁最先翻译的这个词，感觉这翻译真的不好理解，我们试着强行关联起来吧。Flyweight 是轻量级的意思，享元分开来说就是 共享 元器件，也就是复用已经生成的对象，这种做法当然也就是轻量级的了。</p>
<p>复用对象最简单的方式是，用一个 HashMap 来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中。</p>
<p>这种简单的代码我就不演示了。</p>
<h3 id="结构型模式总结"><a href="#结构型模式总结" class="headerlink" title="结构型模式总结"></a>结构型模式总结</h3><p>前面，我们说了代理模式、适配器模式、桥梁模式、装饰模式、门面模式、组合模式和享元模式。读者是否可以分别把这几个模式说清楚了呢？在说到这些模式的时候，心中是否有一个清晰的图或处理流程在脑海里呢？</p>
<p>代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。</p>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式太常用了，所以把它放到最前面进行介绍。它比较简单，我就不废话，直接用代码说事吧。</p>
<p>下面设计的场景是，我们需要画一个图形，可选的策略就是用红色笔来画，还是绿色笔来画，或者蓝色笔来画。</p>
<p>首先，先定义一个策略接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们定义具体的几个策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedPen</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;用红色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenPen</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;用绿色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BluePen</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;用蓝色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用策略的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">executeDraw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> strategy.draw(radius, x, y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">BluePen</span>()); <span class="comment">// 使用绿色笔来画</span></span><br><span class="line">  	context.executeDraw(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>放到一张图上，让大家看得清晰些：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/strategy-1.png" alt="strategy-1"></p>
<p>这个时候，大家有没有联想到结构型模式中的桥梁模式，它们其实非常相似，我把桥梁模式的图拿过来大家对比下：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/bridge-1.png" alt="bridge-1"></p>
<p>要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。桥梁模式的耦合更低，结构更复杂一些。</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，观察者订阅自己关心的主题和主题有数据变化后通知观察者们。</p>
<p>首先，需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">        <span class="comment">// 数据已变更，通知观察者们</span></span><br><span class="line">        notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知观察者们</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyAllObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义观察者接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Subject subject;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。</p>
<p>我们来定义具体的几个观察者类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryObserver</span> <span class="keyword">extends</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">// 在构造方法中进行订阅主题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryObserver</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">        <span class="comment">// 通常在构造方法中将 this 发布出去的操作一定要小心</span></span><br><span class="line">        <span class="built_in">this</span>.subject.attach(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该方法由主题类在数据变更的时候进行调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> Integer.toBinaryString(subject.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;订阅的数据发生变化，新的数据处理为二进制值为：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HexaObserver</span> <span class="keyword">extends</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HexaObserver</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">        <span class="built_in">this</span>.subject.attach(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> Integer.toHexString(subject.getState()).toUpperCase();</span><br><span class="line">        System.out.println(<span class="string">&quot;订阅的数据发生变化，新的数据处理为十六进制值为：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端使用也非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 先定义一个主题</span></span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line">    <span class="comment">// 定义观察者</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BinaryObserver</span>(subject1);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HexaObserver</span>(subject1);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 模拟数据变更，这个时候，观察者们的 update 方法将会被调用</span></span><br><span class="line">    subject.setState(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">订阅的数据发生变化，新的数据处理为二进制值为：1011</span><br><span class="line">订阅的数据发生变化，新的数据处理为十六进制值为：B</span><br></pre></td></tr></table></figure>

<p>当然，jdk 也提供了相似的支持，具体的大家可以参考 java.util.Observable 和 java.util.Observer 这两个类。</p>
<p>实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。</p>
<p>还有，即使是上面的这个代码，也会有很多变种，大家只要记住核心的部分，那就是一定有一个地方存放了所有的观察者，然后在事件发生的时候，遍历观察者，调用它们的回调函数。</p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了。</p>
<p>有这么一个场景，用户参加一个活动可以领取奖品，但是活动需要进行很多的规则校验然后才能放行，比如首先需要校验用户是否是新用户、今日参与人数是否有限额、全场参与人数是否有限额等等。设定的规则都通过后，才能让用户领走奖品。</p>
<blockquote>
<p>如果产品给你这个需求的话，我想大部分人一开始肯定想的就是，用一个 List 来存放所有的规则，然后 foreach 执行一下每个规则就好了。不过，读者也先别急，看看责任链模式和我们说的这个有什么不一样？</p>
</blockquote>
<p>首先，我们要定义流程上节点的基类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">protected</span> RuleHandler successor;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(RuleHandler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> RuleHandler <span class="title function_">getSuccessor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们需要定义具体的每个节点了。</p>
<p>校验用户是否是新用户：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewUserRuleHandler</span> <span class="keyword">extends</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.isNewUser()) &#123;</span><br><span class="line">            <span class="comment">// 如果有后继节点的话，传递下去</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该活动仅限新用户参与&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>校验用户所在地区是否可以参与：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocationRuleHandler</span> <span class="keyword">extends</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allowed</span> <span class="operator">=</span> activityService.isSupportedLocation(context.getLocation);</span><br><span class="line">        <span class="keyword">if</span> (allowed) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;非常抱歉，您所在的地区无法参与本次活动&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>校验奖品是否已领完：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LimitRuleHandler</span> <span class="keyword">extends</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">remainedTimes</span> <span class="operator">=</span> activityService.queryRemainedTimes(context); <span class="comment">// 查询剩余奖品</span></span><br><span class="line">        <span class="keyword">if</span> (remainedTimes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.getSuccessor().apply(userInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;您来得太晚了，奖品被领完了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">RuleHandler</span> <span class="variable">newUserHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewUserRuleHandler</span>();</span><br><span class="line">    <span class="type">RuleHandler</span> <span class="variable">locationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocationRuleHandler</span>();</span><br><span class="line">    <span class="type">RuleHandler</span> <span class="variable">limitHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LimitRuleHandler</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 假设本次活动仅校验地区和奖品数量，不校验新老用户</span></span><br><span class="line">    locationHandler.setSuccessor(limitHandler);</span><br><span class="line">  </span><br><span class="line">    locationHandler.apply(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码其实很简单，就是先定义好一个链表，然后在通过任意一节点后，如果此节点有后继节点，那么传递下去。</p>
<p>至于它和我们前面说的用一个 List 存放需要执行的规则的做法有什么异同，留给读者自己琢磨吧。</p>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>在含有继承结构的代码中，模板方法模式是非常常用的。</p>
<p>通常会有一个抽象类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractTemplate</span> &#123;</span><br><span class="line">    <span class="comment">// 这就是模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        init();</span><br><span class="line">        apply(); <span class="comment">// 这个是重点</span></span><br><span class="line">        end(); <span class="comment">// 可以作为钩子方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init 抽象层已经实现，子类也可以选择覆写&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 留给子类实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。</p>
<p>我们写一个实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteTemplate</span> <span class="keyword">extends</span> <span class="title class_">AbstractTemplate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类实现抽象方法 apply&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AbstractTemplate</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteTemplate</span>();</span><br><span class="line">    <span class="comment">// 调用模板方法</span></span><br><span class="line">    t.templateMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码其实很简单，基本上看到就懂了，关键是要学会用到自己的代码中。</p>
<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>update: 2017-10-19</p>
<p>废话我就不说了，我们说一个简单的例子。商品库存中心有个最基本的需求是减库存和补库存，我们看看怎么用状态模式来写。</p>
<p>核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。</p>
<p>定义状态接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">(Context context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义减库存的状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeductState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;商品卖出，准备减库存&quot;</span>);</span><br><span class="line">        context.setState(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 执行减库存的具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Deduct State&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>定义补库存状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RevertState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;给此商品补库存&quot;</span>);</span><br><span class="line">        context.setState(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 执行加库存的具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Revert State&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面用到了 context.setState(this)，我们来看看怎么定义 Context 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">  	<span class="keyword">private</span> String name;</span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看下客户端调用，大家就一清二楚了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 我们需要操作的是 iPhone X</span></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="string">&quot;iPhone X&quot;</span>);</span><br><span class="line">  	</span><br><span class="line">    <span class="comment">// 看看怎么进行补库存操作</span></span><br><span class="line">  	<span class="type">State</span> <span class="variable">revertState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RevertState</span>();</span><br><span class="line">  	revertState.doAction(context);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 同样的，减库存操作也非常简单</span></span><br><span class="line">  	<span class="type">State</span> <span class="variable">deductState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeductState</span>();</span><br><span class="line">  	deductState.doAction(context);</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 如果需要我们可以获取当前的状态</span></span><br><span class="line">    <span class="comment">// context.getState().toString();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读者可能会发现，在上面这个例子中，如果我们不关心当前 context 处于什么状态，那么 Context 就可以不用维护 state 属性了，那样代码会简单很多。</p>
<p>不过，商品库存这个例子毕竟只是个例，我们还有很多实例是需要知道当前 context 处于什么状态的。</p>
<h3 id="行为型模式总结"><a href="#行为型模式总结" class="headerlink" title="行为型模式总结"></a>行为型模式总结</h3><p>行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 学习设计模式的目的是为了让我们的代码更加的优雅、易维护、易扩展。这次整理这篇文章，让我重新审视了一下各个设计模式，对我自己而言收获还是挺大的。我想，文章的最大收益者一般都是作者本人，为了写一篇文章，需要巩固自己的知识，需要寻找各种资料，而且，自己写过的才最容易记住，也算是我给读者的建议吧。</p>
<p>（全文完）</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>点评项目优化</title>
    <url>/2024/10/20/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="hmdp-optimization"><a href="#hmdp-optimization" class="headerlink" title="hmdp-optimization"></a>hmdp-optimization</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><mark>STRING<mark> </p>
<ul>
<li><code>sign:&#123;userId&#125;:202411</code> 2024年11月的userId的签到信息 （bitmap）</li>
<li><code>incr:order:2024:11:10</code> 2024年11月10号的订单序列号serialNumber，唯一id（timestamp&lt;&lt;32 | serialNumber）</li>
<li><code>seckill:stock:&#123;voucherId&#125;</code> voucherId的优惠券对应的库存</li>
<li><code>cache:shop:&#123;shopId&#125;</code> shopId的商铺信息</li>
<li><code>login:code:&#123;phoneNumber&#125;</code> 验证码信息</li>
</ul>
<p><mark>LIST<mark> </p>
<ul>
<li><code>cache:shoptype</code>（商铺类型信息JSON数组）</li>
</ul>
<p><mark>ZSET<mark> </p>
<ul>
<li><p><code>shop:geo:&#123;shopId&#125;</code> 商铺地理位置信息</p>
</li>
<li><p><code>blog:liked:&#123;blogId&#125;</code> blogId的博客点赞信息，包括userId 以及对应的score（unix时间）</p>
</li>
<li><p><code>feed:&#123;userId&#125;</code> userId 的收件箱，保存笔记时推送到所有粉丝（看看谁follow了我）包括了 blogId 以及对应的score </p>
</li>
</ul>
<p><mark>SET<mark> </p>
<ul>
<li><code>follows:&#123;userId&#125;</code> userId 关注的人</li>
<li><code>seckill:order:&#123;voucherId&#125;</code> 抢过voucherId的优惠券的人的集合</li>
</ul>
<p><mark>HASH<mark> </p>
<ul>
<li><code>login:token:&#123;token&#125;</code> 存储token对应的userDTO </li>
</ul>
<h2 id="feed-滚动"><a href="#feed-滚动" class="headerlink" title="feed 滚动"></a>feed 滚动</h2><p>10-6 5-1 一共是两页，传统分页在feed流是不适用的，因为我们的数据会随时发生变化，</p>
<p>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</p>
<h2 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h2><p>blog blog评论 关注的人(x在t时间关注了y) 用户表 </p>
<p>商铺 商铺类别</p>
<p>券 秒杀券 秒杀券订单</p>
<h2 id="热key-大key"><a href="#热key-大key" class="headerlink" title="热key 大key"></a>热key 大key</h2><p>在处理热key、大key以及分表问题时，可以采用以下策略进行优化：</p>
<hr>
<h3 id="一、热Key处理方案"><a href="#一、热Key处理方案" class="headerlink" title="一、热Key处理方案"></a><strong>一、热Key处理方案</strong></h3><ol>
<li><p><strong>监控与识别</strong><br>• 使用Redis监控工具（如<code>redis-cli --hotkeys</code>、<code>MONITOR</code>命令）或APM系统（如Prometheus）识别高频访问的key。<br>• 业务侧预判热点（如秒杀商品ID、热门话题），提前介入优化。</p>
</li>
<li><p><strong>多级缓存</strong><br>• <strong>本地缓存</strong>：结合Guava Cache或Caffeine，将热key缓存在应用服务器本地，减少Redis压力。<br>• <strong>分布式缓存冗余</strong>：复制热key到多个Redis实例（如<code>key:1</code>, <code>key:2</code>），通过随机访问分散压力。</p>
</li>
<li><p><strong>缓存续期与互斥锁</strong><br>• <strong>逻辑过期</strong>：Value中存储过期时间，异步更新缓存，避免物理过期后大量请求穿透到DB。<br>• <strong>互斥锁（Mutex Lock）</strong>：缓存失效时，仅允许一个线程重建数据，其他线程等待或返回降级结果。</p>
</li>
<li><p><strong>读写分离与分片</strong><br>• 使用Redis Cluster或Codis分片，分散热key压力。<br>• 读写分离：通过从节点处理读请求，主节点处理写请求。</p>
</li>
</ol>
<hr>
<h3 id="二、大Key处理方案"><a href="#二、大Key处理方案" class="headerlink" title="二、大Key处理方案"></a><strong>二、大Key处理方案</strong></h3><ol>
<li><p><strong>拆分与分片</strong><br>• <strong>横向拆分</strong>：将大Hash/List按字段或元素拆分（如<code>user:1000:info</code>拆为<code>user:1000:base</code>、<code>user:1000:contact</code>）。<br>• <strong>分片存储</strong>：对Key添加分片后缀（如<code>user:&#123;id%10&#125;:profile</code>），分散存储。</p>
</li>
<li><p><strong>异步删除</strong><br>• 使用<code>UNLINK</code>替代<code>DEL</code>，非阻塞删除大Key。<br>• 渐进式删除：通过脚本分批删除Hash/Set元素（如<code>HSCAN</code>遍历删除）。</p>
</li>
<li><p><strong>压缩与存储优化</strong><br>• 序列化优化：使用Protobuf或MessagePack替代JSON。<br>• 冷热分离：将大Key中低频数据存入MySQL/HBase，高频数据保留在Redis。</p>
</li>
<li><p><strong>设计规避</strong><br>• 避免单个Key存储超过1MB的数据。<br>• 使用HyperLogLog替代大Set统计UV，或使用TimeSeries存储时序数据。</p>
</li>
</ol>
<hr>
<h3 id="三、分表方案（以MySQL为例）"><a href="#三、分表方案（以MySQL为例）" class="headerlink" title="三、分表方案（以MySQL为例）"></a><strong>三、分表方案（以MySQL为例）</strong></h3><ol>
<li><p><strong>水平分表</strong><br>• <strong>规则分片</strong>：按哈希（如<code>user_id % 100</code>）、范围（如时间戳）或一致性哈希拆分数据。<br>• <strong>中间件</strong>：使用ShardingSphere、Vitess等工具自动路由查询。</p>
</li>
<li><p><strong>垂直分表</strong><br>• 将大表按列拆分（如用户基础信息表<code>user_base</code>与扩展信息表<code>user_extend</code>），减少单行数据量。</p>
</li>
<li><p><strong>全局ID与查询优化</strong><br>• 分布式ID生成（雪花算法、Redis自增ID）避免主键冲突。<br>• 冗余字段或索引表：通过异步维护冗余字段（如商户ID+订单ID）支持多维度查询。</p>
</li>
<li><p><strong>结合Redis</strong><br>• 缓存分表路由信息（如<code>user_shard:1000 -&gt; shard_2</code>），加速查询。<br>• 热数据缓存：将分表后的热数据单独缓存，降低DB压力。</p>
</li>
</ol>
<hr>
<h3 id="四、Redis分片与集群"><a href="#四、Redis分片与集群" class="headerlink" title="四、Redis分片与集群"></a><strong>四、Redis分片与集群</strong></h3><ol>
<li><p><strong>Redis Cluster</strong><br>• 自动分片（16384 slots），支持水平扩展和高可用。<br>• 通过<code>CRC16(key) % 16384</code>计算slot，分散数据。</p>
</li>
<li><p><strong>客户端分片</strong><br>• 使用一致性哈希算法（如Jedis的<code>ShardedJedis</code>）在客户端路由请求。</p>
</li>
<li><p><strong>Proxy方案</strong><br>• 通过Twemproxy或Codis代理层管理分片，对业务透明。</p>
</li>
</ol>
<hr>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a><strong>五、总结</strong></h3><p>• <strong>热Key</strong>：多级缓存 + 分片 + 异步更新。<br>• <strong>大Key</strong>：拆分 + 异步删除 + 设计规避。<br>• <strong>分表</strong>：合理分片规则 + 中间件 + 缓存加速。<br>• <strong>监控</strong>：实时监控Key大小和QPS，提前预防问题。</p>
<p>通过组合以上策略，可显著提升系统性能和稳定性，应对高并发与大数据的挑战。</p>
<h2 id="延迟双删"><a href="#延迟双删" class="headerlink" title="延迟双删"></a>延迟双删</h2><p>通过重试、过期时间、补偿机制保证最终一致性，避免因删除失败导致脏数据长期存在。</p>
<p>延迟双删是解决缓存与数据库一致性的策略，步骤如下：</p>
<ol>
<li>删除缓存。</li>
<li>更新数据库。</li>
<li>延迟一段时间（如等主从同步完成）。</li>
<li>再次删除缓存。</li>
</ol>
<p><strong>若第二次删除失败</strong>：</p>
<ul>
<li><strong>重试机制</strong>：将删除操作加入重试队列（如消息队列），确保最终成功。</li>
<li><strong>设置缓存过期时间</strong>：即使删除失败，缓存也会自动失效，减少不一致的时间窗口。</li>
<li><strong>异步补偿</strong>：通过定时任务检查并清理残留脏数据。</li>
</ul>
<h2 id="缓存：旁路缓存"><a href="#缓存：旁路缓存" class="headerlink" title="缓存：旁路缓存"></a>缓存：旁路缓存</h2><p>Cache Aside Pattern（旁路缓存机制）是一种广泛应用于高并发系统的缓存设计模式，其核心目标是<strong>解决缓存与数据库之间的数据一致性问题</strong>，同时提升系统的读取性能。以下是该模式的具体解决场景、实现原理及实际应用分析：</p>
<hr>
<h3 id="解决的问题场景"><a href="#解决的问题场景" class="headerlink" title="解决的问题场景"></a><strong>解决的问题场景</strong></h3><h4 id="读多写少的高并发场景"><a href="#读多写少的高并发场景" class="headerlink" title="读多写少的高并发场景"></a><strong>读多写少的高并发场景</strong></h4><p>• <strong>典型场景</strong>：用户信息查询、商品详情页、新闻内容页等。<br>• <strong>痛点</strong>：直接读取数据库会导致性能瓶颈，缓存能显著降低数据库压力，但需保证缓存与数据库的一致性。</p>
<h4 id="数据更新后的缓存一致性"><a href="#数据更新后的缓存一致性" class="headerlink" title="数据更新后的缓存一致性"></a><strong>数据更新后的缓存一致性</strong></h4><p>• <strong>痛点</strong>：数据更新时，若缓存与数据库的更新顺序或策略不当，可能引发脏读、旧数据残留等问题。</p>
<h4 id="缓存穿透与雪崩的规避"><a href="#缓存穿透与雪崩的规避" class="headerlink" title="缓存穿透与雪崩的规避"></a><strong>缓存穿透与雪崩的规避</strong></h4><p>• <strong>痛点</strong>：恶意请求或缓存失效时，大量请求穿透到数据库，导致数据库过载甚至宕机。</p>
<hr>
<h3 id="Cache-Aside-Pattern-的实现原理"><a href="#Cache-Aside-Pattern-的实现原理" class="headerlink" title="Cache Aside Pattern 的实现原理"></a><strong>Cache Aside Pattern 的实现原理</strong></h3><h4 id="读流程（优先读缓存）"><a href="#读流程（优先读缓存）" class="headerlink" title="读流程（优先读缓存）"></a><strong>读流程（优先读缓存）</strong></h4><p>• <strong>步骤</strong>：  </p>
<pre><code>1. 客户端读取数据时，先查询缓存。  
2. 若缓存命中（Cache Hit），直接返回结果。  
3. 若缓存未命中（Cache Miss），查询数据库，将结果写入缓存后返回。  
   • **代码示例**：  
</code></pre>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Data <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 先查缓存</span></span><br><span class="line">    <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 缓存未命中，查数据库</span></span><br><span class="line">    data = database.read(key);</span><br><span class="line">    <span class="comment">// 3. 回填缓存</span></span><br><span class="line">    cache.set(key, data, TTL);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写流程（更新数据库后失效缓存）"><a href="#写流程（更新数据库后失效缓存）" class="headerlink" title="写流程（更新数据库后失效缓存）"></a><strong>写流程（更新数据库后失效缓存）</strong></h4><p>• <strong>步骤</strong>：  </p>
<pre><code>1. 客户端更新数据时，先更新数据库。  
2. 删除缓存（而非更新缓存），确保下次读取时触发缓存回填。  
   • **代码示例**：  
</code></pre>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(String key, Data newData)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 更新数据库</span></span><br><span class="line">    database.update(key, newData);</span><br><span class="line">    <span class="comment">// 2. 删除缓存</span></span><br><span class="line">    cache.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="核心解决的问题"><a href="#核心解决的问题" class="headerlink" title="核心解决的问题"></a><strong>核心解决的问题</strong></h3><h4 id="缓存与数据库的一致性"><a href="#缓存与数据库的一致性" class="headerlink" title="缓存与数据库的一致性"></a><strong>缓存与数据库的一致性</strong></h4><p>• <strong>旧数据问题</strong>：直接更新缓存可能导致并发场景下出现脏数据（如两个并发写操作顺序错乱）。<br>• <strong>解决方案</strong>：通过“更新数据库 + 删除缓存”的组合，确保下一次读请求回填最新数据。</p>
<h4 id="降低并发写冲突"><a href="#降低并发写冲突" class="headerlink" title="降低并发写冲突"></a><strong>降低并发写冲突</strong></h4><p>• <strong>场景示例</strong>：若先删除缓存再更新数据库，可能因网络延迟导致其他线程读到旧数据并回填缓存。<br>• <strong>优化策略</strong>：采用 <strong>延迟双删</strong>（先删缓存→更新数据库→再删缓存），但需权衡复杂度。</p>
<h4 id="规避缓存穿透与雪崩"><a href="#规避缓存穿透与雪崩" class="headerlink" title="规避缓存穿透与雪崩"></a><strong>规避缓存穿透与雪崩</strong></h4><p>• <strong>缓存穿透</strong>：恶意查询不存在的数据（如不存在的用户ID）。<br>  • <strong>解决方案</strong>：缓存空值（Null Object）并设置较短TTL。<br>• <strong>缓存雪崩</strong>：大量缓存同时失效导致数据库被击穿。<br>  • <strong>解决方案</strong>：设置随机化过期时间（如基础TTL + 随机偏移量）。</p>
<hr>
<h3 id="实际应用案例"><a href="#实际应用案例" class="headerlink" title="实际应用案例"></a><strong>实际应用案例</strong></h3><h4 id="案例1：电商商品库存更新"><a href="#案例1：电商商品库存更新" class="headerlink" title="案例1：电商商品库存更新"></a><strong>案例1：电商商品库存更新</strong></h4><p>• <strong>场景</strong>：用户下单后扣减库存。<br>• <strong>流程</strong>：  </p>
<pre><code>1. 更新数据库库存（原子操作：`UPDATE stock SET count=count-1 WHERE product_id=xxx AND count&gt;0`）。  
2. 删除商品库存缓存（`cache.delete(&quot;product_stock_xxx&quot;)`）。  
3. 后续查询库存时触发缓存回填，读取最新值。
</code></pre>
<h4 id="案例2：用户信息更新"><a href="#案例2：用户信息更新" class="headerlink" title="案例2：用户信息更新"></a><strong>案例2：用户信息更新</strong></h4><p>• <strong>场景</strong>：用户修改昵称后，前端需要展示最新数据。<br>• <strong>流程</strong>：  </p>
<pre><code>1. 更新数据库用户表。  
2. 删除用户信息缓存（如 `cache.delete(&quot;user_info_123&quot;)`）。  
3. 下次读取时从数据库加载新数据并回填缓存。
</code></pre>
<hr>
<h3 id="与其他缓存模式的对比"><a href="#与其他缓存模式的对比" class="headerlink" title="与其他缓存模式的对比"></a><strong>与其他缓存模式的对比</strong></h3><table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>特点</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Cache Aside</strong></td>
<td>应用层控制缓存逻辑，更新数据库后删除缓存，简单但需处理并发问题。</td>
<td>读多写少，一致性要求较高</td>
</tr>
<tr>
<td><strong>Read/Write Through</strong></td>
<td>缓存层代理数据库操作，应用无需感知缓存逻辑（如Redis Module）。</td>
<td>缓存与数据库强绑定，逻辑简单化</td>
</tr>
<tr>
<td><strong>Write Behind</strong></td>
<td>异步批量更新数据库，缓存作为写入缓冲区，吞吐量高但存在数据丢失风险。</td>
<td>写密集且允许短暂数据不一致（如日志）</td>
</tr>
</tbody></table>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p><strong>并发场景下的极端问题</strong>：<br>• <strong>问题</strong>：A线程读缓存未命中→查询旧数据库数据→B线程更新数据库并删缓存→A线程回填旧数据到缓存。<br>• <strong>解决方案</strong>：加分布式锁（如Redisson）或设置缓存更新版本号。  </p>
</li>
<li><p><strong>缓存删除失败的重试机制</strong>：<br>• <strong>方案</strong>：引入消息队列（如Kafka）异步重试删除缓存。  </p>
</li>
<li><p><strong>冷启动预热</strong>：<br>• <strong>方案</strong>：系统启动时加载热点数据到缓存（如Top 100商品）。</p>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>Cache Aside Pattern 通过<strong>优先读缓存、更新数据库后失效缓存</strong>的策略，解决了高并发下缓存与数据库的一致性问题，适用于读多写少且对一致性要求较高的场景。实际应用中需结合业务特点，处理并发冲突、缓存穿透/雪崩等问题，必要时引入异步重试、分布式锁等机制。</p>
<h2 id="缓存更新失败怎么办？重试机制"><a href="#缓存更新失败怎么办？重试机制" class="headerlink" title="缓存更新失败怎么办？重试机制"></a>缓存更新失败怎么办？重试机制</h2><p>在 Cache Aside Pattern 中，若 <strong>更新数据库后删除缓存的操作失败</strong>，会导致缓存中残留旧数据，后续读请求可能返回不一致的结果。以下是分层解决方案，涵盖 <strong>容错设计、补偿机制和业务兜底策略</strong>：</p>
<hr>
<h3 id="容错设计：同步重试"><a href="#容错设计：同步重试" class="headerlink" title="容错设计：同步重试"></a><strong>容错设计：同步重试</strong></h3><h4 id="本地重试（立即重试）"><a href="#本地重试（立即重试）" class="headerlink" title="本地重试（立即重试）"></a><strong>本地重试（立即重试）</strong></h4><p>• <strong>场景</strong>：因网络抖动或瞬时故障导致删除缓存失败。<br>• <strong>实现</strong>：在业务代码中增加同步重试逻辑（如最多 3 次）。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(String key, Data newData)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 更新数据库</span></span><br><span class="line">    database.update(key, newData);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 删除缓存，最多重试3次</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">retryCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (retryCount &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cache.delete(key);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            retryCount++;</span><br><span class="line">            <span class="keyword">if</span> (retryCount &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;删除缓存失败，key=&#123;&#125;&quot;</span>, key);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>• <strong>缺点</strong>：同步重试可能阻塞业务线程，影响吞吐量。</p>
<h4 id="异步重试（解耦处理）"><a href="#异步重试（解耦处理）" class="headerlink" title="异步重试（解耦处理）"></a><strong>异步重试（解耦处理）</strong></h4><p>• <strong>场景</strong>：重试操作无需阻塞主流程。<br>• <strong>实现</strong>：将失败操作提交到线程池或消息队列异步处理。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(String key, Data newData)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 更新数据库</span></span><br><span class="line">    database.update(key, newData);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 异步删除缓存</span></span><br><span class="line">    executor.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cache.delete(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;删除缓存失败，key=&#123;&#125;&quot;</span>, key);</span><br><span class="line">            <span class="comment">// 可进一步提交到死信队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>• <strong>优点</strong>：不阻塞主线程，适用于高并发场景。</p>
<hr>
<h3 id="补偿机制：异步队列-定时任务"><a href="#补偿机制：异步队列-定时任务" class="headerlink" title="补偿机制：异步队列 + 定时任务"></a><strong>补偿机制：异步队列 + 定时任务</strong></h3><h4 id="消息队列（最终一致性）"><a href="#消息队列（最终一致性）" class="headerlink" title="消息队列（最终一致性）"></a><strong>消息队列（最终一致性）</strong></h4><p>• <strong>场景</strong>：缓存服务不可用，需保证最终一致性。<br>• <strong>实现</strong>：</p>
<pre><code>1. 删除缓存失败时，将 `key` 写入消息队列（如 Kafka、RocketMQ）。
2. 消费者监听队列，持续重试删除操作。
3. 设置最大重试次数，超过后触发告警。
</code></pre>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除缓存失败后提交到MQ</span></span><br><span class="line">mqProducer.send(<span class="string">&quot;cache-retry-topic&quot;</span>, key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// MQ消费者逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumeCacheRetry</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxRetry</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxRetry; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cache.delete(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            sleep(<span class="number">1000</span> * i); <span class="comment">// 指数退避</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    alert(<span class="string">&quot;缓存删除失败，需人工处理 key=&quot;</span> + key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>• <strong>优点</strong>：解耦业务逻辑，确保最终成功。</p>
<h4 id="定时补偿任务"><a href="#定时补偿任务" class="headerlink" title="定时补偿任务"></a><strong>定时补偿任务</strong></h4><p>• <strong>场景</strong>：消息队列不可用或需兜底。<br>• <strong>实现</strong>：</p>
<pre><code>1. 记录删除失败的 `key` 到数据库或本地文件。
2. 定时任务扫描失败记录，重新发起删除。
</code></pre>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 记录失败操作</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> cache_failures (key, retry_count) <span class="keyword">VALUES</span> (<span class="string">&#x27;key1&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定时任务伪代码</span></span><br><span class="line">List<span class="operator">&lt;</span>CacheFailure<span class="operator">&gt;</span> failures <span class="operator">=</span> queryFailures();</span><br><span class="line"><span class="keyword">for</span> (CacheFailure failure : failures) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        cache.delete(failure.getKey());</span><br><span class="line">        deleteFailureRecord(failure);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        incrementRetryCount(failure);</span><br><span class="line">        if (failure.getRetryCount() <span class="operator">&gt;</span> <span class="number">5</span>) &#123;</span><br><span class="line">            alert(&quot;缓存删除失败，key=&quot; <span class="operator">+</span> failure.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="业务兜底策略"><a href="#业务兜底策略" class="headerlink" title="业务兜底策略"></a><strong>业务兜底策略</strong></h3><h4 id="设置较短缓存过期时间（TTL）"><a href="#设置较短缓存过期时间（TTL）" class="headerlink" title="设置较短缓存过期时间（TTL）"></a><strong>设置较短缓存过期时间（TTL）</strong></h4><p>• <strong>实现</strong>：即使删除失败，旧数据也会在 TTL 后自动失效。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入缓存时设置较短TTL（如30秒）</span></span><br><span class="line">cache.set(key, data, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>• <strong>优点</strong>：简单有效，避免长期不一致。<br>• <strong>缺点</strong>：短期不一致窗口仍存在。</p>
<h4 id="强制读数据库（降级开关）"><a href="#强制读数据库（降级开关）" class="headerlink" title="强制读数据库（降级开关）"></a><strong>强制读数据库（降级开关）</strong></h4><p>• <strong>场景</strong>：缓存删除持续失败，且业务无法容忍不一致。<br>• <strong>实现</strong>：通过配置中心动态开关，绕过缓存直接读数据库。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Data <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (config.isCacheDegraded()) &#123;</span><br><span class="line">        <span class="keyword">return</span> database.read(key); <span class="comment">// 降级读数据库</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="版本号或时间戳校验"><a href="#版本号或时间戳校验" class="headerlink" title="版本号或时间戳校验"></a><strong>版本号或时间戳校验</strong></h4><p>• <strong>实现</strong>：在缓存值和数据库记录中存储版本号，读取时校验。</p>
<pre><code>1. 写数据库时更新版本号。
2. 读缓存时若版本号低于数据库，则忽略缓存。
</code></pre>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Data <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">CachedData</span> <span class="variable">cached</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">    <span class="type">Data</span> <span class="variable">dbData</span> <span class="operator">=</span> database.read(key);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="literal">null</span> &amp;&amp; cached.version == dbData.version) &#123;</span><br><span class="line">        <span class="keyword">return</span> cached.data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dbData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结方案"><a href="#总结方案" class="headerlink" title="总结方案"></a><strong>总结方案</strong></h3><table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>解决方案</strong></th>
<th><strong>适用性</strong></th>
</tr>
</thead>
<tbody><tr>
<td>瞬时故障</td>
<td>同步重试（3次以内）</td>
<td>低并发，容忍短暂阻塞</td>
</tr>
<tr>
<td>缓存服务不稳定</td>
<td>异步队列 + 重试（最终一致性）</td>
<td>高并发，要求最终一致</td>
</tr>
<tr>
<td>长期不可用</td>
<td>降级读数据库 + 告警</td>
<td>高一致性要求场景</td>
</tr>
<tr>
<td>无法接受任何不一致</td>
<td>版本号校验 + 同步双写</td>
<td>金融、交易等强一致性场景</td>
</tr>
</tbody></table>
<hr>
<h3 id="生产建议"><a href="#生产建议" class="headerlink" title="生产建议"></a><strong>生产建议</strong></h3><ol>
<li><strong>监控与告警</strong>：<br>• 监控缓存删除失败率、MQ堆积量、降级开关状态。<br>• 设置阈值告警（如每分钟失败次数 &gt; 100）。  </li>
<li><strong>自动化处理</strong>：<br>• 结合运维工具自动重启缓存节点或切换集群。  </li>
<li><strong>压测与演练</strong>：<br>• 模拟缓存删除失败场景，验证重试和降级逻辑的有效性。</li>
</ol>
<h2 id="缓存更新失败后错数据被访问多次"><a href="#缓存更新失败后错数据被访问多次" class="headerlink" title="缓存更新失败后错数据被访问多次"></a>缓存更新失败后错数据被访问多次</h2><p>在重试过程中，若缓存中的错误数据被多次访问，会导致业务逻辑错误或用户体验受损。以下是分层解决方案，结合 <strong>快速失效、降级兜底、数据校验</strong> 等多种手段，最大限度减少错误数据的影响：</p>
<hr>
<h3 id="快速失效：标记缓存为“待修复”状态"><a href="#快速失效：标记缓存为“待修复”状态" class="headerlink" title="快速失效：标记缓存为“待修复”状态"></a><strong>快速失效：标记缓存为“待修复”状态</strong></h3><h4 id="写入标记-短-TTL"><a href="#写入标记-短-TTL" class="headerlink" title="写入标记 + 短 TTL"></a><strong>写入标记 + 短 TTL</strong></h4><p>• <strong>实现</strong>：在删除缓存失败时，写入一个特殊标记（如 <code>key_pending</code>）并设置短 TTL（如 5 秒），提示后续请求该数据可能不准确。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(String key, Data newData)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 更新数据库</span></span><br><span class="line">    database.update(key, newData);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 尝试删除缓存</span></span><br><span class="line">        cache.delete(key);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 3. 删除失败时，写入待修复标记</span></span><br><span class="line">        cache.set(key + <span class="string">&quot;_pending&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">5</span>); <span class="comment">// 标记存在 5 秒</span></span><br><span class="line">        <span class="comment">// 提交异步重试任务</span></span><br><span class="line">        retryQueue.add(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>• <strong>读取逻辑</strong>：若发现 <code>key_pending</code> 存在，直接读数据库并更新缓存。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Data <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否存在待修复标记</span></span><br><span class="line">    <span class="keyword">if</span> (cache.exists(key + <span class="string">&quot;_pending&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">dbData</span> <span class="operator">=</span> database.read(key);</span><br><span class="line">        cache.set(key, dbData, TTL); <span class="comment">// 主动修复缓存</span></span><br><span class="line">        cache.delete(key + <span class="string">&quot;_pending&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dbData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常缓存逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a><strong>熔断降级</strong></h4><p>• <strong>实现</strong>：监控缓存删除失败率，超过阈值时触发熔断，后续请求直接读数据库。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (failureRate &gt; <span class="number">0.1</span>) &#123; <span class="comment">// 10%失败率触发熔断</span></span><br><span class="line">    degradeCacheRead(); <span class="comment">// 降级为直读数据库</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="主动修复：异步补偿-版本控制"><a href="#主动修复：异步补偿-版本控制" class="headerlink" title="主动修复：异步补偿 + 版本控制"></a><strong>主动修复：异步补偿 + 版本控制</strong></h3><h4 id="版本号校验"><a href="#版本号校验" class="headerlink" title="版本号校验"></a><strong>版本号校验</strong></h4><p>• <strong>实现</strong>：在数据库和缓存中存储数据版本号（如时间戳或递增序号）。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(String key, Data newData)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 更新数据库并递增版本</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">newVersion</span> <span class="operator">=</span> database.updateWithVersion(key, newData);</span><br><span class="line">    <span class="comment">// 2. 删除缓存时携带版本号</span></span><br><span class="line">    cache.delete(key + <span class="string">&quot;:&quot;</span> + newVersion); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Data <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">latestVersion</span> <span class="operator">=</span> database.getVersion(key);</span><br><span class="line">    <span class="type">CachedData</span> <span class="variable">cached</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="literal">null</span> &amp;&amp; cached.version == latestVersion) &#123;</span><br><span class="line">        <span class="keyword">return</span> cached.data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 版本不一致，触发修复</span></span><br><span class="line">    <span class="type">Data</span> <span class="variable">dbData</span> <span class="operator">=</span> database.read(key);</span><br><span class="line">    cache.set(key, dbData, latestVersion, TTL);</span><br><span class="line">    <span class="keyword">return</span> dbData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异步补偿任务"><a href="#异步补偿任务" class="headerlink" title="异步补偿任务"></a><strong>异步补偿任务</strong></h4><p>• <strong>实现</strong>：后台任务定期扫描数据库与缓存的一致性。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkConsistency</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; keys = database.getAllKeys();</span><br><span class="line">    <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">dbVersion</span> <span class="operator">=</span> database.getVersion(key);</span><br><span class="line">        <span class="type">CachedData</span> <span class="variable">cached</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (cached == <span class="literal">null</span> || cached.version &lt; dbVersion) &#123;</span><br><span class="line">            <span class="comment">// 触发缓存修复</span></span><br><span class="line">            <span class="type">Data</span> <span class="variable">dbData</span> <span class="operator">=</span> database.read(key);</span><br><span class="line">            cache.set(key, dbData, dbVersion, TTL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="业务层兜底：读写分离-流量染色"><a href="#业务层兜底：读写分离-流量染色" class="headerlink" title="业务层兜底：读写分离 + 流量染色"></a><strong>业务层兜底：读写分离 + 流量染色</strong></h3><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a><strong>读写分离</strong></h4><p>• <strong>实现</strong>：将修复期间的读请求路由到数据库主库（避免从库延迟）。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Data <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isCacheDegraded()) &#123;</span><br><span class="line">        <span class="comment">// 读主库</span></span><br><span class="line">        <span class="keyword">return</span> masterDatabase.read(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="流量染色"><a href="#流量染色" class="headerlink" title="流量染色"></a><strong>流量染色</strong></h4><p>• <strong>实现</strong>：对部分用户请求添加标记，强制读数据库并对比缓存数据。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Data <span class="title function_">getData</span><span class="params">(String key, <span class="type">boolean</span> forceCheck)</span> &#123;</span><br><span class="line">    <span class="type">Data</span> <span class="variable">cachedData</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (forceCheck) &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">dbData</span> <span class="operator">=</span> database.read(key);</span><br><span class="line">        <span class="keyword">if</span> (!dbData.equals(cachedData)) &#123;</span><br><span class="line">            <span class="comment">// 记录不一致日志并修复</span></span><br><span class="line">            cache.set(key, dbData, TTL);</span><br><span class="line">            <span class="keyword">return</span> dbData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cachedData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结方案-1"><a href="#总结方案-1" class="headerlink" title="总结方案"></a><strong>总结方案</strong></h3><table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>解决方案</strong></th>
<th><strong>适用性</strong></th>
</tr>
</thead>
<tbody><tr>
<td>短暂删除失败（网络抖动）</td>
<td>标记待修复 + 读取时主动修复</td>
<td>高并发，允许短暂不一致</td>
</tr>
<tr>
<td>长期缓存服务不可用</td>
<td>熔断降级 + 直读数据库</td>
<td>强一致性要求场景</td>
</tr>
<tr>
<td>数据版本频繁变更</td>
<td>版本号校验 + 异步补偿任务</td>
<td>金融、订单等关键业务</td>
</tr>
<tr>
<td>灰度验证修复效果</td>
<td>流量染色 + 强制对比</td>
<td>需要验证缓存一致性的场景</td>
</tr>
</tbody></table>
<hr>
<h3 id="生产级最佳实践"><a href="#生产级最佳实践" class="headerlink" title="生产级最佳实践"></a><strong>生产级最佳实践</strong></h3><ol>
<li><strong>监控埋点</strong>：<br>• 监控缓存删除失败率、版本不一致比例、修复任务耗时。<br>• 配置告警（如版本不一致率 &gt; 1% 时触发）。  </li>
<li><strong>自动化修复</strong>：<br>• 结合运维工具自动触发补偿任务，避免人工干预。  </li>
<li><strong>压力测试</strong>：<br>• 模拟缓存删除失败场景，验证修复逻辑的吞吐量和延迟。  </li>
<li><strong>动态配置</strong>：<br>• 通过配置中心动态调整 TTL、重试次数、熔断阈值。  </li>
</ol>
<p>通过以上方案，即使在重试过程中缓存数据暂时错误，也能通过快速失效、主动修复和业务降级，将影响范围控制在最小，最终保障数据一致性。</p>
<h2 id="缓存穿透：布隆过滤器"><a href="#缓存穿透：布隆过滤器" class="headerlink" title="缓存穿透：布隆过滤器"></a>缓存穿透：布隆过滤器</h2><ol>
<li>在ShopService中加入布隆过滤器。<ul>
<li>Service Bean 初始化之后（PostConstruct）进行一次查询，将商铺id放入布隆过滤器</li>
<li>本来商铺的数据是经过预热的，秒杀时商铺可以看做不会增加数据</li>
<li><code>getAvoidPenetrationUsingBloom()</code> 能够先将id加入布隆过滤器中，如果不存在直接返回null。缓存命中真实数据, 直接返回数据</li>
</ul>
</li>
</ol>
<p>作为面试官，针对项目中布隆过滤器（Bloom Filter）防止缓存穿透的实现，我会从以下角度层层递进提问，考察候选人对技术细节、设计权衡和实际问题的理解：</p>
<hr>
<h3 id="基础原理与场景理解"><a href="#基础原理与场景理解" class="headerlink" title="基础原理与场景理解"></a><strong>基础原理与场景理解</strong></h3><ol>
<li><p><strong>缓存穿透是什么？</strong><br>• 预期回答：频繁查询数据库中不存在的数据，绕过缓存直接冲击数据库，导致性能风险。<br>• 延伸问题：如何区分缓存穿透、缓存击穿、缓存雪崩？能否举例说明？</p>
</li>
<li><p><strong>为什么选择布隆过滤器？</strong><br>• 预期回答：空间效率高，可快速判断“数据一定不存在”的场景，避免无效查询。<br>• 延伸问题：布隆过滤器的误判率对业务有何影响？如何量化这种影响？</p>
</li>
</ol>
<hr>
<h3 id="技术实现细节"><a href="#技术实现细节" class="headerlink" title="技术实现细节"></a><strong>技术实现细节</strong></h3><ol start="3">
<li><p><strong>布隆过滤器如何与缓存结合？</strong><br>• 预期回答：查询前先经过布隆过滤器，若返回“不存在”则直接拦截请求；若返回“可能存在”，则查询缓存或数据库。<br>• 延伸问题：如何初始化布隆过滤器？是否需要在系统启动时预热数据？</p>
</li>
<li><p><strong>如何设计布隆过滤器的参数？</strong><br>• 预期回答：根据预期数据量（n）、可接受的误判率（p），计算所需位数组大小（m）和哈希函数数量（k），公式为：<br>  ( $m = -\frac{n \ln p}{(\ln 2)^2}$ ), ( $k = \frac{m}{n} \ln 2$ )。<br>• 延伸问题：如果数据量持续增长，如何动态扩容布隆过滤器？</p>
</li>
</ol>
<hr>
<h3 id="设计权衡与优化"><a href="#设计权衡与优化" class="headerlink" title="设计权衡与优化"></a><strong>设计权衡与优化</strong></h3><ol start="5">
<li><p><strong>布隆过滤器的误判率如何处理？</strong><br>• 预期回答：通过调整参数降低误判率，或在业务层添加兜底机制（如白名单）。<br>• 延伸问题：误判导致合法请求被拦截时，如何监控和修复？是否引入二级缓存？</p>
</li>
<li><p><strong>布隆过滤器不支持删除，如何应对数据删除场景？</strong><br>• 预期回答：使用变种结构如 Counting Bloom Filter 计数，或标记删除延迟更新。<br>• 延伸问题：如果是高频率更新的数据（如电商库存），如何避免频繁重建布隆过滤器？</p>
</li>
</ol>
<hr>
<p><strong>替代方案与对比</strong></p>
<ol start="7">
<li><p><strong>除了布隆过滤器，还有哪些方案可以防止缓存穿透？</strong><br>• 预期回答：缓存空值（Null Object）、互斥锁（Mutex Lock）、异步预热等。<br>• 延伸问题：什么场景下更适合缓存空值而非布隆过滤器？两者的性能差异如何？</p>
</li>
<li><p><strong>布隆过滤器与布谷鸟过滤器（Cuckoo Filter）的优劣对比？</strong><br>• 预期回答：布谷鸟过滤器支持删除、空间效率更高，但实现复杂度更高。<br>• 延伸问题：在内存敏感的场景下，如何选择数据结构？</p>
</li>
</ol>
<hr>
<p><strong>实际应用与故障排查</strong></p>
<ol start="9">
<li><p><strong>项目中布隆过滤器的误判率监控指标是什么？</strong><br>• 预期回答：通过日志或监控系统追踪误判次数与总请求数的比例，调整参数或重建过滤器。<br>• 延伸问题：如何测试布隆过滤器的实际误判率是否符合预期？</p>
</li>
<li><p><strong>是否遇到过布隆过滤器未能解决的极端情况？如何应对？</strong><br>◦ 预期回答：例如恶意攻击构造大量哈希碰撞，需结合限流（Rate Limiting）或IP黑名单。<br>◦ 延伸问题：如果数据库新增了一条本应被布隆过滤器拦截的数据，如何保证一致性？</p>
</li>
</ol>
<hr>
<p><strong>分布式环境挑战</strong></p>
<ol start="11">
<li><p><strong>在分布式系统中，如何维护布隆过滤器的数据一致性？</strong><br>◦ 预期回答：中心化存储（如Redis）或分片同步（需权衡网络开销）。<br>◦ 延伸问题：Redis的布隆过滤器模块（如RedisBloom）是否支持动态扩容？</p>
</li>
<li><p><strong>如何避免布隆过滤器成为单点瓶颈？</strong><br>◦ 预期回答：本地缓存+定期同步，或采用分层过滤（如本地布隆过滤器+全局布隆过滤器）。  </p>
</li>
</ol>
<h3 id="布隆过滤器满了"><a href="#布隆过滤器满了" class="headerlink" title="布隆过滤器满了"></a>布隆过滤器满了</h3><p>布隆过滤器的容量由其位数组大小和哈希函数数量决定。当布隆过滤器“满”（即误判率显著上升）时，可以通过以下方式处理：</p>
<ul>
<li><strong>扩容</strong>：创建一个更大的布隆过滤器，并重新插入所有原始数据（前提是原始数据可访问）。</li>
<li><strong>重建</strong>：若无法扩容且原始数据不可用，只能清空并重新初始化，但会导致历史数据丢失。</li>
<li><strong>分层过滤</strong>：结合多个布隆过滤器（如分片或层级结构），将不同范围的数据分散到不同过滤器中。</li>
</ul>
<h3 id="如何迁移布隆过滤器的数据？"><a href="#如何迁移布隆过滤器的数据？" class="headerlink" title="如何迁移布隆过滤器的数据？"></a><strong>如何迁移布隆过滤器的数据？</strong></h3><p>迁移需要依赖原始数据，步骤如下：</p>
<ol>
<li><strong>创建新过滤器</strong>：构建一个更大的布隆过滤器（更大的位数组和相同/优化的哈希函数）。</li>
<li><strong>重新插入数据</strong>：遍历原始数据集，将每个元素重新哈希并插入新过滤器。</li>
<li><strong>替换旧过滤器</strong>：完成迁移后，用新过滤器替换旧过滤器。</li>
</ol>
<p><strong>注意</strong>：若原始数据不可用，迁移无法完成，需清空或接受更高的误判率。</p>
<h3 id="能否从小布隆过滤器升级到更大的？"><a href="#能否从小布隆过滤器升级到更大的？" class="headerlink" title="能否从小布隆过滤器升级到更大的？"></a><strong>能否从小布隆过滤器升级到更大的？</strong></h3><p><strong>可以</strong>，但必须满足以下条件：</p>
<ul>
<li><strong>哈希函数兼容</strong>：新过滤器的哈希函数需要与旧过滤器兼容（例如，位数组扩容后，哈希值需映射到新数组范围）。</li>
<li><strong>依赖原始数据</strong>：需遍历原始数据重新插入到新过滤器中，否则直接合并位数组可能导致误判率不可控。</li>
</ul>
<h3 id="单体应用中的-BloomFilter-选择建议"><a href="#单体应用中的-BloomFilter-选择建议" class="headerlink" title="单体应用中的 BloomFilter 选择建议"></a><strong>单体应用中的 BloomFilter 选择建议</strong></h3><p>在单体应用中，若需使用布隆过滤器，<strong>Guava BloomFilter 是推荐选择</strong>，原因如下：</p>
<ul>
<li><strong>轻量易用</strong>：无需依赖外部服务（如 Redis），适合单体架构。</li>
<li><strong>高性能</strong>：基于内存的位操作，判断时间复杂度为 O(k)（k 为哈希函数数量）。</li>
<li><strong>灵活配置</strong>：通过 <code>expectedInsertions</code> 和 <code>fpp</code> 平衡内存与误判率。</li>
</ul>
<p>**<mark>静态数据集<mark>**（如预加载的ID列表）：</p>
<ul>
<li>初始化时指定 <code>expectedInsertions</code> 为数据集大小，<code>fpp</code> 根据业务容忍度设置（如 1%）。</li>
</ul>
<p>**<mark>动态数据集<mark>**（如实时去重）：</p>
<ul>
<li>监控填充率：通过 <code>expectedInsertions</code> 和 <code>actualInsertions</code> 估算填充率（例如 <code>filter.approximateElementCount()</code>）。</li>
<li><strong>提前预防写满</strong>：当实际插入量接近 <code>expectedInsertions</code> 时，创建更大的新过滤器并迁移数据。</li>
<li><strong>兜底方案</strong>：若数据不可回溯，可接受更高的误判率，或周期性重置过滤器（牺牲部分业务逻辑准确性）。</li>
</ul>
<p>**<mark>资源受限环境<mark>**：</p>
<ul>
<li>降低 <code>fpp</code> 要求：适当提高误判率以减少内存占用。</li>
<li>使用 <code>策略模式</code> 结合多级过滤：例如先用 <code>HashSet</code> 过滤高频元素，再用 <code>BloomFilter</code> 处理长尾数据。</li>
</ul>
<h2 id="RedisBloom"><a href="#RedisBloom" class="headerlink" title="RedisBloom"></a>RedisBloom</h2><h3 id="RedisBloom-的特色功能详解"><a href="#RedisBloom-的特色功能详解" class="headerlink" title="RedisBloom 的特色功能详解"></a>RedisBloom 的特色功能详解</h3><p>RedisBloom 是 Redis 的一个扩展模块，提供了一系列概率数据结构（Probabilistic Data Structures），在分布式场景下表现出色。以下是其核心特色功能及优势：</p>
<hr>
<h4 id="支持多种概率数据结构"><a href="#支持多种概率数据结构" class="headerlink" title="支持多种概率数据结构"></a><strong>支持多种概率数据结构</strong></h4><p>RedisBloom 不仅包含标准布隆过滤器，还提供以下高级数据结构：<br>• <strong>布隆过滤器（Bloom Filter, BF）</strong>：<br>  支持快速判断元素是否存在，适用于去重、缓存穿透防护等场景。<br>• <strong>计数布隆过滤器（Counting Bloom Filter, CBF）</strong>：<br>  允许删除元素（通过计数器增减），解决了传统布隆过滤器无法删除的问题。<br>• <strong>Cuckoo 过滤器（Cuckoo Filter, CF）</strong>：<br>  相比布隆过滤器，支持删除操作且空间效率更高，误判率更低。<br>• <strong>Top-K 计数器（Top-K）</strong>：<br>  统计高频元素（如热点关键词），支持动态更新和查询 Top N 结果。<br>• <strong>Count-Min Sketch（CMS）</strong>：<br>  估算数据流的频率分布（如统计用户行为次数），适用于大数据量下的近似统计。</p>
<p><strong>示例命令</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 布隆过滤器：添加元素并检查存在性</span></span><br><span class="line">BF.ADD myfilter <span class="string">&quot;item1&quot;</span></span><br><span class="line">BF.EXISTS myfilter <span class="string">&quot;item1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cuckoo 过滤器：添加并删除元素</span></span><br><span class="line">CF.ADDNX mycuckoo <span class="string">&quot;item2&quot;</span></span><br><span class="line">CF.DEL mycuckoo <span class="string">&quot;item2&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="动态扩容与自动缩放"><a href="#动态扩容与自动缩放" class="headerlink" title="动态扩容与自动缩放"></a><strong>动态扩容与自动缩放</strong></h4><p>• <strong>自动扩容能力</strong>：<br>  RedisBloom 的布隆过滤器在初始化时可设置 <code>CAPACITY</code> 和 <code>ERROR RATE</code>，当插入元素数量接近容量上限时，<strong>自动创建子过滤器并分摊哈希计算</strong>，无需手动重建。<br>• <strong>弹性扩展</strong>：<br>  通过 <code>BF.RESERVE</code> 命令可动态调整容量和误判率，适应数据量增长。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化一个支持自动扩容的布隆过滤器</span></span><br><span class="line">BF.RESERVE myautofilter 0.01 1000 AUTOEXPAND 1</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="分布式与高可用支持"><a href="#分布式与高可用支持" class="headerlink" title="分布式与高可用支持"></a><strong>分布式与高可用支持</strong></h4><p>• <strong>天然分布式</strong>：<br>  作为 Redis 模块，支持 Redis 集群模式，数据分片存储在多个节点，适合大规模分布式系统。<br>• <strong>持久化与灾备</strong>：<br>  利用 Redis 的 RDB/AOF 持久化机制，数据可持久保存；通过主从复制、哨兵模式或 Redis Cluster 实现高可用。</p>
<hr>
<h4 id="高性能与低延迟"><a href="#高性能与低延迟" class="headerlink" title="高性能与低延迟"></a><strong>高性能与低延迟</strong></h4><p>• <strong>内存优化</strong>：<br>  位数组和哈希算法针对内存效率优化，例如 Cuckoo 过滤器比传统布隆过滤器节省 20%~30% 空间。<br>• <strong>批量操作</strong>：<br>  支持批量添加（<code>BF.MADD</code>）和批量检查（<code>BF.MEXISTS</code>），减少网络开销。</p>
<p><strong>性能对比</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>单次请求耗时</th>
<th>批量（1000元素）耗时</th>
</tr>
</thead>
<tbody><tr>
<td><code>BF.ADD</code></td>
<td>0.1ms</td>
<td>10ms</td>
</tr>
<tr>
<td><code>BF.MADD</code></td>
<td>-</td>
<td>2ms</td>
</tr>
</tbody></table>
<hr>
<h4 id="灵活的配置与管理"><a href="#灵活的配置与管理" class="headerlink" title="灵活的配置与管理"></a><strong>灵活的配置与管理</strong></h4><p>• <strong>自定义参数</strong>：<br>  初始化时可指定容量（<code>CAPACITY</code>）、误判率（<code>ERROR RATE</code>）、扩容策略（<code>AUTOEXPAND</code>）等。<br>• <strong>过期时间（TTL）</strong>：<br>  结合 Redis 的 <code>EXPIRE</code> 命令，可为过滤器设置自动过期清理。<br>• <strong>信息监控</strong>：<br>  通过 <code>BF.INFO</code> 命令查看过滤器状态（如元素数量、内存占用）。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建过滤器并设置过期时间</span></span><br><span class="line">BF.RESERVE myfilter 0.01 10000</span><br><span class="line">EXPIRE myfilter 3600  <span class="comment"># 1小时后自动删除</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="与-Redis-生态无缝集成"><a href="#与-Redis-生态无缝集成" class="headerlink" title="与 Redis 生态无缝集成"></a><strong>与 Redis 生态无缝集成</strong></h4><p>• <strong>Lua 脚本支持</strong>：<br>  可在脚本中直接调用 RedisBloom 命令，实现复杂逻辑（如原子性操作）。<br>• <strong>事务与管道</strong>：<br>  结合 Redis 事务（<code>MULTI/EXEC</code>）和管道（Pipeline），提升批量操作效率。<br>• <strong>发布订阅（Pub/Sub）</strong>：<br>  监听过滤器状态变化（如容量告警），触发业务逻辑。</p>
<hr>
<h3 id="适用场景对比"><a href="#适用场景对比" class="headerlink" title="适用场景对比"></a><strong>适用场景对比</strong></h3><table>
<thead>
<tr>
<th>场景</th>
<th>Guava BloomFilter</th>
<th>RedisBloom</th>
</tr>
</thead>
<tbody><tr>
<td><strong>单机应用</strong></td>
<td>✅ 轻量、高性能</td>
<td>❌ 需 Redis 依赖</td>
</tr>
<tr>
<td><strong>分布式系统</strong></td>
<td>❌ 无法跨节点共享</td>
<td>✅ 天然支持</td>
</tr>
<tr>
<td><strong>动态扩容需求</strong></td>
<td>❌ 需手动重建</td>
<td>✅ 自动扩展</td>
</tr>
<tr>
<td><strong>数据持久化</strong></td>
<td>❌ 内存数据易丢失</td>
<td>✅ RDB/AOF 持久化</td>
</tr>
<tr>
<td><strong>高频删除操作</strong></td>
<td>❌ 不支持</td>
<td>✅ Cuckoo/Counting BF</td>
</tr>
</tbody></table>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>RedisBloom 的核心优势在于：</p>
<ol>
<li><strong>多数据结构支持</strong>：覆盖从存在性判断（布隆/Cuckoo 过滤器）到频率统计（Top-K/CMS）的多样化场景。</li>
<li><strong>分布式能力</strong>：无缝集成 Redis 集群和高可用架构，适合微服务和大规模系统。</li>
<li><strong>自动化运维</strong>：动态扩容、持久化、监控告警等特性降低运维成本。</li>
<li><strong>高性能与弹性</strong>：内存优化和批量操作保障低延迟，适应高并发需求。</li>
</ol>
<p>对于需要扩展性、持久化或分布式协作的场景，RedisBloom 是比 Guava BloomFilter 更强大的选择。</p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><h3 id="简述你的登录逻辑（token-双拦截器）"><a href="#简述你的登录逻辑（token-双拦截器）" class="headerlink" title="简述你的登录逻辑（token 双拦截器）"></a>简述你的登录逻辑（token 双拦截器）</h3><p>短信登录的短信怎么发送的?</p>
<ul>
<li>使用hutool生成的随机六位数验证码</li>
</ul>
<p>如何标识用户</p>
<ul>
<li>（手机号）</li>
</ul>
<p>项目的权限刷新什么意思</p>
<ul>
<li>（登录时判断是否注册）</li>
</ul>
<p>在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，比如主页之类的那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的。</p>
<p>只有访问拦截的网页才会刷redis，这样就导致如果用户访问的是其他网页，不会出发拦截器，过期token就会失效</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653320822964.png" alt="初始方案思路总结"></p>
<p>既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653320764547.png" alt="优化拦截器"></p>
<h3 id="为什么要用thread-local"><a href="#为什么要用thread-local" class="headerlink" title="为什么要用thread local"></a>为什么要用thread local</h3><p>thread local底层你懂吗？会出现什么问题？内存泄漏知道吗？怎么解决的</p>
<p>内存泄露</p>
<p><code>ThreadLocal&lt;T&gt;</code> 主要用于以下场景：</p>
<ol>
<li><strong>线程安全的变量管理：</strong> 比如事务管理、用户会话等。</li>
<li><strong>避免同步锁：</strong> 替代传统的锁机制，提高并发性能。</li>
<li><strong>数据库连接或会话缓存：</strong> 每个线程维护自己的数据库连接实例。避免显式传递参数。</li>
</ol>
<p>T 用于表示 ThreadLocal 存的值类型 线程对象的ThreadLocalMap </p>
<h4 id="ThreadLocal-的核心用法"><a href="#ThreadLocal-的核心用法" class="headerlink" title="ThreadLocal 的核心用法"></a><strong>ThreadLocal 的核心用法</strong></h4><ol>
<li><p><strong>创建 ThreadLocal 实例</strong><br>通常声明为 <code>static final</code>，避免重复创建。可以通过 <code>withInitial</code> 或重写 <code>initialValue</code> 设置默认值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java 8+ 推荐方式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="string">&quot;default&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统方式（重写 initialValue）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>设置和获取值</strong><br>使用 <code>set()</code> 和 <code>get()</code> 方法操作当前线程的副本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threadLocal.set(<span class="string">&quot;value&quot;</span>); <span class="comment">// 设置当前线程的值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get(); <span class="comment">// 获取当前线程的值</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>清理资源</strong><br>务必在 <code>finally</code> 块中调用 <code>remove()</code>，防止内存泄漏：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="comment">// ... 业务逻辑 ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.remove(); <span class="comment">// 清理当前线程的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><ul>
<li>ThreadLocalMap 的键是弱引用（ThreadLocal 实例），但值是强引用。若 ThreadLocal 被回收，但线程未销毁（如线程池复用），值对象可能无法回收。</li>
<li>线程复用可能导致残留旧值，需确保每次任务结束后清理 ThreadLocal。</li>
<li><strong>解决</strong>：始终在 <code>finally</code> 块中调用 <code>remove()</code>。</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li>默认情况下，子线程无法继承父线程的 ThreadLocal 值。若需要继承，使用 <code>InheritableThreadLocal</code>。</li>
<li><strong>局限性</strong>：线程池场景中，子线程可能复用旧线程，导致继承的值并非最新。</li>
</ul>
<h2 id="异步秒杀"><a href="#异步秒杀" class="headerlink" title="异步秒杀"></a>异步秒杀</h2><p>项目为什么要加个消息队列?</p>
<ul>
<li>redis效率比较高，而数据库效率不如redis快，tomcat中的程序，会进行串行操作，分成如下几步：查询优惠卷、<mark>判断秒杀库存是否足够<mark>、查询订单、<mark>校验是否是一人一单<mark>、扣减库存、创建订单。在这六步操作中，又有很多操作是要去操作数据库的，而且还是一个线程串行执行， 这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行。</li>
<li>将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息</li>
<li>为什么不使用线程池或者异步编排。如果访问的人很多，那么线程池中的线程可能一下子就被消耗完了，而且你使用上述方案，最大的特点在于，你觉得时效性会非常重要，但是你想想是吗？并不是，比如我只要确定他能做这件事，然后我后边慢慢做就可以了，我并不需要他一口气做完这件事，所以我们应当采用的是课程中，类似消息队列的方式来完成我们的需求，而不是使用线程池或者是异步编排的方式来完成这个需求。</li>
</ul>
<p>在用户异步下单时，后端会接收到/voucher-order/seckill/{} 的请求，此时VoucherOrderController会调用<code>seckillVoucher</code>方法。执行lua脚本，判断用户的购买资格，有购买资格的话，生成orderId，并将用户id和优惠券id一起存入订单消息中，然后将订单消息存入RabbitMQ消息队列，等待<strong>消费者异步消费</strong>。</p>
<p>订单接口的幂等性是怎么做的？</p>
<ul>
<li>（意思就是post请求带着：一个用户id，一个优惠卷id。发送多次请求，如何保证只有一个成功，也就是一人一单）</li>
</ul>
<p>库存扣减之后，还要去insert一个新的订单，你是如何保存这个的一致性的？</p>
<ul>
<li>使用spring自带的事务，将其放到一个事务里</li>
</ul>
<p>抢优惠券没有及时处理怎么办?</p>
<ul>
<li>（通知用户已经抢了，延迟推送结果）</li>
</ul>
<p>抢优惠券处理完了如何通知用户？</p>
<ul>
<li>（没有通知）</li>
</ul>
<p>秒杀场景下扣减库存太慢了怎么办？</p>
<ul>
<li>（数据库集群，分库分表，索引优化，Redis热key，大key，Redis缓存过小）</li>
</ul>
<h2 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h2><hr>
<h3 id="针对单体架构高并发下请求堆积问题的分层解决方案"><a href="#针对单体架构高并发下请求堆积问题的分层解决方案" class="headerlink" title="针对单体架构高并发下请求堆积问题的分层解决方案"></a>针对单体架构高并发下请求堆积问题的分层解决方案</h3><hr>
<h4 id="紧急止血：快速缓解当前压力"><a href="#紧急止血：快速缓解当前压力" class="headerlink" title="紧急止血：快速缓解当前压力"></a><strong>紧急止血：快速缓解当前压力</strong></h4><ol>
<li><p><strong>限流降级</strong><br>• <strong>限流策略</strong>：<br>  ◦ 使用令牌桶或漏桶算法限制接口请求速率（如 Guava RateLimiter 或 Sentinel）。<br>  ◦ 针对非核心功能直接降级（返回静态页或简化逻辑）。<br>• <strong>代码示例</strong>：  </p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Sentinel 限流</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;coreApi&quot;, blockHandler = &quot;handleBlock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">coreApi</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handleBlock</span><span class="params">(BlockException ex)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;系统繁忙，请稍后重试！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>异步化处理</strong><br>• <strong>消息队列缓冲</strong>：<br>  ◦ 将非实时请求写入消息队列（如 RabbitMQ/Kafka），异步消费。<br>  ◦ 示例：订单支付后的通知、日志记录等操作异步化。<br>• <strong>代码示例</strong>：  </p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订单支付主逻辑同步处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">payOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 核心支付逻辑</span></span><br><span class="line">    processPayment(order);</span><br><span class="line">    <span class="comment">// 2. 通知类操作异步化</span></span><br><span class="line">    mq.send(<span class="string">&quot;payment_success_queue&quot;</span>, order.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>扩容与负载均衡</strong><br>• <strong>垂直扩容</strong>：临时升级服务器配置（CPU、内存）。<br>• <strong>水平扩容</strong>：<br>  ◦ 通过 Nginx 负载均衡部署多个单体实例。<br>  ◦ 使用云服务自动扩展组（如 AWS Auto Scaling）。  </p>
</li>
</ol>
<hr>
<h4 id="性能优化：提升单机处理能力"><a href="#性能优化：提升单机处理能力" class="headerlink" title="性能优化：提升单机处理能力"></a><strong>性能优化：提升单机处理能力</strong></h4><ol>
<li><p><strong>代码层优化</strong><br>• <strong>减少锁竞争</strong>：<br>  ◦ 使用无锁数据结构（如 ConcurrentHashMap）。<br>  ◦ 缩小同步代码块范围，避免全局锁。<br>• <strong>优化算法复杂度</strong>：<br>  ◦ 将 O(n²) 逻辑优化为 O(n) 或 O(log n)。<br>• <strong>示例</strong>：  </p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优化前：双重循环匹配</span></span><br><span class="line"><span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Order order : orders) &#123;</span><br><span class="line">        <span class="keyword">if</span> (user.getId().equals(order.getUserId())) &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化后：使用 Map 降低复杂度</span></span><br><span class="line">Map&lt;Long, User&gt; userMap = users.stream().collect(Collectors.toMap(User::getId, u -&gt; u));</span><br><span class="line"><span class="keyword">for</span> (Order order : orders) &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMap.get(order.getUserId());</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>数据库优化</strong><br>• <strong>索引优化</strong>：<br>  ◦ 通过 EXPLAIN 分析慢查询，添加缺失索引。<br>  ◦ 避免全表扫描，限制查询范围（如时间区间分页）。<br>• <strong>批量操作</strong>：<br>  ◦ 合并多次 INSERT/UPDATE 为批量操作。  </p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 批量插入优化</span></span><br><span class="line">jdbcTemplate.batchUpdate(<span class="string">&quot;INSERT INTO log (content) VALUES (?)&quot;</span>, logs, <span class="number">100</span>, (ps, log) -&gt; &#123;</span><br><span class="line">    ps.setString(<span class="number">1</span>, log.getContent());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>缓存加速</strong><br>• <strong>本地缓存</strong>：<br>  ◦ 使用 Caffeine 缓存热点数据（如配置表、频繁查询的用户信息）。<br>  ◦ 示例：缓存用户基本信息，TTL 设置为 5 分钟。<br>• <strong>分布式缓存</strong>：<br>  ◦ Redis 缓存复杂查询结果（如商品详情页）。  </p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Product <span class="title function_">getProduct</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;product:&quot;</span> + id;</span><br><span class="line">    <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (product == <span class="literal">null</span>) &#123;</span><br><span class="line">        product = database.queryProduct(id);</span><br><span class="line">        redis.setex(key, <span class="number">3600</span>, product); <span class="comment">// 缓存1小时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="架构改造：逐步拆分与异步解耦"><a href="#架构改造：逐步拆分与异步解耦" class="headerlink" title="架构改造：逐步拆分与异步解耦"></a><strong>架构改造：逐步拆分与异步解耦</strong></h4><ol>
<li><p><strong>关键模块拆分</strong><br>• <strong>第一步：拆分高负载模块</strong><br>  ◦ 将消息处理、文件上传等资源密集型模块独立为微服务。<br>  ◦ 示例：将消息消费者拆分为独立服务，单独扩展。<br>• <strong>技术栈</strong>：<br>  ◦ 使用 Spring Cloud 或 Dubbo 实现服务化。  </p>
</li>
<li><p><strong>数据库拆分</strong><br>• <strong>读写分离</strong>：<br>  ◦ 主库处理写操作，从库处理读操作（通过 ShardingSphere 或 MyCAT）。<br>• <strong>分库分表</strong>：<br>  ◦ 按用户ID哈希分表，分散单表压力。  </p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按 user_id 分表（user_table_0, user_table_1）</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> user_table_0 (id <span class="type">BIGINT</span>, user_id <span class="type">BIGINT</span>, ...) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> HASH(user_id <span class="operator">%</span> <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>消息队列解耦</strong><br>• <strong>削峰填谷</strong>：<br>  ◦ 使用 Kafka 承接突发流量，消费者按能力处理。<br>  ◦ 示例：秒杀请求先写入 Kafka，异步处理订单。<br>• <strong>代码示例</strong>：  </p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者快速响应</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleSeckillRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    kafka.send(<span class="string">&quot;seckill_requests&quot;</span>, request);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;请求已受理，请等待结果！&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者批量处理</span></span><br><span class="line"><span class="meta">@KafkaListener(topics = &quot;seckill_requests&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processSeckill</span><span class="params">(List&lt;Request&gt; requests)</span> &#123;</span><br><span class="line">    batchProcessOrders(requests);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="长期运维：监控与自动化"><a href="#长期运维：监控与自动化" class="headerlink" title="长期运维：监控与自动化"></a><strong>长期运维：监控与自动化</strong></h4><ol>
<li><p><strong>全链路监控</strong><br>• <strong>指标采集</strong>：<br>  ◦ 使用 Prometheus + Grafana 监控 CPU、内存、线程池、数据库连接池。<br>• <strong>日志追踪</strong>：<br>  ◦ 通过 ELK（Elasticsearch + Logstash + Kibana）定位慢请求。  </p>
</li>
<li><p><strong>自动化弹性伸缩</strong><br>• <strong>Kubernetes 部署</strong>：<br>  ◦ 根据 CPU 使用率自动扩展 Pod 实例。<br>• <strong>云服务集成</strong>：<br>  ◦ AWS Lambda 处理突发流量（Serverless 无服务器架构）。  </p>
</li>
<li><p><strong>容灾与备份</strong><br>• <strong>多可用区部署</strong>：<br>  ◦ 在云环境中跨可用区（AZ）部署实例，避免单点故障。<br>• <strong>定期备份</strong>：<br>  ◦ 使用 XtraBackup 或 AWS RDS 快照备份数据库。  </p>
</li>
</ol>
<hr>
<h3 id="方案对比与选型建议"><a href="#方案对比与选型建议" class="headerlink" title="方案对比与选型建议"></a><strong>方案对比与选型建议</strong></h3><table>
<thead>
<tr>
<th><strong>方案</strong></th>
<th><strong>实施难度</strong></th>
<th><strong>见效速度</strong></th>
<th><strong>适用阶段</strong></th>
<th><strong>成本</strong></th>
</tr>
</thead>
<tbody><tr>
<td>限流降级</td>
<td>低</td>
<td>立即</td>
<td>紧急处理</td>
<td>低</td>
</tr>
<tr>
<td>代码优化</td>
<td>中</td>
<td>1-3天</td>
<td>短期优化</td>
<td>低</td>
</tr>
<tr>
<td>数据库读写分离</td>
<td>高</td>
<td>1周</td>
<td>中期架构调整</td>
<td>中</td>
</tr>
<tr>
<td>微服务拆分</td>
<td>高</td>
<td>1-3个月</td>
<td>长期重构</td>
<td>高</td>
</tr>
<tr>
<td>消息队列削峰</td>
<td>中</td>
<td>3-7天</td>
<td>中期解耦</td>
<td>中</td>
</tr>
</tbody></table>
<hr>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h3><ol>
<li><strong>短期优先</strong>：限流 + 异步化 + 扩容，快速释放系统压力。  </li>
<li><strong>中期优化</strong>：代码性能优化 + 数据库调优 + 缓存加速。  </li>
<li><strong>长期重构</strong>：分步骤拆解单体为微服务，引入弹性伸缩与自动化运维。  </li>
</ol>
<p>通过分层策略逐步推进，在保障系统稳定的前提下，最终实现高并发场景下的可持续扩展能力。</p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁在数据库层面的实现确实存在并发冲突的问题，但通过合理的设计和优化策略，可以在高并发场景下保持较好的性能。以下从技术实现、优化策略和场景适配三个维度详细说明：</p>
<hr>
<h3 id="乐观锁的核心原理"><a href="#乐观锁的核心原理" class="headerlink" title="乐观锁的核心原理"></a>乐观锁的核心原理</h3><p><strong>实现方式</strong>：通过版本号（Version）或时间戳（Timestamp）机制实现。更新时检查当前版本是否匹配，若匹配则更新成功并递增版本号，否则拒绝操作。</p>
<p><strong>SQL示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> </span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> new_value, version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> #&#123;id&#125; <span class="keyword">AND</span> version <span class="operator">=</span> #&#123;old_version&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>关键特点</strong>：无锁检测，仅在提交时判断版本，适合读多写少场景。</p>
<hr>
<h3 id="高并发下的冲突瓶颈"><a href="#高并发下的冲突瓶颈" class="headerlink" title="高并发下的冲突瓶颈"></a>高并发下的冲突瓶颈</h3><ol>
<li><p><strong>冲突率高时的表现</strong>：<br>• 大量事务因版本不匹配而失败，需重试或回滚。<br>• 频繁的磁盘I/O和锁竞争导致吞吐量下降。</p>
</li>
<li><p><strong>数据库行锁的影响</strong>：<br>• 即使使用乐观锁，MySQL等数据库在执行UPDATE时仍会对行加排他锁，直到事务提交。<br>• 长事务会加剧锁竞争，需缩短事务时间。</p>
</li>
</ol>
<hr>
<h3 id="优化策略与实践方案"><a href="#优化策略与实践方案" class="headerlink" title="优化策略与实践方案"></a>优化策略与实践方案</h3><h4 id="精细化锁粒度"><a href="#精细化锁粒度" class="headerlink" title="精细化锁粒度"></a><strong>精细化锁粒度</strong></h4><p>   • <strong>字段拆分</strong>：对高频更新字段独立维护版本号，减少无关字段的冲突。<br>     <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> user_points </span><br><span class="line"><span class="keyword">SET</span> points <span class="operator">=</span> points <span class="operator">+</span> <span class="number">100</span>, point_version <span class="operator">=</span> point_version <span class="operator">+</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">123</span> <span class="keyword">AND</span> point_version <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><br>   • <strong>分桶计数</strong>：将计数器拆分为多个桶（如100个），随机选择桶更新，查询时求和。<br>     <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> counters </span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">value</span> <span class="operator">=</span> <span class="keyword">value</span> <span class="operator">+</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">WHERE</span> bucket_id <span class="operator">=</span> <span class="built_in">FLOOR</span>(RAND() <span class="operator">*</span> <span class="number">100</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="无锁化设计"><a href="#无锁化设计" class="headerlink" title="无锁化设计"></a><strong>无锁化设计</strong></h4><p>   • <strong>原子操作</strong>：利用数据库内置原子能力，避免CAS检查。<br>     <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 直接增减，无需版本号</span></span><br><span class="line"><span class="keyword">UPDATE</span> products <span class="keyword">SET</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><br>   • <strong>状态机约束</strong>：通过WHERE子句添加业务条件，确保状态合法。<br>     <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> orders </span><br><span class="line"><span class="keyword">SET</span> status <span class="operator">=</span> <span class="string">&#x27;paid&#x27;</span> </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">456</span> <span class="keyword">AND</span> status <span class="operator">=</span> <span class="string">&#x27;unpaid&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="异步合并与缓冲"><a href="#异步合并与缓冲" class="headerlink" title="异步合并与缓冲"></a><strong>异步合并与缓冲</strong></h4><p>   • <strong>本地队列</strong>：在应用层合并短时间内相同资源的写操作，批量提交。<br>   • <strong>Redis中间层</strong>：在缓存层预扣库存，通过定时任务同步至数据库。<br>     <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Redis Lua脚本实现原子扣减</span></span><br><span class="line"><span class="keyword">local</span> stock = redis.call(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;product:100:stock&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> stock &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;DECR&#x27;</span>, <span class="string">&#x27;product:100:stock&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<h4 id="冲突处理与重试"><a href="#冲突处理与重试" class="headerlink" title="冲突处理与重试"></a><strong>冲突处理与重试</strong></h4><p>   • <strong>指数退避重试</strong>：在应用层实现自动重试逻辑，避免无限循环。<br>     <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update_with_retry</span>(<span class="params">max_retries=<span class="number">3</span></span>):</span><br><span class="line">    retries = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> retries &lt; max_retries:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 执行乐观锁更新</span></span><br><span class="line">            <span class="keyword">return</span> success</span><br><span class="line">        <span class="keyword">except</span> VersionConflict:</span><br><span class="line">            sleep(<span class="number">2</span> ** retries)</span><br><span class="line">            retries += <span class="number">1</span></span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;Max retries exceeded&quot;</span>)</span><br></pre></td></tr></table></figure><br>   • <strong>熔断降级</strong>：当冲突超过阈值时，暂时禁用写操作，返回兜底结果。</p>
<h4 id="数据库调优"><a href="#数据库调优" class="headerlink" title="数据库调优"></a><strong>数据库调优</strong></h4><p>   • <strong>短事务原则</strong>：确保事务尽量简短，及时提交释放行锁。<br>   • <strong>读写分离</strong>：将读请求分流到只读副本，减轻主库压力。<br>   • <strong>索引优化</strong>：避免全表扫描导致锁升级为表锁（如MySQL的InnoDB行锁特性）。</p>
<hr>
<h3 id="场景适配与方案选型"><a href="#场景适配与方案选型" class="headerlink" title="场景适配与方案选型"></a>场景适配与方案选型</h3><ol>
<li><p><strong>秒杀场景</strong>：<br>• <strong>预扣库存</strong>：Redis集群+异步落库。<br>• <strong>限流削峰</strong>：令牌桶算法控制请求速率。</p>
</li>
<li><p><strong>账户余额更新</strong>：<br>• <strong>事务拆分</strong>：余额变更与流水记录分离，流水表使用异步插入。</p>
</li>
<li><p><strong>评论点赞计数</strong>：<br>• <strong>内存累加</strong>：应用层缓存计数，定时批量写入。</p>
</li>
</ol>
<hr>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>乐观锁的并发瓶颈并非无解，关键在于结合业务特点选择优化方向：<br>• <strong>减少冲突</strong>：通过拆分资源、无锁化操作降低竞争。<br>• <strong>提升吞吐</strong>：利用异步化、批量处理减少I/O开销。<br>• <strong>柔性设计</strong>：在强一致性和最终一致性之间寻找平衡点。</p>
<p>最终方案需权衡开发成本、数据一致性和性能要求，例如金融交易需强一致，而社交 feed 可接受短暂延迟。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>使用 唯一标识 + 分布式锁 + 数据库唯一约束 保证订单提交的幂等性，做到一人一单、防止超卖，</p>
<p>是的，**<code>@RabbitListener</code> 监听消息的同步处理逻辑可以结合 <code>CompletableFuture</code> 实现异步操作**，尤其适用于需要异步执行耗时任务（如数据库操作、外部接口调用等）的场景。以下是具体实现方案及注意事项：</p>
<h3 id="基础实现思路"><a href="#基础实现思路" class="headerlink" title="基础实现思路"></a><strong>基础实现思路</strong></h3><p>• <strong>核心目标</strong>：在 <code>@RabbitListener</code> 方法内启动异步任务，避免阻塞 RabbitMQ 的监听线程。<br>• <strong>消息确认策略</strong>：需结合手动 ACK 模式，确保异步任务完成后才确认消息，避免消息丢失。</p>
<hr>
<h3 id="实现代码示例"><a href="#实现代码示例" class="headerlink" title="实现代码示例"></a><strong>实现代码示例</strong></h3><h4 id="配置手动-ACK-模式"><a href="#配置手动-ACK-模式" class="headerlink" title="配置手动 ACK 模式"></a><strong>配置手动 ACK 模式</strong></h4><p>在 <code>application.yml</code> 中启用手动确认：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span> <span class="comment"># 手动ACK</span></span><br></pre></td></tr></table></figure>

<h4 id="异步处理消息"><a href="#异步处理消息" class="headerlink" title="异步处理消息"></a><strong>异步处理消息</strong></h4><p>在 <code>@RabbitListener</code> 方法中使用 <code>CompletableFuture</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;order.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message message, Channel channel, <span class="meta">@Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="type">long</span> tag)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msgBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动异步任务</span></span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 异步扣减逻辑（如库存、积分）</span></span><br><span class="line">            deductService.asyncDeduct(msgBody);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 任务成功：手动ACK</span></span><br><span class="line">            channel.basicAck(tag, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 任务失败：NACK并重新入队（根据业务决定是否重试）</span></span><br><span class="line">            channel.basicNack(tag, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, asyncExecutor); <span class="comment">// 指定自定义线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置异步线程池"><a href="#配置异步线程池" class="headerlink" title="配置异步线程池"></a><strong>配置异步线程池</strong></h4><p>避免占用默认线程池资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;asyncExecutor&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Executor <span class="title function_">asyncExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">        <span class="number">5</span>, <span class="number">10</span>, <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="关键注意事项"><a href="#关键注意事项" class="headerlink" title="关键注意事项"></a><strong>关键注意事项</strong></h3><h4 id="消息确认与可靠性"><a href="#消息确认与可靠性" class="headerlink" title="消息确认与可靠性"></a><strong>消息确认与可靠性</strong></h4><p>• <strong>ACK/NACK 必须在异步线程中执行</strong>：RabbitMQ 的 <code>Channel</code> 对象非线程安全，需确保在异步任务内调用 <code>basicAck</code>/<code>basicNack</code>。<br>• <strong>防止消息丢失</strong>：异步任务异常时，通过 <code>basicNack</code> 的 <code>requeue</code> 参数控制消息重试（需业务逻辑幂等）。</p>
<h4 id="线程池管理"><a href="#线程池管理" class="headerlink" title="线程池管理"></a><strong>线程池管理</strong></h4><p>• <strong>拒绝策略</strong>：当线程池满载时，使用 <code>CallerRunsPolicy</code> 让主线程执行任务，避免消息堆积。<br>• <strong>资源隔离</strong>：为不同业务分配独立线程池，避免互相影响。</p>
<h4 id="业务幂等性"><a href="#业务幂等性" class="headerlink" title="业务幂等性"></a><strong>业务幂等性</strong></h4><p>• <strong>防重复处理</strong>：消息可能因重试被多次消费，需通过唯一ID+状态机/数据库锁保证扣减操作幂等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：通过唯一ID保证幂等</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncDeduct</span><span class="params">(String orderId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (deductLock.tryLock(orderId)) &#123; <span class="comment">// 自定义分布式锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行扣减</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            deductLock.unlock(orderId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a><strong>性能优化建议</strong></h3><p>• <strong>批量消费</strong>：结合 <code>@RabbitListener</code> 的 <code>containerFactory</code> 配置批量消费，提升吞吐量。<br>• <strong>异步任务拆分</strong>：若扣减逻辑涉及多个步骤，可进一步用 <code>CompletableFuture</code> 编排子任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture.runAsync(() -&gt; deductStep1(), asyncExecutor)</span><br><span class="line">    .thenRunAsync(() -&gt; deductStep2(), asyncExecutor)</span><br><span class="line">    .exceptionally(ex -&gt; &#123;</span><br><span class="line">        channel.basicNack(tag, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>• <strong>可行性</strong>：<code>@RabbitListener</code> + <code>CompletableFuture</code> 能有效实现异步处理，提升消息消费速度。<br>• <strong>核心要点</strong>：<br>  • 手动 ACK/NACK 需在异步任务内完成。<br>  • 异步线程池需合理配置，避免资源耗尽。<br>  • 业务逻辑必须幂等，防止消息重试导致数据不一致。<br>• <strong>适用场景</strong>：适用于需要异步化、耗时较长的消息处理逻辑（如IO密集型操作）。</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>布隆过滤器</tag>
        <tag>redis</tag>
        <tag>缓存</tag>
        <tag>乐观锁</tag>
        <tag>threadlocal</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合框架</title>
    <url>/2024/07/01/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><p>并发集合见 JUC</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-collection-hierarchy.png" alt="Java 集合框架概览"></p>
<h2 id="Collecion-单列"><a href="#Collecion-单列" class="headerlink" title="Collecion 单列"></a>Collecion 单列</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915133525868-1735477273565-35-1735477280164-37.png" alt="Collection"></p>
<ul>
<li><code>List</code>系列：添加元素有序，可重复，有索引<ul>
<li><code>ArrayList</code></li>
<li><code>LinkedList</code></li>
</ul>
</li>
<li><code>Set</code>系列：添加元素无序，不重复，无索引<ul>
<li><code>HashSet</code> 无序不重复无索引<ul>
<li><code>LinkedHashSet</code> 有序不重复无索引</li>
</ul>
</li>
<li><code>TreeSet</code> 按照大小默认升序排序 不重复 无索引</li>
</ul>
</li>
</ul>
<h3 id="Collection-Methods"><a href="#Collection-Methods" class="headerlink" title="Collection Methods"></a>Collection Methods</h3><ul>
<li><code>boolean add(E e)</code>  <code>boolean isEmpty()</code> <code>boolean remove(E e)</code> <code>boolean contains(Object o)</code> </li>
<li><code>void clear()</code> <code>int size()</code> </li>
<li><code>Object[] toArray()</code>:集合colletion转换成对象<strong>数组</strong> （返回Object数组是为了防止添加不同类型的对象）重载的<code>toArray(String[] strs)</code> 方法能够返回一个String数组<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240914230120510.png" alt="toArray"></li>
<li><code>void addAll(Collections&lt;E&gt; c2)</code> <code>c1.addAll(c2)</code> 把c2的数据全部加入c1中</li>
</ul>
<h3 id="Collection-遍历"><a href="#Collection-遍历" class="headerlink" title="Collection 遍历"></a>Collection 遍历</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = collection.iterator();<span class="comment">//默认在第一个对象</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;<span class="comment">//判断迭代器是否能继续指向下一个</span></span><br><span class="line"> System.out.println(it.next()); <span class="comment">//迭代器返回现在指向的对象，之后指向下一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 最好是一次<code>hasNext()</code>对应一次<code>next()</code></p>
<h4 id="for-Each增强循环"><a href="#for-Each增强循环" class="headerlink" title="for-Each增强循环"></a>for-Each增强循环</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; colle = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(String name:colle)&#123;</span><br><span class="line">&#125;<span class="comment">//colle代表要遍历的集合名，name代表集合中每个元素的名字</span></span><br><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String name:names)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果等同于迭代器Iterator</p>
<h4 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">colle.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span>&#123;</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">colle.forEach(s-&gt;System.out.println(s));</span><br><span class="line">colle.forEach(System.out::println);<span class="comment">//前后参数一样</span></span><br></pre></td></tr></table></figure>

<p>action已经实现了Consumer接口的accept方法</p>
<p>内部实现还是增强for循环，将colle集合中的元素t送到action的accept()处，相当于用元素t执行accept()方法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240914234023283.png" alt="forEach"></p>
<h3 id="List-支持索引"><a href="#List-支持索引" class="headerlink" title="List 支持索引"></a>List 支持索引</h3><p><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code> </p>
<ul>
<li><code>void add(int index, E e)</code>(add()重载)</li>
<li><code>E remove(int index)</code> 返回remove的数据</li>
<li><code>E get(int index)</code>返回指定索引的数据</li>
<li><code>E set(int index, E e)</code> 修改指定索引数据，返回原来的数据</li>
<li><code>List&lt;E&gt; sublist(int from, int to)</code> 返回一个list里面装有[from,to)部分的list</li>
</ul>
<h4 id="List-遍历"><a href="#List-遍历" class="headerlink" title="List 遍历"></a>List 遍历</h4><ul>
<li>for-Each-Loop Lambda Iterator</li>
<li>for循环（支持索引）</li>
</ul>
<h4 id="ArrayList-基于数组"><a href="#ArrayList-基于数组" class="headerlink" title="ArrayList 基于数组"></a>ArrayList 基于数组</h4><ul>
<li>基于<u><strong>数组</strong></u>实现 <strong>对象数组</strong> </li>
<li>查询速度快 (索引) O(1) 集合末端元素有时可以达到 O(1)</li>
<li>删除效率低，添加效率极低，基本都需要整体移动甚至扩容 都是 O(n) </li>
<li>有参构造：指定长度，不够再添</li>
</ul>
<p>适用场景：索引查询，数据量不大</p>
<p>数据量大还要频繁进行增删操作，不适合！</p>
<ol>
<li>动态扩容</li>
<li>创建指定大小</li>
<li>指定泛型，确保元素安全</li>
<li>线程不安全</li>
</ol>
<h5 id="ArrayList-扩容-源码分析：grow-int-minCapacity"><a href="#ArrayList-扩容-源码分析：grow-int-minCapacity" class="headerlink" title="ArrayList 扩容 源码分析：grow(int minCapacity)"></a>ArrayList <strong>扩容</strong> 源码分析：<code>grow(int minCapacity)</code></h5><p>三种创建方式：默认容量为 10</p>
<ol>
<li>空参：首先创建的是一个<mark>空</mark>数组 <em>懒加载的运用</em>   </li>
<li>参数为 n：创建<mark>容量为n<mark>的对象数组，0则创建空数组</li>
<li>参数为 collection：将 collection 的内容复制进入 新的 ArrayList 中</li>
</ol>
<ol>
<li><mark>无参构造，先使用一个长度为0的对象数组<mark> <ul>
<li><code>Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</code></li>
</ul>
</li>
<li><mark>添加首个元素，创建长度为10的对象数组<mark>  <ul>
<li><code>elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];</code></li>
</ul>
</li>
<li>存满后，再添加时创建扩容1.5倍的数组，原内容加进去<ul>
<li><code>newCap = oldCap + oldCap &gt;&gt; 1</code></li>
<li> <code>Arrays.copyof(elementData,newCap)</code></li>
</ul>
</li>
<li>一次加多个元素，addAll，1.5 倍或者10个放不下，新创建数组长度以实际为准<code>minCapacity</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, Object[] elementData, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入一个元素，此时元素个数size = 0，存放元素的数组容量 length = 0，因此正好符合扩容条件：<code>grow(int minCapacity)</code> 对于普通的add，此处 <code>minCapacity = size + 1</code>，也就是现元素个数+1</p>
<p><strong><mark>扩容逻辑<mark></strong></p>
<p>空数组扩容到<code>max</code>[ <mark>10<mark> , <code>minCapacity</code> ], <code>minCapacity</code>是用来应对<code>addAll()</code>的</p>
<p>非空数组扩容到<mark>原来的1.5倍<mark>，当然1.5倍导致溢出则扩容到minCapacity即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="comment">// 最小容量应为size+1, length为数组的大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;<span class="comment">//当前大小</span></span><br><span class="line">    <span class="comment">// 1. 如果是无参构造就是空数组: DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity &gt; <span class="number">0</span> || </span><br><span class="line">    	elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> ArraysSupport.newLength(oldCapacity,</span><br><span class="line">                minCapacity - oldCapacity, <span class="comment">/* minimum growth  */</span></span><br><span class="line">                oldCapacity &gt;&gt; <span class="number">1</span>  <span class="comment">/* preferred GROWTH 0.5倍 原长度*/</span>);</span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1.1 上面是空数组，那就是默认容量 10 和 size+1 进行比较 创建比较大的那个</span></span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">Object</span>[Math.max(DEFAULT_CAPACITY, minCapacity)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">newLength</span><span class="params">(<span class="type">int</span> oldLength,<span class="type">int</span> minGrowth,<span class="type">int</span> prefGrowth)</span> &#123;</span><br><span class="line">    <span class="comment">// preconditions not checked because of inlining</span></span><br><span class="line">    <span class="comment">// assert oldLength &gt;= 0</span></span><br><span class="line">    <span class="comment">// assert minGrowth &gt; 0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">prefLength</span> <span class="operator">=</span> oldLength + Math.max(minGrowth, prefGrowth); <span class="comment">// might overflow</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt; prefLength &amp;&amp; prefLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> prefLength;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// put code cold in a separate method</span></span><br><span class="line">        <span class="keyword">return</span> hugeLength(oldLength, minGrowth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理论上来说，最好在向 <code>ArrayList</code> 添加大量元素之前用 <code>ensureCapacity(minCapacity)</code> 方法，以减少增量重新分配的次数</p>
<h5 id="Vector-Deprecated"><a href="#Vector-Deprecated" class="headerlink" title="Vector(Deprecated)"></a><del>Vector(Deprecated)</del></h5><p><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，适用于频繁的查找工作，线程不安全 。</p>
<p><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，线程安全，但是并发性能较差。</p>
<h5 id="Stack-Deprecated"><a href="#Stack-Deprecated" class="headerlink" title="Stack(Deprecated)"></a><del>Stack(Deprecated)</del></h5><ul>
<li><code>Vector</code> 和 <code>Stack</code> 两者都是线程安全的，都是使用 <code>synchronized</code> 关键字进行同步处理。</li>
<li><code>Stack</code> 继承自 <code>Vector</code>，是一个后进先出的栈，而 <code>Vector</code> 是一个列表。</li>
</ul>
<p>随着 Java 并发编程的发展，<code>Vector</code> 和 <code>Stack</code> 已经被淘汰，推荐使用并发集合类（例如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。</p>
<h4 id="LinkedList-基于链表"><a href="#LinkedList-基于链表" class="headerlink" title="LinkedList 基于链表"></a>LinkedList 基于链表</h4><ul>
<li>基于<u>双向链表</u>实现，比单链表快</li>
<li>查询速度慢O(n)，<strong>对首尾元素操作极快</strong> O(1)</li>
<li>添加和删除不需要扩容，位移 不过还是O(n)的时间复杂度</li>
<li>线程不安全</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/linkedlist-unlink.jpg" alt="unlink 方法逻辑"></p>
<p>新增双链尾首尾特有方法：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915001950393.png" alt="LinkedList"></p>
<p>适用场景：</p>
<ul>
<li><p>对首尾的操作性能很高，LinkedList可以用来实现先进先出(FIFO)的 <strong>队列</strong></p>
<ul>
<li><p><code>LinkedList queue = new LinkedList&lt;&gt;();</code></p>
</li>
<li><p><code>Enqueue</code>⇔<code>addLast</code> <code>Dequeue</code>⇔<code>removeFirst</code></p>
</li>
</ul>
</li>
<li><p>可以实现<strong>Stack</strong> 栈</p>
<ul>
<li><p><code>LinkedList stack = new LinkedList&lt;&gt;();</code></p>
</li>
<li><p><code>push</code>⇔<code>addFirst</code> <code>Pop</code>⇔<code>removeFirst</code></p>
</li>
<li><p><code>push</code> <code>pop</code>方法已经由官方写入API可直接调用</p>
</li>
</ul>
</li>
</ul>
<h3 id="Queue：FIFO"><a href="#Queue：FIFO" class="headerlink" title="Queue：FIFO"></a>Queue：FIFO</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>add/remove实际上是对offer/poll的封装</p>
<ol>
<li><strong>添加元素的方法</strong></li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>add(E e)</code></strong></td>
<td>将指定元素插入队列，如果队列已满，则抛出 <code>IllegalStateException</code> 异常。</td>
</tr>
<tr>
<td><strong><code>offer(E e)</code></strong></td>
<td>将指定元素插入队列，如果队列已满，则返回 <code>false</code> 而不抛异常。</td>
</tr>
</tbody></table>
<p><strong>2. 移除元素的方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>remove()</code></strong></td>
<td>移除队列头部的元素，如果队列为空，则抛出 <code>NoSuchElementException</code> 异常。</td>
</tr>
<tr>
<td><strong><code>poll()</code></strong></td>
<td>移除队列头部的元素，如果队列为空，则返回 <code>null</code>。</td>
</tr>
</tbody></table>
<p><strong>3. 查看元素的方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>element()</code></strong></td>
<td>查看队列头部的元素，不移除。如果队列为空，则抛出 <code>NoSuchElementException</code> 异常。</td>
</tr>
<tr>
<td><strong><code>peek()</code></strong></td>
<td>查看队列头部的元素，不移除。如果队列为空，则返回 <code>null</code>。</td>
</tr>
</tbody></table>
<h4 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h4><ul>
<li><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循FIFO</li>
<li><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素，LinkedList就实现了Deque，因此可以用来模拟栈和队列<ul>
<li>Deque 常用的方法就是对头尾元素的 <code>add/remove/get</code> <code>offer/poll/peek</code>，前者会抛异常，后者不会抛异常只会返回 false(offer) 或者 null(poll/peek) 。</li>
<li>pop = removeFirst   push = addFirst。</li>
</ul>
</li>
</ul>
<h5 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h5><p>基于可变长的数组和双指针来实现，<code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</p>
<h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>
<p>这里列举其相关的一些要点：</p>
<ul>
<li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>
<li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li>
<li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li>
<li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li>
</ul>
<p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。</p>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>详见 JUC</p>
<h3 id="Set-不重复"><a href="#Set-不重复" class="headerlink" title="Set 不重复"></a>Set 不重复</h3><p><code>Set&lt;Integer&gt; set = new HashSet();</code>//无序</p>
<p><code>Set&lt;Integer&gt; set = new LinkedHashSet();</code> //有序</p>
<p><code>Set&lt;Integer&gt; set = new TreeSet()</code> //排序</p>
<h4 id="HashSet-无序"><a href="#HashSet-无序" class="headerlink" title="HashSet 无序"></a>HashSet 无序</h4><ul>
<li>每个对象都有哈希值，int类型，通过<code>hashCode()</code>返回</li>
<li>也可能相同，大部分情况下是相同的</li>
<li>增删改查性能较好，类比查字典，只要看到偏旁就能定位大概的位置</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915124422018.png" alt="JDK 8 之前的 HashSet">数据过多会导致链表过长，查询性能降低，然后就扩容，加载因子0.75*16=12，占到12个数据就开始扩容，2倍大小</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915125104423.png" alt="HashSet 底层结构"></li>
<li>二叉搜索树：小的存左边，大的存右边，一样的不存</li>
<li>平衡二叉树：左右高度差不超过1</li>
<li>红黑树：自平衡的二叉搜索树 </li>
<li>无序，不重复，无索引！<ul>
<li>内容一样的两个对象s1s2，HashSet认为他们不一样</li>
<li>对于HashSet可以重写对象类的<code>equals()</code>方法，比较对象的内容而不是地址，重写<code>hashCode()</code>方法根据对象的内容计算哈希值。<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915125944598.png" alt="equals hashcode"></li>
</ul>
</li>
</ul>
<h5 id="去重原理：Hashmap-put-k-v"><a href="#去重原理：Hashmap-put-k-v" class="headerlink" title="去重原理：Hashmap put(k,v)"></a>去重原理：Hashmap put(k,v)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: true if this set did not already contain the specified element</span></span><br><span class="line"><span class="comment">// 返回值：当 set 中没有包含 add 的元素时返回真</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而 map 的 put ，只有在key不存在时返回null，其他时候返回旧值，因此key不存在正好能够去重</p>
<h4 id="LinkedHashSet-有序"><a href="#LinkedHashSet-有序" class="headerlink" title="LinkedHashSet 有序"></a>LinkedHashSet 有序</h4><ul>
<li>在HashSet基础上，每个元素多了一个双链表机制记录前后位置，原来链表依然存在，双链表仅用来记录**<mark>添加<mark>先后顺序**</li>
<li>占用内存相对多</li>
</ul>
<h4 id="TreeSet-可自定义排序"><a href="#TreeSet-可自定义排序" class="headerlink" title="TreeSet 可自定义排序"></a>TreeSet 可自定义排序</h4><ul>
<li>不重复无索引，<strong>可排序</strong>。底层红黑树</li>
<li>对数值类型按照大小升序排序，对字符串类型按照首字符编号升序排序</li>
<li>自定义<code>Student</code>对象无法直接排序<ul>
<li><ol>
<li>让<code>Student</code>类实现<code>Comparable</code>接口，重写<code>int compareTo()</code>方法</li>
</ol>
</li>
<li><ol start="2">
<li><code>TreeSet</code>有参构造，用<code>Comparator</code>实现对象指定比较规则，2规则优先</li>
</ol>
</li>
<li>如果指定排序规则是年龄，年龄相等的是不会存的</li>
</ul>
</li>
</ul>
<h3 id="ConcurrentModificationException"><a href="#ConcurrentModificationException" class="headerlink" title="ConcurrentModificationException"></a><span id="concurrentmodificaiton">ConcurrentModificationException</span></h3><ul>
<li><p>遍历集合并删除集合中的元素时，会导致元素位置移动但索引没有及时更新导致的漏操作</p>
</li>
<li><p>迭代器会报错，<code>fori</code> 循环会正常执行但返回结果错误</p>
</li>
<li><p><code>fori</code> 循环：i– 、倒着遍历</p>
</li>
<li><p>迭代器：不能调用集合自己的删除，要调用迭代器自己的删除，相当于也是做了i–的操作</p>
</li>
<li><p>0     1    2    3<br>a     b    c    d</p>
<p>删除b以后，索引为1，下一步是i++，中间插一个i–让索引不变(正序遍历)<br>删除b以后，索引为1，下一步是i–，不影响正常的遍历（倒序遍历）</p>
</li>
</ul>
<p>迭代器遍历的是开始遍历那一刻拿到的集合拷贝，遍历期间原集合发生的修改迭代器不知道。</p>
<p><strong>不要<mark>在 forEach 循环里进行元素的 <code>remove/add</code> 操作<mark>。remove 元素请使用 <code>Iterator</code> 方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;Hollis&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> userNames.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iterator.next().equals(<span class="string">&quot;Hollis&quot;</span>)) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(userNames);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>removeIf：遍历并删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line">list.removeIf(filter -&gt; filter % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">/* 删除list中的所有偶数 */</span></span><br><span class="line">System.out.println(list); <span class="comment">/* [1, 3, 5, 7, 9] */</span></span><br></pre></td></tr></table></figure>

<p><strong><mark>如果并发操作<mark>，在使用iterator迭代的时候使用synchronized或者Lock进行同步，或者使用JUC</strong> </p>
<p>并发情况下使用juc的并发集合，这样的集合容器在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p>
<p>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul>
<li>可以不传参数，也可以传一个，两个多个，也可以传数组，接收数据比较灵活</li>
<li>对外是灵活接收数据，对内就是一个数组</li>
<li>一个参数列表只有一个可变参数，而且要放在最后</li>
</ul>
<h3 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915140018933.png" alt="Collections"></p>
<ul>
<li><code>addAll(Collection&lt;? super T&gt; c, T...elements)</code>为集合批量添加数据<ul>
<li>泛型属于多态写法，<code>Animal</code>的<code>List</code>可以接收猫<code>Cat</code>和狗<code>Dog</code>作为可变参数</li>
</ul>
</li>
<li><code>shuffle(List&lt;?&gt; list)</code> 打乱 <mark>list<mark> 的顺序</li>
<li><code>sort(List&lt;?&gt; list)</code> 帮助list排好序，自定义类要实现<code>Comparable</code>接口</li>
<li><code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code> 帮助list排好序,自定义排序规则 <code>Animal</code> 的<code>Comparator</code>可以给<code>Cat</code>排序</li>
</ul>
<p>重写T的toString方法，控制println的输出</p>
<h2 id="Map-双列-K-V"><a href="#Map-双列-K-V" class="headerlink" title="Map 双列 (K-V)"></a>Map 双列 (K-V)</h2><ul>
<li>键值对集合 <code>key-value</code></li>
<li><code>key</code>不允许重复 <code>value</code>允许重复</li>
</ul>
<ol>
<li><code>HashMap</code>无序、不重复、无索引,键相同的会覆盖值</li>
<li><code>LinkedHashMap</code>有序(添加顺序)、不重复、无索引</li>
<li><code>TreeMap</code>大小默认升序、不重复、无索引</li>
</ol>
<p><code>Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();</code></p>
<h3 id="Map-常用方法"><a href="#Map-常用方法" class="headerlink" title="Map 常用方法"></a>Map 常用方法</h3><ul>
<li><code>put(K key, V value)</code>把键值对加入Map</li>
<li><code>void clear()</code> <code>int size()</code> <code>boolean isEmpty()</code> </li>
<li><code>boolean containsKey(Object key)</code> 是否有某个键</li>
<li><code>boolean containsValue(V val)</code>是否有值<code>val</code> </li>
<li><code>V get(Object key)</code> 根据键获取值 不存在返回<code>null</code></li>
<li><code>V remove(Object key)</code>根据键获取值, 删除</li>
<li><code>Set&lt;K&gt; keySet()</code> 获取包含所有键的集合，无序不重复无索引</li>
<li><code>Collection&lt;V&gt; values()</code> 获取所有值的集合，<strong>可重复</strong> </li>
<li><code>map1.putAll(Map&lt;E&gt; map2)</code>map2所有元素加入map1，能覆盖的覆盖</li>
</ul>
<h3 id="Map-遍历方式"><a href="#Map-遍历方式" class="headerlink" title="Map 遍历方式"></a>Map 遍历方式</h3><ol>
<li><p>键找值</p>
<ol>
<li><code>keySet()</code> 获取所有键</li>
<li><code>V get(Object key)</code> 根据键找值</li>
</ol>
</li>
<li><p>键值对</p>
<ol>
<li><p><code>Map.Entry&lt;K,V&gt;</code> API自带的Entry类型把Key-Value看做一个整体</p>
</li>
<li><p><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code> 返回一个Set，包含所有Entry对象</p>
</li>
<li><p>增强for循环遍历<code>Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entryset</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry: entryset)&#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Lambda表达式(<strong>Most Simple</strong>)</p>
<ul>
<li><code>map.forEach((k,v)-&gt;&#123;System.out.println(k + &quot;+&quot; + v)&#125;)</code></li>
<li><code>forEach</code>方法的参数是<code>BiConsumer</code>接口的实现对象，要求重写<code>action</code>函数(遍历的时候要做的事情)</li>
<li><code>forEach</code>方法具体的实现：用增强for循环遍历键值对组成的的Set</li>
</ul>
</li>
</ol>
<h3 id="HashMap-无序"><a href="#HashMap-无序" class="headerlink" title="HashMap 无序"></a>HashMap 无序</h3><h4 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a><a href="#hashmap-%E5%92%8C-hashset-%E5%8C%BA%E5%88%AB">HashMap 和 HashSet 区别</a></h4><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p>
<table>
<thead>
<tr>
<th align="center"><code>HashMap</code></th>
<th align="center"><code>HashSet</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现了 <code>Map</code> 接口</td>
<td align="center">实现 <code>Set</code> 接口</td>
</tr>
<tr>
<td align="center">存储键值对</td>
<td align="center">仅存储对象</td>
</tr>
<tr>
<td align="center">调用 <code>put()</code>向 map 中添加元素</td>
<td align="center">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td>
</tr>
<tr>
<td align="center"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td>
<td align="center"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td>
</tr>
</tbody></table>
<ul>
<li>增删改查数据，性能都较好的集合</li>
<li>无序不重复无索引</li>
<li>Key依赖hashCode和equals保证键的唯一性</li>
<li>如果存储自定义对象，重写上述方法即可</li>
<li>HashSet实际上就是HashMap实现的，只关注键</li>
<li>线程不安全</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/jdk1.8_hashmap.png" alt="JDK 1.8 之后的内部结构-HashMap"></p>
<h4 id="HashTable-Deprecated"><a href="#HashTable-Deprecated" class="headerlink" title="HashTable(Deprecated)"></a><del>HashTable(Deprecated)</del></h4><p><code>Hashtable</code>：数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的。基本都是直接在方法中加<code>synchronized</code>，性能比ConcurrentHashMap弱很多。与 Hashmap相比线程安全，不支持null</p>
<h4 id="HashMap-遍历"><a href="#HashMap-遍历" class="headerlink" title="HashMap 遍历"></a>HashMap 遍历</h4><p><code>EntrySet</code> 之所以比 <code>KeySet</code> 的性能高是因为，<code>KeySet</code> 在循环时使用了 <code>map.get(key)</code>，而 <code>map.get(key)</code> 相当于又遍历了一遍 Map 集合去查询 <code>key</code> 所对应的值。为什么要用“又”这个词？那是因为<strong>在使用迭代器或者 for 循环时，其实已经遍历了一遍 Map 集合了，因此再使用 <code>map.get(key)</code> 查询时，相当于遍历了两遍</strong>。</p>
<p>而 <code>EntrySet</code> 只遍历了一遍 Map 集合，之后通过代码“Entry&lt;Integer, String&gt; entry = iterator.next()”把对象的 <code>key</code> 和 <code>value</code> 值都放入到了 <code>Entry</code> 对象中，因此再获取 <code>key</code> 和 <code>value</code> 值时就无需再遍历 Map 集合，只需要从 <code>Entry</code> 对象中取值就可以了。</p>
<p>所以，**<code>EntrySet</code> 的性能比 <code>KeySet</code> 的性能高出了一倍，因为 <code>KeySet</code> 相当于循环了两遍 Map 集合，而 <code>EntrySet</code> 只循环了一遍**。</p>
<h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>默认的<strong>数组长度</strong>为 16，也就是<strong>容量 or 桶数量（capacity / number of buckets）</strong></p>
<p>数据过多会导致链表过长，查询性能降低</p>
<p><strong>加载因子（loadfactor）</strong>为 0.75</p>
<p>元素个数达到<strong>阈值（threshold）</strong>: capacity*loadfactor = 16*0.75 = 12 ，扩容到原来的两倍</p>
<p>扩容后，需要将原数组中的所有元素重新计算哈希值，并放入新的桶中，这个过程称为<strong>rehash</strong>，会有性能损耗，因此要尽量减少扩容次数。</p>
<h5 id="为什么容量必须是-2-n"><a href="#为什么容量必须是-2-n" class="headerlink" title="为什么容量必须是 2^n^"></a>为什么容量必须是 2^n^</h5><ol>
<li>容量cap 参与 hash % cap 运算，相当于截取低位，cap 如果是2的幂次方，cap-1就是全1，hash % cap = hash &amp; (cap-1)，通过位运算提高了效率。</li>
<li>还有一方面，因为cap-1是全1，因此hash的每一位都能充分参与运算，降低了哈希冲突的风险。</li>
<li>扩容后只需检查哈希值高位的变化来决定元素的新位置，要么位置不变（高位为 0），要么就是移动到新位置（高位为 1，原索引位置+原容量）。详见下文的<a href="#rehash">rehashing</a></li>
</ol>
<h4 id="链表转红黑树"><a href="#链表转红黑树" class="headerlink" title="链表转红黑树"></a>链表转红黑树</h4><p>JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，<strong>如果当前数组的长度小于 64</strong>，那么会选择<strong>先进行数组扩容</strong>，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="FIELDs-属性字段"><a href="#FIELDs-属性字段" class="headerlink" title="FIELDs 属性字段"></a>FIELDs 属性字段</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化容量（数组长度），必须是2的幂次方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大容量，必须小于2的30次方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认加载因子 LoadFactor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表转换成树的阈值（链表长度）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树转换回链表的阈值（链表长度）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表转换成树的阈值（数组容量）</span></span><br><span class="line"><span class="comment"> * 应该至少为TREEIFY_THRESHOLD的4倍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<h5 id="节点-Node-lt-K-V-gt"><a href="#节点-Node-lt-K-V-gt" class="headerlink" title="节点 Node&lt;K,V&gt;"></a>节点 Node&lt;K,V&gt;</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">// 哈希值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 下一个节点</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 设置新的返回旧的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;value = newValue;<span class="keyword">return</span> oldValue;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> Map.Entry&lt;?, ?&gt; e</span><br><span class="line">                &amp;&amp; Objects.equals(key, e.getKey())</span><br><span class="line">                &amp;&amp; Objects.equals(value, e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Contructor"><a href="#Contructor" class="headerlink" title="Contructor"></a>Contructor</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment"> * for keySet() and values().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> * 数组 table 每个 Entry 都是一个 节点Node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructors</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定“容量大小”和“负载因子”的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    	initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line"><span class="comment">// 初始容量暂时存放到 threshold ，在resize中再赋值给 newCap 进行table初始化</span></span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> (n &lt; <span class="number">0</span>)? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>四个构造方法中，都初始化了负载因子 loadFactor，由于 HashMap 中没有 capacity 这样的字段，即使指定了初始化容量 initialCapacity ，也只是通过 tableSizeFor() 扩容到与 initialCapacity 最接近的 2 的幂次方大小，然后<strong>暂时赋值给 threshold ，后续通过 resize 方法将 threshold 赋值给 newCap 进行 table 的初始化。</strong> </p>
<h6 id="使用另一个map构造-putMapEntries-map"><a href="#使用另一个map构造-putMapEntries-map" class="headerlink" title="使用另一个map构造 putMapEntries(map)"></a>使用另一个map构造 <code>putMapEntries(map)</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// s 是实际个数，dt 就是添加 s 个元素的最小容量 ceil 向上取整</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">dt</span> <span class="operator">=</span> Math.ceil(s / (<span class="type">double</span>)loadFactor);</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((dt &lt; (<span class="type">double</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)dt : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 如果超过</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 已经初始化，只要超过阈值就要 resize</span></span><br><span class="line">            <span class="comment">// Because of linked-list bucket constraints, we cannot</span></span><br><span class="line">            <span class="comment">// expand all at once, but can reduce total resize</span></span><br><span class="line">            <span class="comment">// effort by repeated doubling now vs later</span></span><br><span class="line">            <span class="keyword">while</span> (s &gt; threshold &amp;&amp; table.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="getNode"><a href="#getNode" class="headerlink" title="getNode()"></a><code>getNode()</code></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n, hash; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; (hash = hash(key))]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// 快速检查头节点</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; </span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e; <span class="comment">// 从头节点开始遍历。</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="putVal"><a href="#putVal" class="headerlink" title="putVal()"></a><code>putVal()</code></h5><p>体现了懒加载的思想，只有真正put的时候才初始化资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 1. 如果没有初始化，先调用resize初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 2.1 没有哈希冲突的情况</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 2.2 出现了哈希冲突/值重复，在else逻辑里return</span></span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="comment">// .......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 没有哈希冲突或者值重复，元素自增与扩容策略</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);<span class="comment">// 用于LinkedHashMap支持LRU实现,HashMap无用</span></span><br><span class="line">    <span class="comment">// 4. key值不存在,则返回值是null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="哈希冲突-值重复"><a href="#哈希冲突-值重复" class="headerlink" title="哈希冲突/值重复"></a>哈希冲突/值重复</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p 是链表/树的第一个节点</span></span><br><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="comment">/* 1. 快速判断第一个节点table[i]的key是否与插入的key一样 先判断 hash </span></span><br><span class="line"><span class="comment">				若相同就将现在的节点p赋给e，然后在4中处理。     */</span> 		</span><br><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp; <span class="comment">// key 的 hash </span></span><br><span class="line"><span class="comment">// 1.5 短路逻辑：先用 == 比较地址，地址不同再用equals比较内容（K需要重写equals）</span></span><br><span class="line">	((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br><span class="line"><span class="comment">// 2. 树节点去执行树的逻辑</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="comment">// 3. 链表节点</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="comment">// 3.0 边遍历边比较是否出现了重复key, binCount+1 能得出链表长度</span></span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 3.1 一直遍历到了尾部，说明肯定没有重复的，在链表尾端创建新 Node</span></span><br><span class="line">            p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 3.2 如果到了 TREEIFY_THRESHOLD 就触发 treeifyBin 扩容或</span></span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">            <span class="comment">// 3.3 跳出循环 e == null, 不会走重复的逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.5 判断key是否重复 重复就直接跳出，去4处理key的重复情况 e!=null</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        p = e;<span class="comment">// 遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. key 重复 应对1和3.5的重复情况 </span></span><br><span class="line"><span class="comment">// 	在putIfAbsent中，onlyIfAbsent = true, 在put中，onlyIfAbsent = false</span></span><br><span class="line"><span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">    <span class="comment">// putIfAbsent只有原值null才能赋值</span></span><br><span class="line">    <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>) </span><br><span class="line">        e.value = value;</span><br><span class="line">    afterNodeAccess(e);<span class="comment">//回调方法，只在LinkedHashMap中实现,可维护访问顺序(如LRU)</span></span><br><span class="line">    <span class="comment">// 4.5 key值如果存在,则会返回原先被替换掉的value值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="removeNode"><a href="#removeNode" class="headerlink" title="removeNode()"></a><code>removeNode()</code></h5><p>remove主要有两个：一个是remove(key)，返回值为被删除的value，如果节点不存在则返回null</p>
<p>另一个是remove(key,value) 用来表示只有key对应的值为value时才移除，返回值为boolean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">/**  1. 寻找匹配到key的节点</span></span><br><span class="line"><span class="comment">      *  短路条件1: table 不为空(已初始化过)</span></span><br><span class="line"><span class="comment">      *  短路条件2: key 对应的桶不为空</span></span><br><span class="line"><span class="comment">      *  同时满足上述两个条件才会进入正式判断，否则直接返回 null</span></span><br><span class="line"><span class="comment">      *  p 现在是桶的第一个节点。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 1.1 快速检查: 先检查桶的第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">// 1.2 开始遍历， e 相当于 tmp</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">// 树节点</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">// 链表节点</span></span><br><span class="line">                <span class="keyword">do</span> &#123; </span><br><span class="line">                    <span class="comment">// 1.2.1 找到了节点，直接break，将e赋给node</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;<span class="comment">//  p是e的前驱</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 2. 正式开始删除节点</span></span><br><span class="line"><span class="comment">          * node 为将要删除的节点</span></span><br><span class="line"><span class="comment">          * remove(k,v)-&gt;matchValue=true | remove(k)-&gt;matchValue = false</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">// 对应 1.1 快速检查, 将node.next赋值给tab[i]</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//对应 1.2.1, p 是 node 的前驱节点， 直接将node.next赋给p.next</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;<span class="comment">// 减小容量</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;<span class="comment">// 返回被删除的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="resize"><a href="#resize" class="headerlink" title="resize()"></a><code>resize()</code></h5><p>用于初始化或扩容，初始化就调用属性字段里面的 threshold 初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//—————————扩容——————————</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩容两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// threshold * 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//————————初始化——————————</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">    <span class="comment">// 创建时指定了初始化容量或者负载因子 就会把算出的容量暂时存放到threshold中</span></span><br><span class="line">    <span class="comment">// 			在这里进行新容量的初始化</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">// 创建时无参构造，就使用默认的 capacity 和 threshold 对容量和阈值进行初始化</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建时指定了初始化容量或者负载因子，在这里进行新阈值的初始化，</span></span><br><span class="line">        <span class="comment">// 或者扩容前的旧容量小于16，在这里计算新的resize上限</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; <span class="comment">// 新的阈值。</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">// 正式创建新的数组, 可以看到分配大小为 newCap</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// oldTab 的 rehash</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新的 Table 数组;</span></span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="rehashing-oldTab"><a href="#rehashing-oldTab" class="headerlink" title="rehashing oldTab"></a><span id="rehash">rehashing oldTab</span></h6><p>索引本质还是哈希值对容量取余。</p>
<p>HashMap 扩容时采用的容量是 <strong>2 的幂次方</strong>，它的二进制特性使得新容量只在<strong>高位多出一位 1</strong>。</p>
<p>元素 A B 的哈希值分别为 2 和 6，容量从 4 扩容到 8：</p>
<ul>
<li><code>0010 &amp; 0011 = 0010</code> <code>0110 &amp; 0011 = 0010</code>  旧索引均为 2</li>
<li><code>0010 &amp; 0111 = 0010</code> <code>0110 &amp; 0111 = 0110</code>  新索引分别为 2 和 6</li>
</ul>
<p><strong>二者的区别仅在于高位是否为 1</strong>：避免了复杂的哈希重算，仅通过简单的位运算就完成了分配。</p>
<p>本质上还是取hash值的低位，原来只取低两位，只有这两位参与运算，新的需要取低三位，那么此时直接和原容量 <code>0100</code> 相与，看看第三位是不是0，如果第三位是0，索引当然不变，如果第三位是1，新的索引就是原索引+原容量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;<span class="comment">// tmp</span></span><br><span class="line">    <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="literal">null</span>)<span class="comment">// 如果没有后继节点，直接映射到新的哈希位即可</span></span><br><span class="line">            newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">		<span class="comment">// e.hash &amp; (newCap - 1) 等价于 e.hash % newCap</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">// 树：</span></span><br><span class="line">            ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order 保证原来的顺序</span></span><br><span class="line">            Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>; <span class="comment">// 低索引，索引不变</span></span><br><span class="line">            Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>; <span class="comment">// 高索引，索引变化</span></span><br><span class="line">            Node&lt;K,V&gt; next;</span><br><span class="line">            <span class="comment">// 链表尾插法</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                next = e.next;</span><br><span class="line">                <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 还在原桶</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                        loHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 换到新桶</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                        hiHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 在旧桶的，索引不变</span></span><br><span class="line">                loTail.next = <span class="literal">null</span>;</span><br><span class="line">                newTab[j] = loHead;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 在新桶的，新索引为原索引+原容量</span></span><br><span class="line">                hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                newTab[j + oldCap] = hiHead;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newTab;</span><br></pre></td></tr></table></figure>

<h6 id="链表尾插法-防止多线程死循环"><a href="#链表尾插法-防止多线程死循环" class="headerlink" title="链表尾插法 防止多线程死循环"></a><strong>链表尾插法</strong> 防止多线程死循环</h6><p>JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</p>
<p>为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 <code>HashMap</code>，因为多线程下使用 <code>HashMap</code> 还是会存在数据覆盖的问题。并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</p>
<blockquote>
<p><code>if (tail == null)     head = e; </code></p>
<p><code>else tail.next = e;</code>    </p>
<p><code>tail = e;</code>    </p>
</blockquote>
<h5 id="treeifyBin"><a href="#treeifyBin" class="headerlink" title="treeifyBin()"></a><code>treeifyBin()</code></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 如果容量没有超过阈值64，优先扩容！</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedHashMap-有序"><a href="#LinkedHashMap-有序" class="headerlink" title="LinkedHashMap 有序"></a>LinkedHashMap 有序</h3><ul>
<li>有序（添加顺序） 不重复 无索引</li>
<li>HashMap加了双链表机制记录添加顺序</li>
<li>LinkedHashSet实际上就是LinkedHashMap实行的</li>
</ul>
<p>继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看</p>
<h3 id="TreeMap-可自定义排序-定向搜索"><a href="#TreeMap-可自定义排序-定向搜索" class="headerlink" title="TreeMap 可自定义排序 定向搜索"></a>TreeMap 可自定义排序 定向搜索</h3><ul>
<li>基于红黑树，TreeSet跟TreeMap原理一样</li>
<li>排序：自定义排序规则<ul>
<li>自定义的类实现<code>Comparable</code>接口，重写 <code>int compareTo(Object o)</code>方法</li>
<li>TreeMap的有参构造 参数是<code>Comparator</code>的实现对象，重写了<code>int compare()</code>方法</li>
</ul>
</li>
</ul>
<h4 id="集合嵌套"><a href="#集合嵌套" class="headerlink" title="集合嵌套"></a>集合嵌套</h4><p><code>Map&lt;String,List&lt;String&gt;&gt; cityMap = new HashMap&lt;&gt;();</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915170039061.png" alt="嵌套"></p>
<h2 id="Arrays-数组操作"><a href="#Arrays-数组操作" class="headerlink" title="Arrays 数组操作"></a>Arrays 数组操作</h2><ul>
<li><p><code>toString(Object[] arr)</code> 返回一个数组字符串，每个元素调用<code>toString()</code>转换成字符串，用<code>[,,,]</code>拼接成一个总字符串</p>
</li>
<li><p> <code>copyOfRange(Object[] arr, from, to)</code> 返回值为数组， 内容为arr中索引 <strong>[from, to)</strong> 的部分</p>
</li>
<li><p><code>copyOf(Object[] arr, int newlength)</code> 返回值为数组，内容为arr的内容，长度为newlength，不够的用0补齐，索引超出的截断</p>
</li>
<li><p><code>setAll</code>  第二个参数是接口<code>IntToDoubleFunction</code>的实现对象，重写了<code>applyAsDouble(int value)</code>方法，value是数组的索引，返回对数组中内容进行操作的结果，图中是将数组内容乘以0.8。这个对象传进来以后，对数组进行遍历，都用<code>applyAsDouble</code>的方法进行操作。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913170741004.png" alt="applyAsDouble"></p>
</li>
<li><p><code>sort([] arr)</code> 对arr升序排序(默认升序)</p>
</li>
<li><p><code>asList()</code>:只能加<strong>引用类型</strong>，基本数据类型需要改成包装类，并且返回的<code>List</code>是不能运用<code>add remove clear</code>方法的，这个<code>list</code>是<code>AbstractList</code>的子类，如果要访问<code>utils</code>只能将返回的这个<code>List</code>添加到<code>new ArrayList&lt;&gt;()</code>作为有参构造</p>
</li>
</ul>
<h3 id="对象数组排序"><a href="#对象数组排序" class="headerlink" title="对象数组排序"></a>对象数组排序</h3><p><strong>自己指定比较规则</strong> </p>
<ul>
<li><p>方法1：对象类实现<code>Comparable&lt;E&gt;</code>这个泛型接口，类中重写<code>int compareTo(E e)</code> 方法，将E改为自己的对象类型。</p>
<ul>
<li>约定，左边大于右边 return 正整数，小于 return 负整数，等于 return 0;（升序排序）</li>
<li><code>return this.age - o.age</code>  注意返回值是int double可以调用<code>Double.compare(o1.height, o2.height)</code></li>
<li>调用<code>Arrays.sort(students)</code>即可</li>
</ul>
</li>
<li><p>方法2：实现<code>Comparator</code>这个泛型接口，运用</p>
<ul>
<li><p>sort有一个重载函数，第一个参数是对象数组<code>T[] arr</code>，第二个参数是<code>Comparator&lt;? super T&gt; comparator</code></p>
</li>
<li><p>泛型接口做参数用匿名内部类实现，类中重写<code>int compare(T o1,T o2)</code>方法，同时注意返回的是int</p>
</li>
</ul>
</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Students&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(o1.height,o2.height);<span class="comment">//升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>ArrayList有自己的sort方法，实现同Comparator，可以免去泛型的指定</li>
</ul>
<h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><ul>
<li>需要有<strong>数据源</strong>，集合/数组等</li>
<li>调用流水线的方法对集合处理、计算</li>
<li>支持链式方法</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915171033434-1735476275516-27.png" alt="stream 流"></p>
<p>得到流，filter forEach</p>
<h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><h3 id="获取Stream流"><a href="#获取Stream流" class="headerlink" title="获取Stream流"></a>获取Stream流</h3><ul>
<li>流的泛型就是集合中元素的类型</li>
<li><strong>集合</strong>：<code>set.stream()</code> </li>
<li><strong>数组</strong>：<ul>
<li><code>Arrays.stream(T[] array)</code></li>
<li><code>Stream&lt;T&gt;.of(T...values)</code> </li>
</ul>
</li>
<li>Map：处理键用<code>keySet</code>，处理值用<code>values</code> Map.Entry用<code>entrySet</code> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915171810424-1735476275516-28.png" alt="entrySet"></li>
</ul>
<h3 id="中间方法"><a href="#中间方法" class="headerlink" title="中间方法"></a>中间方法</h3><ul>
<li>返回新的Stream流支持链式编程</li>
<li><code>filter</code>:接口的实现<code>filter(s-&gt;s.getAge&gt;=23 &amp;&amp; s.getAge&lt;=30)</code>重写<code>boolean test()</code>方法返回值是一个布尔变量。<strong>筛选条件</strong> s就代表集合中的元素</li>
<li><code>sorted</code>:无参数默认根据值升序排序，有参数（实现<code>Comparator</code>接口并重写<code>int compare(o1,o2)</code>）自定义排序规则。<strong>排序</strong></li>
<li><code>limit(long maxSize)</code>:取前3个对象 </li>
<li><code>skip(long n)</code>:跳过前n个对象，“指针”移动到对应位置，可以实现逻辑分页</li>
<li><code>distinct()</code>:去重</li>
<li><code>map(mapper)</code>:把集合中元素映射，mapper <code>map(Student::getName)</code> <code>map(s-&gt;s.getName())</code> 把集合中的元素 通过映射方法<code>mapper</code> 转换成对应元素</li>
<li><code>distinct()</code>:去重复，<strong>自定义</strong>类型对象如果希望对比内容，应该重写<code>hashCode()</code> <code>equals()</code>方法</li>
<li><code>Stream.concat(st1,st2)</code>:合并两个流内容,返回新的流</li>
<li><code>boxed()</code> 基本数据类型装箱操作</li>
</ul>
<h3 id="终结方法-void"><a href="#终结方法-void" class="headerlink" title="终结方法 void"></a>终结方法 void</h3><ul>
<li>（没有返回值）</li>
<li><code>void forEach(action)</code>: <code>forEach(s-&gt;System.out.println(s))</code> 元素s -&gt; 指定s想做的事情</li>
<li><code>long count()</code>: 返回经过前面处理以后集合剩下的元素个数</li>
<li><code>max((o1,o2)-&gt;Double.compare(o1.getScore(),o2.getScore()))</code> </li>
<li><code>min()</code>同<code>max()</code> 实现<code>Comparator</code></li>
<li><code>get()</code>:用于在<code>min max</code>后接收对象</li>
<li><code>collect(Collectors.toList())</code> <code>collect(Collectors.toSet())</code> 把流收集起来转换成集合</li>
<li><code>collect(Collectors.toMap(a-&gt;a.getName() , a-&gt;a.getHeight()))</code> 两个接口做参数，Lambda表达式。如果遇到<code>key</code>冲突，<code>toMap</code>需要调用重载函数，启用第三个参数，<code>(o1,o2)-&gt;o2</code>表示前后<code>key</code>冲突时，后添加的<code>value</code>会覆盖之前的<code>value</code></li>
<li><code>collect(Collectors.groupingBy(Shop::getTypeId))</code>把流收集起来，并按照typeId分组，返回一个typeId:集合Map</li>
<li><code>toArray()</code>将流中的元素收集到一个<code>Object</code><strong>数组中</strong> </li>
<li><code>toArray(len -&gt; new Student[len])</code>将流中的元素收集到一个指定<code>Student</code>类型的数组中 方法引用<code>toArray(Student[]::new)</code> 此处参数是<code>IntFunction&lt;A[]&gt;</code>接口的实现对象<code>generator</code> 重写函数需要<code>return</code>一个对应类型的数组，故可以用此写法</li>
</ul>
<h3 id="toList-amp-collect-Collectors-toList"><a href="#toList-amp-collect-Collectors-toList" class="headerlink" title="toList() &amp; collect(Collectors.toList())"></a>toList() &amp; collect(Collectors.toList())</h3><ul>
<li>确定其是一个不再被set/add/remove的list 可使用 Stream <code>toList</code>; 如果使用<code>collect(Collectors.toList())</code> ,sonar或idea自带以及第三方的一些code checker会爆warning, 以本人经验，可以使用<code>collect(Collectors.toCollection(ArrayList::new))</code>来代替</li>
</ul>
<p>另外ListOf也是返回的不可增删改的List</p>
<p>Lambda表达式省略规则 REVIEW</p>
<ul>
<li><p>只有一个参数可以省略<code>()</code> ，没有参数不能省略</p>
</li>
<li><p><code>-&gt;</code>后是具体的函数重写，多条语句需要<code>&#123;&#125;</code> <code>;</code> 单条语句可以省略分号</p>
<ul>
<li>单条语句分为有返回值和无返回值，只有一行<code>return</code>的可以省略<code>return</code>关键字，没有返回值的比如输出<code>System.out.println(s)</code> 就要注意了</li>
<li><code>a-&gt;a.getName()</code> 要么getName()的返回值 matters 要么没有返回值 </li>
</ul>
</li>
<li><p>方法引用</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Item, String&gt; getNameFunction = item -&gt; item.getName();</span><br><span class="line"></span><br><span class="line"><span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> getNameFunction.apply(item);  <span class="comment">// 返回 &quot;Apple&quot;</span></span><br><span class="line"></span><br><span class="line">R <span class="title function_">apply</span><span class="params">(T t)</span>;<span class="comment">//抽象方法 给一个T，返回R类型</span></span><br><span class="line">String <span class="title function_">apply</span><span class="params">(Item item)</span>;<span class="comment">//泛型将接口具体化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">键：return 键 </span></span><br><span class="line"><span class="comment">值：return 值 </span></span><br><span class="line"><span class="comment">转换成 Lambda 表达式 调用的函数必须有返回值的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>操作数组：最终的目的仍然是数组、集合</p>
<h1 id="集合最佳实践"><a href="#集合最佳实践" class="headerlink" title="集合最佳实践"></a>集合最佳实践</h1><p>（1）根据需要选择正确的集合类型。比如，如果指定了大小，我们会选用Array而非ArrayList。如果我们想根据插入顺序遍历一个Map，我们需要使用TreeMap。如果我们不想重复，我们应该使用Set。</p>
<p>（2）一些集合类允许指定初始容量，所以如果我们能够估计到存储元素的数量，我们可以使用它，就避免了重新哈希或大小调整。</p>
<p>（3）基于接口编程，而非基于实现编程，它允许我们后来轻易地改变实现。</p>
<p>（4）总是使用类型安全的泛型，避免在运行时出现ClassCastException。</p>
<p>（5）使用JDK提供的不可变类作为Map的key，可以避免自己实现hashCode()和equals()。</p>
<p>（6）尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的实现。它将会提供代码重用性，它有着更好的稳定性和可维护性。</p>
<h2 id="集合判空"><a href="#集合判空" class="headerlink" title="集合判空"></a>集合判空</h2><p>这是因为 <code>isEmpty()</code> 方法的可读性更好，并且时间复杂度为 <code>O(1)</code>。</p>
<p>绝大部分我们使用的集合的 <code>size()</code> 方法的时间复杂度也是 <code>O(1)</code>，不过，也有很多复杂度不是 <code>O(1)</code> 的，比如 <code>java.util.concurrent</code> 包下的 <code>ConcurrentLinkedQueue</code>。<code>ConcurrentLinkedQueue</code> 的 <code>isEmpty()</code> 方法通过 <code>first()</code> 方法进行判断，其中 <code>first()</code> 方法返回的是队列中第一个值不为 <code>null</code> 的节点（节点值为<code>null</code>的原因是在迭代器中使用的逻辑删除）</p>
<h2 id="集合遍历-iterator-并发修改异常"><a href="#集合遍历-iterator-并发修改异常" class="headerlink" title="集合遍历 iterator 并发修改异常"></a><a href="#concurrentmodificaiton">集合遍历 iterator 并发修改异常</a></h2><h2 id="集合转-Map"><a href="#集合转-Map" class="headerlink" title="集合转 Map"></a>集合转 Map</h2><p>**在使用 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。 **</p>
<h2 id="集合转数组"><a href="#集合转数组" class="headerlink" title="集合转数组"></a>集合转数组</h2><p><code>toArray(T[] array)</code> 方法的参数是一个泛型数组，如果 <code>toArray</code> 方法中没有传递任何参数的话返回的是 <code>Object</code>类 型数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] s= <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;lazy&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;over&quot;</span>, <span class="string">&quot;jumps&quot;</span>, <span class="string">&quot;fox&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="string">&quot;quick&quot;</span>, <span class="string">&quot;A&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line"><span class="comment">//没有指定类型的话会报错</span></span><br><span class="line">s=list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>由于 JVM 优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型</p>
<h2 id="数组转集合"><a href="#数组转集合" class="headerlink" title="数组转集合"></a>数组转集合</h2><p><strong><code>Arrays.asList()</code>是泛型方法，传递的数组必须是对象数组，而不是基本类型。</strong> </p>
<p>toList() &amp; collect(Collectors.toList())</p>
<p><code>Arrays.asList()</code> 或者流的<code>toList()</code>或者<code>List.of()</code>，得到的List只能读，不能进行修改操作，因为这个list是AbstarctList的实现类，并没有实现修改的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></span><br><span class="line"><span class="type">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p><code>List list = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</code> 也可以</p>
]]></content>
      <categories>
        <category>jdk</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马点评项目</title>
    <url>/2024/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/</url>
    <content><![CDATA[<h2 id="开篇导读"><a href="#开篇导读" class="headerlink" title="开篇导读"></a>开篇导读</h2><p>亲爱的小伙伴们大家好，马上咱们就开始实战篇的内容了，相信通过本章的学习，小伙伴们就能理解各种redis的使用啦，接下来咱们来一起看看实战篇我们要学习一些什么样的内容</p>
<ul>
<li>短信登录</li>
</ul>
<p>这一块我们会使用redis TOKEN共享session来实现</p>
<ul>
<li>商户查询缓存</li>
</ul>
<p>通过本章节，我们会理解缓存击穿，缓存穿透，缓存雪崩等问题，让小伙伴的对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容</p>
<ul>
<li>优惠卷秒杀</li>
</ul>
<p>通过本章节，我们可以学会Redis的计数器功能， 结合Lua完成高性能的redis操作，同时学会Redis分布式锁的原理，包括Redis的三种消息队列</p>
<ul>
<li>附近的商户</li>
</ul>
<p>我们利用Redis的GEOHash来完成对于地理坐标的操作</p>
<ul>
<li>UV统计</li>
</ul>
<p>主要是使用Redis来完成统计功能</p>
<ul>
<li>用户签到</li>
</ul>
<p>使用Redis的BitMap数据统计功能</p>
<ul>
<li>好友关注</li>
</ul>
<p>基于Set集合的关注、取消关注，共同关注等等功能，这一块知识咱们之前就讲过，这次我们在项目中来使用一下</p>
<ul>
<li>打人探店</li>
</ul>
<p>基于List来完成点赞列表的操作，同时基于SortedSet来完成点赞的排行榜功能</p>
<p>以上这些内容咱们统统都会给小伙伴们讲解清楚，让大家充分理解如何使用Redis</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653056228879.png" alt="1653056228879"></p>
<h2 id="短信登录：分布式session-token-redis"><a href="#短信登录：分布式session-token-redis" class="headerlink" title="短信登录：分布式session (token+redis)"></a>短信登录：分布式session (token+redis)</h2><h3 id="导入黑马点评项目"><a href="#导入黑马点评项目" class="headerlink" title="导入黑马点评项目"></a>导入黑马点评项目</h3><h4 id="导入SQL"><a href="#导入SQL" class="headerlink" title="导入SQL"></a>导入SQL</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653057872536.png" alt="1653057872536"></p>
<h4 id="有关当前模型"><a href="#有关当前模型" class="headerlink" title="有关当前模型"></a>有关当前模型</h4><p>手机或者app端发起请求，请求我们的nginx服务器，nginx基于七层模型走的事HTTP协议，可以实现基于Lua直接绕开tomcat访问redis，也可以作为静态资源服务器，轻松扛下上万并发， 负载均衡到下游tomcat服务器，打散流量，我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，所以nginx是整个项目中重要的一环。</p>
<p>在tomcat支撑起并发流量后，我们如果让tomcat直接去访问Mysql，根据经验Mysql企业级服务器只要上点并发，一般是16或32 核心cpu，32 或64G内存，像企业级mysql加上固态硬盘能够支撑的并发，大概就是4000起~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满，容易崩溃，所以我们在高并发场景下，会选择使用mysql集群，同时为了进一步降低Mysql的压力，同时增加访问的性能，我们也会加入Redis，同时使用Redis集群使得Redis对外提供更好的服务。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653059409865.png" alt="1653059409865"></p>
<h4 id="导入后端项目"><a href="#导入后端项目" class="headerlink" title="导入后端项目"></a>导入后端项目</h4><p>在资料中提供了一个项目源码：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653060237073.png" alt="1653060237073"></p>
<h4 id="导入前端工程"><a href="#导入前端工程" class="headerlink" title="导入前端工程"></a>导入前端工程</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653060337562.png" alt="1653060337562"></p>
<h4 id="运行前端项目"><a href="#运行前端项目" class="headerlink" title="运行前端项目"></a>运行前端项目</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653060588190.png" alt="1653060588190"></p>
<h3 id="基于Session实现登录流程"><a href="#基于Session实现登录流程" class="headerlink" title="基于Session实现登录流程"></a>基于Session实现登录流程</h3><p>cookie不安全，session绝对安全</p>
<p><strong>发送验证码：</strong> </p>
<p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号</p>
<p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</p>
<p><strong>短信验证码登录、注册：</strong></p>
<p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p>
<p><strong>校验登录状态:</strong></p>
<p>用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653066208144.png" alt="1653066208144"></p>
<h3 id="实现发送短信验证码功能"><a href="#实现发送短信验证码功能" class="headerlink" title="实现发送短信验证码功能"></a>实现发送短信验证码功能</h3><p><strong>页面流程</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653067054461.png" alt="1653067054461"></p>
<p><strong>具体代码如下</strong></p>
<p><strong>贴心小提示：</strong></p>
<p>具体逻辑上文已经分析，我们仅仅只需要按照提示的逻辑写出代码即可。</p>
<ul>
<li>发送验证码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.符合，生成验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.保存验证码到 session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;code&quot;</span>,code);</span><br><span class="line">    <span class="comment">// 5.发送验证码</span></span><br><span class="line">    log.debug(<span class="string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);</span><br><span class="line">    <span class="comment">// 返回ok</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>登录</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.校验验证码</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheCode</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="keyword">if</span>(cacheCode == <span class="literal">null</span> || !cacheCode.toString().equals(code))&#123;</span><br><span class="line">         <span class="comment">//3.不一致，报错</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一致，根据手机号查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//不存在，则创建</span></span><br><span class="line">        user =  createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.保存用户信息到session中</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现登录拦截功能"><a href="#实现登录拦截功能" class="headerlink" title="实现登录拦截功能"></a>实现登录拦截功能</h3><p><strong>温馨小贴士：tomcat的运行原理</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653068196656.png" alt="1653068196656"></p>
<p>当用户发起请求时，会访问我们像tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应</p>
<p>通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据</p>
<p><strong>温馨小贴士：关于threadlocal</strong></p>
<p>如果小伙伴们看过threadLocal的源码，你会发现在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，所以可以通过这种方式来做到线程隔离</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653068874258.png" alt="1653068874258"></p>
<p>拦截器代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">//1.获取session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//2.获取session中的用户</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">//3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="comment">//4.不存在，拦截，返回401状态码</span></span><br><span class="line">              response.setStatus(<span class="number">401</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.存在，保存用户信息到Threadlocal</span></span><br><span class="line">        UserHolder.saveUser((User)user);</span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让拦截器生效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// token刷新的拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="隐藏用户敏感信息"><a href="#隐藏用户敏感信息" class="headerlink" title="隐藏用户敏感信息"></a>隐藏用户敏感信息</h3><p>我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了</p>
<p>Data Transfer Object 不包含业务逻辑，只包含传输时必要的字段，精简敏感信息</p>
<p><strong>在登录方法处修改</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//7.保存用户信息到session中</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;user&quot;</span>, BeanUtils.copyProperties(user,UserDTO.class));</span><br></pre></td></tr></table></figure>

<p><strong>在拦截器处：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5.存在，保存用户信息到Threadlocal</span></span><br><span class="line">UserHolder.saveUser((UserDTO) user);</span><br></pre></td></tr></table></figure>

<p><strong>在UserHolder处：将user对象换成UserDTO</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="session共享问题"><a href="#session共享问题" class="headerlink" title="session共享问题"></a>session共享问题</h3><p><strong>核心思路分析：</strong></p>
<p>每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</p>
<p>但是这种方案具有两个大问题</p>
<p>1、每台服务器中都有完整的一份session数据，服务器内存压力过大。</p>
<p>2、session拷贝数据时，可能会出现延迟，影响效率</p>
<p>所以咱们后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653069893050.png" alt="1653069893050"></p>
<p>为什么用cookie,session,redis而不是数据库？</p>
<p>有些东西并不需要持久化到数据库中，只需要存在内存中即可，键值对型数据能够实现高效的查询与获取</p>
<h3 id="Redis代替session的业务流程"><a href="#Redis代替session的业务流程" class="headerlink" title="Redis代替session的业务流程"></a>Redis代替session的业务流程</h3><h4 id="设计key的结构"><a href="#设计key的结构" class="headerlink" title="设计key的结构"></a>设计key的结构</h4><p>首先我们要思考一下利用redis来存储数据，那么到底使用哪种结构呢？由于存入的数据比较简单，我们可以考虑使用String，或者是使用哈希，如下图，如果使用String，同学们注意他的value，用多占用一点空间，如果使用哈希，则他的value中只会存储他数据本身，如果不是特别在意内存，其实使用String就可以啦。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653319261433.png" alt="1653319261433"></p>
<h4 id="设计key的具体细节"><a href="#设计key的具体细节" class="headerlink" title="设计key的具体细节"></a>设计key的具体细节</h4><p>所以我们可以使用String结构，就是一个简单的key，value键值对的方式，但是关于key的处理，session他是每个用户都有自己的session，但是redis的key是共享的，咱们就不能使用code了</p>
<p>在设计这个key的时候，我们之前讲过需要满足两点</p>
<p>1、key要具有唯一性</p>
<p>2、key要方便携带</p>
<p>如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了。</p>
<p><mark>session：浏览器请求自动携带sessionID，服务器根据sessionID访问相应的内存空间存储的信息，<mark></p>
<p><mark>redis+token：浏览器请求携带token，服务器根据token访问redis数据库存储的信息。<mark></p>
<ul>
<li><mark>前端实现逻辑：将服务端生成的<u>token</u>保存到浏览器的sessionStorage域中，在axios发送ajax请求时进行方法拦截，在请求头requestHeader中加入authorization:<u>token</u> ，因为要保存到浏览器，所以不能使用手机号作为token而应该生成一个uuid字符串<mark>: </li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241031173338907.png" alt="image-20241031173338907"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241031173340660.png" alt="image-20241031173340660"></p>
<ul>
<li><mark>后端逻辑：将token取出，根据token访问redis数据库<mark></li>
</ul>
<h4 id="整体访问流程"><a href="#整体访问流程" class="headerlink" title="整体访问流程"></a>整体访问流程</h4><p>当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653319474181.png" alt="1653319474181"></p>
<h3 id="基于Redis实现短信登录"><a href="#基于Redis实现短信登录" class="headerlink" title="基于Redis实现短信登录"></a>基于Redis实现短信登录</h3><p>这里具体逻辑就不分析了，之前咱们已经重点分析过这个逻辑啦。</p>
<p><strong>UserServiceImpl代码</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.从redis获取验证码并校验</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="keyword">if</span> (cacheCode == <span class="literal">null</span> || !cacheCode.equals(code)) &#123;</span><br><span class="line">        <span class="comment">// 不一致，报错</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.一致，根据手机号查询用户 select * from tb_user where phone = ?</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.不存在，创建新用户并保存</span></span><br><span class="line">        user = createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.保存用户信息到 redis中</span></span><br><span class="line">    <span class="comment">// 7.1.随机生成token，作为登录令牌</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 7.2.将User对象转为HashMap存储</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">            CopyOptions.create()</span><br><span class="line">                    .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                    .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line">    <span class="comment">// 7.3.存储</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">    stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);</span><br><span class="line">    <span class="comment">// 7.4.设置token有效期</span></span><br><span class="line">    stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.返回token</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决状态登录刷新问题"><a href="#解决状态登录刷新问题" class="headerlink" title="解决状态登录刷新问题"></a>解决状态登录刷新问题</h3><h4 id="初始方案思路总结"><a href="#初始方案思路总结" class="headerlink" title="初始方案思路总结"></a>初始方案思路总结</h4><p>在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，比如主页之类的那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的。</p>
<p>只有访问拦截的网页才会刷redis，这样就导致如果用户访问的是其他网页，不会出发拦截器，过期token就会失效</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653320822964.png" alt="1653320822964"></p>
<h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><p>既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653320764547.png" alt="1653320764547"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><strong>RefreshTokenInterceptor</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.基于TOKEN获取redis中的用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span>  <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">        <span class="comment">// 3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.将查询到的hash数据转为UserDTO</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 6.存在，保存用户信息到 ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">// 7.刷新token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 8.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p><strong>LoginInterceptor</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要拦截（ThreadLocal中是否有用户）</span></span><br><span class="line">        <span class="keyword">if</span> (UserHolder.getUser() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有，需要拦截，设置状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="comment">// 拦截</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有用户，则放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/weixin_45673401/article/details/132065407">Hutool BeanUtils.copyProperties的四种用法 空不拷贝/忽略拷贝/空不和忽略拷贝/全拷贝_hutool beanutil.copyproperties-CSDN博客</a> </p>
<p>beanToMap 属性转换异常</p>
<h2 id="商户查询缓存-分布式缓存cache"><a href="#商户查询缓存-分布式缓存cache" class="headerlink" title="商户查询缓存 分布式缓存cache"></a>商户查询缓存 分布式缓存cache</h2><h3 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存?"></a>什么是缓存?</h3><p><strong>前言</strong>:<strong>什么是缓存?</strong></p>
<p>就像自行车,越野车的避震器<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E9%81%BF%E9%9C%87%E5%99%A8.gif"></p>
<p>举个例子:越野车,山地自行车,都拥有”避震器”,<strong>防止</strong>车体加速后因惯性,在酷似”U”字母的地形上飞跃,硬着陆导致的<strong>损害</strong>,像个弹簧一样;</p>
<p>同样,实际开发中,系统也需要”避震器”,防止过高的数据访问猛冲系统,导致其操作线程无法及时处理信息而瘫痪;</p>
<p>这在实际开发中对企业讲,对产品口碑,用户评价都是致命的;所以企业非常重视缓存技术;</p>
<p><strong>缓存(<strong>Cache),就是数据交换的</strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码(例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例<span class="number">1</span>:Static <span class="keyword">final</span> ConcurrentHashMap&lt;K,V&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(); 本地用于高并发</span><br><span class="line"></span><br><span class="line">例<span class="number">2</span>:<span class="keyword">static</span> <span class="keyword">final</span> Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存</span><br><span class="line"></span><br><span class="line">例<span class="number">3</span>:Static <span class="keyword">final</span> Map&lt;K,V&gt; map =  <span class="keyword">new</span> <span class="title class_">HashMap</span>(); 本地缓存</span><br></pre></td></tr></table></figure>

<p>由于其被<strong>Static</strong>修饰,所以随着类的加载而被加载到<strong>内存之中</strong>,作为本地缓存,由于其又被<strong>final</strong>修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(=)导致缓存失效;</p>
<h4 id="为什么要使用缓存"><a href="#为什么要使用缓存" class="headerlink" title="为什么要使用缓存"></a>为什么要使用缓存</h4><p>一句话:因为<strong>速度快,好用</strong></p>
<p>缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低<strong>用户访问并发量带来的</strong>服务器读写压力</p>
<p>实际开发过程中,企业的数据量,少则几十万,多则几千万,这么大数据量,如果没有缓存来作为”避震器”,系统是几乎撑不住的,所以企业会大量运用到缓存技术;</p>
<p>但是缓存也会增加代码复杂度和运营的成本:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220523214414123.png"></p>
<h4 id="如何使用缓存"><a href="#如何使用缓存" class="headerlink" title="如何使用缓存"></a>如何使用缓存</h4><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p>
<p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p>
<p><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p>
<p><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p>
<p><strong>CPU缓存：</strong>当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220523212915666.png"></p>
<h3 id="添加商户缓存"><a href="#添加商户缓存" class="headerlink" title="添加商户缓存"></a>添加商户缓存</h3><p>在我们查询商户信息时，我们是直接操作从数据库中去进行查询的，大致逻辑是这样，直接查询数据库那肯定慢咯，所以我们需要增加缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">public Result queryShopById(@PathVariable(&quot;id&quot;) Long id) &#123;</span><br><span class="line">    //这里是直接查询数据库</span><br><span class="line">    return shopService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缓存模型和思路"><a href="#缓存模型和思路" class="headerlink" title="缓存模型和思路"></a>缓存模型和思路</h4><p>标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653322097736.png" alt="1653322097736"></p>
<h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><p>代码思路：如果缓存有，则直接返回，如果缓存不存在，则查询数据库，然后存入redis。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653322190155.png" alt="1653322190155"></p>
<h4 id="练习：商铺信息缓存处理"><a href="#练习：商铺信息缓存处理" class="headerlink" title="练习：商铺信息缓存处理"></a>练习：商铺信息缓存处理</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241101145321055.png" alt="image-20241101145321055"></p>
<p>增加程序健壮性，先查看redis是否有key，没有就创建，如果有key但是长度为0，也创建，长度不为0，肯定有key，读取后解析为list返回</p>
<h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p>
<p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p>
<p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</p>
<p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653322506393.png" alt="1653322506393"></p>
<h4 id="DB-Cache数据一致性解决方案"><a href="#DB-Cache数据一致性解决方案" class="headerlink" title="DB, Cache数据一致性解决方案"></a>DB, Cache数据一致性解决方案</h4><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p>
<p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p>
<h5 id="Cache-Aside-Pattern-旁路缓存"><a href="#Cache-Aside-Pattern-旁路缓存" class="headerlink" title="Cache Aside Pattern 旁路缓存"></a>Cache Aside Pattern 旁路缓存</h5><p>人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p>
<h5 id="Read-Write-Through-Pattern-读写穿透"><a href="#Read-Write-Through-Pattern-读写穿透" class="headerlink" title="Read/Write Through Pattern 读写穿透"></a>Read/Write Through Pattern 读写穿透</h5><p>由系统本身完成，数据库与缓存的问题交由缓存系统本身去处理，实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p>
<p>但是Redis本身并没有支持将cache写入db的功能，因此也不常见</p>
<h5 id="Write-Behind-Caching-Pattern-异步缓存写入"><a href="#Write-Behind-Caching-Pattern-异步缓存写入" class="headerlink" title="Write Behind Caching Pattern 异步缓存写入"></a>Write Behind Caching Pattern 异步缓存写入</h5><p>调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p>
<p>举例：消息队列中消息的 异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制</p>
<p> db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么 高的场景，比如浏览量、点赞量</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653322857620.png" alt="1653322857620"></p>
<h4 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h4><p>综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题</p>
<p>操作缓存和数据库时有三个问题需要考虑：</p>
<h5 id="删除cache还是更新cache？"><a href="#删除cache还是更新cache？" class="headerlink" title="删除cache还是更新cache？"></a><a href="https://blog.csdn.net/qq_38420688/article/details/108803569">删除cache还是更新cache？</a></h5><ul>
<li><p>更新缓存：每次更新数据库都更新缓存，无效写操作较多，并且可能有线程安全问题</p>
</li>
<li><p>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</p>
</li>
</ul>
<p>无效写：假设我们每次操作数据库后，都去更新缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来。</p>
<p>线程安全：比如可能更新了某个表的一个字段，然后更新对应的缓存需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值。而另外的表数据可能已经被其他线程修改，从而出现线程安全问题。</p>
<h5 id="如何保证cache与db的操作的同时成功或失败？"><a href="#如何保证cache与db的操作的同时成功或失败？" class="headerlink" title="如何保证cache与db的操作的同时成功或失败？"></a>如何保证cache与db的操作的同时成功或失败？</h5><ul>
<li><p>单体系统，将缓存与数据库操作放在一个事务</p>
</li>
<li><p>分布式系统，利用TCC等分布式事务方案</p>
</li>
</ul>
<h5 id="先操作cache还是先操作db？"><a href="#先操作cache还是先操作db？" class="headerlink" title="先操作cache还是先操作db？"></a>先操作cache还是先操作db？</h5><ul>
<li><p>先删除缓存，再操作数据库</p>
</li>
<li><p>先操作数据库，再删除缓存</p>
</li>
</ul>
<p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653323595206.png" alt="1653323595206"></p>
<p>先删了，没来得及更新数据库20，另一个抢先未命中然后从数据库读取10并写入缓存，最后造成不一致</p>
<p>查的进程刚好缓存失效了，已经查完数据库10，没来的及写缓存，插进来一个更新的进程，更新数据库20并删缓存，最后写缓存10</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241101154820526.png" alt="image-20241101154820526"></p>
<h4 id="Cache-Aside-Pattern-代码实现"><a href="#Cache-Aside-Pattern-代码实现" class="headerlink" title="Cache Aside Pattern 代码实现"></a>Cache Aside Pattern 代码实现</h4><p>核心思路如下：</p>
<p>修改ShopController中的业务逻辑，满足下面的需求：</p>
<p>根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</p>
<p>根据id修改店铺时，先修改数据库，再删除缓存</p>
<p><strong>修改重点代码1</strong>：修改<strong>ShopServiceImpl</strong>的queryById方法</p>
<p><strong>设置redis缓存时添加过期时间</strong> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653325871232.png" alt="1653325871232"></p>
<p><strong>修改重点代码2</strong></p>
<p>代码分析：通过之前的淘汰，我们确定了采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653325929549.png" alt="1653325929549"></p>
<h3 id="缓存穿透—Cache-Penetration"><a href="#缓存穿透—Cache-Penetration" class="headerlink" title="缓存穿透—Cache Penetration"></a>缓存穿透—Cache Penetration</h3><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>缓存空对象<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ul>
<li>额外的内存消耗</li>
<li>可能造成短期的不一致</li>
</ul>
</li>
</ul>
</li>
<li>布隆过滤<ul>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点：<ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p>
<p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p>
<p>假设布隆过滤器判断这个数据不存在，则直接返回</p>
<p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653326156516.png" alt="1653326156516"></p>
<h4 id="编码解决商品查询的缓存穿透问题"><a href="#编码解决商品查询的缓存穿透问题" class="headerlink" title="编码解决商品查询的缓存穿透问题"></a>编码解决商品查询的缓存穿透问题</h4><p>核心思路如下：</p>
<p>在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的</p>
<p>现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。</p>
<p>caching sharding load balancing</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653327124561.png" alt="1653327124561"></p>
<p><strong>小总结：</strong></p>
<p>缓存穿透产生的原因是什么？</p>
<ul>
<li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li>
</ul>
<p>缓存穿透的解决方案有哪些？</p>
<ul>
<li>缓存null值</li>
<li>布隆过滤</li>
<li>增强id的复杂度，避免被猜测id规律</li>
<li>做好数据的基础格式校验</li>
<li>加强用户权限校验</li>
<li>做好热点参数的限流</li>
</ul>
<h3 id="缓存雪崩—Cache-Avalanche"><a href="#缓存雪崩—Cache-Avalanche" class="headerlink" title="缓存雪崩—Cache Avalanche"></a>缓存雪崩—Cache Avalanche</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p>
<p>解决方案：</p>
<ul>
<li>给不同的Key的TTL添加随机值</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653327884526.png" alt="1653327884526"></p>
<h3 id="缓存击穿—Hotspot-Invalid"><a href="#缓存击穿—Hotspot-Invalid" class="headerlink" title="缓存击穿—Hotspot Invalid"></a>缓存击穿—Hotspot Invalid</h3><h4 id="解决思路-1"><a href="#解决思路-1" class="headerlink" title="解决思路"></a>解决思路</h4><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>互斥锁 MUTEX</li>
<li>逻辑过期 LOGICAL EXPIRE</li>
</ul>
<p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653328022622.png" alt="1653328022622"></p>
<p>解决方案一、使用锁来解决：</p>
<p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p>
<p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653328288627.png" alt="1653328288627"></p>
<p>解决方案二、逻辑过期方案</p>
<p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p>
<p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p>
<p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653328663897.png" alt="1653328663897"></p>
<p>进行对比</p>
<p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p>
<p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653357522914.png" alt="1653357522914"></p>
<h4 id="利用互斥锁解决缓存击穿—Mutex—基于setnx"><a href="#利用互斥锁解决缓存击穿—Mutex—基于setnx" class="headerlink" title="利用互斥锁解决缓存击穿—Mutex—基于setnx"></a>利用互斥锁解决缓存击穿—Mutex—基于setnx</h4><p>核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询</p>
<p>如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653357860001.png" alt="1653357860001"></p>
<p><strong>操作锁的代码：</strong></p>
<p>核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，  如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>操作代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span>  &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">       <span class="comment">// 1、从redis中查询商铺缓存</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">       <span class="comment">// 2、判断是否存在</span></span><br><span class="line">       <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">           <span class="comment">// 存在,直接返回</span></span><br><span class="line">           <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//判断命中的值是否是空值</span></span><br><span class="line">       <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//返回一个错误信息</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4.实现缓存重构</span></span><br><span class="line">       <span class="comment">//获取互斥锁</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:shop:&quot;</span> + id;</span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">           <span class="comment">// 判断否获取成功</span></span><br><span class="line">           <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">               <span class="comment">//失败，则休眠重试</span></span><br><span class="line">               Thread.sleep(<span class="number">50</span>);</span><br><span class="line">               <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//成功，根据id查询数据库</span></span><br><span class="line">            shop = getById(id);</span><br><span class="line">           <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">           <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//将空值写入redis</span></span><br><span class="line">               stringRedisTemplate.opsForValue().set(key,<span class="string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">               <span class="comment">//返回错误信息</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//6.写入redis</span></span><br><span class="line">           stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//7.释放互斥锁 </span></span><br><span class="line">           unlock(lockKey);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> shop;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241101214618482.png" alt="image-20241101214618482"></p>
<h4 id="利用逻辑过期解决缓存击穿—LogicalExpire"><a href="#利用逻辑过期解决缓存击穿—LogicalExpire" class="headerlink" title="利用逻辑过期解决缓存击穿—LogicalExpire"></a>利用逻辑过期解决缓存击穿—LogicalExpire</h4><p><strong>需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题</strong></p>
<p>思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653360308731.png" alt="1653360308731"></p>
<p>如果封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，要么你</p>
<p><strong>步骤一、</strong></p>
<p>新建一个实体类，我们采用第二个方案，这个方案，对原来代码没有侵入性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class RedisData &#123;</span><br><span class="line">    private LocalDateTime expireTime;</span><br><span class="line">    private Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤二、</strong></p>
<p>在<strong>ShopServiceImpl</strong> 新增此方法，利用单元测试进行缓存预热</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653360807133.png" alt="1653360807133"></p>
<p><strong>在测试类中</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653360864839.png" alt="1653360864839"></p>
<p>步骤三：正式代码</p>
<p><strong>ShopServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">( Long id )</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">// 2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">        <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">// 5.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">    <span class="comment">// 6.缓存重建</span></span><br><span class="line">    <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//重建缓存</span></span><br><span class="line">                <span class="built_in">this</span>.saveShop2Redis(id,<span class="number">20L</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="封装Redis工具类—CacheClient"><a href="#封装Redis工具类—CacheClient" class="headerlink" title="封装Redis工具类—CacheClient"></a>封装Redis工具类—CacheClient</h3><p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p>
<ul>
<li>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</li>
<li>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓</li>
</ul>
<p>存击穿问题</p>
<ul>
<li>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题</li>
<li>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</li>
</ul>
<p>将逻辑进行封装</p>
<p>重点在于为了普适性要加入泛型，尽可能提高代码复用性，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">// 写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            <span class="comment">// 6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">newR</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">        <span class="comment">// 4.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3.获取锁失败，休眠并重试</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">// 返回错误信息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ShopServiceImpl 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> CacheClient cacheClient;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 解决缓存穿透</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient</span><br><span class="line">                .queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 互斥锁解决缓存击穿</span></span><br><span class="line">        <span class="comment">// Shop shop = cacheClient</span></span><br><span class="line">        <span class="comment">//         .queryWithMutex(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逻辑过期解决缓存击穿</span></span><br><span class="line">        <span class="comment">// Shop shop = cacheClient</span></span><br><span class="line">        <span class="comment">//         .queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, this::getById, 20L, TimeUnit.SECONDS);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="引入布隆过滤器-BloomFilter"><a href="#引入布隆过滤器-BloomFilter" class="headerlink" title="引入布隆过滤器 BloomFilter"></a>引入布隆过滤器 BloomFilter</h3><h4 id="引入Guava依赖"><a href="#引入Guava依赖" class="headerlink" title="引入Guava依赖"></a>引入Guava依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>33.2.1-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="将布隆过滤器交给IoC容器"><a href="#将布隆过滤器交给IoC容器" class="headerlink" title="将布隆过滤器交给IoC容器"></a>将布隆过滤器交给IoC容器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuavaConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;custom.expectedInsertions&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long expectedInsertions;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;custom.fpp&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Double fpp;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BloomFilter&lt;Long&gt; <span class="title function_">shopIdBloomFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BloomFilter.create(Funnels.longFunnel(), expectedInsertions, fpp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BloomFilter&lt;String&gt; <span class="title function_">stringBloomFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BloomFilter.create(Funnels.stringFunnel(StandardCharsets.UTF_8), expectedInsertions, fpp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol>
<li><p>bloomFilter.put() 加入布隆过滤器</p>
</li>
<li><p>bloomFilter.mightContain()判断是否存在</p>
</li>
<li><p>expectedInsertions 布隆过滤器中预期加入的数字</p>
</li>
<li><p>fpp 可接受的误判率</p>
</li>
</ol>
<h2 id="优惠卷秒杀-乐观锁、悲观锁（synchronized）"><a href="#优惠卷秒杀-乐观锁、悲观锁（synchronized）" class="headerlink" title="优惠卷秒杀 乐观锁、悲观锁（synchronized）"></a>优惠卷秒杀 乐观锁、悲观锁（synchronized）</h2><h3 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="-全局唯一ID"></a>-全局唯一ID</h3><p>每个店铺都可以发布优惠券：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653362612286.png" alt="1653362612286"></p>
<p>当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：</p>
<ul>
<li>id的规律性太明显</li>
<li>受单表数据量的限制</li>
</ul>
<p>场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。</p>
<p>场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。</p>
<p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653363100502.png" alt="1653363100502"></p>
<p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653363172079.png" alt="1653363172079">ID的组成部分：符号位：1bit，永远为0</p>
<p>时间戳：31bit，以秒为单位，可以使用69年</p>
<p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p>
<h3 id="Redis实现全局唯一Id"><a href="#Redis实现全局唯一Id" class="headerlink" title="-Redis实现全局唯一Id"></a>-Redis实现全局唯一Id</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisIdWorker</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.生成序列号</span></span><br><span class="line">        <span class="comment">// 2.1.获取当前日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">// 2.2.自增长</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<p>知识小贴士：关于countdownlatch </p>
<p>countdownlatch名为信号枪：主要的作用是同步协调在多线程的等待于唤醒问题</p>
<p>我们如果没有CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch</p>
<p>CountDownLatch 中有两个最重要的方法</p>
<p>1、countDown</p>
<p>2、await</p>
<p>await 方法 是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch  内部维护的 变量变为0时，就不再阻塞，直接放行，那么什么时候CountDownLatch   维护的变量变为0 呢，我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testIdWorker</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">        &#125;</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        es.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line">    latch.await();</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time = &quot;</span> + (end - begin));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加优惠卷"><a href="#添加优惠卷" class="headerlink" title="添加优惠卷"></a>添加优惠卷</h3><p>每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653365145124.png" alt="1653365145124"></p>
<p>tb_voucher：优惠券的基本信息，优惠金额、使用规则等<br>tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息</p>
<p>平价卷由于优惠力度并不是很大，所以是可以任意领取</p>
<p>而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段</p>
<p>**新增普通卷代码：  **VoucherController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.save(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>新增秒杀卷代码：</strong></p>
<p><strong>VoucherController</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;seckill&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addSeckillVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.addSeckillVoucher(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>VoucherServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现秒杀下单"><a href="#实现秒杀下单" class="headerlink" title="实现秒杀下单"></a>实现秒杀下单</h3><p>下单核心思路：当我们点击抢购时，会触发右侧的请求，我们只需要编写对应的controller即可</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653365839526.png" alt="1653365839526"></p>
<p>秒杀下单应该思考的内容：</p>
<p>下单时需要判断两点：</p>
<ul>
<li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li>
<li>库存是否充足，不足则无法下单</li>
</ul>
<p>下单核心逻辑分析：</p>
<p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件</p>
<p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653366238564.png" alt="1653366238564"></p>
<p>VoucherOrderServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5，扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">//扣减库存</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 6.1.订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">// 6.2.用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 6.3.代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="库存超卖问题分析"><a href="#库存超卖问题分析" class="headerlink" title="库存超卖问题分析"></a>库存超卖问题分析</h3><p>有关超卖问题分析：在我们原有代码中是这么写的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="comment">// 库存不足</span></span><br><span class="line">       <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//5，扣减库存</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">           .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">           .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">   <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">       <span class="comment">//扣减库存</span></span><br><span class="line">       <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653368335155.png" alt="1653368335155"></p>
<p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：见下图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653368562591.png" alt="1653368562591"></p>
<p><strong>悲观锁：</strong></p>
<p> 悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</p>
<p><strong>乐观锁：</strong></p>
<p>  乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas</p>
<p>  乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 == 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值</p>
<p>  其中do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> var5;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">&#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> var5;</span><br></pre></td></tr></table></figure>

<p><strong>课程中的使用方式：</strong></p>
<p>课程中的使用方式是没有像cas一样带自旋的操作，也没有对version的版本号+1 ，他的操作逻辑是在操作时，对版本号进行+1 操作，然后要求version 如果是1 的情况下，才能操作，那么第一个线程在操作后，数据库中的version变成了2，但是他自己满足version=1 ，所以没有问题，此时线程2执行，线程2 最后也需要加上条件version =1 ，但是现在由于线程1已经操作过了，所以线程2，操作时就不满足version=1 的条件了，所以线程2无法执行成功</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653369268550.png" alt="1653369268550"></p>
<h3 id="乐观锁解决超卖问题"><a href="#乐观锁解决超卖问题" class="headerlink" title="乐观锁解决超卖问题"></a>乐观锁解决超卖问题</h3><p><strong>修改代码方案一、</strong></p>
<p>VoucherOrderServiceImpl 在扣减库存时，改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>) <span class="comment">//set stock = stock -1</span></span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="string">&quot;stock&quot;</span>,voucher.getStock()).update(); <span class="comment">//where id = ？ and stock = ?</span></span><br></pre></td></tr></table></figure>

<p>以上逻辑的核心含义是：只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败</p>
<p><strong>修改代码方案二、</strong></p>
<p>之前的方式要修改前后都保持一致，但是这样我们分析过，成功的概率太低，所以我们的乐观锁需要变一下，改成stock大于0 即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update().gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>); <span class="comment">//where id = ? and stock &gt; 0</span></span><br></pre></td></tr></table></figure>

<p><strong>知识小扩展：</strong></p>
<p>针对cas中的自旋压力过大，我们可以使用Longaddr这个类去解决</p>
<p>Java8 提供的一个对AtomicLong改进后的一个类，LongAdder</p>
<p>大量线程并发更新一个原子性的时候，天然的问题就是自旋，会导致并发性问题，当然这也比我们直接使用syn来的好</p>
<p>所以利用这么一个类，LongAdder来进行优化</p>
<p>如果获取某个值，则会对cell和base的值进行递增，最后返回一个完整的值</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653370271627.png" alt="1653370271627"></p>
<h3 id="优惠券秒杀-一人一单"><a href="#优惠券秒杀-一人一单" class="headerlink" title="优惠券秒杀-一人一单"></a>优惠券秒杀-一人一单</h3><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p>
<p><strong>现在的问题在于：</strong></p>
<p>优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单</p>
<p>具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653371854389.png" alt="1653371854389"></p>
<p>VoucherOrderServiceImpl  </p>
<p><strong>初步代码：增加一人一单逻辑</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.一人一单逻辑</span></span><br><span class="line">    <span class="comment">// 5.1.用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 用户已经购买过了</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6，扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">//扣减库存</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 7.1.订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line"></span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 7.3.代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>存在问题：</strong>现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作</p>
<p><strong>注意：</strong>在这里提到了非常多的问题，我们需要慢慢的来思考，首先我们的初始方案是封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">         <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 7.1.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 7.2.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 7.3.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制<strong>锁粒度</strong> 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：</p>
<h4 id="锁的真正含义"><a href="#锁的真正含义" class="headerlink" title="锁的真正含义"></a>锁的真正含义</h4><p><mark>锁的真正含义<mark>: 导致线程安全问题的线程之间需要拥有同一把锁，比如：字符串常量作为锁，意味着只要能得到这个字符串常量的锁都会参与到锁的竞争中，这会使不相关的线程被阻塞，同样的如果使用<code> synchronized(this)</code>，也会导致所有获得服务对象的线程都会参与锁的竞争，也就是所有用户都被挡在门外，引入悲观锁只是用来解决一人一单问题的，所以应该使用userId作为锁对象，这样不同的用户就不会互相影响。（数据库层面的乐观锁仍然可以有效防止库存负数的问题，先查后改）</p>
<p>拿到相同对象（锁）的线程会串行执行同步代码块，所以不同用户可以并行执行这段代码。</p>
<p>intern() 这个方法是从常量池中拿到数据，如果我们直接使用 <code>userId.toString()</code>他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">	<span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">	<span class="keyword">synchronized</span>(userId.toString().intern())&#123;</span><br><span class="line">         <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 7.1.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 7.2.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 7.3.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事务内部加锁导致事务失效"><a href="#事务内部加锁导致事务失效" class="headerlink" title="事务内部加锁导致事务失效"></a>事务内部加锁导致事务失效</h4><p>但是以上代码还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放，下一个拿到锁的对象就开始执行事务方法了，从而导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题如下：</p>
<p>在seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653373434815.png" alt="1653373434815"></p>
<h4 id="事务自调用导致事务失效"><a href="#事务自调用导致事务失效" class="headerlink" title="事务自调用导致事务失效"></a>事务自调用导致事务失效</h4><p>但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象，来操作事务</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653383810643.png" alt="1653383810643"></p>
<h4 id="事务的粒度控制"><a href="#事务的粒度控制" class="headerlink" title="事务的粒度控制"></a>事务的粒度控制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">secKillVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//省略.......</span></span><br><span class="line">    <span class="keyword">synchronized</span> (id.toString().intern()) &#123;</span><br><span class="line">        <span class="comment">//开启事务要用代理对象</span></span><br><span class="line">        <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">        <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//省略.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在回过头来再看，为什么在外部的<code>seckillVoucher()</code>需要去掉@Transactional注解？里外都声明了事务，并且传播都是默认的<code>REQUIRE</code>，外部方法先开启事务，最后<code>createVoucherOrder()</code> 也是加入的这个大事务，而这样同样会导致锁释放了，事务还没提交。</p>
<h4 id="Transactional-amp-Lock"><a href="#Transactional-amp-Lock" class="headerlink" title="@Transactional &amp; Lock"></a>@Transactional &amp; Lock</h4><p><a href="https://www.cnblogs.com/thisiswhy/p/15175380.html">当Transactional碰到锁，有个大坑，要小心。 - why技术 - 博客园 (cnblogs.com)</a> </p>
<p><a href="https://blog.csdn.net/Adoucequan/article/details/123844506">事务中使用分布式锁问题_分布式锁在事务里面,加50毫秒等上一个事务提交后再执行-CSDN博客</a> </p>
<h3 id="集群环境下的并发问题"><a href="#集群环境下的并发问题" class="headerlink" title="集群环境下的并发问题"></a>集群环境下的并发问题</h3><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p>
<p>1、我们将服务启动两份，端口分别为8081和8082：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653373887844.png" alt="1653373887844"></p>
<p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653373908620.png" alt="1653373908620"></p>
<p><strong>具体操作(略)</strong></p>
<h4 id="有关锁失效原因分析"><a href="#有关锁失效原因分析" class="headerlink" title="有关锁失效原因分析"></a><strong>有关锁失效原因分析</strong></h4><p>不同JVM实例的常量池也不同，是隔绝开的，所以实例之间的互斥仅仅靠普通的对象锁是不可靠的</p>
<p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653374044740.png" alt="1653374044740"></p>
<h2 id="分布式锁—为解决分布式-集群进程间的并发安全问题"><a href="#分布式锁—为解决分布式-集群进程间的并发安全问题" class="headerlink" title="分布式锁—为解决分布式/集群进程间的并发安全问题"></a>分布式锁—为解决分布式/集群进程间的并发安全问题</h2><h3 id="基本原理和实现方式对比"><a href="#基本原理和实现方式对比" class="headerlink" title="基本原理和实现方式对比"></a>基本原理和实现方式对比</h3><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p>
<p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653374296906.png" alt="1653374296906"></p>
<p>那么分布式锁他应该满足一些什么样的条件呢？</p>
<p>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p>
<p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p>
<p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p>
<p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p>
<p>安全性：安全也是程序中必不可少的一环</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653381992018.png" alt="1653381992018"></p>
<p>常见的分布式锁有三种</p>
<p>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</p>
<p>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</p>
<p>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653382219377.png" alt="1653382219377"></p>
<h3 id="Redis分布式锁的实现核心思路"><a href="#Redis分布式锁的实现核心思路" class="headerlink" title="Redis分布式锁的实现核心思路"></a>Redis分布式锁的实现核心思路</h3><p>实现分布式锁时需要实现的两个基本方法：</p>
<ul>
<li><p>获取锁：</p>
<ul>
<li>互斥：确保只能有一个线程获取锁</li>
<li>非阻塞：尝试一次，成功返回true，失败返回false</li>
</ul>
</li>
<li><p>释放锁：</p>
<ul>
<li>手动释放</li>
<li>超时释放：获取锁时添加一个超时时间</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653382669900.png" alt="1653382669900"></p>
</li>
</ul>
<p>核心思路：</p>
<p>我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653382830810.png" alt="1653382830810"></p>
<h3 id="实现分布式锁版本一"><a href="#实现分布式锁版本一" class="headerlink" title="实现分布式锁版本一"></a>实现分布式锁版本一</h3><ul>
<li>加锁逻辑</li>
</ul>
<p><strong>锁的基本接口</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1656079017728.png" alt="1656079017728"></p>
<p><strong>SimpleRedisLock</strong></p>
<p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_PREFIX=<span class="string">&quot;lock:&quot;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId()</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>释放锁逻辑</li>
</ul>
<p>SimpleRedisLock</p>
<p>释放锁，防止删除别人的锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//通过del删除锁</span></span><br><span class="line">    stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改业务代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">      <span class="comment">// 1.查询优惠券</span></span><br><span class="line">      <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">      <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">// 尚未开始</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">// 尚未开始</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// 库存不足</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">      <span class="comment">//创建锁对象(新增代码)</span></span><br><span class="line">      <span class="type">SimpleRedisLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(<span class="string">&quot;order:&quot;</span> + userId, stringRedisTemplate);</span><br><span class="line">      <span class="comment">//获取锁对象</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1200</span>);</span><br><span class="line"><span class="comment">//加锁失败</span></span><br><span class="line">      <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">          <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">          <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//释放锁</span></span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Redis分布式锁误删情况说明"><a href="#Redis分布式锁误删情况说明" class="headerlink" title="Redis分布式锁误删情况说明"></a>Redis分布式锁误删情况说明</h3><p>逻辑说明：</p>
<p>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p>
<p>解决方案：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653385920025.png" alt="1653385920025"></p>
<h3 id="解决Redis分布式锁误删问题—本线程误删了其他线程的锁"><a href="#解决Redis分布式锁误删问题—本线程误删了其他线程的锁" class="headerlink" title="解决Redis分布式锁误删问题—本线程误删了其他线程的锁"></a>解决Redis分布式锁误删问题—本线程误删了其他线程的锁</h3><p>需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用UUID表示）<br>在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</p>
<ul>
<li>如果一致则释放锁</li>
<li>如果不一致则不释放锁</li>
</ul>
<p>核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653387398820.png" alt="1653387398820"></p>
<p>具体代码如下：加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取线程标示</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">   <span class="comment">// 获取锁</span></span><br><span class="line">   <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">   <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁中的标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">// 判断标示是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id)) &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有关代码实操说明：</strong></p>
<p>在我们修改完此处代码后，我们重启工程，然后启动两个线程，第一个线程持有锁后，手动释放锁，第二个线程 此时进入到锁内部，再放行第一个线程，此时第一个线程由于锁的value值并非是自己，所以不能释放锁，也就无法删除别人的锁，此时第二个线程能够正确释放锁，通过这个案例初步说明我们解决了锁误删的问题。</p>
<h3 id="分布式锁的原子性问题—Full-GC带来的JAVA代码阻塞延时"><a href="#分布式锁的原子性问题—Full-GC带来的JAVA代码阻塞延时" class="headerlink" title="分布式锁的原子性问题—Full GC带来的JAVA代码阻塞延时"></a>分布式锁的原子性问题—Full GC带来的JAVA代码阻塞延时</h3><p><mark>Full GC<mark>，即完全垃圾回收，是指JVM对堆内存的所有区域（年轻代、老年代以及永久代/元空间）进行的全面清理过程。与之相对的是Minor GC，通常只清理年轻代。Full GC的触发通常是响应式而非主动的，比如堆内存不足、永久代满载等情况。由于Full GC涉及范围广，耗时较长，因此可能会引起应用程序的显著暂停（Stop-the-world），影响用户体验。</p>
<p><mark>判断的动作 与 真正delete的动作不是同步的<mark> 导致在delete操作之前锁已经超时释放，被另一个线程获取，但是依然被第一个线程误删</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">currentLockerId</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOCK_KEY_PREFIX + name);</span><br><span class="line">    <span class="keyword">if</span> (StrUtil.equals(currentLockerId, threadId)) &#123;</span><br><span class="line">        <span class="comment">//阻塞。。。。。</span></span><br><span class="line">        stringRedisTemplate.delete(LOCK_KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>更为极端的误删逻辑说明：</p>
<p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653387764938.png" alt="1653387764938"></p>
<h3 id="Lua脚本解决多条命令原子性问题"><a href="#Lua脚本解决多条命令原子性问题" class="headerlink" title="Lua脚本解决多条命令原子性问题"></a>Lua脚本解决多条命令原子性问题</h3><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：<a href="https://www.runoob.com/lua/lua-tutorial.html%EF%BC%8C%E8%BF%99%E9%87%8C%E9%87%8D%E7%82%B9%E4%BB%8B%E7%BB%8DRedis%E6%8F%90%E4%BE%9B%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8lua%E5%8E%BB%E6%93%8D%E4%BD%9Credis%EF%BC%8C%E5%8F%88%E8%83%BD%E4%BF%9D%E8%AF%81%E4%BB%96%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8B%BF%E9%94%81%E6%AF%94%E9%94%81%E5%88%A0%E9%94%81%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8A%A8%E4%BD%9C%E4%BA%86%EF%BC%8C%E4%BD%9C%E4%B8%BAJava%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%99%E4%B8%80%E5%9D%97%E5%B9%B6%E4%B8%8D%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%A6%81%E6%B1%82%EF%BC%8C%E5%B9%B6%E4%B8%8D%E9%9C%80%E8%A6%81%E5%A4%A7%E5%AE%B6%E8%BF%87%E4%BA%8E%E7%B2%BE%E9%80%9A%EF%BC%8C%E5%8F%AA%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E4%BB%96%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E5%8D%B3%E5%8F%AF%E3%80%82">https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了，作为Java程序员这一块并不作一个简单要求，并不需要大家过于精通，只需要知道他有什么作用即可。</a></p>
<h4 id="原子性的含义"><a href="#原子性的含义" class="headerlink" title="原子性的含义"></a><a href="https://so.csdn.net/so/search?q=%E5%8E%9F%E5%AD%90%E6%80%A7&spm=1001.2101.3001.7020">原子性的含义</a></h4><p>首先何为<strong>原子性</strong> ？原子性 是指<strong>操作不可分割</strong>，要么全部执行成功，要么全部执行失败，中间不会被打断。</p>
<p><strong>使用 lua 脚本就可以实现一组操作的原子性</strong>，这些操作作为一个整体，要么全部执行成功，要么全部执行失败，也就不会存在不同的操作先后执行、多个线程之间相互穿插的情况了。</p>
<h4 id="Redis-单线程模型"><a href="#Redis-单线程模型" class="headerlink" title="Redis 单线程模型"></a>Redis 单线程模型</h4><p><strong>redis 是一个单线程模型的数据库</strong>。redis 虽然可以支持多个客户端的并发连接，<strong>但是每个客户端的操作其实是按照顺序进行的</strong>。也就是说，如果一个客户端正在执行某个操作，其他客户端需要等待这个操作执行完毕后才能进行操作。</p>
<p>看到这里，应该也就能够明白了。我们把多个操作写成一个 lua 脚本，使其具备原子性，作为一个整体执行。再由于 redis 是单线程模型，<strong>不同线程的 lua 脚本是依次执行的</strong>。也就是说，<strong>只有一个线程原子性的多个操作执行完，下一个线程才可以执行</strong>。实际上也是保证了在 redis 内部不同线程操作的串行执行，从而能够解决并发安全问题。</p>
<p>因此，结合 lua 脚本可以实现原子操作，对于需要对多个 key 进行操作的场景，可以把多个操作封装到一个 lua 脚本中，这样就可以保证这些操作的原子性，避免多个线程之间的数据竞争问题，从而保证<a href="https://so.csdn.net/so/search?q=Redis%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020">Redis数据库</a>的数据一致性和可靠性。</p>
<h4 id="Lua-脚本语法"><a href="#Lua-脚本语法" class="headerlink" title="Lua 脚本语法"></a>Lua 脚本语法</h4><p>这里重点介绍Redis提供的调用函数，语法如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其它参数&#x27;</span>, ...)</span><br></pre></td></tr></table></figure>

<p>例如，我们要执行set name jack，则脚本是这样：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"># 执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"># 先执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>)</span><br><span class="line"># 再执行 get name</span><br><span class="line"><span class="keyword">local</span> name = redis.call(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"># 返回</span><br><span class="line"><span class="keyword">return</span> name</span><br></pre></td></tr></table></figure>

<p>写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653392181413.png" alt="1653392181413"></p>
<p>例如，我们要执行 redis.call(‘set’, ‘name’, ‘jack’) 这个脚本，语法如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653392218531.png" alt="1653392218531"></p>
<p>如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653392438917.png" alt="1653392438917"></p>
<p>接下来我们来回一下我们释放锁的逻辑：</p>
<p>释放锁的业务流程是这样的</p>
<p>​    1、获取锁中的线程标示</p>
<p>​    2、判断是否与指定的标示（当前线程标示）一致</p>
<p>​    3、如果一致则释放锁（删除）</p>
<p>​    4、如果不一致则什么都不做</p>
<p>如果用Lua脚本来表示则是这样的：</p>
<p>最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h3 id="利用Java代码调用Lua脚本改造分布式锁"><a href="#利用Java代码调用Lua脚本改造分布式锁" class="headerlink" title="利用Java代码调用Lua脚本改造分布式锁"></a>利用Java代码调用Lua脚本改造分布式锁</h3><p>lua脚本本身并不需要大家花费太多时间去研究，只需要知道如何调用，大致是什么意思即可，所以在笔记中并不会详细的去解释这些lua表达式的含义。</p>
<p>我们的RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图股</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653393304844.png" alt="1653393304844"></p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br><span class="line">经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~</span><br></pre></td></tr></table></figure>

<p>小总结：</p>
<p>基于Redis的分布式锁实现思路：</p>
<ul>
<li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li>
<li>释放锁时先判断线程标示是否与自己一致，一致则删除锁<ul>
<li>特性：<ul>
<li>利用set nx满足互斥性</li>
<li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li>
<li>利用Redis集群保证高可用和高并发特性</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>笔者总结：我们一路走来，利用添加过期时间，防止死锁问题的发生，但是有了过期时间之后，可能出现误删别人锁的问题，这个问题我们开始是利用删之前 通过拿锁，比锁，删锁这个逻辑来解决的，也就是删之前判断一下当前这把锁是否是属于自己的，但是现在还有原子性问题，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后通过lua表达式来解决这个问题</p>
<p>但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission啦</p>
<p><strong>测试逻辑：</strong></p>
<p>第一个线程进来，得到了锁，手动删除锁，模拟锁超时了，其他线程会执行lua来抢锁，当第一天线程利用lua删除锁时，lua能保证他不能删除他的锁，第二个线程删除锁时，利用lua同样可以保证不会删除别人的锁，同时还能保证原子性。</p>
<h2 id="分布式锁-Redission"><a href="#分布式锁-Redission" class="headerlink" title="分布式锁-Redission"></a>分布式锁-Redission</h2><h3 id="分布式锁-Redission-功能介绍"><a href="#分布式锁-Redission-功能介绍" class="headerlink" title="分布式锁-Redission 功能介绍"></a>分布式锁-Redission 功能介绍</h3><p>基于setnx实现的分布式锁存在下面的问题：</p>
<p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，<strong>他的方法都是使用synchronized修饰</strong>的（锁对象都是this），假如他在A方法内，调用B方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p>
<p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p>
<p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p>
<p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653546070602.png" alt="1653546070602"></p>
<p>那么什么是Redission呢</p>
<p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p>
<p>Redission提供了分布式锁的多种多样的功能</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653546736063.png" alt="1653546736063"></p>
<h3 id="分布式锁-Redission-快速入门"><a href="#分布式锁-Redission-快速入门" class="headerlink" title="分布式锁-Redission 快速入门"></a>分布式锁-Redission 快速入门</h3><p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置Redisson客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.150.101:6379&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如何使用Redission的分布式锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 VoucherOrderServiceImpl</p>
<p>注入RedissonClient</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询优惠券</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 尚未开始</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 尚未开始</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 库存不足</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//创建锁对象 这个代码不用了，因为我们现在要使用分布式锁</span></span><br><span class="line">        <span class="comment">//SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">        <span class="comment">//获取锁对象</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">       </span><br><span class="line">		<span class="comment">//加锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">            <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="分布式锁-Redission-可重入锁原理"><a href="#分布式锁-Redission-可重入锁原理" class="headerlink" title="分布式锁-Redission 可重入锁原理"></a>分布式锁-Redission 可重入锁原理</h3><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state=0，假如有人持有这把锁，那么state=1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0 时，表示当前这把锁没有被人持有。  </p>
<p>在redission中，我们的也支持支持可重入锁</p>
<p>在分布式锁中，他采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有，所以接下来我们一起分析一下当前的这个lua表达式</p>
<p>这个地方一共有3个参数</p>
<p><strong>KEYS[1] ： 锁名称</strong></p>
<p><strong>ARGV[1]：  锁失效时间</strong></p>
<p><strong>ARGV[2]：  id + “:” + threadId; 锁的小key</strong></p>
<p>exists: 判断数据是否存在  name：是lock是否存在,如果==0，就表示当前这把锁不存在</p>
<p>redis.call(‘hset’, KEYS[1], ARGV[2], 1);此时他就开始往redis里边去写数据 ，写成一个hash结构</p>
<p>Lock{</p>
<p>​    id + <strong>“:”</strong> + threadId :  1</p>
<p>}</p>
<p>如果当前这把锁存在，则第一个条件不满足，再判断</p>
<p>redis.call(‘hexists’, KEYS[1], ARGV[2]) == 1</p>
<p>此时需要通过大key+小key判断当前这把锁是否是属于自己的，如果是自己的，则进行</p>
<p>redis.call(‘hincrby’, KEYS[1], ARGV[2], 1)</p>
<p>将当前这个锁的value进行+1 ，redis.call(‘pexpire’, KEYS[1], ARGV[1]); 然后再对其设置过期时间，如果以上两个条件都不满足，则表示当前这把锁抢锁失败，最后返回pttl，即为当前这把锁的失效时间</p>
<p>如果小伙帮们看了前边的源码， 你会发现他会去判断当前这个方法的返回值是否为null，如果是null，则对应则前两个if对应的条件，退出抢锁逻辑，如果返回的不是null，即走了第三个分支，在源码处会进行while(true)的自旋抢锁。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653548087334.png" alt="1653548087334"></p>
<h3 id="分布式锁-Redission锁重试和WatchDog机制"><a href="#分布式锁-Redission锁重试和WatchDog机制" class="headerlink" title="分布式锁-Redission锁重试和WatchDog机制"></a>分布式锁-Redission锁重试和WatchDog机制</h3><p><strong>说明</strong>：由于课程中已经说明了有关tryLock的源码解析以及其看门狗原理，所以笔者在这里给大家分析lock()方法的源码解析，希望大家在学习过程中，能够掌握更多的知识</p>
<p>抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p>
<p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p>
<p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p>
<p>所以如果返回是null，则代表着当前这哥们已经抢锁完毕，或者可重入完毕，但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，同学们可以自行往下翻一点点，你能发现有个while( true) 再次进行tryAcquire进行抢锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line"><span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line"><span class="comment">// lock acquired</span></span><br><span class="line"><span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来会有一个条件分支，因为lock方法有重载方法，一个是带参数，一个是不带参数，如果带带参数传入的值是-1，如果传入参数，则leaseTime是他本身，所以如果传入了参数，此时leaseTime != -1 则会进去抢锁，抢锁的逻辑就是之前说的那三个逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是没有传入时间，则此时也会进行抢锁， 而且抢锁时间是默认看门狗时间 commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()</p>
<p>ttlRemainingFuture.onComplete((ttlRemaining, e) 这句话相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class="line">                                        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">                                        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock acquired</span></span><br><span class="line">    <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">        scheduleExpirationRenewal(threadId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> ttlRemainingFuture;</span><br></pre></td></tr></table></figure>

<p>此逻辑就是续约逻辑，注意看commandExecutor.getConnectionManager().newTimeout（） 此方法</p>
<p>Method(  <strong>new</strong> TimerTask() {},参数2 ，参数3  )</p>
<p>指的是：通过参数2，参数3 去描述什么时候去做参数1的事情，现在的情况是：10s之后去做参数一的事情</p>
<p>因为锁的失效时间是30s，当10s之后，此时这个timeTask 就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约</p>
<p>那么大家可以想一想，假设我们的线程出现了宕机他还会续约吗？当然不会，因为没有人再去调用renewExpiration这个方法，所以等到时间之后自然就释放了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">            <span class="keyword">if</span> (ent == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">            <span class="keyword">if</span> (threadId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">// reschedule itself</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    </span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Redisson-获取锁、释放锁逻辑"><a href="#Redisson-获取锁、释放锁逻辑" class="headerlink" title="Redisson 获取锁、释放锁逻辑"></a>Redisson 获取锁、释放锁逻辑</h4><p>tryLock() 只获取一次，不重试</p>
<p>tryLock(waitTime, leaseTime, TimeUnit) 可重试，有等待时间和超时释放</p>
<p><code>leaseTime</code>超时释放时间，<code>waitTime</code>最大等待时间</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241109153113839.png" alt="image-20241109153113839"></p>
<h5 id="超时续约（TTL与业务执行情况挂钩）"><a href="#超时续约（TTL与业务执行情况挂钩）" class="headerlink" title="超时续约（TTL与业务执行情况挂钩）"></a>超时续约（TTL与业务执行情况挂钩）</h5><p>获取成功，但不设置释放时间，此时会把leaseTime设置为-1，然后开启看门狗线程，设置定时任务定时更新TTL，实现了锁有效期的不断重置。<strong>如何跟业务产生联系</strong>：当业务执行完毕会释放锁，此时会将定时任务取消。如果看门狗线程出现宕机，过一段时间也会自动释放。</p>
<p>在释放的同时会发布<code>publish</code>一个释放的消息给其他等待的线程。</p>
<h5 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h5><p>获取失败会订阅<code>subscribe</code>释放的消息，再等一段时间，如果获取到释放锁的信号，重试获取锁，如果一直没获取到，超出最大等待时间之后会返回false。</p>
<h3 id="分布式锁-Redission锁的MultiLock原理"><a href="#分布式锁-Redission锁的MultiLock原理" class="headerlink" title="分布式锁-Redission锁的MultiLock原理"></a>分布式锁-Redission锁的MultiLock原理</h3><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p>
<p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653553998403.png" alt="1653553998403"></p>
<p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653554055048.png" alt="1653554055048"></p>
<p>那么MutiLock 加锁原理是什么呢？笔者画了一幅图来说明</p>
<p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间(waitTime)，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试，重试要从头再来。</p>
<p>成功获取所有锁之后，如果之前设置了leaseTime释放时间，还要重新设置一下TTL，因为成功获取一把锁，这把锁就开始倒计时了，导致expireTime不统一</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653553093967.png" alt="1653553093967"></p>
<h3 id="分布式锁-总结"><a href="#分布式锁-总结" class="headerlink" title="分布式锁 总结"></a>分布式锁 总结</h3><h4 id="不可重入Redis分布式锁—基于setnx"><a href="#不可重入Redis分布式锁—基于setnx" class="headerlink" title="不可重入Redis分布式锁—基于setnx"></a>不可重入Redis分布式锁—基于setnx</h4><p>利用setnx互斥性，释放锁时使用线程标示防止误删</p>
<p>缺陷：不可重入（同一线程无法重复获取）无法重试（完全非阻塞）超时失效</p>
<h4 id="可重入Redis分布式锁—基于Redisson"><a href="#可重入Redis分布式锁—基于Redisson" class="headerlink" title="可重入Redis分布式锁—基于Redisson"></a>可重入Redis分布式锁—基于Redisson</h4><p>与ReentrantLock类似，利用Hash结构，记录线程标示，同时也记录重入次数（可重入）</p>
<p>使用Watchdog机制实现超时可续约，将锁与业务执行情况挂钩。</p>
<p>利用信号量，使用发布订阅这样的异步等待机制实现可重试</p>
<p>缺点：Redis主从模式下主机宕机会引起锁失效</p>
<h4 id="铁锁连环—Redisson-Multilock"><a href="#铁锁连环—Redisson-Multilock" class="headerlink" title="铁锁连环—Redisson Multilock"></a>铁锁连环—Redisson Multilock</h4><p>将多个Redisson锁合并成一把锁，必须把这些锁全部拿到才算获取成功，一扇门用若干锁锁起来。</p>
<p>缺陷：运维成本高，需要多个Redis节点，实现起来较为复杂</p>
<h2 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h2><h3 id="秒杀优化-异步秒杀思路"><a href="#秒杀优化-异步秒杀思路" class="headerlink" title="秒杀优化-异步秒杀思路"></a>秒杀优化-异步秒杀思路</h3><p>我们来回顾一下下单流程</p>
<p>当用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤</p>
<p>1、查询优惠卷</p>
<p><mark>2、判断秒杀库存是否足够<mark></p>
<p>3、查询订单</p>
<p><mark>4、校验是否是一人一单<mark></p>
<p>5、扣减库存</p>
<p>6、创建订单</p>
<p>在这六步操作中，又有很多操作是要去操作数据库的，而且还是一个线程串行执行， 这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行，那么如何加速呢？</p>
<p>在这里笔者想给大家分享一下课程内没有的思路，看看有没有小伙伴这么想，比如，我们可以不可以使用异步编排来做，或者说我开启N多线程，N多个线程，一个线程执行查询优惠卷，一个执行判断扣减库存，一个去创建订单等等，然后再统一做返回，这种做法和课程中有哪种好呢？答案是课程中的好，因为如果你采用我刚说的方式，如果访问的人很多，那么线程池中的线程可能一下子就被消耗完了，而且你使用上述方案，最大的特点在于，你觉得时效性会非常重要，但是你想想是吗？并不是，比如我只要确定他能做这件事，然后我后边慢慢做就可以了，我并不需要他一口气做完这件事，所以我们应当采用的是课程中，类似消息队列的方式来完成我们的需求，而不是使用线程池或者是异步编排的方式来完成这个需求。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653560986599.png" alt="1653560986599"></p>
<p>优化方案：我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点</p>
<p>第一个难点是我们怎么在redis中去快速校验一人一单，还有库存判断</p>
<p>第二个难点是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653561657295.png" alt="1653561657295"></p>
<p>我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua来操作</p>
<p>当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653562234886.png" alt="1653562234886"></p>
<h3 id="秒杀优化-Redis完成秒杀资格判断"><a href="#秒杀优化-Redis完成秒杀资格判断" class="headerlink" title="秒杀优化-Redis完成秒杀资格判断"></a>秒杀优化-Redis完成秒杀资格判断</h3><p>需求：</p>
<ul>
<li><p>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</p>
</li>
<li><p>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</p>
</li>
<li><p>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列  </p>
</li>
<li><p>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1656080546603.png" alt="1656080546603"></p>
</li>
</ul>
<p>VoucherServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    <span class="comment">//SECKILL_STOCK_KEY 这个变量定义在RedisConstans中</span></span><br><span class="line">    <span class="comment">//private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整lua表达式</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1.参数列表</span></span><br><span class="line"><span class="comment">-- 1.1.优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 1.2.用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 1.3.订单id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1.库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2.订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1.判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2.库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3.存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.4.扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5.下单（保存用户）sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span></span><br><span class="line">redis.call(<span class="string">&#x27;xadd&#x27;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;id&#x27;</span>, orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>当以上lua表达式执行完毕后，剩下的就是根据步骤3,4来执行我们接下来的任务了</p>
<p>VoucherOrderServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//获取用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">// 1.执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">            SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(),</span><br><span class="line">            voucherId.toString(), userId.toString(), String.valueOf(orderId)</span><br><span class="line">    );</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">    <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TODO 保存阻塞队列</span></span><br><span class="line">    <span class="comment">// 3.返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="秒杀优化-基于阻塞队列实现秒杀优化"><a href="#秒杀优化-基于阻塞队列实现秒杀优化" class="headerlink" title="秒杀优化-基于阻塞队列实现秒杀优化"></a>秒杀优化-基于阻塞队列实现秒杀优化</h3><p>VoucherOrderServiceImpl</p>
<p>修改下单动作，现在我们去下单时，是通过lua表达式去原子执行判断逻辑，如果判断我出来不为0 ，则要么是库存不足，要么是重复下单，返回错误信息，如果是0，则把下单的逻辑保存到队列中去，然后异步执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异步处理线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">   SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于线程池处理的任务</span></span><br><span class="line"><span class="comment">// 当初始化完毕后，就会去从对列中去拿信息</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1.获取队列中的订单信息</span></span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                    <span class="comment">// 2.创建订单</span></span><br><span class="line">                    handleVoucherOrder(voucherOrder);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">          	 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取用户</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">            <span class="comment">// 2.创建锁对象</span></span><br><span class="line">            <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">            <span class="comment">// 3.尝试获取锁</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.lock();</span><br><span class="line">            <span class="comment">// 4.判断是否获得锁成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 获取锁失败，直接返回失败或者重试</span></span><br><span class="line">                log.error(<span class="string">&quot;不允许重复下单！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效</span></span><br><span class="line">                proxy.createVoucherOrder(voucherOrder);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                redisLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//a</span></span><br><span class="line">	<span class="keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks =<span class="keyword">new</span>  <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.执行lua脚本</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">                SECKILL_SCRIPT,</span><br><span class="line">                Collections.emptyList(),</span><br><span class="line">                voucherId.toString(), userId.toString(), String.valueOf(orderId)</span><br><span class="line">        );</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">        <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 2.3.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 2.4.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 2.5.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="comment">// 2.6.放入阻塞队列</span></span><br><span class="line">        orderTasks.add(voucherOrder);</span><br><span class="line">        <span class="comment">//3.获取代理对象</span></span><br><span class="line">         proxy = (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">        <span class="comment">//4.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">      <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">           log.error(<span class="string">&quot;用户已经购买过了&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="秒杀业务的优化思路"><a href="#秒杀业务的优化思路" class="headerlink" title="秒杀业务的优化思路"></a>秒杀业务的优化思路</h3><p>之前：通过查数据库判断用户是否有资格下单，然后同步创建订单对象</p>
<p>现在：</p>
<ul>
<li>先利用Redis完成库存余量、一人一单判断，提前创建订单，完成抢单业务（直接返回给前端结果）</li>
<li>再将下单业务放入阻塞队列，利用独立线程异步下单，完成数据库的更改</li>
</ul>
<h4 id="基于阻塞队列的异步秒杀存在哪些问题"><a href="#基于阻塞队列的异步秒杀存在哪些问题" class="headerlink" title="基于阻塞队列的异步秒杀存在哪些问题"></a>基于阻塞队列的异步秒杀存在哪些问题</h4><ul>
<li>内存限制问题：BlockingQueue基于JVM，会受JVM内存限制</li>
<li>数据安全问题：<ul>
<li>JVM宕机会导致订单信息全部丢失，无法进行数据库更改</li>
<li>订单从阻塞队列中取出，执行之前发生了一些问题，导致任务失败，但是已经找不回来了</li>
</ul>
</li>
</ul>
<h2 id="Redis消息队列（Stream）"><a href="#Redis消息队列（Stream）" class="headerlink" title="Redis消息队列（Stream）"></a>Redis消息队列（Stream）</h2><h3 id="Redis消息队列-认识消息队列"><a href="#Redis消息队列-认识消息队列" class="headerlink" title="Redis消息队列-认识消息队列"></a>Redis消息队列-认识消息队列</h3><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p>
<ul>
<li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li>
<li>生产者：发送消息到消息队列</li>
<li>消费者：从消息队列获取消息并处理消息</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653574849336.png" alt="1653574849336"></p>
<p>使用队列的好处在于 <strong>解耦：</strong>所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。</p>
<p>这种场景在我们秒杀中就变成了：我们下单之后，利用redis去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。</p>
<p>这里我们可以使用一些现成的mq，比如kafka，rabbitmq等等，但是呢，如果没有安装mq，我们也可以直接使用redis提供的mq方案，降低我们的部署和学习成本。</p>
<h3 id="Redis消息队列-基于List实现消息队列"><a href="#Redis消息队列-基于List实现消息队列" class="headerlink" title="Redis消息队列-基于List实现消息队列"></a>Redis消息队列-基于List实现消息队列</h3><p><strong>基于List结构模拟消息队列</strong></p>
<p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p>
<p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653575176451.png" alt="1653575176451"></p>
<p>基于List的消息队列有哪些优缺点？<br>优点：</p>
<ul>
<li>利用Redis存储，不受限于JVM内存上限</li>
<li>基于Redis的持久化机制，数据安全性有保证</li>
<li>可以满足消息有序性</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法避免消息丢失</li>
<li>只支持单消费者</li>
</ul>
<h3 id="Redis消息队列-基于PubSub的消息队列"><a href="#Redis消息队列-基于PubSub的消息队列" class="headerlink" title="Redis消息队列-基于PubSub的消息队列"></a>Redis消息队列-基于PubSub的消息队列</h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p>
<p> SUBSCRIBE channel [channel] ：订阅一个或多个频道<br> PUBLISH channel msg ：向一个频道发送消息<br> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653575506373.png" alt="1653575506373"></p>
<p>基于PubSub的消息队列有哪些优缺点？<br>优点：</p>
<ul>
<li>采用发布订阅模型，支持多生产、多消费</li>
</ul>
<p>缺点：</p>
<ul>
<li>不支持数据持久化</li>
<li>无法避免消息丢失</li>
<li>消息堆积有上限，超出时数据丢失</li>
</ul>
<h3 id="Redis消息队列-基于Stream的消息队列"><a href="#Redis消息队列-基于Stream的消息队列" class="headerlink" title="Redis消息队列-基于Stream的消息队列"></a>Redis消息队列-基于Stream的消息队列</h3><p>Stream 是 Redis 5.0引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p>
<p>发送消息的命令：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577301737.png" alt="1653577301737"></p>
<p>例如：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577349691.png" alt="1653577349691"></p>
<p>读取消息的方式之一：XREAD</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577445413.png" alt="1653577445413"></p>
<p>例如，使用XREAD读取第一个消息：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577643629.png" alt="1653577643629"></p>
<p>XREAD阻塞方式，读取最新的消息：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577659166.png" alt="1653577659166"></p>
<p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577689129.png" alt="1653577689129"></p>
<p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p>
<p>STREAM类型消息队列的XREAD命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>一个消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li>有消息漏读的风险</li>
</ul>
<h3 id="Redis消息队列-基于Stream的消息队列-消费者组"><a href="#Redis消息队列-基于Stream的消息队列-消费者组" class="headerlink" title="Redis消息队列-基于Stream的消息队列-消费者组"></a>Redis消息队列-基于Stream的消息队列-消费者组</h3><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577801668.png" alt="1653577801668"></p>
<p>创建消费者组：<br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577984924.png" alt="1653577984924"><br>key：队列名称<br>groupName：消费者组名称<br>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息<br>MKSTREAM：队列不存在时自动创建队列<br>其它常见命令：</p>
<p> <strong>删除指定的消费者组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DESTORY key groupName</span><br></pre></td></tr></table></figure>

<p> <strong>给指定的消费者组添加消费者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br></pre></td></tr></table></figure>

<p> <strong>删除消费者组中的指定消费者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DELCONSUMER key groupname consumername</span><br></pre></td></tr></table></figure>

<p>从消费者组读取消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>group：消费组名称</li>
<li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li>
<li>count：本次查询的最大数量</li>
<li>BLOCK milliseconds：当没有消息时最长等待时间</li>
<li>NOACK：无需手动ACK，获取到消息后自动确认</li>
<li>STREAMS key：指定队列名称</li>
<li>ID：获取消息的起始ID：</li>
</ul>
<p>“&gt;”：从下一个未消费的消息开始<br>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span><br><span class="line">位于消费者组g1的消费者c1读取一条消息，没有消息最长阻塞等待2000ms，</span><br><span class="line">消息来源key为s1，从s1下一个未消费的消息开始</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XACK s1 g1 ID1 ID2 ID3</span><br><span class="line">消息来源为s1，使用g1把ID1 ID2 ID3消息确认，从pendinglist中移除消息</span><br></pre></td></tr></table></figure>



<p>消费者监听消息的基本思路：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653578211854.png" alt="1653578211854">STREAM类型消息队列的XREADGROUP命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>可以多消费者争抢消息，加快消费速度</li>
<li>可以阻塞读取</li>
<li>没有消息漏读的风险</li>
<li>有消息确认机制，保证消息至少被消费一次</li>
</ul>
<p>最后我们来个小对比</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653578560691.png" alt="1653578560691"></p>
<h3 id="基于Redis的Stream结构作为消息队列，实现异步秒杀下单"><a href="#基于Redis的Stream结构作为消息队列，实现异步秒杀下单" class="headerlink" title="基于Redis的Stream结构作为消息队列，实现异步秒杀下单"></a>基于Redis的Stream结构作为消息队列，实现异步秒杀下单</h3><p>需求：</p>
<ul>
<li>创建一个Stream类型的消息队列，名为stream.orders</li>
<li>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</li>
<li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单\</li>
</ul>
<p>修改lua表达式,新增3.6</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1656082824939.png" alt="1656082824939"></p>
<p>VoucherOrderServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                    StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.lastConsumed())</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有消息，继续下一次循环</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                <span class="comment">//处理异常消息</span></span><br><span class="line">                handlePendingList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                    StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有异常消息，结束循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理pendding订单异常&quot;</span>, e);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Redis消息队列—Stream结构总结"><a href="#Redis消息队列—Stream结构总结" class="headerlink" title="Redis消息队列—Stream结构总结"></a>Redis消息队列—Stream结构总结</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577801668.png" alt="1653577801668"></p>
<p>STREAM类型消息队列的XREADGROUP命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>可阻塞读取</li>
<li>消息可分流：多个消费者争抢消息，加快处理速度</li>
<li>消息标示机制：确保没有消息被漏读</li>
<li>消息确认机制：获取消息后加入pending-list，处理完成要通过XACK从pending-list移除，实现消息回溯</li>
<li>保证消息至少被消费一次</li>
</ul>
<p>最后我们来个小对比</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653578560691.png" alt="1653578560691"></p>
<p>——秒杀 完——</p>
<h2 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h2><h3 id="达人探店-发布探店笔记"><a href="#达人探店-发布探店笔记" class="headerlink" title="达人探店-发布探店笔记"></a>达人探店-发布探店笔记</h3><p>发布探店笔记</p>
<p>探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个：<br>tb_blog：探店笔记表，包含笔记中的标题、文字、图片等<br>tb_blog_comments：其他用户对探店笔记的评价</p>
<p><strong>具体发布流程</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653578992639.png" alt="1653578992639"></p>
<p>上传接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;blog&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">uploadImage</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile image)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取原始文件名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line">            <span class="comment">// 生成新文件名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> createNewFileName(originalFilename);</span><br><span class="line">            <span class="comment">// 保存文件</span></span><br><span class="line">            image.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, fileName));</span><br><span class="line">            <span class="comment">// 返回结果</span></span><br><span class="line">            log.debug(<span class="string">&quot;文件上传成功，&#123;&#125;&quot;</span>, fileName);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件上传失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：同学们在操作时，需要修改SystemConstants.IMAGE_UPLOAD_DIR 自己图片所在的地址，在实际开发中图片一般会放在nginx上或者是云存储上。</p>
<p>BlogController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/blog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlogController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IBlogService blogService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(<span class="meta">@RequestBody</span> Blog blog)</span> &#123;</span><br><span class="line">        <span class="comment">//获取登录用户</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        blog.setUpdateTime(user.getId());</span><br><span class="line">        <span class="comment">//保存探店博文</span></span><br><span class="line">        blogService.saveBlog(blog);</span><br><span class="line">        <span class="comment">//返回id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="达人探店-查看探店笔记"><a href="#达人探店-查看探店笔记" class="headerlink" title="达人探店-查看探店笔记"></a>达人探店-查看探店笔记</h3><p>实现查看发布探店笔记的接口</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653579931626.png" alt="1653579931626"></p>
<p>实现代码：</p>
<p>BlogServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询blog</span></span><br><span class="line">    <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="keyword">if</span> (blog == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;笔记不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.查询blog有关的用户</span></span><br><span class="line">    queryBlogUser(blog);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="达人探店-点赞功能"><a href="#达人探店-点赞功能" class="headerlink" title="达人探店-点赞功能"></a>达人探店-点赞功能</h3><p>初始代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//修改点赞数量</span></span><br><span class="line">    blogService.update().setSql(<span class="string">&quot;liked = liked +1 &quot;</span>).eq(<span class="string">&quot;id&quot;</span>,id).update();</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题分析：这种方式会导致一个用户无限点赞，明显是不合理的</p>
<p>造成这个问题的原因是，我们现在的逻辑，发起请求只是给数据库+1，所以才会出现这个问题</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653581590453.png" alt="1653581590453"></p>
<p>完善点赞功能</p>
<p>需求：</p>
<ul>
<li>同一个用户只能点赞一次，再次点击则取消点赞</li>
<li>如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</li>
</ul>
<p>实现步骤：</p>
<ul>
<li>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</li>
<li>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1</li>
<li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</li>
<li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li>
</ul>
<p>为什么采用set集合：</p>
<p>因为我们的数据是不能重复的，当用户操作过之后，无论他怎么操作，都是</p>
<p>具体步骤：</p>
<p>1、在Blog 添加一个字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableField(exist = false)</span></span><br><span class="line"><span class="keyword">private</span> Boolean isLike;</span><br></pre></td></tr></table></figure>

<p>2、修改代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">       <span class="comment">// 1.获取登录用户</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());</span><br><span class="line">       <span class="keyword">if</span>(BooleanUtil.isFalse(isMember))&#123;</span><br><span class="line">            <span class="comment">//3.如果未点赞，可以点赞</span></span><br><span class="line">           <span class="comment">//数据库点赞数+1</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">           <span class="comment">//保存用户到Redis的set集合</span></span><br><span class="line">           <span class="keyword">if</span>(isSuccess)&#123;</span><br><span class="line">               stringRedisTemplate.opsForSet().add(key,userId.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//4.如果已点赞，取消点赞</span></span><br><span class="line">           <span class="comment">//数据库点赞数-1</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">           <span class="comment">//把用户从Redis的set集合移除</span></span><br><span class="line">           <span class="keyword">if</span>(isSuccess)&#123;</span><br><span class="line">               stringRedisTemplate.opsForSet().remove(key,userId.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="达人探店-点赞排行榜"><a href="#达人探店-点赞排行榜" class="headerlink" title="达人探店-点赞排行榜"></a>达人探店-点赞排行榜</h3><p>在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的TOP5，形成点赞排行榜：</p>
<p>之前的点赞是放到set集合，但是set集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的set集合，就是咱们的sortedSet</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653805077118.png" alt="1653805077118"></p>
<p>我们接下来来对比一下这些集合的区别是什么</p>
<p>所有点赞的人，需要是唯一的，所以我们应当使用set或者是sortedSet</p>
<p>其次我们需要排序，就可以直接锁定使用sortedSet啦</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653805203758.png" alt="1653805203758"></p>
<p>修改代码</p>
<p>BlogServiceImpl</p>
<p>点赞逻辑代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">     <span class="comment">// 1.获取登录用户</span></span><br><span class="line">     <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">     <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">     <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">     <span class="keyword">if</span> (score == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 3.如果未点赞，可以点赞</span></span><br><span class="line">         <span class="comment">// 3.1.数据库点赞数 + 1</span></span><br><span class="line">         <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">         <span class="comment">// 3.2.保存用户到Redis的set集合  zadd key value score</span></span><br><span class="line">         <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">             stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 4.如果已点赞，取消点赞</span></span><br><span class="line">         <span class="comment">// 4.1.数据库点赞数 -1</span></span><br><span class="line">         <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">         <span class="comment">// 4.2.把用户从Redis的set集合移除</span></span><br><span class="line">         <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">             stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> Result.ok();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">isBlogLiked</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">     <span class="comment">// 1.获取登录用户</span></span><br><span class="line">     <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">     <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 用户未登录，无需查询是否点赞</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> user.getId();</span><br><span class="line">     <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;blog:liked:&quot;</span> + blog.getId();</span><br><span class="line">     <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">     blog.setIsLike(score != <span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>点赞列表查询列表</p>
<p>BlogController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogLikes(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MySQL自定义排序-ORDER-BY-FIELD"><a href="#MySQL自定义排序-ORDER-BY-FIELD" class="headerlink" title="MySQL自定义排序 ORDER BY FIELD"></a>MySQL自定义排序 ORDER BY FIELD</h4><p>MySQL查询结果如果不指定排序顺序，返回结果通常是不确定的，而点赞排行榜是按照用户的点赞时间先后顺序排序的，所以要显式指定特定的排序规则，</p>
<p>根据用户ids查询用户 WHERE id IN ( 5 , 1 )  结果默认是按照ids中元素的id大小升序排序的，我们要让ids的顺序保留到最后，使用ORDER BY FIELD </p>
<p>BlogService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">    <span class="comment">// 1.查询top5的点赞用户 zrange key 0 4</span></span><br><span class="line">    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (top5 == <span class="literal">null</span> || top5.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.解析出其中的用户id</span></span><br><span class="line">    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    <span class="comment">// 3.根据用户id查询用户 WHERE id IN ( 5 , 1 ) ORDER BY FIELD(id, 5, 1)</span></span><br><span class="line">    List&lt;UserDTO&gt; userDTOS = userService.query()</span><br><span class="line">            .in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list()</span><br><span class="line">            .stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 4.返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h2><h3 id="好友关注-关注和取消关注"><a href="#好友关注-关注和取消关注" class="headerlink" title="好友关注-关注和取消关注"></a>好友关注-关注和取消关注</h3><p>针对用户的操作：可以对用户进行关注和取消关注功能。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653806140822.png" alt="1653806140822"></p>
<p>实现思路：</p>
<p>需求：基于该表数据结构，实现两个接口：</p>
<ul>
<li>关注和取关接口</li>
<li>判断是否关注的接口</li>
</ul>
<p>关注是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来标示：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653806253817.png" alt="1653806253817"></p>
<p>注意: 这里需要把主键修改为自增长，简化开发。</p>
<p>FollowController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关注</span></span><br><span class="line"><span class="meta">@PutMapping(&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long followUserId, <span class="meta">@PathVariable(&quot;isFollow&quot;)</span> Boolean isFollow)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> followService.follow(followUserId, isFollow);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取消关注</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long followUserId)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> followService.isFollow(followUserId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FollowService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">取消关注service</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(Long followUserId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">// 2.查询是否关注 select count(*) from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId).count();</span><br><span class="line">        <span class="comment">// 3.判断</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(count &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> 关注service</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFollow)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">        <span class="comment">// 1.判断到底是关注还是取关</span></span><br><span class="line">        <span class="keyword">if</span> (isFollow) &#123;</span><br><span class="line">            <span class="comment">// 2.关注，新增数据</span></span><br><span class="line">            <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">            follow.setUserId(userId);</span><br><span class="line">            follow.setFollowUserId(followUserId);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(follow);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">            remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;()</span><br><span class="line">                    .eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="好友关注-共同关注"><a href="#好友关注-共同关注" class="headerlink" title="好友关注-共同关注"></a>好友关注-共同关注</h3><p>想要去看共同关注的好友，需要首先进入到这个页面，这个页面会发起两个请求</p>
<p>1、去查询用户的详情</p>
<p>2、去查询用户的笔记</p>
<p>以上两个功能和共同关注没有什么关系，大家可以自行将笔记中的代码拷贝到idea中就可以实现这两个功能了，我们的重点在于共同关注功能。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653806706296.png" alt="1653806706296"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UserController 根据id查询用户</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span>&#123;</span><br><span class="line">	<span class="comment">// 查询详情</span></span><br><span class="line">	<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line">	<span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> Result.ok();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">	<span class="comment">// 返回</span></span><br><span class="line">	<span class="keyword">return</span> Result.ok(userDTO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BlogController  根据id查询博主的探店笔记</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/of/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogByUserId</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params">		<span class="meta">@RequestParam(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">	<span class="comment">// 根据用户查询</span></span><br><span class="line">	Page&lt;Blog&gt; page = blogService.query()</span><br><span class="line">			.eq(<span class="string">&quot;user_id&quot;</span>, id).page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));</span><br><span class="line">	<span class="comment">// 获取当前页数据</span></span><br><span class="line">	List&lt;Blog&gt; records = page.getRecords();</span><br><span class="line">	<span class="keyword">return</span> Result.ok(records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们来看看共同关注如何实现：</p>
<p>需求：利用Redis中恰当的数据结构，实现共同关注功能。在博主个人页面展示出当前用户与博主的共同关注呢。</p>
<p>当然是使用我们之前学习过的set集合咯，在set集合中，有交集并集补集的api，我们可以把两人的关注的人分别放入到一个set集合中，然后再通过api去查看这两个set集合中的交集数据。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653806973212.png" alt="1653806973212"></p>
<p>我们先来改造当前的关注列表</p>
<p>改造原因是因为我们需要在用户关注了某位用户后，需要将数据放入到set集合中，方便后续进行共同关注，同时当取消关注时，也需要从set集合中进行删除</p>
<p>FollowServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFollow)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">// 1.判断到底是关注还是取关</span></span><br><span class="line">    <span class="keyword">if</span> (isFollow) &#123;</span><br><span class="line">        <span class="comment">// 2.关注，新增数据</span></span><br><span class="line">        <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">        follow.setUserId(userId);</span><br><span class="line">        follow.setFollowUserId(followUserId);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(follow);</span><br><span class="line">        <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">            <span class="comment">// 把关注用户的id，放入redis的set集合 sadd userId followerUserId</span></span><br><span class="line">            stringRedisTemplate.opsForSet().add(key, followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;()</span><br><span class="line">                .eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId));</span><br><span class="line">        <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">            <span class="comment">// 把关注用户的id从Redis集合中移除</span></span><br><span class="line">            stringRedisTemplate.opsForSet().remove(key, followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体的关注代码：</strong></p>
<p>FollowServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">// 2.求交集</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + id;</span><br><span class="line">    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, key2);</span><br><span class="line">    <span class="keyword">if</span> (intersect == <span class="literal">null</span> || intersect.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 无交集</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.解析id集合</span></span><br><span class="line">    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 4.查询用户</span></span><br><span class="line">    List&lt;UserDTO&gt; users = userService.listByIds(ids)</span><br><span class="line">            .stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> Result.ok(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="好友关注-Feed流-实现"><a href="#好友关注-Feed流-实现" class="headerlink" title="好友关注-Feed流 实现"></a>好友关注-Feed流 实现</h3><p>当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p>
<p>对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653808641260.png" alt="1653808641260"></p>
<p>对于新型的Feed流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653808993693.png" alt="1653808993693"></p>
<p>Feed流的实现有两种模式：</p>
<p>Feed流产品有两种常见模式：<br>Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈</p>
<ul>
<li>优点：信息全面，不会有缺失。并且实现也相对简单</li>
<li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li>
</ul>
<p>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</p>
<ul>
<li>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</li>
<li>缺点：如果算法不精准，可能起到反作用<br>本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种：</li>
</ul>
<p>我们本次针对好友的操作，采用的就是Timeline的方式，只需要拿到我们关注用户的信息，然后按照时间排序即可</p>
<p>，因此采用Timeline的模式。该模式的实现方案有三种：</p>
<ul>
<li>拉模式</li>
<li>推模式</li>
<li>推拉结合</li>
</ul>
<p><strong>拉模式</strong>：也叫做读扩散</p>
<p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序</p>
<p>优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p>
<p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653809450816.png" alt="1653809450816"></p>
<p><strong>推模式</strong>：也叫做写扩散。</p>
<p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p>
<p>优点：时效快，不用临时拉取</p>
<p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653809875208.png" alt="1653809875208"></p>
<p><strong>推拉结合模式</strong>：也叫做读写混合，兼具推和拉两种模式的优点。</p>
<p>推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653812346852.png" alt="1653812346852"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241112191818612.png" alt="image-20241112191818612"></p>
<h3 id="好友关注-推送到粉丝收件箱"><a href="#好友关注-推送到粉丝收件箱" class="headerlink" title="好友关注-推送到粉丝收件箱"></a>好友关注-推送到粉丝收件箱</h3><p>需求：</p>
<ul>
<li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li>
<li>收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现</li>
<li>查询收件箱数据时，可以实现分页查询</li>
</ul>
<p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p>
<p>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</p>
<p>假设在t1 时刻，我们去读取第一页，此时page = 1 ，size = 5 ，那么我们拿到的就是10<del>6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page=2 ，size=5 ，那么此时读取到的第二页实际上是从6 开始，然后是6</del>2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653813047671.png" alt="1653813047671"></p>
<p>Feed流的滚动分页</p>
<p>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</p>
<p>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653813462834.png" alt="1653813462834"></p>
<p>核心的意思：就是我们在保存完探店笔记后，获得到当前笔记的粉丝，然后把数据推送到粉丝的redis中去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取登录用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    blog.setUserId(user.getId());</span><br><span class="line">    <span class="comment">// 2.保存探店笔记</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(blog);</span><br><span class="line">    <span class="keyword">if</span>(!isSuccess)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;新增笔记失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.查询笔记作者的所有粉丝 select * from tb_follow where follow_user_id = ?</span></span><br><span class="line">    List&lt;Follow&gt; follows = followService.query().eq(<span class="string">&quot;follow_user_id&quot;</span>, user.getId()).list();</span><br><span class="line">    <span class="comment">// 4.推送笔记id给所有粉丝</span></span><br><span class="line">    <span class="keyword">for</span> (Follow follow : follows) &#123;</span><br><span class="line">        <span class="comment">// 4.1.获取粉丝id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> follow.getUserId();</span><br><span class="line">        <span class="comment">// 4.2.推送</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.返回id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="好友关注-实现分页查询收邮箱"><a href="#好友关注-实现分页查询收邮箱" class="headerlink" title="好友关注-实现分页查询收邮箱"></a>好友关注-实现分页查询收邮箱</h3><p>需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息：</p>
<p>具体操作如下：</p>
<p>1、每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件</p>
<p>2、我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据</p>
<p>综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。</p>
<p>这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653819821591.png" alt="1653819821591"></p>
<p>一、定义出来具体的返回值实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScrollResult</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;?&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Long minTime;</span><br><span class="line">    <span class="keyword">private</span> Integer offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlogController</p>
<p>注意：RequestParam 表示接受url地址栏传参的注解，当方法上参数的名称和url地址栏不相同时，可以通过RequestParam 来进行指定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/follow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(&quot;lastId&quot;)</span> Long max, <span class="meta">@RequestParam(value = &quot;offset&quot;, defaultValue = &quot;0&quot;)</span> Integer offset)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogOfFollow(max, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlogServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()</span><br><span class="line">        .reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 3.非空判断</span></span><br><span class="line">    <span class="keyword">if</span> (typedTuples == <span class="literal">null</span> || typedTuples.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.解析数据：blogId、minTime（时间戳）、offset</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">    <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">os</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; <span class="comment">// 5 4 4 2 2</span></span><br><span class="line">        <span class="comment">// 4.1.获取id</span></span><br><span class="line">        ids.add(Long.valueOf(tuple.getValue()));</span><br><span class="line">        <span class="comment">// 4.2.获取分数(时间戳）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> tuple.getScore().longValue();</span><br><span class="line">        <span class="keyword">if</span>(time == minTime)&#123;</span><br><span class="line">            os++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            os = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	os = minTime == max ? os : os + offset;</span><br><span class="line">    <span class="comment">// 5.根据id查询blog</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    List&lt;Blog&gt; blogs = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">        <span class="comment">// 5.1.查询blog有关的用户</span></span><br><span class="line">        queryBlogUser(blog);</span><br><span class="line">        <span class="comment">// 5.2.查询blog是否被点赞</span></span><br><span class="line">        isBlogLiked(blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.封装并返回</span></span><br><span class="line">    <span class="type">ScrollResult</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">    r.setList(blogs);</span><br><span class="line">    r.setOffset(os);</span><br><span class="line">    r.setMinTime(minTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="附近商户—GEO"><a href="#附近商户—GEO" class="headerlink" title="附近商户—GEO"></a>附近商户—GEO</h2><h3 id="附近商户-GEO数据结构的基本用法"><a href="#附近商户-GEO数据结构的基本用法" class="headerlink" title="附近商户-GEO数据结构的基本用法"></a>附近商户-GEO数据结构的基本用法</h3><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p>
<ul>
<li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li>
<li>GEODIST：计算指定的两个点之间的距离并返回</li>
<li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li>
<li>GEOPOS：返回指定member的坐标</li>
<li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li>
<li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li>
<li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</li>
</ul>
<h3 id="附近商户-导入店铺数据到GEO"><a href="#附近商户-导入店铺数据到GEO" class="headerlink" title="附近商户-导入店铺数据到GEO"></a>附近商户-导入店铺数据到GEO</h3><p>具体场景说明：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653822036941.png" alt="1653822036941"></p>
<p>当我们点击美食之后，会出现一系列的商家，商家中可以按照多种排序方式，我们此时关注的是距离，这个地方就需要使用到我们的GEO，向后台传入当前app收集的地址(我们此处是写死的) ，以当前坐标作为圆心，同时绑定相同的店家类型type，以及分页信息，把这几个条件传入后台，后台查询出对应的数据再返回。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653822021827.png" alt="1653822021827"></p>
<p>我们要做的事情是：将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。</p>
<p>但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可</p>
<p>代码</p>
<p>HmDianPingApplicationTests</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">loadShopData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询店铺信息</span></span><br><span class="line">    List&lt;Shop&gt; list = shopService.list();</span><br><span class="line">    <span class="comment">// 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合</span></span><br><span class="line">    Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">    <span class="comment">// 3.分批完成写入Redis</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 3.1.获取类型id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        <span class="comment">// 3.2.获取同类型的店铺的集合</span></span><br><span class="line">        List&lt;Shop&gt; value = entry.getValue();</span><br><span class="line">        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(value.size());</span><br><span class="line">        <span class="comment">// 3.3.写入redis GEOADD key 经度 纬度 member</span></span><br><span class="line">        <span class="keyword">for</span> (Shop shop : value) &#123;</span><br><span class="line">            <span class="comment">// stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());</span></span><br><span class="line">            locations.add(<span class="keyword">new</span> <span class="title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(</span><br><span class="line">                    shop.getId().toString(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(), shop.getY())</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.opsForGeo().add(key, locations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="附近商户-实现附近商户—redis逻辑分页查询"><a href="#附近商户-实现附近商户—redis逻辑分页查询" class="headerlink" title="附近商户-实现附近商户—redis逻辑分页查询"></a>附近商户-实现附近商户—redis逻辑分页查询</h3><p>SpringDataRedis的版本并不支持Redis 6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的POM</p>
<p>第一步：导入pom</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>第二步：</p>
<p>ShopController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/type&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;typeId&quot;)</span> Integer typeId,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;x&quot;, required = false)</span> Double x,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;y&quot;, required = false)</span> Double y</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> shopService.queryShopByType(typeId, current, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ShopServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要根据坐标查询</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 不需要坐标查询，按数据库查询</span></span><br><span class="line">            Page&lt;Shop&gt; page = query()</span><br><span class="line">                    .eq(<span class="string">&quot;type_id&quot;</span>, typeId)</span><br><span class="line">                    .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));</span><br><span class="line">            <span class="comment">// 返回数据</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(page.getRecords());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.计算分页参数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> (current - <span class="number">1</span>) * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> current * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询redis、按照距离排序、分页。结果：shopId、distance</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo() <span class="comment">// GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE</span></span><br><span class="line">                .search(</span><br><span class="line">                        key,</span><br><span class="line">                        GeoReference.fromCoordinate(x, y),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Distance</span>(<span class="number">5000</span>),</span><br><span class="line">                        RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">// 4.解析出id</span></span><br><span class="line">        <span class="keyword">if</span> (results == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();</span><br><span class="line">        <span class="keyword">if</span> (list.size() &lt;= from) &#123;</span><br><span class="line">            <span class="comment">// 没有下一页了，结束</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.1.截取 from ~ end的部分</span></span><br><span class="line">        List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());</span><br><span class="line">        Map&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(list.size());</span><br><span class="line">        list.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// 4.2.获取店铺id</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">shopIdStr</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">            ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">            <span class="comment">// 4.3.获取距离</span></span><br><span class="line">            <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> result.getDistance();</span><br><span class="line">            distanceMap.put(shopIdStr, distance);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 5.根据id查询Shop</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">        List&lt;Shop&gt; shops = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">        <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">            shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shops);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="用户签到—BitMap"><a href="#用户签到—BitMap" class="headerlink" title="用户签到—BitMap"></a>用户签到—BitMap</h2><h3 id="用户签到-BitMap功能演示"><a href="#用户签到-BitMap功能演示" class="headerlink" title="用户签到-BitMap功能演示"></a>用户签到-BitMap功能演示</h3><p>我们针对签到功能完全可以通过mysql来完成，比如说以下这张表</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653823145495.png" alt="1653823145495"></p>
<p>用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条</p>
<p>每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共22 字节的内存，一个月则最多需要600多字节</p>
<p>我们如何能够简化一点呢？其实可以考虑小时候一个挺常见的方案，就是小时候，咱们准备一张小小的卡片，你只要签到就打上一个勾，我最后判断你是否签到，其实只需要到小卡片上看一看就知道了</p>
<p>我们可以采用类似这样的方案来实现我们的签到需求。</p>
<p>我们按月来统计用户签到信息，签到记录为1，未签到则记录为0.</p>
<p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示</p>
<p>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653824498278.png" alt="1653824498278"></p>
<p>BitMap的操作命令有：</p>
<ul>
<li>SETBIT：向指定位置（offset）存入一个0或1</li>
<li>GETBIT ：获取指定位置（offset）的bit值</li>
<li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li>
<li>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li>
<li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li>
<li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li>
<li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li>
</ul>
<h4 id="1用户签到-实现签到功能"><a href="#1用户签到-实现签到功能" class="headerlink" title="1用户签到-实现签到功能"></a>1用户签到-实现签到功能</h4><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p>
<p>思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p>
<p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改bitMap。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653833970361.png" alt="1653833970361"></p>
<p><strong>代码</strong></p>
<p>UserController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> userService.sign();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.写入Redis SETBIT key offset 1</span></span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存储肯定是以字节为单位，因此后面会补0</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111230319873.png" alt="image-20241111230319873"></p>
<h4 id="用户签到-签到统计"><a href="#用户签到-签到统计" class="headerlink" title="用户签到-签到统计"></a>用户签到-签到统计</h4><p><strong>问题1：</strong>什么叫做连续签到天数？<br>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653834455899.png" alt="1653834455899"></p>
<p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p>
<p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p>
<p>  BITFIELD key GET u[dayOfMonth] 0</p>
<p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p>
<p><strong>问题3：如何从后向前遍历每个bit位？</strong></p>
<p>注意：bit<mark>Map返回的数据是10进制<mark>，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</p>
<p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p>
<p>有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653835784444.png" alt="1653835784444"></p>
<p>代码</p>
<p><strong>UserController</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sign/count&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.signCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span></span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">            key,</span><br><span class="line">            BitFieldSubCommands.create()</span><br><span class="line">                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 没有任何签到结果</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="literal">null</span> || num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.循环遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为0，说明未签到，结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不为0，说明已签到，计数器+1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="额外加餐-关于使用bitmap来解决缓存穿透的方案"><a href="#额外加餐-关于使用bitmap来解决缓存穿透的方案" class="headerlink" title="额外加餐-关于使用bitmap来解决缓存穿透的方案"></a>额外加餐-关于使用bitmap来解决缓存穿透的方案</h4><p>回顾<strong>缓存穿透</strong>：</p>
<p>发起了一个数据库不存在的，redis里边也不存在的数据，通常你可以把他看成一个攻击</p>
<p>解决方案：</p>
<ul>
<li><p>判断id&lt;0</p>
</li>
<li><p>如果数据库是空，那么就可以直接往redis里边把这个空数据缓存起来</p>
</li>
</ul>
<p>第一种解决方案：遇到的问题是如果用户访问的是id不存在的数据，则此时就无法生效</p>
<p>第二种解决方案：遇到的问题是：如果是不同的id那就可以防止下次过来直击数据</p>
<p>所以我们如何解决呢？</p>
<p>我们可以将数据库的数据，所对应的id写入到一个list集合中，当用户过来访问的时候，我们直接去判断list中是否包含当前的要查询的数据，如果说用户要查询的id数据并不在list集合中，则直接返回，如果list中包含对应查询的id数据，则说明不是一次缓存穿透数据，则直接放行。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653836416586.png" alt="1653836416586"></p>
<p>现在的问题是这个主键其实并没有那么短，而是很长的一个 主键</p>
<p>哪怕你单独去提取这个主键，但是在11年左右，淘宝的商品总量就已经超过10亿个</p>
<p>所以如果采用以上方案，这个list也会很大，所以我们可以使用bitmap来减少list的存储空间</p>
<p>我们可以把list数据抽象成一个非常大的bitmap，我们不再使用list，而是将db中的id数据利用哈希思想，比如：</p>
<p>id % bitmap.size  = 算出当前这个id对应应该落在bitmap的哪个索引上，然后将这个值从0变成1，然后当用户来查询数据时，此时已经没有了list，让用户用他查询的id去用相同的哈希算法， 算出来当前这个id应当落在bitmap的哪一位，然后判断这一位是0，还是1，如果是0则表明这一位上的数据一定不存在，  采用这种方式来处理，需要重点考虑一个事情，就是误差率，所谓的误差率就是指当发生哈希冲突的时候，产生的误差。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653836578970.png" alt="1653836578970"></p>
<h2 id="UV统计—HyperLogLog"><a href="#UV统计—HyperLogLog" class="headerlink" title="UV统计—HyperLogLog"></a>UV统计—HyperLogLog</h2><p>Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。</p>
<p><a href="https://juejin.cn/post/6844903785744056333#heading-0">HyperLogLog 算法的原理讲解以及 Redis 是如何应用它的聪明的你可能会马上想到，用 HashMap 这种数 - 掘金 (juejin.cn)</a></p>
<p><a href="https://www.zhihu.com/question/53416615">Redis源码中hyperloglog结构的实现原理是什么？ - 知乎 (zhihu.com)</a></p>
<p>首先我们搞懂两个概念：</p>
<ul>
<li>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li>
<li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li>
</ul>
<p>通常来说UV会比PV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值</p>
<p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</p>
<p>Redis中的HLL是基于string结构实现的，单个HLL的内存<strong>永远小于16kb</strong>，<strong>内存占用低</strong>的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653837988985.png" alt="1653837988985"></p>
<h3 id="UV统计-测试百万数据的统计"><a href="#UV统计-测试百万数据的统计" class="headerlink" title="UV统计-测试百万数据的统计"></a>UV统计-测试百万数据的统计</h3><p>测试思路：我们直接利用单元测试，向HyperLogLog中添加100万条数据，看看内存占用和统计效果如何</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653838053608.png" alt="1653838053608"></p>
<p>经过测试：我们会发生他的误差是在允许范围内，并且内存占用极小</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>分布式锁</tag>
        <tag>缓存</tag>
        <tag>乐观锁</tag>
        <tag>token</tag>
        <tag>mq</tag>
        <tag>推送</tag>
        <tag>bitmap</tag>
      </tags>
  </entry>
</search>
