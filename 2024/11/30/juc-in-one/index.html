<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Arvo:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scatteredream.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="Java Concurrency Overviewjava.lang.Thread 线程创建与运行:  继承 Thread 类: 继承 Thread 并重写 run() 方法 new MyThread().start()    实现 Runnable 接口: 实现 Runnable 实现 run() 方法 new Thread(runnable).start()      线程生命周期:   Ne">
<meta property="og:type" content="article">
<meta property="og:title" content="java.util.concurrent">
<meta property="og:url" content="http://scatteredream.github.io/2024/11/30/juc-in-one/index.html">
<meta property="og:site_name" content="scatteredream&#39;s blog">
<meta property="og:description" content="Java Concurrency Overviewjava.lang.Thread 线程创建与运行:  继承 Thread 类: 继承 Thread 并重写 run() 方法 new MyThread().start()    实现 Runnable 接口: 实现 Runnable 实现 run() 方法 new Thread(runnable).start()      线程生命周期:   Ne">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/640.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/format,webp.webp">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-concurrent-collections.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-thread-x-juc-overview-2.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Collection-Hierarchy-concurrent-1735225309564-38.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/cpu-cache-protocol.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2586739-20211214234820966-1713761498.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/jmm.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220731155332375-1735372822645-10-1735372984006-14.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220731084604667.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3230688-20231101142724469-1226844103.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/443934-20201207134826598-1740849743.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2-CFHd4NU8.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ThreadLocal-01.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241230193230746.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/5-GYIVKEun.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241230173434255-1735551283426-42.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241230173500715.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aqs.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/40cb932a64694262993907ebda6a0bfetplv-k3u1fbpfcp-zoom-1.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/785ca26c055b5be2761374af6a0c7bc5.webp?x-image-process=image/format,png#pic_center">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/721070-20170504110246211-10684485-1735391533653-31-1735395150328-37.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/721070-20151102145743461-623794326-1735395145015-35-1735395190296-39.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aqs-acquire-exclusive-1735447666698-3-1735447685230-5-1735447698634-7.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aqs-release.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aqs-addWaiter.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-thread-x-juc-overview-lock.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Monitor.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/979960-20180430090729190-1934051559.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/979960-20180430095049880-331436771.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/979960-20180430101906927-1765442903.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20230105200845649-1781815144.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20230105201438568-23123605.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20230105201125421-886160053.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241230173414548.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-concurrent-executors.png">
<meta property="og:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/thread-pool-principle.png">
<meta property="article:published_time" content="2024-11-29T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-27T06:37:58.214Z">
<meta property="article:author" content="碎梦">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/640.png">


<link rel="canonical" href="http://scatteredream.github.io/2024/11/30/juc-in-one/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://scatteredream.github.io/2024/11/30/juc-in-one/","path":"2024/11/30/juc-in-one/","title":"java.util.concurrent"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>java.util.concurrent | scatteredream's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">scatteredream's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-Concurrency-Overview"><span class="nav-number">1.</span> <span class="nav-text">Java Concurrency Overview</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#java-lang-Thread"><span class="nav-number">1.1.</span> <span class="nav-text">java.lang.Thread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-util-concurrent"><span class="nav-number">1.2.</span> <span class="nav-text">java.util.concurrent</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM-%E6%94%AF%E6%8C%81"><span class="nav-number">2.</span> <span class="nav-text">JVM 支持</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%BA%90"><span class="nav-number">2.1.</span> <span class="nav-text">并发问题的根源</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU-%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8"><span class="nav-number">2.1.1.</span> <span class="nav-text">CPU 时分复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU-Cache"><span class="nav-number">2.1.2.</span> <span class="nav-text">CPU Cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="nav-number">2.1.3.</span> <span class="nav-text">指令重排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E9%87%8D%E6%8E%92"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">编译器优化重排</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU-%E4%BC%98%E5%8C%96%E9%87%8D%E6%8E%92"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">CPU 优化重排</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C%E9%87%8D%E6%8E%92-%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C-ILP"><span class="nav-number">2.1.3.2.1.</span> <span class="nav-text">指令级并行重排&#x2F;乱序执行(ILP)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F%E9%87%8D%E6%8E%92"><span class="nav-number">2.1.3.2.2.</span> <span class="nav-text">内存系统重排</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">Java 内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%B8%BB%E5%86%85%E5%AD%98"><span class="nav-number">2.2.1.</span> <span class="nav-text">线程与主内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#happens-before-%E5%8E%9F%E5%88%99"><span class="nav-number">2.2.2.</span> <span class="nav-text">happens-before 原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.3.</span> <span class="nav-text">volatile 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%EF%BC%9Avolatile-synchronized"><span class="nav-number">2.3.1.</span> <span class="nav-text">双重校验实现单例：volatile + synchronized</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.4.</span> <span class="nav-text">synchronized 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">2.4.1.</span> <span class="nav-text">底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">同步代码块与同步方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7-Reentrancy"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">可重入性 (Reentrancy)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ObjectMonitor"><span class="nav-number">2.4.1.3.</span> <span class="nav-text">ObjectMonitor</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7"><span class="nav-number">2.4.2.</span> <span class="nav-text">锁的升级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E4%B8%8E-volatile-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.4.3.</span> <span class="nav-text">synchronized 与 volatile 的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.5.</span> <span class="nav-text">final 关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal-lt-T-gt"><span class="nav-number">2.6.</span> <span class="nav-text">ThreadLocal&lt;T&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6"><span class="nav-number">2.6.1.</span> <span class="nav-text">底层机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">2.6.2.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9A%E5%BC%B1%E5%BC%95%E7%94%A8%E4%B8%8E%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="nav-number">2.6.3.</span> <span class="nav-text">内存泄漏：弱引用与强引用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">3.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">3.1.</span> <span class="nav-text">ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="nav-number">3.1.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E-synchronized-%E6%AF%94%E8%BE%83"><span class="nav-number">3.1.2.</span> <span class="nav-text">与 synchronized 比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">3.2.</span> <span class="nav-text">读写锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS"><span class="nav-number">3.3.</span> <span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6"><span class="nav-number">3.3.1.</span> <span class="nav-text">核心机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#acquire-int"><span class="nav-number">3.3.1.2.1.</span> <span class="nav-text">acquire(int)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#release-int"><span class="nav-number">3.3.1.2.2.</span> <span class="nav-text">release(int)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS-%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8"><span class="nav-number">3.3.2.</span> <span class="nav-text">AQS 的常见应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">3.3.3.</span> <span class="nav-text">工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Semaphore"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">Semaphore</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">3.3.3.2.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%B3%95%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">3.3.3.2.2.</span> <span class="nav-text">用法及注意事项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">3.3.3.2.3.</span> <span class="nav-text">CyclicBarrier</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConditionObject"><span class="nav-number">3.3.4.</span> <span class="nav-text">ConditionObject</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition-%E7%9A%84%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">Condition 的等待队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#await"><span class="nav-number">3.3.4.2.</span> <span class="nav-text">await()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#enableWait-node"><span class="nav-number">3.3.4.2.1.</span> <span class="nav-text">enableWait(node)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#canReacquire-node"><span class="nav-number">3.3.4.2.2.</span> <span class="nav-text">canReacquire(node)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#unlinkCancelledWaiters-node"><span class="nav-number">3.3.4.2.3.</span> <span class="nav-text">unlinkCancelledWaiters(node)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#doSignal-firstNode-all"><span class="nav-number">3.3.4.3.</span> <span class="nav-text">doSignal(firstNode, all)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#signalAll"><span class="nav-number">3.3.4.3.1.</span> <span class="nav-text">signalAll()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%8E%92%E6%9F%A5%E2%80%94%E2%80%94JPS"><span class="nav-number">3.3.5.</span> <span class="nav-text">死锁排查——JPS</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F"><span class="nav-number">4.</span> <span class="nav-text">原子变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">4.1.</span> <span class="nav-text">乐观锁与悲观锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">4.1.1.</span> <span class="nav-text">悲观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">4.1.2.</span> <span class="nav-text">乐观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="nav-number">4.1.3.</span> <span class="nav-text">版本号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS"><span class="nav-number">4.1.4.</span> <span class="nav-text">CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-1"><span class="nav-number">4.1.4.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">4.1.4.2.</span> <span class="nav-text">问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ABA-%E9%97%AE%E9%A2%98"><span class="nav-number">4.1.4.2.1.</span> <span class="nav-text">ABA 问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E5%BC%80%E9%94%80%E5%A4%A7"><span class="nav-number">4.1.4.2.2.</span> <span class="nav-text">自旋开销大</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AA%E5%AF%B9%E5%8D%95%E4%B8%AA%E5%8F%98%E9%87%8F%E6%9C%89%E6%95%88"><span class="nav-number">4.1.4.2.3.</span> <span class="nav-text">只对单个变量有效</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Atomic"><span class="nav-number">4.2.</span> <span class="nav-text">Atomic</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">5.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Future-lt-V-gt"><span class="nav-number">5.1.</span> <span class="nav-text">Future&lt;V&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable"><span class="nav-number">5.1.1.</span> <span class="nav-text">Callable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FutureTask-lt-V-gt"><span class="nav-number">5.1.2.</span> <span class="nav-text">FutureTask&lt;V&gt;</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ExecutorService"><span class="nav-number">5.2.</span> <span class="nav-text">ExecutorService</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#execute-Runnable-command-Runnable-ONLY"><span class="nav-number">5.2.1.</span> <span class="nav-text">execute(Runnable command) (Runnable ONLY)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#submit-supports-Callable-Runnable"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">submit() (supports Callable, Runnable)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executors-%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%8F%90%E4%BE%9B%E7%9A%84%E9%BB%98%E8%AE%A4%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">5.2.2.</span> <span class="nav-text">Executors 工具类提供的默认线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">5.2.3.</span> <span class="nav-text">最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4"><span class="nav-number">5.2.3.1.</span> <span class="nav-text">任务提交</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">5.2.3.2.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0-ThreadPoolExecutor"><span class="nav-number">5.2.3.3.</span> <span class="nav-text">使用自定义线程池 ThreadPoolExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3"><span class="nav-number">5.2.3.3.1.</span> <span class="nav-text">参数详解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%91%BD%E5%90%8D"><span class="nav-number">5.2.3.3.2.</span> <span class="nav-text">命名</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%82%E5%BA%A6%E5%A4%8D%E7%94%A8"><span class="nav-number">5.2.3.4.</span> <span class="nav-text">适度复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E5%85%B3%E9%97%AD"><span class="nav-number">5.2.3.5.</span> <span class="nav-text">正确关闭</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E5%92%8C-JDK-%E8%87%AA%E5%B8%A6-ThreadLocal-%E5%85%B1%E7%94%A8"><span class="nav-number">5.2.3.6.</span> <span class="nav-text">不要和 JDK 自带 ThreadLocal 共用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E6%94%BE%E5%85%A5%E8%80%97%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="nav-number">5.2.3.7.</span> <span class="nav-text">不要放入耗时任务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CompletableFuture"><span class="nav-number">5.3.</span> <span class="nav-text">CompletableFuture</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA"><span class="nav-number">5.3.1.</span> <span class="nav-text">任务创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C"><span class="nav-number">5.3.2.</span> <span class="nav-text">链式操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E5%A4%9A%E4%B8%AA%E4%BB%BB%E5%8A%A1"><span class="nav-number">5.3.3.</span> <span class="nav-text">组合多个任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-1"><span class="nav-number">5.3.4.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="nav-number">5.3.5.</span> <span class="nav-text">线程池自定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%EF%BC%9A%E6%89%B9%E9%87%8F%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86"><span class="nav-number">5.3.6.</span> <span class="nav-text">例：批量任务处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.3.7.</span> <span class="nav-text">虚拟线程</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="碎梦"
      src="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
  <p class="site-author-name" itemprop="name">碎梦</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">73</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">120</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/11/30/juc-in-one/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="java.util.concurrent | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java.util.concurrent
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-30 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-30T00:00:00+08:00">2024-11-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 14:37:58" itemprop="dateModified" datetime="2025-04-27T14:37:58+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/juc/" itemprop="url" rel="index"><span itemprop="name">juc</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="Java-Concurrency-Overview"><a href="#Java-Concurrency-Overview" class="headerlink" title="Java Concurrency Overview"></a>Java Concurrency Overview</h1><h2 id="java-lang-Thread"><a href="#java-lang-Thread" class="headerlink" title="java.lang.Thread"></a><code>java.lang.Thread</code></h2><ol>
<li><p><strong>线程创建与运行</strong>:</p>
<ul>
<li><strong>继承 <code>Thread</code> 类</strong>: 继承 <code>Thread</code> 并重写 <code>run()</code> 方法<ul>
<li><code>new MyThread().start()</code> </li>
</ul>
</li>
<li><strong>实现 <code>Runnable</code> 接口</strong>: 实现 <code>Runnable</code> 实现 <code>run()</code> 方法<ul>
<li><code>new Thread(runnable).start()</code> </li>
</ul>
</li>
</ul>
</li>
<li><p><strong>线程生命周期</strong>:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/640.png" alt="Java 线程状态变迁图"></p>
<ul>
<li><strong>New</strong>: <code>new Thread()</code>, 还没有调用 <code>start()</code> </li>
<li><strong>Runnable</strong>: 线程已经调用了 <code>start()</code> / 获取锁等待 CPU 调度执行，操作系统层面属于 <strong>Ready</strong> 和 <strong>Running</strong> 状态</li>
<li><strong>Blocked</strong>:  等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</li>
<li><strong>Waiting</strong>: 操作系统的 <strong>Sleep</strong> 状态，等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。需要等待其他线程做出一些特定动作（通知或中断）</li>
<li><strong>Timed Waiting</strong>: 无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。获取锁之后调用 <code>wait(long ms)</code> <code>sleep(long ms)</code> 可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li>
<li><strong>Terminated</strong>: <code>run()</code> 执行完毕正常退出或者抛出了未处理的异常</li>
</ul>
</li>
<li><p><strong>Thread Methods</strong>:</p>
<ul>
<li><strong><code>start()</code></strong>: 线程转为 Runnable 可运行状态，相当于 <code>pthread_create()</code></li>
<li><strong><code>run()</code></strong>: 线程应该执行的方法，相当于 <code>pthread_create()</code> 传的函数指针</li>
<li><strong><code>sleep(long millis)</code></strong>: 调用者睡眠一段时间</li>
<li><strong><code>join()</code></strong>: 父线程等待子线程执行完毕再继续执行</li>
<li><strong><code>interrupt()</code></strong>: 使线程中断</li>
<li><code>currentThread()</code>: 获取当前执行的线程对象</li>
<li><code>get/setName()</code>: 获取线程名称</li>
<li><code>yield()</code>: 声明当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。只是对线程调度器的一个建议，只是建议具有相同优先级的其它线程可以运行。只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。</li>
<li><code>setDaemon()</code>: 将一个线程设置为守护线程。当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。main() 属于非守护线程。</li>
</ul>
</li>
<li><p>线程安全：</p>
<ol>
<li><p>线程互斥同步：<code>synchronized</code> <code>ReentrantLock</code> </p>
</li>
<li><p>线程非阻塞同步：<code>AtomicInteger</code> (CAS)</p>
</li>
<li><p>无同步：<code>ThreadLocal</code> 利用线程各自的栈(FutureTask，线程池)</p>
</li>
</ol>
</li>
<li><p>线程通信与协作：</p>
<ul>
<li><code>thread.join()</code> 父线程与子线程的通信</li>
<li><code>object.wait()/notify()/notifyAll()</code> 可用于 synchronized 对象锁</li>
<li><code>condition.await()/signal()/signalAll()</code> 可用于 Lock 的条件变量</li>
<li>或者使用共享内存，volatile/while轮询 的形式隐式通信</li>
</ul>
</li>
</ol>
<h2 id="java-util-concurrent"><a href="#java-util-concurrent" class="headerlink" title="java.util.concurrent"></a><code>java.util.concurrent</code></h2><p>**<mark><a href="#jvm">理论基础</a><mark>**：</p>
<ol>
<li><p><strong>JVM</strong> 对并发的支持：</p>
<ul>
<li><strong>JMM 内存模型</strong> 解决由于 Cache、指令重排序导致的可见性、有序性问题</li>
<li><code>synchronized</code> 用于解决 CPU 时分复用(操作系统调度)导致的原子性问题<ul>
<li>偏向锁、轻量级锁与重量级锁，理解锁升级和锁优化机制，如自旋锁与锁消除。</li>
</ul>
</li>
<li><code>volatile</code> 用于解决指令重排序与可见性问题</li>
<li><code>final</code> 创建不可变对象或常量(线程安全)，内存可见性</li>
<li>happens-before 原则</li>
</ul>
</li>
<li><p>常见<strong>并发设计模式</strong>：</p>
<ul>
<li><p><strong>生产者-消费者模式：</strong> 使用阻塞队列（BlockingQueue）优化实现。</p>
</li>
<li><p><strong>读写分离模式：</strong> 提高读写性能，适合数据库访问优化，读写锁、CoW 集合。</p>
</li>
<li><p><strong>线程池模式：</strong> 使用线程池 ThreadPool 统一管理线程资源。</p>
</li>
<li><p><strong>Future 模式：</strong> 提供任务执行结果的异步返回。</p>
</li>
</ul>
</li>
<li><p><strong>死锁检测与避免策略</strong></p>
</li>
</ol>
<p><strong>可选：</strong>虚拟线程、Reactor、Disruptor</p>
<p><code>java.util.concurrent</code> 给并发控制提供更多可用的操作:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/format,webp.webp" alt="img"></p>
<ol>
<li><p><strong><mark><a href="#lock">Locks</a><mark></strong>:（悲观锁）</p>
<ul>
<li><strong>ReentrantLock</strong>: 相同线程可以重复持有同一把锁</li>
<li><strong>ReentrantReadWriteLock</strong>: 有读锁和写锁两部分组成，支持多线程读取和单个线程写入</li>
<li><strong>StampedLock</strong>: 不可重入的读写锁</li>
<li><strong>LockSupport</strong>: 提供线程阻塞同步原语<ul>
<li><code>park()</code> <code>unpark(thread)</code> </li>
</ul>
</li>
<li><strong>Condition</strong>: 更细粒度的线程同步</li>
<li><strong>AbstractQueuedSynchronizer</strong>: AQS 自定义同步器</li>
</ul>
</li>
<li><p><strong><mark><a href="#tools">Tools</a><mark></strong>(Synchronizers): 和锁配合使用，线程安全工具类</p>
<ul>
<li><strong>CountDownLatch</strong>: Allows one or more threads to wait until a set of operations being performed in other threads completes. 闭锁是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待</li>
<li><strong>CyclicBarrier</strong>: A barrier that all threads must reach before any thread can proceed.（栅栏） 是因为是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 ，并且在释放等待线程后可以重用。</li>
<li><strong>Semaphore</strong>: Controls access to a resource by multiple threads. 它的本质是一个“共享锁“。信号量维护了一个信号量许可集。线程可以通过调用 acquire()来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过release()来释放它所持有的信号量许可。</li>
</ul>
</li>
<li><p><strong><mark><a href="#atomic">Atomic Variables</a><mark></strong>: CAS Lock-free(乐观锁)</p>
<ul>
<li><strong>AtomicBoolean</strong>, <strong>AtomicInteger</strong>, <strong>AtomicLong</strong></li>
<li><strong>AtomicIntegerArray</strong> These classes support lock-free thread-safe programming on single variables using low-level atomic operations.</li>
<li>CAS 构建自旋锁</li>
<li>ABA 问题与解决方案（如 AtomicStampedReference）。</li>
</ul>
</li>
<li><p><strong><mark><a href="#executor">Executor</a><mark></strong>: 线程池及异步任务相关</p>
<ul>
<li><p><strong>Callable</strong>: 和 Runnable 类似，但是有返回值</p>
</li>
<li><p><strong>Future</strong> <strong>FutureTask</strong> </p>
<ul>
<li>CompletableFuture 异步编程</li>
</ul>
</li>
<li><p><strong>ExecutorService</strong>: A flexible interface for managing and controlling thread execution.</p>
<ul>
<li><strong>ThreadPoolExecutor</strong>: 通常所说的线程池</li>
</ul>
</li>
<li><p><strong>Fork/Join</strong> 框架</p>
</li>
</ul>
</li>
<li><p><strong>Concurrent Collections/Maps</strong>: 线程安全的集合</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-concurrent-collections.png" alt="Concurrent Collections"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-thread-x-juc-overview-2.png" alt="image"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Collection-Hierarchy-concurrent-1735225309564-38.png" alt="Collection Hierarchy concurrent"></p>
<ul>
<li><strong>ConcurrentHashMap</strong> 线程安全的哈希表</li>
<li><strong>CopyOnWriteArrayList</strong> CoW List</li>
<li><strong>CopyOnWriteArraySet</strong> CoW Set</li>
<li><strong>BlockingQueue</strong> 阻塞队列</li>
</ul>
</li>
</ol>
<h1 id="JVM-支持"><a href="#JVM-支持" class="headerlink" title="JVM 支持"></a><span id="jvm">JVM 支持</span></h1><h2 id="并发问题的根源"><a href="#并发问题的根源" class="headerlink" title="并发问题的根源"></a>并发问题的根源</h2><h3 id="CPU-时分复用"><a href="#CPU-时分复用" class="headerlink" title="CPU 时分复用"></a>CPU 时分复用</h3><p>**<mark>原子性<mark>**：一个过程要么完全执行并且执行的过程不会被任何因素打断，要么就完全不执行。</p>
<p>操作系统基于受限直接执行(Limited Direct Execution)来运行任务，基于 CPU 的时钟中断对任务进行调度，通过这种 CPU 虚拟化技术让应用程序认为是自己在独占 CPU。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">i += <span class="number">1</span>;<span class="comment">// 线程1执行</span></span><br><span class="line">i += <span class="number">1</span>;<span class="comment">// 线程2执行</span></span><br><span class="line"><span class="comment">/*注意：i += 1 需要三条 CPU 指令</span></span><br><span class="line"><span class="comment">1. 将变量 i 从内存读取到 CPU寄存器；</span></span><br><span class="line"><span class="comment">2. 在CPU寄存器中执行 i + 1 操作；</span></span><br><span class="line"><span class="comment">3. 将最后的结果 i 写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。*/</span></span><br></pre></td></tr></table></figure>

<p>由于CPU分时复用（线程切换）的存在，线程 1 执行了第一条指令后，就切换到线程 2 执行，假如线程 2 执行了这三条指令后，再切换会线程 1 执行后续两条指令，将造成最后写到内存中的 <code>i</code> 是 2 而不是 3</p>
<blockquote>
<p>在 Java 中，可以借助<code>synchronized</code>、各种 <code>Lock</code> 以及各种原子类实现原子性。</p>
<p><code>synchronized</code> 和各种 <code>Lock</code> 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 <code>volatile</code>或者<code>final</code>关键字）来保证原子操作。</p>
</blockquote>
<h3 id="CPU-Cache"><a href="#CPU-Cache" class="headerlink" title="CPU Cache"></a>CPU Cache</h3><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/cpu-cache-protocol.png" alt="缓存一致性协议" style="zoom:67%;" />

<p><mark><strong>可见性</strong><mark>：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。</p>
<ol>
<li>CPU Cache 缓存的是物理内存数据，用于解决 CPU 处理速度和物理内存不匹配的问题<ul>
<li>多核缓存与主内存交互时需要遵守的原则和规范叫做 <strong>缓存一致协议</strong>，如 MESI</li>
</ul>
</li>
<li>应用程序眼中是一片完整的虚拟内存，由操作系统提供内存的虚拟化，将虚拟内存地址映射到真正的物理内存空间中。<ul>
<li>操作系统也要解决缓存(比如 TLB)与内存(比如页表)的一致性问题</li>
</ul>
</li>
</ol>
<blockquote>
<p>在 Java 中，可以借助<code>synchronized</code>、<code>volatile</code> 以及各种 <code>Lock</code> 实现可见性。</p>
<p>如果我们将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
</blockquote>
<h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>**<mark>有序性<mark>**：即程序执行的顺序按照代码的先后顺序执行。</p>
<p>为了提升执行速度/性能，计算机在执行程序代码的时候，会对指令进行重排序。 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。<strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p>
<blockquote>
<p>在 Java 中，<code>volatile</code> 关键字可以禁止指令进行重排序优化。</p>
</blockquote>
<h4 id="编译器优化重排"><a href="#编译器优化重排" class="headerlink" title="编译器优化重排"></a>编译器优化重排</h4><p>编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</p>
<p>对于编译器，禁止重排两句代码的指令，需要在它们之间插入 compiler fence。</p>
<h4 id="CPU-优化重排"><a href="#CPU-优化重排" class="headerlink" title="CPU 优化重排"></a>CPU 优化重排</h4><p>对于处理器，通过插入内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence，一种 CPU 指令）的方式来禁止特定类型的处理器重排序。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障变量的可见性。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/413889872">并发编程：乱序执行的那些事儿 - 知乎</a>  <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maycap/p/15690751.html">图解CPU为何要乱序执行 - last_coding - 博客园</a>  </p>
<h5 id="指令级并行重排-乱序执行-ILP"><a href="#指令级并行重排-乱序执行-ILP" class="headerlink" title="指令级并行重排/乱序执行(ILP)"></a>指令级并行重排/乱序执行(ILP)</h5><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2586739-20211214234820966-1713761498.png" alt="img" style="zoom: 80%;" />

<p>RISC 架构的特点就是指令长度相等，执行时间恒定(通常为一个时钟周期)，因此处理器设计起来就很简单，可以通过深长的流水线达到很高的频率，IBM 的 Power6 就可以轻松地达到 4.7GHz 的起步频率。和 RISC 相反，CISC 指令的长度不固定，执行时间也不固定，因此 Intel 的 RISC/CISC 混合处理器架构就要通过 Instruction Fetch &amp; Decode 将 x86 指令翻译为 μops，从而获得 RISC 架构的长处，提升内部执行效率。x86 指令大部分简单指令可以一对一翻译为 μops，复杂的可能 1 ~ 4 条 μops。解码器是按位数取指的，在经过译码，因此每次可能产生多条 μops。</p>
<p>计算机执行符合局部性原理，这里不仅指同个指令可能重复执行，也指内存访问。而内存访问显然是比较慢的，<strong>对多条指令重新排序，把访存相关的指令放到一起，显然是可以提升效率的。</strong></p>
<h5 id="内存系统重排"><a href="#内存系统重排" class="headerlink" title="内存系统重排"></a>内存系统重排</h5><p>另外，内存系统也会有“重排序”，但又不是真正意义上的重排序。在 JMM 里表现为主内存和线程的本地内存可能不一致，进而导致程序在多线程下执行可能出现问题。</p>
<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a><mark>Java 内存模型<mark></h2><p>并发编程环境下，像 CPU 多级缓存和指令重排这类设计可能会导致程序运行出现一些问题。就比如说我们上面提到的指令重排序就可能会让多线程程序的执行出现问题。</p>
<p>JMM 说白了就是定义了一些规范来解决这些问题，例如 JMM 抽象了 happens-before 原则（后文会详细介绍到）来解决指令重排序问题。开发者可以利用 JMM 规范更方便地开发多线程程序。Java 开发者不需要了解底层原理，直接使用并发相关的一些关键字和类（比如 <code>volatile</code>、<code>synchronized</code>、各种 <code>Lock</code>）即可开发出并发安全的程序。</p>
<p>与 Java 内存区域要区分开：</p>
<ul>
<li>JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说<strong>堆主要用于存放对象实例</strong>，栈用来存放局部变量。</li>
<li>Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</li>
</ul>
<h3 id="线程与主内存"><a href="#线程与主内存" class="headerlink" title="线程与主内存"></a>线程与主内存</h3><p>在当前的 Java 内存模型下，线程可以把变量保存 <strong>本地内存</strong> （比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/jmm.png" alt="JMM(Java 内存模型)" style="zoom:60%;" />

<ul>
<li><strong>主内存</strong>：所有线程创建的实例对象都存放在主内存中，不管该实例对象是<strong>成员变量</strong>，还是<strong>局部变量</strong>，类信息、<strong>常量</strong>、<strong>静态变量</strong>都是放在主内存中。为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。</li>
<li><strong>本地内存</strong>：每个线程都有一个私有的本地内存，本地内存存储了该线程以读 / 写共享变量的副本。每个线程只能操作自己本地内存中的变量，<strong>无法直接访问其他线程的本地内存</strong>。线程间通信必须通过主内存来进行。本地内存是 JMM 抽象出来的一个概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。图中的线程1想和线程2通信，线程1必须把自己的共享变量副本同步到住内存里，然后线程2需要从主内存读取，读取的共享变量是否是线程1修改过的，是不知道的，由此引发了线程安全问题。</li>
<li>Java 内存模型定义了八种同步操作，规定了关于主内存与工作内存直接的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现细节。规定了一些同步规则来保证这些同步操作的正确执行 <a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/jmm.html#jmm-%E6%98%AF%E5%A6%82%E4%BD%95%E6%8A%BD%E8%B1%A1%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%B8%BB%E5%86%85%E5%AD%98%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">详见 JavaGuide</a> </li>
</ul>
<h3 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a>happens-before 原则</h3><p>JSR 133 引入了 happens-before 这个概念来描述<strong>两个操作之间的内存可见性</strong>。</p>
<p>happens-before 原则的诞生是为了程序员和编译器、处理器之间的平衡。程序员追求的是易于理解和编程的强内存模型，遵守既定规则编码即可。编译器和处理器追求的是较少约束的弱内存模型，让它们尽己所能地去优化性能，让性能最大化。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220731155332375-1735372822645-10-1735372984006-14.png" alt="img" style="zoom:70%;" />

<ul>
<li>为了对编译器和处理器的约束尽可能少，只要<strong>不改变程序的执行结果</strong>（单线程程序和正确执行的多线程程序），编译器和处理器怎么进行重排序优化都行。两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。</li>
<li>对于会改变程序执行结果的重排序，JMM 要求<u>编译器</u>和<u>处理器</u>必须<mark>禁止<mark>这种重排序。</li>
</ul>
<p>happens-before 原则表达的意义其实并不是一个操作发生在另外一个操作的前面，虽然这从程序员的角度上来说也并无大碍。更准确地来说，它更想表达的意义是**前一个操作的结果对于后一个操作<mark>是可见的<mark>**，无论这两个操作是否在同一个线程里。</p>
<p>具体规则：1. 按照代码先后顺序 2. 线程的 <code>start()</code> 先于其他所有动作 3. 传递性</p>
<ol start="4">
<li><p>Monitor 的解锁 happens- before 于随后对此 Monitor 的加锁 <code>synchronized</code></p>
</li>
<li><p>对 <code>volatile</code> 域的<mark>写<mark>，happens- before 于任意的后续对此 <code>volatile</code> 域的<mark>读<mark> </p>
<ul>
<li><code>volatile</code> 仅保证变量读写操作的可见性和有序性，不保证复合操作（ <code>i++</code>）的原子性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 线程1</span></span><br><span class="line">a = <span class="number">1</span>;        <span class="comment">// 普通写</span></span><br><span class="line">flag = <span class="literal">true</span>;  <span class="comment">// volatile 写</span></span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;   <span class="comment">// volatile 读</span></span><br><span class="line">    System.out.println(a); <span class="comment">// 一定会输出 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>保证 <code>flag = true</code> 的写入之前，<code>a = 1</code> 已经执行完毕，并且对线程 2 可见。</li>
<li>在 JDK 5 之前，由于没有禁止 volatile 指令重排序，<code>a = 1</code> 可能会被移动到 <code>flag = true</code> 之后执行，导致线程 2 看到 <code>flag</code> 为 true，但 <code>a</code> 的值仍然是 0。这种情况显然是违背直觉的，也无法确保程序正确性。</li>
<li>在 JDK 5 及之后，<code>a = 1</code> 一定会在 <code>flag = true</code> 之前执行， <code>flag = true</code> 一定在 <code>if(flag)</code> 之前执行，从而保证了有序性和内存可见性。</li>
</ul>
</li>
</ol>
<p><strong>JMM 与 happens-before</strong></p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220731084604667.png" alt="happens-before 与 JMM 的关系" style="zoom:67%;" />

<p>程序员在 happens-before 提供的内存可见性基础上编程，JMM 的实现：根据编译器和处理器的重排序规则，如果出现了重排序，除非没有影响执行结果，否则就禁止重排序：为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。实现细节对于程序员是透明的，只要保证程序执行时语义不改变即可。</p>
<h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a><mark><code>volatile</code> 关键字<mark></h2><ol>
<li><p><code>volatile</code> 关键字并非 Java 语言特有，在 C 语言里也有，其最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 <code>volatile</code> 修饰，这就告诉编译器这个变量是共享且不稳定的，每次使用它都到主存中进行读取。（可见性）</p>
</li>
<li><p>在 Java 中，<code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是<strong>防止 JVM 的指令重排序</strong>。 如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。（有序性）（Unsafe 类的内存屏障方法也可以实现 volatile 相同的效果）</p>
</li>
<li><p><code>volatile</code> 无法保证原子性。</p>
</li>
</ol>
<h3 id="双重校验实现单例：volatile-synchronized"><a href="#双重校验实现单例：volatile-synchronized" class="headerlink" title="双重校验实现单例：volatile + synchronized"></a>双重校验实现单例：<code>volatile</code> + <code>synchronized</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton unique;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getunique</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (unique &lt;mark&gt; <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁(对象锁)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (unique &lt;mark&gt; <span class="literal">null</span>) &#123;</span><br><span class="line">                    unique = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unique;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 <code>unique</code> 的写操作: <code>unique = new Singleton();</code> 可以分成如下三步</p>
<ol>
<li>为 <code>unique</code> 分配内存空间 malloc</li>
<li>初始化 <code>unique</code> initialize</li>
<li>将 <code>unique</code> 指向分配的引用地址(赋值)</li>
</ol>
<p>对 <code>unique</code> 的读操作: <code>if (unique == null)</code> </p>
<p><code>volatile</code> 使 <strong>写操作的第 3 步</strong> 一定对读操作可见；</p>
<p>但是指令重排仍然会导致一些问题，在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getunique</code>() 后发现 <code>unique</code> 不为空，因此返回 <code>unique</code>，但此时 <code>unique</code> 还未被初始化。<code>volatile</code> 能够禁止这种重排。</p>
<h2 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a><mark><code>synchronized</code> 关键字<mark></h2><p><code>synchronized</code> 是 Java 中的一个关键字，也叫做对象锁，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。它是 Java 内置的同步机制，在 JVM 中实现，隐式获取、自动释放。</p>
<p>在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。这是因为监视器锁（Monitor）是依赖于底层的操作系统的互斥锁 <code>mutex</code> 和条件变量 <code>cond</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>
<p>在 Java 6 之后， <code>synchronized</code> 引入了大量的优化如<strong>自旋锁</strong>、适应性自旋锁、<strong>锁消除</strong>、<strong>锁粗化</strong>、<del>-偏向锁-</del>、<strong>轻量级锁</strong>等技术来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多。因此， <code>synchronized</code> 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 <code>synchronized</code> 。</p>
<blockquote>
<p>由于偏向锁增加了 JVM 的复杂性，同时也并没有为所有应用都带来性能提升。因此，在 JDK 15 中，偏向锁被默认关闭（仍然可以使用 <code>-XX:+UseBiasedLocking</code> 启用偏向锁），在 JDK 18 中，偏向锁已经被彻底废弃（无法通过命令行打开）。</p>
</blockquote>
<ul>
<li>加在实例方法上，相当于<code>synchronized(this)</code>；</li>
<li>加在静态方法上，相当于<code>synchronized(Example.class)</code>；</li>
<li>尽量使用<code>this</code>作为对象锁，不要图方便使用字符串常量等</li>
</ul>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><h4 id="同步代码块与同步方法"><a href="#同步代码块与同步方法" class="headerlink" title="同步代码块与同步方法"></a>同步代码块与同步方法</h4><p><strong><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong></p>
<p>含有同步代码块的字节码中包含一个 <code>monitorenter</code> 指令以及两个 <code>monitorexit</code> 指令，这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放。</p>
<p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<blockquote>
<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的。每个对象中都内置了一个 <code>ObjectMonitor</code> 对象。</p>
<p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p>
</blockquote>
<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p>
<p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p>
<p><strong>同步方法</strong>：<code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取而代之的是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p>
<h4 id="可重入性-Reentrancy"><a href="#可重入性-Reentrancy" class="headerlink" title="可重入性 (Reentrancy)"></a>可重入性 (Reentrancy)</h4><p><code>synchronized</code> 的可重入性依赖于 <strong>Monitor 对象</strong> 的 <strong>锁计数器</strong> 和 <strong>锁持有线程ID</strong>。</p>
<p>同一个线程每进入一次同步方法或者对象锁相同的同步代码块，就会将锁计数器+1，退出时-1，减到0则释放锁</p>
<h4 id="ObjectMonitor"><a href="#ObjectMonitor" class="headerlink" title="ObjectMonitor"></a>ObjectMonitor</h4><p>synchronized 是基于管程实现的，核心的数据结构是 ObjectMonitor，AQS也基于MESA管程</p>
<p><strong>ObjectMonitor 的核心作用</strong></p>
<ul>
<li>保证同一时刻只有一个线程能执行同步代码块（<strong>互斥</strong>）。</li>
<li>提供线程之间的等待和唤醒机制（<strong>条件变量</strong>）。</li>
</ul>
<p>每个 Java 对象都与一个 对象监视器锁 关联，用于控制对该对象的访问权限。采用 Mesa 语义</p>
<p><strong>底层机制</strong> </p>
<ul>
<li><strong>互斥锁（Mutex）</strong>：<ul>
<li>Monitor 使用操作系统的互斥锁来实现互斥访问。</li>
<li>重量级锁通过内核态的同步原语（如 <code>futex</code> 或 <code>pthread_mutex</code>）挂起和唤醒线程。</li>
</ul>
</li>
<li><strong>条件变量（Condition Variable）</strong>：<ul>
<li>等待队列和条件变量用于管理线程状态。<code>pthread_cond</code></li>
<li>条件变量依赖于操作系统的 <code>wait()</code> 和 <code>signal()</code> 机制，控制线程等待和唤醒。</li>
</ul>
</li>
<li><strong>线程阻塞与唤醒</strong>：<ul>
<li>当线程无法获取锁时，Monitor 会将其挂起，并调用操作系统的线程调度机制。</li>
<li>被唤醒的线程通过抢占式调度重新竞争锁资源。</li>
</ul>
</li>
</ul>
<h3 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h3><p>锁主要有四种状态：无锁、偏向锁、轻量级锁、重量级锁，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3230688-20231101142724469-1226844103.png" alt="img" style="zoom: 80%;" />

<p><strong>对象头中的 Mark Word</strong></p>
<p>Java 对象在内存中由以下部分组成：</p>
<table>
<thead>
<tr>
<th>内存布局</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>对象头（Header）</td>
<td>4 字节 Mark Word、4 字节 <code>.class</code> Pointer</td>
</tr>
<tr>
<td>实例数据</td>
<td>实例变量存储的数据</td>
</tr>
<tr>
<td>对齐填充</td>
<td>用于内存对齐，按照8字节填充</td>
</tr>
</tbody></table>
<p>Mark Word 是对象头中的一部分，存储对象的状态和锁信息。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/443934-20201207134826598-1740849743.png" alt="img"></p>
<p><strong>注：锁状态会根据竞争情况自动升级，从偏向锁到轻量级锁，再到重量级锁。</strong> </p>
<h3 id="synchronized-与-volatile-的区别"><a href="#synchronized-与-volatile-的区别" class="headerlink" title="synchronized 与 volatile 的区别"></a><code>synchronized</code> 与 <code>volatile</code> 的区别</h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li>
<li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li>
<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a><code>final</code> 关键字</h2><p><a target="_blank" rel="noopener" href="https://www.nenggz.com/md/java/thread/java-thread-x-key-final.html">关键字: final详解 | Java 全栈知识体系</a> </p>
<p>用 final 修饰的类不可以被继承，用 final 修饰的方法不可以被覆写，用 final 修饰的属性一旦初始化以后不可以被修改。当然，我们不关心这些段子，这节，我们来看看 final 带来的内存可见性影响。</p>
<p>之前在说双重检查的单例模式的时候，提过了一句，如果所有的属性都使用了 final 修饰，那么 volatile 也是可以不要的，这就是 final 带来的可见性影响。</p>
<p>在对象的构造方法中设置 final 属性，<strong>同时在对象初始化完成前，不要将此对象的引用写入到其他线程可以访问到的地方</strong>（不要让引用在构造函数中逸出）。如果这个条件满足，当其他线程看到这个对象的时候，那个线程始终可以看到正确初始化后的对象的 final 属性。</p>
<p>上面说得很明白了，final 属性的写操作不会和此引用的赋值操作发生重排序，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.finalField = v; ...; sharedRef = x;</span><br></pre></td></tr></table></figure>

<h2 id="ThreadLocal-lt-T-gt"><a href="#ThreadLocal-lt-T-gt" class="headerlink" title="ThreadLocal&lt;T&gt;"></a><mark><code>ThreadLocal&lt;T&gt;</code><mark></h2><p><code>ThreadLocal</code> 主要用于以下场景：</p>
<ol>
<li><strong>线程安全的变量管理：</strong> 比如事务管理、用户会话等。</li>
<li><strong>避免同步锁：</strong> 替代传统的锁机制，提高并发性能。</li>
<li><strong>数据库连接或会话缓存：</strong> 每个线程维护自己的数据库连接实例。</li>
</ol>
<p>T 用于表示 ThreadLocal 存的值类型</p>
<p>ThreadLocal在Spring中发挥着巨大的作用，在管理request作用域中的bean、事务管理、任务调度、aop等模块都出现了它的身影。<br>Spring中绝大部分Bean都可以声明成Singleton作用域，采用ThreadLocal进行封装，因此有状态的bean就能够以 Singleton的方式在多线程中正常工作了。</p>
<h3 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h3><p><strong>JVM 提供线程隔离：</strong></p>
<ul>
<li>每个线程都有自己的栈空间和线程私有变量。</li>
<li>JVM 将 <code>Thread</code> 对象与其局部变量绑定，保证变量不被其他线程访问。</li>
</ul>
<p><strong>JDK 提供 <code>ThreadLocal</code>：</strong> </p>
<ul>
<li><code>ThreadLocal</code> 依赖于每个线程 (<code>Thread</code> 对象) 内部的 <code>ThreadLocalMap</code> 实现数据存储，每个线程都持有一个独立的 <code>ThreadLocalMap</code> 实例</li>
<li><code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</li>
<li><code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</li>
<li>每次访问 <code>ThreadLocal</code> 时，都会从当前线程的 <code>ThreadLocalMap</code> 查找对应的value。</li>
<li>不同线程之间的 <code>ThreadLocalMap</code> 互不影响，因此保证了变量的线程隔离性。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2-CFHd4NU8.png" alt="img"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ThreadLocal-01.png" alt="ThreadLocal各引用间的关系"></p>
<p>哈希冲突解决：开放地址法（线性探测）</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>注意泛型、remove避免内存泄露 public static final</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义 ThreadLocal 变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// tl = ThreadLocal.withInitial(() -&gt; 0) 可以设置初始值</span></span><br><span class="line">tl.set(<span class="number">100</span>); <span class="comment">// 当前线程设置值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get(); <span class="comment">// 获取当前线程的值</span></span><br><span class="line">tl.remove(); <span class="comment">// 避免内存泄漏</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241230193230746.png" alt="image-20241230193230746"></p>
<p>如图 在 web 请求到达时，进入controller之前的interceptor可以</p>
<h3 id="内存泄漏：弱引用与强引用"><a href="#内存泄漏：弱引用与强引用" class="headerlink" title="内存泄漏：弱引用与强引用"></a>内存泄漏：弱引用与强引用</h3><p>key 是 ThreadLocal 对象，弱引用；value 是 Object 对象，强引用。</p>
<p>那么在<code>ThreadLocal.get()</code>的时候，发生<code>GC</code>之后，<code>key</code>是否是<code>null</code>？</p>
<p>为了搞清楚这个问题，我们需要搞清楚<code>Java</code>的<strong>四种引用类型</strong>：</p>
<ul>
<li><strong>强引用</strong>：我们常常 new 出来的对象就是强引用类型，只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足的时候</li>
<li><strong>软引用</strong>：使用 SoftReference 修饰的对象被称为软引用，软引用指向的对象在内存要溢出的时候被回收</li>
<li><strong>弱引用</strong>：使用 WeakReference 修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收</li>
<li><strong>虚引用</strong>：虚引用是最弱的引用，在 Java 中使用 PhantomReference 进行定义。虚引用中唯一的作用就是用队列接收对象即将死亡的通知</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/5-GYIVKEun.png" alt="img"></p>
<p>当作为 key 的 <code>ThreadLocal</code> 实例失去强引用后，只要发生 GC 就会被回收，但是其对应的 value <code>Object</code> 仍然存在于 <code>ThreadLocalMap</code> 中，因为 <code>Entry</code> 对象强引用了它。如果线程持续存活（例如线程池中的线程），<code>ThreadLocalMap</code> 也会一直存在，导致 key 为 <code>null</code> 的 entry 无法被垃圾回收，机会造成内存泄漏。</p>
<ol>
<li>在使用完 <code>ThreadLocal</code> 后，<mark>务必调用 <code>remove()</code> 方法<mark>。 这是最安全和最推荐的做法。 <code>remove()</code> 方法会从 <code>ThreadLocalMap</code> 中显式地移除对应的 entry，彻底解决内存泄漏的风险。 即使将 <code>ThreadLocal</code> 定义为 <code>static final</code>，也强烈建议在每次使用后调用 <code>remove()</code>。</li>
<li>在线程池等线程复用的场景下，<mark>使用 <code>try-finally</code> 块<mark>可以确保即使发生异常，<code>remove()</code> 方法也一定会被执行。</li>
</ol>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a><span id="lock">锁</span></h1><p><code>java.util.concurrent.locks</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241230173434255-1735551283426-42.png" alt="image-20241230173434255"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241230173500715.png" alt="image-20241230173500715"></p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><mark><code>ReentrantLock</code><mark></h2><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个<mark>可重入<mark>且<mark>独占式<mark>的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了<strong>非阻塞</strong>、<strong>超时</strong>、<strong>中断</strong>、<strong>公平锁和非公平锁</strong>等高级功能。</p>
<p>继承关系：实现了 Lock 接口，有一个 Sync 内部类，Sync 继承了 AQS，加锁和释放锁基本在 Sync 中实现，Sync 有公平锁 FairSync 和非公平锁 NonfairSync 两个子类。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aqs.png" alt="Classes"></p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本如上，finally 逻辑一定要释放锁，防止死锁</p>
<h3 id="与-synchronized-比较"><a href="#与-synchronized-比较" class="headerlink" title="与 synchronized 比较"></a>与 <code>synchronized</code> 比较</h3><table>
<thead>
<tr>
<th></th>
<th><code>synchronized</code></th>
<th><code>ReentrantLock</code></th>
</tr>
</thead>
<tbody><tr>
<td>实现</td>
<td><strong>JVM</strong> 底层关键字</td>
<td><strong>JDK</strong> API</td>
</tr>
<tr>
<td>公平锁</td>
<td>不支持</td>
<td>可显式指定 <code>new Reentrantlock(true)</code></td>
</tr>
<tr>
<td>多条件/选择通信</td>
<td>只支持一个条件变量</td>
<td>Condition 支持多个条件变量</td>
</tr>
<tr>
<td>线程通信API</td>
<td><code>wait()</code> <code>notify()</code> <code>notifyAll()</code></td>
<td><code>await()</code> <code>signal()</code> <code>signalAll()</code> <code>lock.newCondition()</code></td>
</tr>
<tr>
<td>可重入</td>
<td>支持</td>
<td>支持 <code>getHoldCount()</code> 查看重入次数</td>
</tr>
<tr>
<td>超时等待</td>
<td>不支持</td>
<td>支持 <code>tryLock(timeout)</code> 超时返回机制</td>
</tr>
<tr>
<td>释放</td>
<td>进出代码块自动完成</td>
<td>手动 (<code>lock()</code> <code>unlock()</code>)</td>
</tr>
<tr>
<td>中断</td>
<td>不可响应中断</td>
<td><code>lock.lockInterruptibly()</code></td>
</tr>
<tr>
<td>阻塞获取</td>
<td>只能阻塞获取</td>
<td>支持非阻塞获取<code>tryLock()</code> 失败直接返回</td>
</tr>
</tbody></table>
<p>超时等待：防止死锁， 防止线程无限期阻塞</p>
<p>等待可中断：获取锁的线程在阻塞等待的过程中，如果其他线程中断当前线程 <code>interrupt()</code> ，就会抛出 <code>InterruptedException</code> 异常，可以捕获该异常，做一些处理操作</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>包含独占写锁和共享读锁，在读多写少的情况下性能很好，分为可重入<code>ReentrantReadWriteLock</code> 和不可重入 <code>StampedLock</code> <a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#reentrantreadwritelock-%E6%98%AF%E4%BB%80%E4%B9%88">详见 JavaGuide</a> </p>
<p>ReentrantReadWriteLock </p>
<p>1、读写锁接口ReadWriteLock接口的一个具体实现，实现了读写锁的分离， </p>
<p>2、支持公平和非公平，底层也是基于AQS实现 </p>
<p>3、允许从写锁降级为读锁 流程：先获取写锁，然后获取读锁，最后释放写锁；但不能从读锁升级到写锁 </p>
<p>4、重入：读锁后还可以获取读锁；获取了写锁之后既可以再次获取写锁又可以获取读锁 核心：读锁是共享的，写锁是独占的。 读和读之间不会互斥，读和写、写和读、写和写之间才会互斥， 主要是提升了读写的性能</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a><span id="tools"><mark>AQS<mark></span></h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解 - waterystone - 博客园</a> </p>
<p><strong>AQS（AbstractQueuedSynchronizer）</strong> 是 <strong>Java 并发包</strong>（<code>java.util.concurrent</code>）提供的一个<strong>底层同步框架</strong>，是一个抽象类，用来实现锁和同步器。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，</p>
<ul>
<li>独占：<code>tryAcquire-tryRelease</code>(ReentrantLock)</li>
<li>共享：<code>tryAcquireShared-tryReleaseShared</code>(Semaphore, CountDownLatch)</li>
<li>AQS也支持同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code> </li>
</ul>
<h3 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ol>
<li><p><strong>共享变量 (state)：</strong> </p>
<ul>
<li>AQS 内部有一个整数 <code>volatile</code> 变量 <code>state</code>，用来表示当前锁的状态，比如 0 表示空闲，1 表示已占用。</li>
<li>多个线程可以通过 <strong>CAS 操作</strong>来修改这个共享变量，从而实现并发控制。</li>
</ul>
</li>
<li><p><strong>等待队列 (CLH FIFO队列)：</strong> </p>
<p><code>Node</code>: 含有<code>thread</code>对象</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/40cb932a64694262993907ebda6a0bfetplv-k3u1fbpfcp-zoom-1.png" alt="img"></p>
<ul>
<li>如果线程无法获取共享资源，就进入一个等待队列，这个队列是一个<strong>双向链表</strong>结构。</li>
</ul>
<p><code>waitStatus</code>: </p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/785ca26c055b5be2761374af6a0c7bc5.webp?x-image-process=image/format,png#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><strong>CANCELLED</strong>(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li>
<li><strong>SIGNAL</strong>(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</li>
<li><strong>CONDITION</strong>(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将<strong>从等待队列转移到同步队列中</strong>，等待获取同步锁。</li>
<li><strong>PROPAGATE</strong>(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li>
<li><strong>0</strong>：新结点入队时的默认状态。</li>
</ul>
<p>注意，<strong>负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用&gt;0、&lt;0来判断结点的状态是否正常</strong>。</p>
</li>
<li><p><strong>模板方法：</strong>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可<strong>，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</strong> </p>
<ul>
<li><p><code>isHeldExclusively()</code>：是否正在独占资源。只有用到condition才需要去实现它。</p>
</li>
<li><p><code>tryAcquire(int i)</code>：独占方式。尝试获取资源，成功则返回true，失败则返回false。</p>
</li>
<li><p><code>tryRelease(int i</code>)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</p>
</li>
<li><p><code>tryAcquireShared(int i)</code>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</p>
</li>
<li><p><code>tryReleaseShared(int i)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>
</li>
<li><p>参数 <code>i</code> 表示共享资源的个数，<code>tryAcquire</code> 就是在更改 <code>state</code></p>
<ul>
<li>以<code>ReentrantLock</code>为例，<code>tryLock()</code>就是在非阻塞获取，<code>lock()</code>就是真正的获取过程，先<code>initialTryLock()</code> 一下，逻辑和<code>tryLock()</code>类似这里默认state就是1，因为是Lock自己内部的。如果失败了才真正<code>acquire(1)</code>，这里的1就代表资源的个数（锁的个数）只有1，这里才开始重写AQS的内容，<code>tryAcquire(1)</code> 开始…</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!initialTryLock())</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解 - waterystone - 博客园</a> </p>
<ol>
<li>尝试获取<ul>
<li>如果共享资源空闲，线程可以直接占用资源。</li>
<li>如果锁已被占用，线程会创建一个节点加入队列尾部。</li>
</ul>
</li>
<li>排队等待<ul>
<li>前一个线程释放锁时，会通知队列中的下一个线程。</li>
<li>通知机制依赖 <code>LockSupport.park()</code> 和 <code>LockSupport.unpark()</code> 实现线程通信。</li>
</ul>
</li>
<li>被唤醒的线程继续尝试获取锁，如果成功，则从队列中移除原队头，老二称为新的队头。</li>
</ol>
<p><strong>CLR 队列节点大致结构</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 等待状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 通知下一个线程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 已取消 已放弃</span></span><br><span class="line">    <span class="type">int</span> waitStatus; </span><br><span class="line"></span><br><span class="line">    Node prev; <span class="comment">// 前驱节点</span></span><br><span class="line">    Node next; <span class="comment">// 后继节点</span></span><br><span class="line">    Thread thread; <span class="comment">// 当前线程引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/721070-20170504110246211-10684485-1735391533653-31-1735395150328-37.png" alt="img"></p>
<h5 id="acquire-int"><a href="#acquire-int" class="headerlink" title="acquire(int)"></a><code>acquire(int)</code></h5><p>获取操作：<code>acquire(int arg)</code>：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/721070-20151102145743461-623794326-1735395145015-35-1735395190296-39.png" alt="img"></p>
<p>如图所示，队头是当前共享资源占用者，AQS保证严格按照入队顺序唤醒，老二被<code>unpark</code>之后尝试获取，如果成功自己就是队头，之前的队头将来会自动回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 acquire() 方法中，当 if 语句的条件返回 true 后，就会调用 selfInterrupt() ，该方法会中断当前线程，为什么需要中断当前线程呢？当 if 判断为 true 时，需要 tryAcquire() 返回 false ，并且 acquireQueued() 返回 true 。其中 acquireQueued() 方法返回的是线程被唤醒之后的 中断状态 ，通过执行 Thread.interrupted() 来返回。该方法在返回中断状态的同时，会清除线程的中断状态。因此如果 if 判断为 true ，表明线程的中断状态为 true ，但是调用 Thread.interrupted() 之后，线程的中断状态被清除为 false ，因此需要重新执行 selfInterrupt() 来重新设置线程的中断状态。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aqs-acquire-exclusive-1735447666698-3-1735447685230-5-1735447698634-7.png" alt="Exclusive Acquire"></p>
<p><strong>尝试获取</strong>：<code>tryAcquire(int arg)</code> : 应该由具体的实现类去实现(对status的CAS操作)</p>
<ul>
<li><p>以ReentrantLock为例：</p>
<ul>
<li><p>非公平锁(NotFairSync)：<code>tryAcquire()</code> 无需考虑队列中是否有前驱节点，前面有人也可以试着抢一下。失败后再排队。</p>
</li>
<li><p>公平锁(FairSync)：<code>tryAcquire()</code> 只有 !hasQueuedPredecessors() 才能尝试acquire</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static final class NonfairSync extends Sync:</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getState() == <span class="number">0</span> &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// static final class FairSync extends Sync:</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (getState() == <span class="number">0</span> &amp;&amp; !hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">       compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">       setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>**线程入队: **<code>addWaiter(Node)</code> <code>enq(Node)</code></p>
<p>应该用CAS更新，有快速和自旋两个阶段，快速插入是队列已经初始化了，尝试一次CAS更改</p>
<p>如果快速插入的CAS不成功，就进行自旋CAS插入<code>enq()</code> 同时，如果未初始化会先初始化队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、将当前线程封装为 Node 节点。</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">// 2、如果 pred ！= null，则证明 tail 节点已经被初始化，直接将 Node 节点加入队列即可。 CAS</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 2.1、通过 CAS 控制并发安全。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、初始化队列，并将新创建的 Node 节点加入队列。</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 1、通过 CAS 操作保证队列初始化的并发安全</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2、与 addWaiter() 方法中节点入队的操作相同</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程睡眠</strong>：<code>acquireQueued(Node, int arg)</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS：令队列中的节点尝试获取锁，并且对线程进行阻塞。</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//标记是否成功拿到资源</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 1、如果已经是老二，就可以再去尝试获取一下。</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2、判断线程是否可以阻塞，如果可以，则阻塞当前线程。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 3、如果获取锁失败，就会取消获取锁，将节点状态更新为 CANCELLED。</span></span><br><span class="line">        <span class="keyword">if</span> (failed)<span class="comment">// 等待过程中没有成功获取资源（超时/中断）</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS：判断当前线程节点是否可以阻塞。</span></span><br><span class="line"><span class="comment">// 前面可能有已经放弃的节点，应该挪到最后一个正常等待的节点后边；</span></span><br><span class="line"><span class="comment">// 并且只有前面节点状态为 `SIGNAL` 才能睡，不是的话就应该改成`SIGNAL`再睡</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="comment">// 1、前继节点状态正常，直接返回 true 即可。</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 2、ws &gt; 0 表示前继节点的状态异常，即为 CANCELLED 状态，需要跳过异常状态的节点。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3、如果前继节点的状态不是 SIGNAL，也不是 CANCELLED，就将状态设置为 SIGNAL。</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS 如果确实可以睡，就睡在`parkAndCheckInterrupt()`里等待唤醒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1、线程阻塞到这里 等待unpark()或interrupt()唤醒自己；</span></span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 2、线程被唤醒之后，返回线程中断状态</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="release-int"><a href="#release-int" class="headerlink" title="release(int)"></a><code>release(int)</code></h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aqs-release.png" alt="Release"></p>
<p>线程唤醒：<code>unparkSuccessor()</code> 唤醒队头之后第一个未放弃正常等待的节点，从后往前找。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;<span class="comment">//找到头结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);<span class="comment">//唤醒等待队列里的下一个线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//底层基于 LockSupport.unpark(thread);</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//这里，node一般为当前线程所在的结点。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)<span class="comment">//置零当前线程所在的结点状态，允许失败。</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;<span class="comment">//找到下一个需要唤醒的结点s</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">//如果为空或已取消</span></span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev) </span><br><span class="line">     <span class="comment">// 从后向前遍历,找到头节点后面第一个正常等待的节点</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)<span class="comment">//从这里可以看出，&lt;=0的结点，都是还有效的结点。</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);<span class="comment">//唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aqs-addWaiter.png" alt="img"></p>
<p>为什么prev链是强一致的？因为addWaiter()里每次compareAndSetTail(pred, node)之前都有node.prev = pred，enq()会反复尝试CAStail，直到成功。一旦CAStail成功，该node.prev就成功挂在之前的tail结点上而且是唯一的，这时其他新结点的prev只能尝试往新tail结点上挂。这里的组合用法非常巧妙，能保证CAS之前的prev链强一致，但不能保证CAS后的next链强一致。</p>
<p><code>acquireShared(int arg)</code>  </p>
<p>前面逻辑基本一致，先try 如果失败了，就准备入队，</p>
<p><code>setHeadAndPropagate(Node node, int propagate)</code> </p>
<p>如果自己成了老二并且尝试获取成功，如果资源还有剩余，就会唤醒下一个正常等待的节点：</p>
<p>这些都是失败了就会寻找安全点，进入睡眠</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    setHead(node);<span class="comment">//head指向自己</span></span><br><span class="line">     <span class="comment">//如果还有剩余量，继续唤醒下一个邻居线程</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>releaseShared(int arg)</code> </p>
<p>独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                unparkSuccessor(h);<span class="comment">//唤醒后继</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)<span class="comment">// head发生变化</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="AQS-的常见应用"><a href="#AQS-的常见应用" class="headerlink" title="AQS 的常见应用"></a>AQS 的常见应用</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-thread-x-juc-overview-lock.png" alt="image"></p>
<p>AQS 本身不是直接用来加锁的，而是作为<strong>其他锁工具的基础</strong>。</p>
<ul>
<li><strong>ReentrantLock（可重入锁）：</strong> 用于线程互斥。<ul>
<li> <code>state</code> 表示重入次数，每lock一次就+1，unlock一次就-1，因此获取和释放要一一对应，否则就会死锁，tryAcquire(1)</li>
</ul>
</li>
<li><strong>Semaphore（信号量）：</strong> 控制并发访问的线程数。tryAcquire(n)</li>
<li><strong>CountDownLatch（计数器）：</strong> 等待多个线程完成任务。tryAcquire(n)<ul>
<li> <code>state = N</code>，N 个子线程执行任务，每个子线程执行完后<code>countDown()</code> 一次，也就是 CAS 减 1，<code>state</code> 归零之后，会<code>unpark(callerThread)</code> 主调用线程，主线程从<code>await</code> 返回，继续后面的动作。</li>
</ul>
</li>
<li><strong>ReadWriteLock（读写锁）：</strong> 支持多个读线程和一个写线程。</li>
</ul>
<h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><code>Semaphore</code></h4><p>Semaphore 是 synchronized 的加强版，作用是控制线程的并发数量（允许 自定义多少线程同时访问）。就这一点而言，单纯的synchronized 关键字是实现不了的。</p>
<p>Semaphore有一个构造函数， 可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待， 等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中 传入的int型整数n=1，相当于变成了一个synchronized了。</p>
<p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，而<code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。</p>
<p>Semaphore 的使用简单，我们这里假设有 N(N&gt;5) 个线程来获取 <code>Semaphore</code> 中的共享资源，下面的代码表示同一时刻 N 个线程中只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。</p>
<p>当初始的资源个数为 1 的时候，<code>Semaphore</code> 退化为独占锁。</p>
<p><code>Semaphore</code> 有两种模式：公平和非公平 </p>
<p><code>Semaphore</code> 是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为 <code>permits</code>，你可以将 <code>permits</code> 的值理解为许可证的数量，只有拿到许可证的线程才能执行。</p>
<p>调用<code>semaphore.acquire()</code> ，线程尝试获取许可证，如果 <code>state &gt;= 0</code> 的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state-1</code>。如果 <code>state&lt;0</code> 的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。</p>
<p>调用<code>semaphore.release();</code> ，线程尝试释放许可证，并使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state+1</code>。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 <code>state</code> 的值 <code>state=state-1</code> ，如果 <code>state&gt;=0</code> 则获取令牌成功，否则重新进入阻塞队列，挂起线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始共享资源数量</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取1个许可</span></span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">// 释放1个许可</span></span><br><span class="line">semaphore.release();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreExample</span> &#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">300</span>);</span><br><span class="line">    <span class="comment">// 初始许可证数量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">      threadPool.execute(() -&gt; &#123;<span class="comment">// Lambda 表达式的运用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          semaphore.acquire();<span class="comment">// 获取一个许可，所以可运行线程数量为20/1=20</span></span><br><span class="line">          test(threadnum);</span><br><span class="line">          semaphore.release();<span class="comment">// 释放一个许可</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><code>CountDownLatch</code></h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>releaseShared()</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。</p>
<p>当主线程调用 <code>await()</code> 方法的时候，实际是<code>tryAcquireShared(1)和acquire(1)</code>: 如果 <strong>state 不为 0</strong>，表示计数器未归零，线程会被<strong>封装成 Node 并加入 AQS 的等待队列</strong>中，并进入 <strong>阻塞状态</strong>。<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。直到 <code>count</code> 个线程调用了<code>countDown()</code>使 state 值被减为 0，或者调用<code>await()</code>的线程被中断，该线程才会从阻塞中被唤醒，<code>await()</code> 方法之后的语句得到执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted() ||</span><br><span class="line">        (tryAcquireShared(arg) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         acquire(<span class="literal">null</span>, arg, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">0L</span>) &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 减-1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        signalNext(head);<span class="comment">// SIGNAL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">signalNext</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; (s = h.next) != <span class="literal">null</span> &amp;&amp; s.status != <span class="number">0</span>) &#123;</span><br><span class="line">        s.getAndUnsetStatus(WAITING);</span><br><span class="line">        LockSupport.unpark(s.waiter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample1</span> &#123;</span><br><span class="line">    <span class="comment">// 处理文件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//处理文件的业务操作</span></span><br><span class="line">                    <span class="comment">//......</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//表示一个文件已经被完成</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="用法及注意事项"><a href="#用法及注意事项" class="headerlink" title="用法及注意事项"></a>用法及注意事项</h5><ol>
<li>某一线程在开始运行前等待 n 个线程执行完毕 : 将 <code>CountDownLatch</code> 的计数器初始化为 n （<code>new CountDownLatch(n)</code>），每当一个任务线程执行完毕，就将计数器减 1 （<code>countdownlatch.countDown()</code>），当计数器的值变为 0 时，在 <code>CountDownLatch 上 await()</code> 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</li>
<li>实现多个线程开始执行任务的最大并行性：注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 <code>CountDownLatch</code> 对象，将其计数器初始化为 1 （<code>new CountDownLatch(1)</code>），多个线程在开始执行任务前首先 <code>coundownlatch.await()</code>，当主线程调用 <code>countDown()</code> 时，计数器变为 0，<strong>多个线程同时被唤醒</strong>。</li>
</ol>
<p>与 <code>CountDownLatch</code> 的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用 <code>CountDownLatch.await()</code> 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p>
<p>其他 N 个线程必须引用闭锁对象，因为他们需要通知 <code>CountDownLatch</code> 对象，他们已经完成了各自的任务。这种通知机制是通过 <code>CountDownLatch.countDown()</code>方法来完成的；每调用一次这个方法，在构造函数中初始化的 count 值就减 1。所以当 N 个线程都调 用了这个方法，count 的值等于 0，然后主线程就能通过 <code>await()</code>方法，恢复执行自己的任务。</p>
<p>再插一嘴：<code>CountDownLatch</code> 的 <code>await()</code> 方法使用不当很容易产生死锁，比如我们上面代码中的 for 循环改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount-<span class="number">1</span>; i++) &#123;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就导致 <code>count</code> 的值没办法等于 0，然后就会导致一直等待。</p>
<h5 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a><code>CyclicBarrier</code></h5><p>一个加强版的CountDownLatch。</p>
<p>作用就是会让所有线程都等待完成后才会继续下一步行 动。 CyclicBarrier初始化时规定一个数目，然后计算调用了CyclicBarrier.await()进入等待的线程数。 当线程数达到了这个数目时，所有进入等待状态的线程被唤醒并继续</p>
<p>CyclicBarrier初始时还可带一个Runnable的参数， 此Runnable任务在CyclicBarrier的数目达到 后，所有其它线程被唤醒前被执行。</p>
<h3 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a><code>ConditionObject</code></h3><p>Usage</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!conditionMet()) &#123;</span><br><span class="line">        condition.await(); <span class="comment">// 等待条件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行条件满足后的逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其他线程中：</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    updateCondition();</span><br><span class="line">    condition.signal(); <span class="comment">// 通知等待的线程</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Condition-的等待队列"><a href="#Condition-的等待队列" class="headerlink" title="Condition 的等待队列"></a>Condition 的等待队列</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Monitor.png" alt="Monitor"></p>
<p><code>ConditionObject</code> 维护一个<strong>等待队列</strong>（<mark>单向链表<mark>），其中每个节点是一个AQS CLH 队列的 <code>Node</code> ，节点的 <code>waitStatus</code> 被设置为 <code>COND</code>，表示属于Condition的等待队列节点。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/979960-20180430090729190-1934051559.png" alt="img"></p>
<p><code>ConditionNode</code> 关键字段：</p>
<ul>
<li><code>waitStatus</code>：<code>COND</code> </li>
<li><code>nextWaiter</code>：指向下一个等待节点。</li>
</ul>
<p><code>ConditionObject</code> 拥有等待队列的 <strong>头尾指针</strong>：</p>
<ul>
<li><code>firstWaiter</code>：指向队列头部（第一个等待线程）。</li>
<li><code>lastWaiter</code>：指向队列尾部（最后一个等待线程）。</li>
</ul>
<p>挂起自己的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isReleasable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> status &lt;= <span class="number">1</span> || Thread.currentThread().isInterrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">block</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!isReleasable()) LockSupport.park();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>线程调用 <code>await()</code> 进入等待队列，同时释放锁(AQS的独占锁实现，比如ReentrantLock)。<ol>
<li>调用 <code>addConditionWaiter()</code> 将线程加入条件队列。</li>
<li>调用 <code>fullyRelease()</code> 释放当前线程持有的锁。</li>
<li>判断线程是否进入同步队列，如果没有，则阻塞线程。</li>
<li>被唤醒后，通过 <code>reacquireQueued()</code> 重新获取锁。</li>
</ol>
</li>
<li>线程被阻塞，直到被其他线程唤醒（<code>signal()</code> 或 <code>signalAll()</code>）。<ol>
<li>检查调用线程是否持有锁。</li>
<li>调用 <code>doSignal()</code> 将条件队列中的节点移动到同步队列。</li>
<li>调用 <code>LockSupport.unpark()</code> 唤醒节点线程。</li>
</ol>
</li>
<li>被唤醒后，该线程进入 <strong>AQS 的 CLH 队列</strong> 排队尝试重新获取锁。</li>
</ol>
<h4 id="await"><a href="#await" class="headerlink" title="await()"></a><code>await()</code></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/979960-20180430095049880-331436771.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把当前线程的节点加入到等待队列中　</span></span><br><span class="line"><span class="comment">//调用await()的线程已经获取锁，所以在加入等待队列后，需要释放锁，并且唤醒后继节点线程</span></span><br><span class="line"><span class="comment">//挂起当前线程，当别的线程调用了signal（），并且是当前线程被唤醒的时候才从返回</span></span><br><span class="line"><span class="comment">//当被唤醒后，该线程会尝试去获取锁，只有获取到了才会从await()返回，否则挂起自己</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 创建节点并加入等待队列</span></span><br><span class="line">    <span class="type">ConditionNode</span> <span class="variable">node</span> <span class="operator">=</span> newConditionNode();</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> enableWait(node);<span class="comment">// 加入等待队列，唤醒同步队列的后继节点</span></span><br><span class="line">    LockSupport.setCurrentBlocker(<span class="built_in">this</span>); <span class="comment">// for back-compatibility</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>, cancelled = <span class="literal">false</span>, rejected = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/********************* 无法进入同步队列，循环 ******************************/</span></span><br><span class="line">    <span class="keyword">while</span> (!canReacquire(node)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interrupted |= Thread.interrupted()) &#123; <span class="comment">// 被中断 取消</span></span><br><span class="line">            <span class="keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((node.status &amp; COND) != <span class="number">0</span>) &#123;<span class="comment">// 未被中断 状态是COND 挂起自己</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rejected)</span><br><span class="line">                    node.block();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ForkJoinPool.managedBlock(node);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">                rejected = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">//其他情况，自选等待</span></span><br><span class="line">            Thread.onSpinWait();    <span class="comment">// awoke while enqueuing</span></span><br><span class="line">    &#125;</span><br><span class="line">    LockSupport.setCurrentBlocker(<span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/******** 从上方的循环中跳出，清除 status，准备ReAcquire，进入同步队列  ********/</span></span><br><span class="line">    node.clearStatus();</span><br><span class="line">    acquire(node, savedState, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cancelled) &#123;</span><br><span class="line">            unlinkCancelledWaiters(node);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="enableWait-node"><a href="#enableWait-node" class="headerlink" title="enableWait(node)"></a><code>enableWait(node)</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">enableWait</span><span class="params">(ConditionNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// 先检查是否拥有独占锁 </span></span><br><span class="line">    <span class="keyword">if</span> (isHeldExclusively()) &#123;</span><br><span class="line">        </span><br><span class="line">        node.waiter = Thread.currentThread();</span><br><span class="line">        node.setStatusRelaxed(COND | WAITING);</span><br><span class="line">        <span class="comment">// 尾插法插入条件变量的等待队列中</span></span><br><span class="line">        <span class="type">ConditionNode</span> <span class="variable">last</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">            firstWaiter = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last.nextWaiter = node;</span><br><span class="line">        lastWaiter = node;</span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 释放锁并唤醒同步队列中的下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState))</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有独占锁就需要将节点状态改变为 CANCELLED</span></span><br><span class="line">    node.status = CANCELLED; <span class="comment">// lock not held or inconsistent</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="canReacquire-node"><a href="#canReacquire-node" class="headerlink" title="canReacquire(node)"></a><code>canReacquire(node)</code></h5><p>如果一个在等待队列中的节点现在能够参与同步队列的 ReAcquire，返回 true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Returns true if a node that was initially placed on a condition</span></span><br><span class="line"><span class="comment">         * queue is now ready to reacquire on sync queue.*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canReacquire</span><span class="params">(ConditionNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// check links, not status to avoid enqueue race</span></span><br><span class="line">    Node p; <span class="comment">// traverse unless known to be bidirectionally linked</span></span><br><span class="line">    <span class="comment">// 必须要有前驱节点才能</span></span><br><span class="line">    <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; (p = node.prev) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (p.next == node || isEnqueued(node));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Returns true if node is found in traversal from tail */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isEnqueued</span><span class="params">(Node node)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="unlinkCancelledWaiters-node"><a href="#unlinkCancelledWaiters-node" class="headerlink" title="unlinkCancelledWaiters(node)"></a><code>unlinkCancelledWaiters(node)</code></h5><p><strong>机制</strong>：通过遍历队列节点检查状态标记，将已取消的节点从队列中断开引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">(ConditionNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span> || node.nextWaiter != <span class="literal">null</span> || node == lastWaiter) &#123;</span><br><span class="line">        <span class="type">ConditionNode</span> <span class="variable">w</span> <span class="operator">=</span> firstWaiter, trail = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (w != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ConditionNode</span> <span class="variable">next</span> <span class="operator">=</span> w.nextWaiter;</span><br><span class="line">            <span class="keyword">if</span> ((w.status &amp; COND) == <span class="number">0</span>) &#123;</span><br><span class="line">                w.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (trail == <span class="literal">null</span>)</span><br><span class="line">                    firstWaiter = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    trail.nextWaiter = next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                    lastWaiter = trail;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                trail = w;</span><br><span class="line">            w = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="doSignal-firstNode-all"><a href="#doSignal-firstNode-all" class="headerlink" title="doSignal(firstNode, all)"></a><code>doSignal(firstNode, all)</code></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/979960-20180430101906927-1765442903.png" alt="img"></p>
<p>signal(）方法首先会判断当前线程是不是独占的持有锁，从等待队列中取出第一个节点，并将其移动到 AQS 的同步队列中，然后唤醒等待线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(ConditionNode first, <span class="type">boolean</span> all)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ConditionNode</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">        <span class="keyword">if</span> ((firstWaiter = next) == <span class="literal">null</span>)</span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((first.getAndUnsetStatus(COND) &amp; COND) != <span class="number">0</span>) &#123;</span><br><span class="line">            enqueue(first);</span><br><span class="line">            <span class="keyword">if</span> (!all)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ConditionNode</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="signalAll"><a href="#signalAll" class="headerlink" title="signalAll()"></a><code>signalAll()</code></h5><p>与 <code>signal()</code> 类似，只是将所有等待节点依次移动到同步队列并唤醒。<code>signalAll()</code> 会唤醒所有线程，但可能导致“惊群效应”（即多个线程争夺锁），需要根据场景合理选择 <code>signal()</code> 或 <code>signalAll()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ConditionNode</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="死锁排查——JPS"><a href="#死锁排查——JPS" class="headerlink" title="死锁排查——JPS"></a>死锁排查——JPS</h3><p>jps进程状态工具 <strong>jps.exe 工具是 jdk 自带的，在 %JAVA_HOME%/bin 目录下。</strong></p>
<p>第一步：打开idea提供terminal终端命令行，使用<code>jps -l</code>查看进程<br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20230105200845649-1781815144.png" alt="DeadLock1"><br>第二步：使用<code>jstack 进程号</code>查看堆栈信息<br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20230105201438568-23123605.png" alt="DeadLock2"><br>一般情况信息在最后面<br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20230105201125421-886160053.png" alt="DeadLock3"></p>
<h1 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a><span id="atomic">原子变量</span></h1><p>一个操作具有原子性，即该操作不可分割、不可中断。即使在多个线程同时执行时，该操作要么全部执行完成，要么不执行，不会被其他线程看到部分完成的状态。</p>
<p><code>java.util.concurrent.atomic</code> 包中的 <code>Atomic</code> 原子类提供了一种线程安全的方式来操作单个变量。<code>Atomic</code> 类依赖于 CAS（Compare-And-Swap，比较并交换）乐观锁来保证其方法的原子性，而不需要使用传统的锁机制（如 <code>synchronized</code> 块或 <code>ReentrantLock</code>）。</p>
<h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a><mark>乐观锁与悲观锁<mark></h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁总是假设最坏的情况，即一定会发生线程安全问题，因此必须串行访问临界区，<code>synchronized</code> 和 <code>ReentrantLock</code> 就是悲观锁，高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题（线程获得锁的顺序不当时），影响代码的正常运行。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。</p>
<p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败并重试，会出现类似活锁的问题，这样同样会非常影响性能，导致 CPU 飙升。</p>
<p>不过，大量失败重试的问题也是可以解决的，像我们前面提到的 <code>LongAdder</code>以空间换时间的方式就解决了这个问题。</p>
<p><strong>理论上</strong>：</p>
<ul>
<li>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li>
<li>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li>
</ul>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>一般是在数据库表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。线程 A 更新数据时读入版本号为 1，此时插入一个线程 B 抢先操作完并提交使版本号更新为 2，线程 A 要提交的时候发现版本号不对，因此重新进行更新操作。</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>CAS 是一条原子操作，依赖于 CPU 的一条指令，在 Java 中由 Unsafe 类(native本地方法类)实现，一共有三个参数：要更新的变量，变量的预期值（旧值），要赋给变量的新值；返回值为CAS是否成功。具体原理参见OSTEP Concurrency 部分，<code>do-while</code> 循环也是自旋锁的原理。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><h5 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h5><p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong> </p>
<p>解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<h5 id="自旋开销大"><a href="#自旋开销大" class="headerlink" title="自旋开销大"></a>自旋开销大</h5><p>CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p>
<h5 id="只对单个变量有效"><a href="#只对单个变量有效" class="headerlink" title="只对单个变量有效"></a>只对单个变量有效</h5><p>CAS 操作仅能对单个共享变量有效。当需要操作多个共享变量时，CAS 就显得无能为力。不过，从 JDK 1.5 开始，Java 提供了<code>AtomicReference</code>类，这使得我们能够保证引用对象之间的原子性。通过将多个变量封装在一个对象中，我们可以使用<code>AtomicReference</code>来执行 CAS 操作。</p>
<p>除了 <code>AtomicReference</code> 这种方式之外，还可以利用加锁来保证。</p>
<h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><p>基本类型：<code>AtomicInteger/Long/Boolean</code></p>
<p>数组类型：<code>AtomicXXXArray</code>  XXX = <code>Integer/Long/Reference</code></p>
<p>引用类型：<code>AtomicReference</code> <code>AtomicStampedReference</code> 引用类型解决ABA</p>
<p>基本方法就是 get getAndAdd getAndIncrement compareAndSet getAndSet</p>
<ul>
<li><code>LongAdder</code>:  消耗内存更多，适合写多读少的情况</li>
<li><code>LongAccumulator</code>: generalized version of LongAdder, use <code>LongBinaryOperator</code> as operations</li>
</ul>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a><span id="executor">线程池</span></h1><h2 id="Future-lt-V-gt"><a href="#Future-lt-V-gt" class="headerlink" title="Future&lt;V&gt;"></a><code>Future&lt;V&gt;</code></h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241230173414548.png" alt="image-20241230173414548"></p>
<p><code>Future</code> 提供了一种轮询/阻塞的方式来获取异步任务的结果，但它不直接支持通知机制，而是需要主动检查任务是否完成。提供方法检查任务是否完成、等待任务完成和获取结果。</p>
<p>是 <code>submit()</code>  的返回值，   isDone() 检查是否完成，get() 阻塞等待返回结果</p>
<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a><code>Callable</code></h3><p>Callable 接口类似于 Runnable，从名字就可以看出来了，会返回结果，并且可以抛出返回结果的异常，使用 <strong>call()</strong> 方法代替 <strong>run()</strong> 方法，适合需要结果的任务。可以直接提交到线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureCallableExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        Callable&lt;Integer&gt; task = () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时任务</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务是否完成: &quot;</span> + future.isDone());</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 阻塞等待结果</span></span><br><span class="line">            System.out.println(<span class="string">&quot;任务结果: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="FutureTask-lt-V-gt"><a href="#FutureTask-lt-V-gt" class="headerlink" title="FutureTask&lt;V&gt;"></a><code>FutureTask&lt;V&gt;</code></h3><p>FutureTask 表示一个异步运算的任务，实现了 Runnable 和 Future 接口（RunnableFuture）</p>
<p>FutureTask 通过传入 Callable 的实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然也可以传入 Runnable 的实现类，但是 Runnable 没有返回值，因此需要额外传入一个指定的返回值。V 表示返回值的类型</p>
<p>只有当任务完成的时候结果才能取回，如果<mark>任务尚未完成 <code>get()</code> 方法将会阻塞<mark>。</p>
<p>FutureTask 可以 submit 到线程池，还可以可以直接作为 Thread 构造器的参数(Runnable)创建新线程（实践中不建议直接创建新线程）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Callable&lt;String&gt; callable = () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;任务完成!&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行其他任务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程正在执行其他任务...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get(); <span class="comment">// 阻塞等待</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行结果: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a><code>ExecutorService</code></h2><p>继承了 ExecutorService 并进行一定程度扩展</p>
<p><code>shutdown()</code> 关闭            <code>submit()</code> 提交任务</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-concurrent-executors.png" alt="Executors"></p>
<h3 id="execute-Runnable-command-Runnable-ONLY"><a href="#execute-Runnable-command-Runnable-ONLY" class="headerlink" title="execute(Runnable command) (Runnable ONLY)"></a><code>execute(Runnable command)</code> (<strong>Runnable ONLY</strong>)</h3><p>ThreadPoolExecutor 实现的方法，定义在 <strong><code>Executor</code></strong> 接口中。</p>
<p>只支持提交 <strong><code>Runnable</code></strong> 类型的任务。无返回值，无法获取任务执行结果。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/thread-pool-principle.png" alt="图解线程池实现原理"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********源码************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment"> * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment"> * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment"> * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment"> * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment"> * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment"> * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment"> * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment"> * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment"> * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment"> * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment"> * and so reject the task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 1. 当前线程数 &lt; corePoolSize，创建核心线程</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 如果corePoolSize已满，将任务放入阻塞队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command); <span class="comment">// 检查是否需要拒绝</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 任务队列已满，尝试扩展到 maximumPoolSize</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command); <span class="comment">// 执行拒绝策略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用例</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务1执行: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;);</span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>

<h4 id="submit-supports-Callable-Runnable"><a href="#submit-supports-Callable-Runnable" class="headerlink" title="submit() (supports Callable, Runnable)"></a><code>submit()</code> (supports Callable, Runnable)</h4><p>可以提交 Callable 和 Runnable 任务，返回的是 Future 对象</p>
<ol>
<li>**<code>Runnable</code>**：不返回结果的任务。</li>
<li>**<code>Callable&lt;T&gt;</code>**：<mark>可以返回结果或抛出异常的任务<mark>。</li>
<li>**<code>T result</code>**：指定任务完成后返回的结果。可以给Runnable人工指定返回值，不指定也行</li>
</ol>
<ul>
<li>返回 <strong><code>Future</code></strong> 对象，用于获取任务执行的结果或状态，并且可以方便异常处理。</li>
</ul>
<p>定义在 <strong><code>ExecutorService</code></strong> 接口中，由<code>AbstractExecutorService</code>实现。支持 <strong><code>Runnable</code></strong> 和 <strong><code>Callable</code></strong> 两种任务类型。返回一个 <strong><code>Future&lt;T&gt;</code></strong> 对象，可以获取任务结果或判断任务状态。</p>
<p>主要的任务就是将 Runnable 或者 Callable 封装成 <strong>FutureTask</strong>，FutureTask 实现了 RunnableFuture（实现了 Runnable）可以直接作为 execute(Runnable command) 的参数，查看返回值本身跟线程池没关系，是 Future 的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br><span class="line">Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务2执行: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务结果: &quot;</span> + future.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>

<h3 id="Executors-工具类提供的默认线程池"><a href="#Executors-工具类提供的默认线程池" class="headerlink" title="Executors 工具类提供的默认线程池"></a>Executors 工具类提供的默认线程池</h3><table>
<thead>
<tr>
<th>线程池类型</th>
<th>核心线程数</th>
<th>最大线程数</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>FixedThreadPool</strong></td>
<td>固定数量</td>
<td>固定数量</td>
<td>固定线程数，适合长期稳定的任务执行。积压任务排队等待</td>
</tr>
<tr>
<td><strong>CachedThreadPool</strong></td>
<td>0</td>
<td>无限制</td>
<td>动态扩展线程，适合短期大量任务。60s 回收空闲位置</td>
</tr>
<tr>
<td><strong>SingleThreadExecutor</strong></td>
<td>1</td>
<td>1</td>
<td>单线程执行任务，保证顺序。</td>
</tr>
<tr>
<td><strong>ScheduledThreadPool</strong></td>
<td>固定数量</td>
<td>无限制</td>
<td>支持延迟和周期性任务调度。</td>
</tr>
<tr>
<td><strong>WorkStealingPool</strong></td>
<td>CPU 核心数</td>
<td>CPU 核心数</td>
<td>支持并行任务执行和任务窃取算法。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 固定大小线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 可缓存线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">// 单线程线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">// 定时任务线程池</span></span><br><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 定时任务</span></span><br><span class="line">pool.schedule(() -&gt; System.out.println(<span class="string">&quot;delay&quot;</span>), <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 周期任务</span></span><br><span class="line">pool.scheduleAtFixedRate(() -&gt; System.out.println(<span class="string">&quot;周期&quot;</span>), </span><br><span class="line">                         <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><h4 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h4><ul>
<li>**<code>execute()</code>**：只关注任务执行，不关注结果或异常处理。适合无需返回值的任务，只支持Runnable。</li>
<li>**<code>submit()</code>**：既关注任务执行，也关注结果和异常处理，适合需要返回结果的任务，除了Runnable 也支持 Callable，返回 Future，对其调用get()会阻塞当前任务。</li>
</ul>
<p><strong>最佳实践：</strong> 优先使用 **<code>submit()</code>**，即使不需结果，也可以捕获潜在异常，避免线程池异常崩溃。</p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ul>
<li><strong>使用<code>execute()</code>提交任务</strong>：当任务通过<code>execute()</code>提交到线程池并在执行过程中抛出异常时，如果这个异常没有在任务内被捕获，那么该异常会导致当前线程终止，并且异常会被打印到控制台或日志文件中。线程池会检测到这种线程终止，并创建一个新线程来替换它，从而保持配置的线程数不变。</li>
<li><strong>使用<code>submit()</code>提交任务</strong>：对于通过<code>submit()</code>提交的任务，如果在任务执行中发生异常，这个异常不会直接打印出来。相反，异常会被封装在由<code>submit()</code>返回的<code>Future</code>对象中。当调用<code>Future.get()</code>方法时，可以捕获到一个<code>ExecutionException</code>。在这种情况下，线程不会因为异常而终止，它会继续存在于线程池中，准备执行后续的任务。</li>
</ul>
<p>简单来说：使用<code>execute()</code>时，未捕获异常导致线程终止，线程池创建新线程替代；使用<code>submit()</code>时，异常被封装在<code>Future</code>中，线程继续复用。</p>
<p>这种设计允许<code>submit()</code>提供更灵活的错误处理机制，因为它允许调用者决定如何处理异常，而<code>execute()</code>则适用于那些不需要关注执行结果的场景。</p>
<h4 id="使用自定义线程池-ThreadPoolExecutor"><a href="#使用自定义线程池-ThreadPoolExecutor" class="headerlink" title="使用自定义线程池 ThreadPoolExecutor"></a><mark>使用自定义线程池 <code>ThreadPoolExecutor</code><mark></h4><p>**避免使用 <code>Executors</code> 创建线程池：推荐直接使用<code>ThreadPoolExecutor</code> 自定义线程池：因为 **<code>Executors</code> 默认队列为 <strong>无限队列</strong>，可能导致内存溢出。除了避免 OOM 的原因之外，不推荐使用 <code>Executors</code>提供快捷的线程池的原因：</p>
<ul>
<li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。<ul>
<li>CPU 密集型任务的 <code>WT/ST</code> 接近或者等于 0，因此， 线程数可以设置为 N（CPU 核心数）∗（1+0）= N，和我们上面说的 N（CPU 核心数）+1 差不多。</li>
<li>IO 密集型任务下，几乎全是线程等待时间，从理论上来说，你就可以将线程数设置为 2N（按道理来说，WT/ST 的结果应该比较大，这里选择 2N 的原因应该是为了避免创建过多线程吧）。</li>
</ul>
</li>
</ul>
<h5 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h5><p>建议实践中手动指定线程池配置，ThreadPoolExecutor的构造器共有七个参数：</p>
<ol>
<li><p><code>int corePoolSize</code>: 核心线程数     </p>
</li>
<li><p><code>int maxPoolSize</code>: 最大线程数</p>
</li>
<li><p><code>long keepAliveTime</code>: 非核心线程闲置的最长时间，超时销毁</p>
</li>
<li><p><code>TimeUnit unit</code>: 时间单位，枚举</p>
</li>
<li><p><code>BlockingQueue&lt;Runnable&gt; workQueue</code>: 保存任务的阻塞队列</p>
<ul>
<li><p>如果运行的线程数少于 corePoolSize，则执行器始终倾向于添加新线程而不是排队。</p>
</li>
<li><p>如果 corePoolSize 或更多线程正在运行，对请求进行排队而不是添加新线程。</p>
</li>
<li><p>如果请求无法排队，则会创建一个新线程，如果超出了 MaximumPoolSize，拒绝策略</p>
</li>
</ul>
</li>
</ol>
<ul>
<li><code>SynchronousQueue</code>不会保存任务，直接递交给线程，没有就创建，需要maxPoolSize很大，<code>CachedThreadPool</code> 就属于这种，创建无限个线程也会OOM。</li>
<li><code>LinkedBlockingQueue</code>为无界队列，默认最大容量为 <strong>Integer.MAX_VALUE</strong>，可能会导致任务积压 OOM，比如 Fixed 和 Single<ul>
<li>当所有 <code>corePoolSize</code> 线程都忙时，使用无界队列（例如没有预定义容量的 LinkedBlockingQueue）将导致新任务在队列中等待。</li>
<li>线程最多只有corePoolSize，maxSize没有影响。</li>
<li>当每个任务完全独立于其他任务时，这可能是合适的，因此任务不会影响彼此的执行；例如，在网页服务器中。虽然这种排队方式对于平滑请求的瞬态突发很有用，但它当命令平均到达速度继续快于处理速度时，可能发生OOM</li>
</ul>
</li>
<li><code>ArrayBlockingQueue</code>为有界队列，防止OOM：<ul>
<li>使用大队列和小池可以最大限度地减少 CPU 使用率、操作系统资源和上下文切换开销，但可能会导致人为降低吞吐量。</li>
<li>使用小队列通常需要更大的池，提高了 CPU 的利用率，但遇到不可接受的调度开销时也会降低吞吐量。</li>
</ul>
</li>
</ul>
<p><strong><u>Optional</u> Parameters</strong>：</p>
<ol start="5">
<li><code>ThreadFactory threadFactory</code>: 线程工厂，创建新线程，支持自定义线程名称等属性。</li>
</ol>
<ul>
<li>默认为 <code>Executors.defaultThreadFactory()</code> </li>
</ul>
<ol start="6">
<li><code>RejectedExecutionHandler handler</code>: 线程池满负荷(队列满且maxPoolSize)的拒绝策略</li>
</ol>
<ul>
<li><code>AbortPolicy</code>(default): 抛出<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/RejectedExecutionException.html"><code>RejectedExecutionException</code></a> 异常</li>
<li><code>CallerRunsPolicy</code>: 由提交任务的线程直接执行任务，防止任务丢失。这提供了一个简单的反馈控制机制，将减慢新任务提交的速度。</li>
<li><code>DiscardOldestPolicy</code>: 丢弃最旧未执行的任务，工作队列头部的任务将被删除，然后重试执行（可能会再次失败，导致重复执行）。这种策略很少被接受</li>
<li><code>DiscardPolicy</code>: 直接丢弃，不抛出任何异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">// 队列长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>线程池可以使用getter setter等方法进行参数的访问与更改</p>
</li>
<li><p>使用 Spring 内部线程池 ThreadPoolTaskExecutor 时，一定要手动自定义，合理配置参数，不然会出现生产问题（一个请求创建一个线程）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(name=&quot;threadPoolExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">threadPoolExecutor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">// 返回可用处理器的Java虚拟机的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">processNum</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors(); </span><br><span class="line">        <span class="type">int</span> <span class="variable">corePoolSize</span> <span class="operator">=</span> (<span class="type">int</span>) (processNum / (<span class="number">1</span> - <span class="number">0.2</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxPoolSize</span> <span class="operator">=</span> (<span class="type">int</span>) (processNum / (<span class="number">1</span> - <span class="number">0.5</span>));</span><br><span class="line">        threadPoolExecutor.setCorePoolSize(corePoolSize); <span class="comment">// 核心池大小</span></span><br><span class="line">        threadPoolExecutor.setMaxPoolSize(maxPoolSize); <span class="comment">// 最大线程数</span></span><br><span class="line">        threadPoolExecutor.setQueueCapacity(maxPoolSize * <span class="number">1000</span>); <span class="comment">// 队长</span></span><br><span class="line">        threadPoolExecutor.setThreadPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        threadPoolExecutor.setDaemon(<span class="literal">false</span>);</span><br><span class="line">        threadPoolExecutor.setKeepAliveSeconds(<span class="number">300</span>);<span class="comment">// 线程空闲时间</span></span><br><span class="line">        <span class="comment">// 线程名字前缀</span></span><br><span class="line">        threadPoolExecutor.setThreadNamePrefix(<span class="string">&quot;test-Executor-&quot;</span>); </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> threadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h5><ul>
<li><p>给线程池(实际上是ThreadFactory)命名，有助于定位问题。一般可以使用 Guava：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                        .setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>)</span><br><span class="line">                        .setDaemon(<span class="literal">true</span>).build();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize,</span><br><span class="line">  maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue,</span><br><span class="line"> threadFactory);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="适度复用"><a href="#适度复用" class="headerlink" title="适度复用"></a><strong>适度</strong>复用</h4><ul>
<li><p>要<mark>适当复用<mark>线程池，不要一个请求创建一个线程池，浪费资源且效率极低。</p>
</li>
<li><p>根据当前业务的情况对线程池进行配置，<mark>不同业务不要复用线程池<mark>：父任务占满线程池，导致子任务阻塞，但是父任务也同时被子任务阻塞，造成互相等待的死锁局面。</p>
</li>
</ul>
<h4 id="正确关闭"><a href="#正确关闭" class="headerlink" title="正确关闭"></a>正确关闭</h4><p>释放资源，shutdown(Now)不过只是异步通知，不会同步阻塞等待。</p>
<ul>
<li><strong><code>void shutdown()</code></strong> 有序关闭，执行完先前提交的任务。</li>
<li><strong><code>List&lt;Runnable&gt; shutdownNow()</code></strong> 停止所有正在执行的任务，停止正在等待的任务的处理，并返回正在等待执行的任务的列表。</li>
<li><code>awaitTermination</code> 同步阻塞等待</li>
<li>实现了autoclosable，close方法可以阻塞等待，因此trywithresource</li>
</ul>
<h4 id="不要和-JDK-自带-ThreadLocal-共用"><a href="#不要和-JDK-自带-ThreadLocal-共用" class="headerlink" title="不要和 JDK 自带 ThreadLocal 共用"></a>不要和 JDK 自带 ThreadLocal 共用</h4><p>这是因为线程池会复用线程对象，与线程对象绑定的类的静态属性 <code>ThreadLocal</code> 变量也会被重用，这就导致一个线程可能获取到其他线程的<code>ThreadLocal</code> 值。</p>
<h4 id="不要放入耗时任务"><a href="#不要放入耗时任务" class="headerlink" title="不要放入耗时任务"></a>不要放入耗时任务</h4><p>线程池本身的目的是为了提高任务执行效率，避免因频繁创建和销毁线程而带来的性能开销。如果将耗时任务提交到线程池中执行，可能会导致线程池中的线程被长时间占用，无法及时响应其他任务，甚至会导致线程池崩溃或者程序假死。这些任务可以采用异步 <code>CompletableFuture</code> 完成</p>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a><code>CompletableFuture</code></h2><p><code>Future</code> 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 <code>get()</code> 方法为阻塞调用。Java 8 才被引入<code>CompletableFuture</code> 类可以解决<code>Future</code> 的这些缺陷。<code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。对某些部分可以并行执行的异步任务支持比较好。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>runAsync</code></strong></td>
<td>执行无返回值异步任务。</td>
</tr>
<tr>
<td><strong><code>supplyAsync</code></strong></td>
<td>执行有返回值异步任务。</td>
</tr>
<tr>
<td><strong><code>thenApply</code></strong></td>
<td>转换结果并返回新的结果。</td>
</tr>
<tr>
<td><strong><code>thenAccept</code></strong></td>
<td>消费结果但不返回新结果。</td>
</tr>
<tr>
<td><strong><code>thenCombine</code></strong></td>
<td>合并两个任务的结果。</td>
</tr>
<tr>
<td><strong><code>allOf</code></strong> / <strong><code>anyOf</code></strong></td>
<td>等待所有任务完成 / 任意任务完成。</td>
</tr>
<tr>
<td><strong><code>exceptionally</code></strong> / <strong><code>handle</code></strong></td>
<td>处理异常并提供默认值或继续处理结果。</td>
</tr>
</tbody></table>
<p>以下是 <strong><code>CompletableFuture</code></strong> 的使用示例及详解：</p>
<h3 id="任务创建"><a href="#任务创建" class="headerlink" title="任务创建"></a>任务创建</h3><p><strong>创建异步任务：</strong><code>runAsync()</code><strong>：执行无返回值任务。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行异步任务：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;);</span><br><span class="line">future.join(); <span class="comment">// 等待任务执行完成</span></span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>join()</code>**：等待任务执行完成（类似 **<code>get()</code>**，但不会抛出 checked 异常）。</li>
</ul>
<p><strong>执行有返回值任务：</strong><code>supplyAsync()</code><strong>：执行有返回值任务。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;计算中...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;计算结果：&quot;</span> + future.join());</span><br></pre></td></tr></table></figure>

<h3 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h3><p><code>thenApply</code> - 对任务结果进行变换（同步执行）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span>)</span><br><span class="line">        .thenApply(result -&gt; result * <span class="number">2</span>); <span class="comment">// 结果翻倍</span></span><br><span class="line">System.out.println(future.join()); <span class="comment">// 输出 20</span></span><br></pre></td></tr></table></figure>

<p><code>thenAccept</code> - 消费结果，不返回新的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">        .thenAccept(result -&gt; System.out.println(<span class="string">&quot;结果: &quot;</span> + result));</span><br></pre></td></tr></table></figure>

<p><code>thenRun</code> - 不关心前一任务结果，直接执行下一步操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;任务完成&quot;</span>)</span><br><span class="line">        .thenRun(() -&gt; System.out.println(<span class="string">&quot;继续执行任务&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="组合多个任务"><a href="#组合多个任务" class="headerlink" title="组合多个任务"></a>组合多个任务</h3><p><code>thenCombine</code> - 合并两个任务结果，组合两个任务结果，并执行新任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span>);</span><br><span class="line">CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; result = future1.thenCombine(future2, (a, b) -&gt; a + b);</span><br><span class="line">System.out.println(<span class="string">&quot;结果: &quot;</span> + result.join()); <span class="comment">// 输出 30</span></span><br></pre></td></tr></table></figure>

<p><code>allOf</code> - 等待所有任务完成，但不返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;任务1&quot;</span>)),</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;任务2&quot;</span>)),</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;任务3&quot;</span>))</span><br><span class="line">);</span><br><span class="line">all.join(); <span class="comment">// 等待所有任务完成</span></span><br></pre></td></tr></table></figure>

<p><code>anyOf</code> - 任意任务完成即结束，返回第一个任务的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Object&gt; any = CompletableFuture.anyOf(</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;任务1&quot;</span>),</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;任务2&quot;</span>),</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;任务3&quot;</span>)</span><br><span class="line">);</span><br><span class="line">System.out.println(<span class="string">&quot;最快完成的任务: &quot;</span> + any.join());</span><br></pre></td></tr></table></figure>

<h3 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h3><p><code>exceptionally</code> - 捕获异常并返回默认值，继续执行任务链。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;任务异常&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;捕获异常: &quot;</span> + ex.getMessage());</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 返回默认值</span></span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;结果: &quot;</span> + future.join()); <span class="comment">// 输出 -1</span></span><br></pre></td></tr></table></figure>

<p><code>handle</code>- 捕获异常并处理结果,同时处理正常结果和异常情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;计算出错&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;).handle((result, ex) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理异常: &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 返回默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;最终结果: &quot;</span> + future.join());</span><br></pre></td></tr></table></figure>

<h3 id="线程池自定义"><a href="#线程池自定义" class="headerlink" title="线程池自定义"></a>线程池自定义</h3><p>指定线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;自定义线程池: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;, executor).join();</span><br><span class="line"></span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>

<p>**异步任务默认使用 **<code>ForkJoinPool.commonPool()</code>，但可以自定义线程池以控制资源。</p>
<h3 id="例：批量任务处理"><a href="#例：批量任务处理" class="headerlink" title="例：批量任务处理"></a>例：批量任务处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;CompletableFuture&lt;Integer&gt;&gt; futures = IntStream.range(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">        .mapToObj(i -&gt; CompletableFuture.supplyAsync(() -&gt; i * <span class="number">2</span>))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; allDone = CompletableFuture.allOf(</span><br><span class="line">        futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>])</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">allDone.join();</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; results = futures.stream()</span><br><span class="line">        .map(CompletableFuture::join)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;所有结果: &quot;</span> + results);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <strong><code>allOf()</code></strong> 确保所有任务完成。</li>
<li>收集各任务结果并返回。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有结果: [2, 4, 6, 8, 10]</span><br></pre></td></tr></table></figure>

<h3 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/virtual-thread.html">虚拟线程</a></h3>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"># 并发</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/11/20/juc-thread-in-one/" rel="prev" title="java.lang.Thread">
                  <i class="fa fa-angle-left"></i> java.lang.Thread
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/11/30/408-OS-Linux/" rel="next" title="Linux 基本命令">
                  Linux 基本命令 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">碎梦</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/scatteredream" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
