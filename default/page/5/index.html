<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Arvo:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scatteredream.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="scatteredream&#39;s blog">
<meta property="og:url" content="http://scatteredream.github.io/default/page/5/index.html">
<meta property="og:site_name" content="scatteredream&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="碎梦">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://scatteredream.github.io/default/page/5/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default/page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>scatteredream's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">scatteredream's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="碎梦"
      src="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
  <p class="site-author-name" itemprop="name">碎梦</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">75</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">120</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/13/408-%E8%AE%A1%E7%BB%84-Link/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/13/408-%E8%AE%A1%E7%BB%84-Link/" class="post-title-link" itemprop="url">符号链接</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-13 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-13T00:00:00+08:00">2024-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 12:43:29" itemprop="dateModified" datetime="2025-05-05T12:43:29+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">计组</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>文本：源代码 <code>hello.c</code></p>
<p>预处理：修改文本 <code>hello.i file</code></p>
<p>编译器：assembly <code>hello.s file</code></p>
<p>汇编器：binary code <code>hello.o file</code></p>
<p>连接器：hello.o + printf.o -&gt; <code>hello</code> </p>
<p><strong>线程级并行</strong>：指令执行基本单位</p>
<ul>
<li><p>多核心：多个核共享L3缓存，一个核有一个统一的L2缓存，L1缓存分为数据缓存和指令缓存，数据缓存直连CPU寄存器</p>
</li>
<li><p>超线程：可以在单个周期内决定要切换到哪个线程，在一个线程等待数据运过来的过程中，CPU可以去转而执行另一个线程，8核心 16线程，线程并行</p>
</li>
</ul>
<p><strong>指令级并行</strong>：指令间并行</p>
<ul>
<li>流水线</li>
<li>超标量</li>
</ul>
<p>单指令，多数据并行：数据流并行 SIMD 一条指令可以产生多个并行执行的操作</p>
<p>抽象：Disk 代表I/O设备，Memory代表主存</p>
<ul>
<li>Virtual Machine：OS+CPU+Memory+Disk</li>
<li>Process： CPU+Memory+Disk</li>
<li>Virtual Memory：Memory+Disk</li>
<li>File：Disk</li>
<li>CPU：Instruction Set architecture</li>
</ul>
<h1 id="Linker"><a href="#Linker" class="headerlink" title="Linker"></a>Linker</h1><h2 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h2><p>“目标文件是字节块的集合”这句话通常用来描述目标文件（object file）的本质结构。目标文件是编译器生成的中间文件，包含程序代码和数据，用于后续的链接操作。以下是对这一概念的详细解析：</p>
<h3 id="目标文件的本质：字节块"><a href="#目标文件的本质：字节块" class="headerlink" title="目标文件的本质：字节块"></a>目标文件的本质：字节块</h3><p>目标文件是由一系列字节组成的文件，这些字节可以看作是数据块。这些数据块并不是随意排列的，而是按照一定的格式组织起来，通常包括：</p>
<ul>
<li><strong>代码段</strong>：存储编译后的机器指令。</li>
<li><strong>数据段</strong>：存储已初始化的全局或静态变量。</li>
<li><strong>未初始化数据段（BSS）</strong>：存储未初始化的全局或静态变量，实际大小记录在文件中，但不占用物理空间。</li>
<li><strong>符号表</strong>：记录函数和变量的名字及其在文件中的位置。</li>
<li><strong>重定位信息</strong>：指示链接器如何修改目标文件以适应最终的内存布局。</li>
</ul>
<p>这些内容本质上都是字节序列，每一部分由多个字节块组成。</p>
<hr>
<h3 id="字节块的特点"><a href="#字节块的特点" class="headerlink" title="字节块的特点"></a>字节块的特点</h3><ul>
<li><strong>固定大小或可变大小</strong>：字节块可以是固定长度的单位，例如4字节对齐的机器指令，也可能是不定长的数据块。</li>
<li><strong>有意义的分组</strong>：每个块都有明确的意义，比如某个函数的机器代码、某个变量的初始值等。</li>
<li><strong>易于解析</strong>：链接器、调试器等工具需要能够根据文件的格式解析这些块，因此这些字节块被有序地组织在文件头定义的布局中。</li>
</ul>
<hr>
<h3 id="目标文件格式"><a href="#目标文件格式" class="headerlink" title="目标文件格式"></a>目标文件格式</h3><p>目标文件的格式是如何定义这些字节块的重要规则。例如：</p>
<ul>
<li><strong>ELF（Executable and Linkable Format）</strong> 是一种常见的目标文件格式，广泛用于Linux系统。它将字节块分为不同的段（Section），并用段表和符号表记录每个块的起始地址和大小。</li>
<li><strong>COFF（Common Object File Format）</strong> 是Windows等系统常用的格式。</li>
</ul>
<p>这些格式提供了语法规则，使得目标文件的字节块能够被链接器或加载器正确地解读。</p>
<hr>
<h3 id="为什么强调“字节块的集合”？"><a href="#为什么强调“字节块的集合”？" class="headerlink" title="为什么强调“字节块的集合”？"></a>为什么强调“字节块的集合”？</h3><ul>
<li><strong>通用性</strong>：这一描述抽象了目标文件的存储本质。无论是代码段还是数据段，本质上都是按字节存储的数据。</li>
<li><strong>便于理解文件结构</strong>：将目标文件看作字节块集合，可以帮助程序员理解文件的解析方式，特别是分析目标文件格式时。</li>
<li><strong>与内存映射相关</strong>：最终，这些字节块会被加载到内存中，按照相同的结构组织成进程的内存布局。</li>
</ul>
<hr>
<h3 id="深入理解的关键"><a href="#深入理解的关键" class="headerlink" title="深入理解的关键"></a>深入理解的关键</h3><p>为了深入理解，可以通过以下方式进一步探索：</p>
<ul>
<li><strong>查看目标文件结构</strong>：使用工具（如 <code>objdump</code> 或 <code>readelf</code>）解析目标文件，观察各部分的字节分布。</li>
<li><strong>编写简单的C程序并编译</strong>：用编译器生成目标文件，并对比源代码和目标文件中的符号表、代码段。</li>
<li><strong>了解链接过程</strong>：理解这些字节块如何在链接过程中被组合成最终的可执行文件。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>编写简单的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译生成目标文件后，使用 <code>readelf -a</code> 或 <code>objdump -h</code> 查看其字节块分布。你会发现，虽然程序非常简单，但目标文件已经按照格式组织了各种段和数据块。</p>
<h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><p><strong>符号解析</strong>是链接过程中一个重要的步骤，用于将目标文件中的符号（如变量名、函数名）解析为具体的内存地址或其他符号的引用地址。它的目的是将代码中使用的符号与其定义进行匹配，以实现正确的程序连接。</p>
<p>以下是详细的解释：</p>
<hr>
<h3 id="什么是符号？"><a href="#什么是符号？" class="headerlink" title="什么是符号？"></a><strong>什么是符号？</strong></h3><p>符号是程序中用来表示变量、函数、常量或其他标识符的名字。它可以包括：</p>
<ul>
<li>全局变量</li>
<li>函数名</li>
<li>静态变量（如果需要）</li>
<li>外部引用的符号（来自其他目标文件或库）</li>
</ul>
<p>在目标文件中，这些符号并不直接对应内存地址，而是保存在<strong>符号表</strong>中，等待链接器解析。</p>
<hr>
<h3 id="符号解析的作用"><a href="#符号解析的作用" class="headerlink" title="符号解析的作用"></a><strong>符号解析的作用</strong></h3><p>符号解析的主要目的是：</p>
<ul>
<li>将<strong>使用符号的地方</strong>（例如函数调用或变量访问）和<strong>定义符号的地方</strong>联系起来。</li>
<li>为符号分配实际的内存地址或引用其他文件中符号的位置。</li>
</ul>
<p>如果符号在当前目标文件中找不到定义，链接器会尝试在其他目标文件或库中找到它。</p>
<hr>
<h3 id="符号解析的过程"><a href="#符号解析的过程" class="headerlink" title="符号解析的过程"></a><strong>符号解析的过程</strong></h3><ol>
<li><p><strong>构建符号表</strong>：链接器首先扫描所有目标文件和库文件，读取它们的符号表，记录所有已定义和未定义的符号。</p>
</li>
<li><p>查找符号定义</p>
<p>：对于每个未定义的符号，链接器会在符号表中搜索其定义。</p>
<ul>
<li>如果找到，链接器会将引用符号的位置更新为定义的位置。</li>
<li>如果找不到，链接器会报错（如“未定义符号”错误）。</li>
</ul>
</li>
<li><p><strong>处理重定位信息</strong>：对于解析后的符号，链接器会根据其地址调整目标文件中的指令或数据。</p>
</li>
</ol>
<hr>
<h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a><strong>常见场景</strong></h3><ul>
<li><strong>内部符号解析</strong>：在同一个目标文件中，一个函数调用另一个函数，链接器只需在这个目标文件内找到符号的定义。</li>
<li><strong>外部符号解析</strong>：一个目标文件调用另一个目标文件或库中的符号，链接器需要跨文件查找。</li>
<li><strong>动态库中的符号解析</strong>：如果链接的是动态库（如 <code>.so</code> 或 <code>.dll</code> 文件），符号解析可能延迟到程序运行时进行。</li>
</ul>
<hr>
<h3 id="符号解析失败的原因"><a href="#符号解析失败的原因" class="headerlink" title="符号解析失败的原因"></a><strong>符号解析失败的原因</strong></h3><p>符号解析失败通常会导致编译或链接错误，比如：</p>
<ul>
<li>未定义符号错误：<ul>
<li>函数或变量的定义缺失。</li>
<li>链接时遗漏了需要的库。</li>
</ul>
</li>
<li>重复定义错误：<ul>
<li>同一个符号在多个目标文件中重复定义。</li>
</ul>
</li>
<li>符号不可见：<ul>
<li>符号被声明为 <code>static</code> 或其他方式限制了可见性，导致无法被外部文件引用。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="符号解析工具"><a href="#符号解析工具" class="headerlink" title="符号解析工具"></a><strong>符号解析工具</strong></h3><p>在实际开发中，可以使用一些工具检查符号：</p>
<ul>
<li><code>nm</code>：列出目标文件或库中的符号表。</li>
<li><code>objdump</code>：查看符号和段信息。</li>
<li><code>readelf</code>：分析目标文件的 ELF 格式符号。</li>
</ul>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm myfile.o</span><br></pre></td></tr></table></figure>

<p>会输出目标文件 <code>myfile.o</code> 中的所有符号及其状态（已定义或未定义）。</p>
<hr>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h3><p>假设有以下代码：</p>
<p>**文件 <code>a.c</code>**：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> foo = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<p>**文件 <code>b.c</code>**：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> foo;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>编译</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c a.c -o a.o</span><br><span class="line">gcc -c b.c -o b.o</span><br></pre></td></tr></table></figure>

<ul>
<li><code>a.o</code> 中定义了符号 <code>foo</code>。</li>
<li><code>b.o</code> 中引用了符号 <code>foo</code>（标记为未定义）。</li>
</ul>
</li>
<li><p><strong>链接</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc a.o b.o -o program</span><br></pre></td></tr></table></figure>

<ul>
<li>链接器会解析 <code>b.o</code> 中的符号 <code>foo</code>，在 <code>a.o</code> 中找到它的定义，并完成解析。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>符号解析是链接器将程序中的符号引用与定义匹配起来的关键步骤。它确保程序在执行时能够正确访问函数、变量等资源。符号解析的成功与否直接影响程序的正确性，开发中需要注意符号的定义与使用是否一致，以及是否正确链接所需的目标文件或库。</p>
<ul>
<li><code>switch</code>性能是否总是比<code>if-else</code>好？</li>
<li>一个函数调用的开销有多大？</li>
<li><code>while</code>性能是否总是比<code>for</code>好？</li>
<li>指针引用比数组索引更加有效吗？</li>
<li>为什么将循环求和的结果放到本地变量中，比放到一个通过引用传递过来的参数中更加有效？</li>
<li>为什么只是简单将算数表达式中的括号进行重排就能加快运行速度？</li>
</ul>
<p>链接的错误：</p>
<ul>
<li>静态变量与全局变量的区别</li>
<li>不同C文件中定义相同的全局变量</li>
<li>静态库和动态库的区别</li>
<li>命令行上排列库的顺序有什么影响</li>
<li>为什么有些链接错误直到运行时才会出现？</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/13/jvm-classfile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/13/jvm-classfile/" class="post-title-link" itemprop="url">ClassFile</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-13 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-13T00:00:00+08:00">2024-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 10:57:48" itemprop="dateModified" datetime="2025-04-27T10:57:48+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ClassFile-字节码"><a href="#ClassFile-字节码" class="headerlink" title="ClassFile 字节码"></a>ClassFile 字节码</h1><p>Java 字节码是 Java 编译器将 Java 源代码编译成的 <strong>中间表示格式</strong>，它运行在 <strong>Java 虚拟机（JVM）</strong> 上。Java 字节码文件的扩展名为 <code>.class</code>，可以通过 <code>javap -c</code> 命令查看其内容。</p>
<p>任何一个Class文件都对应着唯一的一个类或接口的定义信息[1]，但是反过来说，类或 接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。本章中， 笔者只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”，实际上它完全不 需要以磁盘文件的形式存在。</p>
<p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文 件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数 据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[2]的方式分割 成若干个8个字节进行存储。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/09/13/jvm-classfile/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/11/jvm-in-one/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/11/jvm-in-one/" class="post-title-link" itemprop="url">JVM 介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-11 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-11T00:00:00+08:00">2024-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-08 13:31:48" itemprop="dateModified" datetime="2025-05-08T13:31:48+08:00">2025-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JVM-是虚拟机吗？"><a href="#JVM-是虚拟机吗？" class="headerlink" title="JVM 是虚拟机吗？"></a>JVM 是虚拟机吗？</h1><h2 id="JVM-是什么？"><a href="#JVM-是什么？" class="headerlink" title="JVM 是什么？"></a>JVM 是什么？</h2><p><strong>Java Virtual Machine (JVM)</strong> 是 Java 平台的核心组件，它是一个<mark><strong>程序运行环境</strong><mark>，专门用来执行 Java 字节码（Bytecode）</p>
<p><strong>主要功能：</strong></p>
<ol>
<li><strong>跨平台支持</strong>：JVM 实现了 Java 的 “Write Once, Run Anywhere” 特性，使 Java 程序能够在不同操作系统上运行。</li>
<li>字节码解释和编译：JVM 将 Java 编译器生成的字节码（平台无关）转换为平台相关的机器代码，并执行。</li>
<li>内存管理：提供垃圾回收机制 (Garbage Collection, GC)。</li>
<li>安全性：内置安全检查机制，确保 Java 程序在受控环境中运行，防止恶意代码执行。</li>
</ol>
<h2 id="Hypervisor-VMM-是什么"><a href="#Hypervisor-VMM-是什么" class="headerlink" title="Hypervisor/VMM 是什么?"></a>Hypervisor/VMM 是什么?</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2560px-Hyperviseur.svg.png" alt="undefined"></p>
<p>Hypervisor 是一种一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件。也可叫做虚拟机监视器，即 VMM（ virtual machine monitor ）。</p>
<ul>
<li>当服务器启动并执行 Hypervisor 时，它会加载所有虚拟机客户端的操作系统同时会分配给每一台虚拟机适量的内存，CPU，网络和磁盘。它允许多个操作系统（称为<strong>Guest OS</strong>）在同一台物理机器（称为<strong>Host</strong>）上同时运行，每个操作系统被隔离在独立的虚拟机中。</li>
<li>Hypervisor 负责资源分配，如 CPU、内存和存储，协调着这些硬件资源的访问，而且在各个虚拟机之间施加防护，处理虚拟机之间的通信和安全隔离。</li>
</ul>
<h2 id="JVM-与-Hypervisor-VMM-的对比"><a href="#JVM-与-Hypervisor-VMM-的对比" class="headerlink" title="JVM 与 Hypervisor/VMM 的对比"></a>JVM 与 Hypervisor/VMM 的对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>JVM</th>
<th>Hypervisor/VMM</th>
</tr>
</thead>
<tbody><tr>
<td><strong>用途</strong></td>
<td>运行 Java 程序的虚拟环境</td>
<td>管理和运行多个虚拟机，每个虚拟机可运行不同操作系统</td>
</tr>
<tr>
<td><strong>虚拟化层级</strong></td>
<td>应用程序级虚拟化（针对 Java 字节码）</td>
<td>操作系统级虚拟化（针对硬件资源）</td>
</tr>
<tr>
<td><strong>管理对象</strong></td>
<td><strong>Java 字节码执行环境</strong></td>
<td>虚拟机管理和<strong>硬件资源虚拟化</strong></td>
</tr>
<tr>
<td><strong>依赖性</strong></td>
<td>必须安装在操作系统上，依赖操作系统环境</td>
<td>Type 1 可以直接运行在硬件上，Type 2 依赖操作系统</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>程序之间隔离性较弱，依赖 JVM 的安全机制</td>
<td>每个虚拟机互相独立，硬件级别隔离</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td>Oracle HotSpot VM、OpenJDK JVM</td>
<td>VMware ESXi、VirtualBox、KVM、Hyper-V</td>
</tr>
</tbody></table>
<ol>
<li>在 VMware ESXi 上创建一个虚拟机；</li>
<li>在虚拟机内部运行一个 Guest OS，比如 Linux；</li>
<li>在 Linux 中安装 Java 环境并运行 JVM。</li>
</ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/09/11/jvm-in-one/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/09/java-web-frontend/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/09/java-web-frontend/" class="post-title-link" itemprop="url">Web 前端</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-09 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-09T00:00:00+08:00">2024-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:21:49" itemprop="dateModified" datetime="2025-05-05T11:21:49+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web-development/" itemprop="url" rel="index"><span itemprop="name">web development</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p><strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage </p>
<p>结构：HTML</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/html/html-tutorial.html">HTML 教程 | 菜鸟教程 (runoob.com)</a> </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTML">HTML - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">HTML（超文本标记语言） | MDN (mozilla.org)</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926154402465.png" alt="image-20240926154402465"></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="基础标签"><a href="#基础标签" class="headerlink" title="基础标签"></a>基础标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926165557803.png" alt="image-20240926165557803"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926170603004.png" alt="image-20240926170603004"></p>
<h3 id="图片，音视频标签"><a href="#图片，音视频标签" class="headerlink" title="图片，音视频标签"></a>图片，音视频标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926170628097.png" alt="image-20240926170628097"></p>
<p>height weight 有 px 和百分比两种写法 src路径</p>
<p>URL 统一资源定位符 ../ 代表上一级目录 </p>
<h3 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926171504599.png" alt="image-20240926171504599"></p>
<p>a href=”url” </p>
<h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926171804215.png" alt="image-20240926171804215"></p>
<h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926171833199.png" alt="image-20240926171833199"></p>
<p>边框宽度+空白区间宽度</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926172249995.png" alt="image-20240926172249995"></p>
<h3 id="布局标签"><a href="#布局标签" class="headerlink" title="布局标签"></a>布局标签</h3><div></div>


<p>div块级标签，占一整行</p>
<p>span 只占据自己的空间</p>
<h3 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926193335810.png" alt="image-20240926193335810"></p>
<p>提交表单：方式get/post </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926193711640.png" alt="image-20240926193711640"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926194217797.png" alt="image-20240926194217797"></p>
<p><strong>点击框外文本就能让框处于被选中的状态</strong>：</p>
<p>如果要随着表单一起提交，就要起一个name</p>
<p>用<strong>label</strong>标签把用户名包裹起来，给输入框起一个唯一的id, label for “id” </p>
<p><strong>radio</strong>：单选按钮，让其name相同达到互斥效果，给他赋值value让服务器接收到有效信息</p>
<p>hidden 修改商品信息，id隐藏在表单里面,提交表单会上传</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928193146331.png" alt="image-20240928193146331"></p>
<p>submit reset button 如果要指定按钮名字 value</p>
<select>
    <option>123</option>
     <option>4567</option>
</select>


<p>textarea cols支持的列数 rows支持的行数</p>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>表现：CSS</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/css/css-tutorial.html">CSS 教程 | 菜鸟教程 (runoob.com)</a> </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CSS">CSS - 维基百科，自由的百科全书 (wikipedia.org) </a> </p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS：层叠样式表 | MDN (mozilla.org)</a></p>
<h2 id="导入HTML"><a href="#导入HTML" class="headerlink" title="导入HTML"></a>导入HTML</h2><p>在head标签中导入</p>
<p>内联，内部，外部</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926201958367.png" alt="image-20240926201958367"></p>
<p><code>&lt;link href=&quot;css路径&quot; rel=&quot;stylesheet&quot;&gt;</code></p>
<h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926202419738.png" alt="image-20240926202419738"></p>
<p>name唯一 class不唯一</p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>行为：javascript</p>
<p>什么是JS？</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/js/js-tutorial.html">JavaScript 教程 | 菜鸟教程 (runoob.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript">JavaScript——动态客户端脚本语言 - 学习 Web 开发 | MDN (mozilla.org)</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926202813408.png" alt="image-20240926202813408"></p>
<p>改变HTML 交互性</p>
<p>引入方式：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929131050714.png" alt="image-20240929131050714"></p>
<p>内部脚本,一般放在body下面</p>
<p>外部脚本, 不支持自闭合</p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul>
<li>区分大小写，分号可有可无</li>
<li>单行，多行注释</li>
<li>大括号表示代码块</li>
</ul>
<h3 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h3><ul>
<li>(window.)alert()弹出警告</li>
<li>document.write() 写入HTML页面</li>
<li>console.log() 写入浏览器控制台</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>var是变量，弱类型语言，可以存放不同类型的值</p>
<p>作用域：全局变量而且可以重复声明定义</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929132314244.png" alt="image-20240929132314244"></p>
<p>let 作用域只在代码块之内 局部变量 不可重复定义</p>
<p>const 常量</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929132717037.png" alt="image-20240929132717037"></p>
<p>number boolean string 空（null）默认初始值（undefined）</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929132954368.png" alt="image-20240929132954368"></p>
<p>全等于(===) 类型不一样返回false，更加严格</p>
<p>等于（==）判断类型是否一样，如果不一样则转换类型，然后才比较值</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>转为number：</p>
<ul>
<li>string<ul>
<li><code>var str = &quot;20&quot;   parseInt(str)</code></li>
<li>字面值转为数字，如果字面值不是数字，转为NaN</li>
</ul>
</li>
<li>boolean <ul>
<li>true-&gt;1 false-&gt;0</li>
</ul>
</li>
</ul>
<p>转成boolean</p>
<ul>
<li>number： 0和NaN转为false</li>
<li>string：空字符串转为false</li>
<li>null&amp;undefined：转为false</li>
</ul>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>if  switch  while  do while  </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929135023368.png" alt="image-20240929135023368"></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>关键字：function</li>
<li>返回值类型：不需要，直接return</li>
<li>参数列表：不用写参数类型</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929135258270.png" alt="image-20240929135258270"></p>
<p>实际调用可以有很多实参，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929135611640.png" alt="image-20240929135611640"></p>
<p>add(1,2) = 3</p>
<p>add(1)  = NaN</p>
<h2 id="JavaScript-对象"><a href="#JavaScript-对象" class="headerlink" title="JavaScript 对象"></a>JavaScript 对象</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">//访问数组</span></span><br><span class="line">arr1[<span class="number">1</span>]=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>与java不同，js的数组是集合，变长，变类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变长</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr3[<span class="number">5</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//索引为5的元素被赋值为10, 中间空出来的是undefined</span></span><br><span class="line"><span class="comment">//变类型</span></span><br><span class="line">arr3[<span class="number">10</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>长度：length</p>
<p>增：push(10) 加入值为10的元素</p>
<p>删：splice(0,3)从索引0开始，删除3个元素</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>length:长度</p>
<p>trim(): 去除字符串两端的空白字符</p>
<p>charAt(i):返回指定位置的字符</p>
<p>indexOf(c) 返回字符第一次出现的索引</p>
<h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;ZS&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">23</span>,</span><br><span class="line">    <span class="attr">eat</span>:<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;eat&quot;</span>+a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">eat</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>浏览器对象模型</p>
<p>Navigator Screen</p>
<h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><ul>
<li>窗口对象，使用window获取</li>
<li><code>alert()</code> 警告</li>
<li><code>confirm(&quot;对话框内容&quot;)</code> 确认/取消对话框<ul>
<li>有返回值，返回的是一个boolean</li>
</ul>
</li>
<li><code>setInterval(function,ms)</code> 定时器，循环执行function</li>
<li><code>setTimeout(function,ms)</code> 倒计时，只有一次</li>
</ul>
<p>根据变化的数字，产生固定个数的值，取模</p>
<h5 id="history"><a href="#history" class="headerlink" title="history"></a>history</h5><ul>
<li><p>通过window调取，window可省略</p>
</li>
<li><p><code>history.back()</code>加载前一个URL</p>
</li>
<li><p><code>history.forward()</code>加载下一个URL</p>
</li>
</ul>
<h5 id="location"><a href="#location" class="headerlink" title="location"></a>location</h5><ul>
<li>通过window调取，可省略</li>
<li><code>location.href</code> 设置当前的URL，可以实现跳转</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929143103867.png" alt="image-20240929143103867"></p>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>文档对象模型 W3C指定的XML HTML的规则</p>
<p>查文档</p>
<h4 id="document"><a href="#document" class="headerlink" title="document"></a>document</h4><h5 id="获取Element"><a href="#获取Element" class="headerlink" title="获取Element"></a>获取Element</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929143507450.png" alt="image-20240929143507450"></p>
<ul>
<li>id: 每个元素唯一的id</li>
<li>tagName: 标签名</li>
<li>class: 同类的，一个元素可以有多个类，一个类可以有多个元素</li>
<li>name: 用于radio checkbox 和 form表单 提交将输入的值发送</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;submit.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">value</span>=<span class="string">&quot;apple&quot;</span>&gt;</span> Apple</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">value</span>=<span class="string">&quot;banana&quot;</span>&gt;</span> Banana</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">value</span>=<span class="string">&quot;orange&quot;</span>&gt;</span> Orange</span><br></pre></td></tr></table></figure>

<h5 id="element通用方法"><a href="#element通用方法" class="headerlink" title="element通用方法"></a>element通用方法</h5><ul>
<li><p>element.<strong>style</strong> 获取style标签</p>
<ul>
<li>element.style.color = “red” 设置元素的style中 color属性为red</li>
<li></li>
</ul>
</li>
<li><p>element.<strong>innerHTML</strong> 改变两个标签内部的文本内容</p>
</li>
</ul>
<p>checkbox.<strong>checked</strong>=true 复选框设置为勾选  </p>
<h2 id="事件监听-EventListener"><a href="#事件监听-EventListener" class="headerlink" title="事件监听 EventListener"></a>事件监听 EventListener</h2><p>事件：发生在HTML元素上的事件，比如按钮被电击，鼠标移到元素之上，按下键盘按键</p>
<p>监听：侦测到事件，执行某些代码</p>
<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><h4 id="HTML标签的属性绑定"><a href="#HTML标签的属性绑定" class="headerlink" title="HTML标签的属性绑定"></a>HTML标签的属性绑定</h4><p>耦合度太高</p>
<h4 id="DOM元素属性绑定"><a href="#DOM元素属性绑定" class="headerlink" title="DOM元素属性绑定"></a>DOM元素属性绑定</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929145651893.png" alt="image-20240929145651893"></p>
<p>属性和函数绑定</p>
<h3 id="常见的事件"><a href="#常见的事件" class="headerlink" title="常见的事件"></a>常见的事件</h3><p><code>onblur</code>: 失去焦点</p>
<p><code>onfocus</code>: 获得焦点</p>
<p><code>onchange</code>:文本改变</p>
<p><code>onkeydown</code>: 按键</p>
<p><code>onmouseover</code>: 鼠标移动到指定对象上</p>
<p><code>onmouseout</code>：鼠标离开指定对象</p>
<p><code>onsubmit</code>: 表单验证，绑定的函数要有返回值，如果返回true则表单会被提交</p>
<p>核心宗旨：把一些交互逻辑更多地放到浏览器这边，减少服务端的压力</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929152143546.png" alt="image-20240929152143546"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929153455050.png" alt="image-20240929153455050"></p>
<p>绑定函数和事件</p>
<h1 id="Regex"><a href="#Regex" class="headerlink" title="Regex"></a>Regex</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/regexp/regexp-tutorial.html">正则表达式 – 教程 | 菜鸟教程 (runoob.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://regex101.com/">regex101: build, test, and debug regex</a> </p>
<p><strong>正则表达式（Regular Expression, regex）</strong>是一种用来描述和匹配字符串模式的工具，其原理基于形式语言和自动机理论。以下是正则表达式的主要原理和工作机制：</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ol>
<li><strong>字符匹配</strong>：正则表达式中的普通字符（如 <code>a</code>, <code>b</code>, <code>1</code>, <code>2</code>）直接匹配自身。例如，正则表达式 <code>abc</code> 将匹配字符串 “abc”。</li>
<li><strong>元字符和转义</strong>：元字符（如 <code>.</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>|</code>、<code>()</code>、<code>[]</code>、<code>&#123;&#125;</code>）有特殊含义。若要匹配这些字符本身，需要使用转义字符 <code>\</code>。例如，<code>\.</code> 匹配字符 <code>.</code>。</li>
<li><strong>字符类</strong>：使用方括号 <code>[]</code> 定义字符类，可以匹配其中任意一个字符。例如，<code>[abc]</code> 匹配 <code>a</code>、<code>b</code> 或 <code>c</code>。</li>
<li><strong>预定义字符类</strong>：常见的预定义字符类包括 <code>\d</code>（数字），<code>\w</code>（字母、数字或下划线），<code>\s</code>（空白字符），等价于 <code>[0-9]</code>、<code>[a-zA-Z0-9_]</code>、<code>[ \t\n\r\f\v]</code>。</li>
<li><strong>量词</strong>：量词用来指定匹配次数。例如，<code>*</code>（0 次或多次），<code>+</code>（1 次或多次），<code>?</code>（0 次或 1 次），<code>&#123;n&#125;</code>（恰好 n 次），<code>&#123;n,&#125;</code>（至少 n 次），<code>&#123;n,m&#125;</code>（n 到 m 次）。</li>
<li><strong>边界匹配</strong>：边界匹配符包括 <code>^</code>（行首），<code>$</code>（行尾），<code>\b</code>（单词边界），<code>\B</code>（非单词边界）。</li>
<li><strong>分组和捕获</strong>：使用圆括号 <code>()</code> 将正则表达式的一部分进行分组，可以进行捕获以便后续引用。例如，<code>(\d&#123;3&#125;)-(\d&#123;3&#125;)</code> 匹配 “123-456” 并捕获 “123” 和 “456”。</li>
<li><strong>选择和替代</strong>：使用管道符 <code>|</code> 表示选择，匹配左边或右边的表达式。例如，<code>a|b</code> 匹配 <code>a</code> 或 <code>b</code>。</li>
</ol>
<h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><ol>
<li><strong>编译</strong>：正则表达式首先被编译成一种内部表示形式。这个编译过程将解析正则表达式字符串，并将其转换为一个有限状态自动机（Finite State Machine, FSM）。</li>
<li><strong>匹配过程</strong>：<ul>
<li><strong>DFA（确定性有限自动机）</strong>：DFA 每个状态都有确定的转换，即每一个输入字符都会导致状态的唯一确定转换。DFA 的匹配过程效率高，但状态数可能较多。</li>
<li><strong>NFA（非确定性有限自动机）</strong>：NFA 允许从一个状态可以有多条转换边，匹配过程可能需要回溯。NFA 的构建比较简单，但匹配过程效率可能较低。</li>
</ul>
</li>
<li><strong>引擎</strong>：<ul>
<li><strong>NFA 引擎</strong>：基于回溯算法，尝试每一种可能的路径，直到找到匹配或失败。大多数现代正则表达式引擎（如 Perl、Python、JavaScript 等）使用 NFA 引擎。</li>
<li><strong>DFA 引擎</strong>：不使用回溯，直接通过状态转换进行匹配，通常速度较快，但实现较为复杂且内存消耗较大。</li>
</ul>
</li>
</ol>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li><strong>字符串查找和替换</strong>：在文本编辑器、IDE 等工具中，通过正则表达式进行复杂的搜索和替换操作。</li>
<li><strong>数据验证</strong>：验证输入数据的格式，如邮箱地址、电话号码等。</li>
<li><strong>文本处理</strong>：如日志解析、数据抽取等。</li>
</ul>
<p>通过对正则表达式的理解和应用，可以高效地进行字符串处理和模式匹配，极大地提高文本处理的灵活性和效率。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929153836955-1727921863704-1.png" alt="image-20240929153836955"></p>
<p>JS 正则表达式对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;^\\w&#123;6,12&#125;$&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^\w&#123;6,12&#125;$/</span></span><br><span class="line"></span><br><span class="line">regex.<span class="title function_">test</span>(str) <span class="comment">//正则表达式</span></span><br></pre></td></tr></table></figure>



<ul>
<li><code>\d</code>: 数字</li>
<li><code>\D</code>: 除了数字以外的字符</li>
<li><code>\s</code>:空白字符</li>
<li><code>\w</code>:字母+下划线+数字</li>
<li><code>[ ]</code>匹配单个字符 字符集合</li>
<li><code>[^1-3A-Z]</code>匹配一个除了1-3和大写字母的字符</li>
<li>尖角^只有在方框内部才是取反的意思。在外部表示匹配开头，<code>^abc</code>表示作为开头的abc，<code>BCD$</code>就是作为结尾的BCD<ul>
<li>匹配总共需要三个参数：要处理的字符串，匹配模式和正则表达式本身，可以看出处理的文本本身就是一个字符串。</li>
<li>如果没有多行匹配，^和$只会作用于<strong>整个文本</strong>的开头和结尾</li>
<li>multiline模式会匹配每一行</li>
</ul>
</li>
<li><code>/...../g</code>表示不要搜索一次就返回，去掉只显示第一个匹配的</li>
<li><code>/...../m</code>表示多行匹配</li>
<li><code>/...../i</code>表示忽略大小写</li>
<li><code>\b</code>:表示单词边界 <code>\bin</code>表示in在单词开头 <code>in\b</code>表示in在单词末尾</li>
<li><code>\B</code>:表示单词内部 <code>\Bin\B</code>表示in在单词中间 <code>\Bin</code>表示匹配前面有东西的in</li>
<li><code>.$</code>表示属于结尾的任意字符</li>
<li><code>\.$</code>表示属于结尾的点号</li>
</ul>
<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><ul>
<li><code>at+</code> atttt atttt 加号表示a t(重复一次或者多次)</li>
<li><code>at*</code> atttt atttt 星号表示a t(重复0次或者多次)</li>
<li><code>at?</code> at a 问号表示零次或者一次</li>
<li><code>at&#123;3,5&#125;</code> attt 表示t重复了3到5次</li>
<li><code>at&#123;3,&#125;</code> attt 表示t重复了3次以上 </li>
</ul>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul>
<li><code>(at)&#123;3&#125;</code> at整体重复了3次</li>
<li><code>(P|p)iece</code> Piece和piece</li>
<li><code>(d&#123;4&#125;)[-/_.](d&#123;1,2&#125;)[-/_.](d&#123;1,2&#125;)</code> 匹配年月日并且分成三组$1$2$3分别代表123组可以使用替换</li>
<li>如果不想分其中一个组<code>?:</code>表示仅代表一个整体不参与分组</li>
</ul>
<p>在 Java 的正则表达式中，如果你想忽略大小写匹配，可以使用以下几种方法：</p>
<h2 id="Java中忽略大小写的使用"><a href="#Java中忽略大小写的使用" class="headerlink" title="Java中忽略大小写的使用"></a>Java中忽略大小写的使用</h2><h3 id="使用-Pattern-CASE-INSENSITIVE-标志"><a href="#使用-Pattern-CASE-INSENSITIVE-标志" class="headerlink" title="使用 Pattern.CASE_INSENSITIVE 标志"></a>使用 <code>Pattern.CASE_INSENSITIVE</code> 标志</h3><p>通过调用 <code>Pattern.compile</code> 方法并传递 <code>Pattern.CASE_INSENSITIVE</code> 标志，可以忽略大小写。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译正则表达式时指定忽略大小写</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex, Pattern.CASE_INSENSITIVE);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(text);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-i-内联标志"><a href="#使用-i-内联标志" class="headerlink" title="使用 (?i) 内联标志"></a>使用 <code>(?i)</code> 内联标志</h3><p>在正则表达式的开头加上 <code>(?i)</code> 也可以忽略大小写。这是内联标志，不需要使用 <code>Pattern.compile</code>。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;(?i)hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (text.matches(regex)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>Pattern.CASE_INSENSITIVE</code></strong> 标志是在编译正则表达式时通过代码设置忽略大小写。</li>
<li><strong><code>(?i)</code></strong> 是在正则表达式内部直接指定忽略大小写，简单方便。</li>
</ul>
<h1 id="AJAX-JSON-个人笔记-Java-Web-服务端-pdf"><a href="#AJAX-JSON-个人笔记-Java-Web-服务端-pdf" class="headerlink" title="[AJAX, JSON](./个人笔记/Java Web 服务端.pdf)"></a>[AJAX, JSON](./个人笔记/Java Web 服务端.pdf)</h1><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/">Vue.js - 渐进式 JavaScript 框架 | Vue.js (vuejs.org)</a></p>
<h2 id="优点、原理"><a href="#优点、原理" class="headerlink" title="优点、原理"></a>优点、原理</h2><ul>
<li>免除DOM操作，简化书写</li>
<li>基于MVVM思想，双向绑定数据，使view能够绑定model的数据，而不是model变了</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929223353641.png" alt="image-20240929223353641"></p>
<p>model: plain JavaScript Objects     view: 模板</p>
<p>model，也就是数据，通过vue实例绑定到view上，model一更新，view上也会立即更新，</p>
<p>view，模板，通过vue实例的domListener，监听发生的dom事件，比如输入，通过listener将model处的数据实时更新。</p>
<p>数据全存在vm上，view能看到vm所有的数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929231110532.png" alt="image-20240929231110532"></p>
<p>在之前的JSON案例中，填写表单时，表单数据是model，<strong>在提交的时候</strong>，还要用<strong>繁琐的dom操作</strong>获取输入框中的值再赋给model。vue能在输入的时候就赋值给对象，如果从服务器接收到数据也能实时更新。</p>
<h2 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h2><p><a href=".%5C%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%5CHTML%5Cindex.html">index.html</a></p>
<p><strong>Vue3</strong> </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hello-vue&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>//div元素 唯一id为hello-vue 归属于demo类</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span>//v-model双向绑定,这个view中的值是多少, vue实例中数据就是多少</span><br><span class="line">&#123;&#123; message &#125;&#125;//插值表达式。这是 Vue.js 的模板语法，用于将 Vue 实例中的数据绑定到页面上。</span><br><span class="line">			 //vue实例中的数据变化时,这里也跟着变化。</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">HelloVueApp</span>=&#123; <span class="comment">//此处创建了一个自定义JS对象</span></span></span><br><span class="line"><span class="language-javascript">	<span class="title function_">data</span>(<span class="params"></span>)&#123;<span class="comment">//data是一个无参的函数,返回值是一个对象，里面包含了model数据</span></span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">message</span>: <span class="string">&#x27;Hello,Vue!&#x27;</span><span class="comment">//数据初值是Hello,Vue!字符串</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">	&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">HelloVueApp</span>).<span class="title function_">mount</span>(<span class="string">&quot;#hello-vue&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="comment">//Vue.createApp() 方法用于创建一个 Vue 应用实例，参数是一个包含组件选项的对象（这里是 HelloVueApp）。</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//.mount(&#x27;#hello-vue&#x27;) 方法将 Vue 应用实例挂载到页面中具有 id=&quot;hello-vue&quot; 的 DOM 元素上。</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令是带有前缀 <strong>v-</strong> 的特殊属性，用于在模板中表达逻辑。</p>
<p><strong>v-bind</strong>: 动态绑定一个或多个特性，或一个组件 prop。将 Vue 实例的数据绑定到 HTML 元素的属性上</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>简写：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-if</strong>: 条件渲染。根据表达式的值来条件性地渲染元素或组件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;seen&quot;</span>&gt;</span>Now you see me<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-for</strong>: 列表渲染。 用于根据数组或对象的属性值来循环渲染元素或组件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.text &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">//v-for=迭代对象 相当于增强for循环 </span><br><span class="line">//key帮助 Vue 在渲染列表时识别每个元素的唯一性。</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">HelloVueApp</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">items</span>: [ <span class="comment">//items数组包含多个匿名对象，这些匿名对象id和text两个属性</span></span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;Item 1&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&#x27;Item 2&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">text</span>: <span class="string">&#x27;Item 3&#x27;</span> &#125;</span></span><br><span class="line"><span class="language-javascript">      ]</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">HelloVueApp</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-model</strong>: 实现表单数据双向绑定：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;edit me&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-on</strong>: 事件监听器。 用于在 HTML 元素上绑定事件监听器，使其能够触发 Vue 实例中的方法或函数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>简写：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-show</strong>: 用于根据表达式的值来条件性地显示或隐藏元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hello-vue&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;showMessage = !showMessage&quot;</span>&gt;</span>显示/隐藏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">&quot;showMessage&quot;</span>&gt;</span>Hello Vue!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">HelloVueApp</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">showMessage</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">HelloVueApp</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#hello-vue&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>v-on指令能够监听事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">v-<span class="attr">on</span>:click=<span class="string">&quot;methodName&quot;</span></span><br><span class="line">@click=<span class="string">&quot;methodName&quot;</span></span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;counter += 1&quot;</span>&gt;</span>增加 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> app = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">counter</span>: <span class="number">0</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(app).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="案例简化-JavaScript中的this指针与回调函数"><a href="#案例简化-JavaScript中的this指针与回调函数" class="headerlink" title="案例简化-JavaScript中的this指针与回调函数"></a>案例简化-JavaScript中的this指针与回调函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//script</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">VueApp</span> = &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="attr">brands</span>:[]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">        axios.<span class="title function_">get</span>(<span class="string">&quot;http://localhost:8080/selectAllServlet&quot;</span>)</span><br><span class="line">         .<span class="title function_">then</span>(<span class="function">(<span class="params">resp</span>)=&gt;</span>&#123;<span class="variable language_">this</span>.<span class="property">brands</span> = resp.<span class="property">data</span>;&#125;);</span><br><span class="line">        <span class="comment">//brands是集合,用v-for遍历</span></span><br><span class="line">        <span class="comment">//回调函数是作为参数传递给另一个函数的函数，目的是在特定事件或条件发生时被调用。它通常用于异步操作、事件处理和在特定时机执行代码。箭头函数不会根据调用者创建this，只会寻找域中含有的this指针，mounted的this就是Vue实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">    	<span class="attr">show</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&quot;clicked&quot;</span>);<span class="comment">//跟提交的按钮绑定</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">createVueApp</span>(<span class="title class_">VueApp</span>).<span class="title function_">mount</span>(#app)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href=".%5C%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%5CHTML%5CanoymousThis.html">JavaScript中的this指针</a> 另外一种是在mounted中先定义一个var _this = this，这样_this 一定指代的是Vue实例</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>单个复选框：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checked&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>多个复选框：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;runoob&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Runoob&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;runoob&quot;</span>&gt;</span>Runoob<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;google&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Google&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;google&quot;</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;taobao&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Taobao&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;taobao&quot;</span>&gt;</span>taobao<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>选择的值为: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> app = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      checked : <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">checkedNames</span>: []</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(app).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h1><p><a target="_blank" rel="noopener" href="https://element.eleme.cn/#/zh-CN">Element - 网站快速成型工具</a></p>
<p>Vue组件库，可以快速构建网页</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930212139910.png" alt="image-20240930212139910"></p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930224145033.png" alt="image-20240930224145033"></p>
<h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930224317166.png" alt="image-20240930224317166"></p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930224538591.png" alt="image-20240930224538591"></p>
<p>对话框+表单</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/05/java-web-backend/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/05/java-web-backend/" class="post-title-link" itemprop="url">Web 后端 Java</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-05 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-05T00:00:00+08:00">2024-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:49:42" itemprop="dateModified" datetime="2025-05-05T11:49:42+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web-development/" itemprop="url" rel="index"><span itemprop="name">web development</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p><strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol </p>
<p>TCPIP协议四层架构的最上层 规定了服务器和浏览器之间传输数据的规则</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP">HTTP | MDN (mozilla.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">超文本传输协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>基于TCP，面向连接，安全</li>
<li>基于请求-响应模型：1Request 1Response</li>
<li>HTTP是无状态协议，对事务处理没有记忆能力，每次RR都是独立的<ul>
<li>多次请求之间不能共享数据，java用会话技术（cookie session）解决这个问题</li>
<li>优点：速度快</li>
</ul>
</li>
</ul>
<h2 id="请求数据格式"><a href="#请求数据格式" class="headerlink" title="请求数据格式"></a><a href="#request">请求数据格式</a></h2><p><strong>请求行</strong>：第一行，<code>GET</code>(请求方式) 后面的<code>/</code>表示请求资源的路径，HTTP/1.1表示协议版本</p>
<p><strong>请求头</strong>：第二行开始 key: value形式</p>
<p><strong>请求体</strong>：POST请求的最后一部分，存放请求参数</p>
<p>GET请求参数在请求行中，没有请求体，参数大小有限制(URL长度限制) POST请求的参数在请求体中，参数大小无限制</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926220614547.png" alt="image-20240926220614547"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926221417729.png" alt="image-20240926221417729"></p>
<p><strong>Host</strong>: 请求的主机名</p>
<p><strong>User-Agent</strong>: 浏览器版本</p>
<p><strong>Accept</strong>: 浏览器能接受的资源类型，如text/* image/* */* </p>
<p><strong>Accept-Language</strong>: 浏览器的偏好语言</p>
<p><strong>Accept-Encoding</strong>: 浏览器支持的压缩类型</p>
<h2 id="响应数据格式"><a href="#响应数据格式" class="headerlink" title="响应数据格式"></a>响应数据格式</h2><p><strong>响应行</strong>：响应数据的第一行，HTTP/1.1表示协议版本，下一个是响应状态码，OK表示状态码描述</p>
<p><strong>响应头</strong>：keyvalue</p>
<p><strong>响应体</strong>：最后一部分，存放响应数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926221630980.png" alt="image-20240926221630980"></p>
<p><strong>Content-Type</strong>：响应内容类型，比如text/html image/jpeg</p>
<p><strong>Content-Length</strong>：响应内容长度（bytes）</p>
<p><strong>Content-Encoding</strong>：响应压缩算法 gzip等</p>
<p><strong>Cache-Control</strong>: 指示客户端如何缓存，例如max-age=300 表示最多缓存300s</p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926222005460.png" alt="image-20240926222005460"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926222320894.png" alt="image-20240926222320894"></p>
<p>200 OK 404资源不存在 500 服务器异常</p>
<p>Java程序中，如果直接用自带的javawebsocketAPI 代码会变得异常繁琐，要注意请求和响应的格式要求，因此要用web服务器软件进行开发—-Tomcat</p>
<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>Apache Tomcat web服务器是一个应用程序，封装http协议，不用对协议进行直接操作。类似的还有jetty，weblogic，ibm webSphere，部署web项目到服务器中</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61596145">JavaEE的13种核心技术规范： - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://tomcat.apache.org/">Apache Tomcat® - Welcome!</a> </p>
<h2 id="创建Web项目"><a href="#创建Web项目" class="headerlink" title="创建Web项目"></a>创建Web项目</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927151450747.png" alt="image-20240927151450747"></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Web-&gt;META-INF()</span><br><span class="line">     WEB-INF -&gt;classes(java文件夹和resources文件夹合并)</span><br><span class="line">     	     -&gt;lib(依赖jar包)</span><br><span class="line">             -&gt;web.xml(web项目的配置文件)</span><br><span class="line">     webapp中除了WEB-INF的其他文件</span><br></pre></td></tr></table></figure>



<p>using 骨架</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927151529348.png" alt="image-20240927151529348"></p>
<p>packaging 默认jar 改成web项目用的war </p>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>动态资源web开发技术</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927162801770.png" alt="image-20240927162801770"></p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927163054997.png" alt="image-20240927163054997"></p>
<p>servlet对象，service方法由web服务器tomcat创建</p>
<p>WebServlet继承了Servlet接口</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927174147654.png" alt="image-20240927174147654"></p>
<ol>
<li>默认情况 servlet对象第一次被访问就被创建，通过改变loadOnStartup参数可以改变优先级</li>
<li>容器（tomcat）通过init方法初始化对象，只需要调用一次</li>
<li>每次请求servlet 容器都会调用servlet的service方法</li>
</ol>
<h2 id="Servlet-接口"><a href="#Servlet-接口" class="headerlink" title="Servlet 接口"></a>Servlet 接口</h2><p>定义了五个抽象方法：</p>
<ol>
<li><p><code>init(ServletConfig conf)</code>：默认情况下，servlet第一次被访问，容器创建servlet对象时，会调用init，只调用一次。改变WebServlet注解的参数loadOnStartup，可以控制在创建服务器的时候就创建servlet对象。</p>
</li>
<li><p><code>service(ServletRequest req,ServletResponse res)</code>: 每一次访问servlet就调用一次</p>
</li>
<li><p><code>destroy()</code>: 内存释放、服务器关闭时调用，只有一次</p>
</li>
<li><p><code>ServletConfig getServletConfig()</code>: servletconfig是容器调用init方法传进来的参数,可以在demo类中声明一个config成员变量，在init中赋值，然后在getConfig方法中返回</p>
</li>
<li><p><code>String getServletInfo() </code>: copyright information</p>
</li>
</ol>
<h2 id="Servlet-体系"><a href="#Servlet-体系" class="headerlink" title="Servlet 体系"></a>Servlet 体系</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927180225035.png" alt="image-20240927180225035"></p>
<p>Http doGet doPost</p>
<p>根据请求方式的不同分别处理，因为get的参数在请求行中，post的参数在请求体中。</p>
<p>httpservlet是servlet的实现类，实际上把service方法重写，接收请求参数req，如果req中是get方式，就执行doGet，如果是post就执行doPost  子类只需要重写doGetdoPost方法即可</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927181319844.png" alt="image-20240927181319844"></p>
<p>源码分析：原来的service方法重载，参数变成httpservletrequest和httpservletresponse ，原版的请求参数传进来，强制转换成httpservletrequest，然后吊用自己写好的重载service方法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927181753064.png" alt="image-20240927181753064"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927181825881.png" alt="image-20240927181825881"></p>
<h2 id="urlPattern"><a href="#urlPattern" class="headerlink" title="urlPattern"></a>urlPattern</h2><h3 id="一个servlet可以配置多个访问路径"><a href="#一个servlet可以配置多个访问路径" class="headerlink" title="一个servlet可以配置多个访问路径"></a>一个servlet可以配置多个访问路径</h3><p>urlPatterns = {“”,””}</p>
<h3 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927183113407.png" alt="image-20240927183113407"></p>
<ol>
<li>精确匹配 （优先级比目录匹配高）</li>
<li>目录匹配，通配符</li>
<li>扩展名匹配，<code>*.do</code> <code>aaa.do bbb.do</code>都可以访问，注意不能有斜杠</li>
<li>任意匹配，<code>/</code>优先级低于<code>/*</code><ul>
<li>/是tomcat默认生成的一个servlet，启动以后自动创建，是用来访问静态资源的</li>
<li>很危险，不要用</li>
</ul>
</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927183710215.png" alt="image-20240927183710215"></p>
<h3 id="web-xml配置"><a href="#web-xml配置" class="headerlink" title="web.xml配置"></a>web.xml配置</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927183912074.png" alt="image-20240927183912074"></p>
<h1 id="Request-amp-Response"><a href="#Request-amp-Response" class="headerlink" title="Request&amp;Response"></a>Request&amp;Response</h1><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927184223066.png" alt="image-20240927184223066"></p>
<p>request 获取请求数据</p>
<p>response 设置响应时的数据</p>
<p>request中含有用户输入的参数，response可以根据这个参数设置响应的数据，这样就完成了和用户交互的基本过程</p>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><h3 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927184637027.png" alt="image-20240927184637027"></p>
<p>ServletRequest和HttpServletRequest都是接口，不能实例化，定义了一些抽象方法作为规范。</p>
<p>我们的 servlet 重写了 service()方法的方法体，浏览器访问时，tomcat就要调用servlet的service方法。tomcat作为servlet容器，<strong>要解析请求报文，将其封装成req对象</strong>，送到servlet的service方法处作为参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是tomcat的程序</span></span><br><span class="line"><span class="comment">//tomcat做的是解析报文封装请求的操作，具体如何利用请求做出什么样的响应，则是开发者的工作</span></span><br><span class="line"><span class="type">MyServlet</span> <span class="variable">myServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyServlet</span>();</span><br><span class="line">myServlet.init()<span class="comment">//开发者重写</span></span><br><span class="line">myServlet.service(req,res)<span class="comment">//开发者重写</span></span><br></pre></td></tr></table></figure>

<p>所以Tomcat对接口进行了实现，查J2EE API</p>
<h3 id="获取请求数据"><a href="#获取请求数据" class="headerlink" title="获取请求数据"></a>获取请求数据</h3><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927192106826.png" alt="image-20240927192106826"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927192310996.png" alt="image-20240927192310996"></p>
<h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927192340229.png" alt="image-20240927192340229"></p>
<p>getHeader根据name来获取对应的信息</p>
<p>getHeader(“User-Agent”) 输出Mozilla/5.0 Chrome/91.0.4472.106</p>
<h4 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927192426370.png" alt="image-20240927192426370"></p>
<p>统一获取请求参数的方式？从而统一doGet和doPost方法内的代码</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927195026912.png" alt="image-20240927195026912"></p>
<p>getParameterMap 获取参数map 结构如上</p>
<p>getParameter 根据名称获取参数值</p>
<p>getParameterValues 根据名称获取参数值</p>
<h4 id="获取参数中文乱码"><a href="#获取参数中文乱码" class="headerlink" title="获取参数中文乱码"></a>获取参数中文乱码</h4><h5 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h5><p>设置输入流的字符集</p>
<p>底层是获取字符输入流BufferReader，所以<code>setCharacterEncoding(&quot;UTF-8&quot;)</code></p>
<h5 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h5><p>底层是字符串形式</p>
<p>浏览器发出请求的时候，会把中文字符转成URL编码，tomcat需要进行URL解码</p>
<h5 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h5><p>字符串按照编码方式转为二进制，每个字节转换为两个十六进制数，在前面加上%                                            </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927214608765.png" alt="image-20240927214608765"></p>
<p>Tomcat底层将URL编码 解码为ISO-8859-1</p>
<h3 id="Forward-请求转发"><a href="#Forward-请求转发" class="headerlink" title="Forward 请求转发"></a>Forward 请求转发</h3><p>服务器内部资源跳转方式，转发的资源之间共享数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928140710653.png" alt="image-20240928140710653"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928140736371.png" alt="image-20240928140736371"></p>
<p>请求内部有参数（map形式），来源URL等信息</p>
<ul>
<li><code>setAttribute(String name, Object o)</code>把数据o 存到request域中，以key为键    </li>
<li><code>removeAttribute(String name)</code> 根据key删除键值对</li>
<li><code>Object getAttribute(String name)</code>根据key获取数据</li>
</ul>
<ul>
<li>地址栏路径不发生变化；</li>
<li>只能转发到服务器内部的资源；</li>
<li>浏览器发送一次请求，多个资源共享request数据</li>
<li>高效率</li>
</ul>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928142749615.png" alt="image-20240928142749615"></p>
<h3 id="设置响应数据"><a href="#设置响应数据" class="headerlink" title="设置响应数据"></a>设置响应数据</h3><ol>
<li>响应行：设置状态码</li>
<li>响应头：设置键值对</li>
<li>响应体：通过输出流输出数据</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928142944677.png" alt="image-20240928142944677"></p>
<h3 id="Redirect-重定向"><a href="#Redirect-重定向" class="headerlink" title="Redirect 重定向"></a>Redirect 重定向</h3><p>资源跳转方式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928143039892.png" alt="image-20240928143039892"></p>
<p>状态码 <strong>302</strong> 响应头：location: 虚拟目录/demo6</p>
<p><code>sendRedirect(String url)</code>发送重定向响应</p>
<p><code>setStatus(302)</code> </p>
<p><code>setHeader(&quot;location&quot;,&quot;https://www.google.com&quot;)</code> </p>
<p><code>setHeader(&quot;Content-type&quot;,&quot;text/html&quot;)</code> </p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>地址栏路径发生变化；</li>
<li>转发任意资源；</li>
<li>浏览器发送两次请求，不能在多个资源用request共享数据</li>
<li>效率低</li>
</ul>
<h4 id="路径问题-动态获取虚拟目录"><a href="#路径问题-动态获取虚拟目录" class="headerlink" title="路径问题 动态获取虚拟目录"></a>路径问题 动态获取虚拟目录</h4><p>如果浏览器使用，需要加虚拟目录</p>
<p>服务端使用就不需要加了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928145151848.png" alt="image-20240928145151848"></p>
<p>虚拟目录可以动态变化，所以尽量减少硬编码，减少耦合性</p>
<p>可以用<code>request</code>的<code>getContextPath()</code> 获取虚拟目录</p>
<h3 id="设置响应数据-1"><a href="#设置响应数据-1" class="headerlink" title="设置响应数据"></a>设置响应数据</h3><h4 id="字符数据"><a href="#字符数据" class="headerlink" title="字符数据"></a>字符数据</h4><p><code>getWriter().write(String s) </code>写入数据到资源中</p>
<p><code>setContentType(&quot;text/html;charset=utf-8&quot;)</code>   </p>
<p>细节：不用关闭流</p>
<p>乱码可以用响应头设置编码，tomcat8不乱码</p>
<h4 id="字节数据"><a href="#字节数据" class="headerlink" title="字节数据"></a>字节数据</h4><p>ServletOutputStream = request.getOutputStream()</p>
<h2 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h2><p>用来创建与数据库的连接会话,只需要一个即可，所以运用单例的设计模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryUtils</span>&#123;</span><br><span class="line">    SqlSessionFactory factory;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">    SqlSessionFactory <span class="title function_">getSqlSessionFactory</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h2 id="入门-1"><a href="#入门-1" class="headerlink" title="入门"></a>入门</h2><p>Java Server Pages 静态的页面嵌入动态的代码 简化开发</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928175143005.png" alt="image-20240928175143005"></p>
<p>JSP本质是servlet，把写标签等繁琐的工作交给jsp技术</p>
<h3 id="JSP脚本"><a href="#JSP脚本" class="headerlink" title="JSP脚本"></a>JSP脚本</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928175642020.png" alt="image-20240928175642020"></p>
<ol>
<li><p>service方法是访问到这个资源的时候调用</p>
</li>
<li><p>out.print() 是printWriter 调用的</p>
</li>
<li><p>被生成的jsp类直接包含</p>
</li>
</ol>
<p>截断java代码，中间插入html标签是可以的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928180319108.png" alt="image-20240928180319108"></p>
<p>出现HTML标签的地方可以理解为java程序代替你输入这些标签，最简单的字面意义上的代替功能，因此截断也没什么关系</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928180738621.png" alt="image-20240928180738621"></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928180843640.png" alt="image-20240928180843640"></p>
<h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928181558853.png" alt="image-20240928181558853"></p>
<h2 id="JSTL-标签库"><a href="#JSTL-标签库" class="headerlink" title="JSTL 标签库"></a>JSTL 标签库</h2><p><mark><strong>#{}</strong><mark></p>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928182101658.png" alt="image-20240928182101658"></p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928182210315.png" alt="image-20240928182210315"></p>
<p>brand.id 不是访问成员变量，是要调用get方法</p>
<p>自动调用getId()</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928182800258.png" alt="image-20240928182800258"></p>
<p>varStatus 计数器</p>
<p>status.count是计数从1开始，status.index是从1开始</p>
<h4 id="普通for循环"><a href="#普通for循环" class="headerlink" title="普通for循环"></a>普通for循环</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928183033816.png" alt="image-20240928183033816"></p>
<p>Java虚拟机负责存储变量信息，jsp只负责展示与变量相关的信息，因此不用重启服务器，</p>
<h2 id="Servlet-JSP开发"><a href="#Servlet-JSP开发" class="headerlink" title="Servlet+JSP开发"></a>Servlet+JSP开发</h2><p><strong>业务逻辑层</strong>本质上是对dao层的封装，包括创建session，创建mapper，mapper调用dao方法，事务等。</p>
<p>每个servlet都是资源，浏览器能够通过网址或者表单的形式发出请求，servlet根据request的参数进行一系列业务逻辑操作，将返回的结果转发给jsp页面。</p>
<p>jsp本质也是一个servlet，将请求中的参数打印出来的同时还能生成html标签，浏览器就能通过html标签解析出网页。</p>
<p>在修改页面改了一个数据，提交表单到updateServlet，updateServlet进行业务操作，完成后，把包含参数的请求转发到 浏览所有数据 的showAll.jsp页面，jsp本质是servlet，负责打印标签和数据。</p>
<h1 id="MVC-设计模式"><a href="#MVC-设计模式" class="headerlink" title="MVC 设计模式"></a>MVC 设计模式</h1><p><strong>Model</strong>：接受Controller发出的指令，与数据库交互，增删改查，返回数据给Controller</p>
<p><strong>View</strong>：接受Controller发出的数据（Model给的）渲染页面，返回HTML页面给Controller</p>
<p><strong>Controller</strong>：接受客户端的数据请求，返回给客户端HTML页面，同时与model和view交流，充当Model和View之间的桥梁。</p>
<p>Model和View之间一个是处理数据，一个是呈现数据，二者可以专注于各自的事情</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240919202449018-1727923726251-1.png" alt="image-20240919202449018"></p>
<p>Servlet controller </p>
<p>JSP View </p>
<p>JavaBean Model </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928183538077-1727923726251-2.png" alt="image-20240928183538077"></p>
<p>三层架构</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928183903472-1727923726251-3.png" alt="image-20240928183903472"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928183924963-1727923726251-4.png" alt="image-20240928183924963"></p>
<h1 id="Cookie-amp-Session-amp-JWT"><a href="#Cookie-amp-Session-amp-JWT" class="headerlink" title="Cookie&amp;Session&amp;JWT"></a>Cookie&amp;Session&amp;JWT</h1><h2 id="会话跟踪技术"><a href="#会话跟踪技术" class="headerlink" title="会话跟踪技术"></a>会话跟踪技术</h2><p>浏览器打开一个网站就是会话建立的过程，其中可以<strong>包含多次请求和响应</strong>，服务段需要区分不同的会话，判断多次请求是否来自统一浏览器，以便在同一次会话的<strong>多次请求之间，共享数据。</strong></p>
<p><strong>HTTP协议是无状态</strong>的，为了最佳的请求响应效率，牺牲了存储记忆数据的功能，每次请求都被视作新的请求，因此要跟踪回话实现会话内数据共享。</p>
<p>本质是将数据存储在一端</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928201532521.png" alt="image-20240928201532521"></p>
<p>客户端：<strong>Cookie</strong> </p>
<p>服务端：<strong>Session</strong> </p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>客户端的会话技术，保存数据到客户端，每次请求都携带cookie数据进行访问。客户端的记忆</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928202227465.png" alt="image-20240928202227465"></p>
<p>响应的时候setcookie，请求的时候带着cookie</p>
<h3 id="发送cookie"><a href="#发送cookie" class="headerlink" title="发送cookie"></a>发送cookie</h3><p>创建Cookie，设置键值对</p>
<p>response调用addCookie方法发送cookie</p>
<h3 id="获取cookie"><a href="#获取cookie" class="headerlink" title="获取cookie"></a>获取cookie</h3><p>request对象调用getCookies 接收cookies</p>
<p>for循环遍历，getName和getValue</p>
<h2 id="cookie的原理"><a href="#cookie的原理" class="headerlink" title="cookie的原理"></a>cookie的原理</h2><p><strong>基于HTTP协议</strong></p>
<p>响应的时候，做好cookie传回去，<strong>响应头</strong>setCookie:username=zs</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928204006874.png" alt="image-20240928204006874"></p>
<p>浏览器再次请求的时候，<strong>请求头</strong>中cookie:username=zs</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928204020606.png" alt="image-20240928204020606"></p>
<h3 id="cookie使用细节"><a href="#cookie使用细节" class="headerlink" title="cookie使用细节"></a>cookie使用细节</h3><h4 id="存活时间"><a href="#存活时间" class="headerlink" title="存活时间"></a>存活时间</h4><p><strong>默认</strong>存储在浏览器内存中，关闭浏览器会释放内存，销毁cookie</p>
<p>setMaxAge(int seconds) 正数：写入浏览器硬盘，到时间自动删除；负数：写入内存，自动销毁；零：删除对应cookie</p>
<p>30天内免登录</p>
<p>cookie是键值对 </p>
<h4 id="cookie存储中文"><a href="#cookie存储中文" class="headerlink" title="cookie存储中文"></a>cookie存储中文</h4><p>可以把字符串用URL编码</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928205018701.png" alt="image-20240928205018701"></p>
<p>服务端的记忆功能</p>
<p>request.getSession();</p>
<p>set Attribute 存到session域中</p>
<p>get Attribute</p>
<p>session是键值对集合，存储在服务器</p>
<p><strong>Session基于Cookie实现</strong> </p>
<p>如何保证多个浏览器不是同一个session？发送一个sessionID的cookie，作为唯一标识，浏览器请求的时候会带着cookie。响应的时候创建一个session，把浏览器唯一对应的session对象id作为cookie发过去，再次请求的时候带着sessionid作为cookie就能找到对应的session对象去存储</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928210309806.png" alt="image-20240928210309806"></p>
<p>识别sessionid如果已经创建过了就不再创建</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928210431476.png" alt="image-20240928210431476"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928210448553.png" alt="image-20240928210448553"></p>
<h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><h4 id="session-钝化、活化"><a href="#session-钝化、活化" class="headerlink" title="session 钝化、活化"></a>session 钝化、活化</h4><p>钝化：服务器正常关闭，tomcat自动把session存到硬盘</p>
<p>活化：服务器开启，从session文件读取</p>
<p>浏览器关闭后中断会话，session不是同一个</p>
<h4 id="session-销毁"><a href="#session-销毁" class="headerlink" title="session 销毁"></a>session 销毁</h4><ul>
<li>自动销毁web.xml sessionconfig 时间默认为30分钟</li>
<li>手动销毁：登出</li>
</ul>
<h2 id="Cookie-vs-Session"><a href="#Cookie-vs-Session" class="headerlink" title="Cookie vs. Session"></a>Cookie vs. Session</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928220229036.png" alt="image-20240928220229036"></p>
<p>安全性，长期存储</p>
<p>cookie保证用户在未登录情况下的身份识别</p>
<p>session存储用户登录以后的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928225946421.png" alt="image-20240928225946421"></p>
<h3 id="登录系统DEMO"><a href="#登录系统DEMO" class="headerlink" title="登录系统DEMO:"></a>登录系统DEMO:</h3><p>login.jsp页面</p>
<p>登录成功存储用户信息，并且要重定向到另一个brand.jsp页面，两次会话共享信息，考虑安全性，session</p>
<p>登录失败，转发回登录页面，把错误 信息加进request域中，jsp登录页面显示的是错误信息</p>
<p>记住用户登录信息：登录成功并且勾选了复选框（发送复选框的value参数，Object.equals或是”1”.equals（remember））创建username和password的cookie并发送到浏览器。修改login.jsp：拿到请求中的cookies，分别把响应的数据填到页面的username和password中。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928223745507.png" alt="image-20240928223745507"></p>
<h3 id="用户注册DEMO"><a href="#用户注册DEMO" class="headerlink" title="用户注册DEMO:"></a>用户注册DEMO:</h3><p>reg.jsp </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928223916558.png" alt="image-20240928223916558"></p>
<p>if(布尔表达式){</p>
<p>}</p>
<p>return 布尔表达式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928231442349.png" alt="image-20240928231442349"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928231455396.png" alt="image-20240928231455396"></p>
<p>展示验证码：servlet输出的验证码作为img src显示在HTML静态页面上，写js脚本把点击事件设置成重新请求一次，每次请求的路径不同 (?号后面加时间)，防止浏览器缓存</p>
<p>生成验证码和提交注册表单一共需要两次请求，是不同的servlet在处理，所以服务器要在生成的时候将验证码存到session中，提交注册表单的时候再次从session中访问数据看是否一致。存到cookie中会直接被抓取然后攻击，失去了验证码的功能</p>
<p>if else if直接return就不用else了</p>
<p>checkcodeServlet 生成code，输出到自己的输出流中  </p>
<h2 id="Token-Json-Web-Token"><a href="#Token-Json-Web-Token" class="headerlink" title="Token(Json Web Token)"></a>Token(<u>J</u>son <u>W</u>eb <u>T</u>oken)</h2><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/995894#comment">JWT详细讲解(保姆级教程)-阿里云开发者社区 (aliyun.com)</a></p>
<h3 id="token-cookie-session"><a href="#token-cookie-session" class="headerlink" title="token cookie session"></a>token cookie session</h3><h4 id="Cookie-1"><a href="#Cookie-1" class="headerlink" title="Cookie"></a>Cookie</h4><p>本质是键值对，客户端发起请求，服务端响应会把包含着用户信息的set-cookie 加入响应头，客户端收到set-cookie，下次发送请求，请求头中会带着包含相同内容的cookie，服务端只需要根据cookie响应对应用户的资源。</p>
<p>局限：数据直接存放在浏览器端内存，安全性差，</p>
<p>优化：把set-cookie内容除了正常的cookie内容再加一段报文鉴别码，使用服务器自己的私钥进行签名，</p>
<p>优点：存储期限长</p>
<h4 id="Session-1"><a href="#Session-1" class="headerlink" title="Session"></a>Session</h4><p>以cookie为基础，本质是一个对象，每个session可以通过唯一的sessionID进行访问，客户端发起请求，服务端会把包含着sessionID信息的set-cookie响应给客户端，客户端下次发送请求，请求头中会带着包含着sessionID信息的cookie，服务端根据sessionID找到对应的session，响应对应用户的资源</p>
<p>优点：数据完全存储在服务端内存，安全性很高，</p>
<p>缺点：</p>
<p>最重要的是，session只支持单体服务器，session拷贝效率低，</p>
<p>默认不支持跨域名，但是不同域名可能是会共享用户信息的，</p>
<p>因此在集群部署，分布式应用，前后端分离的背景下，session已经不再适用</p>
<h4 id="JsonWebToken"><a href="#JsonWebToken" class="headerlink" title="JsonWebToken"></a>JsonWebToken</h4><p>base64: 将原来的字符串二进制化，然后重新分成每6位一组，6位对应有64个索引，分别对应0-9和所有大小写英文字母</p>
<p>用户信息保存在浏览器端内存，本质就是一条加密字符串。</p>
<h5 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h5><p>RSA—单向陷门函数：加密数字5，公钥是7,33 ，<strong>5</strong>^7^ mod 33 = <mark>14<mark>，解密使用公钥，x^7^ mod 33 = <mark>14<mark> 的数字有无数个，也就无法推算出具体的x，只能穷举。如果有了私钥3,33，<mark>14<mark>^3^ mod 33 = <strong>5</strong> 很容易就能算出原数字5</p>
<p>加密和解密都用同一种算法，但不是逆向。</p>
<p><strong>签名算法：</strong> </p>
<p>HS256：$A+H(A,K)$ 签发和验证都使用同一个密钥，只适用于单体应用。H表示密钥拼接在报文后进行哈希。S表示SHA256</p>
<p>RS256, ES256：$A+D(H(A))$ 签发用私钥，验证用公钥，适合分布式架构，安全性更高。R,E分别表示RSA与ECDSA，S表示SHA256。</p>
<h5 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h5><p>header(base64-encoded).payload(base64-encoded).signature(HMACSHA256-encoded)</p>
<ul>
<li>header 用于定义token类型以及加密算法（非对称），用base64编码，相当于明文</li>
<li>payload 用于装载要传输的用户数据，用base64编码，相当于明文<ul>
<li>附加一些预定义声明</li>
<li>iss: 签发者issuer</li>
<li>sub: jwt所面向的用户subject</li>
<li>aud: 接收jwt的一方audience</li>
<li>iat: jwt的签发时间 issued at</li>
<li>exp: jwt的过期时间，必须大于签发时间  expire</li>
<li>nbf: 定义在什么时间之前，该jwt都是不可用的. not valid before</li>
<li>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击 jwtid</li>
</ul>
</li>
</ul>
<p><code>注意:对于已签名的Token，这些信息虽然受到保护，不会被篡改，但任何人都可以阅读。除非加密，否则不要将机密信息放在 JWT 的有效负载或头元素中。</code> </p>
<ul>
<li>signature = HS256…(header(base64)+payload(base64)+secret)私钥 ，用header指定的算法进行加密，鉴权核心</li>
</ul>
<p>用户请求通过鉴权成功，<strong>服务端通过私钥签发JWT字符串</strong>，通过响应返回给用户，用户后续请求会在请求头中添加一个authorization:token的键值对。</p>
<p>再次请求，鉴权成功，然后将JWT根据secret进行解密，验证此JWT是否有效。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241030152447734.png" alt="image-20241030152447734"></p>
<p>假如其他人偶然间拿到了JWT，然后篡改JWT，服务器拿私钥解密JWT，会发现信息被篡改。</p>
<h1 id="Filter-amp-Listener"><a href="#Filter-amp-Listener" class="headerlink" title="Filter&amp;Listener"></a>Filter&amp;Listener</h1><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>拦截资源请求</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928234937677.png" alt="image-20240928234937677"></p>
<h3 id="入门-2"><a href="#入门-2" class="headerlink" title="入门"></a>入门</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928235049041.png" alt="image-20240928235049041"></p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929000311150.png" alt="image-20240929000311150"></p>
<p>先访问完资源，然后执行放行后的逻辑</p>
<p>放行前对request进行处理，放行后对response进行处理</p>
<h3 id="使用细节-1"><a href="#使用细节-1" class="headerlink" title="使用细节"></a>使用细节</h3><h4 id="拦截路径"><a href="#拦截路径" class="headerlink" title="拦截路径"></a>拦截路径</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929000603427.png" alt="image-20240929000603427"></p>
<p>拦截的是具体的资源，不是说filter访问哪个路径</p>
<h4 id="Filter链"><a href="#Filter链" class="headerlink" title="Filter链"></a>Filter链</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929000822547.png" alt="image-20240929000822547"></p>
<p>执行顺序：类名字符串自然排序</p>
<h4 id="案例：登录验证才可以访问"><a href="#案例：登录验证才可以访问" class="headerlink" title="案例：登录验证才可以访问"></a>案例：登录验证才可以访问</h4><p>第一次请求，没有登录，跳转到登录页面</p>
<p>filter要看是否登录，登录成功就把username pswd存到客户端session中，下一次请求的时候就验证session是否有值，没有值就继续</p>
<p>从服务端获取用户的session，session存储登录密码，如果session</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929011626311.png" alt="image-20240929011626311"></p>
<p>针对某个资源设置filter，第一次访问被拒绝，<strong>转发</strong>到login页面，此时网址不会变化，就会把这个资源的网址缓存成login页面的样式，login成功以后如果再次访问这个资源，会展示login页面，只有刷新一下才能解决这个问题</p>
<h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929121700747.png" alt="image-20240929121700747"></p>
<h1 id="HTML-CSS-JavaScript"><a href="#HTML-CSS-JavaScript" class="headerlink" title="HTML+CSS+JavaScript"></a>HTML+CSS+JavaScript</h1><h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a><span id=ajax>AJAX</span></h1><p>异步JS和XML <strong>A</strong>synchronous <strong>J</strong>avaScript <strong>A</strong>nd <strong>X</strong>ML </p>
<p><strong>AJAX作用1：与服务器交换数据，前后端分离</strong></p>
<ul>
<li>Servlet+JSP开发：HTML是静态的，要想展示动态的数据必须要让servlet根据请求中的参数来手动打印页面（JSP），服务端负担较重</li>
<li>AJAX+HTML: 替换JSP页面 ，AJAX给服务器<strong>发送请求</strong>，<strong>获取服务器响应</strong>的数据，展示给浏览器</li>
</ul>
<p><strong>AJAX作用2：异步交互</strong></p>
<p>不刷新<strong>整个页</strong>面也能与服务器交换数据，更新部分网页，如搜索联想，用户名是否可用校验</p>
<p>用户名按照一定的规则：直接本地编写js脚本即可，如果用户名不能和已有的重复，还应该发送请求，接收服务器响应回来的结果（数据库中是否重名）</p>
<h2 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929161209624.png" alt="image-20240929161209624"></p>
<p>异步操作使 用户可以在等待响应的同时继续与页面互动，这使得应用程序更具响应性</p>
<p>不用刷新整个页面，只跟服务器请求需要的数据，而不是整个页面，AJAX可以减少服务器的负担和网络流量，提高响应速度。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929161455819.png" alt="image-20240929161455819"></p>
<p>URL 全路径，前后端完全分离</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929161832460.png" alt="image-20240929161832460"></p>
<h2 id="异步请求案例"><a href="#异步请求案例" class="headerlink" title="异步请求案例"></a><span id="request">异步请求案例</span></h2><p>现在有这样一个需求，在浏览器填完了一个用户名，要把用户名发送到服务器的某个servlet，servlet根据用户名查询是否重复，并把数据传回到浏览器。</p>
<p>首先应该让失焦事件绑定函数，函数中要查询用户名。</p>
<p>设置 提示重复字句的style属性为不可见（正常情况下不可见）ajax根据传回的数据为true or false，改变 提示重复字句的style属性，如果是，则设置可见，如果否，则设置不可见。</p>
<p>具体流程？可以通过以下步骤：</p>
<h2 id="前端发送请求"><a href="#前端发送请求" class="headerlink" title="前端发送请求"></a>前端发送请求</h2><p>使用 JavaScript（比如 <code>XMLHttpRequest</code> 或 Fetch API）发送请求：</p>
<ul>
<li><strong>GET 方法</strong>（URL 参数字符串）：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>).<span class="property">value</span>;</span><br><span class="line">xhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://example.com/checkUsername?username=&quot;</span> + <span class="built_in">encodeURIComponent</span>(username));</span><br><span class="line">xhttp.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>POST 方法</strong>（请求体）：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>).<span class="property">value</span>;</span><br><span class="line">xhttp.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;http://example.com/checkUsername&quot;</span>);</span><br><span class="line">xhttp.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">xhttp.<span class="title function_">send</span>(<span class="string">&quot;username=&quot;</span> + <span class="built_in">encodeURIComponent</span>(username));</span><br></pre></td></tr></table></figure>

<h3 id="服务器端处理"><a href="#服务器端处理" class="headerlink" title="服务器端处理"></a>服务器端处理</h3><p>在 Servlet 中处理请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="comment">// 查询数据库检查用户名是否重复</span></span><br><span class="line">    <span class="comment">// 返回结果到浏览器</span></span><br><span class="line">    response.setPatameter...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    doGet(request,response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h3><ul>
<li><strong>GET</strong>：参数通过 URL 传递，适合获取数据，但不适合传递敏感信息，因为 URL 可见，且请求长度有限。</li>
<li><strong>POST</strong>：参数通过请求体传递，适合发送大量数据或敏感信息。</li>
</ul>
<p>要探究本质，就要解析他们的**<mark>报文<mark>**  </p>
<p>GET：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /search?query=java&amp;page=2 HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>POST：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /search HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">?query=java&amp;page=2 </span><br></pre></td></tr></table></figure>

<p>这些都是一个个字符串而已，发送的时候设置URL和参数本质上都是拼字符串，然后把整段报文发给服务。Servlet 接收请求，解析报文，拿到参数，仅此而已。填写表单的时候也一样，form标签的action属性就是要发送请求的目标，输入参数，提交的时候，就相当于填写好了目标URL，既然目标确定了。浏览器会解析内容，写好报文，发送给目标，那么浏览器是如何确定要发送给谁呢？浏览器确定请求的目标地址（即请求的 URL）是通过 URL 来实现的。以下是这一过程的基本步骤：以GET请求为例：</p>
<h3 id="目标URL的填写"><a href="#目标URL的填写" class="headerlink" title="目标URL的填写"></a>目标URL的填写</h3><p>用户在浏览器中提交表单（例如，点击“提交”按钮），这会触发一个请求。表单的 <code>action</code> 属性指定了要发送请求的 URL。浏览器会将表单数据编码为查询字符串，并附加到 <code>action</code> URL 后面作为要访问的目标。</p>
<h3 id="解析-URL"><a href="#解析-URL" class="headerlink" title="解析 URL"></a>解析 URL</h3><p>浏览器解析这个 URL，分解成几个部分：</p>
<ul>
<li><strong>协议</strong>：<code>http</code></li>
<li><strong>主机名</strong>：<code>www.example.com</code></li>
<li><strong>路径</strong>：<code>/search</code></li>
<li><strong>查询字符串</strong>：<code>?query=java</code></li>
</ul>
<h3 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h3><p>浏览器会通过 DNS（域名系统）将主机名转换为相应的 IP 地址，以便找到目标服务器。例如，<code>www.example.com</code> 可能会被解析为 <code>192.0.2.1</code>。</p>
<h3 id="建立-TCP-连接"><a href="#建立-TCP-连接" class="headerlink" title="建立 TCP 连接"></a>建立 TCP 连接</h3><p>浏览器与目标服务器建立 TCP 连接，通常使用 HTTP 端口（默认为 80，HTTPS 为 443）。</p>
<h3 id="构造请求报文"><a href="#构造请求报文" class="headerlink" title="构造请求报文"></a>构造请求报文</h3><p>一旦连接建立，浏览器会根据表单数据构造 HTTP 请求报文，包括请求行、请求头和请求体。</p>
<h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>浏览器通过已建立的 TCP 连接，将构造好的请求报文发送到服务器的指定 IP 地址。</p>
<h3 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h3><p>服务器接收到请求后，会根据请求的路径和参数来处理请求，最终返回相应的响应数据。</p>
<p>发出请求实际上就是浏览器访问目标URL</p>
<p>表单：action就是目标URL，如果是get请求，浏览器会将目标url加上参数。随后解析url，得出目标IP，根据这些参数生成请求报文发送到目标IP。</p>
<h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>axios是对js 的封装</p>
<p><a target="_blank" rel="noopener" href="https://www.axios-http.cn/">Axios中文文档 | Axios中文网 (axios-http.cn)</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929192249373.png" alt="image-20240929192249373"></p>
<p>method url data</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929192732304.png" alt="image-20240929192732304"></p>
<p>链式编程</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(url).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">resp</span>)&#123;</span><br><span class="line">    <span class="comment">//具体用响应干什么？</span></span><br><span class="line">&#125;)</span><br><span class="line">axios.<span class="title function_">post</span>(url,data).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">resp</span>)&#123;</span><br><span class="line">    <span class="comment">//具体用响应干什么？</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>resp：</p>
<p>①data :实际响应回来的数据</p>
<p>②headers :响应头信息</p>
<p>③status :响应状态码</p>
<p>④statusText:响应状态信息</p>
<p>特色：自动将data对象序列化为json字符串，再自动将响应数据中的json转回js自定义对象</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929210844535.png" alt="image-20240929210844535"></p>
<p>解构赋值：then({data}) 只取resp的data字段</p>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p><strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation js对象表示法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929194822398.png" alt="image-20240929194822398"></p>
<p>字段名要用双引号括起来，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">    <span class="string">&quot;key1&quot;</span>:value1,</span><br><span class="line">    <span class="string">&quot;key2&quot;</span>:value2</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//json.key1 访问value1</span></span><br><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">    <span class="attr">key1</span>:value1,</span><br><span class="line">    <span class="attr">key2</span>:value2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这两个对象的主要区别在于属性名的引号使用。在第一个对象中，所有属性名都用双引号包围，而在第二个对象中，属性名没有引号。根据 JavaScript 的语法，属性名可以不加引号（如果是有效的标识符），但如果包含特殊字符或空格，就需要加引号。功能上，它们是等价的。</p>
<p>axios发送自定义对象会自动转成json的形式</p>
<h2 id="JSON数据和Java对象转换"><a href="#JSON数据和Java对象转换" class="headerlink" title="JSON数据和Java对象转换"></a>JSON数据和Java对象转换</h2><p>Fastjson 高性能JSON库。</p>
<p>导入fastjson坐标</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line"><span class="comment">//对象tostring</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> JSON.parseObject(user, User.class);</span><br><span class="line"><span class="comment">//解析出对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/json;charset=utf-8&quot;</span>);</span><br><span class="line">response.getWriter().write(jsonString)</span><br></pre></td></tr></table></figure>

<h2 id="案例：增删改查"><a href="#案例：增删改查" class="headerlink" title="案例：增删改查"></a>案例：增删改查</h2><p><strong>查询</strong>：把axios发送请求接收响应数据并打印数据的过程 封装成一个函数，跟onload（brandSelect页面加载完成）绑定。</p>
<p>axios+html 接收servlet响应，打印表格</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929200621197.png" alt="image-20240929200621197"></p>
<p>axios这边接收到json，也就是resp.data 是对象的集合，所以用for循环遍历，由于是打印，所以可以用id锚定表格的标签，每遍历一次就累加字符串一次，最后一起写入表格标签的innerHTML中。</p>
<p><strong>新增品牌</strong>：</p>
<p>表单提交的操作是一个同步请求，同步请求是直接发送参数字段，而且需要重新加载页面才能生效，利用不上js的异步高效性，所以提交按钮应该设置成普通button，进行异步操作</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929203719660.png" alt="image-20240929203719660"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929204058611.png" alt="image-20240929204058611"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929204235548.png" alt="image-20240929204235548"></p>
<p>获取表单数据，字符串直接赋值，复选框的结果用checked表示，因为这是两个复选框，名字都叫status，所以返回的是一个元素数组，对这个数组进行便利，被选中的就把自己的value赋给对象。</p>
<p>axios发送自定义对象会自动转成json的形式，直接把封装好的自定义对象添加到axios的data参数中即可</p>
<p>函数绑定提交按钮的onclick事件，设定js函数把表单填入的内容封装成json对象（即为前面的操作），发送ajax请求给addServlet。</p>
<p><strong>addServlet</strong>处，<u>getParameter不能接收json数据</u>，所以应该用<u>getReader.readLine读取字符串</u>，然后把json字符串转成pojo对象，执行添加操作，返回操作成功与否，作为响应数据发出。</p>
<p>axios接收响应数据，如果操作成功，就跳转到第一步做出来的加载html页面中</p>
<p>增删改用post 查用get </p>
<h1 id="Vue-Servlet-开发"><a href="#Vue-Servlet-开发" class="headerlink" title="Vue+Servlet 开发"></a>Vue+Servlet 开发</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul>
<li><strong>Vue</strong>：前端的JS骨架，model view双向绑定，渲染网页</li>
<li><strong>axios</strong>：AJAX请求发送</li>
<li><strong>Element</strong> <strong>UI</strong>：CSS组件库，基于Vue</li>
</ul>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ul>
<li><strong>Web层</strong>：Servlet调用Service层的方法查询，结果转为JSON，响应JSON数据发给客户端</li>
<li><strong>Service层</strong>：BrandService定义selectAll方法，获取sqlSession对象，调用BrandMapper执行SQL语句</li>
<li><strong>DAO层</strong>：BrandMapper定义selectAll方法，方法体为MyBatis执行某条具体的SQL语句</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002150928236.png" alt="image-20241002150928236"></p>
<h2 id="服务端优化"><a href="#服务端优化" class="headerlink" title="服务端优化"></a>服务端优化</h2><h3 id="Service-优化"><a href="#Service-优化" class="headerlink" title="Service 优化"></a>Service 优化</h3><h4 id="Service-接口定义"><a href="#Service-接口定义" class="headerlink" title="Service 接口定义"></a>Service 接口定义</h4><ul>
<li>定义 <strong>BrandService</strong> 接口：定义一些业务的抽象方法，实现类中实现业务方法，在servlet中创建好业务实现对象，这样就解除了service层和servlet层的耦合性</li>
</ul>
<h4 id="ServiceImpl-接口实现"><a href="#ServiceImpl-接口实现" class="headerlink" title="ServiceImpl 接口实现"></a>ServiceImpl 接口实现</h4><ul>
<li>在实现类中，先创建好唯一的的factory工厂，然后在方法中开启sqlSession，执行SQL语句</li>
</ul>
<h4 id="优化结果"><a href="#优化结果" class="headerlink" title="优化结果"></a>优化结果</h4><ul>
<li><strong>UserService:</strong></li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164617150.png" alt="image-20241002164617150"></li>
<li><strong>UserServiceImpl:</strong></li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164523529.png" alt="image-20241002164523529"></li>
</ul>
<h3 id="Servlet-优化"><a href="#Servlet-优化" class="headerlink" title="Servlet 优化"></a>Servlet 优化</h3><h4 id="业务实现类的创建"><a href="#业务实现类的创建" class="headerlink" title="业务实现类的创建"></a>业务实现类的创建</h4><p>为了增强项目的组织度，会进行业务整合，在BrandServlet中，创建一个BrandService的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BrandServlet</span>&#123;</span><br><span class="line">	<span class="type">BrandService</span> <span class="variable">brandService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrandServiceImpl1</span>();</span><br><span class="line">    <span class="comment">//调用service的方法</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="业务功能整合"><a href="#业务功能整合" class="headerlink" title="业务功能整合"></a>业务功能整合</h4><p>一个实体类的一个功能就要新创建一个Servlet，不易管理，要把一个实体类的所有功能都放在一个servlet中。（BrandServlet，UserServlet）通过/brand/*   /user/*来访问上述两个servlet。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002135939524.png" alt="image-20241002135939524"></p>
<ul>
<li>如图，原先<code>HttpServlet</code>的<code>service</code>方法根据请求的方式（<code>getMethod</code>）进行方法的分发（<code>doGe</code>t或<code>doPost</code>）</li>
<li>现在要根据请求的路径来进行方法的分发，因此<code>BrandServlet</code>不能直接继承<code>HttpServlet</code>，要创建一个<code>BaseServlet</code>继承<code>HttpServlet</code>，重写其<code>service</code>方法，根据路径分发方法。同理<code>UserServlet</code>也直接继承<code>Base</code></li>
<li>获取到请求路径的最后一部分（最后一个<code>/</code>之后的内容）就是请求的方法名</li>
<li>方法名称有了还要找<code>对应servlet</code>的字节码文件，<code>baseServlet</code>没有<code>@WebServlet</code>注解，也就不会直接访问了，到时候被访问的应该是<code>BrandServlet</code>和<code>UserServlet</code>这两个子类，子类继承父类的<code>service</code>方法，所以<code>service</code>方法中的<code>this.getClass</code>就能理所应当地拿到子类的字节码文件。</li>
<li>因为<code>BrandServlet</code>和<code>UserServlet </code>都是要先执行<code>service(req,resp)</code>方法，接收<code>request</code>参数和<code>response</code>参数，如果要执行具体的<code>selectAll</code>业务方法，就要在反射调用方法的时候把参数加上，同时在<code>子类servlet</code>中，业务方法接受的参数全部统一成<code>req</code>和<code>resp</code>。</li>
</ul>
<p>如此一来，就能实现：</p>
<ol>
<li>访问<code>/brand/selectAll</code>路径，</li>
<li>调用重写过后的<code>service(HttpServletRequest req,HttpServletResponse resp)</code> 能获取方法名和字节码文件</li>
<li>根据方法名和参数类型（<code>methodName, HttpServletRequest req.class, HttpServletResponse.class</code>）获取Method对象，</li>
<li><code>method.invoke(this, req, resp)</code>，实现业务整合</li>
</ol>
<h4 id="优化结果-1"><a href="#优化结果-1" class="headerlink" title="优化结果"></a>优化结果</h4><ul>
<li><strong>BaseServlet:</strong></li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164451103.png" alt="image-20241002164451103"></li>
<li><strong>UserServlet:</strong> </li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164355800.png" alt="image-20241002164355800"></li>
</ul>
<h3 id="优化后的后端结构"><a href="#优化后的后端结构" class="headerlink" title="优化后的后端结构"></a>优化后的后端结构</h3><p>后端的DAO, Service, Web层分开 各司其职，减少了耦合度</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164240142.png" alt="image-20241002164240142" style="zoom: 50%;" />



<h2 id="其他细节"><a href="#其他细节" class="headerlink" title=" 其他细节 "></a><span id="mybatis"> 其他细节 </span></h2><h3 id="MyBatis-模糊查询"><a href="#MyBatis-模糊查询" class="headerlink" title="MyBatis 模糊查询"></a>MyBatis 模糊查询</h3><h4 id="39-password-39-不行？-39-password-39-行？"><a href="#39-password-39-不行？-39-password-39-行？" class="headerlink" title="&#39;%#{password}%&#39;不行？&#39;%${password}%&#39;行？"></a><code>&#39;%#&#123;password&#125;%&#39;</code>不行？<code>&#39;%$&#123;password&#125;%&#39;</code>行？</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002225509824.png" alt="image-20241002225509824"></p>
<p>${password}就是最简单的文本替换，直接拼接字符串，也不会类型转换（输入参数<code>that</code>会直接拼接成<code>and password like that</code> 很显然少了引号）连SQL都无法注入<code>&#39; OR &#39;1&#39; = &#39;1</code> <code>and password like &#39; OR &#39;1&#39; = &#39;1</code> （语法错误）自然，模糊匹配就变成<code>&#39;%that%&#39;</code>了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002230031380.png" alt="image-20241002230031380"></p>
<p>预编译占位符#{password}会把整个password转换成字符串，输入参数<code>&#39; OR &#39;1&#39; = &#39;1</code>会帮你转义成<code>\&#39; OR \&#39;1\&#39; = \&#39;1</code> 还会贴心地给两边加上引号<code>and password like &#39;\&#39; OR \&#39;1\&#39; = \&#39;1&#39;</code></p>
<p>因此，#{password}本身就自带引号，模糊匹配会解析成<code>&#39;%&#39;that&#39;%&#39;</code> 完全的语法错误。</p>
<h4 id="应该怎么用"><a href="#应该怎么用" class="headerlink" title="应该怎么用"></a>应该怎么用</h4><p>既然返回的是带引号的字符串，可以用拼接字符串函数，也可以用空格把这三个字符串分开</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002231938685.png" alt="image-20241002231938685"></p>
<h3 id="MyBatis-分页查询"><a href="#MyBatis-分页查询" class="headerlink" title="MyBatis 分页查询"></a>MyBatis 分页查询</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002234502508.png" alt="image-20241002234502508"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003001119464.png" alt="image-20241003001119464"></p>
<h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><p>分页查询要两个参数，这一页从哪一行开始和每页显示的条数</p>
<p>前端传递给后台 当前页码和每页显示条数，(当前页码-1)*每行显示条数就是这一页开始的一行</p>
<p>PageBean封装 总条数 和 这一页的查询结果List&lt;User&gt; </p>
<p>list用于显示，总条数返回给前端</p>
<h4 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h4><p>前端刷新表格的操作：发出自己的两个属性，收到PageBean中的rows和totalCount</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003003901994.png" alt="image-20241003003901994"></p>
<p>前端点击页码的操作，设置自身的两个属性，同时刷新表格</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003004044018.png" alt="image-20241003004044018"></p>
<h3 id="插入重复的键——事务回滚"><a href="#插入重复的键——事务回滚" class="headerlink" title="插入重复的键——事务回滚"></a>插入重复的键——事务回滚</h3><p>username是unique 且 not null 的，所以不能重复，在提交表单的时候，如果输入重复数据，就会导致事务提交失败，这是就会出现异常，<strong>如果出现异常不处理</strong>，会一直导致故障。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003005454880.png" alt="image-20241003005454880"></p>
<p>使用try catch 如果出现异常，就调用rollback，同时return false，响应</p>
<p>前端收到响应，会根据结果弹出提示，成功或者失败</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003005659475.png" alt="image-20241003005659475"></p>
<h3 id="优化后的前端结构"><a href="#优化后的前端结构" class="headerlink" title="优化后的前端结构"></a>优化后的前端结构</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003004606856.png" alt="image-20241003004606856"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003004711700.png" alt="image-20241003004711700"></p>
<p>加入了表格loading动画，刷新按钮，以及删除和插入的结果提示</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/08/31/spring-mp+lombok/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/31/spring-mp+lombok/" class="post-title-link" itemprop="url">MyBatis-Plus</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-31 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-31T00:00:00+08:00">2024-08-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-08 13:24:02" itemprop="dateModified" datetime="2025-05-08T13:24:02+08:00">2025-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web-development/" itemprop="url" rel="index"><span itemprop="name">web development</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>大家在日常开发中应该能发现，单表的CRUD功能代码重复度很高，也没有什么难度。而这部分代码量往往比较大，开发起来比较费时。</p>
<p>因此，目前企业中都会使用一些组件来简化或省略单表的CRUD开发工作。目前在国内使用较多的一个组件就是MybatisPlus.</p>
<p>当然，MybatisPlus不仅仅可以简化单表操作，而且还对Mybatis的功能有很多的增强。可以让我们的开发更加的简单，高效。</p>
<p>通过今天的学习，我们要达成下面的目标：</p>
<ul>
<li>能利用MybatisPlus实现基本的CRUD</li>
<li>会使用条件构建造器构建查询和更新语句</li>
<li>会使用MybatisPlus中的常用注解</li>
<li>会使用MybatisPlus处理枚举、JSON类型字段</li>
<li>会使用MybatisPlus实现分页</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://b11et3un53m.feishu.cn/wiki/PsyawI04ei2FQykqfcPcmd7Dnsc">day01-MybatisPlus - 飞书云文档</a> </p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/08/31/spring-mp+lombok/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/08/15/math-hash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/15/math-hash/" class="post-title-link" itemprop="url">哈希函数的工程应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-15 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-15T00:00:00+08:00">2024-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 11:25:31" itemprop="dateModified" datetime="2025-04-27T11:25:31+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/math/" itemprop="url" rel="index"><span itemprop="name">math</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">散列函数 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<h2 id="Hash-是什么"><a href="#Hash-是什么" class="headerlink" title="Hash 是什么"></a>Hash 是什么</h2><p>哈希（Hash）的原理是通过一种<strong>特定的函数</strong>，将任意长度的输入（也称为键）<strong>映射</strong>为固定长度的输出（称为哈希值、哈希码或散列值）。这种函数称为<strong>哈希函数</strong>或<strong>散列函数</strong>。哈希主要用于快速查找、数据完整性验证等方面，下面具体解释其原理和应用：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/08/15/math-hash/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/08/15/spring-in-one/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/15/spring-in-one/" class="post-title-link" itemprop="url">Spring</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-15 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-15T00:00:00+08:00">2024-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:49:58" itemprop="dateModified" datetime="2025-05-05T11:49:58+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h1><p>IoC: Inverse of Control 原先调用服务或者DAO的需要自行new出来对象，硬编码，耦合程度高，Spring的Container能够接管对象的创建工作（实际上就是管理Bean） 并且能够根据对象Bean之间的关系进行依赖注入，创建A对象的同时会把B对象创建起来，也就是DI(Dependency Injection)</p>
<p>管理方式：配置文件xml            IoC容器的获取：Spring提供接口</p>
<p>把业务接口的实现类交给Spring管理，遇到接口类，Spring就会自动去找Bean中是否有接口的实现类。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020194848409.png" alt="image-20241020194848409"></p>
<p>BookDao是接口，实现类为BookDaoImpl，Impl交给Spring管理</p>
<p>DI：依赖注入，依赖用方法传参的方式传入</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019114405108.png" alt="image-20241019114405108"></p>
<p>property name 是成员变量的名字</p>
<p>ref 是要引用的bean id/name</p>
<h2 id="IoC-配置"><a href="#IoC-配置" class="headerlink" title="IoC 配置"></a>IoC 配置</h2><h3 id="bean-管理"><a href="#bean-管理" class="headerlink" title="bean 管理"></a>bean 管理</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019222443537.png" alt="image-20241019222443537"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019115106810.png" alt="image-20241019115106810"></p>
<h4 id="name-别名"><a href="#name-别名" class="headerlink" title="name 别名"></a>name 别名</h4><p><u>ATTRIBUTE</u></p>
<p>bean <strong>name</strong> = “s1 s2 s3”  alias</p>
<p><strong>ref</strong>可以使用name也可以使用id</p>
<p>getBean </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019144037398.png" alt="image-20241019144037398"></p>
<h4 id="scope-作用范围"><a href="#scope-作用范围" class="headerlink" title="scope 作用范围"></a>scope 作用范围</h4><p><u>ATTRIBUTE</u></p>
<p>Spring默认创建<strong>单例</strong>bean，scope=”singleton” prototype为多例。</p>
<ul>
<li>适合复用的才作为bean交给IoC容器管理<ul>
<li>表现层，业务层，DAO层，工具层</li>
</ul>
</li>
<li>不适合复用的对象<ul>
<li>封装的实体域对象</li>
</ul>
</li>
</ul>
<h4 id="bean-创建方式"><a href="#bean-创建方式" class="headerlink" title="bean 创建方式"></a>bean 创建方式</h4><h5 id="使用构造方法"><a href="#使用构造方法" class="headerlink" title="使用构造方法"></a><mark>使用构造方法<mark></h5><p>无参构造器，如果使用构造器进行依赖注入，则走的是有参构造</p>
<h5 id="使用静态工厂实例化Bean"><a href="#使用静态工厂实例化Bean" class="headerlink" title="使用静态工厂实例化Bean"></a>使用静态工厂实例化Bean</h5><ul>
<li>工厂的静态方法factoryMethod(return new Bean)，不造工厂，调用工厂的<strong>静态</strong>方法造Bean <u>ATTRIBUTE</u>: factory-method</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019160109618.png" alt="image-20241019160109618"></p>
<h5 id="使用实例工厂实例化Bean"><a href="#使用实例工厂实例化Bean" class="headerlink" title="使用实例工厂实例化Bean"></a>使用实例工厂实例化Bean</h5><ul>
<li>先造工厂bean再调用工厂的<strong>实例</strong>方法(return newBean) 造bean</li>
</ul>
<h5 id="FactoryBean-实例工厂bean"><a href="#FactoryBean-实例工厂bean" class="headerlink" title="FactoryBean 实例工厂bean"></a><mark>FactoryBean 实例工厂bean<mark></h5><ul>
<li><p>第三方自定义工厂Bean类实现FactoryBean接口，重写方法<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019160946566.png" alt="image-20241019160946566"></p>
<ul>
<li>getObject 工厂类的returnNewBean方法</li>
<li>getObjectType return Bean.class bean的 字节码</li>
<li>isSingleton 单例</li>
</ul>
</li>
<li><p>xml 配置<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019161457148.png" alt="image-20241019161457148">    </p>
</li>
<li><p>主要用于第三方框架和Spring框架对接，他们创建的对象要配置一些参数，这时就需要一个FactoryBean，工厂bean会提供set对象参数的方法，返回的就是配好参的对象，可以省去手动配参的麻烦</p>
</li>
</ul>
<h4 id="bean-生命周期"><a href="#bean-生命周期" class="headerlink" title="bean 生命周期"></a>bean 生命周期</h4><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/reference/core/beans/factory-nature.html#beans-factory-lifecycle-initializingbean">Customizing the Nature of a Bean :: Spring Framework</a> </p>
<h5 id="init-method-初始化"><a href="#init-method-初始化" class="headerlink" title="init-method 初始化"></a>init-method 初始化</h5><p><u>ATTRIBUTE</u> 方法名</p>
<h5 id="destroy-method-销毁"><a href="#destroy-method-销毁" class="headerlink" title="destroy-method 销毁"></a>destroy-method 销毁</h5><p><u>ATTRIBUTE</u> 方法名</p>
<p>销毁方式1: 容器关闭 <code>ctx.close()</code> appctx这个类没有关闭功能，换一个annotationConfigAppctx才有</p>
<p>销毁方式2: 注册关闭钩子<code>ctx.registerShutdownHook()</code></p>
<h5 id="自定义实体类实现接口"><a href="#自定义实体类实现接口" class="headerlink" title="自定义实体类实现接口"></a>自定义实体类实现接口</h5><p><code>DisposableBean</code> <code>InitializingBean</code> </p>
<p>分别重写destory() afterPropertiesSet()</p>
<p>属性设置就是在属性注入(调用setter)之后调用的方法</p>
<h5 id="生命周期示意图"><a href="#生命周期示意图" class="headerlink" title="生命周期示意图"></a>生命周期示意图</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019163321664.png" alt="image-20241019163321664"></p>
<h3 id="DI-依赖注入"><a href="#DI-依赖注入" class="headerlink" title="DI 依赖注入"></a>DI 依赖注入</h3><p><strong>注入</strong> ⇔ <strong>给bean的属性赋值</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019222530413.png" alt="image-20241019222530413"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019163720566.png" alt="image-20241019163720566"></p>
<p>注入多个bean，填写多个property</p>
<h4 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h4><h5 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a><mark>setter注入<mark></h5><ol>
<li>setter 引用其他的bean property ref = 其他bean的名称 <u>ATTRIBUTE</u></li>
<li>setter 注入基本数据类型和简单值 property value = 值  <u>ATTRIBUTE</u></li>
<li>property name实际上是根据setter方法 setUserDao 去掉set首字母小写 userDao得到的</li>
<li>先无参构造创建bean，再用setter注入依赖</li>
</ol>
<h5 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h5><p>针对有参构造器，必须显式声明有参构造器</p>
<p> <u>ATTRIBUTE</u> <code>&lt;constructor-arg name&gt;</code></p>
<ol>
<li><p> 引用其他bean name是构造器形参名，<strong>耦合度高</strong>，参数先后顺序固定不能变<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019173838816.png" alt="image-20241019173838816"></p>
</li>
<li><p> 基本数据类型和简单值<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019174107702.png" alt="image-20241019174107702"></p>
</li>
<li><p>耦合度高解决方案：<strong>参数适配</strong></p>
<ul>
<li><p><code>&lt;constructor-arg name&gt;</code>改成type，解决参数名的高耦合，但是type相同的参数会混淆</p>
</li>
<li><p>改成index，index表示参数的位置</p>
</li>
</ul>
</li>
<li><p> 直接有参构造创建bean，可以没有无参构造</p>
</li>
</ol>
<h4 id="方式选择"><a href="#方式选择" class="headerlink" title="方式选择"></a>方式选择</h4><ul>
<li><strong>强制依赖</strong>使用构造器进行，使用setter注入有概率不进行注入导致NullPointerException</li>
<li><strong>可选依赖</strong>使用setter注入进行，灵活性强</li>
<li>Spring框架倡导使用构造器,第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨</li>
<li>如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入</li>
<li>实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</li>
<li><u>自己开发的模块推荐使用setter注入</u></li>
</ul>
<h4 id="依赖自动装配-autowire"><a href="#依赖自动装配-autowire" class="headerlink" title="依赖自动装配 autowire"></a>依赖自动装配 <span id="autowire">autowire</span></h4><p>只适用于引用类型</p>
<p><u>ATTRIBUTE</u> </p>
<p>不去手动指定，在容器的bean中自动匹配适合的bean。依赖于有参构造或者setter</p>
<h5 id="byType-依赖setter"><a href="#byType-依赖setter" class="headerlink" title="byType (依赖setter)"></a><mark>byType<mark> (依赖setter)</h5><p><code>bean属性的type</code> 要去匹配 <code>容器中bean的class</code></p>
<p>保证相同class的bean唯一 推荐</p>
<h5 id="byName-依赖setter"><a href="#byName-依赖setter" class="headerlink" title="byName (依赖setter)"></a>byName (依赖setter)</h5><p><code>bean属性的name</code> 要去匹配 <code>容器中bean的id</code></p>
<p>保证必须要有指定名称的bean  耦合度高，不推荐</p>
<h5 id="constructor-依赖有参构造器"><a href="#constructor-依赖有参构造器" class="headerlink" title="constructor(依赖有参构造器)"></a>constructor(依赖有参构造器)</h5><h5 id="default"><a href="#default" class="headerlink" title="default"></a>default</h5><p>如果&lt;beans&gt;指定了autowire 此bean跟随beans</p>
<h5 id="no"><a href="#no" class="headerlink" title="no"></a>no</h5><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li><p>只能自动装配引用类型（IoC容器不会去管理简单类型）包装类bean根本没法写</p>
</li>
<li><p>优先级 &lt; 手动装配</p>
</li>
</ul>
<h4 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h4><p>集合要注入内容，而不是注一个空壳</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myArray&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>5<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">value</span>&gt;</span>this<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>that<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>where<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mySet&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">value</span>&gt;</span>this<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>that<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>where<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;A&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;B&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;C&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myProperties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;A&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;B&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;C&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="管理第三方Bean"><a href="#管理第三方Bean" class="headerlink" title="管理第三方Bean"></a>管理第三方Bean</h3><p>别人写的对象，创建bean，类型是什么？你要配哪些参数？</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019191451764.png" alt="image-20241019191451764"></p>
<h4 id="加载-properties-XML-Namespace"><a href="#加载-properties-XML-Namespace" class="headerlink" title="加载.properties XML Namespace"></a>加载.properties XML Namespace</h4><p>创建context命名空间</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019192317628.png" alt="image-20241019192317628"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019220634669.png" alt="image-20241019220634669"></p>
<p>classpath:*.properties 当前模块下所有的配置文件</p>
<h3 id="容器-ctx"><a href="#容器-ctx" class="headerlink" title="容器 ctx"></a>容器 ctx</h3><h4 id="创建容器方式"><a href="#创建容器方式" class="headerlink" title="创建容器方式"></a>创建容器方式</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019221415451.png" alt="image-20241019221415451"></p>
<h4 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019221407031.png" alt="image-20241019221407031"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019221914707.png" alt="image-20241019221914707"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019222158026.png" alt="image-20241019222158026"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019221938964.png" alt="image-20241019221938964"></p>
<p>立即加载（饿汉），lazy-init 延迟加载 (懒汉)</p>
<h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><h3 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h3><h4 id="定义bean-Component"><a href="#定义bean-Component" class="headerlink" title="定义bean@Component"></a><mark>定义bean@Component<mark></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019223116345.png" alt="image-20241019223116345"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019223156078.png" alt="image-20241019223156078"></p>
<p>加上对应的bean的id ，不加就要加载字节码class</p>
<h4 id="纯注解开发-Configuration-ComponetScan"><a href="#纯注解开发-Configuration-ComponetScan" class="headerlink" title="纯注解开发@Configuration  @ComponetScan"></a><mark>纯注解开发@Configuration  @ComponetScan<mark></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019224153002.png" alt="image-20241019224153002"></p>
<p>获取ctx: <code>ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class)</code> </p>
<p>默认xml配置文件只给了beans的命名空间，context还得另外自己加，纯注解开发需要定义一个SpringConfig类，常用的配置都有，不用手动去加命名空间</p>
<p>XML out!</p>
<h3 id="2-bean管理"><a href="#2-bean管理" class="headerlink" title="2. bean管理"></a>2. bean管理</h3><h4 id="作用范围-Scope"><a href="#作用范围-Scope" class="headerlink" title="作用范围 @Scope"></a>作用范围 @Scope</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019225307356.png" alt="image-20241019225307356"></p>
<h4 id="生命周期-PostConstruct-PreDestroy"><a href="#生命周期-PostConstruct-PreDestroy" class="headerlink" title="生命周期 @PostConstruct @PreDestroy"></a>生命周期 @PostConstruct @PreDestroy</h4><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2426419">探究Spring Boot中@PostConstruct注解的使用场景-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1588212">Spring 框架中 @PostConstruct 注解详解-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019225254913.png" alt="image-20241019225254913"></p>
<p>Instantiate(Constructor)&gt; @Autowired &gt; @PostConstruct</p>
<p>依赖注入完成，被显式调用之前</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/reference/core/beans/annotation-config/postconstruct-and-predestroy-annotations.html">Using @PostConstruct and @PreDestroy :: Spring Framework</a></p>
<h3 id="DI-自动装配"><a href="#DI-自动装配" class="headerlink" title="DI 自动装配"></a>DI 自动装配</h3><h4 id="自动装配-Autowired（引用类型）"><a href="#自动装配-Autowired（引用类型）" class="headerlink" title="自动装配@Autowired（引用类型）"></a><mark>自动装配@Autowired（引用类型）<mark></h4><p>在需要注入依赖的<strong>一个</strong>属性</p>
<p>与配置文件<a href="#autowire">autowire Attribute of Bean</a>不同，注解Autowired不依赖于setter和有参构造器，直接暴力反射访问private属性，创建对象并注入依赖。 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020011345128.png" alt="image-20241020011345128"></p>
<h5 id="按名称匹配-Qualifier"><a href="#按名称匹配-Qualifier" class="headerlink" title="按名称匹配@Qualifier"></a>按名称匹配@Qualifier</h5><p>autowired默认按类型装 配，同一类型多个实现，用Qualifier指定具体bean名称，<em>不加Qualifier就按一定规则选择</em> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020011356460.png" alt="image-20241020011356460"></p>
<h5 id="先名称匹配，再按照类型匹配-Resource"><a href="#先名称匹配，再按照类型匹配-Resource" class="headerlink" title="先名称匹配，再按照类型匹配@Resource"></a>先名称匹配，再按照类型匹配@Resource</h5><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1003903">面试突击78：@Autowired 和 @Resource 有什么区别？-阿里云开发者社区 (aliyun.com)</a> </p>
<ul>
<li><strong>@Autowired 先根据类型（byType）查找，如果存在多个（Bean）再根据名称（byName）进行查找；</strong></li>
<li><strong>@Resource 先根据名称（byName）查找，如果（根据名称）查找不到，再根据类型（byType）进行查找。</strong> </li>
</ul>
<p>注意下方的<a href="#bean">Bean注解</a></p>
<p><strong>@Autowired 支持属性注入、构造方法注入和 Setter 注入，而 @Resource 只支持属性注入和 Setter 注入</strong> </p>
<p>@Autowired 来自 Spring 框架，而 @Resource 来自于（Java）JSR-250；</p>
<p>@Autowired 只支持设置 1 个参数，而 @Resource 支持设置 7 个参数；</p>
<p>@Autowired 既支持构造方法注入，又支持属性注入和 Setter 注入，而 @Resource 只支持属性注入和 Setter 注入；</p>
<h4 id="简单类型注入依赖-Value"><a href="#简单类型注入依赖-Value" class="headerlink" title="简单类型注入依赖@Value"></a>简单类型注入依赖@Value</h4><p>需要注入的属性上 写value</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020011954765.png" alt="image-20241020011954765"></p>
<h4 id="导入配置文件-PropertySource"><a href="#导入配置文件-PropertySource" class="headerlink" title="导入配置文件@PropertySource"></a>导入配置文件@PropertySource</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020011844984.png" alt="image-20241020011844984"></p>
<h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a><mark>循环依赖<mark></h4><p>Spring循环依赖指的是两个或多个Bean之间相互依赖，形成一个环状依赖的情况。简单来说，就是A依赖B，B依赖C，C依赖A，这样就形成了一个循环依赖的环。</p>
<p>Spring循环依赖通常会导致Bean无法正确地被实例化，从而导致应用程序无法正常启动或者出现异常。因此，Spring循环依赖是一种需要尽量避免的情况。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/633066ae3fcb2fcc117ab142dd90d3da-1730639875106-2.png"></p>
<h5 id="使用构造函数注入"><a href="#使用构造函数注入" class="headerlink" title="使用构造函数注入"></a>使用构造函数注入</h5><p>构造函数注入是一种相对保险的方式，因为在实例化Bean时，Spring会检查是否存在循环依赖，并在发现循环依赖时抛出异常，避免死循环。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用-Lazy注解"><a href="#使用-Lazy注解" class="headerlink" title="使用@Lazy注解"></a>使用@Lazy注解</h5><p>@Lazy注解可以延迟Bean的实例化，从而避免循环依赖的问题。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用setter方法注入"><a href="#使用setter方法注入" class="headerlink" title="使用setter方法注入"></a>使用setter方法注入</h5><p>使用setter方法注入也可以解决循环依赖的问题，但要注意可能出现的空指针异常。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">(B b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(A a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="管理第三方Bean-1"><a href="#管理第三方Bean-1" class="headerlink" title="管理第三方Bean"></a>管理第三方Bean</h3><h4 id="Config配置类中bean的创建-Bean"><a href="#Config配置类中bean的创建-Bean" class="headerlink" title="Config配置类中bean的创建@Bean"></a><span id="bean"><mark>Config配置类中bean的创建@Bean<mark></span></h4><p>与@Component不同 这个是方法级别的注解，方法返回的对象将由Spring容器管理</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020012511399.png" alt="image-20241020012511399"></p>
<h5 id="Bean声明的Bean名称？"><a href="#Bean声明的Bean名称？" class="headerlink" title="@Bean声明的Bean名称？"></a>@Bean声明的Bean名称？</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/w1014074794/article/details/106768607">spring boot中通过注解@Bean声明的bean的名称是什么？_springboot 声明bean的名称-CSDN博客</a></p>
<h6 id="不指定name属性，bean名称为方法名"><a href="#不指定name属性，bean名称为方法名" class="headerlink" title="不指定name属性，bean名称为方法名"></a>不指定name属性，bean名称为方法名</h6><h6 id="指定name属性，bean名称为name"><a href="#指定name属性，bean名称为name" class="headerlink" title="指定name属性，bean名称为name"></a>指定name属性，bean名称为name</h6><h5 id="导入其他Config类到核心配置-Import"><a href="#导入其他Config类到核心配置-Import" class="headerlink" title="导入其他Config类到核心配置@Import"></a>导入其他Config类到核心配置@Import</h5><p>不建议直接把其他的配置写到SpringConfig里面，分出去然后import</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020012755726.png" alt="image-20241020012755726"></p>
<h4 id="DI-依赖注入-1"><a href="#DI-依赖注入-1" class="headerlink" title="DI 依赖注入"></a>DI 依赖注入</h4><p><span id="thirdpartydi">最简单的方法：自己new个对象出来，手动配参数，丢给spring</span> (其实xml就是把手动配参的过程从业务代码中解耦出来)</p>
<h5 id="简单类型依赖注入：成员变量-Value"><a href="#简单类型依赖注入：成员变量-Value" class="headerlink" title="简单类型依赖注入：成员变量@Value"></a>简单类型依赖注入：成员变量@Value</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020013246624.png" alt="image-20241020013246624"></p>
<h5 id="引用类型依赖注入：方法形参"><a href="#引用类型依赖注入：方法形参" class="headerlink" title="引用类型依赖注入：方法形参"></a><mark>引用类型依赖注入：方法形参<mark></h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020013406409.png" alt="image-20241020013406409"></p>
<h3 id="XML-vs-Annotation"><a href="#XML-vs-Annotation" class="headerlink" title="XML vs. Annotation"></a>XML vs. Annotation</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020013703651.png" alt="image-20241020013703651"></p>
<h2 id="整合第三方框架实战"><a href="#整合第三方框架实战" class="headerlink" title="整合第三方框架实战"></a>整合第三方框架实战</h2><h3 id="Spring-amp-MyBatis"><a href="#Spring-amp-MyBatis" class="headerlink" title="Spring &amp; MyBatis"></a>Spring &amp; MyBatis</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_64737877/article/details/122608987">使用纯注解方式Spring整合MyBatis_spring整合mybatis基于注解-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/SerikaOnoe/article/details/90639135">Spring整合Mybatis(注解方式完整过程，摒弃MyBatis配置文件)_springboot启动去除mybatis-CSDN博客</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020123544343.png" alt="image-20241020123544343"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020123756444.png" alt="image-20241020123756444"></p>
<p>dao是session用动态代理造出来的，不同业务的内部实现有区别。session也不会一直复用，根源在sqlSessionFactory。</p>
<p>还有一个就是mapper映射，这个跟ssf没什么关系。</p>
<h4 id="MyBatisConfig-SqlSessionFactoryBean"><a href="#MyBatisConfig-SqlSessionFactoryBean" class="headerlink" title="MyBatisConfig - SqlSessionFactoryBean"></a>MyBatisConfig - SqlSessionFactoryBean</h4><p>导入mybatis-spring spring-jdbc，mybatis实现了Spring规定的FactoryBean接口，专门用来造sqlSessionFactory对象。</p>
<p>回顾spring创建对象的方法，一种是<a href="#thirdpartydi">使用构造</a>器直接得到对象，另一种就是使用factoryBean&lt;E&gt;得到对象E，定义一个造E的工厂Bean，这样spring就知道类型E创对象需要用工厂Bean的方式。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020130218463.png" alt="image-20241020130218463"></p>
<p>factorybean中提供了很多设置E参数的方法，最终返回的是一个设置好参数的E，思想还是一样的，只不过套了一层工厂的皮，封装进去很多固定的参数set方法，一般这个E需要xml进行配置(跟真正的业务代码解耦)，工厂Bean就取代了xml，直接给你返回一个配置好的对象。</p>
<p>需要传参就直接在写上方法参数即可，spring自动匹配</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020145504890.png" alt="image-20241020145504890"></p>
<h4 id="MyBatisConfig-MapperScannerConfigurer"><a href="#MyBatisConfig-MapperScannerConfigurer" class="headerlink" title="MyBatisConfig - MapperScannerConfigurer"></a>MyBatisConfig - MapperScannerConfigurer</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020145526730.png" alt="image-20241020145526730"></p>
<p>DAO没有实现类了，在原始接口上加Component、Repository给ioc容器标识一下，不标也行。</p>
<p>这个mapperScannerConfigurer是mybatis和spring集成的部分，扫描指定mapper所在的包，mapper生成代理对象，通过factoryBean方式交给Spring容器，所以重点不是让spring知道dao的实现类在哪，重点是要让mybatis知道mapper位置</p>
<h4 id="JdbcConfig-创建DataSource的Bean交给Spring管理"><a href="#JdbcConfig-创建DataSource的Bean交给Spring管理" class="headerlink" title="JdbcConfig - 创建DataSource的Bean交给Spring管理"></a>JdbcConfig - 创建DataSource的Bean交给Spring管理</h4><h3 id="Spring-amp-JUnit"><a href="#Spring-amp-JUnit" class="headerlink" title="Spring &amp; JUnit"></a>Spring &amp; JUnit</h3><p>导入spring-test 在Test<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020191443245.png" alt="image-20241020191443245"></p>
<p>在test.java中测试。</p>
<h4 id="RunWith-ContextConfiguration"><a href="#RunWith-ContextConfiguration" class="headerlink" title="@RunWith @ContextConfiguration"></a>@RunWith @ContextConfiguration</h4><h4 id="Autowired-Test"><a href="#Autowired-Test" class="headerlink" title="@Autowired @Test"></a>@Autowired @Test</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020145826024.png" alt="image-20241020145826024"></p>
<p>需要引用类型参数直接autowired注入即可，一般是业务类做测试</p>
<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><h2 id="AOP的含义"><a href="#AOP的含义" class="headerlink" title="AOP的含义"></a>AOP的含义</h2><p>AOP 面向切面编程 <strong>不惊动原始设计</strong>的情况下增强功能</p>
<p>Spring理念：无侵入式增强功能</p>
<ul>
<li>所有原始方法-&gt;连接点(joint point) 在SpringAOP中如此<ul>
<li>save update delete select</li>
</ul>
</li>
<li>需要追加功能的方法-&gt;切入点(pointcut)<ul>
<li>save update delete </li>
</ul>
</li>
<li>具备的共性功能-&gt;通知 (advice)<ul>
<li>method1   method2</li>
</ul>
</li>
<li>通知和切入点产生关系-&gt;切面 (aspect) <ul>
<li>save update delete追加method</li>
</ul>
</li>
<li>功能的集合-&gt;通知类</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020152910091.png" alt="image-20241020152910091"></p>
<p>连接点包含切入点</p>
<h2 id="Spring中进行AOP编程"><a href="#Spring中进行AOP编程" class="headerlink" title="Spring中进行AOP编程"></a>Spring中进行AOP编程</h2><h3 id="导入坐标"><a href="#导入坐标" class="headerlink" title="导入坐标"></a>导入坐标</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020154236445.png" alt="image-20241020154236445"></p>
<h3 id="MyAdvice"><a href="#MyAdvice" class="headerlink" title="MyAdvice"></a><mark>MyAdvice<mark></h3><h4 id="定义通知"><a href="#定义通知" class="headerlink" title="定义通知"></a>定义通知</h4><h4 id="定义切入点-Pointcut"><a href="#定义切入点-Pointcut" class="headerlink" title="定义切入点 @Pointcut"></a>定义切入点 @Pointcut</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020154309848.png" alt="image-20241020154309848"></p>
<p><code>private</code> <code>void</code> <code>空参</code> </p>
<h4 id="绑定通知与切入点"><a href="#绑定通知与切入点" class="headerlink" title="绑定通知与切入点"></a>绑定通知与切入点</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020154407660.png" alt="image-20241020154407660"></p>
<h4 id="Spring接管此类-Component"><a href="#Spring接管此类-Component" class="headerlink" title="Spring接管此类 @Component"></a>Spring接管此类 @Component</h4><h4 id="定义AOP-Aspect"><a href="#定义AOP-Aspect" class="headerlink" title="定义AOP @Aspect"></a>定义AOP @Aspect</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020154529656.png" alt="image-20241020154529656"></p>
<h3 id="SpringConfig-EnableAspectAutoProxy"><a href="#SpringConfig-EnableAspectAutoProxy" class="headerlink" title="SpringConfig @EnableAspectAutoProxy"></a><mark>SpringConfig @EnableAspectAutoProxy<mark></h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020154505110-1729410361899-4.png" alt="image-20241020154505110"></p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020155857766.png" alt="image-20241020155857766"></p>
<p>**基于<mark>动态代理<mark>**：</p>
<ul>
<li><p>匹配失败，new原始对象；</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020160228368.png" alt="image-20241020160228368"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020160243146.png" alt="image-20241020160243146"></p>
</li>
<li><p>匹配成功，new出来的是原始对象的代理对象；</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020160302140.png" alt="image-20241020160302140"></p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020160341452.png" alt="image-20241020160341452"></p>
</li>
</ul>
<p><strong>用获取到的bean执行方法</strong>：如果是代理的bean，根据通知和切入点进行方法执行。</p>
<h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3><p>切入点：要对其进行增强的方法</p>
<p>切入点表达式：对切入点的描述方式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020161523488.png" alt="image-20241020161523488"></p>
<p>execution(<code>public</code> <code>User</code> <code>com.itheima.service.UserService.findById</code>(<code>int</code>))</p>
<p>public exception 可省略</p>
<p>参数必须有</p>
<h4 id="通配符使用"><a href="#通配符使用" class="headerlink" title="通配符使用"></a>通配符使用</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020161833474.png" alt="image-20241020161833474"></p>
<ul>
<li>..和*的区别 *用于精准匹配到某个位置</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020163432072.png" alt="image-20241020163432072"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.impl.BookDaoImpl.update())&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.impl.BookDaoImpl.update(*))&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.*.*.*.update())&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* *..*(..))&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* *..*e(..))&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(void com..*())&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.itheima.*.*Service.find*(..))&quot;)</span></span><br><span class="line"><span class="comment">//执行com.itheima包下的任意包下的名称以Service结尾的类或接口中的save方法，参数任意，返回值任意</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h3><h4 id="前置-Before"><a href="#前置-Before" class="headerlink" title="前置@Before"></a>前置@Before</h4><h4 id="后置-After"><a href="#后置-After" class="headerlink" title="后置@After"></a>后置@After</h4><h4 id="环绕-Around"><a href="#环绕-Around" class="headerlink" title="环绕@Around"></a><strong><u><mark>环绕@Around<mark></u></strong></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020170038080.png" alt="image-20241020170038080"></p>
<ul>
<li><p>ProceedingJoinPoint</p>
</li>
<li><p>原始方法在环绕方法中执行，用<code>pjp.proceed()</code>执行原始方法，<mark>不出现就能隔离原始方法，（权限校验）<mark></p>
</li>
<li><p>pjp能接原始方法的返回值，类型为Object，强转后可以在给他返回去，思想和动态代理里的案例比较像：利用反射invoke调用可以拿到返回值，<strong>注意修改通知方法的返回值为Object。</strong>没返回值也可以</p>
</li>
<li><p>强制抛Throwable </p>
</li>
</ul>
<h4 id="得到返回值之后-AfterReturning"><a href="#得到返回值之后-AfterReturning" class="headerlink" title="得到返回值之后@AfterReturning"></a>得到返回值之后@AfterReturning</h4><p>和after区别：after只要方法结束即可，不管是得到返回值正常结束还是抛异常。AfterReturning需要得到返回值正常结束才能</p>
<h4 id="抛出异常之后-AfterThrowing"><a href="#抛出异常之后-AfterThrowing" class="headerlink" title="抛出异常之后@AfterThrowing"></a>抛出异常之后@AfterThrowing</h4><h3 id="案例：JUnit-测量业务层接口执行效率"><a href="#案例：JUnit-测量业务层接口执行效率" class="headerlink" title="案例：JUnit 测量业务层接口执行效率"></a>案例：JUnit 测量业务层接口执行效率</h3><p>JUnit 测试服务类就private服务出来，<code>@Autowired</code> </p>
<p>下面写test具体方法。详见JUnit单元测试篇(Java SE)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020171154617.png" alt="image-20241020171154617"></p>
<p>获取方法签名 (执行信息) <code>getSignature()</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020171252962.png" alt="image-20241020171252962"></p>
<h3 id="通知获取数据"><a href="#通知获取数据" class="headerlink" title="通知获取数据"></a>通知获取数据</h3><h4 id="JoinPoint-amp-ProceedingJoinPoint"><a href="#JoinPoint-amp-ProceedingJoinPoint" class="headerlink" title="JoinPoint &amp; ProceedingJoinPoint"></a>JoinPoint &amp; ProceedingJoinPoint</h4><p><strong>作为通知的参数</strong>，如果出现，必须在第一个参数的位置上,PJP是JP的子类</p>
<p><code>Object[] getArgs()</code>: 获取原始方法的参数</p>
<p><code> Object proceed()</code> :环绕 PJP专用，调用原始方法同时返回这个方法的返回值</p>
<h4 id="AOP获取原始方法调用参数"><a href="#AOP获取原始方法调用参数" class="headerlink" title="AOP获取原始方法调用参数"></a><mark>AOP获取原始方法调用参数<mark></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020173959692.png" alt="image-20241020173959692"></p>
<p>这样可以对原始参数进行处理，可以增加程序健壮性。</p>
<p><code>Object proceed(Object[] args)</code> 可以把处理以后的参数传给原始方法。</p>
<h5 id="案例：网盘提取码去空格"><a href="#案例：网盘提取码去空格" class="headerlink" title="案例：网盘提取码去空格"></a>案例：网盘提取码去空格</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020180157823.png" alt="image-20241020180157823"></p>
<p>args本身是Object数组，拿进来需要转成字符串toString getArgs 然后遍历参数数组，对每个字符串参数trim，再把处理以后的传给proceed</p>
<h4 id="AOP获取返回值"><a href="#AOP获取返回值" class="headerlink" title="AOP获取返回值"></a>AOP获取返回值</h4><ol>
<li>环绕 pjp proceed </li>
<li>AfterReturning 注解的returning要和形参名字相同</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020175037570.png" alt="image-20241020175037570"></p>
<h4 id="AOP接收异常"><a href="#AOP接收异常" class="headerlink" title="AOP接收异常"></a>AOP接收异常</h4><ol>
<li><p>环绕 不要往出抛Throwable 内部try-catch</p>
</li>
<li><p>AfterThrowing 注解的throwing和形参名字相同</p>
</li>
</ol>
<p>![image-20241020174307577](<a target="_blank" rel="noopener" href="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/屏幕截图</a> 2024-10-20 174257.jpg)</p>
<h3 id="环绕通知模拟其他四种通知"><a href="#环绕通知模拟其他四种通知" class="headerlink" title="环绕通知模拟其他四种通知"></a>环绕通知模拟其他四种通知</h3><table>
<thead>
<tr>
<th>前置</th>
<th>最后调用proceed</th>
</tr>
</thead>
<tbody><tr>
<td>后置</td>
<td>try catch finally 在finally里写</td>
</tr>
<tr>
<td>AfterReturning</td>
<td>Object接住proceed的返回值</td>
</tr>
<tr>
<td>AfterThrowing</td>
<td>不要往出抛Throwable，try catch Throwable</td>
</tr>
</tbody></table>
<h2 id="AOP编程思想—this调用实例方法失效"><a href="#AOP编程思想—this调用实例方法失效" class="headerlink" title="AOP编程思想—this调用实例方法失效"></a>AOP编程思想—this调用实例方法失效</h2><p>AOP的核心，是从调用对象的方法时生成代理对象—PROXY，this指向真正的目标对象—TARGET</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IService</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">zoo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IService</span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">		System.println(<span class="string">&quot;fooStart...&quot;</span>);</span><br><span class="line">		zoo();<span class="comment">//this指针调用实例方法</span></span><br><span class="line">		System.println(<span class="string">&quot;fooFinish...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Transactional</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">zoo</span><span class="params">()</span>&#123;</span><br><span class="line">		save(a);<span class="comment">//假设是将a保存到数据库</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">		save(b);<span class="comment">//假设是将b保存到数据库</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IService service;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        service.foo();<span class="comment">//从外部调用内部的事务方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事务的实现基于spring aop，如果直接用this，则会使用target对象进行方法调用，</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/reference/core/aop/proxying.html#aop-understanding-aop-proxies">Proxying Mechanisms :: Spring Framework</a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/tx-decl-explained.html#page-title">Understanding the Spring Framework’s Declarative Transaction Implementation :: Spring Framework</a> </p>
<p>如果是在类内部开启的事务，就需要CGLIB动态代理，实现的基础是方法拦截器，环绕通知，</p>
<h3 id="直接调用方法"><a href="#直接调用方法" class="headerlink" title="直接调用方法"></a>直接调用方法</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241104161707487.png" alt="image-20241104161707487"></p>
<h3 id="通过代理调用方法"><a href="#通过代理调用方法" class="headerlink" title="通过代理调用方法"></a>通过代理调用方法</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241104161648309.png" alt="image-20241104161648309"></p>
<p>也就是说，如果要让代理生效，首先就是要获取代理对象，而通过@Transactional注解的方法<code>zoo()</code>，如果从外部调用，只要获得了代理对象的引用，事务功能就是生效的，因此直接在main中只要获取了代理对象的引用调用service.zoo()方法是没有问题的。</p>
<p>而在目标对象内部，this就是目标对象本身，肯定不会走代理，因此如果实在</p>
<h3 id="解决方案—在类的内部获取代理对象"><a href="#解决方案—在类的内部获取代理对象" class="headerlink" title="解决方案—在类的内部获取代理对象"></a>解决方案—在类的内部获取代理对象</h3><h4 id="AopContext-currentProxy"><a href="#AopContext-currentProxy" class="headerlink" title="AopContext.currentProxy()"></a>AopContext.currentProxy()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (UserHolder.getUser()) &#123;</span><br><span class="line">    <span class="comment">//开启事务需要获取当前的代理对象</span></span><br><span class="line">    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Autowired-注入服务对象本身"><a href="#Autowired-注入服务对象本身" class="headerlink" title="@Autowired 注入服务对象本身"></a>@Autowired 注入服务对象本身</h4><p>获取service对象即可，这样就能在类内部的上下文中获取proxy代理都象的引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ServiceImpl service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (UserHolder.getUser()) &#123;</span><br><span class="line">    <span class="comment">//开启事务需要获取当前的代理对象</span></span><br><span class="line">    <span class="keyword">return</span> service.createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以新开一个Impl2类，把方法移植进去，注入Impl2对象，思路一样</span></span><br></pre></td></tr></table></figure>



<h2 id="AOP：动态代理对象的生成时机"><a href="#AOP：动态代理对象的生成时机" class="headerlink" title="AOP：动态代理对象的生成时机"></a>AOP：动态代理对象的生成时机</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xzb5566/article/details/141639614">【spring系列】spring的AOP是在哪个阶段创建的动态代理对象，spring bean的生命周期中在什么阶段创建的aop动态代理对象，很多人会说第一种，其实还有一种情况也会进行aop_spring的aop代理对象什么时候创建-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2154184">关于Spring的两三事：代理对象的生成时机-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><strong>1） Bean的实例化</strong>：首先，Spring容器会实例化Bean。</p>
<p><strong>2）Bean的属性填充</strong>：然后，为Bean填充依赖注入的属性。</p>
<p><strong>3）Bean的初始化：</strong></p>
<ul>
<li><strong>初始化前（postProcessBeforeInitialization）</strong>：在这一阶段，Spring会调用所有BeanPostProcessor的postProcessBeforeInitialization方法。但此时，代理对象可能还未被创建，因为还需要进一步判断该Bean是否需要被代理。</li>
<li><strong>初始化</strong>：接着，执行Bean的初始化方法（如@PostConstruct注解的方法或实现了InitializingBean接口的afterPropertiesSet方法）。</li>
<li><strong>初始化后（postProcessAfterInitialization）</strong>：在Bean初始化完成后，Spring会调用所有BeanPostProcessor的postProcessAfterInitialization方法。这通常是**创建动态代理对象的时机(AOP)**，因为此时Bean已经完全初始化并准备使用，而且代理对象可以在这一阶段被创建并替换掉原始的Bean实例。</li>
</ul>
<p><strong>4）代理对象的创建：</strong> </p>
<ul>
<li>在postProcessAfterInitialization方法中，Spring会检查该Bean是否需要被代理（通常基于是否存在对应的Advisor或Aspect）。</li>
<li>如果需要，Spring会根据Bean的类型（是否实现了接口）选择合适的代理方式（JDK动态代理或CGLIB代理）来创建代理对象。</li>
<li>代理对象会封装原始Bean，并在方法调用时插入增强的逻辑（如前置通知、后置通知等）。</li>
</ul>
<p><strong>5）Bean的交付</strong>：最后，将创建好的代理对象（如果需要的话）或原始Bean实例交付给客户端使用。</p>
<p>因此，<strong>Spring AOP的动态代理对象主要是在Bean的初始化后的postProcessAfterInitialization阶段创建的</strong>。这一过程确保了代理对象能够封装并增强原始Bean的方法调用，同时保持了Bean的生命周期和依赖注入的完整性。</p>
<h1 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h1><p>事务用于业务层或者Dao层</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wang489687009/article/details/129259394">【Spring事务三千问】Spring的事务管理与MyBatis事务管理结合的原理_spring transaction和mybatis的整合 原理-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/358657396">【spring源码深度解析】：spring是如何利用@Transactional注解实现数据库事务的？把握住事务的基本用法你就懂了 - 知乎 (zhihu.com)</a></p>
<h2 id="事务管理整合"><a href="#事务管理整合" class="headerlink" title="事务管理整合"></a>事务管理整合</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jddreams/p/14024754.html">图解Java JDBC和JPA的区别 - 快乐随行 - 博客园 (cnblogs.com)</a></p>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ul>
<li>InnoDB存储引擎支持事务（SQL语句）</li>
</ul>
<h3 id="原生JDBC"><a href="#原生JDBC" class="headerlink" title="原生JDBC"></a>原生JDBC</h3><ul>
<li> 注册驱动，</li>
<li> 获取Connection，</li>
<li> 建立Statement执行SQL语句，Connection可以管理事务（本质是执行SQL语句）</li>
</ul>
<h3 id="DataSource数据源"><a href="#DataSource数据源" class="headerlink" title="DataSource数据源"></a>DataSource数据源</h3><ul>
<li>主要用来获取并管理，调度Connection</li>
</ul>
<h3 id="原生-MyBatis-ORM"><a href="#原生-MyBatis-ORM" class="headerlink" title="原生 MyBatis (ORM)"></a>原生 MyBatis (ORM)</h3><ul>
<li><p>可以调用外部数据源获取Connection，也可以使用原生JDBC来获取，最终这些Connection可以呗SqlSession获取到。</p>
</li>
<li><p>SqlSession同样能管理事务，底层是基于Transaction(也是mybatis的一个类)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">affected_rows</span> <span class="operator">=</span> session.insert(<span class="string">&quot;com.kvn.mapper.UserMapper.insert&quot;</span>, user);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 捕获到异常，将操作回滚</span></span><br><span class="line">    session.rollback();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正常执行，提交事务</span></span><br><span class="line">session.commit();</span><br><span class="line">session.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Spring联合MyBatis事务管理"><a href="#Spring联合MyBatis事务管理" class="headerlink" title="Spring联合MyBatis事务管理"></a>Spring联合MyBatis事务管理</h3><p><code>SpringManagedTransaction</code> 打通了 MyBatis 的事务管理、连接管理 和 spring-tx 的 事务管理、连接管理，使得 MyBatis 与 Spring 可以使用统一的方式来管理连接的生命周期 和 事务处理。</p>
<ol start="0">
<li><p>原生的MyBatis 使用的是JdbcTransaction实现类</p>
</li>
<li><p>在一个非 <code>@Transactional</code> 标记的方法中执行 sql 命令，则事务的管理会通过 <code>SpringManagedTransaction</code> 来执行。</p>
</li>
<li><p>在一个 <code>@Transactional</code> 标记的事务方法中执行 sql 命令，则 <code>SpringManagedTransaction</code> 的 <code>commit()/rollback()</code> 方法不会执行任何动作，而事务的管理会走 Spring AOP 事务管理，即通过 <code>org.springframework.transaction.interceptor.TransactionInterceptor</code> 来进行拦截处理。</p>
</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020215834772.png" alt="image-20241020215834772"></p>
<ol start="3">
<li>SqlSessionInterceptor 保证了 MyBatis 的 SqlSession 在执行 sql 时使用的连接与 Spring 事务管理操作使用的连接是<u>同一个</u>连接。具体就是通过 Spring 的事务同步器 <code>TransactionSynchronizationManager</code> 来保证的。</li>
<li>SpringManagedTransaction 中连接的获取是从 Spring 管理的 DataSource 中获取的，这样，数据库连接池也就和 spring 整合在一起了。</li>
</ol>
<h2 id="多线程事务"><a href="#多线程事务" class="headerlink" title="多线程事务"></a>多线程事务</h2><h3 id="javax-sql-Connection"><a href="#javax-sql-Connection" class="headerlink" title="javax.sql.Connection"></a>javax.sql.Connection</h3><p>简单地来说，建立<code>Connection</code>连接，会消耗数据库系统的如下资源：</p>
<table>
<thead>
<tr>
<th align="center">资源</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">线程数</td>
<td align="center">线程越多，线程的上下文切换会越频繁，会影响其处理能力</td>
</tr>
<tr>
<td align="center">创建Connection的开销</td>
<td align="center">由于Connection负责和数据库之间的通信，在创建环节会做大量的初始化 ，创建过程所需时间和内存资源上都有一定的开销</td>
</tr>
<tr>
<td align="center">内存资源</td>
<td align="center">为了维护Connection对象会消耗一定的内存</td>
</tr>
<tr>
<td align="center">锁占用</td>
<td align="center">在高并发模式下，不同的Connection可能会操作相同的表数据，就会存在锁的情况，数据库为了维护这种锁会有不少的内存开销</td>
</tr>
</tbody></table>
<p>事务的执行依赖于JDBC-connection，connection的建立基于tcp连接，需要耗费很多资源，所以在多线程并发的情况下，connection数目远少于thread数，需要尽可能考虑connection的共用和复用。</p>
<p>connection可以显式开启和关闭事务，遵循事务的ACID原则，因此虽然共用connection，但是同一时间同一connection只能有同一个事务正在执行，也就是串行执行，否则会造成事务紊乱。</p>
<p>一个最佳实践：<strong>当线程需要做数据库操作时，才会真正请求获取JDBC数据库连接,线程使用完了之后，立即释放，被释放的JDBC数据库连接等待下次分配使用</strong></p>
<p>最简单的方式就是把事务执行的代码块用connection锁对象锁住：事务执行完以后释放（但不销毁）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(connection)&#123;</span><br><span class="line">    <span class="comment">//tx......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程如何获取锁对象？为了保证一个线程所有dao操作都是用的同一个connection，使用threadLocal存放属于线程自己的connection，如果是直接从连接池获得的话，多个 DAO 就用到了多个Connection，不能完成一个事务。而连接池负责提供缓存和提供connection</p>
<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/luanlouis/article/details/37671851">《深入理解mybatis原理》 Mybatis数据源与连接池_mybatis 连接池-CSDN博客</a></p>
<p>原生的JDBC会让connection的close()方法执行数据库连接的释放与销毁，为了保证不更改原生的功能，我们可以使用代理对象，让其close方法不会真正执行，而是回收到数据库连接池中。</p>
<p>使用数据库连接池，通常都是得到一个javax.sql.DataSource[接口]的实例对象，它里面包含了Connection，并且数据库连接池工具类（比如C3P0、JNDI、DBCP等）重新定义了getConnection、closeConnection等方法，所以每次得到的Connection，几乎都不是新建立的连接（而是已经建立好并放到缓存里面的连接），调用closeConnection方法，也不是真正的关闭连接（一般都是起到一个标识作用，标识当前连接已经使用完毕，归还给连接池，让这个连接处于待分配状态）【PS：所以说：使用数据库连接池时，还是要显式的调用数据库连接池API提供的关闭连接的方法】。</p>
<p>至于为什么要用ThreadLocal呢?这个和连接池无关,我认为更多的是和程序本身相关,为了更清楚的说明,我举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">servlet中获取一个连接.首先,servlet是线程安全的吗?</span><br><span class="line"></span><br><span class="line">     class MyServlet extends HttpServlet&#123;</span><br><span class="line">         private Connection conn;</span><br><span class="line">     &#125;</span><br><span class="line">     ok,遗憾的告诉你,这个conn并不是安全的,所有请求这个servlet的连接,使用的都是一个Connection,这个就是致命的了.多个人使用同一个连接,算上延迟啥的,天知道数据会成什么样.</span><br><span class="line">     因此我们要保证Connection对每个请求都是唯一的.这个时候就可以用到ThreadLocal了,保证每个线程都有自己的连接.</span><br><span class="line">     改为 private ThreadLocal&lt;Connection&gt; ct = new ThreadLocal&lt;Connnection&gt;();</span><br><span class="line">     然后从连接池获取Connection,set到ct中,再get就行了,至于得到的是哪个Connection就是连接池的问题了,你也管不到.</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal?"></a>ThreadLocal?</h3><p>就是为每一个使用该变量的线程都提供一个变量值的副本，是每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲</p>
<h2 id="开启步骤"><a href="#开启步骤" class="headerlink" title="开启步骤"></a>开启步骤</h2><h3 id="业务层-接口-为业务方法打开事务-Transactional"><a href="#业务层-接口-为业务方法打开事务-Transactional" class="headerlink" title="业务层**接口**为业务方法打开事务@Transactional"></a>业务层**<mark>接口<mark>**为业务方法打开事务@Transactional</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020204651727.png" alt="image-20241020204651727"></p>
<ul>
<li><p>@Transactional是方法级别或者类级别的注解，可以<strong>开在整个接口上</strong>，也可以开在单个方法上</p>
</li>
<li><p>接口能够提高复用性，降低耦合</p>
</li>
</ul>
<h3 id="JdbcConfig创建事务管理器Bean-Bean"><a href="#JdbcConfig创建事务管理器Bean-Bean" class="headerlink" title="JdbcConfig创建事务管理器Bean@Bean"></a>JdbcConfig创建事务管理器Bean@Bean</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020204933459.png" alt="image-20241020204933459"></p>
<p>PlatformTransactionManager是Spring规定的，DataSourceTransactionManager可以动，根据具体的技术选择</p>
<p>要注意，事务管理器的datasource和mybatis用的datasource必须是同一个，不然</p>
<h3 id="SpringConfig打开事务-EnableTransactionManagement"><a href="#SpringConfig打开事务-EnableTransactionManagement" class="headerlink" title="SpringConfig打开事务@EnableTransactionManagement"></a>SpringConfig打开事务@EnableTransactionManagement</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020205233232.png" alt="image-20241020205233232"></p>
<h2 id="事务角色"><a href="#事务角色" class="headerlink" title="事务角色"></a>事务角色</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020205625500.png" alt="image-20241020205625500"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020205648701.png" alt="image-20241020205648701"></p>
<h2 id="事务配置"><a href="#事务配置" class="headerlink" title="事务配置"></a>事务配置</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020222103484.png" alt="image-20241020222103484"></p>
<p>有些异常不会触发回滚，需要手动设置一下rollbackFor</p>
<h3 id="追加日志"><a href="#追加日志" class="headerlink" title="追加日志"></a>追加日志</h3><p>try finally结构，finally 记日志功能必定触发</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020222628555.png" alt="image-20241020222628555"></p>
<h3 id="事务传播行为控制"><a href="#事务传播行为控制" class="headerlink" title="事务传播行为控制"></a>事务传播行为控制</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013341344#item-2-2">(1) java - Spring事务传播行为详解 - 个人文章 - SegmentFault 思否</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020222917510.png" alt="image-20241020222917510"></p>
<p>transfer、AccountDao中所有的数据层方法、日志记录的业务方法都加了Transacitonal注解。</p>
<ul>
<li>transfer作为方法的调用者，是事务的管理员。</li>
<li>其他作为被调用者，是事务的协调员。</li>
<li>如果默认设置Required，管理员开事务，协调员都会加入</li>
</ul>
<p><code>@Transactional(propagation = Propagation.REQUIRES_NEW)</code></p>
<p>开启事务：<code>@Transactional</code></p>
<p>管理员肯定要开启事务，管理员默认是<code>REQUIRED</code>一般不用改，某一个协调员要单开另外一个事务，那么就可以把这个协调员的事务传播机制改成<code>REQUIRES_NEW</code> </p>
<h4 id="Propagation-REQUIRED"><a href="#Propagation-REQUIRED" class="headerlink" title="Propagation.REQUIRED"></a>Propagation.REQUIRED</h4><p><strong>外围方法未开启事务的情况下<code>Propagation.REQUIRED</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</strong> </p>
<p><strong>在外围方法开启事务的情况下<code>Propagation.REQUIRED</code>修饰的内部方法会加入到外围方法的事务中，所有<code>Propagation.REQUIRED</code>修饰的内部方法和外围方法均属于同一事务，只要一个方法回滚，整个事务均回滚。</strong></p>
<h4 id="Propagation-REQUIRES-NEW"><a href="#Propagation-REQUIRES-NEW" class="headerlink" title="Propagation.REQUIRES_NEW"></a>Propagation.REQUIRES_NEW</h4><p><strong>外围方法未开启事务的情况下<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</strong> </p>
<p><strong>在外围方法开启事务的情况下<code>Propagation.REQUIRES_NEW</code>修饰的内部方法依然会单独开启独立事务，且与外部方法事务也独立，内部方法之间、内部方法和外部方法事务均相互独立，互不干扰。</strong></p>
<h2 id="事务失效"><a href="#事务失效" class="headerlink" title="事务失效"></a>事务失效</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hanjiaqian/article/details/120501741">spring 事务失效的 12 种场景_spring 截获duplicatekeyexception 不抛异常-CSDN博客</a></p>
<ul>
<li>访问权限，private,default无法生效</li>
<li>方法用final或static修饰，代理对象无法重写</li>
<li>多线程调用事务方法，两个线程获取的不是同一个连接</li>
<li>数据库或表不支持事务（MySQL的MyISAM不支持事务）</li>
<li>未开启事务或未将类纳入Spring管理<code>@Transactional</code> <code>@Service</code> </li>
</ul>
<h3 id="方法自调用"><a href="#方法自调用" class="headerlink" title="方法自调用"></a><span id="selfinvoke">方法自调用</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        updateStatus(userModel);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateStatus</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">        doSameThing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到在事务方法 add 中，直接调用事务方法 updateStatus。从前面介绍的内容可以知道，updateStatus 方法拥有事务的能力是因为 spring aop 生成代理对象proxy，但是这种方法直接调用了 this 对象的方法，所以 updateStatus 方法不会生成事务。</p>
<p>由此可见，在同一个类中的方法直接内部调用，会导致事务失效。</p>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><p>Java实现MVC模型的web框架，灵活性强，主要进行<strong>表现层开发</strong> Controller。</p>
<h3 id="导坐标"><a href="#导坐标" class="headerlink" title="导坐标"></a>导坐标</h3><h3 id="bean创建-Controller"><a href="#bean创建-Controller" class="headerlink" title="bean创建@Controller"></a>bean创建@Controller</h3><h4 id="方法级别注解-请求映射-RequestMapping"><a href="#方法级别注解-请求映射-RequestMapping" class="headerlink" title="方法级别注解 请求映射 @RequestMapping"></a>方法级别注解 请求映射 @RequestMapping</h4><h4 id="方法级别注解-设置响应-ResponseBody"><a href="#方法级别注解-设置响应-ResponseBody" class="headerlink" title="方法级别注解 设置响应 @ResponseBody"></a>方法级别注解 设置响应 @ResponseBody</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021161644841.png" alt="image-20241021161644841"></p>
<p>都是方法级别注解    </p>
<h3 id="创建SpringMvcConfig-Configuration-ComponentScan"><a href="#创建SpringMvcConfig-Configuration-ComponentScan" class="headerlink" title="创建SpringMvcConfig@Configuration@ComponentScan"></a>创建SpringMvcConfig@Configuration@ComponentScan</h3><p>扫描到controller</p>
<h3 id="创建servlet容器Config"><a href="#创建servlet容器Config" class="headerlink" title="创建servlet容器Config"></a>创建servlet容器Config</h3><p>ServletContainerInitConfig继承AbstractDispatcherServeltInitializer类重写对应方法。都是一次性</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021161341011.png" alt="image-20241021161341011"></p>
<ul>
<li><code>getServletMappings</code> 表示接管URL的那个部分的映射</li>
<li><code>createRootApplicationContext</code> 创建Spring Framework容器并指定配置    </li>
<li><code>createServletApplicationContext</code> 创建web容器并指定配置</li>
<li>web容器 <strong>servlet容器</strong></li>
</ul>
<h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021162133487.png" alt="image-20241021162133487"></p>
<h3 id="bean加载-ComponentScan-Filter"><a href="#bean加载-ComponentScan-Filter" class="headerlink" title="bean加载@ComponentScan.Filter"></a>bean加载@ComponentScan.Filter</h3><p><u>Spring避免加载springmvc的controller</u></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021162700082.png" alt="image-20241021162700082"></p>
<p>导包：mybatis自动代理会返回dao接口的实现对象，可以不写，但是其他技术不一定是这样，所以为了通用性还是应该导dao</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021164147565.png" alt="image-20241021164147565"></p>
<p>SpringConfig扫描排除含有Controller注解的类：<strong>Filter</strong> 可以更细粒度地加载bean</p>
<p>exclude排除</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021164311077.png" alt="image-20241021164311077"></p>
<p>加了configuration的类，spring都会将其作为配置类，里面如果有componentScan，就会扫上。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021164930504.png" alt="image-20241021164930504"></p>
<p>创建容器设定配置再去返回容器，简化过程只需要指定类的字节码即可</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021165128160.png" alt="image-20241021165128160"></p>
<h2 id="配置Controller"><a href="#配置Controller" class="headerlink" title="配置Controller"></a>配置Controller</h2><h3 id="请求Request相关"><a href="#请求Request相关" class="headerlink" title="请求Request相关"></a>请求Request相关</h3><h4 id="请求映射路径-RequestMapping"><a href="#请求映射路径-RequestMapping" class="headerlink" title="请求映射路径@RequestMapping"></a>请求映射路径@RequestMapping</h4><p>对于不同的controller可能会优相同方法，这时会有冲突问题，解决办法是在controller**<mark>类<mark><strong>上加一个@RequestMapping，要和</strong><mark>方法<mark>**的@RequestMapping注解结合一下。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021172423291.png" alt="image-20241021172423291"></p>
<h4 id="名称匹配-指定请求参数名-RequestParam"><a href="#名称匹配-指定请求参数名-RequestParam" class="headerlink" title="名称匹配 指定请求参数名@RequestParam"></a>名称匹配 指定<mark>请求参数<mark>名@RequestParam</h4><p>用于接收GET请求中URL的查询参数，也可以接收POST请求的参数（表单）</p>
<blockquote>
<p>You can use the <code>@RequestParam</code> annotation to bind Servlet request parameters (that is, query parameters or form data) to a method argument in a controller.</p>
</blockquote>
<p>与mybatis类似，对于外部传进来的请求参数用map封装，因此**@RequestParam接收的是key-value形式的参数<strong>，</strong>发送get请求**只会处理URL中的参数，忽略请求体中的数据</p>
<p><strong>发送post请求</strong>时，<mark>表单数据在请求体中<mark>，不过仍然是username=root这样键值对的形式存在，如果URL里有请求参数，服务端收到以后会一并加到map中，打印出来，即使方法里的参数只是一个String也能打印出来</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021220731172.png" alt="image-20241021220731172"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021220755961.png" alt="image-20241021220755961" style="zoom:150%;" /></p>
<p>@RequestParam XXX xxx 表示查询参数用XXX类型接</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43606226/article/details/106545024">SpringMvc--@RequestBody和@RequestParam注解以及不加注解接收参数的区别_不写接收参数的注解,默认使用什么的-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_12393361/5021343">解决mybatis不加@Param报错 org.apache.ibatis.binding.BindingException_51CTO博客_mybatis @Param</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zeng1994/p/9110632.html">记一次SpringMVC碰到的坑 - zeng1994 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as513385/article/details/93512699">关于SpringMvc使用时,不加@RequestParam注解,根据方法形参名也可以获取请求值的分析_spring 请求体不写注解-CSDN博客</a></p>
<p>和 <strong>MyBatis</strong> 一样，使用反射机制获取参数名称，JDK8以后 java.lang.reflect.Parameter 中能够获取参数相关信息，框架就是利用这个机制，不加RequestParam获取参数信息。不然就只有arg0 arg1这种形式。</p>
<ul>
<li>required参数 是否为必传参数，默认必传</li>
<li>defaultValue 参数默认值</li>
</ul>
<h4 id="传递多种类型的请求参数"><a href="#传递多种类型的请求参数" class="headerlink" title="传递多种类型的请求参数"></a>传递多种类型的<mark>请求参数<mark></h4><p>与mybatis类似</p>
<ul>
<li><p>pojo：直接使用pojo内部的字段名称</p>
</li>
<li><p>嵌套pojo：address.字段名称</p>
</li>
<li><p>数组：直接接收字符串数组即可，请求的参数名就是数组的形参名，会把数组当成一个独立的参数</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021192646729.png" alt="image-20241021192646729"></p>
</li>
<li><p>集合类型：加RequestParam注解。 因为集合属于<strong>引用类型</strong>，spring会把它当成pojo处理（造pojo然后根据字段名注入依赖），不加param注解，spring就不会像数组一样把他当成一个独立的参数。</p>
</li>
</ul>
<h5 id="传JSON-EnableWebMvc"><a href="#传JSON-EnableWebMvc" class="headerlink" title="传JSON @EnableWebMvc"></a>传JSON @<mark>EnableWebMvc<mark></h5><p>导坐标 webMvc</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021193842326.png" alt="image-20241021193842326"></p>
<h6 id="参数在请求体里-RequestBody"><a href="#参数在请求体里-RequestBody" class="headerlink" title="参数在请求体里@RequestBody"></a>参数在请求体里@RequestBody</h6><p>@RequestBody XXX xxx 表示请求体中的数据用XXX类型接</p>
<p>RequestBody请求体中的数据通常是以JSON、XML等格式发送的，可以将请求体中的数据自动绑定到指定的Java对象上。</p>
<ol>
<li>参数写在请求体里，用List接收json数组</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021194047781.png" alt="image-20241021194047781"></p>
<ol start="2">
<li>用Pojo类接单个pojo对象json</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021194303198.png" alt="image-20241021194303198"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021194445000.png" alt="image-20241021194445000"></p>
<ol start="3">
<li>用List<pojo>接收多个pojo对象的json，</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021194340592.png" alt="image-20241021194340592"></p>
<p>一个请求，只有一个RequestBody；一个请求，可以有多个RequestParam。</p>
<p><strong>Body vs Param:</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021222507281.png" alt="image-20241021222507281"></p>
<h5 id="日期参数格式化-DateTimeFormat-pattern-”yyyy-MM-dd”"><a href="#日期参数格式化-DateTimeFormat-pattern-”yyyy-MM-dd”" class="headerlink" title="日期参数格式化@DateTimeFormat(pattern=”yyyy-MM-dd”)"></a>日期参数格式化@DateTimeFormat(pattern=”yyyy-MM-dd”)</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021223057976.png" alt="image-20241021223057976"></p>
<p>默认yyyy/MM/dd 其他形式不认识，需要自己手动指明formatPattern</p>
<h5 id="Converter接口-将字符串参数转换成Java类型"><a href="#Converter接口-将字符串参数转换成Java类型" class="headerlink" title="Converter接口-将字符串参数转换成Java类型"></a>Converter接口-将字符串参数转换成Java类型</h5><p>请求里面的参数都是以字符串形式发来的，converter要根据形参类型，把字符串转成对应类型提供给方法，这就是为什么前面能把字符串12按照需求转换成int 12</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021223621200.png" alt="image-20241021223621200"></p>
<p>@EnableWebMvc</p>
<h3 id="响应Response相关"><a href="#响应Response相关" class="headerlink" title="响应Response相关"></a>响应Response相关</h3><h4 id="响应页面（跳转页面）"><a href="#响应页面（跳转页面）" class="headerlink" title="响应页面（跳转页面）"></a>响应页面（跳转页面）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toPage&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toJumpPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接在方法里 return “page.jsp” </p>
<p>Spring默认认为Controller的方法返回的就是一个页面</p>
<h4 id="响应文本数据-ResponseBody"><a href="#响应文本数据-ResponseBody" class="headerlink" title="响应文本数据@ResponseBody"></a>响应文本数据@ResponseBody</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021225227708.png" alt="image-20241021225227708"></p>
<p>如果直接return一个字符串Spring会认为这个字符串是一个网页，响应分为响应行响应头和响应体，响应头里是放状态码之类的，只能在响应体里返回数据，加@ResponseBody注解表示返回值就是响应体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toText&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toText</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//表示返回 page.jsp 这个字符串</span></span><br></pre></td></tr></table></figure>

<h4 id="响应POJO对象-JSON形式"><a href="#响应POJO对象-JSON形式" class="headerlink" title="响应POJO对象(JSON形式)"></a>响应POJO对象(JSON形式)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toJsonPOJO&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">toJsonPOJO</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;返回json对象数据&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">15</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接返回user即可，jackson帮我们做的</p>
<h5 id="响应POJO对象集合（JSON数组）"><a href="#响应POJO对象集合（JSON数组）" class="headerlink" title="响应POJO对象集合（JSON数组）"></a>响应POJO对象集合（JSON数组）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toJsonList&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">toJsonList</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;返回json集合数据&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user1.setName(<span class="string">&quot;传智播客&quot;</span>);</span><br><span class="line">    user1.setAge(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user2.setName(<span class="string">&quot;黑马程序员&quot;</span>);</span><br><span class="line">    user2.setAge(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">    userList.add(user1);</span><br><span class="line">    userList.add(user2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="HttpMessageConverter接口"><a href="#HttpMessageConverter接口" class="headerlink" title="HttpMessageConverter接口"></a>HttpMessageConverter接口</h5><p>POJO转JSON字符串</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021225843796.png" alt="image-20241021225843796"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021225823024.png" alt="image-20241021225823024"></p>
<h3 id="REST-风格"><a href="#REST-风格" class="headerlink" title="REST 风格"></a>REST 风格</h3><p><strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021230252993.png" alt="image-20241021230252993"></p>
<p>根据请求的方式区分 GET POST PUT DELETE</p>
<p>同一URL，请求方式不同，调用的方法也不同</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021230150675.png" alt="image-20241021230150675"></p>
<p>RESTful：用REST风格访问资源</p>
<h4 id="RequestMapping-加-method-参数"><a href="#RequestMapping-加-method-参数" class="headerlink" title="@RequestMapping 加 method 参数"></a>@RequestMapping 加 method 参数</h4><p><code>@RequestMapping(value = &quot;/users/&#123;id&#125;&quot; ,method = RequestMethod.DELETE)</code> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021231918974.png" alt="image-20241021231918974"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021231836548.png" alt="image-20241021231836548"></p>
<h5 id="URL占位符传参-PathVariable"><a href="#URL占位符传参-PathVariable" class="headerlink" title="URL占位符传参 @PathVariable"></a>URL占位符传参 <mark>@PathVariable<mark></h5><p>value=”/users/{id}”  URL中的{id}和用@PathVariable修饰的方法参数id是一致的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021231846312.png" alt="image-20241021231846312"></p>
<h5 id="RequestBody-RequestParam-PathVariable"><a href="#RequestBody-RequestParam-PathVariable" class="headerlink" title="@RequestBody@RequestParam@PathVariable"></a>@RequestBody@RequestParam@PathVariable</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021232010983.png" alt="image-20241021232010983"></p>
<h4 id="RESTful-快速开发"><a href="#RESTful-快速开发" class="headerlink" title="RESTful 快速开发"></a><mark>RESTful 快速开发<mark></h4><h5 id="类级别注解-RequestMapping"><a href="#类级别注解-RequestMapping" class="headerlink" title="类级别注解 @RequestMapping"></a>类级别注解 @RequestMapping</h5><p>省去所有user前缀，写一次就好。</p>
<h5 id="类级别注解-RestController"><a href="#类级别注解-RestController" class="headerlink" title="类级别注解 @RestController"></a>类级别注解 @RestController</h5><p>类级别的@RequestBody，表示所有类的返回值都是请求体的数据，既然@Controller和RequestBody都要写，合而为一即可</p>
<h5 id="方法级别注解-PostMapping"><a href="#方法级别注解-PostMapping" class="headerlink" title="方法级别注解 @PostMapping"></a>方法级别注解 @PostMapping</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot; ,method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/&#123;id&#125;&quot;)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021232955549.png" alt="image-20241021232955549"></p>
<h4 id="RESTful-页面交互案例"><a href="#RESTful-页面交互案例" class="headerlink" title="RESTful 页面交互案例"></a>RESTful 页面交互案例</h4><p>RestController PostMapping GetMapping DeleteMapping PutMapping </p>
<p>方法参数RequestBody</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021235556399.png" alt="image-20241021235556399"></p>
<h5 id="Config-类-SpringMvcSupport-放行静态页面访问"><a href="#Config-类-SpringMvcSupport-放行静态页面访问" class="headerlink" title="Config 类 SpringMvcSupport 放行静态页面访问"></a>Config 类 SpringMvcSupport 放行静态页面访问</h5><p>@Configuration</p>
<p>默认SpringMvcConfig接管/后所有东西，通过ResourceHandlerRegistry 设置SpringMVC如何处理对静态资源的访问 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021235616215.png" alt="image-20241021235616215"></p>
<h5 id="前端ajax"><a href="#前端ajax" class="headerlink" title="前端ajax"></a>前端ajax</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021235623670.png" alt="image-20241021235623670"></p>
<h2 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h2><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><h3 id="整合Config包"><a href="#整合Config包" class="headerlink" title="整合Config包"></a>整合Config包</h3><h4 id="SpringConfig"><a href="#SpringConfig" class="headerlink" title="SpringConfig"></a>SpringConfig</h4><p><code>Configuration</code> <code>ComponentScan</code> <code>Import</code></p>
<h5 id="MyBatisConfig-amp-JdbcConfig"><a href="#MyBatisConfig-amp-JdbcConfig" class="headerlink" title="MyBatisConfig &amp; JdbcConfig"></a>MyBatisConfig &amp; JdbcConfig</h5><p>JdbcConfig：数据源 DataSource Bean</p>
<p>MyBatisConfig：sqlSessionFactoryBean</p>
<p><code>Bean</code> <code>jdbc.properties</code> </p>
<h4 id="SpringMvcConfig"><a href="#SpringMvcConfig" class="headerlink" title="SpringMvcConfig"></a>SpringMvcConfig</h4><p><code>Configuration</code> <code>ComponentScan</code> <code>EnableWebMvc</code></p>
<h5 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h5><p>rootApplicationContext和webApplicationContext</p>
<h3 id="编写后端模块"><a href="#编写后端模块" class="headerlink" title="编写后端模块"></a>编写后端模块</h3><h4 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h4><p>实体类，User</p>
<h4 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h4><p>MyBatis Mapper自动代理，写接口，写方法结合注解</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022135643205.png" alt="image-20241022135643205"></p>
<p>占位符对应参数的名称，这里映射实体类中的字段信息     </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022135845990.png" alt="image-20241022135845990"></p>
<h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>BookDao@Autowired</p>
<p>dao接口加repository注解（可加可不加）</p>
<h4 id="RestController"><a href="#RestController" class="headerlink" title="RestController"></a>RestController</h4><p>参数在url中：PathVariable</p>
<p>参数在请求体：RequestBody</p>
<h4 id="JUnit-测试-Service"><a href="#JUnit-测试-Service" class="headerlink" title="JUnit 测试 Service"></a>JUnit 测试 Service</h4><h4 id="Postman-测试-Controller"><a href="#Postman-测试-Controller" class="headerlink" title="Postman 测试 Controller"></a>Postman 测试 Controller</h4><h4 id="Spring-事务激活"><a href="#Spring-事务激活" class="headerlink" title="Spring 事务激活"></a>Spring 事务激活</h4><p><code>JdbcConfig</code> 里 加PlatformTransactionManager Bean, 接dataSource参数</p>
<p><code>Service</code>接口添加@Transactional</p>
<h3 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h3><h4 id="表现层数据封装模型-设置统一的返回结果集Result"><a href="#表现层数据封装模型-设置统一的返回结果集Result" class="headerlink" title="表现层数据封装模型 - 设置统一的返回结果集Result"></a>表现层数据封装模型 - 设置统一的返回结果集Result</h4><p>实际开发过程中前后端<mark>约定<mark></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">//下方提供若干构造方法,有参无参</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code,Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code, Object data, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....getter setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022152253512-1729581786093-1.png" alt="image-20241022152253512"></p>
<h5 id="Result-data"><a href="#Result-data" class="headerlink" title="Result.data"></a>Result.data</h5><p>业务方法不同返回数据格式也不同，可能是true false这样的text，也可能是json数据，还可能是json数组，约定将数据封装到<mark>data<mark>字段中</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022144637267.png" alt="image-20241022144637267"></p>
<h5 id="Result-code"><a href="#Result-code" class="headerlink" title="Result.code"></a>Result.code</h5><p>不同业务方法可能会返回相同的内容，返回一个true可能对应新增，修改，删除的业务方法，加一个识别码<mark>code<mark>字段区分 ，可以约定尾数是0表示失败，尾数是1表示成功：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022145108783.png" alt="image-20241022145108783"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SAVE_OK</span> <span class="operator">=</span> <span class="number">20011</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DELETE_OK</span> <span class="operator">=</span> <span class="number">20021</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">UPDATE_OK</span> <span class="operator">=</span> <span class="number">20031</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">GET_OK</span> <span class="operator">=</span> <span class="number">20041</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SAVE_ERR</span> <span class="operator">=</span> <span class="number">20010</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DELETE_ERR</span> <span class="operator">=</span> <span class="number">20020</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">UPDATE_ERR</span> <span class="operator">=</span> <span class="number">20030</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">GET_ERR</span> <span class="operator">=</span> <span class="number">20040</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里Result的构造器识别的是Integer code</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Enum枚举：CodeEnum是一个类，类内部有一字段code(Integer)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022152238169.png" alt="image-20241022152238169"></p>
<h5 id="Result-message"><a href="#Result-message" class="headerlink" title="Result.message"></a>Result.message</h5><p>一些业务方法，本来应该返回json，没查到只能返回null，不能直接把null展示给用户看，展示的是message信息</p>
<h5 id="Controller-返回值统一设定为-Result"><a href="#Controller-返回值统一设定为-Result" class="headerlink" title="Controller 返回值统一设定为 Result"></a>Controller 返回值统一设定为 Result</h5><p>将返回值封装到Result中，data</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Book&gt; bookList = bookService.getAll();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> bookList != <span class="literal">null</span> ? Code.GET_OK : Code.GET_ERR;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> bookList != <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;数据查询失败，请重试！&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(code,bookList,msg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//data字段是否为null？</span></span><br></pre></td></tr></table></figure>

<h4 id="返回数据格式统一-异常处理器-RestControllerAdvice"><a href="#返回数据格式统一-异常处理器-RestControllerAdvice" class="headerlink" title="返回数据格式统一 - 异常处理器@RestControllerAdvice"></a>返回数据格式统一 - 异常处理器<mark>@RestControllerAdvice<mark></h4><ul>
<li><p><mark>类级别注解<mark></p>
</li>
<li><p>后端抛出的异常如果不处理，就会抛到前端页面，不美观，并且不会返回任何数据，导致<mark>数据不统一<mark> </p>
</li>
<li><p>要让WebMvcConfig扫到这个Advice类</p>
</li>
</ul>
<h5 id="常见异常诱因"><a href="#常见异常诱因" class="headerlink" title="常见异常诱因"></a>常见异常诱因</h5><ul>
<li><strong>框架内部抛出的异常</strong>:因使用不合规导致</li>
<li><strong>数据层抛出的异常</strong>:因外部服务器故障导致(例如:服务器访问超时)</li>
<li><strong>业务层抛出的异常</strong>:因业务逻辑书写错误导致(例如:遍历业务书写操作，导致索引异常等)</li>
<li><strong>表现层抛出的异常</strong>:因数据收集、校验等规则导致(例如:不匹配的数据类型间导致异常)</li>
<li><strong>工具类抛出的异常</strong>:因工具类书写不严谨不够健壮导致(例如:必要释放的连接长期未释放等)</li>
</ul>
<p><u>处理方法</u>：全部抛到表现层Controller —— AOP 编程，<strong>用最少量的代码实现最强大的功能</strong>，快速统一地处理异常 </p>
<h5 id="方法级别注解-处理具体类别的异常-ExceptionHandler"><a href="#方法级别注解-处理具体类别的异常-ExceptionHandler" class="headerlink" title="方法级别注解 处理具体类别的异常@ExceptionHandler"></a>方法级别注解 处理具体类别的异常<mark>@ExceptionHandler<mark></h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022153703868.png" alt="image-20241022153703868"></p>
<p>处理异常返回的结果也要封装成Result</p>
<h3 id="项目异常处理方案-捕获异常并返回Result"><a href="#项目异常处理方案-捕获异常并返回Result" class="headerlink" title="项目异常处理方案 (捕获异常并返回Result)"></a>项目异常处理方案 (捕获异常并返回Result)</h3><h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><ul>
<li><strong>业务异常 BusinessException</strong> 可预期<ul>
<li>发送对应消息，提醒用户规范操作</li>
</ul>
</li>
<li><strong>系统异常 SystemException</strong> <ul>
<li>发送固定消息，安抚用户</li>
<li>发送特定消息给运维，提醒维护</li>
<li>记录日志</li>
</ul>
</li>
<li><strong>其他异常 Exception</strong><ul>
<li>发送固定消息，安抚用户</li>
<li>发送特定消息给开发，提醒维护（纳入预期范围）</li>
<li>记录日志</li>
</ul>
</li>
</ul>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022154704744.png" alt="image-20241022154704744"></p>
<h5 id="继承RuntimeException"><a href="#继承RuntimeException" class="headerlink" title="继承RuntimeException"></a>继承RuntimeException</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022155606802.png" alt="image-20241022155606802"></p>
<p>加一个code属性（getter setter），重写RuntimeException的方法。异常构造的时候需要用到这些构造器，包装返回数据要用到code和message</p>
<p>建议放在源根的exception包下面</p>
<h5 id="异常代码扩充"><a href="#异常代码扩充" class="headerlink" title="异常代码扩充"></a>异常代码扩充</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022160311854.png" alt="image-20241022160311854"></p>
<h5 id="触发异常"><a href="#触发异常" class="headerlink" title="触发异常"></a>触发异常</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022160332391.png" alt="image-20241022160332391"></p>
<h5 id="拦截并处理异常-返回Result"><a href="#拦截并处理异常-返回Result" class="headerlink" title="拦截并处理异常 返回Result"></a>拦截并处理异常 返回Result</h5><p>在RestControllerAdvice下方的类中处理对应类型的异常，将异常继续封装成Result返回</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022160546843.png" alt="image-20241022160546843"></p>
<h3 id="放行静态资源配置"><a href="#放行静态资源配置" class="headerlink" title="放行静态资源配置"></a>放行静态资源配置</h3><h4 id="SpringMvcSupport（Config类）"><a href="#SpringMvcSupport（Config类）" class="headerlink" title="SpringMvcSupport（Config类）"></a>SpringMvcSupport（Config类）</h4><p>加Configuration注解，继承WebMvcConfigurationSupport类，重写resourceHandler方法</p>
<h4 id="Config包详解"><a href="#Config包详解" class="headerlink" title="Config包详解"></a><mark>Config包详解<mark></h4><h5 id="ServletContainersInitializerConfig-Servlet容器配置类"><a href="#ServletContainersInitializerConfig-Servlet容器配置类" class="headerlink" title="ServletContainersInitializerConfig (Servlet容器配置类)"></a>ServletContainersInitializerConfig (Servlet容器配置类)</h5><p>用来构建ServletContext，继承自 AbstractDispatcherServletInitializer，Spring MVC是建立在 DispatcherServlet 基础之上的，每一个请求最先访问的都是它，负责转发每一个Request请求，所以是必不可少的。</p>
<p>先以 <mark>Abstract<u>DispatcherServlet</u>Initializer<mark> 为例介绍这个加载Config类的职责 具体介绍在<a href="#webappinit">下方</a></p>
<h6 id="a-createRootApplicationContext"><a href="#a-createRootApplicationContext" class="headerlink" title="a. createRootApplicationContext"></a>a. createRootApplicationContext</h6><p>需要加载Spring IoC容器的配置类(SpringConfig)，返回配置好的 <a href="#wac">Root WAC</a> </p>
<h6 id="b-createServletApplicationContext"><a href="#b-createServletApplicationContext" class="headerlink" title="b.createServletApplicationContext"></a>b.createServletApplicationContext</h6><p>需要加载WebMvc容器的配置类(SpringMvcConfig) 返回配置好的 <a href="#swac">Servlet WAC</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022205635235.png" alt="image-20241022205635235"></p>
<h6 id="c-getServletMappings"><a href="#c-getServletMappings" class="headerlink" title="c.getServletMappings"></a>c.getServletMappings</h6><p>配置由此DispatcherServlet接管的URL映射路径</p>
<h5 id="SpringConfig-Configuration"><a href="#SpringConfig-Configuration" class="headerlink" title="SpringConfig(@Configuration)"></a>SpringConfig(@Configuration)</h5><p><u>对应applicationContext.xml</u>，配置 <a href="#wac">Root WAC</a>  </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zzjlxy-225223/p/12611093.html">applicationContext.xml及spring-servlet.xml详解 - 长木木弓 - 博客园 (cnblogs.com)</a>  </p>
<p>注解开发用来替代传统的XML配置文件，因此可以透过xml与注解的映射关系来了解，<code>@Configuration</code>用来替代<code>&lt;beans&gt;</code> <code>&lt;/beans&gt;</code> 在应用启动时，Spring 会自动扫描并加载所有带有 <code>@Configuration</code> 注解的类，根据<code>@ComponentScan</code>扫描要加入的<code>@Component</code>(代替<code>&lt;bean&gt;</code> <code>&lt;/bean&gt;</code>)，最终创建出对应的容器(Context) </p>
<h6 id="Import-MyBatisConfig-class-JdbcConfig-class"><a href="#Import-MyBatisConfig-class-JdbcConfig-class" class="headerlink" title="@Import({MyBatisConfig.class,JdbcConfig.class})"></a>@Import({MyBatisConfig.class,JdbcConfig.class})</h6><p><code>MyBatisConfig</code> 和 <code>JdbcConfig</code>中方法级别注解<code>@Bean</code>用来替代 <code>&lt;bean&gt;</code> <code>&lt;/bean&gt;</code> 标签（表示方法返回的对象当成Bean/Component交给Spring容器管理）虽然没有加<code>Configuration</code>注解，但是会由<code>SpringConfig</code> <code>@Import</code>，导入的还是SpringConfig配置的容器，属于 <a href="#wac">Root WAC</a> </p>
<h5 id="SpringMvcConfig-Configuration-EnableWebMvc"><a href="#SpringMvcConfig-Configuration-EnableWebMvc" class="headerlink" title="SpringMvcConfig(@Configuration @EnableWebMvc)"></a>SpringMvcConfig(@Configuration @EnableWebMvc)</h5><p><u>对应spring-servlet.xml</u>，配置 <a href="#swac">Servlet WAC</a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/EnableWebMvc.html">@EnableWebMvc (Spring Framework 6.1.14 API)</a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurationSupport.html">WebMvcConfigurationSupport (Spring Framework 6.1.14 API)</a>  (WMCS)</p>
<ul>
<li><p><code>@EnableWebMvc</code> 会通过导入 <code>WMCS</code> 完成 Spring MVC 默认配置的添加，<strong>只有一个类能拥有此注解</strong> </p>
</li>
<li><p>不写 <code>@EnableWebMvc</code> 直接继承 WMCS 也可以实现相同效果</p>
</li>
<li><p>自定义具体某项WebMvc配置：<code>extends WebMvcConfigurer</code> 允许多个WebMvcConfigurer存在，但是具有一定侵入性</p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023210351697.png" alt="image-20241023210351697"></p>
<ul>
<li>主要Config：<code>@EnableWebMvc</code> + 继承 <code>WebMvcConfigurer</code> 重写方法 + <code>@ComponentScan</code> 其他Config类</li>
<li>次要Config：继承 <code>WebMvcConfigurer</code>重写方法+@Configuration确保被主要Config扫描到</li>
<li>没有暴露高级设置，如果需要高级设置 需要第二种方式直接继承 WMCS 来做更高级别的配置，此时要移除@Enable注解</li>
</ul>
<h6 id="SpringMvcSupport-Configuration"><a href="#SpringMvcSupport-Configuration" class="headerlink" title="SpringMvcSupport(@Configuration)"></a>SpringMvcSupport(@Configuration)</h6><p><u>对应springMvcContext.xml</u>，配置 <a href="#swac">Servlet WAC</a> </p>
<ul>
<li>继承WMCS，完成对SpringMVC的默认配置，重写resourceHandler方法，实现在默认配置基础上的自定义。</li>
<li>案例中的SMS是配置类，用于配置容器，被SMC扫config包扫到了，此时SMS这里的自定义配置会覆盖SMC的Enable注解</li>
</ul>
<h3 id="前端逻辑"><a href="#前端逻辑" class="headerlink" title="前端逻辑"></a>前端逻辑</h3><p>查询： get请求</p>
<p>保存/添加：post请求</p>
<p>新增要弹出表单，添加成功要关闭表单并<strong>清空表单数据</strong>，不论成功与否finallyGetAll回显 ，按照识别码判别成功与否</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023190220059.png" alt="image-20241023190220059"></p>
<p>修改：put请求</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023191646261.png" alt="image-20241023191646261"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023191751771.png" alt="image-20241023191751771"></p>
<p>删除：delete请求</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023191526268.png" alt="image-20241023191526268"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023191952545.png" alt="image-20241023191952545"></p>
<h3 id="容器之间的嵌套关系-概念解释-源码解析"><a href="#容器之间的嵌套关系-概念解释-源码解析" class="headerlink" title="容器之间的嵌套关系 + 概念解释 (源码解析)"></a>容器之间的嵌套关系 + 概念解释 (源码解析)</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022175254007-1729595662475-3.png" alt="image-20241022175254007"></p>
<h4 id="WebApplicationContext-WAC"><a href="#WebApplicationContext-WAC" class="headerlink" title="WebApplicationContext(WAC)"></a><span id="wac">WebApplicationContext(WAC)</span></h4><ul>
<li>ApplicationContext(AC) 表示整个 Spring 应用的上下文。WAC是普通AC的扩展，它具有Web应用程序所需的一些额外功能，比如可以<u>get</u>ServletContext或者<u>set</u>ServletContext</li>
<li><code>Root WAC</code>在应用启动时首先被加载，并且作为父上下文，供表示层使用，主要负责管理服务层（Service）、数据访问层（DAO）、中间件配置等非 Web 层（表示层）的 Bean</li>
</ul>
<h4 id="Servlet-WebApplicationContext-Servlet-WAC"><a href="#Servlet-WebApplicationContext-Servlet-WAC" class="headerlink" title="Servlet WebApplicationContext(Servlet WAC)"></a><span id="swac">Servlet WebApplicationContext(Servlet WAC)</span></h4><ul>
<li><code>Servlet WAC</code> 是 <code>Root WAC</code> 的<strong>子上下文</strong>，专门用于处理表示层的 Bean 和配置。比如控制器（<code>Controller</code>）、视图解析器、拦截器(<code>Interceptor</code>)等</li>
<li>每个 <code>DispatcherServlet</code> 实例会有一个独立的 <code>Servlet WAC</code> </li>
</ul>
<h5 id="Parent-amp-Child-ApplicatitonContext"><a href="#Parent-amp-Child-ApplicatitonContext" class="headerlink" title="Parent &amp; Child ApplicatitonContext"></a>Parent &amp; Child ApplicatitonContext</h5><p>Root WAC 作为 所有 Servlet WAC 的 Parent，DispatherServlet在创建属于自己的ServletContext的getAttribute方法来判断是否存在Root WebApplicationContext。如果存在，则将其设置为自己的parent。这就是父子上下文(父子容器)的概念，getParentBeanFactory。</p>
<p>对于作用范围而言，在DispatcherServlet中可以引用由ContextLoaderListener所创建的RootWAC中的内容，而反过来不行。当Spring在执行ApplicationContext的getBean时，如果在自己context中找不到对应的bean，则会在父ApplicationContext中去找。这也解释了为什么我们可以在DispatcherServlet中获取到RootWAC中的bean。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023154504980.png" alt="image-20241023154504980"></p>
<h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><ul>
<li>Servlet容器（Tomcat）在启动一个web应用时，根据web.xml 会为整个应用创建一个<mark>唯一<mark>的ServletContext(SC)对象，应用内部所有的Servlet共享同一个SC。</li>
<li>ServletContext是Servlet与Servlet容器（Tomcat）之间直接通信的接口。</li>
<li>容器中的Servlet可以通过它来访问容器中的各种资源</li>
<li>ServletContext跟XML一样，由Attributes组成，要访问资源就要通过字符串name访问，可以通过<code>void setAttribute(name, object) </code>来将ServletContext与你的object绑定，<code>Object getAttribute(name)</code>可以得到object</li>
<li><code>Enumeration&lt;String&gt; getInitParameterNames()</code> 获取所有 <code>&lt;context-param/&gt;</code> 参数的名称 字符串枚举</li>
<li><code> String getInitParameter(name)</code> 根据name获取指定的 <code>&lt;context-param/&gt;</code> 参数值</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023013135254.png" alt="image-20241023013135254"></p>
<h5 id="Root-WAC-Servlet-WAC-ServletContext之间的关系"><a href="#Root-WAC-Servlet-WAC-ServletContext之间的关系" class="headerlink" title="Root WAC, Servlet WAC, ServletContext之间的关系"></a>Root WAC, Servlet WAC, ServletContext之间的关系</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022230909096.png" alt="image-20241022230909096"></p>
<ul>
<li><p>Root WebApplicationContext存储key为<code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>，可以通过此Key访问Root WAC。</p>
</li>
<li><p>WebApplicationContextUtis工具类提供了从ServletContext获取RootWAC的方法：</p>
<ul>
<li><code>WebApplicationContextUtils.getWebApplicationContext(ServletContext sc)</code></li>
</ul>
</li>
<li><p>WAC提供了获取ServletContext的抽象方法 <code>getServletContext()</code> </p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E6%97%A0%E6%A0%87%E9%A2%98-1729654361571-5.png" alt="context"></p>
<h5 id="web-xml-配置-ServletContext"><a href="#web-xml-配置-ServletContext" class="headerlink" title="web.xml 配置 ServletContext"></a>web.xml 配置 ServletContext</h5><p>Tomcat创建web应用时，会构建ServletContext对象，根据web.xml中的配置把如下参数都存到ServletContext对象中，注册Listener，Servlet等</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line">    &lt;!—ServletContext自有的init 参数--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span>  </span><br><span class="line">        &lt;!—创建Root WAC所需要的配置文件路径--&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span>  </span><br><span class="line">  	</span><br><span class="line">    &lt;!—注册ContextLoaderListener--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line">    &lt;!—注册DispatcherServlet ServletConfig--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span> </span><br><span class="line">        &lt;!—init Servlet所需参数--&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">            &lt;!—创建Servlet WAC所需参数--&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/spring-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line">        &lt;!—指定某个servlet的URL映射路径--&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="ContextLoaderListener-创建-Root-WAC"><a href="#ContextLoaderListener-创建-Root-WAC" class="headerlink" title="ContextLoaderListener - 创建 Root WAC"></a>ContextLoader<mark>Listener<mark> - 创建 Root WAC</h4><ul>
<li><p>本质就是一个Listener，因此需要在web.xml中注册</p>
</li>
<li><p>实现了ServletContextListener接口，EventListener-&gt;ServletContextListener</p>
</li>
<li><p>继承了ContextLoader类，见名知意，是用来加载WAC的，有一个WAC参数context，所有方法都是围绕加工这个context字段进行的</p>
</li>
</ul>
<h5 id="WebApplicationContext-initWAC-ServletContext-sc"><a href="#WebApplicationContext-initWAC-ServletContext-sc" class="headerlink" title="WebApplicationContext initWAC(ServletContext sc)"></a>WebApplicationContext initWAC(ServletContext sc)</h5><p>ContextLoaer 接收一个ServletContext参数sc，调用initWAC方法返回加载好的WAC对象this.context</p>
<p>打印在服务器日志上 <code>servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);</code></p>
<p>中间调用<code>createWAC(ServletContext sc)</code>返回一个ConfigurableWAC对象，将其<strong>parentContext设置为sc</strong>，</p>
<p>再把这个CWAC和sc传给<code>configureAndRefreshWAC(CWAC cwac,ServletContext sc)</code>方法进行配置（ServletContext是根据web.xml构建的，根据key: contextConfigLocation找到RootWAC的配置文件<code>applicationContext.xml</code>）</p>
<p>之后在sc中创建一个Attribute，使得能通过ServletContext对这个Root WAC进行访问（键值对形式）</p>
<p><code>setAttribute(</code> <code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>, <code>this.context)</code></p>
<p>最终返回 <code>this.context</code> 作为 Root WAC</p>
<h5 id="WebApplicationContext-contextInitialized-ServletContextEvent-sce"><a href="#WebApplicationContext-contextInitialized-ServletContextEvent-sce" class="headerlink" title="WebApplicationContext contextInitialized(ServletContextEvent sce)"></a>WebApplicationContext contextInitialized(ServletContextEvent sce)</h5><p>ContextLoaderListener 能监听Web应用启动或关闭的事件（会修改ServletContext中的参数），触发contextInitializaed/contextDestroyed，创建或销毁Root WAC。</p>
<h4 id="DispatcherServlet-创建-Servlet-WAC"><a href="#DispatcherServlet-创建-Servlet-WAC" class="headerlink" title="DispatcherServlet - 创建 Servlet WAC"></a>Dispatcher<mark>Servlet<mark> - 创建 Servlet WAC</h4><ul>
<li><p>本质就是一个Servlet，所以需要在web.xml中注册，继承自HttpServlet-&gt;HttpServletBean-&gt;FrameworkServlet</p>
</li>
<li><p>Spring MVC 的核心前端控制器，用于处理所有进入的 HTTP 请求。将请求分发给适当的处理器（控制器 Controller），并在处理后将响应返回给客户端。</p>
</li>
<li><p>每一个 <code>DispatcherServlet</code> 都拥有自己的 <a href="#swac">Servlet WebApplicationContext</a>，管理与 Web 层(表现层)相关的 Bean，如控制器、视图解析器、拦截器等。</p>
</li>
<li><p>HttpServletBean有一个final的init()<strong>[Servlet的入口方法]</strong>  其中会调用抽象方法initServletBean()</p>
</li>
<li><p>FrameServlet实现了initServletBean(): <strong>[生成Servlet WAC，设置parent和ServletContext]</strong> 最后会调用initStrategies</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">var10000</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line"><span class="type">String</span> <span class="variable">var10001</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getSimpleName();</span><br><span class="line">var10000.log(<span class="string">&quot;Initializing Spring &quot;</span> + var10001 + <span class="string">&quot; &#x27;&quot;</span> + <span class="built_in">this</span>.getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"><span class="comment">//记录日志</span></span><br></pre></td></tr></table></figure>

<ul>
<li>同样的，途中也会调用自己的initWAC方法：<ul>
<li>调用WACUtils工具类，获得自己所在的ServletContext的<strong>Root WAC</strong> </li>
<li>将自己的WAC转换成CWAC，如果存在RootWAC，则将其设置为自己的parent</li>
<li>然后configureAndRefreshWAC(cwac)：设置ServletContext为sc，从其中ServletConfig中获取 <code>&lt;init-param&gt;</code> 参数的值</li>
</ul>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023013013442.png" alt="image-20241023013013442"></p>
<ul>
<li>最后根据自己的ServletConfig获取到ServletContext，根据自己的名称设置自己的Servlet WAC在ServletContext中的Key</li>
</ul>
</li>
<li><p>DispatcherServlet实现了initStrategies [生成各个功能组件，异常处理器，视图处理，请求映射]</p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/mvc-context-hierarchy.png" alt="mvc-context-hierarchy"></p>
<p>这两个context都是在ServletContext中，属于dispatcherServlet的上下文是servletWAC，找不到的话就去rootWAC中找</p>
<h4 id="替代web-xml，以Java形式配置ServletContext——WebApplicationInitializer"><a href="#替代web-xml，以Java形式配置ServletContext——WebApplicationInitializer" class="headerlink" title="替代web.xml，以Java形式配置ServletContext——WebApplicationInitializer"></a><span id="webappinit">替代web.xml，以Java形式配置ServletContext——WebApplicationInitializer</span></h4><p>![屏幕截图 2024-10-23 133904](<a target="_blank" rel="noopener" href="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/屏幕截图</a> 2024-10-23 133904.png)</p>
<h5 id="ServletContainerInitializer"><a href="#ServletContainerInitializer" class="headerlink" title="ServletContainerInitializer"></a>ServletContainerInitializer</h5><p>之前，web容器（Tomcat）会根据WEB-INF下的web.xml初始化ServletContext</p>
<p>Java EE Servlet 规范定义了这个接口，web容器（Tomcat）启动时根据这个初始化器做一些组件内的初始化工作。 </p>
<p><strong>SpringServletContainerInitializer</strong> 是Spring 对其的实现，其onStartup方法会调用 <strong><a href="#webappinit">WebApplicationInitializer</a></strong> 的onStartup(<strong>ServletContext sc</strong>)初始化Web应用</p>
<h4 id="SpringMVC-Web应用启动流程"><a href="#SpringMVC-Web应用启动流程" class="headerlink" title="SpringMVC Web应用启动流程"></a>SpringMVC Web应用启动流程</h4><ul>
<li>Tomcat 读取web.xml中 <code>&lt;context-param&gt;</code> <code>&lt;listener&gt;</code>  然后创建一个全局共享的ServletContext</li>
<li>Tomcat 将<code>&lt;context-param&gt;</code> <code>&lt;listener&gt;</code>转化为键值对，存到ServletContext </li>
<li>Tomcat 加载Listener实例，实施监听，Listener必须实现<u>ServletContext</u>Listener接口（比如ContextLoaderListener）</li>
<li><strong>Web项目继续启动中</strong>，触发Listener中的contextInitialized(ServletContexEvent event)，根据ServletContext中 <code>&lt;context-param&gt;</code> 部分创建父容器，configClass是类的形式，configLocation是xml配置文件的形式</li>
<li>创建完父容器，如果有<code>&lt;filter&gt;</code>会创建filter，然后读取 <code>&lt;servlet&gt;</code> 用于注册DispatcherServlet（这块流程建议从init方法一步步往下看，流程还是很清晰的），因为DispatcherServlet实质是一个Servlet，所以会先执行它的init方法。这个init()方法在<strong>HttpServletBean</strong>这个类中实现，其主要工作是做一些初始化工作，将我们在web.xml中配置的参数设置到ServletContext的ServletConfig中，然后再触发<strong>FrameworkServlet</strong>的initServletBean()方法；<ul>
<li><strong>FrameworkServlet</strong>主要作用是初始化Spring子容器，设置其父容器，并将其放入ServletContext中；</li>
<li><strong>FrameworkServlet</strong>在调用initServletBean()的过程中同时会触发<strong>DispatcherServlet</strong>的onRefresh()方法，这个方法会初始化Spring MVC的各个功能组件。比如异常处理器、视图处理器、请求映射处理等</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/54chensongxia/p/12522804.html">Spring MVC启动流程</a> </p>
<h5 id="100-code-based"><a href="#100-code-based" class="headerlink" title="100% code-based"></a>100% code-based</h5><p>用Java类的形式配置ServletContext，有一些细微差异，Spring这边实现了ServletContainerInitializer接口，注册组件的工作就交给了WebApplicationInitializer：</p>
<p>先根据指定的rootWacConfig配置类（SpringConfig）创建出父容器，父容器作为参数进行Listener的有参构造，最后以<mark>add<mark>Listener的方式注册到ServletContext中。</p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023193138396.png" alt="image-20241023193138396"></p>
<h4 id="Interceptor-vs-Filter"><a href="#Interceptor-vs-Filter" class="headerlink" title="Interceptor vs Filter"></a>Interceptor vs Filter</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023193414214.png" alt="image-20241023193414214"></p>
<p>filter在一定是在访问servlet之前，interceptor只能在servlet中， <mark>before Controller<mark></p>
<h3 id="功能类"><a href="#功能类" class="headerlink" title="功能类"></a>功能类</h3><p>控制表现层：controller下新建interceptor包，新建一个Interceptor类 <strong>extends HandlerInterceptor</strong> </p>
<p>注意preHandle返回值和@Component</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023210048371.png" alt="image-20241023210048371"></p>
<h4 id="SpringMvcSupport"><a href="#SpringMvcSupport" class="headerlink" title="SpringMvcSupport"></a>SpringMvcSupport</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023205518460.png" alt="image-20241023205518460"></p>
<p>addInterceptors 自动注入自定义拦截器</p>
<p>addPathPatterns 加的不是前缀，<mark>是严格的URL匹配<mark>，配/books就拦截对/books发的请求，/books/100就拦截不了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023205715345.png" alt="image-20241023205715345"></p>
<p><mark>preHandle<mark>，yourService，postHandle，afterCompletion 顺序</p>
<h4 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023210636045.png" alt="image-20241023210636045"></p>
<h4 id="简化开发"><a href="#简化开发" class="headerlink" title="简化开发"></a>简化开发</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023210528299.png" alt="image-20241023210528299"></p>
<p>已经和Spring接口绑定，侵入性强。</p>
<h3 id="拦截方法参数配置"><a href="#拦截方法参数配置" class="headerlink" title="拦截方法参数配置"></a>拦截方法参数配置</h3><h4 id="boolean-preHandle-req-resp-handler"><a href="#boolean-preHandle-req-resp-handler" class="headerlink" title="boolean preHandle(req,resp,handler)"></a>boolean preHandle(req,resp,<mark>handler<mark>)</h4><p>req和resp是servlet的响应和请求，handler实际上是HandlerMethod，通过getMethod能拿到执行的业务方法的对象（反射）</p>
<h4 id="void-postHandle-req-resp-handler-modelAndView"><a href="#void-postHandle-req-resp-handler-modelAndView" class="headerlink" title="void postHandle(req,resp,handler,modelAndView)"></a>void postHandle(req,resp,<mark>handler<mark>,modelAndView)</h4><p>页面跳转相关。</p>
<h4 id="void-afterCompletion-req-resp-handler-exception"><a href="#void-afterCompletion-req-resp-handler-exception" class="headerlink" title="void afterCompletion(req,resp,handler,exception)"></a>void afterCompletion(req,resp,<mark>handler<mark>,exception)</h4><p>能拿到原始业务方法执行过程中的异常</p>
<h3 id="拦截链顺序"><a href="#拦截链顺序" class="headerlink" title="拦截链顺序"></a>拦截链顺序</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023211911820.png" alt="image-20241023211911820"></p>
<p>拦截顺序，和注册顺序有关系</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023212439810.png" alt="image-20241023212439810"></p>
<p>如果某个pre返回false，post全部跳过，倒序执行，从最近一个pre返回true的拦截器开始执行afterCompletion</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023212527269.png" alt="image-20241023212527269"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/penriver/article/details/118571991">万字详解 GoF 23 种设计模式（多图、思维导图、模式对比），让你一文全面理解-CSDN博客</a></p>
<h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><h2 id="入门案例——Web项目"><a href="#入门案例——Web项目" class="headerlink" title="入门案例——Web项目"></a>入门案例——Web项目</h2><h3 id="创建boot模块"><a href="#创建boot模块" class="headerlink" title="创建boot模块"></a>创建boot模块</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dream_ready/article/details/134639886">idea创建不了spring2.X版本，无法使用JDK8，最低支持JDK17 ， 如何用idea创建spring2.X版本，使用JDK8解决方案_spring3不支持jdk8-CSDN博客</a></p>
<p>SpringBoot2停止维护，SpringBoot3最低Java17</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025190302057.png" alt="image-20241025190302057"></p>
<h3 id="写控制器类"><a href="#写控制器类" class="headerlink" title="写控制器类"></a>写控制器类</h3><p>把controller类写好</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025194037167.png" alt="image-20241025194037167"></p>
<h3 id="启动app"><a href="#启动app" class="headerlink" title="启动app"></a>启动app</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025194052846.png" alt="image-20241025194052846"></p>
<h2 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h2><h3 id="打包—jar"><a href="#打包—jar" class="headerlink" title="打包—jar"></a>打包—jar</h3><p><code>package</code> 之前 <code>clean</code> 全部设置为UTF-8参数</p>
<h3 id="命令行启动-java-jar"><a href="#命令行启动-java-jar" class="headerlink" title="命令行启动 java -jar"></a>命令行启动 java -jar</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025194844475.png" alt="image-20241025194844475"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025194925821.png" alt="image-20241025194925821"></p>
<p>jar执行要有入口类，boot打包需要插件才能生成可执行的入口类</p>
<h2 id="简述boot"><a href="#简述boot" class="headerlink" title="简述boot"></a>简述boot</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025195226537.png" alt="image-20241025195226537"></p>
<h3 id="starter-起步依赖"><a href="#starter-起步依赖" class="headerlink" title="starter 起步依赖"></a>starter 起步依赖</h3><h3 id="starter-parent-依赖管理"><a href="#starter-parent-依赖管理" class="headerlink" title="starter-parent 依赖管理"></a>starter-parent 依赖管理</h3><p>starter-parent：定义了无数jar包的版本管理和依赖管理，减少依赖冲突。只写GA 不写V</p>
<h3 id="dependencies-辅助功能"><a href="#dependencies-辅助功能" class="headerlink" title="dependencies-辅助功能"></a>dependencies-辅助功能</h3><p>每一个dependency（以web包为例）把真正需要用到的jar包声明，去找parent要即可</p>
<p>spring-boot-starter-web: </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025201404198.png" alt="image-20241025201404198"></p>
<p>spring-boot-dependencies: </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025201443556.png" alt="image-20241025201443556"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025201805886.png" alt="image-20241025201805886"></p>
<h3 id="替换starter的某个依赖"><a href="#替换starter的某个依赖" class="headerlink" title="替换starter的某个依赖"></a>替换starter的某个依赖</h3><p>依赖排除exclusion，换技术</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025202142653.png" alt="image-20241025202142653"></p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="resources目录下配置文件加载优先级"><a href="#resources目录下配置文件加载优先级" class="headerlink" title="resources目录下配置文件加载优先级"></a>resources目录下配置文件加载优先级</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025204356892.png" alt="image-20241025204356892"></p>
<p>properties&gt;<mark>yml<mark>&gt;yaml</p>
<h3 id="自动提示功能消失—引入配置文件到boot模块中"><a href="#自动提示功能消失—引入配置文件到boot模块中" class="headerlink" title="自动提示功能消失—引入配置文件到boot模块中"></a>自动提示功能消失—引入配置文件到boot模块中</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025204437530.png" alt="image-20241025204437530"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025204503008.png" alt="image-20241025204503008"></p>
<p>debug&gt;info&gt;warn</p>
<h3 id="YAML—-YAML-Ain’t-Markup-Language"><a href="#YAML—-YAML-Ain’t-Markup-Language" class="headerlink" title="YAML—(YAML Ain’t Markup Language)"></a>YAML—(YAML Ain’t Markup Language)</h3><h4 id="YAML-简介"><a href="#YAML-简介" class="headerlink" title="YAML 简介"></a>YAML 简介</h4><p>Jamel  Camel</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025204800590.png" alt="image-20241025204800590"></p>
<h4 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025204945594.png" alt="image-20241025204945594"></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空格数量不限，只要前面格数一样就是同一级，不允许使用tab缩进</span></span><br><span class="line"><span class="attr">enterprise:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">John</span></span><br><span class="line"> <span class="attr">likes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Java</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Python</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">C++</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025205033642.png" alt="image-20241025205033642"></p>
<h3 id="以Java方式读取yaml配置文件"><a href="#以Java方式读取yaml配置文件" class="headerlink" title="以Java方式读取yaml配置文件"></a>以Java方式读取yaml配置文件</h3><h4 id="读取单个数据—定义成员变量-Value-enterprise-subject"><a href="#读取单个数据—定义成员变量-Value-enterprise-subject" class="headerlink" title="读取单个数据—定义成员变量@Value(${enterprise.subject)"></a>读取单个数据—定义成员变量@Value(${enterprise.subject)</h4><p>自动赋值</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025205805383.png" alt="image-20241025205805383"></p>
<h4 id="读取全部数据—Environment对象"><a href="#读取全部数据—Environment对象" class="headerlink" title="读取全部数据—Environment对象"></a>读取全部数据—Environment对象</h4><p>定义一个Environment，自动装配，将配置中的属性全部遍历:</p>
<p><code>environment.getProperty(&quot;name&quot;)</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025210024893.png" alt="image-20241025210024893"></p>
<h4 id="自定义对象封装指定数据-Component-ConfigurationProperties-prefix-enterprise"><a href="#自定义对象封装指定数据-Component-ConfigurationProperties-prefix-enterprise" class="headerlink" title="自定义对象封装指定数据@Component@ConfigurationProperties(prefix = enterprise)"></a><strong>自定义对象封装指定数据</strong>@Component@ConfigurationProperties(prefix = enterprise)</h4><p>可以拿到需要的某个属性的信息(prefix)</p>
<p>在控制器中定义成员变量自动装配，常用</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025210946272.png" alt="image-20241025210710013"></p>
<h5 id="自定义对象封装数据警告"><a href="#自定义对象封装数据警告" class="headerlink" title="自定义对象封装数据警告"></a>自定义对象封装数据警告</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025211036999.png" alt="image-20241025211036999"></p>
<h3 id="多环境开发"><a href="#多环境开发" class="headerlink" title="多环境开发"></a>多环境开发</h3><h4 id="生产环境设定"><a href="#生产环境设定" class="headerlink" title="生产环境设定"></a>生产环境设定</h4><p><strong>独立生产环境设定</strong>：</p>
<p><code>spring.profiles</code> <strong>boot2</strong></p>
<p><code>spring.config.activate.on-profile</code> <strong>boot3</strong></p>
<p><code>---</code> 三条横线分割配置</p>
<p><code>spring.profiles.active</code> 设置激活的环境</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025214421983.png" alt="image-20241025214421983"></p>
<h4 id="带参数启动boot"><a href="#带参数启动boot" class="headerlink" title="带参数启动boot"></a>带参数启动boot</h4><h5 id="命令行参数临时修改配置内容"><a href="#命令行参数临时修改配置内容" class="headerlink" title="命令行参数临时修改配置内容"></a>命令行参数临时修改配置内容</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改启动环境为test</span></span><br><span class="line">java -jar boot_1.0_SNAPSHOT.jar --spring.profiles.active=<span class="built_in">test</span></span><br><span class="line"><span class="comment"># 修改服务器端口号为88</span></span><br><span class="line">java -jar boot_1.0_SNAPSHOT.jar --server.port=88</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="参数加载优先级"><a href="#参数加载优先级" class="headerlink" title="参数加载优先级"></a>参数加载优先级</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025215406246.png" alt="image-20241025215406246"></p>
<h4 id="maven-amp-boot开发环境兼容—加载配置文件"><a href="#maven-amp-boot开发环境兼容—加载配置文件" class="headerlink" title="maven&amp;boot开发环境兼容—加载配置文件"></a>maven&amp;boot开发环境兼容—加载配置文件</h4><p>maven和boot都设置了多环境，但是打包工作是maven负责，所以maven应该占主导</p>
<p>手动配置resources插件，覆盖parent设定</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hcgk/p/17600908.html">maven-resources-plugin详解 - 红尘过客2022 - 博客园 (cnblogs.com)</a></p>
<h5 id="lt-resources-gt-lt-filtering-gt"><a href="#lt-resources-gt-lt-filtering-gt" class="headerlink" title="&lt;resources&gt; (&lt;filtering&gt;)"></a><code>&lt;resources&gt;</code> (<code>&lt;filtering&gt;</code>)</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026013908079.png" alt="image-20241026013908079"></p>
<p><code>&lt;resources&gt;</code>标签其实就是<code>maven-resources-plugin</code>的<code>&lt;resources&gt;</code>配置，主要用来配置资源目录的。普通项目没有<code>parent</code>，默认继承<code>父pom.xml</code>: </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026024547372.png" alt="image-20241026024547372"></p>
<p>可以看到<code>resources</code>默认就是项目下的<code>src/main/resources</code>，但是没开过滤<code>filtering</code>，所以之前maven课程中，<u>在配置文件中引入占位符还得重写一遍resources标签。</u></p>
<p>而boot模块默认继承的starter-parent默认的<code>resources</code>标签是开了过滤的，而且资源明确<code>包括application.yml</code>这种配置文件，所以即使子项目里不用手动复写<code>resources</code>也能匹配到占位符：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026025346547.png" alt="image-20241026025346547"></p>
<h5 id="maven-resources-plugin-lt-useDefaultDelimeters-gt"><a href="#maven-resources-plugin-lt-useDefaultDelimeters-gt" class="headerlink" title="maven-resources-plugin (&lt;useDefaultDelimeters&gt; )"></a><code>maven-resources-plugin</code> (<code>&lt;useDefaultDelimeters&gt;</code> )</h5><p><code>&lt;useDefaultDelimeters&gt;</code> 支持使用<code>$&#123;&#125;或@</code>过滤资源 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026021624316.png" alt="image-20241026021624316"></p>
<p>boot的starter-parent默认对<code>resources-plugin</code>的配置也做了自定义更改（主要就是<code>&lt;useDefaultDelimeters&gt;</code> = false）而上文提到的父pom没有，<code>&lt;useDefaultDelimeters&gt;</code>默认就是true</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026025510839.png" alt="image-20241026025510839"></p>
<h4 id="定义多环境-lt-profiles-gt"><a href="#定义多环境-lt-profiles-gt" class="headerlink" title="定义多环境 &lt;profiles&gt;"></a>定义多环境 <code>&lt;profiles&gt;</code></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026005328800.png" alt="image-20241026005328800"></p>
<h4 id="配置属性替换占位符"><a href="#配置属性替换占位符" class="headerlink" title="配置属性替换占位符"></a>配置属性替换占位符</h4><h5 id=""><a href="#" class="headerlink" title="@"></a><code>@</code></h5><p>boot项目的parent为了防止spring占位符被扩展，所以只允许<code>@</code>为占位符，不解析<code>$&#123;&#125;</code>。如果已经继承starter-parent，直接在配置文件中@xxx@即可。 <a target="_blank" rel="noopener" href="https://docs.springjava.cn/spring-boot/how-to/properties-and-configuration.html#howto.properties-and-configuration.expand-properties.maven">parent不是starter-parent的解决办法</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026021230152.png" alt="image-20241026021230152"></p>
<h5 id="-1"><a href="#-1" class="headerlink" title="${}"></a><code>$&#123;&#125;</code></h5><p>非要用${}，可以使用如下方法覆盖配置：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026081744618.png" alt="image-20241026081744618"></p>
<p>或者启用插件的<code>&lt;useDefaultDelimeters&gt;</code> = true</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026005308461-1729903011039-5.png" alt="image-20241026005308461"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026005348094-1729902750823-1-1729902803907-3.png" alt="image-20241026005348094"></p>
<h4 id="多配置文件加载优先级"><a href="#多配置文件加载优先级" class="headerlink" title="多配置文件加载优先级"></a>多配置文件加载优先级</h4><h5 id="包外配置"><a href="#包外配置" class="headerlink" title="包外配置"></a>包外配置</h5><p>假设JAR包位于file目录下，<code>file/config/application.yml</code> &gt; <code>file/application.yml</code></p>
<h5 id="包内配置"><a href="#包内配置" class="headerlink" title="包内配置"></a>包内配置</h5><p><code>resources/config/application.yml</code> &gt; <code>resources/application.yml</code></p>
<h4 id="Java项目目录结构"><a href="#Java项目目录结构" class="headerlink" title="Java项目目录结构"></a>Java项目目录结构</h4><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026140333629.png" alt="image-20241026140333629" style="zoom: 67%;" />

<ul>
<li><p>src/main 就是编译以后的classpath(classes)，java是java源代码，resources资源文件，编译完打包都在同一个classes目录下。</p>
</li>
<li><p>src/test 是test-classes，属于测试文件，默认不会参与打包。</p>
</li>
<li><p>依赖放在<strong>包内</strong>和classes并列的lib目录</p>
</li>
<li><p>对于maven webapp骨架，main还有webapp目录，其中WEB-INF文件夹存放web.xml，打包之后web.xml classes lib并列放在WEB-INF中</p>
<ul>
<li>webapp也可存放静态资源，打包之后在JAR包中的第一级</li>
</ul>
</li>
</ul>
<h4 id="JAR包内部结构"><a href="#JAR包内部结构" class="headerlink" title="JAR包内部结构"></a>JAR包内部结构</h4><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/JAR_(%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F)">JAR (文件格式) - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p>META-INF 整个项目的元数据，MANIFEST.MF 包含执行时的入口类等信息</p>
<p>BOOT-INF boot项目的jar包中 classes+lib</p>
<p>WEB-INF web项目war包中 classes+lib+web.xml</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026143753352.png" alt="image-20241026143753352"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026143816570.png" alt="image-20241026143816570"></p>
<h5 id="APK内部结构"><a href="#APK内部结构" class="headerlink" title="APK内部结构"></a>APK内部结构</h5><p>APK作为JAR包的变种，也具有相似的结构：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026144246642.png" alt="image-20241026144246642"></p>
<h2 id="与其他框架整合"><a href="#与其他框架整合" class="headerlink" title="与其他框架整合"></a>与其他框架整合</h2><h3 id="Spring-Boot-X-JUnit"><a href="#Spring-Boot-X-JUnit" class="headerlink" title="Spring Boot X JUnit"></a>Spring Boot X JUnit</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026151902777.png" alt="image-20241026151902777"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026152538674.png" alt="image-20241026152538674"></p>
<h4 id="测试类注解-SpringBootTest"><a href="#测试类注解-SpringBootTest" class="headerlink" title="测试类注解@SpringBootTest"></a>测试类注解@SpringBootTest</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026152650043.png" alt="image-20241026152650043"></p>
<p>SpringBoot启动类：@SpringBootApplication有加载bean的功能，会扫描当前包同层以及子包中所有的bean，加载bean（包含配置类）</p>
<p>SpringBootTest会自动扫描SpringBootApplication，测试类不在启动类所在包/子包中，需要指定启动类的class文件</p>
<h3 id="基于SpringBoot实现SSM整合"><a href="#基于SpringBoot实现SSM整合" class="headerlink" title="基于SpringBoot实现SSM整合"></a>基于SpringBoot实现SSM整合</h3><h4 id="整合MyBatis案例"><a href="#整合MyBatis案例" class="headerlink" title="整合MyBatis案例"></a>整合MyBatis案例</h4><h5 id="启动依赖-MyBatis-MySQL"><a href="#启动依赖-MyBatis-MySQL" class="headerlink" title="启动依赖-MyBatis,MySQL"></a>启动依赖-MyBatis,MySQL</h5><h5 id="pojo-dao-Mapper-MapperScan"><a href="#pojo-dao-Mapper-MapperScan" class="headerlink" title="pojo dao @Mapper @MapperScan"></a>pojo dao @Mapper @MapperScan</h5><p>mybatis自动代理注解开发返回的对象就是实体类，所以实体类不用配置，</p>
<p>mybatis注解开发中@Mapper注解取代了bookMapper.xml，对mybatis声明这是一个mapper。</p>
<p>spring-mybatis整合中，mybatis生成mapper的代理对象会以FactoryBean的形式交给Spring容器管理，要让mybatis知道mapper在哪里，就要加@Mapper注解</p>
<p>spring-mybatis整合中，不加@Mapper注解，要么配置mapperScannerConfigurer，要么加@MapperScan扫mapper包。</p>
<h5 id="application-yml-配置数据源"><a href="#application-yml-配置数据源" class="headerlink" title="application.yml 配置数据源"></a>application.yml 配置数据源</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026163010546.png" alt="image-20241026163010546"></p>
<h4 id="SSM项目迁移到Spring-Boot"><a href="#SSM项目迁移到Spring-Boot" class="headerlink" title="SSM项目迁移到Spring Boot"></a>SSM项目迁移到Spring Boot</h4><p>TODO 注释前面加TODO 可以有事项清单</p>
<h5 id="配置类全部删除"><a href="#配置类全部删除" class="headerlink" title="配置类全部删除"></a>配置类全部删除</h5><h5 id="Dao加-Mapper"><a href="#Dao加-Mapper" class="headerlink" title="Dao加@Mapper"></a>Dao加@Mapper</h5><h5 id="Controller-Service不变"><a href="#Controller-Service不变" class="headerlink" title="Controller Service不变"></a>Controller Service不变</h5><h5 id="application-yml-配置端口和数据源"><a href="#application-yml-配置端口和数据源" class="headerlink" title="application.yml 配置端口和数据源"></a>application.yml 配置端口和数据源</h5><h5 id="静态资源放到resources-static"><a href="#静态资源放到resources-static" class="headerlink" title="静态资源放到resources/static"></a>静态资源放到resources/static</h5><h6 id="静态资源的重定向-JS脚本"><a href="#静态资源的重定向-JS脚本" class="headerlink" title="静态资源的重定向(JS脚本)"></a>静态资源的重定向(JS脚本)</h6><p>访问一个web资源，如果直接访问 <code>localhost:port</code> 一般会请求一个主页index.html，为了能直接从地址访问资源，创建一个index.html，添加一个跳转的js脚本</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span>=<span class="string">&quot;pages/books.html&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/08/14/redis-advanced/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/14/redis-advanced/" class="post-title-link" itemprop="url">Redis 分布式应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-14 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-14T00:00:00+08:00">2024-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-08 13:23:10" itemprop="dateModified" datetime="2025-05-08T13:23:10+08:00">2025-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="——分布式缓存——"><a href="#——分布式缓存——" class="headerlink" title="——分布式缓存——"></a>——分布式缓存——</h1><p>– 基于Redis集群解决单机Redis存在的问题</p>
<p>单机的Redis存在四大问题：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725144240631.png" alt="image-20210725144240631"></p>
<h1 id="一、Redis持久化"><a href="#一、Redis持久化" class="headerlink" title="一、Redis持久化"></a>一、Redis持久化</h1><p>Redis有两种持久化方案：</p>
<ul>
<li>RDB持久化</li>
<li>AOF持久化</li>
</ul>
<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照（<mark>SNAPSHOT<mark>）。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p>
<p>执行时机</p>
<p>RDB持久化在四种情况下会执行：</p>
<ul>
<li>执行save命令</li>
<li>执行bgsave命令</li>
<li>Redis停机时</li>
<li>触发RDB条件时</li>
</ul>
<p><strong>1）save命令</strong></p>
<p>执行下面的命令，可以立即执行一次RDB：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725144536958.png" alt="image-20210725144536958"></p>
<p>save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</p>
<p><strong>2）bgsave命令</strong></p>
<p>下面的命令可以异步执行RDB：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725144725943.png" alt="image-20210725144725943"></p>
<p>这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</p>
<p><strong>3）停机时</strong></p>
<p>Redis停机时会执行一次save命令，实现RDB持久化。</p>
<p><strong>4）触发RDB条件</strong></p>
<p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 900秒内，如果至少有1个key发生变化，则自动执行bgsave ， 如果是save &quot;&quot; 则表示:禁用RDB</span></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000 </span></span><br></pre></td></tr></table></figure>

<p>RDB的其它配置也可以在redis.conf文件中设置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘不值钱</span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># RDB文件名称</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb  </span></span><br><span class="line"><span class="comment"># 文件保存的路径目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">./ </span></span><br></pre></td></tr></table></figure>

<h3 id="RDB-原理"><a href="#RDB-原理" class="headerlink" title="RDB 原理"></a>RDB 原理</h3><p>bgsave开始时会 <strong>fork</strong> 主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p>
<p>fork采用的是copy-on-write技术：写入时复制</p>
<ul>
<li>当主进程执行读操作时，访问共享内存；</li>
<li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725151319695.png" alt="image-20210725151319695"></p>
<p>如果在RDB过程中，修改了所有的数据，那么redis占用内存将直接<mark>翻倍<mark></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="RDB方式bgsave的基本流程？"><a href="#RDB方式bgsave的基本流程？" class="headerlink" title="RDB方式bgsave的基本流程？"></a>RDB方式bgsave的基本流程？</h4><ul>
<li>fork主进程得到一个子进程，共享内存空间</li>
<li>子进程读取内存数据并写入新的RDB文件</li>
<li>用新RDB文件替换旧的RDB文件</li>
</ul>
<h4 id="RDB会在什么时候执行？save-60-1000代表什么含义？"><a href="#RDB会在什么时候执行？save-60-1000代表什么含义？" class="headerlink" title="RDB会在什么时候执行？save 60 1000代表什么含义？"></a>RDB会在什么时候执行？save 60 1000代表什么含义？</h4><ul>
<li>默认是服务停止时</li>
<li>代表60秒内至少执行1000次修改则触发RDB</li>
</ul>
<h4 id="RDB的缺点？"><a href="#RDB的缺点？" class="headerlink" title="RDB的缺点？"></a>RDB的缺点？</h4><ul>
<li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li>
<li>fork子进程、压缩、写出RDB文件都比较耗时，仅仅修改save命令的第一个参数不会提高RDB执行的效率</li>
</ul>
<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><h3 id="AOF-原理"><a href="#AOF-原理" class="headerlink" title="AOF 原理"></a>AOF 原理</h3><p>AOF全称为<mark>Append Only File<mark>（追加文件）。Redis处理的<mark>每一个写命令<mark>都会记录在AOF文件，可以看做是命令日志文件。(binlog in MySQL)。AOF是执行命令之后写入，binlog是执行之前写入</p>
<ul>
<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>
<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>
<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>
<li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725151543640.png" alt="image-20210725151543640"></p>
<h3 id="AOF-配置"><a href="#AOF-配置" class="headerlink" title="AOF 配置"></a>AOF 配置</h3><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启AOF功能，默认是no</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># AOF文件的名称</span></span><br><span class="line"><span class="attr">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure>

<p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示每执行一次写命令，立即记录到AOF文件</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">always </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">everysec </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">no</span></span><br></pre></td></tr></table></figure>

<p>三种策略对比：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725151654046.png" alt="image-20210725151654046"></p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241117220311689.png" alt="image-20241117220311689" style="zoom: 50%;" />

<h3 id="AOF-步骤"><a href="#AOF-步骤" class="headerlink" title="AOF 步骤"></a>AOF 步骤</h3><p><strong>命令追加（append）</strong>：所有的写命令会追加到 AOF 缓冲区中。</p>
<p><strong>文件写入（write）</strong>：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用<code>write</code>函数（系统调用），<code>write</code>将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。写入系统内核缓冲区之后直接返回（仅仅是写到缓冲区），不会立即同步到硬盘。虽然提高了效率，但也带来了数据丢失的风险。同步硬盘操作通常依赖于系统调度机制，Linux 内核通常为 30s 同步一次，具体值取决于写出的数据量和 I/O 缓冲区的状态。</p>
<p><strong>文件同步（fsync）</strong>：AOF 缓冲区根据对应的持久化方式（ <code>fsync</code> 策略）向硬盘做同步操作。这一步需要调用 <code>fsync</code> 函数（系统调用）， <code>fsync</code> 针对单个文件操作，对其进行强制硬盘同步，<code>fsync</code> 将阻塞直到写入磁盘完成后返回，保证了数据持久化。强制刷新系统内核缓冲区（同步到到磁盘），确保写磁盘操作结束才会返回。</p>
<p><strong>文件重写（rewrite）</strong>：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</p>
<p><strong>重启加载（load）</strong>：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aof-work-process.png"></p>
<p>从 Redis 7 开始，Redis 使用了 <strong>Multi Part AOF</strong> 机制。顾名思义，Multi Part AOF 就是将原来的单个 AOF 文件拆分成多个 AOF 文件。在 Multi Part AOF 中，AOF 文件被分为三种类型，分别为：</p>
<ul>
<li>BASE：表示基础 AOF 文件，它一般由子进程通过重写产生，该文件最多只有一个。</li>
<li>INCR：表示增量 AOF 文件，它一般会在 AOFRW 开始执行时被创建，该文件可能存在多个。</li>
<li>HISTORY：表示历史 AOF 文件，它由 BASE 和 INCR AOF 变化而来，每次 AOFRW 成功完成时，本次 AOFRW 之前对应的 BASE 和 INCR AOF 都将变为 HISTORY，HISTORY 类型的 AOF 会被 Redis 自动删除。</li>
</ul>
<h3 id="AOF-文件重写"><a href="#AOF-文件重写" class="headerlink" title="AOF 文件重写"></a>AOF 文件重写</h3><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行<code>bgrewriteaof</code>命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725151729118.png" alt="image-20210725151729118"></p>
<p>如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p>
<p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p>
<p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p>
<ol>
<li>增长百分比阈值</li>
<li>文件体积大小阈值</li>
</ol>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span></span><br><span class="line"><span class="attr">auto-aof-rewrite-percentage</span> <span class="string">100</span></span><br><span class="line"><span class="comment"># AOF文件体积最小多大以上才触发重写 </span></span><br><span class="line"><span class="attr">auto-aof-rewrite-min-size</span> <span class="string">64mb </span></span><br></pre></td></tr></table></figure>

<h3 id="AOF-校验机制了解吗？"><a href="#AOF-校验机制了解吗？" class="headerlink" title="AOF 校验机制了解吗？"></a><a href="#aof-%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97">AOF 校验机制了解吗？</a></h3><p>AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。这个机制的原理其实非常简单，就是通过使用一种叫做 <strong>校验和（checksum）</strong> 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。因此，Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和（计算的时候会把最后一行保存校验和的内容给忽略点），从而判断 AOF 文件是否完整。如果发现文件有问题，Redis 就会拒绝启动并提供相应的错误信息。AOF 校验机制十分简单有效，可以提高 Redis 数据的可靠性。</p>
<hr>
<p>著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：<a target="_blank" rel="noopener" href="https://javaguide.cn/database/redis/redis-persistence.html">https://javaguide.cn/database/redis/redis-persistence.html</a></p>
<h2 id="RDB与AOF对比"><a href="#RDB与AOF对比" class="headerlink" title="RDB与AOF对比"></a>RDB与AOF对比</h2><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p>
<ul>
<li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。</li>
<li>AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725151940515.png" alt="image-20210725151940515"></p>
<p>Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</p>
<p>Redis 7.0 版本之后，AOF 重写机制得到了优化改进。具体方法是采用 base（全量数据）+inc（增量数据）独立文件存储的方式，彻底解决内存和 IO 资源的浪费，同时也支持对历史 AOF 文件的保存管理，结合 AOF 文件中的时间信息还可以实现 PITR 按时间点恢复（阿里云企业版 Tair 已支持），这进一步增强了 Redis 的数据可靠性，满足用户数据回档等需求。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/RnoPPL7jiFSKkx3G4p57Pg">从Redis7.0发布看Redis的过去与未来 (qq.com)</a> </p>
<h1 id="二、Redis主从集群：应对高并发读"><a href="#二、Redis主从集群：应对高并发读" class="headerlink" title="二、Redis主从集群：应对高并发读"></a>二、Redis主从集群：应对高并发读</h1><p>Redis 通过 Replica/Slave 从节点机制 完成主从复制与读写分离</p>
<h2 id="搭建主从架构"><a href="#搭建主从架构" class="headerlink" title="搭建主从架构"></a>搭建主从架构</h2><p>主从复制：单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725152037611.png" alt="image-20210725152037611"></p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建三个文件夹，将redis.conf复制过去</span></span><br><span class="line"><span class="built_in">mkdir</span> 7001 7002 7003</span><br><span class="line"><span class="built_in">cp</span> redis-6.2.6/redis.conf 7001</span><br><span class="line"><span class="built_in">cp</span> redis-6.2.6/redis.conf 7002</span><br><span class="line"><span class="built_in">cp</span> redis-6.2.6/redis.conf 7003</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改redis.conf中的port、dir</span></span><br><span class="line">sed -i -e <span class="string">&#x27;s/6379/7001/g&#x27;</span> -e <span class="string">&#x27;s/dir .\//dir \/root\/redissetup\/7001\//g&#x27;</span> 7001/redis.conf</span><br><span class="line">sed -i -e <span class="string">&#x27;s/6379/7002/g&#x27;</span> -e <span class="string">&#x27;s/dir .\//dir \/root\/redissetup\/7002\//g&#x27;</span> 7002/redis.conf</span><br><span class="line">sed -i -e <span class="string">&#x27;s/6379/7003/g&#x27;</span> -e <span class="string">&#x27;s/dir .\//dir \/root\/redissetup\/7003\//g&#x27;</span> 7003/redis.conf</span><br><span class="line"><span class="comment"># 添加主从配置ip</span></span><br><span class="line">sed -i <span class="string">&#x27;1a replica-announce-ip localhost&#x27;</span> 7001/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;1a replica-announce-ip localhost&#x27;</span> 7002/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;1a replica-announce-ip localhost&#x27;</span> 7003/redis.conf</span><br><span class="line"><span class="comment"># 添加主从配置端口号 和 主节点的密码</span></span><br><span class="line">sed -i <span class="string">&#x27;1i slaveof 127.0.0.1 7001&#x27;</span> 7002/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;2i masterauth 123321&#x27;</span> 7002/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;1i slaveof 127.0.0.1 7001&#x27;</span> 7003/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;2i masterauth 123321&#x27;</span> 7003/redis.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动redis-server</span></span><br><span class="line">redis-server -p 7001/redis.conf</span><br><span class="line">redis-server -p 7002/redis.conf</span><br><span class="line">redis-server -p 7003/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动命令行</span></span><br><span class="line">redis-cli -p 7001</span><br><span class="line">redis-cli -p 7002</span><br><span class="line">redis-cli -p 7003</span><br><span class="line"></span><br><span class="line">INFO replication <span class="comment">#显示主从信息</span></span><br></pre></td></tr></table></figure>



<h2 id="主从数据同步原理"><a href="#主从数据同步原理" class="headerlink" title="主从数据同步原理"></a>主从数据同步原理</h2><h3 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h3><p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将master节点的所有数据都拷贝给slave节点，流程：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725152222497.png" alt="image-20210725152222497"></p>
<p>这里有一个问题，master如何得知slave是第一次来连接呢？？</p>
<p>有几个概念，可以作为判断依据：</p>
<ul>
<li><strong>Replication Id</strong>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid<mark>（表示主从关系）<mark> </li>
<li><strong>offset</strong>：偏移量，随着记录在repl_backlog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。<mark>（表示数据版本）<mark></li>
</ul>
<p>因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。</p>
<p>因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。</p>
<p>master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。</p>
<p>master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。</p>
<p>因此，<strong>master判断一个节点是否是第一次同步的依据，就是看replid是否一致</strong>。</p>
<p>如图：AOF + RDB</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725152700914.png" alt="image-20210725152700914"></p>
<p>完整流程描述：</p>
<ol>
<li><p>slave节点请求同步，发送replid + offset</p>
</li>
<li><p>master节点判断replid，发现不一致，则进行全量同步返回master的replid + offset</p>
<ul>
<li>master将完整内存数据生成RDB（bgsave）发送RDB到slave</li>
<li>slave清空本地数据，加载master的RDB</li>
<li>master将RDB期间的命令记录在repl_backlog，并持续将repl_backlog的命令发送给slave</li>
</ul>
</li>
<li><p>master节点判断replid，发现一致，并且offset较小</p>
<ul>
<li>去repl_backlog中取得offset之后的数据，将repl_backlog的命令发送给slave</li>
</ul>
</li>
<li><p>slave执行接收到的命令，保持与master之间的同步</p>
</li>
</ol>
<h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><p>全量同步需要先做RDB，然后将RDB文件通过网络传输给slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做<strong>增量同步</strong></p>
<p>什么是增量同步？就是只更新slave与master存在差异的部分数据。如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725153201086.png" alt="image-20210725153201086"></p>
<p>那么master怎么知道slave与自己的数据差异在哪里呢?</p>
<h3 id="repl-backlog原理"><a href="#repl-backlog原理" class="headerlink" title="repl_backlog原理"></a>repl_backlog原理</h3><p>master怎么知道slave与自己的数据差异在哪里呢?</p>
<p>这就要说到全量同步时的repl_backlog文件了。</p>
<p>这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖。</p>
<p>repl_backlog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725153359022.png" alt="image-20210725153359022"> </p>
<p>slave与master的offset之间的差异，就是slave需要增量拷贝的数据了。</p>
<p>随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725153524190.png" alt="image-20210725153524190"> </p>
<p>直到数组被填满：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725153715910.png" alt="image-20210725153715910"> </p>
<p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。</p>
<p>但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725153937031.png" alt="image-20210725153937031"> </p>
<p>slave : 5 master 110(10) 10-100错过的数据还在，错过了105-110(5-10)的数据</p>
<p>如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725154155984.png" alt="image-20210725154155984"> </p>
<p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725154216392.png" alt="image-20210725154216392"></p>
<h2 id="主从同步优化"><a href="#主从同步优化" class="headerlink" title="主从同步优化"></a>主从同步优化</h2><p>主从同步可以保证主从数据的一致性，非常重要。</p>
<p>可以从以下几个方面来优化Redis主从就集群：</p>
<ul>
<li><p>提高全量同步的性能</p>
<ul>
<li><p>在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。（磁盘慢，网络快）</p>
</li>
<li><p>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO（RDB 小）</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>适当提高repl_backlog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步(OFFSET_MAX)</li>
<li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力（减少压力）</li>
</ul>
<p>主从从架构图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725154405899.png" alt="image-20210725154405899"></p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><h3 id="简述全量同步和增量同步区别？"><a href="#简述全量同步和增量同步区别？" class="headerlink" title="简述全量同步和增量同步区别？"></a>简述全量同步和增量同步区别？</h3><ul>
<li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_backlog，逐个发送给slave。</li>
<li>增量同步：slave提交自己的offset到master，master获取repl_backlog中从offset之后的命令给slave</li>
</ul>
<h3 id="什么时候执行全量同步？"><a href="#什么时候执行全量同步？" class="headerlink" title="什么时候执行全量同步？"></a>什么时候执行全量同步？</h3><ul>
<li>slave节点第一次连接master节点时</li>
<li>slave节点断开时间太久，repl_backlog中的offset已经被覆盖时</li>
</ul>
<h3 id="什么时候执行增量同步？"><a href="#什么时候执行增量同步？" class="headerlink" title="什么时候执行增量同步？"></a>什么时候执行增量同步？</h3><ul>
<li>slave节点断开又恢复，并且在repl_backlog中能找到offset时</li>
</ul>
<h1 id="三、Redis哨兵集群：保证主从高可用性"><a href="#三、Redis哨兵集群：保证主从高可用性" class="headerlink" title="三、Redis哨兵集群：保证主从高可用性"></a>三、Redis哨兵集群：保证主从高可用性</h1><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。</p>
<h2 id="哨兵原理"><a href="#哨兵原理" class="headerlink" title="哨兵原理"></a>哨兵原理</h2><h3 id="集群结构和作用"><a href="#集群结构和作用" class="headerlink" title="集群结构和作用"></a>集群结构和作用</h3><p>哨兵的结构如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725154528072.png" alt="image-20210725154528072"></p>
<p>哨兵的作用如下：</p>
<ul>
<li><strong>监控</strong>：Sentinel 会不断检查您的master和slave是否按预期工作 </li>
<li><strong>自动故障恢复（转移）</strong>：如果master故障，Sentinel会<mark>将一个slave提升为master<mark>。当故障实例恢复后也以新的master为主</li>
<li><strong>通知</strong>：Sentinel充当Redis<mark>客户端的服务发现来源<mark>，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li>
</ul>
<h3 id="集群监控状态原理：心跳机制"><a href="#集群监控状态原理：心跳机制" class="headerlink" title="集群监控状态原理：心跳机制"></a>集群监控状态原理：心跳机制</h3><p>Sentinel基于<mark>心跳机制<mark>监测服务状态，每隔<mark>1秒<mark>向集群的每个实例<mark>发送ping命令<mark>：</p>
<p>•主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</p>
<p>•客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725154632354.png" alt="image-20210725154632354"></p>
<h3 id="集群故障恢复原理：选举机制"><a href="#集群故障恢复原理：选举机制" class="headerlink" title="集群故障恢复原理：选举机制"></a>集群故障恢复原理：选举机制</h3><p>一旦发现master故障，sentinel需要在slave中选择一个作为新的master，选择依据是这样的：</p>
<ul>
<li><strong>与master断开时间</strong>：首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</li>
<li><strong>优先级</strong>：然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</li>
<li><strong>offset</strong>：如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li>
<li><strong>运行id</strong>：最后是判断slave节点的运行id大小，越小优先级越高。每个 redis 节点启动时都有一个 40 字节随机字符串作为运行 id。</li>
</ul>
<p>当选出一个新的master后，该如何实现切换呢？</p>
<p>流程如下：</p>
<ul>
<li>sentinel给备选的slave1节点发送<code>slaveof no one</code>命令，让该节点成为master</li>
<li>sentinel给所有其它slave发送slaveof 127.0.0.1 7002(也就是slave1) 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</li>
<li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725154816841.png" alt="image-20210725154816841"></p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><h4 id="Sentinel的三个作用是什么？"><a href="#Sentinel的三个作用是什么？" class="headerlink" title="Sentinel的三个作用是什么？"></a>Sentinel的三个作用是什么？</h4><ul>
<li>监控</li>
<li>故障转移</li>
<li>通知</li>
</ul>
<h4 id="Sentinel如何判断一个redis实例是否健康？"><a href="#Sentinel如何判断一个redis实例是否健康？" class="headerlink" title="Sentinel如何判断一个redis实例是否健康？"></a>Sentinel如何判断一个redis实例是否健康？</h4><ul>
<li>每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线</li>
<li>如果大多数sentinel都认为实例主观下线，则判定服务下线</li>
</ul>
<h4 id="故障转移步骤有哪些？"><a href="#故障转移步骤有哪些？" class="headerlink" title="故障转移步骤有哪些？"></a>故障转移步骤有哪些？</h4><ul>
<li>首先选定一个slave作为新的master，执行slaveof no one</li>
<li>然后让所有节点(包括故障节点)都执行slaveof 新master</li>
<li>修改故障节点配置，添加slaveof 新master</li>
</ul>
<h2 id="搭建哨兵集群：master宕机案例"><a href="#搭建哨兵集群：master宕机案例" class="headerlink" title="搭建哨兵集群：master宕机案例"></a>搭建哨兵集群：master宕机案例</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119171035000.png" alt="image-20241119171035000"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119171850683.png" alt="image-20241119171850683"></p>
<p>从节点连不上主节点</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119172740595.png" alt="image-20241119172740595"></p>
<p>哨兵选举一个slave作为新的master</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119172833310.png" alt="image-20241119172833310"></p>
<p>被选中的slave变成master</p>
<h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。</p>
<p>下面，我们通过一个测试来实现RedisTemplate集成哨兵机制。</p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>在项目的pom文件中引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置Redis哨兵集群地址"><a href="#配置Redis哨兵集群地址" class="headerlink" title="配置Redis哨兵集群地址"></a>配置Redis哨兵集群地址</h3><p>然后在配置文件application.yml中指定redis的sentinel相关信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    sentinel:</span><br><span class="line">      master: mymaster</span><br><span class="line">      nodes:</span><br><span class="line">        - <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">27001</span><span class="comment">//哨兵一号</span></span><br><span class="line">        - <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">27002</span></span><br><span class="line">        - <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">27003</span></span><br></pre></td></tr></table></figure>

<p>哨兵的启动配置文件里已经有了主节点的一切信息，IP+PORT+quorum+name，只需要引入哨兵就能启用集群</p>
<h3 id="配置读写分离"><a href="#配置读写分离" class="headerlink" title="配置读写分离"></a>配置读写分离</h3><p>在项目的启动类中，添加一个新的bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="title function_">clientConfigurationBuilderCustomizer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个bean中配置的就是读写策略，包括四种：</p>
<ul>
<li>MASTER：从主节点读取</li>
<li>MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica</li>
<li>REPLICA：从slave（replica）节点读取</li>
<li><mark>REPLICA _PREFERRED<mark>：优先从slave（replica）节点读取，所有的slave都不可用才读取master</li>
</ul>
<p>每个节点都会建立连接，读取时会按照读写分离的策略读。</p>
<h1 id="四、Redis分片集群：应对高并发写、海量数据存储"><a href="#四、Redis分片集群：应对高并发写、海量数据存储" class="headerlink" title="四、Redis分片集群：应对高并发写、海量数据存储"></a>四、Redis分片集群：应对高并发写、海量数据存储</h1><p>Redis Cluster 解决了哨兵机制的弊端：每个实例全量存储，木桶效应，提供动态的横向扩展，</p>
<h2 id="纵向-横向扩展"><a href="#纵向-横向扩展" class="headerlink" title="纵向/横向扩展"></a>纵向/横向扩展</h2><p>纵向也可以多节点，纵/横的标准是：是否所有节点的存储内容都一样</p>
<p>究竟选择scale-up（纵向）还是scale-out（横向）架构,主要考虑以下因素：</p>
<table>
<thead>
<tr>
<th align="center">成本</th>
<th align="left">Scale-up架构只有容量升级的成本，不会增加控制器或基础设施的开销。如果我们主要衡量每GB存储的单位价格，scale-up的扩展方式无疑更便宜一些</th>
</tr>
</thead>
<tbody><tr>
<td align="center">容量</td>
<td align="left">两种解决方案都可以满足容量需求，但scale-up架构也许会有些限制，主要取决于单个系统最大支持多少个磁盘数量和多大的容量</td>
</tr>
<tr>
<td align="center">性能</td>
<td align="left">Scale-out架构在性能上具有扩展潜力，在多个存储控制器下，IOPS处理能力和吞吐带宽都可以聚合。虽然节点之间的通信会引发延迟，但那是部署时的细节问题</td>
</tr>
<tr>
<td align="center">管理</td>
<td align="left">Scale-up架构本身就是以单一系统的方式来进行管理的。而Scale-out架构通常有聚合管理的能力，但每个厂商提供的产品可能会有所不同</td>
</tr>
<tr>
<td align="center">复杂性</td>
<td align="left">Scale-up架构的存储相对简单，而scale-out架构的系统会更复杂一些，毕竟每个节点都需要管理</td>
</tr>
<tr>
<td align="center">可用性</td>
<td align="left">多个节点可以提供更好的可用性，假使有一个部件故障或失效，系统也不至于整体宕机。这一点与具体的实施方案也有关系</td>
</tr>
</tbody></table>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119184050478.png" alt="Scale-UP 纵向扩展"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119184124945.png" alt="Scale-OUT 横向扩展"></p>
<h2 id="搭建分片集群"><a href="#搭建分片集群" class="headerlink" title="搭建分片集群"></a>搭建分片集群</h2><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p>
<ul>
<li><p><mark>海量数据存储问题<mark></p>
</li>
<li><p><mark>高并发写的问题<mark></p>
</li>
</ul>
<p>使用横向扩展分片集群可以解决上述问题，如图:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725155747294.png" alt="分片集群"></p>
<p>分片集群特征：</p>
<ul>
<li><p>集群中有多个master，每个master保存不同数据</p>
</li>
<li><p>每个master都可以有多个slave节点（高可用）</p>
</li>
<li><p>slave 不对外提供读服务，主要用来保障 master 的高可用，做数据的热备份，当 master 出现故障的时候替代它。</p>
</li>
<li><p>master之间通过ping监测彼此健康状态（全员哨兵）</p>
</li>
<li><p>客户端请求可以访问集群任意节点，最终都会被自动路由转发到正确节点（自动路由）</p>
</li>
</ul>
<p>本质就是多个主从集群的互相监控，不需要另外sentinel的监控，不过此时的slave</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 开启集群功能</span></span><br><span class="line"><span class="attr">cluster-enabled</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># 集群的配置文件名称，不需要我们创建，由redis自己维护</span></span><br><span class="line"><span class="attr">cluster-config-file</span> <span class="string">/root/redissetup/6379/nodes.conf</span></span><br><span class="line"><span class="comment"># 节点心跳失败的超时时间</span></span><br><span class="line"><span class="attr">cluster-node-timeout</span> <span class="string">5000</span></span><br><span class="line"><span class="comment"># 持久化</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">/root/redissetup/6379</span></span><br><span class="line"></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># 主从ip地址</span></span><br><span class="line"><span class="attr">replica-announce-ip</span> <span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment"># 保护模式</span></span><br><span class="line"><span class="attr">protected-mode</span> <span class="string">no</span></span><br><span class="line"></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 日志记录</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">/root/redissetup/6379/run.log</span></span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t sed -i <span class="string">&#x27;s/6379/&#123;&#125;/g&#x27;</span> &#123;&#125;/redis.conf</span><br><span class="line"><span class="comment"># 编辑端口号</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-server &#123;&#125;/redis.conf</span><br><span class="line"><span class="comment"># 开启服务器实例</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas 1 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:8001 127.0.0.1:8002 127.0.0.1:8003</span><br><span class="line"><span class="comment"># 开启分片集群功能</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119193312708.png" alt="image-20241119193312708"></p>
<p>6/(1+1) = 3</p>
<p>！！！！！！！！</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119201022033.png" alt="image-20241119201022033"></p>
<p>启动一定加 -c</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119203336515.png" alt="image-20241119203336515"></p>
<p>查看节点状况</p>
<h2 id="散列插槽"><a href="#散列插槽" class="headerlink" title="散列插槽"></a>散列插槽</h2><h3 id="插槽原理"><a href="#插槽原理" class="headerlink" title="插槽原理"></a>插槽原理</h3><p>Redis Cluster 并没有使用一致性哈希，采用的是 哈希槽分区 ，每一个键值对都属于一个 hash slot（哈希槽） 。</p>
<p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725155820320.png" alt="image-20210725155820320"></p>
<p>数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p>
<ul>
<li><mark>key中包含”{}”，且“{}”中至少包含1个字符，“{}”中的部分是有效部分<mark> </li>
<li>key中不包含“{}”，整个key都是有效部分</li>
</ul>
<p>例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119201236259.png" alt="image-20241119201236259"> </p>
<p>如图，在7001这个节点执行set a 1时，对a做hash运算，对16384取余，得到的结果是15495，因此要存储到7003节点。</p>
<p>到了7003后，执行<code>get num</code>时，对num做hash运算，对16384取余，得到的结果是2765，因此需要切换到7001节点</p>
<p>当客户端发送命令请求的时候，需要</p>
<ul>
<li>先根据 key 找到的对应的哈希槽，</li>
<li>然后再查询哈希槽和节点的映射关系，即可找到目标节点。 </li>
</ul>
<h3 id="哈希槽数目为什么选择-16384？"><a href="#哈希槽数目为什么选择-16384？" class="headerlink" title="哈希槽数目为什么选择 16384？"></a>哈希槽数目为什么选择 16384？</h3><p><code>CRC16</code>算法产生的hash值有16bit，该算法可以产生2^16-=65536个值。换句话说，值是分布在0~65535之间。那作者在做<code>mod</code>运算的时候，为什么不<code>mod</code>65536，而选择<code>mod</code>16384？</p>
<p>哈希槽的数量选择 16384 而不是 65536 的主要原因：</p>
<ul>
<li>哈希槽太大会导致心跳包（包括slots信息）太大，消耗太多带宽； </li>
<li>哈希槽总数越少，对存储哈希槽信息的 bitmap 压缩效果越好； </li>
<li>Redis Cluster 的主节点通常不会扩展太多，16384 个哈希槽已经足够用了。</li>
</ul>
<p>一致性哈希理论上可以有2^32^个节点，实际上不会有那么多，</p>
<p>正常的心跳包会携带一个节点的完整配置，它会以幂等的方式更新旧的配置，这意味着心跳包会附 带当前节点的负责的哈希槽的信息。假设哈希槽采用 16384 ,则占空间 2k(16384/8)。假设哈希槽 采用 65536， 则占空间 8k(65536/8)，这是令人难以接受的内存占用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 省略部分字段</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 本节点负责的哈希槽信息,16384/8 个 char 数组，一共为16384bit</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> myslots[CLUSTER_SLOTS/<span class="number">8</span>];</span><br><span class="line">    <span class="comment">// 集群的状态</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> state;</span><br><span class="line">    <span class="comment">// 消息的内容</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">clusterMsgData</span> <span class="title">data</span>;</span></span><br><span class="line">&#125; clusterMsg;</span><br></pre></td></tr></table></figure>

<p>可以看到哈希槽是使用槽位数/8 使用一个char数组来表示，这里实际就是通过 bitmap 这种数据结构维护的哈希槽信息，每一个 bit 代表一个哈希槽，每个 bit 只能 存储 0/1 。如果该位为 1，表示这个哈希槽是属于这个节点。</p>
<p>虽说 Redis Cluster 可以扩展到 1000 个节点，但强烈不推荐这样做，应尽量避免集群中的节点过多。这 是因为 Redis Cluster 中的各个节点基于 Gossip 协议 来进行通信共享信息，当节点过多时，<strong>Gossip</strong> 协议的效率会显著下降，通信成本剧增。请注意，在小簇中，位图将很难压缩，因为当 N 很小时，位图将具有插槽/N 位设置，这是位设置的很大百分比。</p>
<h3 id="为什么不采用一致性哈希？"><a href="#为什么不采用一致性哈希？" class="headerlink" title="为什么不采用一致性哈希？"></a>为什么不采用一致性哈希？</h3><p>一致性哈希：为了防止节点和数据绑定，将整个哈希结果构造为一个2^32的域，服务器名称也在域中，根据key的哈希结果和服务器的位置关系判断应该访问哪个服务器。（狭义上）</p>
<p>为啥redis cluster 不设置 2的32次方个槽位呢？主要是考虑节点数在1000的规模左右，而使用 <strong>Gossip</strong> 去中心一致性协议，数据包不能太大，16K 个二进制位 2K字节已经很大了。</p>
<p>Redis 选择哈希插槽，是因为其设计目标（强一致性、高可用性）与哈希插槽的特性高度契合，而一致性哈希更适合对扩展性要求更高、允许最终一致性的场景（如缓存系统）。</p>
<ul>
<li><p>一致性hash 哈希环顺时针映射 优先考虑的是： 如何实现 最少的节点数据发生数据迁移。</p>
<p>一致性hash 哈希环上面，只有被干掉的节点顺时针方向最近的那一个节点涉及到数据迁移；其他间隔较远的节点，不涉及到数据迁移。迁移范围仅限环上相邻节点间的键。</p>
</li>
<li><p>redis cluster 哈希槽静态映射 优先考虑的是： 如何 实现数据的均匀。</p>
<p>槽位是逻辑单位，节点是物理单位，二者通过配置文件或集群协议关联。<strong>映射关系由集群元数据控制</strong>（如 Redis Cluster 的 Gossip 协议同步），客户端需缓存槽位分布表。</p>
<p>redis cluster 各个节点都会参与数据迁移，优先保证各个redis节点承担同样的访问压力。</p>
</li>
<li><p>同时，redis cluster 哈希槽静态映射还有一个优点，<mark>手动迁移<mark>。</p>
<p>redis cluster 可以自动分配，也可以根据节点的性能（比如Memory大小） 手动的调整slot的分配。</p>
</li>
</ul>
<h3 id="如何判断某个key应该在哪个实例？"><a href="#如何判断某个key应该在哪个实例？" class="headerlink" title="如何判断某个key应该在哪个实例？"></a>如何判断某个key应该在哪个实例？</h3><ul>
<li>将16384个插槽分配到不同的实例</li>
<li>根据key的有效部分计算哈希值，对16384取余</li>
<li>余数作为插槽，寻找插槽所在实例即可</li>
</ul>
<h3 id="如何将同一类数据固定的保存在同一个实例？"><a href="#如何将同一类数据固定的保存在同一个实例？" class="headerlink" title="如何将同一类数据固定的保存在同一个实例？"></a>如何将同一类数据固定的保存在同一个实例？</h3><p>不同节点之间的切换比较耗时，所以同类的key尽量存在同一个节点上面</p>
<ul>
<li>这一类数据使用相同的有效部分，例如key都以{typeId}为前缀</li>
</ul>
<p><mark>要清楚的一点：<mark>数据不存在hash插槽上，因此也不存在哈希冲突这一说，key映射到某个哈希插槽仅仅说明它属于XX节点，将来相同key也会去找相同的节点，仅此而已。</p>
<h2 id="集群伸缩：插槽迁移"><a href="#集群伸缩：插槽迁移" class="headerlink" title="集群伸缩：插槽迁移"></a>集群伸缩：插槽迁移</h2><p>redis-cli –cluster提供了很多操作集群的命令，可以通过下面方式查看：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725160138290.png" alt="image-20210725160138290"></p>
<p>比如，添加节点的命令：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725160448139.png" alt="image-20210725160448139"></p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>需求：向集群中添加一个新的master节点，并向其中存储 num = 10</p>
<ul>
<li>启动一个新的redis实例，端口为7004</li>
<li>添加7004到之前的集群，并作为一个master节点</li>
<li>给7004节点分配插槽，使得num这个key可以存储到7004实例</li>
</ul>
<p>这里需要两个新的功能：</p>
<ul>
<li>添加一个节点到集群中</li>
<li>将部分插槽分配到新插槽</li>
</ul>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><h4 id="创建新的redis实例"><a href="#创建新的redis实例" class="headerlink" title="创建新的redis实例"></a>创建新的redis实例</h4><p>创建一个文件夹：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> 7004</span><br></pre></td></tr></table></figure>

<p>拷贝配置文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> redis.conf /7004</span><br></pre></td></tr></table></figure>

<p>修改配置文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed /s/6379/7004/g 7004/redis.conf</span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server 7004/redis.conf</span><br></pre></td></tr></table></figure>



<h4 id="添加新节点到redis"><a href="#添加新节点到redis" class="headerlink" title="添加新节点到redis"></a>添加新节点到redis</h4><p>添加节点的语法如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725160448139.png" alt="image-20210725160448139"></p>
<p>执行命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node  127.0.0.1:7004 127.0.0.1:7001</span><br></pre></td></tr></table></figure>



<p>通过命令查看集群状态：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></table></figure>



<p>如图，7004加入了集群，并且默认是一个master节点：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161007099.png" alt="image-20210725161007099"></p>
<p>但是，可以看到7004节点的插槽数量为0，因此没有任何数据可以存储到7004上</p>
<h4 id="转移插槽"><a href="#转移插槽" class="headerlink" title="转移插槽"></a>转移插槽</h4><p>每个数据都有对应的插槽编号，可以根据编号查出数据</p>
<p>我们要将num存储到7004节点，因此需要先看看num的插槽是多少：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161241793.png" alt="image-20210725161241793"></p>
<p>如上图所示，num的插槽为2765.</p>
<p>我们可以将0~3000的插槽从7001转移到7004，命令格式如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161401925.png" alt="image-20210725161401925"></p>
<p>具体命令如下：</p>
<p>建立连接：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161506241.png" alt="image-20210725161506241"></p>
<p>得到下面的反馈：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161540841.png" alt="image-20210725161540841"></p>
<p>询问要移动多少个插槽，我们计划是3000个：新的问题来了：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161637152.png" alt="image-20210725161637152"></p>
<p>那个node来接收这些插槽？？显然是7004，那么7004节点的id是多少呢？</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161731738.png" alt="image-20210725161731738"></p>
<p>复制这个id，然后拷贝到刚才的控制台后：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161817642.png" alt="image-20210725161817642"></p>
<p>这里询问，你的插槽是从哪里移动过来的？</p>
<ul>
<li>all：代表全部，也就是三个节点各转移一部分</li>
<li>具体的id：目标节点的id</li>
<li>done：没有了</li>
</ul>
<p>这里我们要从7001获取，因此填写7001的id：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725162030478.png" alt="image-20210725162030478"></p>
<p>填完后，点击done，这样插槽转移就准备好了：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725162101228.png" alt="image-20210725162101228"></p>
<p>确认要转移吗？输入yes：然后，通过命令查看结果：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725162145497.png" alt="image-20210725162145497"> </p>
<p>可以看到： </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725162224058.png" alt="image-20210725162224058"></p>
<p>目的达成。</p>
<h3 id="迁移流程：集群节点的数据结构"><a href="#迁移流程：集群节点的数据结构" class="headerlink" title="迁移流程：集群节点的数据结构"></a>迁移流程：集群节点的数据结构</h3><p>每个节点都有一个对应的clusterNode clusterState结构</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E6%97%A0%E6%A0%87%E9%A2%98.jpg"></p>
<p>存储的时候，会根据key计算哈希，这是key到哈希槽位的映射，</p>
<p>迁移的时候，如果遍历整个数据库，分别计算哈希，效率低下，因此节点自身用一个跳表slots_to_key维护槽位到key的映射，score是槽位号，member是key值    </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sulishihupan/p/14538864.html">Redis–集群Cluster（槽指派、重新分片） - 苏黎世湖畔 - 博客园 (cnblogs.com)</a> </p>
<p>假设将 <code>0-3000</code> 插槽从节点 A 迁移至节点 B：</p>
<ol>
<li>节点 A 标记为 <code>MIGRATING</code>，表示它即将释放这些插槽。节点 B 标记为 <code>IMPORTING</code>，表示它即将接管这些插槽。</li>
<li>通知所有节点，让客户端感知到这些插槽的迁移状态，确保客户端请求能够动态路由到正确的节点。</li>
</ol>
<h2 id="故障转移：全员哨兵"><a href="#故障转移：全员哨兵" class="headerlink" title="故障转移：全员哨兵"></a>故障转移：全员哨兵</h2><p>clusterState结构中，有一个nodes，指向其他节点，因此能够实现全员哨兵</p>
<p>有了 Redis Cluster 之后，不需要专门部署 Sentinel 集群服务了。Redis Cluster 相当于是内置了 Sentinel 机制，Redis Cluster 内部的各个 Redis 节点通过 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/463455831">Gossip 协议</a>互相探测健康状态，在故障时可 以自动切换。</p>
<p>集群初始状态是这样的：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210727161152065.png" alt="image-20210727161152065"></p>
<p>其中7001、7002、7003都是master，我们计划让7002宕机。</p>
<h3 id="自动故障转移"><a href="#自动故障转移" class="headerlink" title="自动故障转移"></a>自动故障转移</h3><p>当集群中有一个master宕机会发生什么呢？</p>
<p>直接停止一个redis实例，例如7002：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7002 shutdown</span><br></pre></td></tr></table></figure>

<p>1）首先是该实例与其它实例失去连接</p>
<p>2）然后是疑似宕机：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725162319490.png" alt="image-20210725162319490"></p>
<p>3）最后是确定下线，自动提升一个slave为新的master：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725162408979.png" alt="image-20210725162408979"></p>
<p>4）当7002再次启动，就会变为一个slave节点了：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210727160803386.png" alt="image-20210727160803386"></p>
<h3 id="手动故障转移"><a href="#手动故障转移" class="headerlink" title="手动故障转移"></a>手动故障转移</h3><p>利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725162441407.png" alt="image-20210725162441407"></p>
<p>这种failover命令可以指定三种模式：</p>
<ul>
<li>缺省：默认的流程，如图1~6歩</li>
<li>force：省略了对offset的一致性校验</li>
<li>takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见</li>
</ul>
<p><strong>案例需求</strong>：在7002这个slave节点执行手动故障转移，重新夺回master地位</p>
<p>步骤如下：</p>
<p>1）利用redis-cli连接7002这个节点</p>
<p>2）执行cluster failover命令</p>
<p>如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210727160037766.png" alt="image-20210727160037766"></p>
<p>效果：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210727161152065.png" alt="image-20210727161152065"></p>
<h2 id="客户端访问分片集群"><a href="#客户端访问分片集群" class="headerlink" title="客户端访问分片集群"></a>客户端访问分片集群</h2><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：</p>
<p>1）引入redis的starter依赖</p>
<p>2）配置分片集群地址</p>
<p>3）配置读写分离</p>
<p>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">cluster:</span></span><br><span class="line">      <span class="attr">nodes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:7001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:7002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:7003</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8003</span></span><br></pre></td></tr></table></figure>

<h3 id="客户端访问时集群正在迁移数据"><a href="#客户端访问时集群正在迁移数据" class="headerlink" title="客户端访问时集群正在迁移数据"></a>客户端访问时集群正在迁移数据</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119212106075.png" alt="image-20241119212106075"></p>
<h4 id="ASK"><a href="#ASK" class="headerlink" title="ASK"></a>ASK</h4><ol>
<li>客户端发送请求命令，如果请求的 key 对应的哈希槽还在当前节点，就直接响应客户端的请求。如果客户端请求的 key 对应的哈希槽当前正在迁移至新的节点，就会返回<code>-ASK</code> 重定向错误，告知客户端要将请求发送到哈希槽被迁移到的目标节点。</li>
<li>客户端收到<code>-ASK</code>重定向错误后，将会临时（一次性）重定向，自动向目标节点发送一条 ASKING 命令。也就是说，接收到 ASKING 命令的节点会强制执行一次请求，下次再来需要重新提前发送 ASKING 命令。</li>
<li>ASK 重定向并不会同步更新客户端缓存的哈希槽分配信息，也就是说，客户端对正在迁移的相同哈希槽的请求依然会发送到原节点而不是目标节点。</li>
</ol>
<h4 id="MOVED"><a href="#MOVED" class="headerlink" title="MOVED"></a>MOVED</h4><ol>
<li>当客户端请求的 key 对应的哈希槽迁移完成，就会返回 -MOVED 重定向错误，告知客户端当前哈希槽是由哪个节点负责，客户端向目标节点发送请求并更新缓存的哈希槽分配信息。</li>
</ol>
<h4 id="客户端缓存插槽与节点映射表"><a href="#客户端缓存插槽与节点映射表" class="headerlink" title="客户端缓存插槽与节点映射表"></a>客户端缓存插槽与节点映射表</h4><p>当 Redis 客户端连接到集群时，会通过 <code>CLUSTER SLOTS</code> 命令从 Redis 获取插槽与节点的对应关系。客户端将这张表缓存起来，用于后续操作中快速定位目标节点，而无需每次操作都向服务器查询。减少了每次请求都需要额外的网络交互来查询插槽分布，增加延迟。</p>
<p>缓存后，客户端可以直接根据键快速定位目标节点并发送请求。</p>
<h1 id="——多级缓存——"><a href="#——多级缓存——" class="headerlink" title="——多级缓存——"></a>——多级缓存——</h1><h1 id="一、什么是多级缓存"><a href="#一、什么是多级缓存" class="headerlink" title="一、什么是多级缓存"></a>一、什么是多级缓存</h1><p>传统的缓存策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821075259137.png" alt="image-20210821075259137"></p>
<p>存在下面的问题：</p>
<p>•请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈</p>
<p>•Redis缓存失效时，会对数据库产生冲击</p>
<p>多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能：</p>
<ul>
<li>浏览器访问静态资源时，优先读取浏览器本地缓存</li>
<li>访问非静态资源（ajax查询数据）时，访问服务端</li>
<li>请求到达Nginx后，优先读取Nginx本地缓存</li>
<li>如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）</li>
<li>如果Redis查询未命中，则查询Tomcat</li>
<li>请求进入Tomcat后，优先查询JVM进程缓存</li>
<li>如果JVM进程缓存未命中，则查询数据库</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821075558137.png" alt="image-20210821075558137"></p>
<p>在多级缓存架构中，Nginx内部需要编写本地缓存查询、Redis查询、Tomcat查询的业务逻辑，因此这样的nginx服务不再是一个<strong>反向代理服务器</strong>，而是一个编写<strong>业务的Web服务器了</strong>。</p>
<p>因此这样的业务Nginx服务也需要搭建集群来提高并发，再有专门的nginx服务来做反向代理，如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821080511581.png" alt="image-20210821080511581"></p>
<p>另外，我们的Tomcat服务将来也会部署为集群模式：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821080954947.png" alt="image-20210821080954947"></p>
<p>可见，多级缓存的关键有两个：</p>
<ul>
<li><p>一个是在nginx中编写业务，实现nginx本地缓存、Redis、Tomcat的查询</p>
</li>
<li><p>另一个就是在Tomcat中实现JVM进程缓存</p>
</li>
</ul>
<p>其中Nginx编程则会用到OpenResty框架结合Lua这样的语言。</p>
<h1 id="二、JVM进程缓存"><a href="#二、JVM进程缓存" class="headerlink" title="二、JVM进程缓存"></a>二、JVM进程缓存</h1><p>为了演示多级缓存的案例，我们先准备一个商品查询的业务。</p>
<h2 id="导入案例"><a href="#导入案例" class="headerlink" title="导入案例"></a>导入案例</h2><p>参考课前资料的：《案例导入说明.md》</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821081418456.png" alt="image-20210821081418456"> </p>
<h2 id="初识Caffeine"><a href="#初识Caffeine" class="headerlink" title="初识Caffeine"></a>初识Caffeine</h2><p>缓存在日常开发中启动至关重要的作用，由于是存储在内存中，数据的读取速度是非常快的，能大量减少对数据库的访问，减少数据库的压力。我们把缓存分为两类：</p>
<ul>
<li>分布式缓存，例如Redis：<ul>
<li>优点：存储容量更大、可靠性更好、可以在集群间共享</li>
<li>缺点：访问缓存有网络开销</li>
<li>场景：缓存数据量较大、可靠性要求较高、需要在集群间共享</li>
</ul>
</li>
<li>进程本地缓存，例如HashMap、GuavaCache：<ul>
<li>优点：读取本地内存，没有网络开销，速度更快</li>
<li>缺点：存储容量有限、可靠性较低、无法共享</li>
<li>场景：性能要求较高，缓存数据量较小</li>
</ul>
</li>
</ul>
<p>我们今天会利用Caffeine框架来实现JVM进程缓存。</p>
<p><strong>Caffeine</strong>是一个基于Java8开发的，提供了近乎最佳命中率的高性能的本地缓存库。目前Spring内部的缓存使用的就是Caffeine。GitHub地址：<a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine">https://github.com/ben-manes/caffeine</a></p>
<p>Caffeine的性能非常好，下图是官方给出的性能对比：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821081826399.png" alt="image-20210821081826399"></p>
<p>可以看到Caffeine的性能遥遥领先！</p>
<p>缓存使用的基本API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBasicOps</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 构建cache对象</span></span><br><span class="line">    Cache&lt;String, String&gt; cache = Caffeine.newBuilder().build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存数据</span></span><br><span class="line">    cache.put(<span class="string">&quot;gf&quot;</span>, <span class="string">&quot;迪丽热巴&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">gf</span> <span class="operator">=</span> cache.getIfPresent(<span class="string">&quot;gf&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;gf = &quot;</span> + gf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取数据，包含两个参数：</span></span><br><span class="line">    <span class="comment">// 参数一：缓存的key</span></span><br><span class="line">    <span class="comment">// 参数二：Lambda表达式，表达式参数就是缓存的key，方法体是查询数据库的逻辑</span></span><br><span class="line">    <span class="comment">// 优先根据key查询JVM缓存，如果未命中，则执行参数二的Lambda表达式</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">defaultGF</span> <span class="operator">=</span> cache.get(<span class="string">&quot;defaultGF&quot;</span>, key -&gt; &#123;</span><br><span class="line">        <span class="comment">// 根据key去数据库查询数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;柳岩&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;defaultGF = &quot;</span> + defaultGF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>Caffeine既然是缓存的一种，肯定需要有缓存的清除策略，不然的话内存总会有耗尽的时候。</p>
<p>Caffeine提供了三种缓存驱逐策略：</p>
<ul>
<li><p><strong>基于容量</strong>：设置缓存的数量上限</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建缓存对象</span></span><br><span class="line">Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">1</span>) <span class="comment">// 设置缓存大小上限为 1</span></span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>基于时间</strong>：设置缓存的有效时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建缓存对象</span></span><br><span class="line">Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    <span class="comment">// 设置缓存有效期为 10 秒，从最后一次写入开始计时 </span></span><br><span class="line">    .expireAfterWrite(Duration.ofSeconds(<span class="number">10</span>)) </span><br><span class="line">    .build();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong>基于引用</strong>：设置缓存为软引用或弱引用，利用GC来回收缓存数据。性能较差，不建议使用。</p>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>：在默认情况下，当一个缓存元素过期的时候，Caffeine不会自动立即将其清理和驱逐。而是在一次读或写操作后，或者在空闲时间完成对失效数据的驱逐。</p>
</blockquote>
<h2 id="实现JVM进程缓存"><a href="#实现JVM进程缓存" class="headerlink" title="实现JVM进程缓存"></a>实现JVM进程缓存</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>利用Caffeine实现下列需求：</p>
<ul>
<li>给根据id查询商品的业务添加缓存，缓存未命中时查询数据库</li>
<li>给根据id查询商品库存的业务添加缓存，缓存未命中时查询数据库</li>
<li>缓存初始大小为100</li>
<li>缓存上限为10000</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>首先，我们需要定义两个Caffeine的缓存对象，分别保存商品、库存的缓存数据。</p>
<p>在item-service的<code>com.heima.item.config</code>包下定义<code>CaffeineConfig</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Caffeine;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.ItemStock;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaffeineConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cache&lt;Long, Item&gt; <span class="title function_">itemCache</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Caffeine.newBuilder()</span><br><span class="line">                .initialCapacity(<span class="number">100</span>)</span><br><span class="line">                .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cache&lt;Long, ItemStock&gt; <span class="title function_">stockCache</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Caffeine.newBuilder()</span><br><span class="line">                .initialCapacity(<span class="number">100</span>)</span><br><span class="line">                .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后，修改item-service中的<code>com.heima.item.web</code>包下的ItemController类，添加缓存逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;item&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemService itemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemStockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;Long, Item&gt; itemCache;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;Long, ItemStock&gt; stockCache;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...其它略</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemCache.get(id, key -&gt; itemService.query()</span><br><span class="line">                .ne(<span class="string">&quot;status&quot;</span>, <span class="number">3</span>).eq(<span class="string">&quot;id&quot;</span>, key)</span><br><span class="line">                .one()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/stock/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ItemStock <span class="title function_">findStockById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stockCache.get(id, key -&gt; stockService.getById(key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="三、Lua语法入门"><a href="#三、Lua语法入门" class="headerlink" title="三、Lua语法入门"></a>三、Lua语法入门</h1><p>Nginx编程需要用到Lua语言，因此我们必须先入门Lua的基本语法。</p>
<h2 id="初识Lua"><a href="#初识Lua" class="headerlink" title="初识Lua"></a>初识Lua</h2><p>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。官网：<a target="_blank" rel="noopener" href="https://www.lua.org/">https://www.lua.org/</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821091437975.png" alt="image-20210821091437975"></p>
<p>Lua经常嵌入到C语言开发的程序中，例如游戏开发、游戏插件等。</p>
<p>Nginx本身也是C语言开发，因此也允许基于Lua做拓展。</p>
<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>CentOS7默认已经安装了Lua语言环境，所以可以直接运行Lua代码。</p>
<p>1）在Linux虚拟机的任意目录下，新建一个hello.lua文件</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821091621308.png" alt="image-20210821091621308"></p>
<p>2）添加下面的内容</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)  </span><br></pre></td></tr></table></figure>



<p>3）运行</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821091638140.png" alt="image-20210821091638140"></p>
<h2 id="变量和循环"><a href="#变量和循环" class="headerlink" title="变量和循环"></a>变量和循环</h2><p>学习任何语言必然离不开变量，而变量的声明必须先知道数据的类型。</p>
<h3 id="Lua的数据类型"><a href="#Lua的数据类型" class="headerlink" title="Lua的数据类型"></a>Lua的数据类型</h3><p>Lua中支持的常见数据类型包括：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821091835406.png" alt="image-20210821091835406"></p>
<p>另外，Lua提供了type()函数来判断一个变量的数据类型：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821091904332.png" alt="image-20210821091904332"></p>
<h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><p>Lua声明变量的时候无需指定数据类型，而是用local来声明变量为局部变量：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明字符串，可以用单引号或双引号，</span></span><br><span class="line"><span class="keyword">local</span> str = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">-- 字符串拼接可以使用 ..</span></span><br><span class="line"><span class="keyword">local</span> str2 = <span class="string">&#x27;hello&#x27;</span> .. <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="comment">-- 声明数字</span></span><br><span class="line"><span class="keyword">local</span> num = <span class="number">21</span></span><br><span class="line"><span class="comment">-- 声明布尔类型</span></span><br><span class="line"><span class="keyword">local</span> flag = <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<p>Lua中的table类型既可以作为数组，又可以作为Java中的map来使用。数组就是特殊的table，key是数组角标而已：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明数组 ，key为角标的 table</span></span><br><span class="line"><span class="keyword">local</span> arr = &#123;<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;lua&#x27;</span>&#125;</span><br><span class="line"><span class="comment">-- 声明table，类似java的map</span></span><br><span class="line"><span class="keyword">local</span> map =  &#123;name=<span class="string">&#x27;Jack&#x27;</span>, age=<span class="number">21</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Lua中的数组角标是从1开始，访问的时候与Java中类似：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 访问数组，lua数组的角标从1开始</span></span><br><span class="line"><span class="built_in">print</span>(arr[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>Lua中的table可以用key来访问：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 访问table</span></span><br><span class="line"><span class="built_in">print</span>(map[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(map.name)</span><br></pre></td></tr></table></figure>



<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>对于table，我们可以利用for循环来遍历。不过数组和普通table遍历略有差异。</p>
<p>遍历数组：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明数组 key为索引的 table</span></span><br><span class="line"><span class="keyword">local</span> arr = &#123;<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;lua&#x27;</span>&#125;</span><br><span class="line"><span class="comment">-- 遍历数组</span></span><br><span class="line"><span class="keyword">for</span> index,value <span class="keyword">in</span> <span class="built_in">ipairs</span>(arr) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(index, value) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>遍历普通table</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明map，也就是table</span></span><br><span class="line"><span class="keyword">local</span> map = &#123;name=<span class="string">&#x27;Jack&#x27;</span>, age=<span class="number">21</span>&#125;</span><br><span class="line"><span class="comment">-- 遍历table</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> <span class="built_in">pairs</span>(map) <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(key, value) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>







<h2 id="条件控制、函数"><a href="#条件控制、函数" class="headerlink" title="条件控制、函数"></a>条件控制、函数</h2><p>Lua中的条件控制和函数声明与Java类似。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>定义函数的语法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名<span class="params">( argument1, argument2..., argumentn)</span></span></span><br><span class="line">    <span class="comment">-- 函数体</span></span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>例如，定义一个函数，用来打印数组：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArr</span><span class="params">(arr)</span></span></span><br><span class="line">    <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">ipairs</span>(arr) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h3><p>类似Java的条件控制，例如if、else语法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 布尔表达式为 true 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="comment">--[ 布尔表达式为 false 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>与java不同，布尔表达式中的逻辑运算是基于英文单词：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821092657918.png" alt="image-20210821092657918"></p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>需求：自定义一个函数，可以打印table，当参数为nil时，打印错误信息</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArr</span><span class="params">(arr)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> arr <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;数组不能为空！&#x27;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">ipairs</span>(arr) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>





<h1 id="四、实现多级缓存"><a href="#四、实现多级缓存" class="headerlink" title="四、实现多级缓存"></a>四、实现多级缓存</h1><p>多级缓存的实现离不开Nginx编程，而Nginx编程又离不开OpenResty。</p>
<h2 id="安装OpenResty"><a href="#安装OpenResty" class="headerlink" title="安装OpenResty"></a>安装OpenResty</h2><p>OpenResty® 是一个基于 Nginx的高性能 Web 平台，用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。具备下列特点：</p>
<ul>
<li>具备Nginx的完整功能</li>
<li>基于Lua语言进行扩展，集成了大量精良的 Lua 库、第三方模块</li>
<li>允许使用Lua<strong>自定义业务逻辑</strong>、<strong>自定义库</strong></li>
</ul>
<p>官方网站： <a target="_blank" rel="noopener" href="https://openresty.org/cn/">https://openresty.org/cn/</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821092902946.png" alt="image-20210821092902946"></p>
<p>安装Lua可以参考课前资料提供的《安装OpenResty.md》：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821092941139.png" alt="image-20210821092941139"> </p>
<h2 id="OpenResty快速入门"><a href="#OpenResty快速入门" class="headerlink" title="OpenResty快速入门"></a>OpenResty快速入门</h2><p>我们希望达到的多级缓存架构如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/yeVDlwtfMx.png" alt="yeVDlwtfMx"></p>
<p>其中：</p>
<ul>
<li><p>windows上的nginx用来做反向代理服务，将前端的查询商品的ajax请求代理到OpenResty集群</p>
</li>
<li><p>OpenResty集群用来编写多级缓存业务</p>
</li>
</ul>
<h3 id="反向代理流程"><a href="#反向代理流程" class="headerlink" title="反向代理流程"></a>反向代理流程</h3><p>现在，商品详情页使用的是假的商品数据。不过在浏览器中，可以看到页面有发起ajax请求查询真实商品数据。</p>
<p>这个请求如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821093144700.png" alt="image-20210821093144700"></p>
<p>请求地址是localhost，端口是80，就被windows上安装的Nginx服务给接收到了。然后代理给了OpenResty集群：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821094447709.png" alt="image-20210821094447709"></p>
<p>我们需要在OpenResty中编写业务，查询商品数据并返回到浏览器。</p>
<p>但是这次，我们先在OpenResty接收请求，返回假的商品数据。</p>
<h3 id="OpenResty监听请求"><a href="#OpenResty监听请求" class="headerlink" title="OpenResty监听请求"></a>OpenResty监听请求</h3><p>OpenResty的很多功能都依赖于其目录下的Lua库，需要在nginx.conf中指定依赖库的目录，并导入依赖：</p>
<p>1）添加对OpenResty的Lua模块的加载</p>
<p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，在其中的http下面，添加下面代码：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#lua 模块</span></span><br><span class="line"><span class="attribute">lua_package_path</span> <span class="string">&quot;/usr/local/openresty/lualib/?.lua;;&quot;</span>;</span><br><span class="line"><span class="comment">#c模块     </span></span><br><span class="line"><span class="attribute">lua_package_cpath</span> <span class="string">&quot;/usr/local/openresty/lualib/?.so;;&quot;</span>;  </span><br></pre></td></tr></table></figure>



<p>2）监听/api/item路径</p>
<p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，在nginx.conf的server下面，添加对/api/item这个路径的监听：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span>  /api/item &#123;</span><br><span class="line">    <span class="comment"># 默认的响应类型</span></span><br><span class="line">    <span class="attribute">default_type</span> application/json;</span><br><span class="line">    <span class="comment"># 响应结果由lua/item.lua文件来决定</span></span><br><span class="line">    <span class="attribute">content_by_lua_file</span> lua/item.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个监听，就类似于SpringMVC中的<code>@GetMapping(&quot;/api/item&quot;)</code>做路径映射。</p>
<p>而<code>content_by_lua_file lua/item.lua</code>则相当于调用item.lua这个文件，执行其中的业务，把结果返回给用户。相当于java中调用service。</p>
<h3 id="编写item-lua"><a href="#编写item-lua" class="headerlink" title="编写item.lua"></a>编写item.lua</h3><p>1）在<code>/usr/loca/openresty/nginx</code>目录创建文件夹：lua</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821100755080.png" alt="image-20210821100755080"></p>
<p>2）在<code>/usr/loca/openresty/nginx/lua</code>文件夹下，新建文件：item.lua</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821100801756.png" alt="image-20210821100801756"></p>
<p>3）编写item.lua，返回假数据</p>
<p>item.lua中，利用ngx.say()函数返回数据到Response中</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(<span class="string">&#x27;&#123;&quot;id&quot;:10001,&quot;name&quot;:&quot;SALSA AIR&quot;,&quot;title&quot;:&quot;RIMOWA 21寸托运箱拉杆箱 SALSA AIR系列果绿色 820.70.36.4&quot;,&quot;price&quot;:17900,&quot;image&quot;:&quot;https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp&quot;,&quot;category&quot;:&quot;拉杆箱&quot;,&quot;brand&quot;:&quot;RIMOWA&quot;,&quot;spec&quot;:&quot;&quot;,&quot;status&quot;:1,&quot;createTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;updateTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;stock&quot;:2999,&quot;sold&quot;:31290&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>4）重新加载配置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>



<p>刷新商品页面：<a target="_blank" rel="noopener" href="http://localhost/item.html?id=1001%EF%BC%8C%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E6%95%88%E6%9E%9C%EF%BC%9A">http://localhost/item.html?id=1001，即可看到效果：</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821101217089.png" alt="image-20210821101217089"></p>
<h2 id="请求参数处理"><a href="#请求参数处理" class="headerlink" title="请求参数处理"></a>请求参数处理</h2><p>上一节中，我们在OpenResty接收前端请求，但是返回的是假数据。</p>
<p>要返回真实数据，必须根据前端传递来的商品id，查询商品信息才可以。</p>
<p>那么如何获取前端传递的商品参数呢？</p>
<h3 id="获取参数的API"><a href="#获取参数的API" class="headerlink" title="获取参数的API"></a>获取参数的API</h3><p>OpenResty中提供了一些API用来获取不同类型的前端请求参数：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821101433528.png" alt="image-20210821101433528"></p>
<h3 id="获取参数并返回"><a href="#获取参数并返回" class="headerlink" title="获取参数并返回"></a>获取参数并返回</h3><p>在前端发起的ajax请求如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821101721649.png" alt="image-20210821101721649"></p>
<p>可以看到商品id是以路径占位符方式传递的，因此可以利用正则表达式匹配的方式来获取ID</p>
<p>1）获取商品id</p>
<p>修改<code>/usr/loca/openresty/nginx/nginx.conf</code>文件中监听/api/item的代码，利用正则表达式获取ID：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ /api/item/(\d+)</span> &#123;</span><br><span class="line">    <span class="comment"># 默认的响应类型</span></span><br><span class="line">    <span class="attribute">default_type</span> application/json;</span><br><span class="line">    <span class="comment"># 响应结果由lua/item.lua文件来决定</span></span><br><span class="line">    <span class="attribute">content_by_lua_file</span> lua/item.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2）拼接ID并返回</p>
<p>修改<code>/usr/loca/openresty/nginx/lua/item.lua</code>文件，获取id并拼接到结果中返回：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取商品id</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 拼接并返回</span></span><br><span class="line">ngx.say(<span class="string">&#x27;&#123;&quot;id&quot;:&#x27;</span> .. id .. <span class="string">&#x27;,&quot;name&quot;:&quot;SALSA AIR&quot;,&quot;title&quot;:&quot;RIMOWA 21寸托运箱拉杆箱 SALSA AIR系列果绿色 820.70.36.4&quot;,&quot;price&quot;:17900,&quot;image&quot;:&quot;https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp&quot;,&quot;category&quot;:&quot;拉杆箱&quot;,&quot;brand&quot;:&quot;RIMOWA&quot;,&quot;spec&quot;:&quot;&quot;,&quot;status&quot;:1,&quot;createTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;updateTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;stock&quot;:2999,&quot;sold&quot;:31290&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>3）重新加载并测试</p>
<p>运行命令以重新加载OpenResty配置：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>



<p>刷新页面可以看到结果中已经带上了ID：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821102235467.png" alt="image-20210821102235467"> </p>
<h2 id="查询Tomcat"><a href="#查询Tomcat" class="headerlink" title="查询Tomcat"></a>查询Tomcat</h2><p>拿到商品ID后，本应去缓存中查询商品信息，不过目前我们还未建立nginx、redis缓存。因此，这里我们先根据商品id去tomcat查询商品信息。我们实现如图部分：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821102610167.png" alt="image-20210821102610167"></p>
<p>需要注意的是，我们的OpenResty是在虚拟机，Tomcat是在Windows电脑上。两者IP一定不要搞错了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821102959829.png" alt="image-20210821102959829"></p>
<h3 id="发送http请求的API"><a href="#发送http请求的API" class="headerlink" title="发送http请求的API"></a>发送http请求的API</h3><p>nginx提供了内部API用以发送http请求：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> resp = ngx.location.capture(<span class="string">&quot;/path&quot;</span>,&#123;</span><br><span class="line">    method = ngx.HTTP_GET,   <span class="comment">-- 请求方式</span></span><br><span class="line">    args = &#123;a=<span class="number">1</span>,b=<span class="number">2</span>&#125;,  <span class="comment">-- get方式传参数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>返回的响应内容包括：</p>
<ul>
<li>resp.status：响应状态码</li>
<li>resp.header：响应头，是一个table</li>
<li>resp.body：响应体，就是响应数据</li>
</ul>
<p>注意：这里的path是路径，并不包含IP和端口。这个请求会被nginx内部的server监听并处理。</p>
<p>但是我们希望这个请求发送到Tomcat服务器，所以还需要编写一个server来对这个路径做反向代理：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /path &#123;</span><br><span class="line">    <span class="comment"># 这里是windows电脑的ip和Java服务端口，需要确保windows防火墙处于关闭状态</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.150.1:8081; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>原理如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821104149061.png" alt="image-20210821104149061"></p>
<h3 id="封装http工具"><a href="#封装http工具" class="headerlink" title="封装http工具"></a>封装http工具</h3><p>下面，我们封装一个发送Http请求的工具，基于ngx.location.capture来实现查询tomcat。</p>
<p>1）添加反向代理，到windows的Java服务</p>
<p>因为item-service中的接口都是/item开头，所以我们监听/item路径，代理到windows上的tomcat服务。</p>
<p>修改 <code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，添加一个location：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /item &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.150.1:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以后，只要我们调用<code>ngx.location.capture(&quot;/item&quot;)</code>，就一定能发送请求到windows的tomcat服务。</p>
<p>2）封装工具类</p>
<p>之前我们说过，OpenResty启动时会加载以下两个目录中的工具文件：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821104857413.png" alt="image-20210821104857413"></p>
<p>所以，自定义的http工具也需要放到这个目录下。</p>
<p>在<code>/usr/local/openresty/lualib</code>目录下，新建一个common.lua文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/local/openresty/lualib/common.lua</span><br></pre></td></tr></table></figure>

<p>内容如下:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 封装函数，发送http请求，并解析响应</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_http</span><span class="params">(path, params)</span></span></span><br><span class="line">    <span class="keyword">local</span> resp = ngx.location.capture(<span class="built_in">path</span>,&#123;</span><br><span class="line">        method = ngx.HTTP_GET,</span><br><span class="line">        args = params,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 记录错误信息，返回404</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;http请求查询失败, path: &quot;</span>, <span class="built_in">path</span> , <span class="string">&quot;, args: &quot;</span>, args)</span><br><span class="line">        ngx.<span class="built_in">exit</span>(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> resp.body</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 将方法导出</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;  </span><br><span class="line">    read_http = read_http</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure>



<p>这个工具将read_http函数封装到_M这个table类型的变量中，并且返回，这类似于导出。</p>
<p>使用的时候，可以利用<code>require(&#39;common&#39;)</code>来导入该函数库，这里的common是函数库的文件名。</p>
<p>3）实现商品查询</p>
<p>最后，我们修改<code>/usr/local/openresty/lua/item.lua</code>文件，利用刚刚封装的函数库实现对tomcat的查询：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 引入自定义common工具模块，返回值是common中返回的 _M</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&quot;common&quot;</span>)</span><br><span class="line"><span class="comment">-- 从 common中获取read_http这个函数</span></span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 根据id查询商品</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_http(<span class="string">&quot;/item/&quot;</span>.. id, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 根据id查询商品库存</span></span><br><span class="line"><span class="keyword">local</span> itemStockJSON = read_http(<span class="string">&quot;/item/stock/&quot;</span>.. id, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>



<p>这里查询到的结果是json字符串，并且包含商品、库存两个json字符串，页面最终需要的是把两个json拼接为一个json：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821110441222.png" alt="image-20210821110441222"></p>
<p>这就需要我们先把JSON变为lua的table，完成数据整合后，再转为JSON。</p>
<h3 id="CJSON工具类"><a href="#CJSON工具类" class="headerlink" title="CJSON工具类"></a>CJSON工具类</h3><p>OpenResty提供了一个cjson的模块用来处理JSON的序列化和反序列化。</p>
<p>官方地址： <a target="_blank" rel="noopener" href="https://github.com/openresty/lua-cjson/">https://github.com/openresty/lua-cjson/</a></p>
<p>1）引入cjson模块：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span> <span class="string">&quot;cjson&quot;</span></span><br></pre></td></tr></table></figure>



<p>2）序列化：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> obj = &#123;</span><br><span class="line">    name = <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    age = <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">-- 把 table 序列化为 json</span></span><br><span class="line"><span class="keyword">local</span> json = cjson.encode(obj)</span><br></pre></td></tr></table></figure>



<p>3）反序列化：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> json = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;jack&quot;, &quot;age&quot;: 21&#125;&#x27;</span></span><br><span class="line"><span class="comment">-- 反序列化 json为 table</span></span><br><span class="line"><span class="keyword">local</span> obj = cjson.decode(json);</span><br><span class="line"><span class="built_in">print</span>(obj.name)</span><br></pre></td></tr></table></figure>





<h3 id="实现Tomcat查询"><a href="#实现Tomcat查询" class="headerlink" title="实现Tomcat查询"></a>实现Tomcat查询</h3><p>下面，我们修改之前的item.lua中的业务，添加json处理功能：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入common函数库</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&#x27;common&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="comment">-- 导入cjson库</span></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">&#x27;cjson&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 根据id查询商品</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_http(<span class="string">&quot;/item/&quot;</span>.. id, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 根据id查询商品库存</span></span><br><span class="line"><span class="keyword">local</span> itemStockJSON = read_http(<span class="string">&quot;/item/stock/&quot;</span>.. id, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSON转化为lua的table</span></span><br><span class="line"><span class="keyword">local</span> item = cjson.decode(itemJSON)</span><br><span class="line"><span class="keyword">local</span> stock = cjson.decode(stockJSON)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 组合数据</span></span><br><span class="line">item.stock = stock.stock</span><br><span class="line">item.sold = stock.sold</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把item序列化为json 返回结果</span></span><br><span class="line">ngx.say(cjson.encode(item))</span><br></pre></td></tr></table></figure>



<h3 id="基于ID负载均衡"><a href="#基于ID负载均衡" class="headerlink" title="基于ID负载均衡"></a>基于ID负载均衡</h3><p>刚才的代码中，我们的tomcat是单机部署。而实际开发中，tomcat一定是集群模式：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821111023255.png" alt="image-20210821111023255"></p>
<p>因此，OpenResty需要对tomcat集群做负载均衡。</p>
<p>而默认的负载均衡规则是轮询模式，当我们查询/item/10001时：</p>
<ul>
<li>第一次会访问8081端口的tomcat服务，在该服务内部就形成了JVM进程缓存</li>
<li>第二次会访问8082端口的tomcat服务，该服务内部没有JVM缓存（因为JVM缓存无法共享），会查询数据库</li>
<li>…</li>
</ul>
<p>你看，因为轮询的原因，第一次查询8081形成的JVM缓存并未生效，直到下一次再次访问到8081时才可以生效，缓存命中率太低了。</p>
<p>怎么办？</p>
<p>如果能让同一个商品，每次查询时都访问同一个tomcat服务，那么JVM缓存就一定能生效了。</p>
<p>也就是说，我们需要根据商品id做负载均衡，而不是轮询。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>nginx提供了基于请求路径做负载均衡的算法：</p>
<p>nginx根据请求路径做hash运算，把得到的数值对tomcat服务的数量取余，余数是几，就访问第几个服务，实现负载均衡。</p>
<p>例如：</p>
<ul>
<li>我们的请求路径是 /item/10001</li>
<li>tomcat总数为2台（8081、8082）</li>
<li>对请求路径/item/1001做hash运算求余的结果为1</li>
<li>则访问第一个tomcat服务，也就是8081</li>
</ul>
<p>只要id不变，每次hash运算结果也不会变，那就可以保证同一个商品，一直访问同一个tomcat服务，确保JVM缓存生效。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，实现基于ID做负载均衡。</p>
<p>首先，定义tomcat集群，并设置基于路径做负载均衡：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> tomcat-cluster &#123;</span><br><span class="line">    <span class="attribute">hash</span> <span class="variable">$request_uri</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.150.1:8081</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.150.1:8082</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，修改对tomcat服务的反向代理，目标指向tomcat集群：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /item &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://tomcat-cluster;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新加载OpenResty</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>





<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>启动两台tomcat服务：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821112420464.png" alt="image-20210821112420464"></p>
<p>同时启动：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821112444482.png" alt="image-20210821112444482"> </p>
<p>清空日志后，再次访问页面，可以看到不同id的商品，访问到了不同的tomcat服务：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821112559965.png" alt="image-20210821112559965"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821112637430.png" alt="image-20210821112637430"></p>
<h2 id="Redis缓存预热"><a href="#Redis缓存预热" class="headerlink" title="Redis缓存预热"></a>Redis缓存预热</h2><p>Redis缓存会面临冷启动问题：</p>
<p><strong>冷启动</strong>：服务刚刚启动时，Redis中并没有缓存，如果所有商品数据都在第一次查询时添加缓存，可能会给数据库带来较大压力。</p>
<p><strong>缓存预热</strong>：在实际开发中，我们可以利用大数据统计用户访问的热点数据，在项目启动时将这些热点数据提前查询并保存到Redis中。</p>
<p>我们数据量较少，并且没有数据统计相关功能，目前可以在启动时将所有数据都放入缓存中。</p>
<p>1）利用Docker安装Redis</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 -d redis redis-server --appendonly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>



<p>2）在item-service服务中引入Redis依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>3）配置Redis地址</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>



<p>4）编写初始化类</p>
<p>缓存预热需要在项目启动时完成，并且必须是拿到RedisTemplate之后。</p>
<p>这里我们利用InitializingBean接口来实现，因为InitializingBean可以在对象被Spring创建并且成员变量全部注入后执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.ItemStock;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemService;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemStockService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisHandler</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemService itemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemStockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">MAPPER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 初始化缓存</span></span><br><span class="line">        <span class="comment">// 1.查询商品信息</span></span><br><span class="line">        List&lt;Item&gt; itemList = itemService.list();</span><br><span class="line">        <span class="comment">// 2.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (Item item : itemList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(item);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:id:&quot;</span> + item.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询商品库存信息</span></span><br><span class="line">        List&lt;ItemStock&gt; stockList = stockService.list();</span><br><span class="line">        <span class="comment">// 4.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (ItemStock stock : stockList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(stock);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:stock:id:&quot;</span> + stock.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="查询Redis缓存"><a href="#查询Redis缓存" class="headerlink" title="查询Redis缓存"></a>查询Redis缓存</h2><p>现在，Redis缓存已经准备就绪，我们可以再OpenResty中实现查询Redis的逻辑了。如下图红框所示：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821113340111.png" alt="image-20210821113340111"></p>
<p>当请求进入OpenResty之后：</p>
<ul>
<li>优先查询Redis缓存</li>
<li>如果Redis缓存未命中，再查询Tomcat</li>
</ul>
<h3 id="封装Redis工具"><a href="#封装Redis工具" class="headerlink" title="封装Redis工具"></a>封装Redis工具</h3><p>OpenResty提供了操作Redis的模块，我们只要引入该模块就能直接使用。但是为了方便，我们将Redis操作封装到之前的common.lua工具库中。</p>
<p>修改<code>/usr/local/openresty/lualib/common.lua</code>文件：</p>
<p>1）引入Redis模块，并初始化Redis对象</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入redis</span></span><br><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span>(<span class="string">&#x27;resty.redis&#x27;</span>)</span><br><span class="line"><span class="comment">-- 初始化redis</span></span><br><span class="line"><span class="keyword">local</span> red = redis:new()</span><br><span class="line">red:set_timeouts(<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>



<p>2）封装函数，用来释放Redis连接，其实是放入连接池</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 关闭redis连接的工具方法，其实是放入连接池</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">close_redis</span><span class="params">(red)</span></span></span><br><span class="line">    <span class="keyword">local</span> pool_max_idle_time = <span class="number">10000</span> <span class="comment">-- 连接的空闲时间，单位是毫秒</span></span><br><span class="line">    <span class="keyword">local</span> pool_size = <span class="number">100</span> <span class="comment">--连接池大小</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = red:set_keepalive(pool_max_idle_time, pool_size)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;放入redis连接池失败: &quot;</span>, err)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>3）封装函数，根据key查询Redis数据</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询redis的方法 ip和port是redis地址，key是查询的key</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_redis</span><span class="params">(ip, port, key)</span></span></span><br><span class="line">    <span class="comment">-- 获取一个连接</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = red:connect(ip, port)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;连接redis失败 : &quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 查询redis</span></span><br><span class="line">    <span class="keyword">local</span> resp, err = red:get(key)</span><br><span class="line">    <span class="comment">-- 查询失败处理</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis失败: &quot;</span>, err, <span class="string">&quot;, key = &quot;</span> , key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">--得到的数据为空处理</span></span><br><span class="line">    <span class="keyword">if</span> resp == ngx.null <span class="keyword">then</span></span><br><span class="line">        resp = <span class="literal">nil</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis数据为空, key = &quot;</span>, key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    close_redis(red)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>4）导出</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将方法导出</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;  </span><br><span class="line">    read_http = read_http,</span><br><span class="line">    read_redis = read_redis</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure>



<p>完整的common.lua：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入redis</span></span><br><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span>(<span class="string">&#x27;resty.redis&#x27;</span>)</span><br><span class="line"><span class="comment">-- 初始化redis</span></span><br><span class="line"><span class="keyword">local</span> red = redis:new()</span><br><span class="line">red:set_timeouts(<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭redis连接的工具方法，其实是放入连接池</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">close_redis</span><span class="params">(red)</span></span></span><br><span class="line">    <span class="keyword">local</span> pool_max_idle_time = <span class="number">10000</span> <span class="comment">-- 连接的空闲时间，单位是毫秒</span></span><br><span class="line">    <span class="keyword">local</span> pool_size = <span class="number">100</span> <span class="comment">--连接池大小</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = red:set_keepalive(pool_max_idle_time, pool_size)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;放入redis连接池失败: &quot;</span>, err)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询redis的方法 ip和port是redis地址，key是查询的key</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_redis</span><span class="params">(ip, port, key)</span></span></span><br><span class="line">    <span class="comment">-- 获取一个连接</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = red:connect(ip, port)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;连接redis失败 : &quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 查询redis</span></span><br><span class="line">    <span class="keyword">local</span> resp, err = red:get(key)</span><br><span class="line">    <span class="comment">-- 查询失败处理</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis失败: &quot;</span>, err, <span class="string">&quot;, key = &quot;</span> , key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">--得到的数据为空处理</span></span><br><span class="line">    <span class="keyword">if</span> resp == ngx.null <span class="keyword">then</span></span><br><span class="line">        resp = <span class="literal">nil</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis数据为空, key = &quot;</span>, key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    close_redis(red)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装函数，发送http请求，并解析响应</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_http</span><span class="params">(path, params)</span></span></span><br><span class="line">    <span class="keyword">local</span> resp = ngx.location.capture(<span class="built_in">path</span>,&#123;</span><br><span class="line">        method = ngx.HTTP_GET,</span><br><span class="line">        args = params,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 记录错误信息，返回404</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;http查询失败, path: &quot;</span>, <span class="built_in">path</span> , <span class="string">&quot;, args: &quot;</span>, args)</span><br><span class="line">        ngx.<span class="built_in">exit</span>(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> resp.body</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 将方法导出</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;  </span><br><span class="line">    read_http = read_http,</span><br><span class="line">    read_redis = read_redis</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure>





<h3 id="实现Redis查询"><a href="#实现Redis查询" class="headerlink" title="实现Redis查询"></a>实现Redis查询</h3><p>接下来，我们就可以去修改item.lua文件，实现对Redis的查询了。</p>
<p>查询逻辑是：</p>
<ul>
<li>根据id查询Redis</li>
<li>如果查询失败则继续查询Tomcat</li>
<li>将查询结果返回</li>
</ul>
<p>1）修改<code>/usr/local/openresty/lua/item.lua</code>文件，添加一个查询函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入common函数库</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&#x27;common&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="keyword">local</span> read_redis = common.read_redis</span><br><span class="line"><span class="comment">-- 封装查询函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, path, params)</span></span></span><br><span class="line">    <span class="comment">-- 查询本地缓存</span></span><br><span class="line">    <span class="keyword">local</span> val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, key)</span><br><span class="line">    <span class="comment">-- 判断查询结果</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)</span><br><span class="line">        <span class="comment">-- redis查询失败，去查询http</span></span><br><span class="line">        val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>2）而后修改商品查询、库存查询的业务：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821114528954.png" alt="image-20210821114528954"></p>
<p>3）完整的item.lua代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入common函数库</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&#x27;common&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="keyword">local</span> read_redis = common.read_redis</span><br><span class="line"><span class="comment">-- 导入cjson库</span></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">&#x27;cjson&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装查询函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, path, params)</span></span></span><br><span class="line">    <span class="comment">-- 查询本地缓存</span></span><br><span class="line">    <span class="keyword">local</span> val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, key)</span><br><span class="line">    <span class="comment">-- 判断查询结果</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)</span><br><span class="line">        <span class="comment">-- redis查询失败，去查询http</span></span><br><span class="line">        val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询商品信息</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_data(<span class="string">&quot;item:id:&quot;</span> .. id,  <span class="string">&quot;/item/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 查询库存信息</span></span><br><span class="line"><span class="keyword">local</span> stockJSON = read_data(<span class="string">&quot;item:stock:id:&quot;</span> .. id, <span class="string">&quot;/item/stock/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSON转化为lua的table</span></span><br><span class="line"><span class="keyword">local</span> item = cjson.decode(itemJSON)</span><br><span class="line"><span class="keyword">local</span> stock = cjson.decode(stockJSON)</span><br><span class="line"><span class="comment">-- 组合数据</span></span><br><span class="line">item.stock = stock.stock</span><br><span class="line">item.sold = stock.sold</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把item序列化为json 返回结果</span></span><br><span class="line">ngx.say(cjson.encode(item))</span><br></pre></td></tr></table></figure>





<h2 id="Nginx本地缓存"><a href="#Nginx本地缓存" class="headerlink" title="Nginx本地缓存"></a>Nginx本地缓存</h2><p>现在，整个多级缓存中只差最后一环，也就是nginx的本地缓存了。如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821114742950.png" alt="image-20210821114742950"></p>
<h3 id="本地缓存API"><a href="#本地缓存API" class="headerlink" title="本地缓存API"></a>本地缓存API</h3><p>OpenResty为Nginx提供了<strong>shard dict</strong>的功能，可以在nginx的多个worker之间共享数据，实现缓存功能。</p>
<p>1）开启共享字典，在nginx.conf的http下添加配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 共享字典，也就是本地缓存，名称叫做：item_cache，大小150m</span></span><br><span class="line"><span class="attribute">lua_shared_dict</span> item_cache <span class="number">150m</span>; </span><br></pre></td></tr></table></figure>



<p>2）操作共享字典：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取本地缓存对象</span></span><br><span class="line"><span class="keyword">local</span> item_cache = ngx.shared.item_cache</span><br><span class="line"><span class="comment">-- 存储, 指定key、value、过期时间，单位s，默认为0代表永不过期</span></span><br><span class="line">item_cache:set(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">-- 读取</span></span><br><span class="line"><span class="keyword">local</span> val = item_cache:get(<span class="string">&#x27;key&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="实现本地缓存查询"><a href="#实现本地缓存查询" class="headerlink" title="实现本地缓存查询"></a>实现本地缓存查询</h3><p>1）修改<code>/usr/local/openresty/lua/item.lua</code>文件，修改read_data查询函数，添加本地缓存逻辑：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入共享词典，本地缓存</span></span><br><span class="line"><span class="keyword">local</span> item_cache = ngx.shared.item_cache</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装查询函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, expire, path, params)</span></span></span><br><span class="line">    <span class="comment">-- 查询本地缓存</span></span><br><span class="line">    <span class="keyword">local</span> val = item_cache:get(key)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;本地缓存查询失败，尝试查询Redis， key: &quot;</span>, key)</span><br><span class="line">        <span class="comment">-- 查询redis</span></span><br><span class="line">        val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, key)</span><br><span class="line">        <span class="comment">-- 判断查询结果</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">            ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)</span><br><span class="line">            <span class="comment">-- redis查询失败，去查询http</span></span><br><span class="line">            val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 查询成功，把数据写入本地缓存</span></span><br><span class="line">    item_cache:set(key, val, expire)</span><br><span class="line">    <span class="comment">-- 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>





<p>2）修改item.lua中查询商品和库存的业务，实现最新的read_data函数：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821115108528.png" alt="image-20210821115108528"></p>
<p>其实就是多了缓存时间参数，过期后nginx缓存会自动删除，下次访问即可更新缓存。</p>
<p>这里给商品基本信息设置超时时间为30分钟，库存为1分钟。</p>
<p>因为库存更新频率较高，如果缓存时间过长，可能与数据库差异较大。</p>
<p>3）完整的item.lua文件：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入common函数库</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&#x27;common&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="keyword">local</span> read_redis = common.read_redis</span><br><span class="line"><span class="comment">-- 导入cjson库</span></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">&#x27;cjson&#x27;</span>)</span><br><span class="line"><span class="comment">-- 导入共享词典，本地缓存</span></span><br><span class="line"><span class="keyword">local</span> item_cache = ngx.shared.item_cache</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装查询函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, expire, path, params)</span></span></span><br><span class="line">    <span class="comment">-- 查询本地缓存</span></span><br><span class="line">    <span class="keyword">local</span> val = item_cache:get(key)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;本地缓存查询失败，尝试查询Redis， key: &quot;</span>, key)</span><br><span class="line">        <span class="comment">-- 查询redis</span></span><br><span class="line">        val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, key)</span><br><span class="line">        <span class="comment">-- 判断查询结果</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">            ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)</span><br><span class="line">            <span class="comment">-- redis查询失败，去查询http</span></span><br><span class="line">            val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 查询成功，把数据写入本地缓存</span></span><br><span class="line">    item_cache:set(key, val, expire)</span><br><span class="line">    <span class="comment">-- 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询商品信息</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_data(<span class="string">&quot;item:id:&quot;</span> .. id, <span class="number">1800</span>,  <span class="string">&quot;/item/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 查询库存信息</span></span><br><span class="line"><span class="keyword">local</span> stockJSON = read_data(<span class="string">&quot;item:stock:id:&quot;</span> .. id, <span class="number">60</span>, <span class="string">&quot;/item/stock/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSON转化为lua的table</span></span><br><span class="line"><span class="keyword">local</span> item = cjson.decode(itemJSON)</span><br><span class="line"><span class="keyword">local</span> stock = cjson.decode(stockJSON)</span><br><span class="line"><span class="comment">-- 组合数据</span></span><br><span class="line">item.stock = stock.stock</span><br><span class="line">item.sold = stock.sold</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把item序列化为json 返回结果</span></span><br><span class="line">ngx.say(cjson.encode(item))</span><br></pre></td></tr></table></figure>





<h1 id="五、缓存同步"><a href="#五、缓存同步" class="headerlink" title="五、缓存同步"></a>五、缓存同步</h1><p>大多数情况下，浏览器查询到的都是缓存数据，如果缓存数据与数据库数据存在较大差异，可能会产生比较严重的后果。</p>
<p>所以我们必须保证数据库数据、缓存数据的一致性，这就是缓存与数据库的同步。</p>
<h2 id="数据同步策略"><a href="#数据同步策略" class="headerlink" title="数据同步策略"></a>数据同步策略</h2><p>缓存数据同步的常见方式有三种：</p>
<p><strong>设置有效期</strong>：给缓存设置有效期，到期后自动删除。再次查询时更新</p>
<ul>
<li>优势：简单、方便</li>
<li>缺点：时效性差，缓存过期之前可能不一致</li>
<li>场景：更新频率较低，时效性要求低的业务</li>
</ul>
<p><strong>同步双写</strong>：在修改数据库的同时，直接修改缓存</p>
<ul>
<li>优势：时效性强，缓存与数据库强一致</li>
<li>缺点：有代码侵入，耦合度高；</li>
<li>场景：对一致性、时效性要求较高的缓存数据</li>
</ul>
<p><strong>异步通知：</strong>修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据</p>
<ul>
<li>优势：低耦合，可以同时通知多个缓存服务</li>
<li>缺点：时效性一般，可能存在中间不一致状态</li>
<li>场景：时效性要求一般，有多个服务需要同步</li>
</ul>
<p>而异步实现又可以基于MQ或者Canal来实现：</p>
<p>1）基于MQ的异步通知：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821115552327.png" alt="image-20210821115552327"></p>
<p>解读：</p>
<ul>
<li>商品服务完成对数据的修改后，只需要发送一条消息到MQ中。</li>
<li>缓存服务监听MQ消息，然后完成对缓存的更新</li>
</ul>
<p>依然有少量的代码侵入。</p>
<p>2）基于Canal的通知</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821115719363.png" alt="image-20210821115719363"></p>
<p>解读：</p>
<ul>
<li>商品服务完成商品修改后，业务直接结束，没有任何代码侵入</li>
<li>Canal监听MySQL变化，当发现变化后，立即通知缓存服务</li>
<li>缓存服务接收到canal通知，更新缓存</li>
</ul>
<p>代码零侵入</p>
<h2 id="安装Canal"><a href="#安装Canal" class="headerlink" title="安装Canal"></a>安装Canal</h2><h3 id="认识Canal"><a href="#认识Canal" class="headerlink" title="认识Canal"></a>认识Canal</h3><p>**Canal [kə’næl]**，译意为水道/管道/沟渠，canal是阿里巴巴旗下的一款开源项目，基于Java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费。GitHub的地址：<a target="_blank" rel="noopener" href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p>
<p>Canal是基于mysql的主从同步来实现的，MySQL主从同步的原理如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821115914748.png" alt="image-20210821115914748"></p>
<ul>
<li>1）MySQL master 将数据变更写入二进制日志( binary log），其中记录的数据叫做binary log events</li>
<li>2）MySQL slave 将 master 的 binary log events拷贝到它的中继日志(relay log)</li>
<li>3）MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据</li>
</ul>
<p>而Canal就是把自己伪装成MySQL的一个slave节点，从而监听master的binary log变化。再把得到的变化信息通知给Canal的客户端，进而完成对其它数据库的同步。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821115948395.png" alt="image-20210821115948395"></p>
<h3 id="安装Canal-1"><a href="#安装Canal-1" class="headerlink" title="安装Canal"></a>安装Canal</h3><p>安装和配置Canal参考课前资料文档：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821120017324.png" alt="image-20210821120017324"> </p>
<h2 id="监听Canal"><a href="#监听Canal" class="headerlink" title="监听Canal"></a>监听Canal</h2><p>Canal提供了各种语言的客户端，当Canal监听到binlog变化时，会通知Canal的客户端。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821120049024.png" alt="image-20210821120049024"></p>
<p>我们可以利用Canal提供的Java客户端，监听Canal通知消息。当收到变化的消息时，完成对缓存的更新。</p>
<p>不过这里我们会使用GitHub上的第三方开源的canal-starter客户端。地址：<a target="_blank" rel="noopener" href="https://github.com/NormanGyllenhaal/canal-client">https://github.com/NormanGyllenhaal/canal-client</a></p>
<p>与SpringBoot完美整合，自动装配，比官方客户端要简单好用很多。</p>
<h3 id="引入依赖："><a href="#引入依赖：" class="headerlink" title="引入依赖："></a>引入依赖：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.javatool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>canal-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="编写配置："><a href="#编写配置：" class="headerlink" title="编写配置："></a>编写配置：</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">canal:</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">heima</span> <span class="comment"># canal的集群名字，要与安装canal时设置的名称一致</span></span><br><span class="line">  <span class="attr">server:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:11111</span> <span class="comment"># canal服务地址</span></span><br></pre></td></tr></table></figure>



<h3 id="修改Item实体类"><a href="#修改Item实体类" class="headerlink" title="修改Item实体类"></a>修改Item实体类</h3><p>通过@Id、@Column、等注解完成Item与数据库表字段的映射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Transient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;tb_item&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;<span class="comment">//商品id</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//商品名称</span></span><br><span class="line">    <span class="keyword">private</span> String title;<span class="comment">//商品标题</span></span><br><span class="line">    <span class="keyword">private</span> Long price;<span class="comment">//价格（分）</span></span><br><span class="line">    <span class="keyword">private</span> String image;<span class="comment">//商品图片</span></span><br><span class="line">    <span class="keyword">private</span> String category;<span class="comment">//分类名称</span></span><br><span class="line">    <span class="keyword">private</span> String brand;<span class="comment">//品牌名称</span></span><br><span class="line">    <span class="keyword">private</span> String spec;<span class="comment">//规格</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;<span class="comment">//商品状态 1-正常，2-下架</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;<span class="comment">//创建时间</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;<span class="comment">//更新时间</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> Integer sold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="编写监听器"><a href="#编写监听器" class="headerlink" title="编写监听器"></a>编写监听器</h3><p>通过实现<code>EntryHandler&lt;T&gt;</code>接口编写监听器，监听Canal消息。注意两点：</p>
<ul>
<li>实现类通过<code>@CanalTable(&quot;tb_item&quot;)</code>指定监听的表信息</li>
<li>EntryHandler的泛型是与表对应的实体类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.canal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.config.RedisHandler;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.annotation.CanalTable;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.handler.EntryHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CanalTable(&quot;tb_item&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemHandler</span> <span class="keyword">implements</span> <span class="title class_">EntryHandler</span>&lt;Item&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisHandler redisHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;Long, Item&gt; itemCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="comment">// 写数据到JVM进程缓存</span></span><br><span class="line">        itemCache.put(item.getId(), item);</span><br><span class="line">        <span class="comment">// 写数据到redis</span></span><br><span class="line">        redisHandler.saveItem(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Item before, Item after)</span> &#123;</span><br><span class="line">        <span class="comment">// 写数据到JVM进程缓存</span></span><br><span class="line">        itemCache.put(after.getId(), after);</span><br><span class="line">        <span class="comment">// 写数据到redis</span></span><br><span class="line">        redisHandler.saveItem(after);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="comment">// 删除数据到JVM进程缓存</span></span><br><span class="line">        itemCache.invalidate(item.getId());</span><br><span class="line">        <span class="comment">// 删除数据到redis</span></span><br><span class="line">        redisHandler.deleteItemById(item.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这里对Redis的操作都封装到了RedisHandler这个对象中，是我们之前做缓存预热时编写的一个类，内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.ItemStock;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemService;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemStockService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisHandler</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemService itemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemStockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">MAPPER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 初始化缓存</span></span><br><span class="line">        <span class="comment">// 1.查询商品信息</span></span><br><span class="line">        List&lt;Item&gt; itemList = itemService.list();</span><br><span class="line">        <span class="comment">// 2.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (Item item : itemList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(item);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:id:&quot;</span> + item.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询商品库存信息</span></span><br><span class="line">        List&lt;ItemStock&gt; stockList = stockService.list();</span><br><span class="line">        <span class="comment">// 4.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (ItemStock stock : stockList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(stock);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:stock:id:&quot;</span> + stock.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveItem</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(item);</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:id:&quot;</span> + item.getId(), json);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteItemById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;item:id:&quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="——最佳实践——"><a href="#——最佳实践——" class="headerlink" title="——最佳实践——"></a>——最佳实践——</h1><p><strong>今日内容</strong></p>
<blockquote>
<ul>
<li>Redis键值设计</li>
<li>批处理优化</li>
<li>服务端优化</li>
<li>集群最佳实践</li>
</ul>
</blockquote>
<h1 id="一、Redis键值设计"><a href="#一、Redis键值设计" class="headerlink" title="一、Redis键值设计"></a>一、Redis键值设计</h1><h2 id="优雅的key结构"><a href="#优雅的key结构" class="headerlink" title="优雅的key结构"></a>优雅的key结构</h2><p>Redis的Key虽然可以自定义，但最好遵循下面的几个最佳实践约定：</p>
<ul>
<li>遵循基本格式：[业务名称]:[数据名]:[id]</li>
<li>长度不超过44字节</li>
<li>不包含特殊字符</li>
</ul>
<p>例如：我们的登录业务，保存用户信息，其key可以设计成如下格式：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521120213631.png" alt="image-20220521120213631"></p>
<p>这样设计的好处：</p>
<ul>
<li>可读性强</li>
<li>避免key冲突</li>
<li>方便管理</li>
<li>更节省内存： key是string类型，底层编码包含int、embstr和raw三种。embstr在小于44字节使用，采用连续内存空间，内存占用更小。当字节数大于44字节时，会转为raw模式存储，在raw模式下，内存空间不是连续的，而是采用一个指针指向了另外一段内存空间，在这段空间里存储SDS内容，这样空间不连续，访问的时候性能也就会收到影响，还有可能产生内存碎片</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521122320482.png" alt="image-20220521122320482"></p>
<h2 id="拒绝BigKey"><a href="#拒绝BigKey" class="headerlink" title="拒绝BigKey"></a>拒绝BigKey</h2><p>BigKey通常以Key的大小和Key中成员的数量来综合判定，例如：</p>
<ul>
<li>Key本身的数据量过大：一个String类型的Key，它的值为5 MB</li>
<li>Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个</li>
<li>Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1,000个但这些成员的Value（值）总大小为100 MB</li>
</ul>
<p>那么如何判断元素的大小呢？redis也给我们提供了命令</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521124650117.png" alt="image-20220521124650117"></p>
<p>推荐值：</p>
<ul>
<li>单个key的value小于10KB</li>
<li>对于集合类型的key，建议元素数量小于1000</li>
</ul>
<h3 id="BigKey的危害"><a href="#BigKey的危害" class="headerlink" title="BigKey的危害"></a>BigKey的危害</h3><ul>
<li>网络阻塞<ul>
<li>对BigKey执行读请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis实例，乃至所在物理机变慢</li>
</ul>
</li>
<li>数据倾斜<ul>
<li>BigKey所在的Redis实例内存使用率远超其他实例，无法使数据分片的内存资源达到均衡</li>
</ul>
</li>
<li>Redis阻塞<ul>
<li>对元素较多的hash、list、zset等做运算会耗时较旧，使主线程被阻塞</li>
</ul>
</li>
<li>CPU压力<ul>
<li>对BigKey的数据序列化和反序列化会导致CPU的使用率飙升，影响Redis实例和本机其它应用</li>
</ul>
</li>
</ul>
<h3 id="如何发现BigKey"><a href="#如何发现BigKey" class="headerlink" title="如何发现BigKey"></a>如何发现BigKey</h3><h4 id="redis-cli-–bigkeys"><a href="#redis-cli-–bigkeys" class="headerlink" title="redis-cli –bigkeys"></a>redis-cli –bigkeys</h4><p>利用redis-cli提供的–bigkeys参数，可以遍历分析所有key，并返回Key的整体统计信息与每个数据的Top1的big key</p>
<p>命令：<code>redis-cli -a 密码 --bigkeys</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521133359507.png" alt="image-20220521133359507"></p>
<h4 id="scan扫描"><a href="#scan扫描" class="headerlink" title="scan扫描"></a>scan扫描</h4><p>自己编程，利用scan扫描Redis中的所有key，利用strlen、hlen等命令判断key的长度（此处不建议使用MEMORY USAGE）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521133703245.png" alt="image-20220521133703245"></p>
<p>scan 命令调用完后每次会返回2个元素，第一个是下一次迭代的光标，第一次光标会设置为0，当最后一次scan 返回的光标等于0时，表示整个scan遍历结束了，第二个返回的是List，一个匹配的key的数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.heima.jedis.util.JedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="comment">// jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span></span><br><span class="line">        jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">        <span class="comment">// 2.设置密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.选择库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">STR_MAX_LEN</span> <span class="operator">=</span> <span class="number">10</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">HASH_MAX_LEN</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testScan</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 扫描并获取一部分key</span></span><br><span class="line">            ScanResult&lt;String&gt; result = jedis.scan(cursor);</span><br><span class="line">            <span class="comment">// 记录cursor</span></span><br><span class="line">            cursor = result.getCursor();</span><br><span class="line">            List&lt;String&gt; list = result.getResult();</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历</span></span><br><span class="line">            <span class="keyword">for</span> (String key : list) &#123;</span><br><span class="line">                <span class="comment">// 判断key的类型</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> jedis.type(key);</span><br><span class="line">                <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;string&quot;</span>:</span><br><span class="line">                        len = jedis.strlen(key);</span><br><span class="line">                        maxLen = STR_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;hash&quot;</span>:</span><br><span class="line">                        len = jedis.hlen(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;list&quot;</span>:</span><br><span class="line">                        len = jedis.llen(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;set&quot;</span>:</span><br><span class="line">                        len = jedis.scard(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;zset&quot;</span>:</span><br><span class="line">                        len = jedis.zcard(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (len &gt;= maxLen) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;Found big key : %s, type: %s, length or size: %d %n&quot;</span>, key, type, len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!cursor.equals(<span class="string">&quot;0&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三方工具"><a href="#第三方工具" class="headerlink" title="第三方工具"></a>第三方工具</h4><ul>
<li>利用第三方工具，如 Redis-Rdb-Tools 分析RDB快照文件，全面分析内存使用情况</li>
<li><a target="_blank" rel="noopener" href="https://github.com/sripathikrishnan/redis-rdb-tools">https://github.com/sripathikrishnan/redis-rdb-tools</a></li>
</ul>
<h4 id="网络监控"><a href="#网络监控" class="headerlink" title="网络监控"></a>网络监控</h4><ul>
<li>自定义工具，监控进出Redis的网络数据，超出预警值时主动告警</li>
<li>一般阿里云搭建的云服务器就有相关监控页面</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521140415785.png" alt="image-20220521140415785"></p>
<h3 id="如何删除BigKey"><a href="#如何删除BigKey" class="headerlink" title="如何删除BigKey"></a>如何删除BigKey</h3><p>BigKey内存占用较多，即便时删除这样的key也需要耗费很长时间，导致Redis主线程阻塞，引发一系列问题。</p>
<ul>
<li>redis 3.0 及以下版本<ul>
<li>如果是集合类型，则遍历BigKey的元素，先逐个删除子元素，最后删除BigKey</li>
</ul>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521140621204.png" alt="image-20220521140621204"></p>
<ul>
<li>Redis 4.0以后<ul>
<li>Redis在4.0后提供了异步删除的命令：unlink</li>
</ul>
</li>
</ul>
<h2 id="恰当的数据类型"><a href="#恰当的数据类型" class="headerlink" title="恰当的数据类型"></a>恰当的数据类型</h2><h3 id="存储一个User对象，我们有三种存储方式："><a href="#存储一个User对象，我们有三种存储方式：" class="headerlink" title="存储一个User对象，我们有三种存储方式："></a>存储一个User对象，我们有三种存储方式：</h3><h4 id="json字符串"><a href="#json字符串" class="headerlink" title="json字符串"></a>json字符串</h4><table>
<thead>
<tr>
<th align="center">user:1</th>
<th align="center">{“name”: “Jack”, “age”: 21}</th>
</tr>
</thead>
</table>
<p>优点：实现简单粗暴</p>
<p>缺点：数据耦合，不够灵活</p>
<h4 id="字段打散"><a href="#字段打散" class="headerlink" title="字段打散"></a>字段打散</h4><table>
<thead>
<tr>
<th align="center">user:1:name</th>
<th align="center">Jack</th>
</tr>
</thead>
<tbody><tr>
<td align="center">user:1:age</td>
<td align="center">21</td>
</tr>
</tbody></table>
<p>优点：可以灵活访问对象任意字段</p>
<p>缺点：占用空间大、没办法做统一控制</p>
<h4 id="hash（推荐）"><a href="#hash（推荐）" class="headerlink" title="hash（推荐）"></a>hash（推荐）</h4><table>
    <tr>
        <td rowspan="2">user:1</td>
        <td>name</td>
        <td>jack</td>
    </tr>
    <tr>
        <td>age</td>
        <td>21</td>
    </tr>
</table>



<p>优点：底层使用ziplist，空间占用小，可以灵活访问对象的任意字段</p>
<p>缺点：代码相对复杂</p>
<h3 id="假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？"><a href="#假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？" class="headerlink" title="假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？"></a>假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？</h3><table>
    <tr style="color:red">
        <td>key</td>
        <td>field</td>
        <td>value</td>
    </tr>
    <tr>
        <td rowspan="3">someKey</td>
        <td>id:0</td>
        <td>value0</td>
    </tr>
    <tr>
        <td>.....</td>
        <td>.....</td>
    </tr>
    <tr>
        <td>id:999999</td>
        <td>value999999</td>
    </tr>
</table>



<p>存在的问题：</p>
<ul>
<li>hash的entry数量超过500时，会使用哈希表而不是ZipList，内存占用较多<ul>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521142943350.png" alt="image-20220521142943350"></li>
</ul>
</li>
<li>可以通过hash-max-ziplist-entries配置entry上限。但是如果entry过多就会导致BigKey问题</li>
</ul>
<h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>拆分为string类型</p>
<table>
    <tr style="color:red">
        <td>key</td>
        <td>value</td>
    </tr>
    <tr>
        <td>id:0</td>
        <td>value0</td>
    </tr>
    <tr>
        <td>.....</td>
        <td>.....</td>
    </tr>
    <tr>
        <td>id:999999</td>
        <td>value999999</td>
    </tr>
</table>



<p>存在的问题：</p>
<ul>
<li>string结构底层没有太多内存优化，内存占用较多</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521143458010.png" alt="image-20220521143458010"></p>
<ul>
<li>想要批量获取这些数据比较麻烦</li>
</ul>
<h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>拆分为小的hash，将 id / 100 作为key， 将id % 100 作为field，这样每100个元素为一个Hash</p>
<table>
    <tr style="color:red">
        <td>key</td>
        <td>field</td>
        <td>value</td>
    </tr>
    <tr>
        <td rowspan="3">key:0</td>
        <td>id:00</td>
        <td>value0</td>
    </tr>
    <tr>
        <td>.....</td>
        <td>.....</td>
    </tr>
    <tr>
        <td>id:99</td>
        <td>value99</td>
    </tr>
    <tr>
        <td rowspan="3">key:1</td>
        <td>id:00</td>
        <td>value100</td>
    </tr>
    <tr>
        <td>.....</td>
        <td>.....</td>
    </tr>
    <tr>
        <td>id:99</td>
        <td>value199</td>
    </tr>
    <tr>
        <td colspan="3">....</td>
    </tr>
    <tr>
        <td rowspan="3">key:9999</td>
        <td>id:00</td>
        <td>value999900</td>
    </tr>
    <tr>
        <td>.....</td>
        <td>.....</td>
    </tr>
    <tr>
        <td>id:99</td>
        <td>value999999</td>
    </tr>
</table>



<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521144339377.png" alt="image-20220521144339377"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.heima.jedis.util.JedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Pipeline;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="comment">// jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span></span><br><span class="line">        jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">        <span class="comment">// 2.设置密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.选择库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSetBigKey</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">650</span>; i++) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;hello_&quot;</span> + i, <span class="string">&quot;world!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.hmset(<span class="string">&quot;m2&quot;</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testBigHash</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;key_&quot;</span> + i, <span class="string">&quot;value_&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.hmset(<span class="string">&quot;test:big:hash&quot;</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testBigString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            jedis.set(<span class="string">&quot;test:str:key_&quot;</span> + i, <span class="string">&quot;value_&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSmallHash</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hashSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(hashSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (i - <span class="number">1</span>) / hashSize;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> i % hashSize;</span><br><span class="line">            map.put(<span class="string">&quot;key_&quot;</span> + v, <span class="string">&quot;value_&quot;</span> + v);</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="number">0</span>) &#123;</span><br><span class="line">                jedis.hmset(<span class="string">&quot;test:small:hash_&quot;</span> + k, map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Key的最佳实践<ul>
<li>固定格式：[业务名]:[数据名]:[id]</li>
<li>足够简短：不超过44字节</li>
<li>不包含特殊字符</li>
</ul>
</li>
<li>Value的最佳实践：<ul>
<li>合理的拆分数据，拒绝BigKey</li>
<li>选择合适数据结构</li>
<li>Hash结构的entry数量不要超过1000</li>
<li>设置合理的超时时间</li>
</ul>
</li>
</ul>
<h1 id="二、批处理优化"><a href="#二、批处理优化" class="headerlink" title="二、批处理优化"></a>二、批处理优化</h1><h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><h3 id="我们的客户端与redis服务器是这样交互的"><a href="#我们的客户端与redis服务器是这样交互的" class="headerlink" title="我们的客户端与redis服务器是这样交互的"></a>我们的客户端与redis服务器是这样交互的</h3><p>单个命令的执行流程</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521151459880.png" alt="image-20220521151459880"></p>
<p>N条命令的执行流程</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521151524621.png" alt="image-20220521151524621"></p>
<p>redis处理指令是很快的，主要花费的时候在于网络传输。于是乎很容易想到将多条指令批量的传输给redis</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521151902080.png" alt="image-20220521151902080"></p>
<h3 id="MSet"><a href="#MSet" class="headerlink" title="MSet"></a>MSet</h3><p>Redis提供了很多Mxxx这样的命令，可以实现批量插入数据，例如：</p>
<ul>
<li>mset</li>
<li>hmset</li>
</ul>
<p>利用mset批量插入10万条数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMxx</span><span class="params">()</span> &#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2000</span>];</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        j = (i % <span class="number">1000</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        arr[j] = <span class="string">&quot;test:key_&quot;</span> + i;</span><br><span class="line">        arr[j + <span class="number">1</span>] = <span class="string">&quot;value_&quot;</span> + i;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            jedis.mset(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time: &quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Pipeline-1"><a href="#Pipeline-1" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>MSET虽然可以批处理，但是却只能操作部分数据类型，因此如果有对复杂数据类型的批处理需要，建议使用Pipeline</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPipeline</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 放入命令到管道</span></span><br><span class="line">        pipeline.set(<span class="string">&quot;test:key_&quot;</span> + i, <span class="string">&quot;value_&quot;</span> + i);</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 每放入1000条命令，批量执行</span></span><br><span class="line">            pipeline.sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time: &quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集群下的批处理"><a href="#集群下的批处理" class="headerlink" title="集群下的批处理"></a>集群下的批处理</h2><p>如MSET或Pipeline这样的批处理需要在一次请求中携带多条命令，而此时如果Redis是一个集群，那批处理命令的多个key必须落在一个插槽中，否则就会导致执行失败。大家可以想一想这样的要求其实很难实现，因为我们在批处理时，可能一次要插入很多条数据，这些数据很有可能不会都落在相同的节点上，这就会导致报错了</p>
<p>这个时候，我们可以找到4种解决方案</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653126446641.png" alt="1653126446641"></p>
<p>第一种方案：串行执行，所以这种方式没有什么意义，当然，执行起来就很简单了，缺点就是耗时过久。</p>
<p>第二种方案：串行slot，简单来说，就是执行前，客户端先计算一下对应的key的slot，一样slot的key就放到一个组里边，不同的，就放到不同的组里边，然后对每个组执行pipeline的批处理，他就能串行执行各个组的命令，这种做法比第一种方法耗时要少，但是缺点呢，相对来说复杂一点，所以这种方案还需要优化一下</p>
<p>第三种方案：并行slot，相较于第二种方案，在分组完成后串行执行，第三种方案，就变成了并行执行各个命令，所以他的耗时就非常短，但是实现呢，也更加复杂。</p>
<p>第四种：hash_tag，redis计算key的slot的时候，其实是根据key的有效部分来计算的，通过这种方式就能一次处理所有的key，这种方式耗时最短，实现也简单，但是如果通过操作key的有效部分，那么就会导致所有的key都落在一个节点上，产生数据倾斜的问题，所以我们推荐使用第三种方式。</p>
<h3 id="串行化执行代码实践"><a href="#串行化执行代码实践" class="headerlink" title="串行化执行代码实践"></a>串行化执行代码实践</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisClusterTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JedisCluster jedisCluster;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">        HashSet&lt;HostAndPort&gt; nodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7001</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7002</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7003</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8001</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8002</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8003</span>));</span><br><span class="line">        jedisCluster = <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(nodes, poolConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testMSet</span><span class="params">()</span> &#123;</span><br><span class="line">        jedisCluster.mset(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>, <span class="string">&quot;sex&quot;</span>, <span class="string">&quot;male&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testMSet2</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;Male&quot;</span>);</span><br><span class="line">        <span class="comment">//对Map数据进行分组。根据相同的slot放在一个分组</span></span><br><span class="line">        <span class="comment">//key就是slot，value就是一个组</span></span><br><span class="line">        Map&lt;Integer, List&lt;Map.Entry&lt;String, String&gt;&gt;&gt; result = map.entrySet()</span><br><span class="line">                .stream()</span><br><span class="line">                .collect(Collectors.groupingBy(</span><br><span class="line">                        entry -&gt; ClusterSlotHashUtil.calculateSlot(entry.getKey()))</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">//串行的去执行mset的逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Map.Entry&lt;String, String&gt;&gt; list : result.values()) &#123;</span><br><span class="line">            String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[list.size() * <span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                j = i&lt;&lt;<span class="number">2</span>;</span><br><span class="line">                Map.Entry&lt;String, String&gt; e = list.get(<span class="number">0</span>);</span><br><span class="line">                arr[j] = e.getKey();</span><br><span class="line">                arr[j + <span class="number">1</span>] = e.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">            jedisCluster.mset(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedisCluster != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedisCluster.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring集群环境下批处理代码"><a href="#Spring集群环境下批处理代码" class="headerlink" title="Spring集群环境下批处理代码"></a>Spring集群环境下批处理代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">testMSetInCluster</span><span class="params">()</span> &#123;</span><br><span class="line">     Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">     map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;Female&quot;</span>);</span><br><span class="line">     stringRedisTemplate.opsForValue().multiSet(map);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     List&lt;String&gt; strings = stringRedisTemplate.opsForValue().multiGet(Arrays.asList(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;sex&quot;</span>));</span><br><span class="line">     strings.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>原理分析</strong></p>
<p>在RedisAdvancedClusterAsyncCommandsImpl 类中</p>
<p>首先根据slotHash算出来一个partitioned的map，map中的key就是slot，而他的value就是对应的对应相同slot的key对应的数据</p>
<p>通过 RedisFuture<String> mset = super.mset(op);进行异步的消息发送</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RedisFuture&lt;String&gt; <span class="title function_">mset</span><span class="params">(Map&lt;K, V&gt; map)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, List&lt;K&gt;&gt; partitioned = SlotHash.partition(codec, map.keySet());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (partitioned.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.mset(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, RedisFuture&lt;String&gt;&gt; executions = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, List&lt;K&gt;&gt; entry : partitioned.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;K, V&gt; op = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        entry.getValue().forEach(k -&gt; op.put(k, map.get(k)));</span><br><span class="line"></span><br><span class="line">        RedisFuture&lt;String&gt; mset = <span class="built_in">super</span>.mset(op);</span><br><span class="line">        executions.put(entry.getKey(), mset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MultiNodeExecution.firstOfAsync(executions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、服务器端优化"><a href="#三、服务器端优化" class="headerlink" title="三、服务器端优化"></a>三、服务器端优化</h1><h2 id="持久化配置"><a href="#持久化配置" class="headerlink" title="持久化配置"></a>持久化配置</h2><p>Redis的持久化虽然可以保证数据安全，但也会带来很多额外的开销，因此持久化请遵循下列建议：</p>
<ul>
<li>用来做缓存的Redis实例尽量不要开启持久化功能</li>
<li>建议关闭RDB持久化功能，使用AOF持久化</li>
<li>利用脚本定期在slave节点做RDB，实现数据备份</li>
<li>设置合理的rewrite阈值，避免频繁的bgrewrite</li>
<li>配置no-appendfsync-on-rewrite = yes，禁止在rewrite期间做aof，避免因AOF引起的阻塞</li>
<li>部署有关建议：<ul>
<li>Redis实例的物理机要预留足够内存，应对fork和rewrite</li>
<li>单个Redis实例内存上限不要太大，例如4G或8G。可以加快fork的速度、减少主从同步、数据迁移压力</li>
<li>不要与CPU密集型应用部署在一起</li>
<li>不要与高硬盘负载应用一起部署。例如：数据库、消息队列</li>
</ul>
</li>
</ul>
<h2 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h2><h3 id="什么是慢查询"><a href="#什么是慢查询" class="headerlink" title="什么是慢查询"></a>什么是慢查询</h3><p>并不是很慢的查询才是慢查询，而是：在Redis执行时耗时超过某个阈值的命令，称为慢查询。</p>
<p>慢查询的危害：由于Redis是单线程的，所以当客户端发出指令后，他们都会进入到redis底层的queue来执行，如果此时有一些慢查询的数据，就会导致大量请求阻塞，从而引起报错，所以我们需要解决慢查询问题。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653129590210.png" alt="1653129590210"></p>
<p>慢查询的阈值可以通过配置指定：</p>
<p>slowlog-log-slower-than：慢查询阈值，单位是微秒。默认是10000，建议1000</p>
<p>慢查询会被放入慢查询日志中，日志的长度有上限，可以通过配置指定：</p>
<p>slowlog-max-len：慢查询日志（本质是一个队列）的长度。默认是128，建议1000</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653130457771.png" alt="1653130457771"></p>
<p>修改这两个配置可以使用：config set命令：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653130475979.png" alt="1653130475979"></p>
<h3 id="如何查看慢查询"><a href="#如何查看慢查询" class="headerlink" title="如何查看慢查询"></a>如何查看慢查询</h3><p>知道了以上内容之后，那么咱们如何去查看慢查询日志列表呢：</p>
<ul>
<li>slowlog len：查询慢查询日志长度</li>
<li>slowlog get [n]：读取n条慢查询日志</li>
<li>slowlog reset：清空慢查询列表</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653130858066.png" alt="1653130858066"></p>
<h2 id="命令及安全配置"><a href="#命令及安全配置" class="headerlink" title="命令及安全配置"></a>命令及安全配置</h2><p> 安全可以说是服务器端一个非常重要的话题，如果安全出现了问题，那么一旦这个漏洞被一些坏人知道了之后，并且进行攻击，那么这就会给咱们的系统带来很多的损失，所以我们这节课就来解决这个问题。</p>
<p>Redis会绑定在0.0.0.0:6379，这样将会将Redis服务暴露到公网上，而Redis如果没有做身份认证，会出现严重的安全漏洞.<br>漏洞重现方式：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1039000">https://cloud.tencent.com/developer/article/1039000</a></p>
<p>为什么会出现不需要密码也能够登录呢，主要是Redis考虑到每次登录都比较麻烦，所以Redis就有一种ssh免秘钥登录的方式，生成一对公钥和私钥，私钥放在本地，公钥放在redis端，当我们登录时服务器，再登录时候，他会去解析公钥和私钥，如果没有问题，则不需要利用redis的登录也能访问，这种做法本身也很常见，但是这里有一个前提，前提就是公钥必须保存在服务器上，才行，但是Redis的漏洞在于在不登录的情况下，也能把秘钥送到Linux服务器，从而产生漏洞</p>
<p>漏洞出现的核心的原因有以下几点：</p>
<ul>
<li>Redis未设置密码</li>
<li>利用了Redis的config set命令动态修改Redis配置</li>
<li>使用了Root账号权限启动Redis</li>
</ul>
<p>所以：如何解决呢？我们可以采用如下几种方案</p>
<p>为了避免这样的漏洞，这里给出一些建议：</p>
<ul>
<li>Redis一定要设置密码</li>
<li>禁止线上使用下面命令：keys、flushall、flushdb、config set等命令。可以利用rename-command禁用。</li>
<li>bind：限制网卡，禁止外网网卡访问</li>
<li>开启防火墙</li>
<li>不要使用Root账户启动Redis</li>
<li>尽量不是有默认的端口</li>
</ul>
<h2 id="Redis内存划分和内存配置"><a href="#Redis内存划分和内存配置" class="headerlink" title="Redis内存划分和内存配置"></a>Redis内存划分和内存配置</h2><p>当Redis内存不足时，可能导致Key频繁被删除、响应时间变长、QPS不稳定等问题。当内存使用率达到90%以上时就需要我们警惕，并快速定位到内存占用的原因。</p>
<p><strong>有关碎片问题分析</strong></p>
<p>Redis底层分配并不是这个key有多大，他就会分配多大，而是有他自己的分配策略，比如8,16,20等等，假定当前key只需要10个字节，此时分配8肯定不够，那么他就会分配16个字节，多出来的6个字节就不能被使用，这就是我们常说的 碎片问题</p>
<p><strong>进程内存问题分析：</strong></p>
<p>这片内存，通常我们都可以忽略不计</p>
<p><strong>缓冲区内存问题分析：</strong></p>
<p>一般包括客户端缓冲区、AOF缓冲区、复制缓冲区等。客户端缓冲区又包括输入缓冲区和输出缓冲区两种。这部分内存占用波动较大，所以这片内存也是我们需要重点分析的内存问题。</p>
<table>
<thead>
<tr>
<th><strong>内存占用</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>数据内存</td>
<td>是Redis最主要的部分，存储Redis的键值信息。主要问题是BigKey问题、内存碎片问题</td>
</tr>
<tr>
<td>进程内存</td>
<td>Redis主进程本身运⾏肯定需要占⽤内存，如代码、常量池等等；这部分内存⼤约⼏兆，在⼤多数⽣产环境中与Redis数据占⽤的内存相⽐可以忽略。</td>
</tr>
<tr>
<td>缓冲区内存</td>
<td>一般包括客户端缓冲区、AOF缓冲区、复制缓冲区等。客户端缓冲区又包括输入缓冲区和输出缓冲区两种。这部分内存占用波动较大，不当使用BigKey，可能导致内存溢出。</td>
</tr>
</tbody></table>
<p>于是我们就需要通过一些命令，可以查看到Redis目前的内存分配状态：</p>
<ul>
<li>info memory：查看内存分配的情况</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653132073570.png" alt="1653132073570"></p>
<ul>
<li>memory xxx：查看key的主要占用情况</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653132098823.png" alt="1653132098823"></p>
<p>接下来我们看到了这些配置，最关键的缓存区内存如何定位和解决呢？</p>
<p>内存缓冲区常见的有三种：</p>
<ul>
<li>复制缓冲区：主从复制的repl_backlog_buf，如果太小可能导致频繁的全量复制，影响性能。通过replbacklog-size来设置，默认1mb</li>
<li>AOF缓冲区：AOF刷盘之前的缓存区域，AOF执行rewrite的缓冲区。无法设置容量上限</li>
<li>客户端缓冲区：分为输入缓冲区和输出缓冲区，输入缓冲区最大1G且不能设置。输出缓冲区可以设置</li>
</ul>
<p>以上复制缓冲区和AOF缓冲区 不会有问题，最关键就是客户端缓冲区的问题</p>
<p>客户端缓冲区：指的就是我们发送命令时，客户端用来缓存命令的一个缓冲区，也就是我们向redis输入数据的输入端缓冲区和redis向客户端返回数据的响应缓存区，输入缓冲区最大1G且不能设置，所以这一块我们根本不用担心，如果超过了这个空间，redis会直接断开，因为本来此时此刻就代表着redis处理不过来了，我们需要担心的就是输出端缓冲区</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653132410073.png" alt="1653132410073"></p>
<p>我们在使用redis过程中，处理大量的big value，那么会导致我们的输出结果过多，如果输出缓存区过大，会导致redis直接断开，而默认配置的情况下， 其实他是没有大小的，这就比较坑了，内存可能一下子被占满，会直接导致咱们的redis断开，所以解决方案有两个</p>
<p>1、设置一个大小</p>
<p>2、增加我们带宽的大小，避免我们出现大量数据从而直接超过了redis的承受能力</p>
<h2 id="集群优化-集群-or-主从"><a href="#集群优化-集群-or-主从" class="headerlink" title="集群优化 集群 or 主从"></a>集群优化 集群 or 主从</h2><p>集群虽然具备高可用特性，能实现自动故障恢复，但是如果使用不当，也会存在一些问题：</p>
<ul>
<li><p>集群完整性问题</p>
</li>
<li><p>集群带宽问题</p>
</li>
<li><p>数据倾斜问题</p>
</li>
<li><p>客户端性能问题</p>
</li>
<li><p>命令的集群兼容性问题</p>
</li>
<li><p>lua和事务问题</p>
</li>
<li><p><em>问题1、在Redis的默认配置中，如果发现任意一个插槽不可用，则整个集群都会停止对外服务：</em>* </p>
</li>
</ul>
<p>大家可以设想一下，如果有几个slot不能使用，那么此时整个集群都不能用了，我们在开发中，其实最重要的是可用性，所以需要把如下配置修改成no，即有slot不能使用时，我们的redis集群还是可以对外提供服务</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653132740637.png" alt="1653132740637"></p>
<p><strong>问题2、集群带宽问题</strong></p>
<p>集群节点之间会不断的互相Ping来确定集群中其它节点的状态。每次Ping携带的信息至少包括：</p>
<ul>
<li>插槽信息</li>
<li>集群状态信息</li>
</ul>
<p>集群中节点越多，集群状态信息数据量也越大，10个节点的相关信息可能达到1kb，此时每次集群互通需要的带宽会非常高，这样会导致集群中大量的带宽都会被ping信息所占用，这是一个非常可怕的问题，所以我们需要去解决这样的问题</p>
<p><strong>解决途径：</strong></p>
<ul>
<li>避免大集群，集群节点数不要太多，最好少于1000，如果业务庞大，则建立多个集群。</li>
<li>避免在单个物理机中运行太多Redis实例</li>
<li>配置合适的cluster-node-timeout值</li>
</ul>
<p><strong>问题3、命令的集群兼容性问题</strong></p>
<p>有关这个问题咱们已经探讨过了，当我们使用批处理的命令时，redis要求我们的key必须落在相同的slot上，然后大量的key同时操作时，是无法完成的，所以客户端必须要对这样的数据进行处理，这些方案我们之前已经探讨过了，所以不再这个地方赘述了。</p>
<p><strong>问题4、lua和事务的问题</strong></p>
<p>lua和事务都是要保证原子性问题，如果你的key不在一个节点，那么是无法保证lua的执行和事务的特性的，所以在集群模式是没有办法执行lua和事务的</p>
<p><strong>那我们到底是集群还是主从</strong></p>
<p>单体Redis（主从Redis）已经能达到万级别的QPS，并且也具备很强的高可用特性。如果主从能满足业务需求的情况下，所以如果不是在万不得已的情况下，尽量不搭建Redis集群</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/08/13/redis-source-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/13/redis-source-code/" class="post-title-link" itemprop="url">Redis 数据结构 网络模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-13 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-13T00:00:00+08:00">2024-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-10 00:33:03" itemprop="dateModified" datetime="2025-05-10T00:33:03+08:00">2025-05-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><h3 id="动态字符串SDS"><a href="#动态字符串SDS" class="headerlink" title="动态字符串SDS"></a>动态字符串SDS</h3><p>我们都知道Redis中保存的Key是字符串，value往往是字符串或者字符串的集合。可见字符串是Redis中最常用的一种数据结构。</p>
<p>不过Redis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题：<br>获取字符串长度的需要通过运算<br>非二进制安全<br>不可修改<br>Redis构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称SDS。<br>例如，我们执行命令：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653984583289.png" alt="1653984583289"></p>
<p>那么Redis将在底层创建两个SDS，其中一个是包含“name”的SDS，另一个是包含“虎哥”的SDS。</p>
<p>Redis是C语言实现的，其中SDS是一个结构体，源码如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653984624671.png" alt="1653984624671"></p>
<p>例如，一个包含字符串“name”的sds结构如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653984648404.png" alt="1653984648404"></p>
<p>SDS之所以叫做动态字符串，是因为它具备动态扩容的能力，例如一个内容为“hi”的SDS：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653984787383.png" alt="1653984787383"></p>
<p>假如我们要给SDS追加一段字符串“,Amy”，这里首先会申请新内存空间：</p>
<ul>
<li><p>如果新字符串小于1M，则新空间为扩展后字符串长度的两倍+1；</p>
</li>
<li><p>如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1。</p>
</li>
<li><p>称为内存预分配，减少分配次数，且二进制安全。</p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653984822363.png" alt="1653984822363"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653984838306.png" alt="1653984838306"></p>
<h3 id="Intset"><a href="#Intset" class="headerlink" title="Intset"></a>Intset</h3><h4 id="复习C语言数据类型"><a href="#复习C语言数据类型" class="headerlink" title="复习C语言数据类型"></a>复习C语言数据类型</h4><blockquote>
<p><code>uint32_t</code> 是一种数据类型定义，常用于 C 和 C++ 语言中。它表示一个<strong>32位无符号整数</strong>类型，具体含义如下：</p>
<ol>
<li><strong>u</strong>：表示“unsigned”，即无符号。</li>
<li><strong>int</strong>：表示“整数”。</li>
<li><strong>32</strong>：表示占用的位数，即32位。</li>
<li><strong>_t</strong>：表示类型（type），是标准库中的约定后缀，用于区别基本数据类型的固定大小版本。</li>
</ol>
<p><strong><code>uint32_t</code>的特点：</strong></p>
<ul>
<li><strong>取值范围</strong>：因为是无符号的，它可以存储从 0 到 (2^{32} - 1) 的整数，即 0 到 4,294,967,295。</li>
<li><strong>固定宽度</strong>：<code>uint32_t</code> 由标准库 <code>stdint.h</code>（C99 标准）或 <code>cstdint</code>（C++11 标准）提供，确保跨平台的一致性。在不同平台和编译器上，它总是占用 32 位（4 字节）的存储空间，因此适用于需要精确控制数据大小的场景，如嵌入式编程和网络协议设计。</li>
</ul>
<p><strong>用法示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> num = <span class="number">4294967295</span>; <span class="comment">// 最大值 4,294,967,295</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;num = %u\n&quot;</span>, num);</span><br></pre></td></tr></table></figure>

<p>这种类型定义可以确保在不同硬件架构下，程序行为的一致性，是一种便携的写法。</p>
</blockquote>
<blockquote>
<p><code>int8_t</code> 是 C 和 C++ 语言中定义的一种数据类型，表示一个<strong>8位有符号整数</strong>。它也是在 <code>stdint.h</code>（C99 标准）或 <code>cstdint</code>（C++11 标准）中定义的类型，常用于需要精确控制整数大小的场景。下面是它的具体含义：</p>
<ol>
<li><strong>int</strong>：表示整数类型。</li>
<li><strong>8</strong>：表示这个整数类型占用 8 位（1 字节）。</li>
<li><strong>_t</strong>：是类型（type）的后缀，用于区别标准库中的固定宽度整数类型。</li>
</ol>
<p><strong><code>int8_t</code> 的特点：</strong></p>
<ul>
<li><strong>取值范围</strong>：因为是有符号整数，它的取值范围是 -128 到 127。<ul>
<li>负数范围：-128 到 -1</li>
<li>正数范围：0 到 127</li>
</ul>
</li>
<li><strong>固定宽度</strong>：<code>int8_t</code> 代表固定宽度的8位整数，不受平台影响，因此在不同编译器和硬件上始终占用 8 位（1 字节）。这种特性在嵌入式系统、网络协议和文件格式处理中很重要，因为它可以确保数据的大小和布局不变。</li>
</ul>
<p><strong>用法示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int8_t</span> temperature = <span class="number">-30</span>; <span class="comment">// 设置温度为 -30 摄氏度</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Temperature: %d\n&quot;</span>, temperature);</span><br></pre></td></tr></table></figure>

<p><code>int8_t</code> 和 <code>uint8_t</code>（8 位无符号整数）都是用于表示小范围的整数类型，通常在内存有限的系统中或者精确到字节操作的场景中广泛使用。</p>
</blockquote>
<h4 id="IntSet实现"><a href="#IntSet实现" class="headerlink" title="IntSet实现"></a>IntSet实现</h4><p>IntSet是Redis中set集合的一种实现方式，基于整数数组来实现，并且具备长度可变、有序等特征。<br>结构如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653984923322.png" alt="1653984923322"></p>
<p>其中的encoding包含三种模式，表示存储的整数大小不同：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653984942385.png" alt="1653984942385"></p>
<p>为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中，结构如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985149557.png" alt="1653985149557"></p>
<p>现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：<br>encoding：4字节<br>length：4字节<br>contents：2字节 * 3  = 6字节</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985197214.png" alt="1653985197214"></p>
<h5 id="有序与唯一"><a href="#有序与唯一" class="headerlink" title="有序与唯一"></a>有序与唯一</h5><p>我们向该其中添加一个数字：50000，这个数字超出了int16_t的范围，intset会自动升级编码方式到合适的大小。<br>以当前案例来说流程如下：</p>
<ul>
<li>升级编码为INTSET_ENC_INT32, 每个整数占4字节，并按照新的编码方式及元素个数扩容数组</li>
<li>倒序依次将数组中的元素拷贝到扩容后的正确位置</li>
<li>将待添加的元素放入数组末尾</li>
<li>最后，将inset的encoding属性改为INTSET_ENC_INT32，将length属性改为4</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985276621.png" alt="1653985276621"></p>
<p>源码如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985304075.png" alt="1653985304075"></p>
<p>普通插入：如果编码没有越界，先在set中查找，查找的过程中进行pos的赋值，大于max，pos=length，小于最小值，pos = 0，然后开始二分查找，pos的结果就是最后的mid/left ，查到就不插入，查不到就能进行插入</p>
<h5 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985327653.png" alt="1653985327653"></p>
<p>升级：新元素肯定在队首或队尾，倒序遍历把旧元素整体搬运，最后将新元素插入</p>
<h4 id="复习C语言指针"><a href="#复习C语言指针" class="headerlink" title="复习C语言指针"></a>复习C语言指针</h4><blockquote>
<p>指针: 本质就是一块连续内存区域的头地址。</p>
<p>字符数组: <code>char *p = &#123;&#39;b&#39;,&#39;r&#39;,&#39;a&#39;,&#39;i&#39;,&#39;n&#39;,&#39;\0&#39;&#125;;</code> 指针变量p指向字符数组(的头地址)</p>
<p>字符串数组: <code>char *array[] = &#123;&quot;abandon&quot;,&quot;brain&quot;,&quot;certain&quot;&#125;;</code> array是一个指针数组的头地址（指针的地址，也就是指针的指针——二级指针）</p>
<p>二级指针: <code>char **q = array;</code> q是指向指针的指针，也就是二级指针之间的直接赋值。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Intset可以看做是特殊的整数数组，具备一些特点：</p>
<ul>
<li>Redis会确保Intset中的元素唯一、有序</li>
<li>具备类型升级机制，可以节省内存空间</li>
<li>底层采用二分查找方式来查询</li>
</ul>
<h3 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h3><p>我们知道Redis是一个键值型（Key-Value Pair）的数据库，我们可以根据键实现快速的增删改查。而键与值的映射关系正是通过Dict来实现的。<br>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985396560.png" alt="1653985396560"> </p>
<p>当我们向Dict添加键值对时，Redis首先根据key计算出hash值（h），然后利用 h &amp; sizemask来计算元素应该存储到数组中的哪个索引位置。我们存储k1=v1，假设k1的哈希值h =1，则1&amp;3 =1，因此k1=v1要存储到数组角标1位置。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985497735.png" alt="1653985497735"></p>
<p>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985570612.png" alt="1653985570612"></p>
<h4 id="size-2-n"><a href="#size-2-n" class="headerlink" title="size = 2^n^"></a>size = 2^n^</h4><p><mark>size<mark></p>
<ul>
<li><p>求余操作实际上就是截取低位，十进制如果除以10的n次方就是直接截取低位，而对于计算机二进制明显更有效率，所以截取二进制的低n位</p>
</li>
<li><p>size = 2^n^ sizemask = 2^n^ - 1</p>
</li>
<li><p>Hash % size 相当于截取自己的低n位，而要想获取低n位，最简单的办法就是拿n个1跟Hash进行与操作</p>
</li>
<li><p>Hash &amp; sizemask  = Hash % size</p>
</li>
<li><p>当哈希表的大小是2的n次方时，哈希函数能够更好地将数据分布在哈希表的各个位置上，从而减少哈希冲突的概率。<code>capacity - 1</code> 的二进制表示全部为 1（如 15 为 1111），这样能让低位的哈希值充分参与运算，最大程度分散数据，降低冲突概率。</p>
</li>
<li><p><strong>负载因子调整</strong>： 在很多哈希表实现中（如Java的 <code>HashMap</code> 或 <code>Redis</code>），当负载因子超过一定阈值时，哈希表的大小会动态扩展。如果哈希表的大小是2的n次方，那么扩展时的大小也会是2的n次方（如从 16 扩展到 32），这使得扩展过程更加简单且高效。</p>
</li>
<li><p>最小是4 <code>DICT_HT_INITIAL_SIZE</code> </p>
</li>
</ul>
<h4 id="Entry-Table-Dict-数据结构"><a href="#Entry-Table-Dict-数据结构" class="headerlink" title="Entry Table Dict 数据结构"></a>Entry Table Dict 数据结构</h4><p><mark>dictEntry<mark></p>
<ul>
<li>dictEntry是自定义的一个数据结构，dictEntry *p 表示一个指向dictEntry的指针，指向分配给一个entry的连续内存区域的头地址，dictEntry是最底层的键值对元素</li>
</ul>
<p><mark>dictTable<mark></p>
<ul>
<li>dictEntry **table 就表示二级指针，这个指针指向entry指针，又因为指针指向的区域都是一片连续的内存区域，所以就是指针数组。dictTable本质是entry数组，根据key把键值对存到数组的对应索引处。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985586543.png" alt="1653985586543"></p>
<ul>
<li>发生冲突，采用链地址法解决</li>
</ul>
<p><mark>dict<mark> </p>
<ul>
<li>dict里有两个hashTable </li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985640422.png" alt="1653985640422"></p>
<ul>
<li>type 哈希函数的类型</li>
<li>ht 两张hashtable，多出的一张表用于rehash时数据的暂存</li>
<li>rehashidx，pauserehash rehash过程标记</li>
</ul>
<h4 id="Dict的伸缩"><a href="#Dict的伸缩" class="headerlink" title="Dict的伸缩"></a>Dict的伸缩</h4><p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。</p>
<p><mark>扩容<mark>：Dict在每次新增键值对时都会检查负载因子（LoadFactor = used/size） ，满足以下两种情况时会触发扩容：</p>
<ul>
<li>哈希表的<code>LoadFactor&gt;= 1</code>，并且服务器没有执行 BGSAVE(RDB持久化) 或者 BGREWRITEAOF(AOF持久化) 等后台进程；</li>
<li>哈希表的<code>LoadFactor &gt; 5</code>； </li>
</ul>
<p>扩容实际上扩到比used+1大的第一个2^n^ </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985716275.png" alt="1653985716275"></p>
<p><mark>收缩<mark>：SIZE&gt;4 &amp;&amp; LoadFactor &lt; 0.1 (used*100避免浮点运算 <code>HASHTABLE_MIN_FILL=10</code> )</p>
<p>实际上容量为比used大的第一个2^n^ （<code>used&gt;=4</code>）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241113202920178.png" alt="image-20241113202920178"></p>
<p><mark>DICTEXPAND<mark>这些实际上是申请了一个新的数组，如果不是初始化，还要rehash将旧数据装到新的数组中</p>
<p>rehashidx = 0，表示这个dict开始rehash</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241113205217079.png" alt="image-20241113205217079"></p>
<h4 id="Dict的渐进式rehash"><a href="#Dict的渐进式rehash" class="headerlink" title="Dict的渐进式rehash"></a><strong>Dict的渐进式rehash</strong></h4><p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必<mark>须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash<mark>。过程是这样的：</p>
<ul>
<li>计算新hash表的<code>realSize</code>，值取决于当前要做的是扩容还是收缩：<ul>
<li>如果是扩容，则<code>realSize</code>为第一个大于等于dict.ht[0].used + 1的2^n</li>
<li>如果是收缩，则<code>realSize</code>为第一个大于等于dict.ht[0].used的2^n （不得小于4）</li>
</ul>
</li>
<li>按照新的<code>realSize</code>申请内存空间，创建dictht，并赋值给dict.ht[1]</li>
<li>设置dict.<code>rehashidx</code> = 0，标示开始rehash</li>
<li><del>将dict.ht[0]中的每一个dictEntry都rehash到dict.ht[1]</del> </li>
<li><mark>在rehash过程中，增删改查操作都会检查dict是否处于rehash状态（rehashidx）<mark>新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht[0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash逐渐进行慢慢变成空数组</li>
<li>将dict.ht[1]赋值给dict.ht[0]，</li>
<li>给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存，并将<code>rehashidx</code>赋值为-1，代表rehash结束</li>
</ul>
<p>整个过程可以描述成：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985824540.png" alt="1653985824540"></p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>Dict的结构：</p>
<ul>
<li>类似java的HashTable，底层是数组加链表来解决哈希冲突（链地址法）</li>
<li>Dict包含两个哈希表，ht[0]平常用，ht[1]用来rehash</li>
</ul>
<p>Dict的伸缩：</p>
<ul>
<li>当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容</li>
<li>当LoadFactor小于0.1时，Dict收缩</li>
<li>扩容大小为第一个大于等于 <code>used + 1</code> 的2^n^</li>
<li>收缩大小为第一个大于等于 <code>used</code> 的2^n^ </li>
<li>Dict采用**<mark>渐进式<mark>**rehash，每次访问Dict时执行一次rehash</li>
<li>rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表</li>
</ul>
<h3 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7093145133368999943">深入分析redis之quicklist，不一样的ziplist使用方式？ - 掘金 (juejin.cn)</a></p>
<p>ZipList 是一种特殊的“双端链表” ，由一系列特殊编码的<mark>连续内存块<mark>（不需要通过指针寻址）组成。可以在任意一端进行压入/弹出操作, 并且该操作的时间复杂度为 O(1)。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653985987327.png" alt="1653985987327"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986020491.png" alt="1653986020491"></p>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>类型</strong></th>
<th><strong>长度</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td>4 字节</td>
<td>记录整个压缩列表占用的内存字节数</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td>4 字节</td>
<td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，可以确定表尾节点的地址。</td>
</tr>
<tr>
<td>zllen</td>
<td>uint16_t</td>
<td>2 字节</td>
<td>记录了压缩列表包含的节点个数。 最大值为UINT16_MAX （65534），如果超过这个值，此处会记录为65535，但节点的真实数量需要遍历整个压缩列表才能计算得出。</td>
</tr>
<tr>
<td>entry</td>
<td>列表节点</td>
<td>不定</td>
<td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td>
</tr>
<tr>
<td>zlend</td>
<td>uint8_t</td>
<td>1 字节</td>
<td>特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</td>
</tr>
</tbody></table>
<h4 id="ZipListEntry"><a href="#ZipListEntry" class="headerlink" title="ZipListEntry"></a><strong>ZipListEntry</strong></h4><p>ZipList 中的Entry并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16个字节，浪费内存。而是采用了下面的结构：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986055253.png" alt="1653986055253"></p>
<ul>
<li><p>previous_entry_length：前一节点的长度，占1个或5个字节。</p>
<ul>
<li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li>
<li>如果前一节点的长度大于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</li>
</ul>
</li>
<li><p>encoding：编码属性，记录content的数据类型（字符串还是整数）以及长度，占用1个、2个或5个字节</p>
</li>
<li><p>contents：负责保存节点的数据，可以是字符串或整数</p>
</li>
</ul>
<p><strong>正向遍历</strong>：current + sizeof(previous_entry_length) + sizeof(encoding) + encoding.contentLength</p>
<p><strong>逆向遍历</strong>：current - previous_entry_length</p>
<h5 id="大小端存储"><a href="#大小端存储" class="headerlink" title="大小端存储"></a>大小端存储</h5><p>ZipList中所有<mark>存储长度的数值：tlbytes,tltail,tllen,previous_entry_length<mark> 均采用<mark>小端字节序<mark>即低位字节在前，高位字节在后。例如：数值0x1234，采用小端字节序后实际存储值为：0x3412 </p>
<blockquote>
<p>LSB（Least Significant Byte）和MSB（Most Significant Byte）分别表示数据的最低有效字节和最高有效字节。它们在数据存储和处理时起到重要作用，尤其在大端字节序和小端字节序的不同存储方式中。</p>
<ul>
<li><strong>LSB（最低有效字节）</strong>：存储数据时，代表数据的最低有效字节，即值最小的字节。通常对应数据的最低位。</li>
<li><strong>MSB（最高有效字节）</strong>：存储数据时，代表数据的最高有效字节，即值最大的字节。通常对应数据的最高位。</li>
</ul>
<p>假设我们有一个4字节（32位）整数<code>0x12345678</code>，它的二进制表示为：</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0001</span> <span class="number">0010</span> <span class="number">0011</span> <span class="number">0100</span> <span class="number">0101</span> <span class="number">0110</span> <span class="number">0111</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>我们将这个值从内存地址<code>0x1000</code>开始存储，来看不同字节序下 LSB 和 MSB 的位置。</p>
<p><strong>小端字节序存储</strong></p>
<p>在小端模式下，LSB 存放在最低地址，MSB 存放在最高地址。也就是说，低地址存放低位字节，高地址存放高位字节。从最低位开始存。</p>
<table>
<thead>
<tr>
<th>地址(Hex)</th>
<th>数据</th>
</tr>
</thead>
<tbody><tr>
<td>0x1000</td>
<td>78</td>
</tr>
<tr>
<td>0x1001</td>
<td>56</td>
</tr>
<tr>
<td>0x1002</td>
<td>34</td>
</tr>
<tr>
<td>0x1003</td>
<td>12</td>
</tr>
</tbody></table>
<p>在这种情况下，存储顺序为 <code>78 56 34 12</code>。</p>
<ul>
<li><p><strong>便于数值操作</strong>：在小端模式下，最低有效字节存放在最低地址，因此读取数值时，从低地址开始逐字节读取即可，省去了对字节顺序的额外处理。对于需要频繁数值计算的处理器（如x86架构），这种字节序更高效。</p>
</li>
<li><p><strong>简化某些数据类型的转换</strong>：例如，将16位的<code>short</code>扩展成32位的<code>int</code>，只需将高位填零，不需要移动低位数据。</p>
</li>
<li><p><strong>人类阅读不直观</strong>：小端模式存储的数据不符合从高到低的阅读习惯，直接查看数据时可能显得混乱。</p>
</li>
</ul>
<p><strong>大端字节序存储</strong></p>
<p>在大端模式下，MSB 存放在最低地址，LSB 存放在最高地址。也就是说，低地址存放高位字节，高地址存放低位字节。从最高位开始存</p>
<table>
<thead>
<tr>
<th>地址（Hex）</th>
<th>数据</th>
</tr>
</thead>
<tbody><tr>
<td>0x1000</td>
<td>12</td>
</tr>
<tr>
<td>0x1001</td>
<td>34</td>
</tr>
<tr>
<td>0x1002</td>
<td>56</td>
</tr>
<tr>
<td>0x1003</td>
<td>78</td>
</tr>
</tbody></table>
<p>在这种情况下，存储顺序为 <code>12 34 56 78</code>。</p>
<ul>
<li><strong>符合人类阅读习惯</strong>：大端模式将最高有效字节放在低地址，类似于人类阅读从高位到低位的顺序，因此直接查看数据更直观。</li>
<li><strong>统一网络字节序</strong>：大端字节序是网络协议的标准（网络字节序），在跨平台通信时无需转换，适用于网络应用。</li>
<li><strong>计算复杂度稍高</strong>：对于低地址优先访问的处理器，大端模式的数值计算可能需要更多的字节重排操作，不如小端模式高效。</li>
</ul>
</blockquote>
<h5 id="Encoding编码—记录content长度"><a href="#Encoding编码—记录content长度" class="headerlink" title="Encoding编码—记录content长度"></a>Encoding编码—记录content长度</h5><p>ZipListEntry中的encoding编码分为字符串和整数两种：</p>
<ul>
<li>字符串：如果encoding是以“00”、“01”或者“10”开头，则证明content是字符串，不同encoding表示不同的字符串长度</li>
</ul>
<table>
<thead>
<tr>
<th><strong>编码</strong>（bit）</th>
<th><strong>编码长度</strong></th>
<th><strong>字符串大小</strong></th>
</tr>
</thead>
<tbody><tr>
<td>| 00pppppp |</td>
<td>1 bytes</td>
<td>&lt;= 63 bytes</td>
</tr>
<tr>
<td>| 01pppppp | qqqqqqqq |</td>
<td>2 bytes</td>
<td>&lt;= 16383 bytes</td>
</tr>
<tr>
<td>| 10000000 | qqqqqqqq | rrrrrrrr | ssssssss | tttttttt |</td>
<td>5 bytes</td>
<td>&lt;= 4294967295 bytes</td>
</tr>
</tbody></table>
<p>例如，我们要保存字符串：“ab”和 “bc”</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986172002.png" alt="1653986172002"></p>
<p>tlbytes,tltail,tllen </p>
<p>ZipListEntry中的encoding编码分为字符串和整数两种：</p>
<ul>
<li>整数：如果encoding是以“11”开始，则证明content是整数，且encoding固定只占用1个字节,不同的encoding表示不同数据类型，也就知道了长度</li>
</ul>
<table>
<thead>
<tr>
<th><strong>编码</strong></th>
<th><strong>编码长度</strong></th>
<th><strong>整数类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td>11000000</td>
<td>1</td>
<td>int16_t（2 bytes）</td>
</tr>
<tr>
<td>11010000</td>
<td>1</td>
<td>int32_t（4 bytes）</td>
</tr>
<tr>
<td>11100000</td>
<td>1</td>
<td>int64_t（8 bytes）</td>
</tr>
<tr>
<td>11110000</td>
<td>1</td>
<td>24位有符整数(3 bytes)</td>
</tr>
<tr>
<td>11111110</td>
<td>1</td>
<td>8位有符整数(1 bytes)</td>
</tr>
<tr>
<td>1111xxxx</td>
<td>1</td>
<td>直接在xxxx位置存数，范围从0001~1101，减1后结果为实际值（0到12）节约内存的极致</td>
</tr>
</tbody></table>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986282879.png" alt="1653986282879"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986217182.png" alt="1653986217182"></p>
<h4 id="ZipList的连锁更新问题"><a href="#ZipList的连锁更新问题" class="headerlink" title="ZipList的连锁更新问题"></a>ZipList的连锁更新问题</h4><p>ZipList的每个Entry都包含previous_entry_length来记录上一个节点的大小，长度是1个或5个字节：<br>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值<br>如果前一节点的长度大于等于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据<br>现在，假设我们有N个连续的、长度为250~253字节之间的entry，因此entry的previous_entry_length属性用1个字节即可表示，如图所示：正好插入一个254字节的entry导致后面的previousLen全部都变化了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986328124.png" alt="1653986328124"></p>
<p>ZipList这种特殊情况下产生的连续多次空间扩展操作称之为连锁更新（Cascade Update）。新增、删除都可能导致连锁更新的发生。</p>
<p>频繁申请、销毁内存  性能开销很大</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p><strong>ZipList特性：</strong></p>
<p>优点：</p>
<ul>
<li>压缩列表的可以看做一种连续内存空间的”双向链表”，不使用指针，所以不是真正意义上的链表</li>
<li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低。</li>
</ul>
<p>缺点：</p>
<ul>
<li>逐个遍历，如果列表数据量tllen过多，导致链表过长，可能影响查询性能</li>
<li>可能会发生频繁的内存申请销毁导致频繁内核态切换，资源开销较大</li>
<li>增或删较大数据时有可能发生连续更新问题</li>
</ul>
<p><strong>ziplist</strong> 的不足主要在于当 ziplist 中元素个数过多，它的查找效率就会降低。而且如果在 ziplist 里新增或修改数据，ziplist 占用的内存空间还需要<strong>重新分配</strong>；更糟糕的是，ziplist 新增某个元素或修改某个元素时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起<strong>连锁更新</strong>问题，导致每个元素的空间都要重新分配，这就会导致 ziplist 的访问性能下降。</p>
<h3 id="QuickList（双端链表-压缩列表）"><a href="#QuickList（双端链表-压缩列表）" class="headerlink" title="QuickList（双端链表+压缩列表）"></a>QuickList（双端链表+压缩列表）</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7093145133368999943">深入分析redis之quicklist，不一样的ziplist使用方式？ - 掘金 (juejin.cn)</a> </p>
<p>问题1：ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。怎么办？</p>
<p>​    答：为了缓解这个问题，我们必须限制ZipList的长度和entry大小。</p>
<p>问题2：但是我们要存储大量数据，超出了ZipList最佳的上限该怎么办？</p>
<p>​    答：我们可以创建多个ZipList来<mark>分片<mark>存储数据。</p>
<p>问题3：数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？</p>
<p>​    答：Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，只不过链表中的每个节点都是一个ZipList。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986474927.png" alt="1653986474927"></p>
<p>为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：list-max-ziplist-size来限制。<br>如果值为正，则代表ZipList的允许的entry个数的最大值<br>如果值为负，则代表ZipList的最大内存大小，分5种情况：</p>
<ul>
<li>-1：每个ZipList的内存占用不能超过4kb</li>
<li>-2：每个ZipList的内存占用不能超过8kb</li>
<li>-3：每个ZipList的内存占用不能超过16kb</li>
<li>-4：每个ZipList的内存占用不能超过32kb</li>
<li>-5：每个ZipList的内存占用不能超过64kb</li>
</ul>
<p>其默认值为 -2：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986642777.png" alt="1653986642777"></p>
<p>以下是QuickList的和QuickListNode的结构源码：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986667228.png" alt="1653986667228"></p>
<p>我们接下来用一段流程图来描述当前的这个结构</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986718554.png" alt="1653986718554"></p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>QuickList的特点：</p>
<ul>
<li>是一个节点为ZipList的双端链表</li>
<li>节点采用ZipList，解决了传统链表的内存占用问题</li>
<li>控制了ZipList大小，解决连续内存空间申请效率问题</li>
<li>中间节点可以压缩，进一步节省了内存</li>
</ul>
<h3 id="Listpack"><a href="#Listpack" class="headerlink" title="Listpack"></a>Listpack</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000041670843">Redis7代码分析阅读总结一：listpack - 个人文章 - SegmentFault 思否</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7093530299866284045">深入分析redis之listpack，取代ziplist? - 掘金 (juejin.cn)</a></p>
<p>解决了ZipList的连锁更新问题</p>
<h3 id="SkipList（加强链表）"><a href="#SkipList（加强链表）" class="headerlink" title="SkipList（加强链表）"></a>SkipList（加强链表）</h3><p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：</p>
<ul>
<li>元素按照SCORE值升序排列存储</li>
<li>节点可能包含多个指针，指针跨度不同。</li>
</ul>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986771309.png" alt="1653986771309"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986813240.png" alt="1653986813240"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986877620.png" alt="1653986877620"></p>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>SkipList的特点：</p>
<ul>
<li><p>跳跃表是一个双向链表，每个节点都包含score和ele值（sds字符串）</p>
</li>
<li><p>节点按照score值排序，score值一样则按照ele字典排序。</p>
</li>
<li><p>每个节点都可以包含多层指针，<mark>层数是1到32之间的随机数<mark> 这种<strong>随机</strong>性避免了平衡树中频繁的旋转或重构操作。</p>
<ul>
<li><strong>抛硬币法</strong>：抛硬币法是一种经典的随机算法，假设每次抛硬币有 50% 的概率使当前节点新增一层，直到硬币正面朝上或达到最大层数。该算法实现简单且符合概率分布。</li>
<li><strong>概率分布法</strong>：概率分布法采用伪随机数生成器，预先设置一个层数分布表，以确保生成的层数具有严格的概率性分布。相较于抛硬币法，概率分布法更为精准，能够进一步优化跳表的性能。</li>
</ul>
</li>
<li><p>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</p>
</li>
<li><p>增删改查效率与红黑树基本一致，实现却更简单</p>
</li>
</ul>
<h4 id="跳表-vs-Trees"><a href="#跳表-vs-Trees" class="headerlink" title="跳表 vs Trees"></a>跳表 vs Trees</h4><h5 id="AVL-Tree-vs-SkipList"><a href="#AVL-Tree-vs-SkipList" class="headerlink" title="AVL Tree vs SkipList"></a>AVL Tree vs SkipList</h5><p>平衡树：AVL Tree 的插入、删除和查询的时间复杂度和跳表一样都是 <strong>O(log n)</strong> 。但是每一次插入或者删除操作都需要保证整颗树左右节点的绝对平衡，只要不平衡就要通过旋转操作来保持平衡，这个过程是比较耗时的。</p>
<p>而跳表是一种可以用来代替平衡树的数据结构。跳表使用概率平衡而不是严格强制的平衡，因此，跳表中的插入和删除算法比平衡树的等效算法简单得多，速度也快得多。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/202401222005312.png" alt="img"></p>
<h5 id="红黑树-vs-SkipList"><a href="#红黑树-vs-SkipList" class="headerlink" title="红黑树 vs SkipList"></a>红黑树 vs SkipList</h5><p>红黑树：Red Black Tree 也是一种自平衡二叉查找树，它的查询性能略微逊色于 AVL 树，但插入和删除效率更高。红黑树的插入、删除和查询的时间复杂度和跳表一样都是 <strong>O(log n)</strong> 。红黑树是一个<strong>黑平衡树</strong>，即从任意节点到另外一个叶子叶子节点，它所经过的黑节点是一样的。当对它进行插入操作时，需要通过旋转和染色（红黑变换）来保证黑平衡。不过，相较于 AVL 树为了维持平衡的开销要小一些。关于红黑树的详细介绍，可以查看这篇文章：<a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/data-structure/red-black-tree.html">红黑树</a>。</p>
<p>跳表的实现也更简单一些。并且，按照区间来查找数据这个操作，红黑树的效率没有跳表高。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/202401222005709.png" alt="img"></p>
<h5 id="B-Tree-vs-SkipList"><a href="#B-Tree-vs-SkipList" class="headerlink" title="B+ Tree vs SkipList"></a>B+ Tree vs SkipList</h5><p>B+树更适合作为数据库和文件系统中常用的索引结构之一，它的核心思想是通过可能少的 IO 定位到尽可能多的索引来获得查询数据。Redis对于文件IO不敏感，只需按照概率进行随机维护即可，节约内存。而且使用跳表实现 zset 时相较前者来说更简单一些，在进行插入时只需通过索引将数据插入到链表中合适的位置再随机维护一定高度的索引即可，也不需要像 B+树那样插入时发现失衡时还需要对节点分裂与合并。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/202401222005649.png" alt="img"></p>
<h5 id="Redis作者的理由"><a href="#Redis作者的理由" class="headerlink" title="Redis作者的理由"></a>Redis作者的理由</h5><p>1、它们不是很占用内存。这主要取决于你。改变节点拥有给定层数的概率的参数，会使它们比 B 树更节省内存。</p>
<p>2、有序集合经常是许多 ZRANGE 或 ZREVRANGE 操作的目标，也就是说，以链表的方式遍历跳表。通过这种操作，跳表的缓存局部性至少和其他类型的平衡树一样好。</p>
<p>3、它们更容易实现、调试等等。例如，由于跳表的简单性，我收到了一个补丁（已经在 Redis 主分支中），用增强的跳表实现了 O(log(N))的 ZRANK。它只需要对代码做很少的修改。</p>
<h3 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h3><p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象，源码如下：</p>
<p>1、什么是redisObject：<br>从Redis的使用者的角度来看，⼀个Redis节点包含多个database（非cluster模式下默认是16个，cluster模式下只能是1个），而一个database维护了从key space到object space的映射关系。这个映射关系的key是string类型，⽽value可以是多种数据类型，比如：<br>string, list, hash、set、sorted set等。我们可以看到，<strong>key的类型固定是string，而value可能的类型是多个</strong>。<br>⽽从Redis内部实现的⾓度来看，database内的这个映射关系是<strong>用⼀个dict</strong>来维护的。dict的key固定用⼀种数据结构来表达就够了，这就是动态字符串sds。而value则比较复杂，为了在同⼀个dict内能够存储不同类型的value，这就需要⼀个通⽤的数据结构，这个通用的数据结构就是robj，全名是redisObject。</p>
<p>一个database对应一个dict，其中entry就是key(string)和value(五种基本数据结构类型)的对应关系</p>
<p>需要用RedisObject囊括value</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653986956618.png" alt="1653986956618"></p>
<p>Redis的编码方式</p>
<p>Redis中会根据存储的数据类型不同，选择不同的编码方式，共包含11种不同类型：</p>
<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th><strong>编码方式</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>OBJ_ENCODING_RAW</td>
<td>raw编码动态<mark>字符串<mark></td>
</tr>
<tr>
<td>1</td>
<td>OBJ_ENCODING_INT</td>
<td>long类型的整数的<mark>字符串<mark></td>
</tr>
<tr>
<td>2</td>
<td>OBJ_ENCODING_HT</td>
<td>hash表（<mark>字典dict<mark>）</td>
</tr>
<tr>
<td>3</td>
<td>OBJ_ENCODING_ZIPMAP</td>
<td>已废弃</td>
</tr>
<tr>
<td>4</td>
<td>OBJ_ENCODING_LINKEDLIST</td>
<td>双端链表</td>
</tr>
<tr>
<td>5</td>
<td>OBJ_ENCODING_ZIPLIST</td>
<td><mark>压缩列表<mark></td>
</tr>
<tr>
<td>6</td>
<td>OBJ_ENCODING_INTSET</td>
<td><mark>整数集合<mark></td>
</tr>
<tr>
<td>7</td>
<td>OBJ_ENCODING_SKIPLIST</td>
<td><mark>跳表<mark></td>
</tr>
<tr>
<td>8</td>
<td>OBJ_ENCODING_EMBSTR</td>
<td>embstr的动态<mark>字符串<mark></td>
</tr>
<tr>
<td>9</td>
<td>OBJ_ENCODING_QUICKLIST</td>
<td><mark>快速列表<mark></td>
</tr>
<tr>
<td>10</td>
<td>OBJ_ENCODING_STREAM</td>
<td>Stream流</td>
</tr>
</tbody></table>
<p>五种数据结构</p>
<p>Redis中会根据存储的数据类型不同，选择不同的编码方式。每种数据类型的使用的编码方式如下：</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>编码方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td>OBJ_STRING</td>
<td>int、embstr、raw</td>
</tr>
<tr>
<td>OBJ_LIST</td>
<td>LinkedList和ZipList(3.2以前)、QuickList（3.2以后）</td>
</tr>
<tr>
<td>OBJ_SET</td>
<td>intset、HT</td>
</tr>
<tr>
<td>OBJ_ZSET</td>
<td>ZipList、HT、SkipList</td>
</tr>
<tr>
<td>OBJ_HASH</td>
<td>ZipList、HT</td>
</tr>
</tbody></table>
<h3 id="String（RAW-EMBSTR-INT）"><a href="#String（RAW-EMBSTR-INT）" class="headerlink" title="String（RAW / EMBSTR / INT）"></a>String（RAW / EMBSTR / INT）</h3><p>String是Redis中最常见的数据存储类型：</p>
<ul>
<li><p>其基本编码方式是<mark>ENCODING_RAW<mark>，基于简单动态字符串（SDS）实现，存储上限为512mb。</p>
</li>
<li><p>如果存储的SDS长度<mark>小于44<mark>字节，则会采用<mark>ENCODING_EMBSTR<mark>(Embedded String)编码，此时object head与SDS是一段连续空间。申请内存时只需要调用一次内存分配函数，<mark>效率更高。<mark></p>
<ul>
<li>底层采用Jemalloc分配内存，2^n^效率更高，4+8+44+4 = 64</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241114163342533.png" alt="image-20241114163342533"></li>
</ul>
</li>
</ul>
<p>底层实现⽅式：动态字符串 SDS 或 long </p>
<p>String的内部存储结构⼀般是SDS（Simple Dynamic String，可以动态扩展内存）</p>
<p>但是如果⼀个String类型的value的值是数字，那么Redis内部会把它转成long类型来存储，从⽽减少内存的使用。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653987103450.png" alt="1653987103450"></p>
<p>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用<mark>ENCODING_INT<mark>编码：直接将数据保存在RedisObject的ptr指针位置（刚好8字节），不再需要SDS了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653987159575.png" alt="1653987159575"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653987202522.png" alt="1653987202522"></p>
<p>确切地说，String在Redis中是⽤⼀个robj来表示的。</p>
<p>用来表示String的robj可能编码成3种内部表⽰：OBJ_ENCODING_RAW，OBJ_ENCODING_EMBSTR，OBJ_ENCODING_INT。<br>其中前两种编码使⽤的是sds来存储，最后⼀种OBJ_ENCODING_INT编码直接把string存成了long型。<br>在对string进行incr, decr等操作的时候，如果它内部是OBJ_ENCODING_INT编码，那么可以直接行加减操作；如果它内部是OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR编码，那么Redis会先试图把sds存储的字符串转成long型，如果能转成功，再进行加减操作。对⼀个内部表示成long型的string执行append, setbit, getrange这些命令，针对的仍然是string的值（即⼗进制表示的字符串），而不是针对内部表⽰的long型进⾏操作。比如字符串”32”，如果按照字符数组来解释，它包含两个字符，它们的ASCII码分别是0x33和0x32。当我们执行命令setbit key 7 0的时候，相当于把字符0x33变成了0x32，这样字符串的值就变成了”22”。⽽如果将字符串”32”按照内部的64位long型来解释，那么它是0x0000000000000020，在这个基础上执⾏setbit位操作，结果就完全不对了。因此，在这些命令的实现中，会把long型先转成字符串再进行相应的操作。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241114163612101.png" alt="image-20241114163612101"></p>
<p>总结：字符串尽量控制在44字节以内</p>
<h3 id="List（QUICKLIST）"><a href="#List（QUICKLIST）" class="headerlink" title="List（QUICKLIST）"></a>List（QUICKLIST）</h3><p>Redis的List类型可以从首、尾操作列表中的元素：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653987240622.png" alt="1653987240622"></p>
<p>哪一个数据结构能满足上述特征？</p>
<ul>
<li>LinkedList ：普通链表，可以从双端访问，内存占用较高，内存碎片较多</li>
<li>ZipList ：压缩列表，可以从双端访问，内存占用低，存储上限低</li>
<li>QuickList：LinkedList + ZipList，可以从双端访问，内存占用较低，包含多个ZipList，存储上限高</li>
</ul>
<h4 id="RedisObject-结构"><a href="#RedisObject-结构" class="headerlink" title="RedisObject 结构"></a>RedisObject 结构</h4><p>Redis的List结构类似一个双端链表，可以从首、尾操作列表中的元素：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241114164451953.png" alt="image-20241114164451953"></p>
<p>在3.2版本之前，Redis采用ZipList和LinkedList来实现List，当元素数量小于512并且元素大小小于64字节时采用ZipList编码，超过则采用LinkedList编码。</p>
<p>在3.2版本之后，Redis统一采用QuickList来实现List：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653987313461.png" alt="1653987313461"></p>
<h4 id="创建与插入"><a href="#创建与插入" class="headerlink" title="创建与插入"></a>创建与插入</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241114174543958-1731774561497-3.png" alt="image-20241114174543958"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241114174533836.png" alt="image-20241114174533836"></p>
<h3 id="Set（INTSET-HT）"><a href="#Set（INTSET-HT）" class="headerlink" title="Set（INTSET / HT）"></a>Set（INTSET / HT）</h3><p>Set是Redis中的单列集合，满足下列特点：</p>
<ul>
<li>不保证有序性</li>
<li>保证元素唯一</li>
<li>求交集、并集、差集</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653987342550.png" alt="1653987342550"></p>
<p>可以看出，Set对查询元素的效率要求非常高，思考一下，什么样的数据结构可以满足？<br>HashTable，也就是Redis中的<mark>Dict<mark>，不过Dict是双列集合（可以存键、值对）</p>
<p>同一个key计算的索引肯定一样，所以也能确保key唯一</p>
<p>Set是Redis中的集合，不一定确保元素有序，可以满足元素唯一、查询效率要求极高。</p>
<ul>
<li>为了查询效率和唯一性，set采用HT编码（Dict）。Dict中的key用来存储元素，value统一为null。</li>
<li>当存储的所有数据都是整数，并且元素数量不超过set-max-intset-entries时，Set会采用IntSet编码，以节省内存</li>
</ul>
<h4 id="RedisObject-结构-1"><a href="#RedisObject-结构-1" class="headerlink" title="RedisObject 结构"></a>RedisObject 结构</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653987454403.png" alt="1653987454403"></p>
<h4 id="创建或插入对编码的影响"><a href="#创建或插入对编码的影响" class="headerlink" title="创建或插入对编码的影响"></a>创建或插入对编码的影响</h4><p><mark>根据创建set时添加的第一个元素判断使用哪种编码格式<mark> 如果是intset编码，需要根据插入的元素判断是否转换数据结构</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653987388177.png" alt="1653987388177"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241114180238855.png" alt="image-20241114180238855"></p>
<h3 id="ZSET（SKIPLIST-HT-ZIPLIST）"><a href="#ZSET（SKIPLIST-HT-ZIPLIST）" class="headerlink" title="ZSET（SKIPLIST+HT / ZIPLIST）"></a>ZSET（SKIPLIST+HT / ZIPLIST）</h3><p>ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值：</p>
<ul>
<li>可以根据score值排序后</li>
<li>member必须唯一</li>
<li>可以根据member查询分数</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653992091967.png" alt="1653992091967"></p>
<h4 id="RedisObject-结构-2"><a href="#RedisObject-结构-2" class="headerlink" title="RedisObject 结构"></a>RedisObject 结构</h4><p>因此，zset底层数据结构必须满足键值存储、键必须唯一、可排序这几个需求。之前学习的哪种编码结构可以满足？</p>
<ul>
<li>SkipList：可以排序，并且可以同时存储score和ele值（member）</li>
<li>HT（Dict）：可以键值存储，并且可以根据key找value(SCORE)</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653992121692.png" alt="1653992121692"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653992172526.png" alt="1653992172526"></p>
<p>当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存。因此zset还会采用ZipList结构来节省内存，不过需要同时满足两个条件。</p>
<ul>
<li>元素数量小于zset_max_ziplist_entries，默认值128</li>
<li>每个元素都小于zset_max_ziplist_value字节，默认值64</li>
</ul>
<p>ziplist本身没有排序功能，而且没有键值对的概念，因此需要有zset通过编码实现：</p>
<ul>
<li>ZipList是连续内存，因此score和element是紧挨在一起的两个entry， element在前，score在后</li>
<li>score越小越接近队首，score越大越接近队尾，按照score值升序排列</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653992299740.png" alt="1653992299740"></p>
<h4 id="创建或插入对编码的影响-1"><a href="#创建或插入对编码的影响-1" class="headerlink" title="创建或插入对编码的影响"></a>创建或插入对编码的影响</h4><p><mark>创建redisobject时，就会根据参数判断采用哪种结构，之后每次插入都会做判断是否需要更改编码类型<mark>  </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653992238097.png" alt="1653992238097"></p>
<h3 id="Hash（HT-ZIPLIST）"><a href="#Hash（HT-ZIPLIST）" class="headerlink" title="Hash（HT / ZIPLIST）"></a>Hash（HT / ZIPLIST）</h3><p>hash结构如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653992339937.png" alt="1653992339937"></p>
<p>zset集合如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653992360355.png" alt="1653992360355"></p>
<p>Hash结构与Redis中的Zset非常类似：</p>
<ul>
<li>都是键值存储</li>
<li>都需求根据键获取值</li>
<li>键必须唯一</li>
</ul>
<p>区别如下：</p>
<ul>
<li>zset的键是member，值是score；hash的键和值都是任意值</li>
<li>zset要根据score排序；hash则无需排序</li>
</ul>
<h4 id="RedisObject-结构-3"><a href="#RedisObject-结构-3" class="headerlink" title="RedisObject 结构"></a>RedisObject 结构</h4><p>因此，Hash底层采用的编码与Zset也基本一致，只需要把排序有关的SkipList去掉即可</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653992413406.png" alt="1653992413406"></p>
<p>Hash结构默认采用ZipList编码，用以节省内存。 ZipList中相邻的两个entry 分别保存field和value </p>
<p>随着数据的增加，底层的ziplist就可能会转成dict，具体配置如下：</p>
<ul>
<li><p>hash-max-ziplist-entries 512 元素个数</p>
</li>
<li><p>hash-max-ziplist-value 64 元素大小</p>
</li>
</ul>
<p>当满足上面两个条件其中之⼀的时候，Redis就使⽤dict字典来实现hash。<br>Redis的hash之所以这样设计，是因为当ziplist变得很⼤的时候，它有如下几个缺点：</p>
<ul>
<li>每次插⼊或修改引发的realloc操作会有更⼤的概率造成内存拷贝，从而降低性能。</li>
<li>⼀旦发生内存拷贝，内存拷贝的成本也相应增加，因为要拷贝更⼤的⼀块数据。</li>
<li>当ziplist数据项过多的时候，在它上⾯查找指定的数据项就会性能变得很低，因为ziplist上的查找需要进行遍历。</li>
</ul>
<p>ziplist这种结构并不擅长做修改操作。⼀旦数据发⽣改动，就会引发内存realloc，可能导致内存拷贝。</p>
<h4 id="创建或插入对编码的影响-2"><a href="#创建或插入对编码的影响-2" class="headerlink" title="创建或插入对编码的影响"></a>创建或插入对编码的影响</h4><p><mark>创建redisobject默认采用ZIPLIST，之后根据元素大小做判断是否需要转换成DICT，在真正插入后判断长度是否需要转换成DICT<mark> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241117001037075.png" alt="image-20241117001037075"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241117003843384.png" alt="image-20241117003843384"></p>
<h2 id="Redis网络模型"><a href="#Redis网络模型" class="headerlink" title="Redis网络模型"></a>Redis网络模型</h2><h3 id="用户空间和内核态空间"><a href="#用户空间和内核态空间" class="headerlink" title="用户空间和内核态空间"></a>用户空间和内核态空间</h3><p>服务器大多都采用Linux系统，这里我们以Linux为例来讲解:</p>
<p>ubuntu和Centos 都是Linux的发行版，发行版可以看成对linux包了一层壳，任何Linux发行版，其系统内核都是Linux。我们的应用都需要通过Linux内核与硬件交互</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653844970346.png" alt="1653844970346"></p>
<p>用户的应用，比如redis，mysql等其实是没有办法去执行访问我们操作系统的硬件的，所以我们可以通过发行版的这个壳子去访问内核，再通过内核去访问计算机硬件</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653845147190.png" alt="1653845147190"></p>
<p>计算机硬件包括，如cpu，内存，网卡等等，内核（通过寻址空间）可以操作硬件的，但是内核需要不同设备的驱动，有了这些驱动之后，内核就可以去对计算机硬件去进行 内存管理，文件系统的管理，进程的管理等等</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653896065386.png" alt="1653896065386"></p>
<p>我们想要用户的应用来访问，计算机就必须要通过对外暴露的一些接口，才能访问到，从而简介的实现对内核的操控，但是内核本身上来说也是一个应用，所以他本身也需要一些内存，cpu等设备资源，用户应用本身也在消耗这些资源，如果不加任何限制，用户去操作随意的去操作我们的资源，就有可能导致一些冲突，甚至有可能导致我们的系统出现无法运行的问题，因此我们需要把用户和<strong>内核隔离开</strong></p>
<p>进程的寻址空间划分成两部分：<strong>内核空间、用户空间</strong></p>
<p>什么是寻址空间呢？我们的应用程序也好，还是内核空间也好，都是没有办法直接去物理内存的，而是通过分配一些虚拟内存映射到物理内存中，我们的内核和应用程序去访问虚拟内存的时候，就需要一个虚拟地址，这个地址是一个无符号的整数，比如一个32位的操作系统，他的带宽就是32，他的虚拟地址就是2的32次方，也就是说他寻址的范围就是0~2的32次方， 这片寻址空间对应的就是2的32个字节，就是4GB，这个4GB，会有3个GB分给用户空间，会有1GB给内核系统</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653896377259.png" alt="1653896377259"></p>
<p>在linux中，他们权限分成两个等级，0和3，用户空间只能执行受限的命令（Ring3），而且不能直接调用系统资源，必须通过内核提供的接口来访问内核空间可以执行特权命令（Ring0），调用一切系统资源，所以一般情况下，用户的操作是运行在用户空间，而内核运行的数据是在内核空间的，而有的情况下，一个应用程序需要去调用一些特权资源，去调用一些内核空间的操作，所以此时他俩需要在用户态和内核态之间进行切换。</p>
<p>比如：</p>
<p>Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区：</p>
<p>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</p>
<p>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</p>
<p>针对这个操作：我们的用户在写读数据时，会去向内核态申请，想要读取内核的数据，而内核数据要去等待驱动程序从硬件上读取数据，当从磁盘上加载到数据之后，内核会将数据写入到内核的缓冲区中，然后再将数据拷贝到用户态的buffer中，然后再返回给应用程序，整体而言，速度慢，就是这个原因，为了加速，我们希望read也好，还是wait for data也最好都不要等待，或者时间尽量的短。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653896687354.png" alt="1653896687354"></p>
<h3 id="TCP-Socket"><a href="#TCP-Socket" class="headerlink" title="TCP Socket"></a>TCP Socket</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/464268288">网络编程：Socket 是如何创建的？ - 知乎 (zhihu.com)</a></p>
<h4 id="Socket-定义"><a href="#Socket-定义" class="headerlink" title="Socket 定义"></a>Socket 定义</h4><p>Socket：应用程序通过socket提供的接口将网络传输的工作交给linux内核，内核通过驱动程序操作网卡，接受网卡发来的信息。</p>
<p><code>socket</code> 是一个 <strong>编程接口</strong>（API），它本身并不属于网络协议栈的某一层，但它主要用于操作 <strong>传输层</strong>（如 TCP 和 UDP）以及网络层（如原始套接字）的通信，它本身不是传输层或应用层的一部分，而是一个编程抽象，用于简化应用程序访问网络的过程。</p>
<ul>
<li><strong>Socket API</strong> 是操作系统提供的接口，用于应用程序与网络协议栈交互。</li>
<li>它允许开发者使用 <strong>传输层协议（TCP/UDP）</strong> 或更底层的协议（如 IP）进行网络通信。</li>
<li>因此，虽然 Socket 本身不属于传输层或应用层，但它主要作用于 <strong>传输层协议</strong>，并为应用层提供访问网络的工具。</li>
</ul>
<p><strong>按照使用的协议可以分为</strong>：</p>
<ul>
<li><p><strong>传输层：</strong></p>
<ul>
<li>使用 <code>TCP</code> 协议时，<code>TCP Socket</code> 提供可靠的面向连接的数据传输。</li>
<li>使用 <code>UDP</code> 协议时，<code>UDP Socket</code> 提供无连接、不可靠的数据传输。</li>
</ul>
</li>
<li><p><strong>网络层：</strong></p>
<ul>
<li>使用原始套接字（Raw Socket）时，可以直接处理 IP 包，适用于网络工具如 ping 和 traceroute。</li>
</ul>
</li>
<li><p>应用程序通过 Socket 来发送和接收数据，但具体的数据传输和可靠性保障是由 <strong>传输层协议（如 TCP/UDP）</strong> 实现的</p>
</li>
</ul>
<h4 id="Socket-类型"><a href="#Socket-类型" class="headerlink" title="Socket 类型"></a>Socket 类型</h4><ul>
<li><strong>主动Socket</strong> socket()默认创建的socket类型，客户端向服务端建立连接需要的socket</li>
<li><strong>监听Socket</strong> listen()将主动socket转换成监听socket，用于监听客户端的连接请求。是服务端独有的，将伴随服务端的整个生命周期。</li>
<li><strong>已连接Socket</strong> 通过系统库函数accept()获取的已建立连接的socket，该socket是用于客户端和服务端数据读写的通道，已连接socket是服务器独有的，生命周期为 客户端和服务端的维持的连接时长，当断开连接，生命周期结束。</li>
</ul>
<p>一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p>
<h4 id="Socket-相关函数"><a href="#Socket-相关函数" class="headerlink" title="Socket 相关函数"></a>Socket 相关函数</h4><p>socket, bind, connect, listen, accept….</p>
<blockquote>
<ul>
<li><p><code>socket</code>:创建socket，规定各项参数，不能随意组合，socket()创建的socket默认是一个主动类型的，参数如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241115195114618.png" alt="image-20241115195114618"></p>
</li>
<li><p><code>bind</code>: 将IP和端口号绑定到socket上，如果不绑定，客户端会通过connect随机分配，服务端会通过listen随机分配，服务端需要的是一个明确的地址信息，所以必须提前绑定好端口。</p>
</li>
<li><p><code>connect</code>: 客户端通过connect向服务端发起连接请求。</p>
</li>
<li><p><code>listen</code>: 将socket变为被动类型（监听Socket）监听客户的连接请求。</p>
</li>
<li><p><code>accept</code>: 服务端监听到连接请求之后，在3次成功握手之后成功建立连接。1个<strong>监听Socket</strong>维护2个连接队列（全连接established和半连接syn_rcvd），accept会从全连接队列中拿出一个已连接的Socket进行处理，如果还没有完成，就要阻塞等待直到全链接队列有可用的socket。拿到已连接Socket之后就可以开始网络I/O，类同普通文件的读写I/O。当连接可用时，创建的套接字就可以从请求连接的进程中读取数据。</p>
<ul>
<li>accept() 调用创建一个与监听socket具有相同属性的新socketFD，并将其返回给调用者caller。如果队列没有挂起的连接请求，accept() 会阻塞调用者，除非socket处于非阻塞模式（Non-Blocking）。如果没有连接请求排队并且套接字处于非阻塞模式，则accept()返回-1并将错误代码设置为<mark>EWOULDBLOCK<mark>。新的socketFD不能用于接受新连接。原来的监听socket仍然可以接受更多的连接请求。</li>
<li>accept的第一个参数为服务器的socketFD，是服务器开始调用socket()函数生成的，称为监听socketFD；<br>而accept函数返回的是已连接的socketFD。两个套接字不一样。</li>
</ul>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241115202937962.png" alt="image-20241115202937962"></p>
<p>连接双方的IP地址和端口构成一个四元组，唯一标记一个客户端，将其作为Key，存到哈希表里，值就是sockfd，下次连接时重新从哈希表里取出来即可。        </p>
<ul>
<li><code>send/recv read/write</code>: 读写操作会先写到缓冲区中</li>
</ul>
<p><strong>怎么观察 socket 缓冲区</strong> </p>
<p>如果想要查看 socket 缓冲区，可以在linux环境下执行 <code>netstat -nt</code> 命令。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># netstat -nt</span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        <span class="number">0</span>     <span class="number">60</span> <span class="number">172.22</span><span class="number">.66</span><span class="number">.69</span>:<span class="number">22</span>         <span class="number">122.14</span><span class="number">.220</span><span class="number">.252</span>:<span class="number">59889</span>    ESTABLISHED</span><br></pre></td></tr></table></figure>

<p>这上面表明了，这里有一个协议（Proto）类型为 TCP 的连接，同时还有本地（Local Address）和远端（Foreign Address）的IP信息，状态（State）是已连接（Established） 还有<strong>Send-Q 是发送缓冲区</strong>，下面的数字60是指，当前还有60 Byte在发送缓冲区中未发送。而 <strong>Recv-Q 代表接收缓冲区</strong>，此时是空的，数据都被应用进程接收干净了。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qcrao/article/details/120278587">动画图解 socket 缓冲区的那些事儿-CSDN博客</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241116154258525.png" alt="image-20241116154258525"></p>
</blockquote>
<h4 id="Socket-与文件系统、内核的调用关系"><a href="#Socket-与文件系统、内核的调用关系" class="headerlink" title="Socket 与文件系统、内核的调用关系"></a>Socket 与文件系统、内核的调用关系</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241115193558676.png" alt="image-20241115193558676"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241115193416185.png" alt="image-20241115193416185"></p>
<h4 id="Socket-就绪之前"><a href="#Socket-就绪之前" class="headerlink" title="Socket 就绪之前"></a>Socket 就绪之前</h4><p>从ESTABLISHED tcp connection 到 就绪 之前：</p>
<p>TCP是面向连接的协议，通过三次握手建立连接后，会进行一些必要的初始化：</p>
<p><strong>（1）TCP状态维护</strong></p>
<ul>
<li><strong>接收和发送缓冲区准备</strong>：双方为这个连接分配缓冲区，准备接收或发送数据。</li>
<li><strong>连接状态记录</strong>：内核中的Socket结构会记录新连接的相关信息，如对端的IP地址、端口、协议状态等。</li>
</ul>
<p><strong>（2）SSL/TLS握手（如适用）</strong></p>
<p>如果通信使用了加密（如HTTPS），在TCP连接建立后会进行SSL/TLS握手。此过程包括：</p>
<ul>
<li>协商协议版本和加密算法。</li>
<li>交换密钥。</li>
<li>验证身份。</li>
</ul>
<p><strong>（3）应用层协议的初始化</strong></p>
<p>在TCP连接建立后，通常需要按照应用层协议（如HTTP、FTP、WebSocket等）定义的逻辑进行数据交互的初始化。例如：</p>
<ul>
<li>HTTP/1.1会发送<code>GET</code>或<code>POST</code>请求。</li>
<li>WebSocket会升级协议，通过<code>Upgrade</code>头进行握手。</li>
</ul>
<p><strong>（4）延迟与阻塞等待</strong></p>
<p>如果一端发送了数据而另一端未及时处理，连接可能处于阻塞或等待状态。例如：</p>
<ul>
<li><strong>服务端等待客户端请求</strong>。  </li>
<li><strong>客户端等待服务端响应</strong>。  </li>
</ul>
<h3 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h3><h4 id="阻塞IO-BIO"><a href="#阻塞IO-BIO" class="headerlink" title="阻塞IO (BIO)"></a>阻塞IO (BIO)</h4><p>在《UNIX网络编程》一书中，总结归纳了5种IO模型：</p>
<ul>
<li>阻塞IO（Blocking IO）</li>
<li>非阻塞IO（Nonblocking IO）</li>
<li>IO多路复用（IO Multiplexing）</li>
<li>信号驱动IO（Signal Driven IO）</li>
<li>异步IO（Asynchronous IO）</li>
</ul>
<p>应用程序想要去读取数据，他是无法直接去读取磁盘/网卡数据的，他需要先到内核里边去等待内核操作硬件拿到数据，这个过程就是1，是需要等待的，等到内核从磁盘上把数据加载出来之后，再把这个数据写给用户的缓存区，这个过程是2，如果是阻塞IO，那么整个过程中，用户从发起读请求开始，一直到读取到数据，都是一个阻塞状态。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653897115346.png" alt="1653897115346"></p>
<p>具体流程如下图：</p>
<p>用户去读取数据时，会去先发起recvform一个命令，去尝试从内核上加载数据，如果内核没有数据，那么用户就会等待，此时内核会去从硬件上读取数据，内核读取数据之后，会把数据拷贝到用户态，并且返回ok，整个过程，都是阻塞等待的，这就是阻塞IO</p>
<p>总结如下：</p>
<p>顾名思义，阻塞IO就是两个阶段都必须阻塞等待：</p>
<p>阶段一：receivefrom（阻塞）</p>
<ul>
<li>用户进程尝试读取数据（比如网卡数据）</li>
<li>此时数据尚未到达，内核需要等待数据</li>
<li>此时用户进程也处于阻塞状态</li>
</ul>
<p>阶段二：copy（阻塞）</p>
<ul>
<li>数据到达并拷贝到内核缓冲区，代表已就绪</li>
<li>将内核数据拷贝到用户缓冲区</li>
<li>拷贝过程中，用户进程依然阻塞等待</li>
<li>拷贝完成，用户进程解除阻塞，处理数据</li>
</ul>
<p>可以看到，阻塞IO模型中，用户进程在两个阶段都是阻塞状态。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653897270074.png" alt="1653897270074"></p>
<h4 id="非阻塞IO-NIO"><a href="#非阻塞IO-NIO" class="headerlink" title="非阻塞IO (NIO)"></a>非阻塞IO (NIO)</h4><p>顾名思义，非阻塞IO的recvfrom操作会立即返回结果而不是阻塞用户进程。</p>
<p>阶段一：recvfrom（非阻塞）</p>
<ul>
<li>用户进程尝试读取数据（比如网卡数据）</li>
<li>此时数据尚未到达，内核需要等待数据</li>
<li>返回异常给用户进程</li>
<li>用户进程拿到error后，再次尝试读取</li>
<li>循环往复，直到数据就绪</li>
</ul>
<p>阶段二：copy（阻塞）</p>
<ul>
<li>将内核数据拷贝到用户缓冲区</li>
<li>拷贝过程中，用户进程依然阻塞等待</li>
<li>拷贝完成，用户进程解除阻塞，处理数据</li>
<li>可以看到，非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增。</li>
</ul>
<p>用户应用进行IO操作，调用监听socket的accept()获取已连接socket进行IO操作，如果accept获取不到已连接的socket则直接返回-1(EWOULDBLOCK)，获取成功则返回已连接的socket的socketFD</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653897490116.png" alt="1653897490116"></p>
<h4 id="IO多路复用-IO-Multiplexing"><a href="#IO多路复用-IO-Multiplexing" class="headerlink" title="IO多路复用 (IO Multiplexing)"></a>IO多路复用 (IO Multiplexing)</h4><p>无论是阻塞IO还是非阻塞IO，用户应用在一阶段都需要调用recvfrom来获取数据，差别在于无数据时的处理方案：</p>
<p>如果调用recvfrom时，恰好没有数据，阻塞IO会使CPU阻塞，非阻塞IO使CPU空转，都不能充分发挥CPU的作用。<br>如果调用recvfrom时，恰好有数据，则用户进程可以直接进入第二阶段，读取并处理数据</p>
<p>所以怎么看起来以上两种方式性能都不好</p>
<p>而在单线程情况下，只能依次处理IO事件，如果正在处理的IO事件恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有IO事件都必须等待，性能自然会很差。</p>
<p>就比如服务员给顾客点餐，<strong>分两步</strong>：</p>
<ul>
<li>顾客思考要吃什么（服务员这边等待数据就绪）</li>
<li>顾客想好了，开始点餐（服务员开始真正读取数据）</li>
</ul>
<p>要提高效率有几种办法？</p>
<p>方案一：增加更多服务员（多线程）：上下文切换消耗资源 PASS<br>方案二：不排队，谁想好了吃什么（数据就绪了），服务员就给谁点餐（用户应用就去读取数据）OKAY</p>
<p>那么问题来了：用户进程如何知道内核中数据是否就绪呢？</p>
<p>所以接下来就需要详细的来解决多路复用模型是如何知道到底怎么知道内核数据是否就绪的问题了</p>
<p>这个问题的解决依赖于提出的：Socket FD</p>
<p>文件描述符（File Descriptor）：简称FD，是一个从0 开始的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）。</p>
<blockquote>
<p>一个进程对应一个<code>task_struct</code>，一个<code>task_struct</code>中有一个<code>file_struct</code>，一个<code>file_struct</code>中有一个<code>fdt</code>(file descriptor table文件描述符表) <code>fdt</code>中就有一个<code>fd_array</code>（fd数组）数组索引为fd，内容就是指向<code>file</code>的指针</p>
</blockquote>
<p>通过FD，我们的网络模型可以利用一个线程监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</p>
<p>阶段一：</p>
<ul>
<li>用户进程调用select，指定要监听的FD集合</li>
<li>核监听FD对应的多个socket</li>
<li>任意一个或多个socket数据就绪则返回readable（可读）</li>
<li>此过程中用户进程阻塞</li>
</ul>
<p>阶段二：</p>
<ul>
<li>用户进程找到就绪的socket</li>
<li>依次调用recvfrom读取数据</li>
<li>内核将数据拷贝到用户空间</li>
<li>用户进程处理数据。</li>
</ul>
<p>当用户去读取数据的时候，不再去直接调用recvfrom了，而是调用select的函数，select函数会将需要监听的数据交给内核，由内核去检查这些数据是否就绪了，如果说这个数据就绪了，就会通知应用程序数据就绪，然后来读取数据，再从内核中把数据拷贝给用户态，完成数据处理，如果N多个FD一个都没处理完，此时就进行等待。</p>
<p>BIO模式只能查看一个socket，SocketA准备就绪了，但是用户进程在阻塞等待SocketB的数据，这就是无效的等待。</p>
<p>IO Multiplexing可以减少空等空转空轮询，提高性能</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653898691736.png" alt="1653898691736"></p>
<p>数据就绪返回readable，用户进程调用recvfrom处理数据。</p>
<p>IO多路复用是利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过监听FD的方式、通知的方式又有多种实现，常见的有：select，poll，epoll。其中select和pool相当于是当被监听的数据准备好之后，他会把你监听的FD数组整个数据都发给你，你需要到整个FD中去找，哪些是处理好了的，需要通过遍历的方式，所以性能也并不是那么好。而epoll，则相当于内核准备好了之后，他会把准备好的数据，直接发给你，省去了遍历的动作。</p>
<h5 id="IO多路复用-select函数"><a href="#IO多路复用-select函数" class="headerlink" title="IO多路复用-select函数"></a>IO多路复用-select函数</h5><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#select-poll">select/poll</a> </p>
<h6 id="select-流程"><a href="#select-流程" class="headerlink" title="select 流程"></a>select 流程</h6><p>select是Linux最早是由的I/O多路复用技术：</p>
<p>简单说，就是我们把需要处理的数据封装成FD，然后在用户态时创建一个fd的集合（这个集合的大小是要监听的那个FD的最大值+1，但是大小整体是有限制的 ），这个集合的长度大小是有限制的，同时在这个集合中，标明出来我们要控制哪些数据，比如要监听的数据，是1,2,5三个数据，此时会执行select函数，<strong>遍历数组把需要监听的FD置1</strong>（直到nfds fd上限），然后<mark>将整个FDSet拷贝到内核态<mark>，内核态会去<strong>遍历用户态传递过来的数据</strong>，如果发现这里边都数据都没有就绪，就休眠。</p>
<p>直到有数据准备好时，就会被唤醒，唤醒之后，<strong>再次遍历一遍</strong>，看看谁准备好了，将没有准备好的数据置0，<mark>最后再次将这个FDSet拷贝回用户态<mark>，此时用户态就知道有人准备好了（readable），但对于用户态而言，并不知道谁处理好了，所以用户态<strong>也需要去进行遍历</strong>，然后找到被置1（准备就绪）的节点，再去发起receivefrom读写请求，我们会发现，这种模式下他虽然比阻塞IO和非阻塞IO好，但是依然有些麻烦的事情， 比如说频繁的传递fd集合，频繁的去遍历FD等问题</p>
<p>bitmap： __fd_mask = 32bits  FDSet共1024个bit位。</p>
<p>把fd的状态映射到单个bit位上面，很大程度上节省了内存空间，但是也导致用户态不知道谁准备好了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653900022580.png" alt="1653900022580"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241114211029023.png" alt="image-20241114211029023"></p>
<h6 id="select-返回值"><a href="#select-返回值" class="headerlink" title="select 返回值"></a><strong>select 返回值</strong></h6><blockquote>
<ul>
<li><strong>大于0</strong>：表示有文件描述符准备好了。返回值是就绪的文件描述符的数量，也就是有多少个文件描述符在监视的时间内发生了事件（例如：可以读、可以写、异常等）。</li>
<li><strong>0</strong>：表示在指定的时间内没有文件描述符准备好，即超时。</li>
<li>-1：表示发生了错误，errno 中会设置为相应的错误码。常见的错误包括：<ul>
<li><code>EBADF</code>：传递给 <code>select</code> 的某些文件描述符无效。</li>
<li><code>EINTR</code>：调用被信号中断。</li>
<li><code>EINVAL</code>：某个参数无效（例如 <code>nfds</code> 负值）。</li>
</ul>
</li>
</ul>
</blockquote>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>整个流程涉及到两次用户态与内核态之间的拷贝，频繁切换，一共需要2次「拷贝」fdSet</li>
<li>返回值只是就绪的节点个数，然而select并不知道是具体哪个节点就绪，还需要重新遍历，一共需要2次「遍历」</li>
<li>fd_Set 最多监听1024个</li>
</ul>
<h5 id="IO多路复用-poll函数"><a href="#IO多路复用-poll函数" class="headerlink" title="IO多路复用-poll函数"></a>IO多路复用-poll函数</h5><p>poll模式对select模式做了简单改进，但性能提升不明显，部分关键代码如下：</p>
<p>IO流程：</p>
<ul>
<li>创建pollfd数组，向其中添加关注的fd信息，数组大小自定义</li>
<li>调用poll函数，将pollfd数组拷贝到内核空间，转链表存储，无上限</li>
<li>内核遍历fd，判断是否就绪</li>
<li>数据就绪或超时后，拷贝pollfd数组到用户空间，返回就绪fd数量n</li>
<li>用户进程判断n是否大于0,大于0则遍历pollfd数组，找到就绪的fd</li>
</ul>
<p><strong>与select对比：</strong></p>
<ul>
<li>select模式中的fd_set大小固定为1024，而pollfd在内核中采用链表，理论上无上限</li>
<li>监听FD越多，每次遍历消耗时间也越久，性能反而会下降</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653900721427.png" alt="1653900721427"></p>
<h5 id="IO多路复用-epoll函数（event-poll-事件轮询）"><a href="#IO多路复用-epoll函数（event-poll-事件轮询）" class="headerlink" title="IO多路复用-epoll函数（event poll 事件轮询）"></a>IO多路复用-epoll函数（event poll 事件轮询）</h5><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#epoll">epoll</a></p>
<p><mark>核心：事件轮询<mark></p>
<h6 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h6><p>创建eventpoll结构，包含以下两个结构：</p>
<p>1、监听红黑树-&gt; 记录要监听的FD rb_root</p>
<p>2、就绪链表-&gt;记录就绪的FD list_head</p>
<p>紧接着，调用<code>epoll_ctl</code>操作，将要监听的数据添加到红黑树上去，并且给对应的每个fd设置一个监听函数，这个函数会在fd数据就绪时触发，把对应就绪的fd数据添加到就绪链表中</p>
<p>3、调用<code>epoll_wait</code>函数</p>
<p>就去等待，在用户态创建一个空的<code>events</code>数组，当就绪之后，我们的回调函数会把数据添加到<code>list_head</code>中去，当调用这个函数的时候，会去检查list_head，当然这个过程需要参考配置的等待时间，可以等一定时间，也可以一直等， 如果在此过程中，检查到了list_head中有数据会将数据添加到链表中，此时将数据放入到events数组中，并且返回对应的事件数量，用户态的此时收到响应后，从events中拿到对应准备好的数据的节点（SocketFD），再去调用方法从Socket拿数据。</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%8F%A5%E6%9F%84">句柄 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241114221957536.png" alt="image-20241114221957536"></p>
<p>最后返回的依然是数量，但是只需要拷贝已就绪的FD，开销大大减小，并且不用遍历</p>
<h6 id="回调函数与事件驱动"><a href="#回调函数与事件驱动" class="headerlink" title="回调函数与事件驱动"></a>回调函数与事件驱动</h6><blockquote>
<p>回调函数：将函数作为参数传入，Java中是函数式接口的实现类，C中是函数指针</p>
<p>事件驱动：以状态的转换作为事件发生的标志，事件发生会触发回调函数的执行。而事件是多种多样的，这就要求执行的函数不能写死，需要实现充分的解耦</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/c-callback-function.html">C 语言回调函数详解 | 菜鸟教程 (runoob.com)</a> </p>
</blockquote>
<h5 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h5><p>select模式存在的三个问题：</p>
<ul>
<li>能监听的FD<mark>最大不超过<mark>1024</li>
<li><mark>每次<mark>select都需要把<mark>所有<mark>要监听的FD都拷贝到内核空间</li>
<li>每次都要<mark>遍历所有<mark>FD来判断就绪状态</li>
</ul>
<p>poll模式的问题：</p>
<ul>
<li>poll利用链表解决了select中监听FD上限的问题，但依然要遍历所有FD，如果监听较多，性能会下降</li>
</ul>
<p>epoll模式中如何解决这些问题的？</p>
<ul>
<li>基于epoll实例中的红黑树保存要监听的FD，理论上无上限，而且增删改查效率都非常高</li>
<li>每个FD只需要执行一次epoll_ctl添加到红黑树，以后每次epol_wait无需传递任何参数，无需重复拷贝FD到内核空间</li>
<li>利用ep_poll_callback机制来监听FD状态，无需遍历所有FD，因此性能不会随监听的FD数量增多而下降</li>
</ul>
<p>epoll 是解决 C10K 问题的利器，通过两个方面解决了 select/poll 的问题。</p>
<ul>
<li>epoll 在内核里使用「红黑树」来关注进程所有待检测的 Socket，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)，通过对这棵黑红树的管理，不需要像 select/poll 在每次操作时都传入整个 Socket 集合，减少了内核和用户空间大量的数据拷贝和内存分配。</li>
<li>epoll 使用事件驱动的机制，内核里维护了一个「链表」来记录就绪事件，只将有事件发生的 Socket 集合传递给应用程序，不需要像 select/poll 那样轮询扫描整个集合（包含有和无事件的 Socket ），大大提高了检测的效率。</li>
</ul>
<h5 id="epoll中的ET和LT"><a href="#epoll中的ET和LT" class="headerlink" title="epoll中的ET和LT"></a>epoll中的ET和LT</h5><p>当FD有数据可读时，我们调用epoll_wait（或者select、poll）可以得到通知。但是事件通知的模式有两种：</p>
<ul>
<li>LevelTriggered：简称LT，也叫做水平触发。只要某个FD中有数据可读，每次调用epoll_wait都会得到通知。</li>
<li>EdgeTriggered：简称ET，也叫做边沿触发。只有在某个FD有状态变化时，调用epoll_wait才会被通知。</li>
</ul>
<p>举个栗子：</p>
<ul>
<li>假设一个客户端socket对应的FD已经注册到了epoll实例中</li>
<li>客户端socket发送了2kb的数据</li>
<li>服务端调用epoll_wait，得到通知说FD就绪</li>
<li>服务端从FD读取了1kb数据回到步骤3（再次调用epoll_wait，形成循环）</li>
</ul>
<p>结论</p>
<p>如果我们采用LT模式，因为FD中仍有1kb数据，则第⑤步依然会返回结果，并且得到通知<br>如果我们采用ET模式，因为第③步已经消费了FD可读事件，第⑤步FD状态没有变化，因此epoll_wait不会返回，数据无法读取，客户端响应超时。</p>
<h6 id="LT-ET-的底层实现"><a href="#LT-ET-的底层实现" class="headerlink" title="LT ET 的底层实现"></a>LT ET 的底层实现</h6><p><code>ep_send_events ep_scan_ready_list ep_send_events_proc</code></p>
<p>读写就绪的事件会触发回调函数把FD添加至链表中，wait函数将就绪节点从链表断开之后将内容拷贝回用户态。</p>
<p>读取之后，如果FD仍然是就绪的状态（没有读完），内核会根据LT或ET做出不同的行为：</p>
<p><strong>LT</strong> 会把仍就绪的节点加回去，确保下次wait还能读到链表的内容，同一个就绪的事件反复通知。（状态 state）</p>
<p><strong>ET</strong> 不会加回去，只有一次IO机会，没读完也不会通知，同一就绪的事件只通知一次。（状态的变化 state transitions）</p>
<p>如果ET要实现LT效果，需要在拷贝完以后手动调用ctl(before wait)修改的时候检查FD节点，将其重新添加会队列</p>
<h6 id="ET的优势"><a href="#ET的优势" class="headerlink" title="ET的优势"></a>ET的优势</h6><p>ET结合NIO能够确保一次性读完Socket中的数据，减少epoll_wait的调用次数，提高效率</p>
<p>LT因为会保留就绪链表上的节点，因此多个进程阻塞在epoll_wait的系统调用时，会将他们全部唤醒，即惊群</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/385410196">深入浅出 Linux 惊群：现象、原因和解决方案 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/xxjCrFH1361iG-srfNL9_Q">再谈 Linux epoll 惊群问题的原因和解决方案 (qq.com)</a> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果“就绪链表”上仍有未处理的epi，且有进程阻塞在epoll句柄的睡眠队列，则唤醒它！</span></span><br><span class="line"><span class="comment">//(这将是LT惊群的根源)</span></span><br><span class="line"><span class="comment">//ET将链表清空，LT将链表重新加回去</span></span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">        wake_up_locked(&amp;ep-&gt;wq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>epoll</code> 中，事件（event）是通过 <code>epoll_event</code> 结构体来定义和处理的。<code>epoll</code> 的事件分类主要基于 I/O 操作的类型（例如：可读、可写等），它们可以通过 <code>epoll_ctl</code> 函数注册，之后通过 <code>epoll_wait</code> 等函数来等待这些事件的发生。</p>
<h5 id="epoll-事件分类"><a href="#epoll-事件分类" class="headerlink" title="epoll 事件分类"></a>epoll 事件分类</h5><p><code>epoll</code> 支持多种事件类型，主要有以下几种：</p>
<ol>
<li><strong><code>EPOLLIN</code> - 可读事件</strong></li>
</ol>
<ul>
<li><p><strong>描述</strong>：表示指定的文件描述符（如 socket）可供读取数据。</p>
</li>
<li><p><strong>适用场景</strong>：当一个 socket 有数据可读时，<code>epoll</code> 会触发此事件。</p>
</li>
<li><p><strong>使用场景</strong>：服务器通常使用此事件来检测客户端是否有数据发送过来。</p>
<p><strong>例子</strong>：</p>
<ul>
<li>对于 TCP socket，<code>EPOLLIN</code> 事件表示客户端发送了数据，服务器可以使用 <code>recv()</code> 函数读取数据。</li>
<li>对于 监听 socket，<code>EPOLLIN</code> 表示有客户端发起了连接请求，服务器可以调用 <code>accept()</code> 来接受连接。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong><code>EPOLLOUT</code> - 可写事件</strong> </li>
</ol>
<ul>
<li><p><strong>描述</strong>：表示指定的文件描述符（如 socket）可以写入数据。</p>
</li>
<li><p><strong>适用场景</strong>：当 socket 可以安全地写入数据时，<code>epoll</code> 会触发此事件。</p>
</li>
<li><p><strong>使用场景</strong>：客户端在发送大量数据时，可能需要等待 socket 可写。此时，<code>epoll</code> 通过 <code>EPOLLOUT</code> 事件通知应用程序可以写入数据了。</p>
<p><strong>例子</strong>：</p>
<ul>
<li>如果一个 socket 处于阻塞状态，等待写缓冲区可用，<code>EPOLLOUT</code> 会被触发，表示可以开始写入数据。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong><code>EPOLLERR</code> - 错误事件</strong></li>
</ol>
<ul>
<li><p><strong>描述</strong>：表示文件描述符发生了错误。</p>
</li>
<li><p><strong>适用场景</strong>：如果连接发生了错误或出错事件（如网络中断），<code>epoll</code> 会触发此事件。</p>
</li>
<li><p><strong>使用场景</strong>：应用程序通常会检查 <code>EPOLLERR</code> 事件来处理错误情况，如关闭连接或执行错误恢复。</p>
<p><strong>例子</strong>：</p>
<ul>
<li>当 socket 发生网络错误，或者远程主机不可达时，<code>EPOLLERR</code> 会被触发。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong><code>EPOLLHUP</code> - 挂起事件（Hangup）</strong></li>
</ol>
<ul>
<li><p><strong>描述</strong>：表示文件描述符发生挂起（通常表示连接关闭）。</p>
</li>
<li><p><strong>适用场景</strong>：当连接被关闭，或者流中的另一端挂起时，<code>epoll</code> 会触发此事件。</p>
</li>
<li><p><strong>使用场景</strong>：客户端或服务器检测到连接关闭时，通常会处理此事件并清理资源。</p>
<p><strong>例子</strong>：</p>
<ul>
<li>当客户端断开连接时，服务器会收到 <code>EPOLLHUP</code> 事件。此时，服务器应关闭对应的 socket。</li>
</ul>
</li>
</ul>
<ol start="5">
<li><strong><code>EPOLLRDHUP</code> - 远程挂起事件</strong></li>
</ol>
<ul>
<li><strong>描述</strong>：表示对端关闭了连接。该事件是对 <code>EPOLLHUP</code> 的补充，专门用于表示对端关闭连接时的事件。</li>
<li><strong>适用场景</strong>：它是为了处理 <strong>TCP</strong> 连接中远程关闭（例如客户端关闭连接）时的特定事件。</li>
<li><strong>使用场景</strong>：与 <code>EPOLLHUP</code> 类似，应用程序通常通过这个事件来检测到对端已关闭连接，并可以进行相应处理。</li>
</ul>
<ol start="6">
<li><strong><code>EPOLLET</code> - 边缘触发（Edge Triggered）</strong></li>
</ol>
<ul>
<li><strong>描述</strong>：<code>EPOLLET</code> 是边缘触发模式，意味着当文件描述符的状态发生变化时，事件会被触发一次。边缘触发模式相比于传统的水平触发（Level Triggered），能够更加高效地处理 I/O 操作。</li>
<li><strong>适用场景</strong>：在高性能场景中使用，可以避免对文件描述符的重复检查。应用程序需要保证不会丢失事件，并且需要轮询所有事件，直到事件处理完成。</li>
<li><strong>使用场景</strong>：通常与 <code>EPOLLIN</code>、<code>EPOLLOUT</code> 等事件一同使用。</li>
</ul>
<ol start="7">
<li><strong><code>EPOLLONESHOT</code> - 单次触发</strong></li>
</ol>
<ul>
<li><strong>描述</strong>：表示文件描述符只会被触发一次事件。处理完事件后，<code>epoll</code> 会自动停止监视该文件描述符，直到再次通过 <code>epoll_ctl</code> 显式注册为监听状态。</li>
<li><strong>适用场景</strong>：用于那些只需要处理一次事件的场景，如处理某个特定的请求，处理完后不再关心该文件描述符。</li>
<li><strong>使用场景</strong>：一般用于一个事件只处理一次的情况，可以减少事件触发的次数，提高效率。</li>
</ul>
<ol start="8">
<li><strong><code>EPOLLPRI</code> - 优先事件</strong></li>
</ol>
<ul>
<li><strong>描述</strong>：表示文件描述符上发生了高优先级的事件。通常这种事件的优先级高于常规的 I/O 事件。</li>
<li><strong>适用场景</strong>：通常用于处理信号量、优先级消息队列等场景。</li>
</ul>
<ol start="9">
<li><strong><code>EPOLLWAKEUP</code> - 唤醒事件</strong></li>
</ol>
<ul>
<li><strong>描述</strong>：表示 <code>epoll</code> 实例在事件等待期间需要被唤醒。</li>
<li><strong>适用场景</strong>：适用于在多线程环境中希望从 <code>epoll_wait()</code> 等待事件的线程外部唤醒的情况。</li>
</ul>
<p><strong>组合使用的方式</strong></p>
<p><code>epoll</code> 事件通常可以组合使用，以满足更复杂的场景。例如，应用程序可以同时监视 <strong><code>EPOLLIN</code></strong> 和 **<code>EPOLLOUT</code>**，这样就可以同时处理读和写事件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">ev.events = EPOLLIN | EPOLLOUT | EPOLLERR;  <span class="comment">// 监听读、写和错误事件</span></span><br><span class="line">ev.data.fd = fd;</span><br><span class="line">epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br></pre></td></tr></table></figure>

<h5 id="基于epoll的服务端流程"><a href="#基于epoll的服务端流程" class="headerlink" title="基于epoll的服务端流程"></a>基于epoll的服务端流程</h5><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/384098769">从内核看epoll的实现（基于5.9.9） - 知乎 (zhihu.com)</a></p>
<ol>
<li>服务器通过前文提到的listen()将普通的socket转换成专门用来监听的socket(Listened Socket)</li>
<li>服务端会去调用epoll_create，创建一个epoll实例，epoll实例中包含两个数据</li>
</ol>
<ul>
<li>红黑树（为空）：rb_root 用来去记录需要被监听的FD(Socket)</li>
<li>链表（为空）：list_head，用来存放已经就绪的FD<ul>
<li>创建好了之后，会去调用epoll_ctl函数，此函数将需要监听的数据添加到rb_root中去，并且对当前这些存在于红黑树的节点设置回调函数，（同时设置要监听什么类型的事件）当这些被监听的数据一旦准备完成，就会被调用，而调用的结果就是将红黑树的fd添加到list_head中去(但是此时并没有完成)</li>
</ul>
</li>
</ul>
<ol start="3">
<li>当第二步完成后，就会调用epoll_wait函数，这个函数会去校验是否有数据准备完毕（因为数据一旦准备就绪，就会被回调函数添加到list_head中），wait一段时间后(可配置)，如果等待超时，则返回无数据，如果有，则进一步判断当前是什么事件：</li>
</ol>
<ul>
<li>如果是<strong>监听Socket</strong>的FD发生了EPOLLIN事件，则调用accept() 获取已建立的TCP连接，开始准备IO。</li>
<li>如果是<strong>已连接Socket</strong>的EPOLLIN事件，则正常读取socket的数据</li>
</ul>
<p><strong>网络套接字</strong>：在使用 <code>epoll</code> 时，最常见的就是网络套接字（如 TCP 套接字）的数据就绪。具体来说，数据就绪意味着：</p>
<ul>
<li><strong>可读事件（<code>EPOLLIN</code>）</strong>：当套接字有数据可读时，<code>epoll_wait</code> 会返回，表明应用程序可以从套接字中读取数据。</li>
<li><strong>可写事件（<code>EPOLLOUT</code>）</strong>：当套接字可写时，即缓冲区有足够空间发送数据时，<code>epoll_wait</code> 会返回，表明应用程序可以向套接字写入数据。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653902845082.png" alt="1653902845082"></p>
<h4 id="信号驱动IO-Signal-Driven-IO"><a href="#信号驱动IO-Signal-Driven-IO" class="headerlink" title="信号驱动IO (Signal Driven IO)"></a>信号驱动IO (Signal Driven IO)</h4><p>信号驱动IO是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。</p>
<p>阶段一：</p>
<ul>
<li>用户进程调用sigaction，注册信号处理函数</li>
<li>内核返回成功，开始监听FD</li>
<li>用户进程不阻塞等待，可以执行其它业务</li>
<li>当内核数据就绪后，回调用户进程的SIGIO处理函数</li>
</ul>
<p>阶段二：</p>
<ul>
<li>收到SIGIO回调信号</li>
<li>调用recvfrom，读取</li>
<li>内核将数据拷贝到用户空间</li>
<li>用户进程处理数据</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653911776583.png" alt="1653911776583"></p>
<p>当有大量IO操作时，信号较多，SIGIO处理函数不能及时处理可能导致信号队列溢出，而且内核空间与用户空间的频繁信号交互性能也较低。</p>
<p>与NIO要做区分：NIO会一直空轮询，SIGIO只会询问一次。</p>
<h4 id="异步IO-Asynchronous-IO"><a href="#异步IO-Asynchronous-IO" class="headerlink" title="异步IO (Asynchronous IO)"></a>异步IO (Asynchronous IO)</h4><p>这种方式，不仅仅是用户态在试图读取数据后，不阻塞，而且当内核的数据准备完成后，也不会阻塞</p>
<p>他会由内核将所有数据处理完成后，由内核将数据写入到用户态中，然后才算完成，所以性能极高，不会有任何阻塞，全部都由内核完成，可以看到，异步IO模型中，用户进程在两个阶段都是非阻塞状态。</p>
<p>缺陷：高并发下，内核中积累的IO任务很多，消耗太多系统资源从而导致崩溃，所以要求限流机制。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653911877542.png" alt="1653911877542"></p>
<h4 id="五种IO模型对比"><a href="#五种IO模型对比" class="headerlink" title="五种IO模型对比"></a>五种IO模型对比</h4><p>最后用一幅图，来说明他们之间的区别</p>
<p>同步IO or 异步IO 取决于从内核拷贝到用户空间时是否阻塞</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653912219712.png" alt="1653912219712"></p>
<h3 id="Redis-单线程？"><a href="#Redis-单线程？" class="headerlink" title="Redis 单线程？"></a>Redis 单线程？</h3><h4 id="到底是单线程还是多线程？"><a href="#到底是单线程还是多线程？" class="headerlink" title="到底是单线程还是多线程？"></a>到底是单线程还是多线程？</h4><ul>
<li>如果仅仅聊Redis的核心业务部分（命令处理），答案是单线程</li>
<li>如果是聊整个Redis，那么答案就是多线程</li>
</ul>
<p>在Redis版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：</p>
<ul>
<li>Redis v4.0：引入多线程异步处理一些耗时较长的任务，例如异步删除命令unlink(另开一个线程删除bigKey)</li>
<li>Redis v6.0：在核心网络模型中引入 多线程，进一步提高对于多核CPU的利用率</li>
</ul>
<p>因此，对于Redis的核心网络模型，在Redis 6.0之前确实都是单线程。是利用epoll（Linux系统）这样的IO多路复用技术在事件循环中不断处理客户端情况。</p>
<h4 id="为什么Redis要选择单线程？"><a href="#为什么Redis要选择单线程？" class="headerlink" title="为什么Redis要选择单线程？"></a><strong>为什么Redis要选择单线程？</strong></h4><ul>
<li>抛开持久化不谈，Redis是<strong>纯内存</strong>操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升。</li>
<li>多线程会导致过多的上下文切换，带来不必要的开销</li>
<li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣</li>
</ul>
<h3 id="Reactor-Event-driven-I-O-Model"><a href="#Reactor-Event-driven-I-O-Model" class="headerlink" title="Reactor: Event-driven I/O Model"></a>Reactor: Event-driven I/O Model</h3><h4 id="AE-事件库"><a href="#AE-事件库" class="headerlink" title="AE 事件库"></a>AE 事件库</h4><p>C/C++ 指针与引用</p>
<blockquote>
<table>
<thead>
<tr>
<th>运算符</th>
<th>用途</th>
<th>使用对象</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>.</code></td>
<td>访问对象的成员 C++</td>
<td>非指针对象</td>
<td><code>obj.value</code>, <code>obj.print()</code></td>
</tr>
<tr>
<td><code>-&gt;</code></td>
<td>通过指针访问对象的成员C</td>
<td>指针对象</td>
<td><code>ptr-&gt;value</code>, <code>ptr-&gt;print()</code></td>
</tr>
<tr>
<td><code>::</code></td>
<td>访问特定作用域中的成员 C++</td>
<td>命名空间、类、全局作用域等</td>
<td><code>std::cout</code>, <code>ClassName::member</code></td>
</tr>
</tbody></table>
<p><code>int&amp; ref = x;</code>引用变量，得到x的引用，交给ref引用。（only in c++，弱化版指针）</p>
<p><code>int* ptr = &amp;x;</code>指针变量，取x的地址，赋值给ptr指针。</p>
<p><code>int val = x;</code> 普通变量，将x的值复制到val中。</p>
<p>访问x： ref 或 *ptr</p>
</blockquote>
<p><em>A simple Event-driven programming library</em> </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/androidlushangderen/article/details/40474815">Redis源码分析（二十）— ae事件驱动_aeCreateEventLoop setSize-CSDN博客</a></p>
<p>Redis做了跨平台整合，把不同OS的IO多路复用函数封装到统一的API中——AE</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241116140955535.png" alt="image-20241116140955535"></p>
<blockquote>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241116145235220.png" alt="image-20241116145235220"></p>
<ol>
<li>创建监听socket，并开始监听这个socket，acceptTcpHandler用于监听通信socket的可读事件的回调函数</li>
<li>设置<code>beforeSleepProcessor</code>，用于sleep之前的一些准备工作，一旦开始epoll_wait如果没有就绪就会sleep。</li>
<li>在<code>aeProcessEvents</code>中处理事件，首先调用<code>beforeSleep</code>，然后开始<code>epoll_wait</code>等待就绪socketFD</li>
<li>拿到就绪的socketFD集合之后，遍历处理，分别调用对应的不同的事件处理器(每个socket事件类型不同，处理器也不同)</li>
</ol>
</blockquote>
<h4 id="IO多路复用-命令处理模型"><a href="#IO多路复用-命令处理模型" class="headerlink" title="IO多路复用+命令处理模型"></a>IO多路复用+命令处理模型</h4><h5 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h5><blockquote>
<p><code>acceptTcpHandler</code>：TCP连接建立处理器</p>
<ul>
<li>大名鼎鼎的accept函数返回已经建立连接的socket FD，</li>
<li>然后会创建一个connection关联此socket，监听socketFD可读事件，把命令读取处理器（回调函数）绑定到socketFD上</li>
<li>随后才能开始socket的IO操作</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241116150329753.png" alt="image-20241116150329753"></p>
<p><code>readQueryFromClient:</code>命令读取处理器</p>
<ul>
<li>获取命令：client（绑定了socketFD）具备读写缓冲区，从缓冲区中获取字节流，转换成SDS字符串并存入client-&gt;argv[] </li>
<li>处理命令：命令由多个SDS构成，从缓冲区中读取之后存入一个ARGV数组中，<code>set name Jack</code> lookUpCommand 先要读取命令的类型，然后通过查找<code>set -&gt; setCommand(client *c)（指针）</code>的映射表来确定要执行命令的具体函数，随后proc执行回调函数。这里也体现出回调函数的优越性：充分解耦。</li>
<li>返回命令：addReply将执行结果作为SDS写到缓冲区中，满则写入链表。</li>
<li>写回命令：最后将客户端加入待写出的队列中。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241116153602252.png" alt="image-20241116153602252"></p>
<p><code>sendReplyFromClient</code>: 执行结果写回处理器</p>
<p>之前的beforeSleep，在正式开始监听事件之前，会遍历上文的待写队列，</p>
<p>监听待写client的socketFD可写事件，然后把写回处理器（回调函数）绑定到socketFD上，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241116162517768.png" alt="image-20241116162517768"></p>
</blockquote>
<h5 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h5><p>简单来说，在正式监听之前首先要<strong>注册</strong>不同的事件，将其绑定到特定socket上，事件真正发生以后会触发处理器回调函数</p>
<table>
<thead>
<tr>
<th align="center">事件名称</th>
<th align="center">监听socket 可读</th>
<th align="center">已连接socket 可读</th>
<th align="center">已连接socket 可写</th>
</tr>
</thead>
<tbody><tr>
<td align="center">绑定时机</td>
<td align="center">创建监听socket时(createSocketAcceptHandler)</td>
<td align="center">创建已连接socket时(acceptTcpHandler)</td>
<td align="center">监听开始前(beforeSleep)</td>
</tr>
<tr>
<td align="center">绑定对象</td>
<td align="center">监听socket</td>
<td align="center">已连接socket</td>
<td align="center">待写队列中的已连接socket</td>
</tr>
<tr>
<td align="center">处理器</td>
<td align="center">acceptTcpHandler (创建TCP连接)</td>
<td align="center">readQueryFromClient (读取处理命令)</td>
<td align="center">sendReplyToClient (写回)</td>
</tr>
</tbody></table>
<h5 id="Redis-单线程网络模型"><a href="#Redis-单线程网络模型" class="headerlink" title="Redis 单线程网络模型"></a>Redis 单线程网络模型</h5><p>IO Multiplexing + Event Distributing = <code>eventLoop</code> -&gt; <code>beforeSleep</code> -&gt; <code>aeApiPoll</code>(<code>epoll_wait</code>)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653982278727.png" alt="1653982278727"></p>
<p>当我们的客户端想要去连接我们服务器，会去先到IO多路复用模型去进行排队，会有一个连接应答处理器，他会去接受读请求，然后又把读请求注册到具体模型中去，此时这些建立起来的连接，如果是客户端请求处理器去进行执行命令时，他会去把数据读取出来，然后把数据放入到client中， client去解析当前的命令转化为redis认识的命令，接下来就开始处理这些命令，从redis中的command中找到这些命令，然后就真正的去操作对应的数据了，当数据操作完成后，会去找到命令回复处理器，再由他将数据写出。</p>
<p>简</p>
<h4 id="多线程网络模型——解决网络IO瓶颈"><a href="#多线程网络模型——解决网络IO瓶颈" class="headerlink" title="多线程网络模型——解决网络IO瓶颈"></a>多线程网络模型——解决网络IO瓶颈</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241116173420995.png" alt="image-20241116173420995"></p>
<p>原来的性能瓶颈出现在网络IO，从IO流中读取信息比较耗时，因此将读取命令和写回结果的任务派发给子线程</p>
<p>但是真正执行命令的过程并不是瓶颈（基于内存已经很快了）所以命令执行依然是单线程 </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ldw201510803006/article/details/124365838#:~:text=%E6%88%91%E4%BB%AC%E5%85%88%E6%9D%A5%E7%9C%8B%E7%9C%8B%EF%BC%8C%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%9C%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E9%98%B6%E6%AE%B5%EF%BC%9A">高性能网络编程之 Reactor 网络模型（彻底搞懂）_reactor网络模型-CSDN博客</a> </p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7124667316637270046#heading-11">Redis中的Reactor模型介绍Reactor模型，并对比Redis 6.0之前的单线程模型 与 Redis 6.0 - 掘金 (juejin.cn)</a> </p>
<h2 id="Redis通信协议"><a href="#Redis通信协议" class="headerlink" title="Redis通信协议"></a>Redis通信协议</h2><h3 id="RESP协议"><a href="#RESP协议" class="headerlink" title="RESP协议"></a>RESP协议</h3><p>Redis是一个C/S架构的软件，通信一般分两步（不包括pipeline和PubSub）：</p>
<ol>
<li>客户端（Client）向服务端（Server）发送一条命令</li>
<li>服务端解析并执行命令，返回响应结果给客户端</li>
</ol>
<p>因此客户端发送命令的格式、服务端响应结果的格式必须有一个规范，这个规范就是通信协议。(B/S架构为HTTP协议)</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/freee12/article/details/114411950">FTP、TFTP、HTTP、SMTP、DHCP、Telnet、DNS、SNMP(网络协议：应用层协议）-CSDN博客</a></p>
<p>Redis采用RESP（Redis Serialization Protocol）协议：</p>
<ul>
<li><p>Redis 1.2版本引入了RESP协议</p>
</li>
<li><p>Redis 2.0版本中成为与Redis服务端通信的标准，称为RESP2</p>
</li>
<li><p>Redis 6.0版本中，从RESP2升级到了RESP3协议，增加了更多数据类型并且支持6.0的新特性–客户端缓存</p>
</li>
</ul>
<p>但目前，默认使用的依然是RESP2协议，也是我们要学习的协议版本（以下简称RESP）。</p>
<p>在RESP中，通过首字节的字符来区分不同数据类型，常用的数据类型包括5种：</p>
<p>单行字符串：首字节是 ‘+’ ，后面跟上单行字符串，以CRLF（ “\r\n” ）结尾。例如返回”OK”： “+OK\r\n”</p>
<p>错误（Errors）：首字节是 ‘-’ ，与单行字符串格式一样，只是字符串是异常信息，例如：”-Error message\r\n”</p>
<p>数值：首字节是 ‘:’ ，后面跟上数字格式的字符串，以CRLF结尾。例如：”:10\r\n”</p>
<p>多行字符串：首字节是 ‘$’ ，表示二进制安全的字符串，最大支持512MB：</p>
<p>如果大小为0，则代表空字符串：”$0\r\n\r\n”</p>
<p>如果大小为-1，则代表不存在：”$-1\r\n”</p>
<p>数组：首字节是 ‘*’，后面跟上数组元素个数，再跟上元素，元素数据类型不限:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653982993020.png" alt="1653982993020"></p>
<h3 id="基于Socket自定义Redis客户端"><a href="#基于Socket自定义Redis客户端" class="headerlink" title="基于Socket自定义Redis客户端"></a>基于Socket自定义Redis客户端</h3><p>Redis支持TCP通信，因此我们可以使用Socket来模拟客户端，与Redis服务端建立连接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Socket s;</span><br><span class="line">    <span class="keyword">static</span> PrintWriter writer;</span><br><span class="line">    <span class="keyword">static</span> BufferedReader reader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.建立连接</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;192.168.150.101&quot;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">6379</span>;</span><br><span class="line">            s = <span class="keyword">new</span> <span class="title class_">Socket</span>(host, port);</span><br><span class="line">            <span class="comment">// 2.获取输出流、输入流</span></span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(s.getOutputStream(), StandardCharsets.UTF_8));</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream(), StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.发出请求</span></span><br><span class="line">            <span class="comment">// 3.1.获取授权 auth 123321</span></span><br><span class="line">            sendRequest(<span class="string">&quot;auth&quot;</span>, <span class="string">&quot;123321&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2.set name 虎哥</span></span><br><span class="line">            sendRequest(<span class="string">&quot;set&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">            <span class="comment">// 4.解析响应</span></span><br><span class="line">            obj = handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2.set name 虎哥</span></span><br><span class="line">            sendRequest(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="comment">// 4.解析响应</span></span><br><span class="line">            obj = handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2.set name 虎哥</span></span><br><span class="line">            sendRequest(<span class="string">&quot;mget&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;num&quot;</span>, <span class="string">&quot;msg&quot;</span>);</span><br><span class="line">            <span class="comment">// 4.解析响应</span></span><br><span class="line">            obj = handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 5.释放连接</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (reader != <span class="literal">null</span>) reader.close();</span><br><span class="line">                <span class="keyword">if</span> (writer != <span class="literal">null</span>) writer.close();</span><br><span class="line">                <span class="keyword">if</span> (s != <span class="literal">null</span>) s.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">handleResponse</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 读取首字节</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prefix</span> <span class="operator">=</span> reader.read();</span><br><span class="line">        <span class="comment">// 判断数据类型标示</span></span><br><span class="line">        <span class="keyword">switch</span> (prefix) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="comment">// 单行字符串，直接读一行</span></span><br><span class="line">                <span class="keyword">return</span> reader.readLine();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="comment">// 异常，也读一行</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(reader.readLine());</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>: <span class="comment">// 数字</span></span><br><span class="line">                <span class="keyword">return</span> Long.parseLong(reader.readLine());</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;$&#x27;</span>: <span class="comment">// 多行字符串</span></span><br><span class="line">                <span class="comment">// 先读长度</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.parseInt(reader.readLine());</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 再读数据,读len个字节。我们假设没有特殊字符，所以读一行（简化）</span></span><br><span class="line">                <span class="keyword">return</span> reader.readLine();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> readBulkString();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;错误的数据格式！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">readBulkString</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取数组大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.parseInt(reader.readLine());</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义集合，接收多个元素</span></span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(len);</span><br><span class="line">        <span class="comment">// 遍历，依次读取每个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            list.add(handleResponse());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set name 虎哥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendRequest</span><span class="params">(String ... args)</span> &#123;</span><br><span class="line">        writer.println(<span class="string">&quot;*&quot;</span> + args.length);</span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">            writer.println(<span class="string">&quot;$&quot;</span> + arg.getBytes(StandardCharsets.UTF_8).length);</span><br><span class="line">            writer.println(arg);</span><br><span class="line">        &#125;</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Redis内存回收"><a href="#Redis内存回收" class="headerlink" title="Redis内存回收"></a>Redis内存回收</h2><h3 id="过期key处理"><a href="#过期key处理" class="headerlink" title="过期key处理"></a>过期key处理</h3><p>Redis之所以性能强，最主要的原因就是基于内存存储。然而单节点的Redis其内存大小不宜过大，会影响持久化或主从同步性能。<br>我们可以通过修改配置文件来设置Redis的最大内存：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653983341150.png" alt="1653983341150"></p>
<p>当内存使用达到上限时，就无法存储更多数据了。为了解决这个问题，Redis提供了一些策略实现内存回收：</p>
<p>内存过期策略</p>
<p>在学习Redis缓存的时候我们说过，可以通过expire命令给Redis的key设置TTL（存活时间）：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653983366243.png" alt="1653983366243"></p>
<p>可以发现，当key的TTL到期以后，再次访问name返回的是nil，说明这个key已经不存在了，对应的内存也得到释放。从而起到内存回收的目的。</p>
<h4 id="RedisDB-结构"><a href="#RedisDB-结构" class="headerlink" title="RedisDB 结构"></a>RedisDB 结构</h4><p>Redis本身是一个典型的key-value内存存储数据库，因此所有的key、value都保存在之前学习过的Dict结构中。不过在其db结构体中，有两个Dict：一个用来记录key-value；另一个用来记录key-TTL。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653983423128.png" alt="redisDb 结构体"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653983606531.png" alt="1653983606531"></p>
<p>这里有两个问题需要我们思考：<br>Redis是如何知道一个key是否过期呢？</p>
<p>利用两个Dict分别记录key-value对及key-ttl对</p>
<p>是不是TTL到期就立即删除了呢？</p>
<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a><strong>惰性删除</strong></h4><p>惰性删除：顾明思议并不是在TTL到期后就立刻删除，而是在访问一个key的时候，检查该key的存活时间，如果已经过期才执行删除。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653983652865.png" alt="1653983652865"></p>
<h4 id="周期删除"><a href="#周期删除" class="headerlink" title="周期删除"></a><strong>周期删除</strong></h4><p>周期删除：通过一个定时任务，周期性的抽样部分过期的key，然后执行删除。执行周期有两种：</p>
<ul>
<li>Redis服务初始化函数initServer()中设置定时任务，按照server.hz的频率来执行过期key清理，模式为SLOW</li>
<li>Redis的每个事件循环前会调用beforeSleep()函数，执行过期key清理，模式为FAST</li>
</ul>
<p>SLOW模式规则：低频 高时长</p>
<ul>
<li>执行频率受server.hz影响，默认为10，即每秒执行10次，每个执行周期100ms。</li>
<li>执行清理耗时不超过一次执行周期的25%.默认slow模式耗时不超过25ms</li>
<li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</li>
<li>如果没达到时间上限（25ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li>
</ul>
<p>FAST模式规则（过期key比例小于10%不执行 ）    高频 低时长</p>
<ul>
<li>执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms</li>
<li>执行清理耗时不超过1ms</li>
<li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期<br>如果没达到时间上限（1ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li>
</ul>
<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>RedisKey的TTL记录方式：</p>
<ul>
<li>在RedisDB中通过一个Dict记录每个Key的TTL时间</li>
</ul>
<p>过期key的删除策略：</p>
<ul>
<li><p>惰性清理：每次查找key时判断是否过期，如果过期则删除</p>
</li>
<li><p>定期清理：定期抽样部分key，判断是否过期，如果过期则删除。</p>
</li>
</ul>
<p>定期清理的两种模式：</p>
<ul>
<li><p>SLOW模式执行频率默认为10，每次不超过25ms，低频高时长</p>
</li>
<li><p>FAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms，高频低时长</p>
</li>
</ul>
<h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>内存淘汰：就是当Redis内存使用达到设置的上限时，主动挑选部分key删除以释放更多内存的流程。Redis会在处理客户端命令的方法processCommand()中尝试做内存淘汰：（时机：调用真正的 回调函数之前）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653983978671.png" alt="1653983978671"></p>
<h4 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h4><p>Redis支持8种不同策略来选择要删除的key：</p>
<ul>
<li><p>noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。</p>
</li>
<li><p>volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</p>
</li>
<li><p>allkeys-random：对全体key ，随机进行淘汰。也就是直接从db-&gt;dict中随机挑选。</p>
</li>
<li><p>volatile-random：对设置了TTL的key ，随机进行淘汰。也就是从db-&gt;expires中随机挑选。</p>
</li>
<li><p>allkeys-lru： 对全体key，基于LRU算法进行淘汰</p>
</li>
<li><p>volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰</p>
</li>
<li><p>allkeys-lfu： 对全体key，基于LFU算法进行淘汰</p>
</li>
<li><p>volatile-lfu： 对设置了TTL的key，基于LFI算法进行淘汰</p>
</li>
</ul>
<h4 id="LRU-LFU"><a href="#LRU-LFU" class="headerlink" title="LRU LFU"></a>LRU LFU</h4><p>比较容易混淆的有两个：</p>
<ul>
<li>LRU（Least Recently Used），最少最近使用。最后一次访问时间越小则淘汰优先级越高。</li>
<li>LFU（Least Frequently Used），最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。</li>
</ul>
<p>Redis的数据都会被封装为RedisObject结构：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653984029506.png" alt="1653984029506"></p>
<p>LFU的访问次数之所以叫做逻辑访问次数，是因为并不是每次key被访问都计数，而是通过运算：</p>
<ul>
<li>生成0~1之间的随机数R</li>
<li>计算 (旧次数 * lfu_log_factor + 1)，记录为P</li>
<li>如果 R &lt; P ，则计数器 + 1，且最大不超过255</li>
<li>访问次数会随时间衰减，距离上一次访问时间每隔 lfu_decay_time 分钟，计数器 -1</li>
</ul>
<ul>
<li>Redis 在键的元数据中为每个键维护一个 <code>LFU 信息</code>，它是一个 8 位的字段。</li>
<li>这个字段的两个部分：<ul>
<li><strong>前 6 位</strong>（称为 <code>log-based counter</code>）：表示键的访问频率。</li>
<li><strong>后 2 位</strong>：存储时间相关信息，用于对计数的衰减。</li>
</ul>
</li>
</ul>
<p>Redis 的访问计数器设计为 <strong>对数型增长</strong>，原因是避免计数器线性增长带来的溢出问题，同时降低热点数据被频繁访问的影响。</p>
<p>Redis 定期对计数值进行衰减，确保长期未访问的键逐渐失去其高计数值。</p>
<ul>
<li>衰减机制使用 Redis 的 <code>LFU_DECAY_TIME</code> 参数控制，默认值为 1 分钟。</li>
<li>每次访问键时，Redis 检查上次更新计数的时间。如果超过 <code>LFU_DECAY_TIME</code>，就会减少计数值。</li>
</ul>
<p>$$<br>\text{新计数} = \text{旧计数} \times (0.5)^{\frac{\text{时间差}}{\text{LFU_DECAY_TIME}}}<br>$$</p>
<p><strong>计算淘汰优先级</strong></p>
<p>在淘汰键时，Redis 根据 LFU 计数选择淘汰候选：</p>
<ul>
<li>计数值越低，淘汰优先级越高。</li>
<li>如果计数值相同，Redis 会根据其他元数据（如键的创建时间）来辅助决定。</li>
</ul>
<p>Redis 提供了以下两种与 LFU 相关的内存淘汰策略：</p>
<ol>
<li><code>volatile-lfu</code>：从设置了过期时间的键中使用 LFU 策略淘汰。</li>
<li><code>allkeys-lfu</code>：从所有键中使用 LFU 策略淘汰。</li>
</ol>
<p>可以在 <code>redis.conf</code> 文件中设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy allkeys-lfu</span><br></pre></td></tr></table></figure>

<p>Redis 的 LFU 实现基于紧凑的计数器设计，并通过概率增长与时间衰减结合，达到高效的淘汰效果。它是 Redis 用于管理内存淘汰的重要策略之一，适合高访问频率场景下的优化。</p>
<h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653984085095.png" alt="1653984085095"></p>
<p>淘汰池子，加入抽样调查key，</p>
<p>淘汰规则：按照idleTime升序排序，值大的优先淘汰</p>
<p>LRU LFU TTL 都是值越小越应该淘汰，因此idleTime优先淘汰值大的</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default/">1</a><span class="space">&hellip;</span><a class="page-number" href="/default/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/default/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/default/page/8/">8</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">碎梦</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/scatteredream" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
