<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Arvo:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scatteredream.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"duration":100,"transition":{"menu_item":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="scatteredream&#39;s blog">
<meta property="og:url" content="http://scatteredream.github.io/default/page/5/index.html">
<meta property="og:site_name" content="scatteredream&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="碎梦">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://scatteredream.github.io/default/page/5/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default/page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>scatteredream's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">scatteredream's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="碎梦"
      src="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
  <p class="site-author-name" itemprop="name">碎梦</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">125</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/18/408-%E8%AE%A1%E7%BB%84-PC%20IO%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/18/408-%E8%AE%A1%E7%BB%84-PC%20IO%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">PC IO 结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-18 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-18T00:00:00+08:00">2024-09-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-11 10:46:52" itemprop="dateModified" datetime="2025-05-11T10:46:52+08:00">2025-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">计组</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Prototypical-Architecture"><a href="#Prototypical-Architecture" class="headerlink" title="Prototypical Architecture"></a>Prototypical Architecture</h1><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241216183418923-1734346411610-1.png" alt="image-20241216183418923"></p>
<p>CPU通过专用的内存总线连接到内存，通过通用I/O总线(如PCI)连接到显卡等高性能设备，通过外围总线连接到低速的设备(USB Flash, 磁盘驱动器 )，因为光速的限制以及各种物理因素，越快的总线越短，造价也贵，因此离CPU越远的设备性能越低。</p>
<h1 id="Modern-Architecture"><a href="#Modern-Architecture" class="headerlink" title="Modern Architecture"></a>Modern Architecture</h1><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241216185046235.png" alt="image-20241216185046235"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1024px-Motherboard_diagram.svg-1734348489593-5.png" alt="undefined"></p>
<p>在现代系统架构中，有更多的点对点连接到 CPU，PCIe 显卡总线和内存专用总线速度相近，以提供更高的显示性能，CPU通过 <strong>DMI</strong> 连接到一颗 I/O 芯片，所有其他外设通过各种总线连接到这颗I/O芯片。</p>
<h2 id="CPU-Socket"><a href="#CPU-Socket" class="headerlink" title="CPU Socket"></a>CPU Socket</h2><ul>
<li>用于安装中央处理器 (CPU)。</li>
<li>支持不同接口类型（如 LGA、PGA 或 BGA）。</li>
<li>插槽周围有供电模块（VRM）提供稳定电压。</li>
</ul>
<p>不同CPU系列使用不同插槽。后期CPU插槽，数字多数与针脚数量相同：</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LGA_1155">LGA 1155</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LGA_1366">LGA 1366</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LGA_2066">LGA 2066</a>  <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LGA_1700">LGA 1700</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Socket_AM4">Socket AM4</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Socket_TR4">Socket TR4</a> </p>
<h2 id="Chipset"><a href="#Chipset" class="headerlink" title="Chipset"></a>Chipset</h2><p>管理数据传输和硬件通信，负责连接 CPU、内存、显卡、存储等设备</p>
<p><strong>芯片组</strong>(Chipset)负责将电脑的处理器和和其它部分连接，以便能互传数据。芯片组在它所诞生的1980年代时是由多颗微芯片组成的，但是随着科技的进步，芯片组先是从2000年代开始简化为南桥和北桥两颗芯片，再于2010年代简化为单独一颗的南桥芯片，北桥芯片内置在CPU中，目前世界上的芯片组均以单南桥芯片为主流。  </p>
<ul>
<li><strong>南桥</strong>(Southbridge): 主要处理低速信号，后来演变成 ICH-&gt;PCH</li>
<li><strong>北桥</strong>(Northbridge): 主要处理高速信号，同时也负责与南桥的通信，IOH-&gt;MCH，集成进CPU</li>
<li><strong>DMI</strong>：连接南北桥的串行总线</li>
<li><strong>FSB</strong>：前端总线，负责 CPU 和北桥的数据传递。现在的x86 CPU 内部整合了<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%A8%98%E6%86%B6%E9%AB%94%E6%8E%A7%E5%88%B6%E5%99%A8&action=edit&redlink=1">北桥</a>。FSB 已被Intel <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/QPI">QPI</a>和AMD <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HyperTransport">HyperTransport</a>取代</li>
</ul>
<h3 id="Memory-Controller-Hub-Northbridge"><a href="#Memory-Controller-Hub-Northbridge" class="headerlink" title="Memory Controller Hub (Northbridge)"></a>Memory Controller Hub (Northbridge)</h3><p>随着技术发展，原来的北桥芯片已直接整合到 <strong>CPU 内部</strong>，减少延迟并提升效率：</p>
<table>
<thead>
<tr>
<th>控制器名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Memory Controller</strong></td>
<td>控制内存访问和管理，负责与 RAM 通信。</td>
</tr>
<tr>
<td><strong>Integrated Graphics Controller</strong></td>
<td>提供基本图形渲染能力，支持视频输出，无需独立显卡。</td>
</tr>
<tr>
<td><strong>PCIe Controller (部分 CPU)</strong></td>
<td>高端 CPU 内部集成部分 PCIe 通道，用于高性能设备的直接通信。</td>
</tr>
<tr>
<td><strong>Power Management Controller</strong></td>
<td>管理电源状态和功耗调节，提高能效。</td>
</tr>
</tbody></table>
<h4 id="Memory-Slots"><a href="#Memory-Slots" class="headerlink" title="Memory Slots"></a>Memory Slots</h4><ul>
<li>用于安装内存模块（RAM）。</li>
<li>常见类型：DDR3、DDR4、DDR5 等。</li>
<li>多通道技术（如双通道、四通道）提高内存带宽。</li>
</ul>
<h5 id="Volatile-Memory-RAM"><a href="#Volatile-Memory-RAM" class="headerlink" title="Volatile Memory (RAM)"></a>Volatile Memory (RAM)</h5><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8F%AE%E7%99%BC%E6%80%A7%E8%A8%98%E6%86%B6%E9%AB%94">易失性存储器</a>(Volatile Memory): 电流中断后，所存储的数据便会消失，一般为 <strong>RAM</strong></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%9C%E6%85%8B%E9%9A%A8%E6%A9%9F%E5%AD%98%E5%8F%96%E8%A8%98%E6%86%B6%E9%AB%94">静态随机存储器</a>(<strong>SRAM</strong>, Static RAM): 把信息存储在锁存器中，只要保持通电，存储的数据就可以一直保持，存储密度较低，速度高，功耗低，内部结构也更为复杂。通常作为<strong>cache</strong>(L1, L2, L3)、<strong>寄存器</strong>或 FPGA ASIC 等专用设备的存储器。</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8">动态随机存储器</a>(<strong>DRAM</strong>, Dynamic RAM): 根据电容中的电荷多寡来分辨0和1，电容会漏电，不仅要保持通电，还需周期性充电。由于这种需要定时刷新的特性，因此被称为“动态”存储器。存储密度高，速度较低，功耗高，但是成本比 SRAM 低，通常作为 主存 使用，用于存储运行中的程序和数据；也用于 显存。<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SDRAM">同步 DRAM</a>(<strong>SDRAM</strong>, Synchronous DRAM): 在 DRAM 的架构基础上增加同步和双区域（Dual Bank）的功能，使得<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E8%99%95%E7%90%86%E5%99%A8">微处理器</a>能与 SDRAM 的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%99%82%E8%84%88">时钟</a>同步，所以 SDRAM 执行命令和传输资料时相较于 DRAM 可以节省更多时间。</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DDR_SDRAM">双倍数据率 SDRAM</a>(DDR SDRAM, Double Data Rate): DDR SDRAM 在系统时钟的上升沿和下降沿都可以进行数据传输，发展到 DDR5，数据传输率、总线频率逐渐提高<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A7%BB%E5%8A%A8DDR">低功耗 DDR</a>(<strong>LPDDR</strong>, Low Power DDR): 专门用于移动设备，发展到 LPDDR5X</li>
<li>图形 DDR(<strong>GDDR</strong>, Graphics DDR): 为高性能显卡提供显存支持，发展到 GDDR7</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%A0%BB%E5%AF%AC%E8%A8%98%E6%86%B6%E9%AB%94">高带宽内存</a>(HBM, High Bandwidth Memory): 基于3D堆栈工艺的高性能 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DRAM">DRAM</a> 适用于高存储器带宽需求的应用场合，与高性能<strong>显卡</strong>、路由器、交换机、高性能数据中心的AI ASIC结合使用，在 CPU 和 FPGA 中用作包内 RAM 和 Cache</li>
</ul>
</li>
</ol>
<h4 id="PCIe"><a href="#PCIe" class="headerlink" title="PCIe"></a>PCIe</h4><p>北桥负责高速传输，因此显卡这种高速设备也需要通过PCIe和北桥(CPU)相连，详见下方PCIe x16</p>
<h3 id="I-O-Controller-Hub-Southbridge"><a href="#I-O-Controller-Hub-Southbridge" class="headerlink" title="I/O Controller Hub (Southbridge)"></a>I/O Controller Hub (Southbridge)</h3><table>
<thead>
<tr>
<th>控制器名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Disk Controller</strong></td>
<td>控制 SATA、SAS 等存储设备的数据传输。</td>
</tr>
<tr>
<td><strong>USB Controller</strong></td>
<td>控制 USB 2.0、3.0、3.1、Type-C 等接口的数据传输。</td>
</tr>
<tr>
<td><strong>PCIe Controller</strong></td>
<td>管理 PCI Express 插槽的通信，用于扩展显卡、网卡等设备。</td>
</tr>
<tr>
<td><strong>Ethernet Controller</strong></td>
<td>控制有线网络通信，通常内置支持千兆或 2.5G 网卡。</td>
</tr>
<tr>
<td><strong>Audio Controller</strong></td>
<td>提供板载音频功能，支持麦克风、扬声器等外设连接。</td>
</tr>
<tr>
<td><strong>SATA Controller</strong></td>
<td>控制 SATA 硬盘和光驱设备的数据传输。</td>
</tr>
<tr>
<td><strong>RAID Controller</strong></td>
<td>支持磁盘阵列（RAID）的数据管理，提高存储性能和安全性。</td>
</tr>
<tr>
<td><strong>Wireless Controller</strong></td>
<td>控制 Wi-Fi 和蓝牙模块的无线通信功能（部分主板内置）。</td>
</tr>
<tr>
<td><strong>Security Controller (TPM)</strong></td>
<td>提供可信平台模块 (TPM) 功能，保障数据安全性和加密管理。</td>
</tr>
</tbody></table>
<h4 id="Storage-Interface-SATA-SAS"><a href="#Storage-Interface-SATA-SAS" class="headerlink" title="Storage Interface (SATA/SAS)"></a>Storage Interface (SATA/SAS)</h4><ul>
<li><strong>IDE</strong>(Integrated Device Electronics): IDE 是一项企图把控制器与盘体集成在一起为主要意图的硬盘接口技术。</li>
<li><strong>ATA</strong>(Advanced Technology Attachment): ATA 技术是一个关于 IDE 的技术规范族，全球标准化协议将 IDE 接口技术自诞生以来使用的技术规范归纳成为全球硬盘标准。<ul>
<li><strong>并行接口 ATA</strong>(Parallel ATA)的电缆属性、连接器和信号协议都表现出了很大的技术瓶颈，而在技术上突破这些瓶颈存在相当大的难度</li>
</ul>
</li>
<li>==<strong>SATA</strong>==(Serial ATA): 并行的 PATA 存在固有的瓶颈——并行信号串扰与同步问题，因此改成了<strong>串行</strong>总线。SATA 既是一种<strong>物理接口</strong>（硬件层连接方式），也是一种<strong>逻辑接口</strong>协议（定义数据通信规则）最初是为传统机械硬盘（HDD）设计的，后来也应用于部分 SSD<ul>
<li><strong>eSATA</strong>(External SATA): 外置 SATA 接口，方便外设的连接，eSATA 不像 USB 那样能同时传输数据和供电，因此需要额外的电源线为外部设备供电，属于物理接口协议。</li>
<li><strong>mSATA</strong>(mini-SATA): 迷你版本SATA接口，外型和电子接口与mini PCI-E完全相同，但电子信号不同，两者互不兼容。多用于固态硬盘，适用于需要尺寸较小的存储器的场合</li>
<li><strong>AHCI</strong>(Advanced Host Controller Interface): 允许软件与 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SATA">SATA</a> 存储设备沟通的硬件机制，激活 SATA 的高级功能，属于逻辑接口协议。AHCI 系统的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E6%9C%BA%E9%80%82%E9%85%8D%E5%99%A8">主机适配器</a>将CPU/存储器子系统与相对慢得多的、基于旋转<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A3%81%E5%84%B2%E5%AD%98">磁性介质</a>的存储子系统，AHCI 是针对这种悬殊的速度差来进行优化设计的。AHCI 是针对硬盘优化的，不适合固态盘。</li>
</ul>
</li>
<li><strong>SCSI</strong>(Small Computer System Interface): 一种连接主机和外围设备的接口，支持包括硬盘、光驱及扫描仪在内的多种设备。SCSI 总线是一种<strong>并行</strong>总线，其优点是适应面广，性能高；缺点是价格昂贵，安装复杂。</li>
<li>==<strong>SAS</strong>==(Serial Attached SCSI): <strong>串行</strong> SCSI ，跟 SATA 总线类似，都是采用串行技术以获得更高的传输速度。就接口标准而言，SATA 是 SAS 的一个子标准，因此 SAS 控制器可以直接操控SATA 硬盘，但是 SATA 控制器并不能对 SAS 硬盘进行控制。</li>
</ul>
<p>SCSI/SAS 需要专用的控制卡，或者主板另外集成控制芯片，性能更好。PATA/SATA 一般由主板南桥/ICH 芯片直接集成控制器，但接口性能一般比同时期的 SCSI/SAS 要低。目前，服务器流行的硬盘接口类型是 SATA 以及 SAS，两者都是采用串行技术，传输速率都更高。</p>
<h4 id="I-O-Ports-USB-DP-HDMI"><a href="#I-O-Ports-USB-DP-HDMI" class="headerlink" title="I/O Ports(USB, DP, HDMI)"></a>I/O Ports(USB, DP, HDMI)</h4><p><strong>通用外设接口</strong> </p>
<ul>
<li><p><strong>==USB==</strong>(Universal Serial Bus): 串口总线标准，也是一种输入输出接口的技术规范，被广泛地应用于个人电脑和移动设备等信息通讯产品，并扩展至摄影器材、数字电视(机顶盒)、游戏机等其它相关领域。逐渐取代 PS/2 连接键盘与鼠标，取代 COM(串口)与 LPT(并口)</p>
<ul>
<li><p>技术标准</p>
<ul>
<li>USB 2.0: 480 Mbps，半双工</li>
<li>USB 3.0: 5 Gbps，全双工，向下兼容</li>
<li>USB 3.1: 10 Gbps，向下兼容</li>
<li>USB 3.2: 20 Gbps，在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/USB_Type-C">USB Type-C</a>接口上实现双通道，向下兼容，推荐 Type-C 接口</li>
<li>USB 4: 40 Gbps，只支持 Type-C</li>
<li>USB PD: USB 充电标准</li>
</ul>
</li>
<li><p>接口</p>
<ul>
<li>Mini-USB：弃用</li>
<li>Type-A： <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1920px-USB_3.0_Type-A_receptacle_blue.svg.png" alt="undefined" style="zoom:3%;" />  <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2560px-USB_3.0_Type-A_blue.svg.png" alt="undefined" style="zoom:3%;" /></li>
<li>Type-B：<img src="https://upload.wikimedia.org/wikipedia/commons/d/d5/USB_3.0_Type-B_blue.svg" style="zoom:17%;" /> <img src="https://upload.wikimedia.org/wikipedia/commons/8/8c/USB_3.0_Type-B_receptacle_blue.svg" style="zoom:17%;" /></li>
<li>Micro-USB：<img src="https://upload.wikimedia.org/wikipedia/commons/1/1b/USB_Micro-B_receptacle.svg" style="zoom:15%;" /> <img src="https://upload.wikimedia.org/wikipedia/commons/1/15/USB_Micro-B.svg" style="zoom:16%;" /></li>
<li>Type-C：<img src="https://upload.wikimedia.org/wikipedia/commons/e/e8/USB_Type-C_receptacle.svg" style="zoom:15%;" /> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/512px-USB_Type-C_icon.svg.png" alt="img" style="zoom:13%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>雷电</strong>(Thunderbolt): 目的在于当作电脑与其他设备之间的通用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8C%AF%E6%B5%81%E6%8E%92_(%E6%95%B8%E6%93%9A)">总线</a>，第一代与第二代的连接口与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Mini_DisplayPort">Mini DisplayPort</a>集成，第三代至第五代的连接口与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/USB_Type-C">USB Type-C</a>结合，并且能用于充电。由于采用了PCI Express和DisplayPort架构，雷电可以<strong>高速连接诸如硬盘、RAID阵列、视频采集设备和网络接口等外设</strong> </p>
</li>
</ul>
<p><strong>音视频接口</strong>(HDMI, DP, 雷电)：</p>
<ul>
<li><p><strong>VGA</strong>(视频图形阵列, <strong>V</strong>ideo <strong>G</strong>raphics <strong>A</strong>rray): 使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E6%AF%94%E8%A8%8A%E8%99%9F">模拟信号</a>的电脑显示标准，在1987年随IBM PS/2系列计算机推出。VGA是大多数PC制造商所遵循的最后一个IBM图形标准，几乎1990年后的所有PC图形硬件都最低支持VGA。当用VGA来表示分辨率时，通常是指640×480。</p>
</li>
<li><p><strong>DVI</strong>(<strong>数字</strong>视频接口, <strong>D</strong>igital <strong>V</strong>isual <strong>I</strong>nterface)：一种<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A6%96%E8%A8%8A">视频</a>接口标准，设计的目的是用来传输未经压缩的数字化影像。目前广泛应用于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LCD">LCD</a>、数字<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8A%95%E5%BD%B1%E6%A9%9F">投影机</a>等显示设备上。</p>
</li>
<li><p><strong>HDMI</strong>(高清媒体接口, <strong>H</strong>igh <strong>D</strong>efinition <strong>M</strong>ultimedia <strong>I</strong>nterface): 是一种全<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D">数字</a>化<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BD%B1%E5%83%8F">影像</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%81%B2%E9%9F%B3">声音</a>发送接口，可以发送未<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E5%A3%93%E7%B8%AE">压缩</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9F%B3%E9%A2%91">音频</a>及<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A6%96%E9%A0%BB">视频</a>信号。HDMI 可以同时发送音频和视频信号。音频和视频信号采用同一条线材的设计大大简化系统线路的安装难度。</p>
</li>
<li><p><strong>DP</strong>(显示端口, <strong>D</strong>isplay <strong>P</strong>ort): 数字式音频/视频接头，此接口的设计是为了取代传统的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/VGA">VGA</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DVI">DVI</a>接口。透过主动或被动转接器，该接口可与传统接口（如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HDMI">HDMI</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DVI">DVI</a>）<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%90%91%E4%B8%8B%E7%9B%B8%E5%AE%B9">向下兼容</a>。</p>
</li>
<li><p><strong>雷电</strong>(Thunderbolt): 有接口也有总线，目的在于当作电脑与其他设备之间的通用 <strong>总线</strong>，第一代与第二代的连接口与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Mini_DisplayPort">Mini DisplayPort</a>集成，第三代至第五代的连接口与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/USB_Type-C">USB Type-C</a>结合，并且能用于充电。由于采用了PCI Express和DisplayPort架构，雷电可以<strong>高速连接诸如硬盘、RAID阵列、视频采集设备和网络接口等外设</strong>。</p>
</li>
</ul>
<h4 id="Peripheral-Card-Slots"><a href="#Peripheral-Card-Slots" class="headerlink" title="Peripheral Card Slots"></a>Peripheral Card Slots</h4><p>外围扩展设备插槽：</p>
<ul>
<li>用于连接显卡、声卡、网卡、固态硬盘 (NVMe SSD) 等扩展设备。</li>
<li>常见标准：PCI Express (PCIe) 3.0、4.0、5.0  M.2 2280</li>
</ul>
<h5 id="PCIe-slots"><a href="#PCIe-slots" class="headerlink" title="PCIe slots"></a>PCIe slots</h5><p>PCIe 可以连到南桥或北桥</p>
<ul>
<li><strong>PCI</strong>(Peripheral Component Interconnect): 常见于现代的个人电脑中，并已取代了 ISA 和 VESA 局部总线，成为了标准扩展总线，是并行的总线。</li>
<li><strong>==PCIe==</strong>(PCI Express): 沿用既有的 PCI 编程概念及信号标准，并且构建了更加高速的串行通信系统标准。只需修改<strong>物理层</strong>而无须修改软件就可将现有 PCI 系统转换为 PCIe，几乎取代了以往所有的内部总线(包括 PCI)。现在英特尔和 AMD 已采用单芯片组(IO Chip)技术，取代原有的南桥和北桥方案。PCIe仅应用于内部互连，没有对外开放的接口。可以连接<strong>显卡</strong>、<strong>网卡</strong>，高性能的持久化存储设备如 NVMe 设备。根据传输通道数量分为 PCIe ×1, PCIe ×4, PCIe ×8, PCIe ×16<ul>
<li><strong>SATA Express</strong>: 物理、逻辑接口标准，使用 PCIe 总线，向下兼容 SATA，支持 PCIe(AHCI 和 NVMe) 设备。后来物理接口被 M.2 和 U.2 取代。</li>
<li><strong>NVMe</strong>(NVM Express, NVMHCIS): 非易失性存储器的接口标准，它是基于设备<strong>逻辑接口</strong>的总线传输协议规范，用于访问通过 PCIe 总线附加的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%9E%E6%8F%AE%E7%99%BC%E6%80%A7%E8%A8%98%E6%86%B6%E9%AB%94">非易失性存储器</a>介质（比如 SSD）降低了I/O操作等待时间、提升同一时间内的操作数、更大容量的操作队列等，取代 AHCI 作为新的逻辑接口协议。</li>
</ul>
</li>
</ul>
<h6 id="NVM-Flash-EEPROM"><a href="#NVM-Flash-EEPROM" class="headerlink" title="NVM(Flash/EEPROM)"></a>NVM(Flash/EEPROM)</h6><p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%9E%E6%8F%AE%E7%99%BC%E6%80%A7%E8%A8%98%E6%86%B6%E9%AB%94">非易失性存储器</a></strong>(<strong>NVM</strong>, Non-Volatile Memory): 电流关掉后，所存储的信息不会消失的存储设备。依存储器内的资料是否能在使用系统时随时改写为标准，可分为三大类产品：</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ROM">只读存储器</a>(ROM, Read-only Memory)</p>
<ul>
<li>MROM(Masked ROM): 使用掩模工艺，出厂后不可改变，永久固化</li>
<li>PROM(Programmable ROM): 用户可编程的 ROM，烧断熔丝来改变比特，不可逆</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%93%A6%E9%99%A4%E5%8F%AF%E8%A6%8F%E5%8A%83%E5%BC%8F%E5%94%AF%E8%AE%80%E8%A8%98%E6%86%B6%E9%AB%94">EPROM</a>(Erasable PROM): FGMOS 代替熔丝，专用编程器编程，用紫外线擦除，可逆</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E6%8A%B9%E9%99%A4%E5%BC%8F%E5%8F%AF%E8%A4%87%E5%AF%AB%E5%94%AF%E8%AE%80%E8%A8%98%E6%86%B6%E9%AB%94">EEPROM</a>(Electrically EPROM): 只需要特定电压就可以擦除</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Flash_memory">闪存</a>(Flash Memory): 与传统的硬盘相比，闪存有更佳的动态抗震性，不会因为剧烈晃动而造成资料丢失。与 SRAM 相比不需要供电，造价相对 EEPROM 较低，使用块抹除。闪存在分类上属于 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EEPROM">EEPROM</a> 的一种，但普通的 EEPROM 使用的是字节抹除。 </p>
<ul>
<li><p>按照 FGMOS 的门电路结构分为：</p>
<ul>
<li>NOR Flash: 抹写时间长，提供完整的寻址总线，可按字节<strong>随机存取</strong>，类似 RAM</li>
<li>NAND Flash: 抹写时间短，次数高，存储密度高，只能按页访问，类似硬盘，应用有 SSD 固态硬盘、SD 卡、U盘等。</li>
</ul>
</li>
<li><p>按照 每存储单元存储 bit 数分为：</p>
<ul>
<li><p>SLC(1) MLC(2) TLC(3) QLC(4) 成本、寿命、写入性能依次降低</p>
</li>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2560px-Nand_flash_structure.svg.png" alt="undefined"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E9%9D%9E%E6%8F%AE%E7%99%BC%E6%80%A7%E9%9A%A8%E6%A9%9F%E5%AD%98%E5%8F%96%E8%A8%98%E6%86%B6%E9%AB%94&action=edit&redlink=1">非易失性随机存储器</a>(NVRAM, Non-volatile RAM)</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/FRAM">FeRAM</a>: 替换介电质为铁电材料</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A3%81%E9%98%BB%E5%BC%8F%E9%9A%A8%E6%A9%9F%E5%AD%98%E5%8F%96%E8%A8%98%E6%86%B6%E9%AB%94">MRAM</a>: 使用磁存储器件存储数据，应用巨磁阻效应</li>
</ul>
</li>
</ol>
<h5 id="M-2-slots"><a href="#M-2-slots" class="headerlink" title="M.2 slots"></a>M.2 slots</h5><ul>
<li><strong>==M.2==</strong>(NGFF): 采用全新物理布局与接口，取代 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/PCI_Express">PCIe</a> 及 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SATA#mSATA">mSATA</a> 的物理插槽<ul>
<li>U.2: 2015 年SATA Express发布了一种兼容SAS、PCI Express x4、SATA总线的的U.2连接器界面，U.2更多用于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%BA%E6%9C%8D%E5%99%A8">服务器</a>等企业应用场合。U.2支持<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%86%B1%E6%8F%92%E6%8B%94">热插拔</a>而M.2不支持；U.2可使用3.3V电源和12V电源，M.2只能使用3.3V电源；M.2可应用于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98">固态硬盘</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1">无线网卡</a>等设备，而U.2仅用于2.5英寸固态盘。</li>
<li>支持 SATA、AHCI+PCIe、NVMe+PCIe，同时可以连接网卡等</li>
</ul>
</li>
</ul>
<h4 id="Flash-ROM-BIOS"><a href="#Flash-ROM-BIOS" class="headerlink" title="Flash ROM (BIOS)"></a>Flash ROM (BIOS)</h4><p>大部分的主板的BIOS存储在Flash ROM芯片内，用于对主板作启动的初始化；在启动的过程中包含存储器、周边设备都会被测试以及做初始设置，这个过程称为 加电自检 POST，若是在 POST 的过程中出现错误，则主机会发出”哔”声或是出现错误消息在屏幕上。从2011年起，大部分的零售主板已采用UEFI BIOS，一些厂商（尤其是微星科技、华硕）还率先导入图形界面的UEFI BIOS等技术。</p>
<h4 id="CMOS-Memory"><a href="#CMOS-Memory" class="headerlink" title="CMOS Memory"></a>CMOS Memory</h4><p>CMOS 纽扣电池供电给 CMOS 芯片(RAM)，CMOS 芯片保存系统时间和 BIOS 设置。</p>
<h2 id="Other-Modules"><a href="#Other-Modules" class="headerlink" title="Other Modules"></a>Other Modules</h2><h3 id="Power-Interface"><a href="#Power-Interface" class="headerlink" title="Power Interface"></a>Power Interface</h3><ul>
<li>24 针主电源接口：为主板供电。</li>
<li>8 针或 4+4 针 CPU 辅助电源接口：为 CPU 供电。</li>
</ul>
<h3 id="Cooling-Module"><a href="#Cooling-Module" class="headerlink" title="Cooling Module"></a>Cooling Module</h3><ul>
<li>CPU 散热器接口：供电及控制风扇速度。</li>
<li>芯片组和供电模块上的散热片和风扇，降低温度。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1024px-IO_stack_of_the_Linux_kernel.svg.png" alt="undefined"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/17/408-%E8%AE%A1%E7%BB%84-ROM%20RAM%20Cache%20Bus%20IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/17/408-%E8%AE%A1%E7%BB%84-ROM%20RAM%20Cache%20Bus%20IO/" class="post-title-link" itemprop="url">ROM RAM Cache IO</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-17 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-17T00:00:00+08:00">2024-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 12:44:19" itemprop="dateModified" datetime="2025-05-05T12:44:19+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">计组</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240617152721653.png" alt="image-20240617152721653"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240617154333462.png" alt="image-20240617154333462"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240617160638666.png" alt="image-20240617160638666"></p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="计算机基本组成"><a href="#计算机基本组成" class="headerlink" title="计算机基本组成"></a>计算机基本组成</h2><h4 id="冯诺依曼"><a href="#冯诺依曼" class="headerlink" title="冯诺依曼"></a>冯诺依曼</h4><p>==calculator== storage controller I/O</p>
<p>instruction data 同等地位</p>
<p>层次化 模块化 明确定义的接口</p>
<p>规则性 容易被重用</p>
<p>取存 加乘 PRINTs STOP</p>
<p>指令格式：操作码+地址码</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240617213301501.png" alt="image-20240617213301501"></p>
<h4 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h4><p>存储单元个数 由MAR决定 存储器地址寄存器，4位能存16个地址</p>
<p>取数指令，运算指令 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240617214101456.png" alt="image-20240617214101456"></p>
<p>每个存储单元能够保存的数据长度称为字长，</p>
<p>MAR 4位 能存16个地址</p>
<p>MDR 8位 每个地址能存的字节数</p>
<p>房间号-房间里的床位情况</p>
<h4 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h4><p>乘法<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240621161144203.png" alt="image-20240621161144203"></p>
<h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><h4 id="完成一条指令的过程"><a href="#完成一条指令的过程" class="headerlink" title="完成一条指令的过程"></a>完成一条指令的过程</h4><p>取指令，PC储存要执行指令的地址，应支持计数，存到IR，取完自加</p>
<p>分析指令， IR 存放当前执行的指令，OPCODE操作码给到CU</p>
<p>执行指令 操作数的地址</p>
<ul>
<li>程序计数器（PC，Program counter），用于存放指令的地址。为了保证程序(在操作系统中理解为进程)能够连续地执行下去，CPU必须具有某些手段来确定下一条指令的地址。当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到指令寄存器中，此过程称，为“取指令”。与此同时，PC中的地址或自动加1或由转移指针给出下一条指令的地址。此后经过分析指令，执行指令。完成第一条指令的执行，而后根据PC取出第二条指令的地址，如此循环，执行每一条指令。</li>
<li>指令寄存器（IR，Instruction Register），用来保存当前正在执行的一条指令。是临时放置从内存里面取得的程序指令的寄存器，用于存放当前从主存储器读出的正在执行的一条指令。当执行一条指令时，先把它从内存取到数据寄存器（DR，Data Register）中，然后再传送至IR。指令划分为操作码和地址码字段，由二进制数字组成。为了执行任何给定的指令，必须对操作码进行测试，以便识别所要求的操作。指令译码器就是做这项工作的。指令寄存器中操作码字段的输出就是指令译码器的输入。操作码一经译码后，即可向操作控制器发出具体操作的特定信号。</li>
</ul>
<h4 id="主机完成一条指令过程"><a href="#主机完成一条指令过程" class="headerlink" title="主机完成一条指令过程"></a>主机完成一条指令过程</h4><p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240621171338162.png" alt="image-20240621171338162"></p>
<h4 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h4><p>字长，主频，核数与线程数，指令集执行的时间（静态动态执行频率）</p>
<p>CPI 一条指令所需时钟周期数</p>
<p>IPC 一个时钟周期执行指令数</p>
<p>mips 每秒执行的百万条指令数</p>
<p>flops 每秒浮点运算次数</p>
<p>iops I/O Operations Per Second</p>
<h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>总线： 各部件共享的传输介质，分时，同一时刻只允许一个</p>
<p>传送方式：串行、并行（距离短）</p>
<p>主设备从设备：有无对总线的控制功能</p>
<h3 id="单总线"><a href="#单总线" class="headerlink" title="单总线"></a>单总线</h3><p>延宕严重</p>
<h3 id="双总线"><a href="#双总线" class="headerlink" title="双总线"></a>双总线</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240621213833311.png" alt="image-20240621213833311"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240621213950031.png" alt="image-20240621213950031"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240621221022916.png" alt="image-20240621221022916"></p>
<ol start="3">
<li>通信总线</li>
</ol>
<h3 id="总线通信"><a href="#总线通信" class="headerlink" title="总线通信"></a>总线通信</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/iteye_21199/article/details/82200270">同步通信：高度同步，总系长度短</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704200733860.png" alt="image-20240704200733860"></p>
<p>不互锁，半互锁，全互锁</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704200917886.png" alt="image-20240704200917886"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704201135928.png" alt="image-20240704201135928"></p>
<p>从设备准备好数据，WAIT才变成高电平</p>
<p>主模块发地址 命令，占用总线</p>
<p>从模块准备数据，<strong>空闲</strong></p>
<p>从模块向主模块发数据，占用总线</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704201642697.png" alt="image-20240704201642697"></p>
<p>同步方式，不等对方回答</p>
<p>各模块都有权申请占用总线</p>
<p>从模块变成主模块，发完数据以后再次跟总线断开，总线和原来的主模块连接</p>
<p>充分利用总线带宽</p>
<h3 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h3><p>链式查询、计数器定时查询、独立请求</p>
<p>为的是解决多个设备竞争总线控制权</p>
<h2 id="存储器-1"><a href="#存储器-1" class="headerlink" title="存储器"></a>存储器</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a><strong>存储介质</strong></h4><p><strong>半导体</strong>存储器（TTL MOS）</p>
<p><strong>磁</strong>表面 (HDD 磁带)</p>
<p>磁芯存储器(Core memory) 电流磁化以后使其极化</p>
<p><strong>光盘</strong>存储器</p>
<h4 id="存取方式"><a href="#存取方式" class="headerlink" title="存取方式"></a>存取方式</h4><p>随机访问，和物理地址无关 RAM 可读写，只读存储器ROM只读</p>
<p>串行访问，磁带，顺序存取，磁盘</p>
<h4 id="地位"><a href="#地位" class="headerlink" title="地位"></a>地位</h4><p>主存</p>
<ul>
<li>RAM(SRAM,DRAM)<br>ROM(MROM,PROM,EPROM,EEPROM)</li>
</ul>
<p>闪存 缓冲主存和辅存</p>
<p>高速缓冲存储器Cache sram</p>
<p>辅助存储</p>
<h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><p>速度，价格，容量</p>
<p>存储体系：把两种以上的存储器用软&amp;硬件连接成一个整体</p>
<p>缓存和主存之间要的是速度，硬件支持</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704203517251.png" alt="image-20240704203517251"></p>
<p>主辅之间要的是容量，软件硬件相结合，虚拟存储，虚地址</p>
<h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704205102321.png" alt="image-20240704205102321"></p>
<p>GB是千kilo进制 </p>
<p>GiB是千位kilo b<strong>i</strong>nary二进制</p>
<p>计算机一次处理的位数称为字长</p>
<p>16位，1word=16bit=2byte</p>
<p>32位，1word=32bit=4byte</p>
<p>64位，1word=64bit=8byte</p>
<p>字节是计算机处理数据的基本单位，几乎所有计算机操作系统和编程语言都以字节为单位进行数据管理和传输，数据存储是以“字节”（Byte）为单位，数据传输是以大多是以“位”（bit，又名“比特”）为单位，一个位就代表一个0或1（即二进制），每8个位（bit，简写为b）组成一个字节（Byte，简写为B），是最小一级的信息单位。<br>还可以从以下几个方面来理解：<br>1.字节(Byte)是电脑中表示信息含义的最小单位，因为在通常情况下一个ACSII码就是一个字节的空间来存放。而事实上电脑中还有比字节更小的单位，因为一个字节是由八个二进制位组成的，换一句话说，每个二进制位所占的空间才是电脑中最小的单位，我们把它称为位，也称比特（bit）。由此可见，一个字节等于八个位。人们之所以把字节称为电脑中表示信息含义的最小单位，表示最基本的字符，是因为一个位并不能表示我们现实生活中的一个相对完整的信息。另外，内存中运算的最小存储单位是字节，位运算也是在一个字节的存储单位的基础上进行的，所以<strong>存储的最小单位可以理解为字节。</strong> </p>
<p>2.bit是二进制数的一位包含的信息或2个选项中特别指定1个的需要信息量称为一比特，是表示信息的最小单位，只有两种状态：0和1。电脑内部的电路工作有高电平和低电平两种状态.所以就用二进制来表示信号，以便计算机识别。所以计算机能传输的最小单位当然是你信号的单位bit，而不是字节，串口最小也有一位传递的。另外数字信息流的基本单位是bit（比特），时间的基本单位是s（秒），因此bit/s（比特/秒）是描述带宽的单位，1bit/s是带宽的基本单位，所谓的带宽其实指的是传输速度的快慢，也就是指在一个固定的时间内（1秒），能通过的最大位数据。</p>
<p>地址线上是地址信息，一根地址线只能存储2种状态。32根地址线实际上能表示一个32位的二进制数，可以用32个二进制位来表示任意的内存地址或I/O端口地址。</p>
<p>寻址：当CPU<strong>请求数据时获得该数据在内存上的位置的过程</strong>。内存上存储的所有数据都会有一个可以区分的地址，这与其存放的位置相对应，当CPU请求数据时，内存中的电路会根据CPU的地址线上的信号利用数据总线向CPU返回数据。</p>
<p>那么内存是如何编码数据保存的位置的？这里涉及到上文所述的字节的概念。内存每一个存储位置的最小单元都可以储存0或1，即一个位的内容，而内存将8个位设定为一个存储空间的基本单位。而在地址线上每一个地址的编号便对应的是一个存储位置的最小的基本单位。</p>
<p>如何在地址线上用信号表示这个地址，这个问题引出了两个不同的寻址方式：按字节寻址和按字寻址。</p>
<p>如果有30条地址线，一共能表示2^30^ 个字节，能表示2^30^ </p>
<h4 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h4><p>容量大小</p>
<p>速度：</p>
<ul>
<li>存取时间t1<ul>
<li>访问时间（读出时间，写入时间）</li>
</ul>
</li>
<li>存取周期t2<ul>
<li>连续 两次 独立 的存储器操作</li>
<li>读或者写最小的时间间隔</li>
</ul>
</li>
</ul>
<p>t1&lt;t2</p>
<p>带宽 bps</p>
<h4 id="半导体存储芯片"><a href="#半导体存储芯片" class="headerlink" title="半导体存储芯片"></a>半导体存储芯片</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704214511866.png" alt="image-20240704214511866"></p>
<p>4条数据线意味着每个内存单元可以存储4个数据位（通常是4比特）。这意味着每个内存单元可以存储 24=162^4 = 1624=16 个不同的数据值。</p>
<table>
<thead>
<tr>
<th>地址线（单向）</th>
<th>数据线（双向）</th>
<th>芯片容量</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>4</td>
<td>1K*4bit</td>
</tr>
<tr>
<td>14</td>
<td>1</td>
<td>16K*1 bit</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>内存条上有很多芯片，不同的地址范围选的芯片也不一样 ，还有读写控制线</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704215706473.png" alt="image-20240704215706473"></p>
<h5 id="译码驱动"><a href="#译码驱动" class="headerlink" title="译码驱动"></a>译码驱动</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704220128452.png" alt="image-20240704220128452"></p>
<p>4位地址，共16个单元，8条控制线，一个单元是8位，所以存储空间是一个16*8位的矩阵，简单</p>
<p>0000 字线0号激活，0,0~0,7</p>
<p>缺点：线路密集</p>
<p>20个地址线，输出1M条线，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704220753043.png" alt="image-20240704220753043"></p>
<p>只有两边同时激活才能进行数据的输出，20个地址线，译码器输出只用2K条线。</p>
<h4 id="RAM-随机存取"><a href="#RAM-随机存取" class="headerlink" title="RAM 随机存取"></a>RAM 随机存取</h4><h5 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h5><p>保存0-1的原理：用双稳态触发器</p>
<p>六管静态RAM</p>
<h5 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704221726015.png" alt="image-20240704221726015"></h5><p>给出行选信号，列选信号，读有效</p>
<p>T6 T8 然后读出</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704222330938.png" alt="image-20240704222330938"></p>
<p>Intel 2114 读</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704223228647.png" alt="image-20240704223228647"></p>
<h5 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h5><p>保存0-1:电容（需要刷新）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704224121714.png" alt="image-20240704224121714"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704224306390.png" alt="image-20240704224306390"></p>
<p>刷新放大器对电容充电</p>
<p>放大器能够放大电容的电平</p>
<p>刷新和行地址有关，列地址无关</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704225313098.png" alt="image-20240704225313098"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704225840140.png" alt="image-20240704225840140"></p>
<p>刷新安排再指令译码阶段</p>
<h5 id="SRAM-VS-DRAM"><a href="#SRAM-VS-DRAM" class="headerlink" title="SRAM VS DRAM"></a>SRAM VS DRAM</h5><table>
<thead>
<tr>
<th></th>
<th>DRAM（主存）</th>
<th>SRAM（Cache）</th>
</tr>
</thead>
<tbody><tr>
<td>存储原理</td>
<td>电容</td>
<td>触发器</td>
</tr>
<tr>
<td>集成度</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>芯片引脚</td>
<td>少（行列分别传）</td>
<td>多</td>
</tr>
<tr>
<td>功耗</td>
<td>少</td>
<td>多</td>
</tr>
<tr>
<td>价格</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>刷新</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>速度</td>
<td>慢</td>
<td>快</td>
</tr>
</tbody></table>
<h4 id="ROM-只读存储器"><a href="#ROM-只读存储器" class="headerlink" title="ROM 只读存储器"></a>ROM 只读存储器</h4><p>MROM 掩膜ROM Uncustomizable</p>
<p>交叉处有无MOS管 有1无0</p>
<p>PROM 一次性编程 破坏性编程</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704230627923.png" alt="image-20240704230627923"></p>
<p>EPROM 多次 紫外线擦写</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704230734230.png" alt="image-20240704230734230"></p>
<p>EEPROM 支持局部擦写</p>
<p>FlashMemory </p>
<h4 id="存储器与CPU连接"><a href="#存储器与CPU连接" class="headerlink" title="存储器与CPU连接"></a>存储器与CPU连接</h4><h5 id="容量扩展"><a href="#容量扩展" class="headerlink" title="容量扩展"></a>容量扩展</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704231244644.png" alt="image-20240704231244644"></p>
<p>两个芯片共用地址线，输入1个十位的地址，2114内相同的地址单元能够同时各自输出自己储存的4位信息，重点：<strong>同时工作</strong> 片选同时激活</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704231832857.png" alt="image-20240704231832857"></p>
<p>11根地址线，多出来的一条用于控制片选，原来10根地址线共用，地址线的目的：每一个二进制数都要表示一个不同的存储单元 片选不同时工作</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704232318234.png" alt="image-20240704232318234"></p>
<p>原来10根地址线共用</p>
<h5 id="连接存储器与CPU"><a href="#连接存储器与CPU" class="headerlink" title="连接存储器与CPU"></a>连接存储器与CPU</h5><p>写出二进制地址码，确认芯片数量和类型，分配地址线，确定片选信号逻辑</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705131119849.png" alt="image-20240705131119849"></p>
<p>CPU-16根地址线-8根数据线</p>
<p>6000H 67FF为系统程序区 2K*8 11根 ROM</p>
<p>6800H 6BFFH为用户程序区 1K*8 10根 RAM</p>
<p>ROM选择2K*8 RAM选择1K*4的两个存储器进行位扩展</p>
<p>A10-A0 连接ROM A9-A0连接RAM</p>
<p>A13-A11 连接138 译码信号连到片选上 100-ROM 101-RAM </p>
<p>A14连到138的G1 A15连接到G2a</p>
<p>MREQ低电平访存控制信号连到G2b</p>
<p>（CPU访问内存，译码器必须工作）</p>
<p>地址要全部用上</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705131919043.png" alt="image-20240705131919043"></p>
<p>注意看 ROM2K空间利用充分，但是Y5和A10同时=0才算RAM空间</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705131758051.png" alt="image-20240705131758051"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705135723021.png" alt="image-20240705135723021"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705135733548.png" alt="image-20240705135733548"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705135742847.png" alt="image-20240705135742847"></p>
<p>错误处理</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705212942601.png" alt="image-20240705212942601"></p>
<p>低位交叉</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705213711855.png" alt="image-20240705213711855"></p>
<p>看清，是几体并行，4体并行就是低2位为译码器输入。</p>
<p>要求32K * 8 bit 给了4K * 4 bit的芯片 ， 低位交叉四体并行</p>
<p>4K 共12位地址线 需要芯片共16片，一般的做法是用2片4K*4进行位扩展，用8个这样的组合进行字扩展，高3位接译码器，但由于是要求低位4体并行的交叉编址，先用2片4K*4进行位扩展，然后用两组进行字扩展，最后用4个这样的组合进行字扩展。低2位接译码器</p>
<p>读写信号、MREQ、数据输出位D、地址线、片选使能（位扩展使能统一，字扩展看译码器输出）</p>
<h5 id="存储器校验"><a href="#存储器校验" class="headerlink" title="存储器校验"></a>存储器校验</h5><p>检测与纠错能力</p>
<h6 id="前导：奇偶校验"><a href="#前导：奇偶校验" class="headerlink" title="前导：奇偶校验"></a>前导：奇偶校验</h6><ul>
<li><p><strong>奇校验</strong>：如果数据单元中1的数量已经是奇数，则校验位设置为0；否则，校验位设置为1。如果出现错误，1的个数不再是奇数。</p>
<ul>
<li>假设数据单元为8位，并且使用奇校验：</li>
<li>数据 <code>10110011</code> 中有5个1，因此符合奇数要求，校验位为0。</li>
<li>数据 <code>11001010</code> 中有4个1，不符合奇数要求，校验位为1。</li>
</ul>
</li>
<li><p><strong>偶校验</strong>：如果数据单元中1的数量已经是偶数，则校验位设置为0；否则，校验位设置为1。如果出现错误，1的个数不再是偶数。</p>
</li>
<li><p><strong>校验过程</strong></p>
<p>发送方在数据末尾添加校验位，形成校验单元后发送。接收方收到数据后，重新计算校验位，并与接收到的校验位进行比对。如果两者相同，则认为数据传输正确；如果不同，则意味着在传输过程中出现了错误。</p>
</li>
</ul>
<p>2^k^≥n+k+1</p>
<p>K是纠错码位数，一共有2^k^种错误，</p>
<p>一位错，n+k+1</p>
<p>合法代码</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705140417990.png" alt="image-20240705140417990"></p>
<p> 编码最小距离：任意两个合法代码二进制位的最少差异数</p>
<p>L-1 = D+C</p>
<p>Length Detected Correction</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a493823882/article/details/109343791">汉明码使用</a> 校验位错了不用纠</p>
<h4 id="提高访存速度"><a href="#提高访存速度" class="headerlink" title="提高访存速度"></a>提高访存速度</h4><p>高速器件、层次结构(Cache)、<strong>调整主存结构</strong></p>
<h5 id="单体多字系统"><a href="#单体多字系统" class="headerlink" title="单体多字系统"></a>单体多字系统</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705210133859.png" alt="image-20240705210133859"></p>
<p>数据不连续会影响效率，4个字一起出来</p>
<h5 id="多体并行"><a href="#多体并行" class="headerlink" title="多体并行"></a>多体并行</h5><p><strong>高位交叉</strong>，</p>
<p>数据组织特点：相邻地址的数据处于同一存储体,一个地址寄存器,多模块串行（局部性原理）,性能无提升,扩充容量方便</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705210318229.png" alt="image-20240705210318229"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/b5ecff2b7ba843538f083126dfe59653-1720187489744-3.png" alt="b5ecff2b7ba843538f083126dfe59653"></p>
<p><strong>低位交叉</strong>，如果采用分时启动的方法，可以在不改变每个存储体存取周期的前提下，提高整个主存的速度</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705210508945.png" alt="image-20240705210508945"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705210704163.png" alt="image-20240705210704163"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/96e598788488485e97a03a8ff2059885-1720187482260-1.png" alt="96e598788488485e97a03a8ff2059885"></p>
<p>每个存储体均需地址寄存器,模M编址方式 多模块并行（局部性原理）,扩充容量也方便</p>
<p>低位交叉的好处：如果要连续读取，同一个访问周期内，存储器是不能进行下一步读取的，高位交叉会让同一个存储器占用过高，其他用不上，低位就解决了这个问题,流水线访问</p>
<h5 id="存储芯片"><a href="#存储芯片" class="headerlink" title="存储芯片"></a>存储芯片</h5><p>SDRAM 同步DRAM</p>
<p>RDRAM 解决带宽问题</p>
<p>Cache DRAM DRAM访问过的行存入cache 下一次先和这个行地址比较，一样的话直接把列地址输入cache 有利于猝发读取</p>
<h3 id="辅存"><a href="#辅存" class="headerlink" title="辅存"></a>辅存</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704232924331.png" alt="image-20240704232924331"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704233315282.png" alt="image-20240704233315282"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704233745159.png" alt="image-20240704233745159"></p>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>高速缓冲存储器，避免CPU空等现象</p>
<h4 id="程序访问的局部性原理"><a href="#程序访问的局部性原理" class="headerlink" title="程序访问的局部性原理"></a>程序访问的局部性原理</h4><p>时间的局部性：当前的数据，过一会还会用</p>
<p>空间的局部性：当前的数据，相邻的数据也会用</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705224559514.png" alt="image-20240705224559514"></p>
<p>按照块进行传送。 M&gt;&gt;C</p>
<p>命中：主存快调入缓存</p>
<p>命中率：与cache容量和块长有关</p>
<p>访问效率：</p>
<p>$e=\frac{访问\text{Cache时间}}{平均访问时间}$</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705225126490.png" alt="image-20240705225126490"></p>
<h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705225727823.png" alt="image-20240705225727823"></p>
<h4 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705225811853.png" alt="image-20240705225811853"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705225941275.png" alt="image-20240705225941275"></p>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>L1 L2 L3缓存</p>
<p>分离缓存 指令数据分离，冯氏结构统一</p>
<h4 id="Cache-主存的地址映射"><a href="#Cache-主存的地址映射" class="headerlink" title="Cache-主存的地址映射"></a>Cache-主存的地址映射</h4><p>方式和级数有关</p>
<h5 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h5><p>xx<strong>x只能装到cache的某一确定</strong>的位置，即使Cache的其他许多地址空着也不能占用，这使得直接映射的块冲突概率最高，空间利用率最低。vmax</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705230901918.png" alt="image-20240705230901918"></p>
<p>主存块号的低𝑐位正好是它要装入的Cache行号。给每个Cache行设置一个长为𝑡=𝑚−𝑐的标记(tag),当主存某块替换进Cache后，就将其块号标记位设置在对应Cache行的标记中</p>
<h5 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h5><p>主存中的每一块可以装入Cache 中的<strong>任何</strong>位置，每行的标记用于指出该行取自主存的哪一块，所以CPU访存时需要与所有Cache行的标记进行比较。全相联映射方式的优点是比较灵活，Cache 块的冲突概率低，空间利用率高，命中率也高;缺点是标记的比较速度较慢，实现成本较高，通常需采用昂贵的按内容寻址的相联存储器进行地址映射 vmin</p>
<h5 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a><strong>组相联映射</strong></h5><p><strong>组内全相联 组外直接映射</strong></p>
<p>确定组号之后再确定区号，0和2^c-r^ 2^c-r+1^ 都在第0组，组内采用字块号一一对应的方法<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/20210713154218.png" alt="20210713154218"></p>
<h4 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h4><p>Cache满就要替换栈</p>
<h5 id="FIFO-First-in-first-out"><a href="#FIFO-First-in-first-out" class="headerlink" title="FIFO(First in first out)"></a>FIFO(First in first out)</h5><p>先进先出，违反程序局部性原则</p>
<h5 id="LRU-Last-recently-used"><a href="#LRU-Last-recently-used" class="headerlink" title="LRU(Last recently used)"></a>LRU(Last recently used)</h5><p>近期最少使用</p>
<h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><h3 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h3><p>早期：分散连接，串行工作</p>
<p>接口模块和DMA阶段：总线连接，并行工作（中断/DMA）</p>
<p>通道结构阶段：有自己的简单处理器</p>
<p>I/O处理机阶段：高性能微处理器</p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705235621421.png" alt="image-20240705235621421"  />

<h4 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h4><p>接口\设备</p>
<h4 id="外部设备"><a href="#外部设备" class="headerlink" title="外部设备"></a>外部设备</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706002820937.png" alt="image-20240706002820937"></p>
<p>键盘鼠标显示器，A/D D/A 模数转换，终端，汉字处理。</p>
<h4 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I/O接口"></a>I/O接口</h4><p>选择设备，数据缓冲匹配速度，串并格式转换，电平转换，传送命令</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706121949206.png" alt="image-20240706121949206"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706122640491.png" alt="image-20240706122640491"></p>
<h3 id="主机与I-O的联系方式"><a href="#主机与I-O的联系方式" class="headerlink" title="主机与I/O的联系方式"></a>主机与I/O的联系方式</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705235948953.png" alt="image-20240705235948953"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706000234331.png" alt="image-20240706000234331"></p>
<p> (3)必须要有统一的时间标准</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706000359748.png" alt="image-20240706000359748"></p>
<h3 id="主机与I-O的信息传送控制"><a href="#主机与I-O的信息传送控制" class="headerlink" title="主机与I/O的信息传送控制"></a>主机与I/O的信息传送控制</h3><h4 id="通道方式、IO处理器方式"><a href="#通道方式、IO处理器方式" class="headerlink" title="通道方式、IO处理器方式"></a>通道方式、IO处理器方式</h4><h4 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706000830237.png" alt="image-20240706000830237"></p>
<p>完全由主机执行程序实现，等待数据准备的过程CPU会空转，一直查询状态，串行工作</p>
<p>查询的程序嵌入CPU</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706140313041.png" alt="image-20240706140313041"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706142641037.png" alt="image-20240706142641037"></p>
<h4 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706001125217.png" alt="image-20240706001125217"></p>
<p>会暂停现行程序 ，部分并行工作。中断会影响正常的程序处理，为了恢复CPU仍然要消耗资源，执行中断服务程序</p>
<h5 id="I-O形成中断请求过程"><a href="#I-O形成中断请求过程" class="headerlink" title="I/O形成中断请求过程"></a>I/O形成中断请求过程</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706001442993.png" alt="image-20240706001442993"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706141207557.png" alt="image-20240706141207557"></p>
<ol>
<li>中断请求触发器+中断屏蔽触发器</li>
</ol>
<p>先决条件：MASK = 0 中断未被屏蔽 + 设备本身已经准备好数据了 -&gt; INTR = 1 设备发出中断请求  </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706141710467.png" alt="image-20240706141710467"></p>
<ol start="2">
<li>排队器</li>
</ol>
<p>分为<strong>软件</strong>和<strong>硬件</strong>方式</p>
<p>硬件：链式排队器</p>
<p>优先级最高的没有请求，$\overline {INTP’}$=1，$\overline {INTR}$=1，会导致这些优先级高、无请求的$\overline {INTP’}$=1，低优先级的来了请求，$\overline {INTR}$=0，就会让之后的$\overline {INTP’}$=0, 此时之后的$\overline {INTP’}$都对之后的与非门起了决定性作用，也就是优先级更低的全部禁用。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706145002524.png" alt="image-20240706145002524"></p>
<p>$\overline {INTP’}$，$ {INTR}$全部为1才能发出真正的中断指令INTP</p>
<ol start="3">
<li>中断向量地址形成部件（编码器）</li>
</ol>
<p>不同的设备中断服务程序不同，每一个服务程序都有一个入口地址，CPU要找到这些入口就必须对这些地址进行编码，输入是经过排队器综合以后的中断信号INTP，输出是中断向量（二进制码）仅仅是就这些输入编的码，还要将中断向量地址和存储的中断对应设备的服务程序一一对应，中断向量地址处保存的是服务程序的入口地址的地址</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706154548716.png" alt="image-20240706154548716"></p>
<ol start="4">
<li>接口电路</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706154757761.png" alt="image-20240706154757761"></p>
<h5 id="中断执行过程"><a href="#中断执行过程" class="headerlink" title="中断执行过程"></a>中断执行过程</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706161105095.png" alt="image-20240706161105095"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706212237016.png" alt="image-20240706212237016"></p>
<p>中断请求、中断判优、中断响应、中断服务、中断返回</p>
<p>CPU会在统一的时间，即每条指令执行阶段的最后时刻，进行<strong>中断查询</strong></p>
<p>设备只要准备好了(D=1)并且没有被屏蔽(MASK=0)，查询信号(相当于D触发器的clk信号)就会使得输出INTR=1，此时请求INTR=1也会被送到排队器进行<strong>判优</strong>，</p>
<p>随后CPU根据判优结果进行响应，如果排队选中并且EINT=1，进行CPU的<strong>中断响应</strong> </p>
<ul>
<li>响应条件<ul>
<li>中断源有中断请求, INTR=1 </li>
<li>开中断，使 EINT=1</li>
<li>一条指令执行完毕，且没有更紧迫的任务</li>
</ul>
</li>
</ul>
<p>通过INTR信号线发出的外中断是可屏蔽中断 ，在关中断（EINT=0）的情况下不会被响应</p>
<p>I/O设备的就绪时间是随机的，而CPU在统一的时刻即每条指令执行阶段结束前向接口发出中断查询信号，以获取I/O 的中断请求，也就是说，CPU响应中断的时间是在每条指令执行阶段的结束时刻。这里说的中断仅指外中断，内中断不属于此类情况。</p>
<p><strong>响应</strong>时，先由INTA<del>cknowledge</del>=1激活设备编码器：将排队结果发到编码器，生成向量地址，向量本身是JMP TO  200, 向量地址是JMP TO 200 的地址</p>
<p>根据向量地址进行开始<strong>运行服务程序</strong> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706170143933.png" alt="image-20240706170143933"></p>
<p>多重中断的流程</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706172054097.png" alt="image-20240706172054097"></p>
<p>1-3由隐指令完成，单重中断：直到恢复完现场才开中断。多重中断允许嵌套，必须满足下列条件:①在中断服务程序中提前设置开中断②优先级别高的中断源有权中断优先级别低的中断源。</p>
<p>假如D&gt;A&gt;C&gt;B，源A执行中，D来了就要中断A去执行D。每个中断源都有一个 屏蔽触发器屏蔽触发器 ，1 表示 屏蔽该中断源屏蔽该中断源 的请求，0 表示可以 正常申请正常申请 ，所有屏蔽触发器组合在一起便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字。D的屏蔽字是1111，具有最高优先级，A是1110次之，以此类推</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706170847647.png" alt="image-20240706170847647"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706171244016.png" alt="image-20240706171244016"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706171245893.png" alt="image-20240706171245893"></p>
<p>屏蔽技术</p>
<p>屏蔽触发器和屏蔽字：程序中断接口电路中，完成触发器D，中断请求触发器INTR和屏蔽触发器MASK。</p>
<p>当中断源被屏蔽时（MASK=1），此时即使D=1，中断查询信号到来时刻只能将INTR置“0”，CPU接收不到该中断源的中断请求，即它被屏蔽。</p>
<p>若该中断源未被屏蔽（MASK=0）当设备工作已完成时（D=1），中断查询信号则将INTR置“1”，表示该中断源向CPU发出中断请求，该信号送至排队器进行优先级判断。显然，对于每个中断请求触发器就有一个<strong>屏蔽触发器</strong>，将所有屏蔽触发器组合在一起，便构成了一个<strong>屏蔽寄存器</strong>。屏蔽寄存器的内容称为<strong>屏蔽字</strong>。屏蔽字与中断源的优先级是一一对应的。</p>
<p>屏蔽技术可改变优先等级：严格地说，优先级包含<strong>响应优先级</strong>和<strong>处理优先级</strong>。响应优先级是指CPU响应各中断源请求的优先次序，这种次序往往是硬件线路已设置好的，不便于改动。处理优先级是指CPU实际对各中断源请求的处理优先次序。如果不采用屏蔽技术，响应的优先次序就是处理的优先次序。</p>
<p>eg. 响应L1&gt;L2&gt;L3&gt;L4 处理反过来</p>
<p>几个中断源同时提出中断请求，L1首先响应，开始执行，但是被L2打断，L2开始执行，被L3打断，之后L3被L4打断，L4执行完继续执行L3</p>
<p>ABCD由设备识别电路，A能将</p>
<h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><p><strong>I/O direct to Memory</strong></p>
<p><strong>D</strong>irect <strong>M</strong>emory <strong>A</strong>ccess</p>
<h5 id="DMA方式的特点"><a href="#DMA方式的特点" class="headerlink" title="DMA方式的特点"></a>DMA方式的特点</h5><ul>
<li><p>在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。</p>
</li>
<li><p>主存中要开辟专用缓冲区，及时供给和接收外设的数据。</p>
</li>
</ul>
<h6 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h6><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706172851691.png" alt="image-20240706172851691"></p>
<p>CPU不参与</p>
<h6 id="与主存交换数据方式"><a href="#与主存交换数据方式" class="headerlink" title="与主存交换数据方式"></a>与主存交换数据方式</h6><ol>
<li><p>停止CPU对主存的访问。不能充分发挥CPU对主存的利用率。<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706173212015.png" alt="image-20240706173212015"></p>
</li>
<li><p>窃取周期。存取周期内CPU不能通过总线对内存进行访问，然而CPU指令执行并不是一条条取的，而是预取。并行工作。</p>
<p>CPU未占用总线,DMA/CPU正在占用总线,CPU/DMA、CPU同时发起占用总线的请求，DMA<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706174016933.png" alt="image-20240706174016933"></p>
</li>
<li><p>交替访问 一个原周期分为DMA周期和CPU周期<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706173952420.png" alt="image-20240706173952420"></p>
</li>
</ol>
<h5 id="接口-DMA控制器"><a href="#接口-DMA控制器" class="headerlink" title="接口/DMA控制器"></a>接口/DMA控制器</h5><h6 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h6><p>DMA申请总线控制权/CPU移交总线控制权/DMA管理总线控制传输数据, 确定数据传送首地址和长度, 对传输过程中的数据进行修正/DMA发出操作完成信号</p>
<h6 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h6><p><u>字</u>计数器<strong>W</strong>ord<strong>C</strong>ounter</p>
<p><u>主存地址</u>寄存器<strong>A</strong>ddress<strong>R</strong>egister</p>
<p><u>数据缓冲</u>寄存器<strong>B</strong>uffer<strong>R</strong>egister</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706180228563.png" alt="image-20240706180228563"></p>
<h5 id="传输过程"><a href="#传输过程" class="headerlink" title="传输过程"></a>传输过程</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706180723685-1720260754514-3.png" alt="image-20240706180723685"></p>
<h6 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h6><p>预处理就是CPU的I/O指令</p>
<p>CPU完成准备工作：首先，CPU执行几条I/O 指令，用以测试I/O设备状态，向 DMA 控制器的有关寄存器置初值、设置传送方向、启动该设备等。然后，CPU继续执行原来的程序，直到I/O设备准备好发送的数据（输入情况）或接收的数据（输出情况）时，I/O设备向DMA控制器发送DMA请求，再由DMA控制器向CPU 发送总线请求（有时将这两个过程统称为DMA请求），用以传输数据。</p>
<h6 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h6><p>传输可以用byte/word为基本单位，也可用block作为基本单位，对于以数据块为单位的传送（如硬盘），DMA占用总线后的数据输入和输出操作都是通过循环来实现的。需要指出的是，这一循环也是由 DMA 控制器（而非通过CPU执行程序）实现的，即数据传送阶段完全由DMA（硬件）控制。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706181444755.png" alt="image-20240706181444755"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706181559135.png" alt="image-20240706181559135"></p>
<p>WC(Word Counter)溢出会发中断请求INTR给中断机构</p>
<h6 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h6><p>DMA控制器向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理，包括**<u>校验</u>送入主存的数据是否正确<strong>、测试传送过程中是否出错（错误则转入诊断程序）及决定是否继续使用DMA传送其他数据块等，</strong>由中断服务程序完成** </p>
<h5 id="DMA和系统连接方式"><a href="#DMA和系统连接方式" class="headerlink" title="DMA和系统连接方式"></a>DMA和系统连接方式</h5><p>公共总线 串联</p>
<p>独立DMA请求 并联</p>
<h5 id="DMA接口类型"><a href="#DMA接口类型" class="headerlink" title="DMA接口类型"></a>DMA接口类型</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706183458104.png" alt="image-20240706183458104"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706183609988.png" alt="image-20240706183609988"></p>
<p>优先级：速度优先</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706184002042.png" alt="image-20240706184002042"></p>
<h4 id="三种方式辨析"><a href="#三种方式辨析" class="headerlink" title="三种方式辨析"></a>三种方式辨析</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706001545500.png" alt="image-20240706001545500"></p>
<h5 id="DMA方式和中断方式的区别"><a href="#DMA方式和中断方式的区别" class="headerlink" title="DMA方式和中断方式的区别"></a>DMA方式和中断方式的区别</h5><ol>
<li>中断方式是程序的切换，需要保护和恢复现场;而DMA方式除了预处理和后处理，其他时候不占用CPU的任何资源。</li>
<li>对中断请求的响应只能发生在每条指令执行完毕时（即指令的执行周期后）;而对DMA请求的响应可以发生在每个机器周期结束时（存储周期、取指周期、间址周期、执行周期后均可），只要CPU不占用总线就可被响应。</li>
<li>中断传送过程需要CPU的干预;而 DMA传送过程不需要CPU 的干预，因此数据传输率非常高，适合于高速外设的成组数据传送。</li>
<li>DMA请求的优先级高于中断请求。</li>
<li>中断方式的中断请求以传送数据的方式，DMA是以后处理的方式</li>
<li>中断方式具有对异常事件的处理能力，而DMA方式仅局限于传送数据块的I/O操作。</li>
<li>从数据传送来看，中断方式靠程序传送，DMA方式靠硬件传送。</li>
</ol>
<h4 id="易混淆点"><a href="#易混淆点" class="headerlink" title="易混淆点"></a>易混淆点</h4><p>向量中断、中断向量、向量地址</p>
<ul>
<li>向量中断：用来识别中断源的方式，能够找到对应的中断服务程序的入口地址，即向量地址</li>
<li>向量地址：向量表中每一项的地址，中断服务程序的入口地址</li>
<li>中断服务程序：中断源对应的处理程序</li>
<li>中断向量：中断服务程序的入口地址/中断服务程序的跳转指令</li>
<li>中断向量地址：中断向量的地址</li>
</ul>
<p>中断服务程序、子程序</p>
<ul>
<li>中断服务程序：时间不固定，跟主程序无关，需要另外的硬件电路，嵌套级数完全由中断优先级来决定</li>
<li>子程序：时间固定可预知，和主程序息息相关，为主程序服务，不需要额外硬件，嵌套级数由内存堆栈大小限制决定</li>
</ul>
<p>中断响应优先级、中断处理优先级</p>
<ul>
<li>中断响应优先级：由硬件排队器或中断查询程序的查询顺序决定</li>
<li>中断处理优先级：由中断屏蔽字来改变，反映的是正在处理的中断是否比新发生的中断的处理优先级低（屏蔽位为“0”，对新中断开放），若是，则中止正在处理的中断，转到新中断去处理，处理完后再回到刚才被中止的中断继续处理。</li>
</ul>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/13/408-%E8%AE%A1%E7%BB%84-Link/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/13/408-%E8%AE%A1%E7%BB%84-Link/" class="post-title-link" itemprop="url">符号链接</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-13 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-13T00:00:00+08:00">2024-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 12:43:29" itemprop="dateModified" datetime="2025-05-05T12:43:29+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">计组</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>文本：源代码 <code>hello.c</code></p>
<p>预处理：修改文本 <code>hello.i file</code></p>
<p>编译器：assembly <code>hello.s file</code></p>
<p>汇编器：binary code <code>hello.o file</code></p>
<p>连接器：hello.o + printf.o -&gt; <code>hello</code> </p>
<p><strong>线程级并行</strong>：指令执行基本单位</p>
<ul>
<li><p>多核心：多个核共享L3缓存，一个核有一个统一的L2缓存，L1缓存分为数据缓存和指令缓存，数据缓存直连CPU寄存器</p>
</li>
<li><p>超线程：可以在单个周期内决定要切换到哪个线程，在一个线程等待数据运过来的过程中，CPU可以去转而执行另一个线程，8核心 16线程，线程并行</p>
</li>
</ul>
<p><strong>指令级并行</strong>：指令间并行</p>
<ul>
<li>流水线</li>
<li>超标量</li>
</ul>
<p>单指令，多数据并行：数据流并行 SIMD 一条指令可以产生多个并行执行的操作</p>
<p>抽象：Disk 代表I/O设备，Memory代表主存</p>
<ul>
<li>Virtual Machine：OS+CPU+Memory+Disk</li>
<li>Process： CPU+Memory+Disk</li>
<li>Virtual Memory：Memory+Disk</li>
<li>File：Disk</li>
<li>CPU：Instruction Set architecture</li>
</ul>
<h1 id="Linker"><a href="#Linker" class="headerlink" title="Linker"></a>Linker</h1><h2 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h2><p>“目标文件是字节块的集合”这句话通常用来描述目标文件（object file）的本质结构。目标文件是编译器生成的中间文件，包含程序代码和数据，用于后续的链接操作。以下是对这一概念的详细解析：</p>
<h3 id="目标文件的本质：字节块"><a href="#目标文件的本质：字节块" class="headerlink" title="目标文件的本质：字节块"></a>目标文件的本质：字节块</h3><p>目标文件是由一系列字节组成的文件，这些字节可以看作是数据块。这些数据块并不是随意排列的，而是按照一定的格式组织起来，通常包括：</p>
<ul>
<li><strong>代码段</strong>：存储编译后的机器指令。</li>
<li><strong>数据段</strong>：存储已初始化的全局或静态变量。</li>
<li><strong>未初始化数据段（BSS）</strong>：存储未初始化的全局或静态变量，实际大小记录在文件中，但不占用物理空间。</li>
<li><strong>符号表</strong>：记录函数和变量的名字及其在文件中的位置。</li>
<li><strong>重定位信息</strong>：指示链接器如何修改目标文件以适应最终的内存布局。</li>
</ul>
<p>这些内容本质上都是字节序列，每一部分由多个字节块组成。</p>
<hr>
<h3 id="字节块的特点"><a href="#字节块的特点" class="headerlink" title="字节块的特点"></a>字节块的特点</h3><ul>
<li><strong>固定大小或可变大小</strong>：字节块可以是固定长度的单位，例如4字节对齐的机器指令，也可能是不定长的数据块。</li>
<li><strong>有意义的分组</strong>：每个块都有明确的意义，比如某个函数的机器代码、某个变量的初始值等。</li>
<li><strong>易于解析</strong>：链接器、调试器等工具需要能够根据文件的格式解析这些块，因此这些字节块被有序地组织在文件头定义的布局中。</li>
</ul>
<hr>
<h3 id="目标文件格式"><a href="#目标文件格式" class="headerlink" title="目标文件格式"></a>目标文件格式</h3><p>目标文件的格式是如何定义这些字节块的重要规则。例如：</p>
<ul>
<li><strong>ELF（Executable and Linkable Format）</strong> 是一种常见的目标文件格式，广泛用于Linux系统。它将字节块分为不同的段（Section），并用段表和符号表记录每个块的起始地址和大小。</li>
<li><strong>COFF（Common Object File Format）</strong> 是Windows等系统常用的格式。</li>
</ul>
<p>这些格式提供了语法规则，使得目标文件的字节块能够被链接器或加载器正确地解读。</p>
<hr>
<h3 id="为什么强调“字节块的集合”？"><a href="#为什么强调“字节块的集合”？" class="headerlink" title="为什么强调“字节块的集合”？"></a>为什么强调“字节块的集合”？</h3><ul>
<li><strong>通用性</strong>：这一描述抽象了目标文件的存储本质。无论是代码段还是数据段，本质上都是按字节存储的数据。</li>
<li><strong>便于理解文件结构</strong>：将目标文件看作字节块集合，可以帮助程序员理解文件的解析方式，特别是分析目标文件格式时。</li>
<li><strong>与内存映射相关</strong>：最终，这些字节块会被加载到内存中，按照相同的结构组织成进程的内存布局。</li>
</ul>
<hr>
<h3 id="深入理解的关键"><a href="#深入理解的关键" class="headerlink" title="深入理解的关键"></a>深入理解的关键</h3><p>为了深入理解，可以通过以下方式进一步探索：</p>
<ul>
<li><strong>查看目标文件结构</strong>：使用工具（如 <code>objdump</code> 或 <code>readelf</code>）解析目标文件，观察各部分的字节分布。</li>
<li><strong>编写简单的C程序并编译</strong>：用编译器生成目标文件，并对比源代码和目标文件中的符号表、代码段。</li>
<li><strong>了解链接过程</strong>：理解这些字节块如何在链接过程中被组合成最终的可执行文件。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>编写简单的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译生成目标文件后，使用 <code>readelf -a</code> 或 <code>objdump -h</code> 查看其字节块分布。你会发现，虽然程序非常简单，但目标文件已经按照格式组织了各种段和数据块。</p>
<h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><p><strong>符号解析</strong>是链接过程中一个重要的步骤，用于将目标文件中的符号（如变量名、函数名）解析为具体的内存地址或其他符号的引用地址。它的目的是将代码中使用的符号与其定义进行匹配，以实现正确的程序连接。</p>
<p>以下是详细的解释：</p>
<hr>
<h3 id="什么是符号？"><a href="#什么是符号？" class="headerlink" title="什么是符号？"></a><strong>什么是符号？</strong></h3><p>符号是程序中用来表示变量、函数、常量或其他标识符的名字。它可以包括：</p>
<ul>
<li>全局变量</li>
<li>函数名</li>
<li>静态变量（如果需要）</li>
<li>外部引用的符号（来自其他目标文件或库）</li>
</ul>
<p>在目标文件中，这些符号并不直接对应内存地址，而是保存在<strong>符号表</strong>中，等待链接器解析。</p>
<hr>
<h3 id="符号解析的作用"><a href="#符号解析的作用" class="headerlink" title="符号解析的作用"></a><strong>符号解析的作用</strong></h3><p>符号解析的主要目的是：</p>
<ul>
<li>将<strong>使用符号的地方</strong>（例如函数调用或变量访问）和<strong>定义符号的地方</strong>联系起来。</li>
<li>为符号分配实际的内存地址或引用其他文件中符号的位置。</li>
</ul>
<p>如果符号在当前目标文件中找不到定义，链接器会尝试在其他目标文件或库中找到它。</p>
<hr>
<h3 id="符号解析的过程"><a href="#符号解析的过程" class="headerlink" title="符号解析的过程"></a><strong>符号解析的过程</strong></h3><ol>
<li><p><strong>构建符号表</strong>：链接器首先扫描所有目标文件和库文件，读取它们的符号表，记录所有已定义和未定义的符号。</p>
</li>
<li><p>查找符号定义</p>
<p>：对于每个未定义的符号，链接器会在符号表中搜索其定义。</p>
<ul>
<li>如果找到，链接器会将引用符号的位置更新为定义的位置。</li>
<li>如果找不到，链接器会报错（如“未定义符号”错误）。</li>
</ul>
</li>
<li><p><strong>处理重定位信息</strong>：对于解析后的符号，链接器会根据其地址调整目标文件中的指令或数据。</p>
</li>
</ol>
<hr>
<h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a><strong>常见场景</strong></h3><ul>
<li><strong>内部符号解析</strong>：在同一个目标文件中，一个函数调用另一个函数，链接器只需在这个目标文件内找到符号的定义。</li>
<li><strong>外部符号解析</strong>：一个目标文件调用另一个目标文件或库中的符号，链接器需要跨文件查找。</li>
<li><strong>动态库中的符号解析</strong>：如果链接的是动态库（如 <code>.so</code> 或 <code>.dll</code> 文件），符号解析可能延迟到程序运行时进行。</li>
</ul>
<hr>
<h3 id="符号解析失败的原因"><a href="#符号解析失败的原因" class="headerlink" title="符号解析失败的原因"></a><strong>符号解析失败的原因</strong></h3><p>符号解析失败通常会导致编译或链接错误，比如：</p>
<ul>
<li>未定义符号错误：<ul>
<li>函数或变量的定义缺失。</li>
<li>链接时遗漏了需要的库。</li>
</ul>
</li>
<li>重复定义错误：<ul>
<li>同一个符号在多个目标文件中重复定义。</li>
</ul>
</li>
<li>符号不可见：<ul>
<li>符号被声明为 <code>static</code> 或其他方式限制了可见性，导致无法被外部文件引用。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="符号解析工具"><a href="#符号解析工具" class="headerlink" title="符号解析工具"></a><strong>符号解析工具</strong></h3><p>在实际开发中，可以使用一些工具检查符号：</p>
<ul>
<li><code>nm</code>：列出目标文件或库中的符号表。</li>
<li><code>objdump</code>：查看符号和段信息。</li>
<li><code>readelf</code>：分析目标文件的 ELF 格式符号。</li>
</ul>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm myfile.o</span><br></pre></td></tr></table></figure>

<p>会输出目标文件 <code>myfile.o</code> 中的所有符号及其状态（已定义或未定义）。</p>
<hr>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h3><p>假设有以下代码：</p>
<p>**文件 <code>a.c</code>**：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> foo = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<p>**文件 <code>b.c</code>**：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> foo;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>编译</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c a.c -o a.o</span><br><span class="line">gcc -c b.c -o b.o</span><br></pre></td></tr></table></figure>

<ul>
<li><code>a.o</code> 中定义了符号 <code>foo</code>。</li>
<li><code>b.o</code> 中引用了符号 <code>foo</code>（标记为未定义）。</li>
</ul>
</li>
<li><p><strong>链接</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc a.o b.o -o program</span><br></pre></td></tr></table></figure>

<ul>
<li>链接器会解析 <code>b.o</code> 中的符号 <code>foo</code>，在 <code>a.o</code> 中找到它的定义，并完成解析。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>符号解析是链接器将程序中的符号引用与定义匹配起来的关键步骤。它确保程序在执行时能够正确访问函数、变量等资源。符号解析的成功与否直接影响程序的正确性，开发中需要注意符号的定义与使用是否一致，以及是否正确链接所需的目标文件或库。</p>
<ul>
<li><code>switch</code>性能是否总是比<code>if-else</code>好？</li>
<li>一个函数调用的开销有多大？</li>
<li><code>while</code>性能是否总是比<code>for</code>好？</li>
<li>指针引用比数组索引更加有效吗？</li>
<li>为什么将循环求和的结果放到本地变量中，比放到一个通过引用传递过来的参数中更加有效？</li>
<li>为什么只是简单将算数表达式中的括号进行重排就能加快运行速度？</li>
</ul>
<p>链接的错误：</p>
<ul>
<li>静态变量与全局变量的区别</li>
<li>不同C文件中定义相同的全局变量</li>
<li>静态库和动态库的区别</li>
<li>命令行上排列库的顺序有什么影响</li>
<li>为什么有些链接错误直到运行时才会出现？</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/13/408-%E8%AE%A1%E7%BB%84-Cache%20%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D%20HDD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/13/408-%E8%AE%A1%E7%BB%84-Cache%20%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D%20HDD/" class="post-title-link" itemprop="url">cache、先行进位、hdd</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-13 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-13T00:00:00+08:00">2024-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:56:48" itemprop="dateModified" datetime="2025-05-05T11:56:48+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">计组</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><p>磁道数⇔柱面数</p>
<p>数据传输率 = 单磁道容量 * 转速</p>
<p>单磁盘容量 = 有效盘面数 * 磁道数 * 单磁道容量 </p>
<p>​           = 有效盘面数 * 磁道数 * 扇区数 * 单扇区容量 </p>
<p>平均读取时间 = 平均寻道时间 + 平均寻找扇区时间（0.5T）+ 其他延迟时间 + 传输时间(比如<strong>读取一个扇区的时间 = 读取一个磁道的时间即1/r / 扇区数</strong>  或者 <strong>1s传20MB，那么读取一个4KB的扇区时间=4K*1s/20M</strong>)</p>
<p> 寻道时间一般不变，找扇区时间以及传输时间和转速挂钩。</p>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>主存物理地址</p>
<p>第一块</p>
<blockquote>
<p>00000000</p>
<p>00000001</p>
<p>00000010</p>
<p>00000011</p>
</blockquote>
<p>第二块</p>
<blockquote>
<p>00000100</p>
<p>00000101</p>
<p>00000110</p>
<p>00000111</p>
</blockquote>
<p>前六位是块号，每块有四个地址，所以要用最后2位来表示块内地址（这个单元位于块的哪个部分）高位全部是块号</p>
<p>块内地址位数的确定：必须要直到一个块内有多少个地址，比如说一个块16个字，每个字4 Byte，按字编址就是16个，需要4位表示块内地址，按字节编址就是64个，需要6位来给块内地址</p>
<p>一块就对应cache一行（一块）</p>
<p>一块一块交换，所以最终是要核对cache中的块号。</p>
<p>写回法，CPU将cache作为目标存储器，写完如果脏位有效才写回主存</p>
<p>写通/写穿，CPU将cache和主存同时写入，如果cache不命中就先写完主存，再从主存写cache</p>
<p>主存物理地址 = 标记tag+ cache地址</p>
<p>cache地址 = 行号/组号/无 + 块内地址</p>
<p>cache行内容 = 标记区 + 数据区</p>
<p>cache地址映射表 = cache标记区</p>
<p>cache标记区 = 有效位1bit + 主存标记tag +（脏位(写回策略)1bit + 替换控制位）</p>
<p>cache数据区大小 = 块容量 一块4B……</p>
<h3 id="全相联"><a href="#全相联" class="headerlink" title="全相联"></a>全相联</h3><p>直接一位一位核对块号（tag） </p>
<p>优点：存储块可以放到cache的任意一行，空间利用率高</p>
<p>缺点：查找时间可以很长</p>
<h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p>指定1行Cache，只能存间隔固定的存储单元，比如第0行cache只能存每一个区的第0块</p>
<p>优点：查找速度快</p>
<p>缺点：存储块只能放到某一个固定的行，空间利用率低</p>
<p>要知道cache的行数，根据行数确定行号占位，然后再核对剩下的tag内容</p>
<p>如果cache共16行，直接节省了16倍的时间 行号占4位</p>
<h3 id="组相联"><a href="#组相联" class="headerlink" title="组相联"></a>组相联</h3><p>指定某几行Cache，只能存间隔固定的存储单元，比如第0行cache可以存每一个区的第0，2,4，8，是前两种的折中，</p>
<p>如果cache共16行，4路组相联，4个组 组号占2位，节省了4倍时间</p>
<p>先确定组号然后核对tag和有效位，tag匹配，有效位为1即为命中</p>
<h3 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h3><p>cache行数128，在主存中有102个字，8字为一个块，重复按照0-101顺序读10次，一下读一个字，命中率？</p>
<p>先到cache里寻找，一定是先核对组号和tag内容，再根据块内地址找，0-101分成13块，第一次先核对tag，没有对的上的，所以只需要13次没命中。</p>
<p>第二次，cache已经写入了102个字的内容，并且分块分组保存，先核对tag中的组号，发现能对的上，然后核对tag，块内地址，算命中。</p>
<p>总命中次数 102*10-13 得命中率为98.7%</p>
<h2 id="双重分组跳跃进位加法链-ALU"><a href="#双重分组跳跃进位加法链-ALU" class="headerlink" title="双重分组跳跃进位加法链 ALU"></a>双重分组跳跃进位加法链 ALU</h2><h3 id="小组内先行进位"><a href="#小组内先行进位" class="headerlink" title="小组内先行进位"></a>小组内先行进位</h3><p>已知d3-d0, t3-t0, C<del>-1</del>  同时产生C3-C0 DT也能同时产生 耗时2.5t<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240711163217501.png" alt="image-20240711163217501"></p>
<p>缺点：每组要工作都要知道自己的进位输入位，<strong>不能同时知道自己的进位输入位</strong> </p>
<p>16bit 耗时10t（产生C15-C0的时间）</p>
<p>典型的先行进位4位加法器能够同时产生DT,C3-C0</p>
<h4 id="小组间先行进位"><a href="#小组间先行进位" class="headerlink" title="小组间先行进位"></a>小组间先行进位</h4><p>(只要知道组内dt情况就能立即给出DT，C3-C0)</p>
<p>如果能让他们同时知道自己的进位输入位就能节省时间，此时最高位产生的逻辑只需要知道C<del>-1</del> </p>
<p>已知DT就能马上给出所有最高进位 耗时2.5t ，但是要先得出DT才行，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240711163153788-1720686897748-1.png" alt="image-20240711163153788"></p>
<p>16bit 耗时5t（产生C15-C0的时间）</p>
<p><u>逻辑：同时产生每个组的DT和前三个进位输出，然后再同时产生每个组的最高位进位输出。</u></p>
<p>同时产生每个组的DT和前三个进位输出，倒是也可以同时产生C3，但是此时C3是根据C<del>-1</del> 产生的，后边的C7C11C15要化成C3的形式才能同时产生，反正都是分两步，索性让他们四个按照相同的逻辑产生。</p>
<p>总结，要让DT起作用，就要先知道DT才行，然后让最高位按照统一的逻辑生成。</p>
<h4 id="MSI-ALU"><a href="#MSI-ALU" class="headerlink" title="MSI_ALU"></a>MSI_ALU</h4><p>74182(CLA Generator):Cmin，4DT———3Cout ，D*T* （4个小组）（1个大组） 16bit </p>
<p>74181(4bit CLA Adder):Cmin，4dt——— Cmax，1DT  （1个小组）4bit </p>
<p>4*74181+1*182 = 输入dt，Cmin，到74181和74182，输出D*T*，和4个组最终的进位输出</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240711174412643.png" alt="image-20240711174412643"></p>
<p>74182: 输入Cmin，4D*T*，  输出Cmax、 D**T**（4个大组） 64bit</p>
<p>(4*74181+1*74182)*4 + 1*74182 = 64位 三重分组跳跃进位ALU </p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/13/jvm-classfile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/13/jvm-classfile/" class="post-title-link" itemprop="url">ClassFile</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-13 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-13T00:00:00+08:00">2024-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 10:57:48" itemprop="dateModified" datetime="2025-04-27T10:57:48+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ClassFile-字节码"><a href="#ClassFile-字节码" class="headerlink" title="ClassFile 字节码"></a>ClassFile 字节码</h1><p>Java 字节码是 Java 编译器将 Java 源代码编译成的 <strong>中间表示格式</strong>，它运行在 <strong>Java 虚拟机（JVM）</strong> 上。Java 字节码文件的扩展名为 <code>.class</code>，可以通过 <code>javap -c</code> 命令查看其内容。</p>
<p>任何一个Class文件都对应着唯一的一个类或接口的定义信息[1]，但是反过来说，类或 接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。本章中， 笔者只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”，实际上它完全不 需要以磁盘文件的形式存在。</p>
<p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文 件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数 据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[2]的方式分割 成若干个8个字节进行存储。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/09/13/jvm-classfile/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/11/jvm-in-one/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/11/jvm-in-one/" class="post-title-link" itemprop="url">JVM 介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-11 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-11T00:00:00+08:00">2024-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-08 13:31:48" itemprop="dateModified" datetime="2025-05-08T13:31:48+08:00">2025-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JVM-是虚拟机吗？"><a href="#JVM-是虚拟机吗？" class="headerlink" title="JVM 是虚拟机吗？"></a>JVM 是虚拟机吗？</h1><h2 id="JVM-是什么？"><a href="#JVM-是什么？" class="headerlink" title="JVM 是什么？"></a>JVM 是什么？</h2><p><strong>Java Virtual Machine (JVM)</strong> 是 Java 平台的核心组件，它是一个<mark><strong>程序运行环境</strong><mark>，专门用来执行 Java 字节码（Bytecode）</p>
<p><strong>主要功能：</strong></p>
<ol>
<li><strong>跨平台支持</strong>：JVM 实现了 Java 的 “Write Once, Run Anywhere” 特性，使 Java 程序能够在不同操作系统上运行。</li>
<li>字节码解释和编译：JVM 将 Java 编译器生成的字节码（平台无关）转换为平台相关的机器代码，并执行。</li>
<li>内存管理：提供垃圾回收机制 (Garbage Collection, GC)。</li>
<li>安全性：内置安全检查机制，确保 Java 程序在受控环境中运行，防止恶意代码执行。</li>
</ol>
<h2 id="Hypervisor-VMM-是什么"><a href="#Hypervisor-VMM-是什么" class="headerlink" title="Hypervisor/VMM 是什么?"></a>Hypervisor/VMM 是什么?</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2560px-Hyperviseur.svg.png" alt="undefined"></p>
<p>Hypervisor 是一种一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件。也可叫做虚拟机监视器，即 VMM（ virtual machine monitor ）。</p>
<ul>
<li>当服务器启动并执行 Hypervisor 时，它会加载所有虚拟机客户端的操作系统同时会分配给每一台虚拟机适量的内存，CPU，网络和磁盘。它允许多个操作系统（称为<strong>Guest OS</strong>）在同一台物理机器（称为<strong>Host</strong>）上同时运行，每个操作系统被隔离在独立的虚拟机中。</li>
<li>Hypervisor 负责资源分配，如 CPU、内存和存储，协调着这些硬件资源的访问，而且在各个虚拟机之间施加防护，处理虚拟机之间的通信和安全隔离。</li>
</ul>
<h2 id="JVM-与-Hypervisor-VMM-的对比"><a href="#JVM-与-Hypervisor-VMM-的对比" class="headerlink" title="JVM 与 Hypervisor/VMM 的对比"></a>JVM 与 Hypervisor/VMM 的对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>JVM</th>
<th>Hypervisor/VMM</th>
</tr>
</thead>
<tbody><tr>
<td><strong>用途</strong></td>
<td>运行 Java 程序的虚拟环境</td>
<td>管理和运行多个虚拟机，每个虚拟机可运行不同操作系统</td>
</tr>
<tr>
<td><strong>虚拟化层级</strong></td>
<td>应用程序级虚拟化（针对 Java 字节码）</td>
<td>操作系统级虚拟化（针对硬件资源）</td>
</tr>
<tr>
<td><strong>管理对象</strong></td>
<td><strong>Java 字节码执行环境</strong></td>
<td>虚拟机管理和<strong>硬件资源虚拟化</strong></td>
</tr>
<tr>
<td><strong>依赖性</strong></td>
<td>必须安装在操作系统上，依赖操作系统环境</td>
<td>Type 1 可以直接运行在硬件上，Type 2 依赖操作系统</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>程序之间隔离性较弱，依赖 JVM 的安全机制</td>
<td>每个虚拟机互相独立，硬件级别隔离</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td>Oracle HotSpot VM、OpenJDK JVM</td>
<td>VMware ESXi、VirtualBox、KVM、Hyper-V</td>
</tr>
</tbody></table>
<ol>
<li>在 VMware ESXi 上创建一个虚拟机；</li>
<li>在虚拟机内部运行一个 Guest OS，比如 Linux；</li>
<li>在 Linux 中安装 Java 环境并运行 JVM。</li>
</ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/09/11/jvm-in-one/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/09/java-web-frontend/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/09/java-web-frontend/" class="post-title-link" itemprop="url">Web 前端</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-09 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-09T00:00:00+08:00">2024-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:21:49" itemprop="dateModified" datetime="2025-05-05T11:21:49+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web-development/" itemprop="url" rel="index"><span itemprop="name">web development</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p><strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage </p>
<p>结构：HTML</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/html/html-tutorial.html">HTML 教程 | 菜鸟教程 (runoob.com)</a> </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTML">HTML - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">HTML（超文本标记语言） | MDN (mozilla.org)</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926154402465.png" alt="image-20240926154402465"></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="基础标签"><a href="#基础标签" class="headerlink" title="基础标签"></a>基础标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926165557803.png" alt="image-20240926165557803"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926170603004.png" alt="image-20240926170603004"></p>
<h3 id="图片，音视频标签"><a href="#图片，音视频标签" class="headerlink" title="图片，音视频标签"></a>图片，音视频标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926170628097.png" alt="image-20240926170628097"></p>
<p>height weight 有 px 和百分比两种写法 src路径</p>
<p>URL 统一资源定位符 ../ 代表上一级目录 </p>
<h3 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926171504599.png" alt="image-20240926171504599"></p>
<p>a href=”url” </p>
<h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926171804215.png" alt="image-20240926171804215"></p>
<h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926171833199.png" alt="image-20240926171833199"></p>
<p>边框宽度+空白区间宽度</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926172249995.png" alt="image-20240926172249995"></p>
<h3 id="布局标签"><a href="#布局标签" class="headerlink" title="布局标签"></a>布局标签</h3><div></div>


<p>div块级标签，占一整行</p>
<p>span 只占据自己的空间</p>
<h3 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926193335810.png" alt="image-20240926193335810"></p>
<p>提交表单：方式get/post </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926193711640.png" alt="image-20240926193711640"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926194217797.png" alt="image-20240926194217797"></p>
<p><strong>点击框外文本就能让框处于被选中的状态</strong>：</p>
<p>如果要随着表单一起提交，就要起一个name</p>
<p>用<strong>label</strong>标签把用户名包裹起来，给输入框起一个唯一的id, label for “id” </p>
<p><strong>radio</strong>：单选按钮，让其name相同达到互斥效果，给他赋值value让服务器接收到有效信息</p>
<p>hidden 修改商品信息，id隐藏在表单里面,提交表单会上传</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928193146331.png" alt="image-20240928193146331"></p>
<p>submit reset button 如果要指定按钮名字 value</p>
<select>
    <option>123</option>
     <option>4567</option>
</select>


<p>textarea cols支持的列数 rows支持的行数</p>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>表现：CSS</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/css/css-tutorial.html">CSS 教程 | 菜鸟教程 (runoob.com)</a> </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CSS">CSS - 维基百科，自由的百科全书 (wikipedia.org) </a> </p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS：层叠样式表 | MDN (mozilla.org)</a></p>
<h2 id="导入HTML"><a href="#导入HTML" class="headerlink" title="导入HTML"></a>导入HTML</h2><p>在head标签中导入</p>
<p>内联，内部，外部</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926201958367.png" alt="image-20240926201958367"></p>
<p><code>&lt;link href=&quot;css路径&quot; rel=&quot;stylesheet&quot;&gt;</code></p>
<h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926202419738.png" alt="image-20240926202419738"></p>
<p>name唯一 class不唯一</p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>行为：javascript</p>
<p>什么是JS？</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/js/js-tutorial.html">JavaScript 教程 | 菜鸟教程 (runoob.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript">JavaScript——动态客户端脚本语言 - 学习 Web 开发 | MDN (mozilla.org)</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926202813408.png" alt="image-20240926202813408"></p>
<p>改变HTML 交互性</p>
<p>引入方式：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929131050714.png" alt="image-20240929131050714"></p>
<p>内部脚本,一般放在body下面</p>
<p>外部脚本, 不支持自闭合</p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul>
<li>区分大小写，分号可有可无</li>
<li>单行，多行注释</li>
<li>大括号表示代码块</li>
</ul>
<h3 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h3><ul>
<li>(window.)alert()弹出警告</li>
<li>document.write() 写入HTML页面</li>
<li>console.log() 写入浏览器控制台</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>var是变量，弱类型语言，可以存放不同类型的值</p>
<p>作用域：全局变量而且可以重复声明定义</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929132314244.png" alt="image-20240929132314244"></p>
<p>let 作用域只在代码块之内 局部变量 不可重复定义</p>
<p>const 常量</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929132717037.png" alt="image-20240929132717037"></p>
<p>number boolean string 空（null）默认初始值（undefined）</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929132954368.png" alt="image-20240929132954368"></p>
<p>全等于(===) 类型不一样返回false，更加严格</p>
<p>等于（==）判断类型是否一样，如果不一样则转换类型，然后才比较值</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>转为number：</p>
<ul>
<li>string<ul>
<li><code>var str = &quot;20&quot;   parseInt(str)</code></li>
<li>字面值转为数字，如果字面值不是数字，转为NaN</li>
</ul>
</li>
<li>boolean <ul>
<li>true-&gt;1 false-&gt;0</li>
</ul>
</li>
</ul>
<p>转成boolean</p>
<ul>
<li>number： 0和NaN转为false</li>
<li>string：空字符串转为false</li>
<li>null&amp;undefined：转为false</li>
</ul>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>if  switch  while  do while  </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929135023368.png" alt="image-20240929135023368"></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>关键字：function</li>
<li>返回值类型：不需要，直接return</li>
<li>参数列表：不用写参数类型</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929135258270.png" alt="image-20240929135258270"></p>
<p>实际调用可以有很多实参，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929135611640.png" alt="image-20240929135611640"></p>
<p>add(1,2) = 3</p>
<p>add(1)  = NaN</p>
<h2 id="JavaScript-对象"><a href="#JavaScript-对象" class="headerlink" title="JavaScript 对象"></a>JavaScript 对象</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">//访问数组</span></span><br><span class="line">arr1[<span class="number">1</span>]=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>与java不同，js的数组是集合，变长，变类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变长</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr3[<span class="number">5</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//索引为5的元素被赋值为10, 中间空出来的是undefined</span></span><br><span class="line"><span class="comment">//变类型</span></span><br><span class="line">arr3[<span class="number">10</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>长度：length</p>
<p>增：push(10) 加入值为10的元素</p>
<p>删：splice(0,3)从索引0开始，删除3个元素</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>length:长度</p>
<p>trim(): 去除字符串两端的空白字符</p>
<p>charAt(i):返回指定位置的字符</p>
<p>indexOf(c) 返回字符第一次出现的索引</p>
<h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;ZS&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">23</span>,</span><br><span class="line">    <span class="attr">eat</span>:<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;eat&quot;</span>+a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">eat</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>浏览器对象模型</p>
<p>Navigator Screen</p>
<h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><ul>
<li>窗口对象，使用window获取</li>
<li><code>alert()</code> 警告</li>
<li><code>confirm(&quot;对话框内容&quot;)</code> 确认/取消对话框<ul>
<li>有返回值，返回的是一个boolean</li>
</ul>
</li>
<li><code>setInterval(function,ms)</code> 定时器，循环执行function</li>
<li><code>setTimeout(function,ms)</code> 倒计时，只有一次</li>
</ul>
<p>根据变化的数字，产生固定个数的值，取模</p>
<h5 id="history"><a href="#history" class="headerlink" title="history"></a>history</h5><ul>
<li><p>通过window调取，window可省略</p>
</li>
<li><p><code>history.back()</code>加载前一个URL</p>
</li>
<li><p><code>history.forward()</code>加载下一个URL</p>
</li>
</ul>
<h5 id="location"><a href="#location" class="headerlink" title="location"></a>location</h5><ul>
<li>通过window调取，可省略</li>
<li><code>location.href</code> 设置当前的URL，可以实现跳转</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929143103867.png" alt="image-20240929143103867"></p>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>文档对象模型 W3C指定的XML HTML的规则</p>
<p>查文档</p>
<h4 id="document"><a href="#document" class="headerlink" title="document"></a>document</h4><h5 id="获取Element"><a href="#获取Element" class="headerlink" title="获取Element"></a>获取Element</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929143507450.png" alt="image-20240929143507450"></p>
<ul>
<li>id: 每个元素唯一的id</li>
<li>tagName: 标签名</li>
<li>class: 同类的，一个元素可以有多个类，一个类可以有多个元素</li>
<li>name: 用于radio checkbox 和 form表单 提交将输入的值发送</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;submit.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">value</span>=<span class="string">&quot;apple&quot;</span>&gt;</span> Apple</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">value</span>=<span class="string">&quot;banana&quot;</span>&gt;</span> Banana</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">value</span>=<span class="string">&quot;orange&quot;</span>&gt;</span> Orange</span><br></pre></td></tr></table></figure>

<h5 id="element通用方法"><a href="#element通用方法" class="headerlink" title="element通用方法"></a>element通用方法</h5><ul>
<li><p>element.<strong>style</strong> 获取style标签</p>
<ul>
<li>element.style.color = “red” 设置元素的style中 color属性为red</li>
<li></li>
</ul>
</li>
<li><p>element.<strong>innerHTML</strong> 改变两个标签内部的文本内容</p>
</li>
</ul>
<p>checkbox.<strong>checked</strong>=true 复选框设置为勾选  </p>
<h2 id="事件监听-EventListener"><a href="#事件监听-EventListener" class="headerlink" title="事件监听 EventListener"></a>事件监听 EventListener</h2><p>事件：发生在HTML元素上的事件，比如按钮被电击，鼠标移到元素之上，按下键盘按键</p>
<p>监听：侦测到事件，执行某些代码</p>
<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><h4 id="HTML标签的属性绑定"><a href="#HTML标签的属性绑定" class="headerlink" title="HTML标签的属性绑定"></a>HTML标签的属性绑定</h4><p>耦合度太高</p>
<h4 id="DOM元素属性绑定"><a href="#DOM元素属性绑定" class="headerlink" title="DOM元素属性绑定"></a>DOM元素属性绑定</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929145651893.png" alt="image-20240929145651893"></p>
<p>属性和函数绑定</p>
<h3 id="常见的事件"><a href="#常见的事件" class="headerlink" title="常见的事件"></a>常见的事件</h3><p><code>onblur</code>: 失去焦点</p>
<p><code>onfocus</code>: 获得焦点</p>
<p><code>onchange</code>:文本改变</p>
<p><code>onkeydown</code>: 按键</p>
<p><code>onmouseover</code>: 鼠标移动到指定对象上</p>
<p><code>onmouseout</code>：鼠标离开指定对象</p>
<p><code>onsubmit</code>: 表单验证，绑定的函数要有返回值，如果返回true则表单会被提交</p>
<p>核心宗旨：把一些交互逻辑更多地放到浏览器这边，减少服务端的压力</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929152143546.png" alt="image-20240929152143546"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929153455050.png" alt="image-20240929153455050"></p>
<p>绑定函数和事件</p>
<h1 id="Regex"><a href="#Regex" class="headerlink" title="Regex"></a>Regex</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/regexp/regexp-tutorial.html">正则表达式 – 教程 | 菜鸟教程 (runoob.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://regex101.com/">regex101: build, test, and debug regex</a> </p>
<p><strong>正则表达式（Regular Expression, regex）</strong>是一种用来描述和匹配字符串模式的工具，其原理基于形式语言和自动机理论。以下是正则表达式的主要原理和工作机制：</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ol>
<li><strong>字符匹配</strong>：正则表达式中的普通字符（如 <code>a</code>, <code>b</code>, <code>1</code>, <code>2</code>）直接匹配自身。例如，正则表达式 <code>abc</code> 将匹配字符串 “abc”。</li>
<li><strong>元字符和转义</strong>：元字符（如 <code>.</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>|</code>、<code>()</code>、<code>[]</code>、<code>&#123;&#125;</code>）有特殊含义。若要匹配这些字符本身，需要使用转义字符 <code>\</code>。例如，<code>\.</code> 匹配字符 <code>.</code>。</li>
<li><strong>字符类</strong>：使用方括号 <code>[]</code> 定义字符类，可以匹配其中任意一个字符。例如，<code>[abc]</code> 匹配 <code>a</code>、<code>b</code> 或 <code>c</code>。</li>
<li><strong>预定义字符类</strong>：常见的预定义字符类包括 <code>\d</code>（数字），<code>\w</code>（字母、数字或下划线），<code>\s</code>（空白字符），等价于 <code>[0-9]</code>、<code>[a-zA-Z0-9_]</code>、<code>[ \t\n\r\f\v]</code>。</li>
<li><strong>量词</strong>：量词用来指定匹配次数。例如，<code>*</code>（0 次或多次），<code>+</code>（1 次或多次），<code>?</code>（0 次或 1 次），<code>&#123;n&#125;</code>（恰好 n 次），<code>&#123;n,&#125;</code>（至少 n 次），<code>&#123;n,m&#125;</code>（n 到 m 次）。</li>
<li><strong>边界匹配</strong>：边界匹配符包括 <code>^</code>（行首），<code>$</code>（行尾），<code>\b</code>（单词边界），<code>\B</code>（非单词边界）。</li>
<li><strong>分组和捕获</strong>：使用圆括号 <code>()</code> 将正则表达式的一部分进行分组，可以进行捕获以便后续引用。例如，<code>(\d&#123;3&#125;)-(\d&#123;3&#125;)</code> 匹配 “123-456” 并捕获 “123” 和 “456”。</li>
<li><strong>选择和替代</strong>：使用管道符 <code>|</code> 表示选择，匹配左边或右边的表达式。例如，<code>a|b</code> 匹配 <code>a</code> 或 <code>b</code>。</li>
</ol>
<h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><ol>
<li><strong>编译</strong>：正则表达式首先被编译成一种内部表示形式。这个编译过程将解析正则表达式字符串，并将其转换为一个有限状态自动机（Finite State Machine, FSM）。</li>
<li><strong>匹配过程</strong>：<ul>
<li><strong>DFA（确定性有限自动机）</strong>：DFA 每个状态都有确定的转换，即每一个输入字符都会导致状态的唯一确定转换。DFA 的匹配过程效率高，但状态数可能较多。</li>
<li><strong>NFA（非确定性有限自动机）</strong>：NFA 允许从一个状态可以有多条转换边，匹配过程可能需要回溯。NFA 的构建比较简单，但匹配过程效率可能较低。</li>
</ul>
</li>
<li><strong>引擎</strong>：<ul>
<li><strong>NFA 引擎</strong>：基于回溯算法，尝试每一种可能的路径，直到找到匹配或失败。大多数现代正则表达式引擎（如 Perl、Python、JavaScript 等）使用 NFA 引擎。</li>
<li><strong>DFA 引擎</strong>：不使用回溯，直接通过状态转换进行匹配，通常速度较快，但实现较为复杂且内存消耗较大。</li>
</ul>
</li>
</ol>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li><strong>字符串查找和替换</strong>：在文本编辑器、IDE 等工具中，通过正则表达式进行复杂的搜索和替换操作。</li>
<li><strong>数据验证</strong>：验证输入数据的格式，如邮箱地址、电话号码等。</li>
<li><strong>文本处理</strong>：如日志解析、数据抽取等。</li>
</ul>
<p>通过对正则表达式的理解和应用，可以高效地进行字符串处理和模式匹配，极大地提高文本处理的灵活性和效率。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929153836955-1727921863704-1.png" alt="image-20240929153836955"></p>
<p>JS 正则表达式对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;^\\w&#123;6,12&#125;$&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^\w&#123;6,12&#125;$/</span></span><br><span class="line"></span><br><span class="line">regex.<span class="title function_">test</span>(str) <span class="comment">//正则表达式</span></span><br></pre></td></tr></table></figure>



<ul>
<li><code>\d</code>: 数字</li>
<li><code>\D</code>: 除了数字以外的字符</li>
<li><code>\s</code>:空白字符</li>
<li><code>\w</code>:字母+下划线+数字</li>
<li><code>[ ]</code>匹配单个字符 字符集合</li>
<li><code>[^1-3A-Z]</code>匹配一个除了1-3和大写字母的字符</li>
<li>尖角^只有在方框内部才是取反的意思。在外部表示匹配开头，<code>^abc</code>表示作为开头的abc，<code>BCD$</code>就是作为结尾的BCD<ul>
<li>匹配总共需要三个参数：要处理的字符串，匹配模式和正则表达式本身，可以看出处理的文本本身就是一个字符串。</li>
<li>如果没有多行匹配，^和$只会作用于<strong>整个文本</strong>的开头和结尾</li>
<li>multiline模式会匹配每一行</li>
</ul>
</li>
<li><code>/...../g</code>表示不要搜索一次就返回，去掉只显示第一个匹配的</li>
<li><code>/...../m</code>表示多行匹配</li>
<li><code>/...../i</code>表示忽略大小写</li>
<li><code>\b</code>:表示单词边界 <code>\bin</code>表示in在单词开头 <code>in\b</code>表示in在单词末尾</li>
<li><code>\B</code>:表示单词内部 <code>\Bin\B</code>表示in在单词中间 <code>\Bin</code>表示匹配前面有东西的in</li>
<li><code>.$</code>表示属于结尾的任意字符</li>
<li><code>\.$</code>表示属于结尾的点号</li>
</ul>
<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><ul>
<li><code>at+</code> atttt atttt 加号表示a t(重复一次或者多次)</li>
<li><code>at*</code> atttt atttt 星号表示a t(重复0次或者多次)</li>
<li><code>at?</code> at a 问号表示零次或者一次</li>
<li><code>at&#123;3,5&#125;</code> attt 表示t重复了3到5次</li>
<li><code>at&#123;3,&#125;</code> attt 表示t重复了3次以上 </li>
</ul>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul>
<li><code>(at)&#123;3&#125;</code> at整体重复了3次</li>
<li><code>(P|p)iece</code> Piece和piece</li>
<li><code>(d&#123;4&#125;)[-/_.](d&#123;1,2&#125;)[-/_.](d&#123;1,2&#125;)</code> 匹配年月日并且分成三组$1$2$3分别代表123组可以使用替换</li>
<li>如果不想分其中一个组<code>?:</code>表示仅代表一个整体不参与分组</li>
</ul>
<p>在 Java 的正则表达式中，如果你想忽略大小写匹配，可以使用以下几种方法：</p>
<h2 id="Java中忽略大小写的使用"><a href="#Java中忽略大小写的使用" class="headerlink" title="Java中忽略大小写的使用"></a>Java中忽略大小写的使用</h2><h3 id="使用-Pattern-CASE-INSENSITIVE-标志"><a href="#使用-Pattern-CASE-INSENSITIVE-标志" class="headerlink" title="使用 Pattern.CASE_INSENSITIVE 标志"></a>使用 <code>Pattern.CASE_INSENSITIVE</code> 标志</h3><p>通过调用 <code>Pattern.compile</code> 方法并传递 <code>Pattern.CASE_INSENSITIVE</code> 标志，可以忽略大小写。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译正则表达式时指定忽略大小写</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex, Pattern.CASE_INSENSITIVE);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(text);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-i-内联标志"><a href="#使用-i-内联标志" class="headerlink" title="使用 (?i) 内联标志"></a>使用 <code>(?i)</code> 内联标志</h3><p>在正则表达式的开头加上 <code>(?i)</code> 也可以忽略大小写。这是内联标志，不需要使用 <code>Pattern.compile</code>。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;(?i)hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (text.matches(regex)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>Pattern.CASE_INSENSITIVE</code></strong> 标志是在编译正则表达式时通过代码设置忽略大小写。</li>
<li><strong><code>(?i)</code></strong> 是在正则表达式内部直接指定忽略大小写，简单方便。</li>
</ul>
<h1 id="AJAX-JSON-个人笔记-Java-Web-服务端-pdf"><a href="#AJAX-JSON-个人笔记-Java-Web-服务端-pdf" class="headerlink" title="[AJAX, JSON](./个人笔记/Java Web 服务端.pdf)"></a>[AJAX, JSON](./个人笔记/Java Web 服务端.pdf)</h1><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/">Vue.js - 渐进式 JavaScript 框架 | Vue.js (vuejs.org)</a></p>
<h2 id="优点、原理"><a href="#优点、原理" class="headerlink" title="优点、原理"></a>优点、原理</h2><ul>
<li>免除DOM操作，简化书写</li>
<li>基于MVVM思想，双向绑定数据，使view能够绑定model的数据，而不是model变了</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929223353641.png" alt="image-20240929223353641"></p>
<p>model: plain JavaScript Objects     view: 模板</p>
<p>model，也就是数据，通过vue实例绑定到view上，model一更新，view上也会立即更新，</p>
<p>view，模板，通过vue实例的domListener，监听发生的dom事件，比如输入，通过listener将model处的数据实时更新。</p>
<p>数据全存在vm上，view能看到vm所有的数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929231110532.png" alt="image-20240929231110532"></p>
<p>在之前的JSON案例中，填写表单时，表单数据是model，<strong>在提交的时候</strong>，还要用<strong>繁琐的dom操作</strong>获取输入框中的值再赋给model。vue能在输入的时候就赋值给对象，如果从服务器接收到数据也能实时更新。</p>
<h2 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h2><p><a href=".%5C%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%5CHTML%5Cindex.html">index.html</a></p>
<p><strong>Vue3</strong> </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hello-vue&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>//div元素 唯一id为hello-vue 归属于demo类</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span>//v-model双向绑定,这个view中的值是多少, vue实例中数据就是多少</span><br><span class="line">&#123;&#123; message &#125;&#125;//插值表达式。这是 Vue.js 的模板语法，用于将 Vue 实例中的数据绑定到页面上。</span><br><span class="line">			 //vue实例中的数据变化时,这里也跟着变化。</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">HelloVueApp</span>=&#123; <span class="comment">//此处创建了一个自定义JS对象</span></span></span><br><span class="line"><span class="language-javascript">	<span class="title function_">data</span>(<span class="params"></span>)&#123;<span class="comment">//data是一个无参的函数,返回值是一个对象，里面包含了model数据</span></span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">message</span>: <span class="string">&#x27;Hello,Vue!&#x27;</span><span class="comment">//数据初值是Hello,Vue!字符串</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">	&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">HelloVueApp</span>).<span class="title function_">mount</span>(<span class="string">&quot;#hello-vue&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="comment">//Vue.createApp() 方法用于创建一个 Vue 应用实例，参数是一个包含组件选项的对象（这里是 HelloVueApp）。</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//.mount(&#x27;#hello-vue&#x27;) 方法将 Vue 应用实例挂载到页面中具有 id=&quot;hello-vue&quot; 的 DOM 元素上。</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令是带有前缀 <strong>v-</strong> 的特殊属性，用于在模板中表达逻辑。</p>
<p><strong>v-bind</strong>: 动态绑定一个或多个特性，或一个组件 prop。将 Vue 实例的数据绑定到 HTML 元素的属性上</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>简写：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-if</strong>: 条件渲染。根据表达式的值来条件性地渲染元素或组件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;seen&quot;</span>&gt;</span>Now you see me<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-for</strong>: 列表渲染。 用于根据数组或对象的属性值来循环渲染元素或组件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.text &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">//v-for=迭代对象 相当于增强for循环 </span><br><span class="line">//key帮助 Vue 在渲染列表时识别每个元素的唯一性。</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">HelloVueApp</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">items</span>: [ <span class="comment">//items数组包含多个匿名对象，这些匿名对象id和text两个属性</span></span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;Item 1&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&#x27;Item 2&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">text</span>: <span class="string">&#x27;Item 3&#x27;</span> &#125;</span></span><br><span class="line"><span class="language-javascript">      ]</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">HelloVueApp</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-model</strong>: 实现表单数据双向绑定：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;edit me&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-on</strong>: 事件监听器。 用于在 HTML 元素上绑定事件监听器，使其能够触发 Vue 实例中的方法或函数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>简写：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-show</strong>: 用于根据表达式的值来条件性地显示或隐藏元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hello-vue&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;showMessage = !showMessage&quot;</span>&gt;</span>显示/隐藏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">&quot;showMessage&quot;</span>&gt;</span>Hello Vue!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">HelloVueApp</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">showMessage</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">HelloVueApp</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#hello-vue&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>v-on指令能够监听事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">v-<span class="attr">on</span>:click=<span class="string">&quot;methodName&quot;</span></span><br><span class="line">@click=<span class="string">&quot;methodName&quot;</span></span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;counter += 1&quot;</span>&gt;</span>增加 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> app = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">counter</span>: <span class="number">0</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(app).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="案例简化-JavaScript中的this指针与回调函数"><a href="#案例简化-JavaScript中的this指针与回调函数" class="headerlink" title="案例简化-JavaScript中的this指针与回调函数"></a>案例简化-JavaScript中的this指针与回调函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//script</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">VueApp</span> = &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="attr">brands</span>:[]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">        axios.<span class="title function_">get</span>(<span class="string">&quot;http://localhost:8080/selectAllServlet&quot;</span>)</span><br><span class="line">         .<span class="title function_">then</span>(<span class="function">(<span class="params">resp</span>)=&gt;</span>&#123;<span class="variable language_">this</span>.<span class="property">brands</span> = resp.<span class="property">data</span>;&#125;);</span><br><span class="line">        <span class="comment">//brands是集合,用v-for遍历</span></span><br><span class="line">        <span class="comment">//回调函数是作为参数传递给另一个函数的函数，目的是在特定事件或条件发生时被调用。它通常用于异步操作、事件处理和在特定时机执行代码。箭头函数不会根据调用者创建this，只会寻找域中含有的this指针，mounted的this就是Vue实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">    	<span class="attr">show</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&quot;clicked&quot;</span>);<span class="comment">//跟提交的按钮绑定</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">createVueApp</span>(<span class="title class_">VueApp</span>).<span class="title function_">mount</span>(#app)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href=".%5C%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%5CHTML%5CanoymousThis.html">JavaScript中的this指针</a> 另外一种是在mounted中先定义一个var _this = this，这样_this 一定指代的是Vue实例</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>单个复选框：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checked&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>多个复选框：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;runoob&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Runoob&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;runoob&quot;</span>&gt;</span>Runoob<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;google&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Google&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;google&quot;</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;taobao&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Taobao&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;taobao&quot;</span>&gt;</span>taobao<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>选择的值为: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> app = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      checked : <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">checkedNames</span>: []</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(app).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h1><p><a target="_blank" rel="noopener" href="https://element.eleme.cn/#/zh-CN">Element - 网站快速成型工具</a></p>
<p>Vue组件库，可以快速构建网页</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930212139910.png" alt="image-20240930212139910"></p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930224145033.png" alt="image-20240930224145033"></p>
<h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930224317166.png" alt="image-20240930224317166"></p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930224538591.png" alt="image-20240930224538591"></p>
<p>对话框+表单</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/05/java-web-backend/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/05/java-web-backend/" class="post-title-link" itemprop="url">Web 后端 Java</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-05 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-05T00:00:00+08:00">2024-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:49:42" itemprop="dateModified" datetime="2025-05-05T11:49:42+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web-development/" itemprop="url" rel="index"><span itemprop="name">web development</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p><strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol </p>
<p>TCPIP协议四层架构的最上层 规定了服务器和浏览器之间传输数据的规则</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP">HTTP | MDN (mozilla.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">超文本传输协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>基于TCP，面向连接，安全</li>
<li>基于请求-响应模型：1Request 1Response</li>
<li>HTTP是无状态协议，对事务处理没有记忆能力，每次RR都是独立的<ul>
<li>多次请求之间不能共享数据，java用会话技术（cookie session）解决这个问题</li>
<li>优点：速度快</li>
</ul>
</li>
</ul>
<h2 id="请求数据格式"><a href="#请求数据格式" class="headerlink" title="请求数据格式"></a><a href="#request">请求数据格式</a></h2><p><strong>请求行</strong>：第一行，<code>GET</code>(请求方式) 后面的<code>/</code>表示请求资源的路径，HTTP/1.1表示协议版本</p>
<p><strong>请求头</strong>：第二行开始 key: value形式</p>
<p><strong>请求体</strong>：POST请求的最后一部分，存放请求参数</p>
<p>GET请求参数在请求行中，没有请求体，参数大小有限制(URL长度限制) POST请求的参数在请求体中，参数大小无限制</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926220614547.png" alt="image-20240926220614547"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926221417729.png" alt="image-20240926221417729"></p>
<p><strong>Host</strong>: 请求的主机名</p>
<p><strong>User-Agent</strong>: 浏览器版本</p>
<p><strong>Accept</strong>: 浏览器能接受的资源类型，如text/* image/* */* </p>
<p><strong>Accept-Language</strong>: 浏览器的偏好语言</p>
<p><strong>Accept-Encoding</strong>: 浏览器支持的压缩类型</p>
<h2 id="响应数据格式"><a href="#响应数据格式" class="headerlink" title="响应数据格式"></a>响应数据格式</h2><p><strong>响应行</strong>：响应数据的第一行，HTTP/1.1表示协议版本，下一个是响应状态码，OK表示状态码描述</p>
<p><strong>响应头</strong>：keyvalue</p>
<p><strong>响应体</strong>：最后一部分，存放响应数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926221630980.png" alt="image-20240926221630980"></p>
<p><strong>Content-Type</strong>：响应内容类型，比如text/html image/jpeg</p>
<p><strong>Content-Length</strong>：响应内容长度（bytes）</p>
<p><strong>Content-Encoding</strong>：响应压缩算法 gzip等</p>
<p><strong>Cache-Control</strong>: 指示客户端如何缓存，例如max-age=300 表示最多缓存300s</p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926222005460.png" alt="image-20240926222005460"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926222320894.png" alt="image-20240926222320894"></p>
<p>200 OK 404资源不存在 500 服务器异常</p>
<p>Java程序中，如果直接用自带的javawebsocketAPI 代码会变得异常繁琐，要注意请求和响应的格式要求，因此要用web服务器软件进行开发—-Tomcat</p>
<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>Apache Tomcat web服务器是一个应用程序，封装http协议，不用对协议进行直接操作。类似的还有jetty，weblogic，ibm webSphere，部署web项目到服务器中</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61596145">JavaEE的13种核心技术规范： - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://tomcat.apache.org/">Apache Tomcat® - Welcome!</a> </p>
<h2 id="创建Web项目"><a href="#创建Web项目" class="headerlink" title="创建Web项目"></a>创建Web项目</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927151450747.png" alt="image-20240927151450747"></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Web-&gt;META-INF()</span><br><span class="line">     WEB-INF -&gt;classes(java文件夹和resources文件夹合并)</span><br><span class="line">     	     -&gt;lib(依赖jar包)</span><br><span class="line">             -&gt;web.xml(web项目的配置文件)</span><br><span class="line">     webapp中除了WEB-INF的其他文件</span><br></pre></td></tr></table></figure>



<p>using 骨架</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927151529348.png" alt="image-20240927151529348"></p>
<p>packaging 默认jar 改成web项目用的war </p>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>动态资源web开发技术</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927162801770.png" alt="image-20240927162801770"></p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927163054997.png" alt="image-20240927163054997"></p>
<p>servlet对象，service方法由web服务器tomcat创建</p>
<p>WebServlet继承了Servlet接口</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927174147654.png" alt="image-20240927174147654"></p>
<ol>
<li>默认情况 servlet对象第一次被访问就被创建，通过改变loadOnStartup参数可以改变优先级</li>
<li>容器（tomcat）通过init方法初始化对象，只需要调用一次</li>
<li>每次请求servlet 容器都会调用servlet的service方法</li>
</ol>
<h2 id="Servlet-接口"><a href="#Servlet-接口" class="headerlink" title="Servlet 接口"></a>Servlet 接口</h2><p>定义了五个抽象方法：</p>
<ol>
<li><p><code>init(ServletConfig conf)</code>：默认情况下，servlet第一次被访问，容器创建servlet对象时，会调用init，只调用一次。改变WebServlet注解的参数loadOnStartup，可以控制在创建服务器的时候就创建servlet对象。</p>
</li>
<li><p><code>service(ServletRequest req,ServletResponse res)</code>: 每一次访问servlet就调用一次</p>
</li>
<li><p><code>destroy()</code>: 内存释放、服务器关闭时调用，只有一次</p>
</li>
<li><p><code>ServletConfig getServletConfig()</code>: servletconfig是容器调用init方法传进来的参数,可以在demo类中声明一个config成员变量，在init中赋值，然后在getConfig方法中返回</p>
</li>
<li><p><code>String getServletInfo() </code>: copyright information</p>
</li>
</ol>
<h2 id="Servlet-体系"><a href="#Servlet-体系" class="headerlink" title="Servlet 体系"></a>Servlet 体系</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927180225035.png" alt="image-20240927180225035"></p>
<p>Http doGet doPost</p>
<p>根据请求方式的不同分别处理，因为get的参数在请求行中，post的参数在请求体中。</p>
<p>httpservlet是servlet的实现类，实际上把service方法重写，接收请求参数req，如果req中是get方式，就执行doGet，如果是post就执行doPost  子类只需要重写doGetdoPost方法即可</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927181319844.png" alt="image-20240927181319844"></p>
<p>源码分析：原来的service方法重载，参数变成httpservletrequest和httpservletresponse ，原版的请求参数传进来，强制转换成httpservletrequest，然后吊用自己写好的重载service方法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927181753064.png" alt="image-20240927181753064"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927181825881.png" alt="image-20240927181825881"></p>
<h2 id="urlPattern"><a href="#urlPattern" class="headerlink" title="urlPattern"></a>urlPattern</h2><h3 id="一个servlet可以配置多个访问路径"><a href="#一个servlet可以配置多个访问路径" class="headerlink" title="一个servlet可以配置多个访问路径"></a>一个servlet可以配置多个访问路径</h3><p>urlPatterns = {“”,””}</p>
<h3 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927183113407.png" alt="image-20240927183113407"></p>
<ol>
<li>精确匹配 （优先级比目录匹配高）</li>
<li>目录匹配，通配符</li>
<li>扩展名匹配，<code>*.do</code> <code>aaa.do bbb.do</code>都可以访问，注意不能有斜杠</li>
<li>任意匹配，<code>/</code>优先级低于<code>/*</code><ul>
<li>/是tomcat默认生成的一个servlet，启动以后自动创建，是用来访问静态资源的</li>
<li>很危险，不要用</li>
</ul>
</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927183710215.png" alt="image-20240927183710215"></p>
<h3 id="web-xml配置"><a href="#web-xml配置" class="headerlink" title="web.xml配置"></a>web.xml配置</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927183912074.png" alt="image-20240927183912074"></p>
<h1 id="Request-amp-Response"><a href="#Request-amp-Response" class="headerlink" title="Request&amp;Response"></a>Request&amp;Response</h1><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927184223066.png" alt="image-20240927184223066"></p>
<p>request 获取请求数据</p>
<p>response 设置响应时的数据</p>
<p>request中含有用户输入的参数，response可以根据这个参数设置响应的数据，这样就完成了和用户交互的基本过程</p>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><h3 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927184637027.png" alt="image-20240927184637027"></p>
<p>ServletRequest和HttpServletRequest都是接口，不能实例化，定义了一些抽象方法作为规范。</p>
<p>我们的 servlet 重写了 service()方法的方法体，浏览器访问时，tomcat就要调用servlet的service方法。tomcat作为servlet容器，<strong>要解析请求报文，将其封装成req对象</strong>，送到servlet的service方法处作为参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是tomcat的程序</span></span><br><span class="line"><span class="comment">//tomcat做的是解析报文封装请求的操作，具体如何利用请求做出什么样的响应，则是开发者的工作</span></span><br><span class="line"><span class="type">MyServlet</span> <span class="variable">myServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyServlet</span>();</span><br><span class="line">myServlet.init()<span class="comment">//开发者重写</span></span><br><span class="line">myServlet.service(req,res)<span class="comment">//开发者重写</span></span><br></pre></td></tr></table></figure>

<p>所以Tomcat对接口进行了实现，查J2EE API</p>
<h3 id="获取请求数据"><a href="#获取请求数据" class="headerlink" title="获取请求数据"></a>获取请求数据</h3><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927192106826.png" alt="image-20240927192106826"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927192310996.png" alt="image-20240927192310996"></p>
<h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927192340229.png" alt="image-20240927192340229"></p>
<p>getHeader根据name来获取对应的信息</p>
<p>getHeader(“User-Agent”) 输出Mozilla/5.0 Chrome/91.0.4472.106</p>
<h4 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927192426370.png" alt="image-20240927192426370"></p>
<p>统一获取请求参数的方式？从而统一doGet和doPost方法内的代码</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927195026912.png" alt="image-20240927195026912"></p>
<p>getParameterMap 获取参数map 结构如上</p>
<p>getParameter 根据名称获取参数值</p>
<p>getParameterValues 根据名称获取参数值</p>
<h4 id="获取参数中文乱码"><a href="#获取参数中文乱码" class="headerlink" title="获取参数中文乱码"></a>获取参数中文乱码</h4><h5 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h5><p>设置输入流的字符集</p>
<p>底层是获取字符输入流BufferReader，所以<code>setCharacterEncoding(&quot;UTF-8&quot;)</code></p>
<h5 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h5><p>底层是字符串形式</p>
<p>浏览器发出请求的时候，会把中文字符转成URL编码，tomcat需要进行URL解码</p>
<h5 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h5><p>字符串按照编码方式转为二进制，每个字节转换为两个十六进制数，在前面加上%                                            </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927214608765.png" alt="image-20240927214608765"></p>
<p>Tomcat底层将URL编码 解码为ISO-8859-1</p>
<h3 id="Forward-请求转发"><a href="#Forward-请求转发" class="headerlink" title="Forward 请求转发"></a>Forward 请求转发</h3><p>服务器内部资源跳转方式，转发的资源之间共享数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928140710653.png" alt="image-20240928140710653"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928140736371.png" alt="image-20240928140736371"></p>
<p>请求内部有参数（map形式），来源URL等信息</p>
<ul>
<li><code>setAttribute(String name, Object o)</code>把数据o 存到request域中，以key为键    </li>
<li><code>removeAttribute(String name)</code> 根据key删除键值对</li>
<li><code>Object getAttribute(String name)</code>根据key获取数据</li>
</ul>
<ul>
<li>地址栏路径不发生变化；</li>
<li>只能转发到服务器内部的资源；</li>
<li>浏览器发送一次请求，多个资源共享request数据</li>
<li>高效率</li>
</ul>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928142749615.png" alt="image-20240928142749615"></p>
<h3 id="设置响应数据"><a href="#设置响应数据" class="headerlink" title="设置响应数据"></a>设置响应数据</h3><ol>
<li>响应行：设置状态码</li>
<li>响应头：设置键值对</li>
<li>响应体：通过输出流输出数据</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928142944677.png" alt="image-20240928142944677"></p>
<h3 id="Redirect-重定向"><a href="#Redirect-重定向" class="headerlink" title="Redirect 重定向"></a>Redirect 重定向</h3><p>资源跳转方式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928143039892.png" alt="image-20240928143039892"></p>
<p>状态码 <strong>302</strong> 响应头：location: 虚拟目录/demo6</p>
<p><code>sendRedirect(String url)</code>发送重定向响应</p>
<p><code>setStatus(302)</code> </p>
<p><code>setHeader(&quot;location&quot;,&quot;https://www.google.com&quot;)</code> </p>
<p><code>setHeader(&quot;Content-type&quot;,&quot;text/html&quot;)</code> </p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>地址栏路径发生变化；</li>
<li>转发任意资源；</li>
<li>浏览器发送两次请求，不能在多个资源用request共享数据</li>
<li>效率低</li>
</ul>
<h4 id="路径问题-动态获取虚拟目录"><a href="#路径问题-动态获取虚拟目录" class="headerlink" title="路径问题 动态获取虚拟目录"></a>路径问题 动态获取虚拟目录</h4><p>如果浏览器使用，需要加虚拟目录</p>
<p>服务端使用就不需要加了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928145151848.png" alt="image-20240928145151848"></p>
<p>虚拟目录可以动态变化，所以尽量减少硬编码，减少耦合性</p>
<p>可以用<code>request</code>的<code>getContextPath()</code> 获取虚拟目录</p>
<h3 id="设置响应数据-1"><a href="#设置响应数据-1" class="headerlink" title="设置响应数据"></a>设置响应数据</h3><h4 id="字符数据"><a href="#字符数据" class="headerlink" title="字符数据"></a>字符数据</h4><p><code>getWriter().write(String s) </code>写入数据到资源中</p>
<p><code>setContentType(&quot;text/html;charset=utf-8&quot;)</code>   </p>
<p>细节：不用关闭流</p>
<p>乱码可以用响应头设置编码，tomcat8不乱码</p>
<h4 id="字节数据"><a href="#字节数据" class="headerlink" title="字节数据"></a>字节数据</h4><p>ServletOutputStream = request.getOutputStream()</p>
<h2 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h2><p>用来创建与数据库的连接会话,只需要一个即可，所以运用单例的设计模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryUtils</span>&#123;</span><br><span class="line">    SqlSessionFactory factory;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">    SqlSessionFactory <span class="title function_">getSqlSessionFactory</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h2 id="入门-1"><a href="#入门-1" class="headerlink" title="入门"></a>入门</h2><p>Java Server Pages 静态的页面嵌入动态的代码 简化开发</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928175143005.png" alt="image-20240928175143005"></p>
<p>JSP本质是servlet，把写标签等繁琐的工作交给jsp技术</p>
<h3 id="JSP脚本"><a href="#JSP脚本" class="headerlink" title="JSP脚本"></a>JSP脚本</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928175642020.png" alt="image-20240928175642020"></p>
<ol>
<li><p>service方法是访问到这个资源的时候调用</p>
</li>
<li><p>out.print() 是printWriter 调用的</p>
</li>
<li><p>被生成的jsp类直接包含</p>
</li>
</ol>
<p>截断java代码，中间插入html标签是可以的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928180319108.png" alt="image-20240928180319108"></p>
<p>出现HTML标签的地方可以理解为java程序代替你输入这些标签，最简单的字面意义上的代替功能，因此截断也没什么关系</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928180738621.png" alt="image-20240928180738621"></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928180843640.png" alt="image-20240928180843640"></p>
<h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928181558853.png" alt="image-20240928181558853"></p>
<h2 id="JSTL-标签库"><a href="#JSTL-标签库" class="headerlink" title="JSTL 标签库"></a>JSTL 标签库</h2><p><mark><strong>#{}</strong><mark></p>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928182101658.png" alt="image-20240928182101658"></p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928182210315.png" alt="image-20240928182210315"></p>
<p>brand.id 不是访问成员变量，是要调用get方法</p>
<p>自动调用getId()</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928182800258.png" alt="image-20240928182800258"></p>
<p>varStatus 计数器</p>
<p>status.count是计数从1开始，status.index是从1开始</p>
<h4 id="普通for循环"><a href="#普通for循环" class="headerlink" title="普通for循环"></a>普通for循环</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928183033816.png" alt="image-20240928183033816"></p>
<p>Java虚拟机负责存储变量信息，jsp只负责展示与变量相关的信息，因此不用重启服务器，</p>
<h2 id="Servlet-JSP开发"><a href="#Servlet-JSP开发" class="headerlink" title="Servlet+JSP开发"></a>Servlet+JSP开发</h2><p><strong>业务逻辑层</strong>本质上是对dao层的封装，包括创建session，创建mapper，mapper调用dao方法，事务等。</p>
<p>每个servlet都是资源，浏览器能够通过网址或者表单的形式发出请求，servlet根据request的参数进行一系列业务逻辑操作，将返回的结果转发给jsp页面。</p>
<p>jsp本质也是一个servlet，将请求中的参数打印出来的同时还能生成html标签，浏览器就能通过html标签解析出网页。</p>
<p>在修改页面改了一个数据，提交表单到updateServlet，updateServlet进行业务操作，完成后，把包含参数的请求转发到 浏览所有数据 的showAll.jsp页面，jsp本质是servlet，负责打印标签和数据。</p>
<h1 id="MVC-设计模式"><a href="#MVC-设计模式" class="headerlink" title="MVC 设计模式"></a>MVC 设计模式</h1><p><strong>Model</strong>：接受Controller发出的指令，与数据库交互，增删改查，返回数据给Controller</p>
<p><strong>View</strong>：接受Controller发出的数据（Model给的）渲染页面，返回HTML页面给Controller</p>
<p><strong>Controller</strong>：接受客户端的数据请求，返回给客户端HTML页面，同时与model和view交流，充当Model和View之间的桥梁。</p>
<p>Model和View之间一个是处理数据，一个是呈现数据，二者可以专注于各自的事情</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240919202449018-1727923726251-1.png" alt="image-20240919202449018"></p>
<p>Servlet controller </p>
<p>JSP View </p>
<p>JavaBean Model </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928183538077-1727923726251-2.png" alt="image-20240928183538077"></p>
<p>三层架构</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928183903472-1727923726251-3.png" alt="image-20240928183903472"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928183924963-1727923726251-4.png" alt="image-20240928183924963"></p>
<h1 id="Cookie-amp-Session-amp-JWT"><a href="#Cookie-amp-Session-amp-JWT" class="headerlink" title="Cookie&amp;Session&amp;JWT"></a>Cookie&amp;Session&amp;JWT</h1><h2 id="会话跟踪技术"><a href="#会话跟踪技术" class="headerlink" title="会话跟踪技术"></a>会话跟踪技术</h2><p>浏览器打开一个网站就是会话建立的过程，其中可以<strong>包含多次请求和响应</strong>，服务段需要区分不同的会话，判断多次请求是否来自统一浏览器，以便在同一次会话的<strong>多次请求之间，共享数据。</strong></p>
<p><strong>HTTP协议是无状态</strong>的，为了最佳的请求响应效率，牺牲了存储记忆数据的功能，每次请求都被视作新的请求，因此要跟踪回话实现会话内数据共享。</p>
<p>本质是将数据存储在一端</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928201532521.png" alt="image-20240928201532521"></p>
<p>客户端：<strong>Cookie</strong> </p>
<p>服务端：<strong>Session</strong> </p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>客户端的会话技术，保存数据到客户端，每次请求都携带cookie数据进行访问。客户端的记忆</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928202227465.png" alt="image-20240928202227465"></p>
<p>响应的时候setcookie，请求的时候带着cookie</p>
<h3 id="发送cookie"><a href="#发送cookie" class="headerlink" title="发送cookie"></a>发送cookie</h3><p>创建Cookie，设置键值对</p>
<p>response调用addCookie方法发送cookie</p>
<h3 id="获取cookie"><a href="#获取cookie" class="headerlink" title="获取cookie"></a>获取cookie</h3><p>request对象调用getCookies 接收cookies</p>
<p>for循环遍历，getName和getValue</p>
<h2 id="cookie的原理"><a href="#cookie的原理" class="headerlink" title="cookie的原理"></a>cookie的原理</h2><p><strong>基于HTTP协议</strong></p>
<p>响应的时候，做好cookie传回去，<strong>响应头</strong>setCookie:username=zs</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928204006874.png" alt="image-20240928204006874"></p>
<p>浏览器再次请求的时候，<strong>请求头</strong>中cookie:username=zs</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928204020606.png" alt="image-20240928204020606"></p>
<h3 id="cookie使用细节"><a href="#cookie使用细节" class="headerlink" title="cookie使用细节"></a>cookie使用细节</h3><h4 id="存活时间"><a href="#存活时间" class="headerlink" title="存活时间"></a>存活时间</h4><p><strong>默认</strong>存储在浏览器内存中，关闭浏览器会释放内存，销毁cookie</p>
<p>setMaxAge(int seconds) 正数：写入浏览器硬盘，到时间自动删除；负数：写入内存，自动销毁；零：删除对应cookie</p>
<p>30天内免登录</p>
<p>cookie是键值对 </p>
<h4 id="cookie存储中文"><a href="#cookie存储中文" class="headerlink" title="cookie存储中文"></a>cookie存储中文</h4><p>可以把字符串用URL编码</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928205018701.png" alt="image-20240928205018701"></p>
<p>服务端的记忆功能</p>
<p>request.getSession();</p>
<p>set Attribute 存到session域中</p>
<p>get Attribute</p>
<p>session是键值对集合，存储在服务器</p>
<p><strong>Session基于Cookie实现</strong> </p>
<p>如何保证多个浏览器不是同一个session？发送一个sessionID的cookie，作为唯一标识，浏览器请求的时候会带着cookie。响应的时候创建一个session，把浏览器唯一对应的session对象id作为cookie发过去，再次请求的时候带着sessionid作为cookie就能找到对应的session对象去存储</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928210309806.png" alt="image-20240928210309806"></p>
<p>识别sessionid如果已经创建过了就不再创建</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928210431476.png" alt="image-20240928210431476"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928210448553.png" alt="image-20240928210448553"></p>
<h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><h4 id="session-钝化、活化"><a href="#session-钝化、活化" class="headerlink" title="session 钝化、活化"></a>session 钝化、活化</h4><p>钝化：服务器正常关闭，tomcat自动把session存到硬盘</p>
<p>活化：服务器开启，从session文件读取</p>
<p>浏览器关闭后中断会话，session不是同一个</p>
<h4 id="session-销毁"><a href="#session-销毁" class="headerlink" title="session 销毁"></a>session 销毁</h4><ul>
<li>自动销毁web.xml sessionconfig 时间默认为30分钟</li>
<li>手动销毁：登出</li>
</ul>
<h2 id="Cookie-vs-Session"><a href="#Cookie-vs-Session" class="headerlink" title="Cookie vs. Session"></a>Cookie vs. Session</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928220229036.png" alt="image-20240928220229036"></p>
<p>安全性，长期存储</p>
<p>cookie保证用户在未登录情况下的身份识别</p>
<p>session存储用户登录以后的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928225946421.png" alt="image-20240928225946421"></p>
<h3 id="登录系统DEMO"><a href="#登录系统DEMO" class="headerlink" title="登录系统DEMO:"></a>登录系统DEMO:</h3><p>login.jsp页面</p>
<p>登录成功存储用户信息，并且要重定向到另一个brand.jsp页面，两次会话共享信息，考虑安全性，session</p>
<p>登录失败，转发回登录页面，把错误 信息加进request域中，jsp登录页面显示的是错误信息</p>
<p>记住用户登录信息：登录成功并且勾选了复选框（发送复选框的value参数，Object.equals或是”1”.equals（remember））创建username和password的cookie并发送到浏览器。修改login.jsp：拿到请求中的cookies，分别把响应的数据填到页面的username和password中。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928223745507.png" alt="image-20240928223745507"></p>
<h3 id="用户注册DEMO"><a href="#用户注册DEMO" class="headerlink" title="用户注册DEMO:"></a>用户注册DEMO:</h3><p>reg.jsp </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928223916558.png" alt="image-20240928223916558"></p>
<p>if(布尔表达式){</p>
<p>}</p>
<p>return 布尔表达式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928231442349.png" alt="image-20240928231442349"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928231455396.png" alt="image-20240928231455396"></p>
<p>展示验证码：servlet输出的验证码作为img src显示在HTML静态页面上，写js脚本把点击事件设置成重新请求一次，每次请求的路径不同 (?号后面加时间)，防止浏览器缓存</p>
<p>生成验证码和提交注册表单一共需要两次请求，是不同的servlet在处理，所以服务器要在生成的时候将验证码存到session中，提交注册表单的时候再次从session中访问数据看是否一致。存到cookie中会直接被抓取然后攻击，失去了验证码的功能</p>
<p>if else if直接return就不用else了</p>
<p>checkcodeServlet 生成code，输出到自己的输出流中  </p>
<h2 id="Token-Json-Web-Token"><a href="#Token-Json-Web-Token" class="headerlink" title="Token(Json Web Token)"></a>Token(<u>J</u>son <u>W</u>eb <u>T</u>oken)</h2><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/995894#comment">JWT详细讲解(保姆级教程)-阿里云开发者社区 (aliyun.com)</a></p>
<h3 id="token-cookie-session"><a href="#token-cookie-session" class="headerlink" title="token cookie session"></a>token cookie session</h3><h4 id="Cookie-1"><a href="#Cookie-1" class="headerlink" title="Cookie"></a>Cookie</h4><p>本质是键值对，客户端发起请求，服务端响应会把包含着用户信息的set-cookie 加入响应头，客户端收到set-cookie，下次发送请求，请求头中会带着包含相同内容的cookie，服务端只需要根据cookie响应对应用户的资源。</p>
<p>局限：数据直接存放在浏览器端内存，安全性差，</p>
<p>优化：把set-cookie内容除了正常的cookie内容再加一段报文鉴别码，使用服务器自己的私钥进行签名，</p>
<p>优点：存储期限长</p>
<h4 id="Session-1"><a href="#Session-1" class="headerlink" title="Session"></a>Session</h4><p>以cookie为基础，本质是一个对象，每个session可以通过唯一的sessionID进行访问，客户端发起请求，服务端会把包含着sessionID信息的set-cookie响应给客户端，客户端下次发送请求，请求头中会带着包含着sessionID信息的cookie，服务端根据sessionID找到对应的session，响应对应用户的资源</p>
<p>优点：数据完全存储在服务端内存，安全性很高，</p>
<p>缺点：</p>
<p>最重要的是，session只支持单体服务器，session拷贝效率低，</p>
<p>默认不支持跨域名，但是不同域名可能是会共享用户信息的，</p>
<p>因此在集群部署，分布式应用，前后端分离的背景下，session已经不再适用</p>
<h4 id="JsonWebToken"><a href="#JsonWebToken" class="headerlink" title="JsonWebToken"></a>JsonWebToken</h4><p>base64: 将原来的字符串二进制化，然后重新分成每6位一组，6位对应有64个索引，分别对应0-9和所有大小写英文字母</p>
<p>用户信息保存在浏览器端内存，本质就是一条加密字符串。</p>
<h5 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h5><p>RSA—单向陷门函数：加密数字5，公钥是7,33 ，<strong>5</strong>^7^ mod 33 = <mark>14<mark>，解密使用公钥，x^7^ mod 33 = <mark>14<mark> 的数字有无数个，也就无法推算出具体的x，只能穷举。如果有了私钥3,33，<mark>14<mark>^3^ mod 33 = <strong>5</strong> 很容易就能算出原数字5</p>
<p>加密和解密都用同一种算法，但不是逆向。</p>
<p><strong>签名算法：</strong> </p>
<p>HS256：$A+H(A,K)$ 签发和验证都使用同一个密钥，只适用于单体应用。H表示密钥拼接在报文后进行哈希。S表示SHA256</p>
<p>RS256, ES256：$A+D(H(A))$ 签发用私钥，验证用公钥，适合分布式架构，安全性更高。R,E分别表示RSA与ECDSA，S表示SHA256。</p>
<h5 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h5><p>header(base64-encoded).payload(base64-encoded).signature(HMACSHA256-encoded)</p>
<ul>
<li>header 用于定义token类型以及加密算法（非对称），用base64编码，相当于明文</li>
<li>payload 用于装载要传输的用户数据，用base64编码，相当于明文<ul>
<li>附加一些预定义声明</li>
<li>iss: 签发者issuer</li>
<li>sub: jwt所面向的用户subject</li>
<li>aud: 接收jwt的一方audience</li>
<li>iat: jwt的签发时间 issued at</li>
<li>exp: jwt的过期时间，必须大于签发时间  expire</li>
<li>nbf: 定义在什么时间之前，该jwt都是不可用的. not valid before</li>
<li>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击 jwtid</li>
</ul>
</li>
</ul>
<p><code>注意:对于已签名的Token，这些信息虽然受到保护，不会被篡改，但任何人都可以阅读。除非加密，否则不要将机密信息放在 JWT 的有效负载或头元素中。</code> </p>
<ul>
<li>signature = HS256…(header(base64)+payload(base64)+secret)私钥 ，用header指定的算法进行加密，鉴权核心</li>
</ul>
<p>用户请求通过鉴权成功，<strong>服务端通过私钥签发JWT字符串</strong>，通过响应返回给用户，用户后续请求会在请求头中添加一个authorization:token的键值对。</p>
<p>再次请求，鉴权成功，然后将JWT根据secret进行解密，验证此JWT是否有效。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241030152447734.png" alt="image-20241030152447734"></p>
<p>假如其他人偶然间拿到了JWT，然后篡改JWT，服务器拿私钥解密JWT，会发现信息被篡改。</p>
<h1 id="Filter-amp-Listener"><a href="#Filter-amp-Listener" class="headerlink" title="Filter&amp;Listener"></a>Filter&amp;Listener</h1><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>拦截资源请求</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928234937677.png" alt="image-20240928234937677"></p>
<h3 id="入门-2"><a href="#入门-2" class="headerlink" title="入门"></a>入门</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928235049041.png" alt="image-20240928235049041"></p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929000311150.png" alt="image-20240929000311150"></p>
<p>先访问完资源，然后执行放行后的逻辑</p>
<p>放行前对request进行处理，放行后对response进行处理</p>
<h3 id="使用细节-1"><a href="#使用细节-1" class="headerlink" title="使用细节"></a>使用细节</h3><h4 id="拦截路径"><a href="#拦截路径" class="headerlink" title="拦截路径"></a>拦截路径</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929000603427.png" alt="image-20240929000603427"></p>
<p>拦截的是具体的资源，不是说filter访问哪个路径</p>
<h4 id="Filter链"><a href="#Filter链" class="headerlink" title="Filter链"></a>Filter链</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929000822547.png" alt="image-20240929000822547"></p>
<p>执行顺序：类名字符串自然排序</p>
<h4 id="案例：登录验证才可以访问"><a href="#案例：登录验证才可以访问" class="headerlink" title="案例：登录验证才可以访问"></a>案例：登录验证才可以访问</h4><p>第一次请求，没有登录，跳转到登录页面</p>
<p>filter要看是否登录，登录成功就把username pswd存到客户端session中，下一次请求的时候就验证session是否有值，没有值就继续</p>
<p>从服务端获取用户的session，session存储登录密码，如果session</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929011626311.png" alt="image-20240929011626311"></p>
<p>针对某个资源设置filter，第一次访问被拒绝，<strong>转发</strong>到login页面，此时网址不会变化，就会把这个资源的网址缓存成login页面的样式，login成功以后如果再次访问这个资源，会展示login页面，只有刷新一下才能解决这个问题</p>
<h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929121700747.png" alt="image-20240929121700747"></p>
<h1 id="HTML-CSS-JavaScript"><a href="#HTML-CSS-JavaScript" class="headerlink" title="HTML+CSS+JavaScript"></a>HTML+CSS+JavaScript</h1><h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a><span id=ajax>AJAX</span></h1><p>异步JS和XML <strong>A</strong>synchronous <strong>J</strong>avaScript <strong>A</strong>nd <strong>X</strong>ML </p>
<p><strong>AJAX作用1：与服务器交换数据，前后端分离</strong></p>
<ul>
<li>Servlet+JSP开发：HTML是静态的，要想展示动态的数据必须要让servlet根据请求中的参数来手动打印页面（JSP），服务端负担较重</li>
<li>AJAX+HTML: 替换JSP页面 ，AJAX给服务器<strong>发送请求</strong>，<strong>获取服务器响应</strong>的数据，展示给浏览器</li>
</ul>
<p><strong>AJAX作用2：异步交互</strong></p>
<p>不刷新<strong>整个页</strong>面也能与服务器交换数据，更新部分网页，如搜索联想，用户名是否可用校验</p>
<p>用户名按照一定的规则：直接本地编写js脚本即可，如果用户名不能和已有的重复，还应该发送请求，接收服务器响应回来的结果（数据库中是否重名）</p>
<h2 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929161209624.png" alt="image-20240929161209624"></p>
<p>异步操作使 用户可以在等待响应的同时继续与页面互动，这使得应用程序更具响应性</p>
<p>不用刷新整个页面，只跟服务器请求需要的数据，而不是整个页面，AJAX可以减少服务器的负担和网络流量，提高响应速度。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929161455819.png" alt="image-20240929161455819"></p>
<p>URL 全路径，前后端完全分离</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929161832460.png" alt="image-20240929161832460"></p>
<h2 id="异步请求案例"><a href="#异步请求案例" class="headerlink" title="异步请求案例"></a><span id="request">异步请求案例</span></h2><p>现在有这样一个需求，在浏览器填完了一个用户名，要把用户名发送到服务器的某个servlet，servlet根据用户名查询是否重复，并把数据传回到浏览器。</p>
<p>首先应该让失焦事件绑定函数，函数中要查询用户名。</p>
<p>设置 提示重复字句的style属性为不可见（正常情况下不可见）ajax根据传回的数据为true or false，改变 提示重复字句的style属性，如果是，则设置可见，如果否，则设置不可见。</p>
<p>具体流程？可以通过以下步骤：</p>
<h2 id="前端发送请求"><a href="#前端发送请求" class="headerlink" title="前端发送请求"></a>前端发送请求</h2><p>使用 JavaScript（比如 <code>XMLHttpRequest</code> 或 Fetch API）发送请求：</p>
<ul>
<li><strong>GET 方法</strong>（URL 参数字符串）：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>).<span class="property">value</span>;</span><br><span class="line">xhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://example.com/checkUsername?username=&quot;</span> + <span class="built_in">encodeURIComponent</span>(username));</span><br><span class="line">xhttp.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>POST 方法</strong>（请求体）：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>).<span class="property">value</span>;</span><br><span class="line">xhttp.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;http://example.com/checkUsername&quot;</span>);</span><br><span class="line">xhttp.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">xhttp.<span class="title function_">send</span>(<span class="string">&quot;username=&quot;</span> + <span class="built_in">encodeURIComponent</span>(username));</span><br></pre></td></tr></table></figure>

<h3 id="服务器端处理"><a href="#服务器端处理" class="headerlink" title="服务器端处理"></a>服务器端处理</h3><p>在 Servlet 中处理请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="comment">// 查询数据库检查用户名是否重复</span></span><br><span class="line">    <span class="comment">// 返回结果到浏览器</span></span><br><span class="line">    response.setPatameter...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    doGet(request,response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h3><ul>
<li><strong>GET</strong>：参数通过 URL 传递，适合获取数据，但不适合传递敏感信息，因为 URL 可见，且请求长度有限。</li>
<li><strong>POST</strong>：参数通过请求体传递，适合发送大量数据或敏感信息。</li>
</ul>
<p>要探究本质，就要解析他们的**<mark>报文<mark>**  </p>
<p>GET：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /search?query=java&amp;page=2 HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>POST：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /search HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">?query=java&amp;page=2 </span><br></pre></td></tr></table></figure>

<p>这些都是一个个字符串而已，发送的时候设置URL和参数本质上都是拼字符串，然后把整段报文发给服务。Servlet 接收请求，解析报文，拿到参数，仅此而已。填写表单的时候也一样，form标签的action属性就是要发送请求的目标，输入参数，提交的时候，就相当于填写好了目标URL，既然目标确定了。浏览器会解析内容，写好报文，发送给目标，那么浏览器是如何确定要发送给谁呢？浏览器确定请求的目标地址（即请求的 URL）是通过 URL 来实现的。以下是这一过程的基本步骤：以GET请求为例：</p>
<h3 id="目标URL的填写"><a href="#目标URL的填写" class="headerlink" title="目标URL的填写"></a>目标URL的填写</h3><p>用户在浏览器中提交表单（例如，点击“提交”按钮），这会触发一个请求。表单的 <code>action</code> 属性指定了要发送请求的 URL。浏览器会将表单数据编码为查询字符串，并附加到 <code>action</code> URL 后面作为要访问的目标。</p>
<h3 id="解析-URL"><a href="#解析-URL" class="headerlink" title="解析 URL"></a>解析 URL</h3><p>浏览器解析这个 URL，分解成几个部分：</p>
<ul>
<li><strong>协议</strong>：<code>http</code></li>
<li><strong>主机名</strong>：<code>www.example.com</code></li>
<li><strong>路径</strong>：<code>/search</code></li>
<li><strong>查询字符串</strong>：<code>?query=java</code></li>
</ul>
<h3 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h3><p>浏览器会通过 DNS（域名系统）将主机名转换为相应的 IP 地址，以便找到目标服务器。例如，<code>www.example.com</code> 可能会被解析为 <code>192.0.2.1</code>。</p>
<h3 id="建立-TCP-连接"><a href="#建立-TCP-连接" class="headerlink" title="建立 TCP 连接"></a>建立 TCP 连接</h3><p>浏览器与目标服务器建立 TCP 连接，通常使用 HTTP 端口（默认为 80，HTTPS 为 443）。</p>
<h3 id="构造请求报文"><a href="#构造请求报文" class="headerlink" title="构造请求报文"></a>构造请求报文</h3><p>一旦连接建立，浏览器会根据表单数据构造 HTTP 请求报文，包括请求行、请求头和请求体。</p>
<h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>浏览器通过已建立的 TCP 连接，将构造好的请求报文发送到服务器的指定 IP 地址。</p>
<h3 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h3><p>服务器接收到请求后，会根据请求的路径和参数来处理请求，最终返回相应的响应数据。</p>
<p>发出请求实际上就是浏览器访问目标URL</p>
<p>表单：action就是目标URL，如果是get请求，浏览器会将目标url加上参数。随后解析url，得出目标IP，根据这些参数生成请求报文发送到目标IP。</p>
<h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>axios是对js 的封装</p>
<p><a target="_blank" rel="noopener" href="https://www.axios-http.cn/">Axios中文文档 | Axios中文网 (axios-http.cn)</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929192249373.png" alt="image-20240929192249373"></p>
<p>method url data</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929192732304.png" alt="image-20240929192732304"></p>
<p>链式编程</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(url).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">resp</span>)&#123;</span><br><span class="line">    <span class="comment">//具体用响应干什么？</span></span><br><span class="line">&#125;)</span><br><span class="line">axios.<span class="title function_">post</span>(url,data).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">resp</span>)&#123;</span><br><span class="line">    <span class="comment">//具体用响应干什么？</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>resp：</p>
<p>①data :实际响应回来的数据</p>
<p>②headers :响应头信息</p>
<p>③status :响应状态码</p>
<p>④statusText:响应状态信息</p>
<p>特色：自动将data对象序列化为json字符串，再自动将响应数据中的json转回js自定义对象</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929210844535.png" alt="image-20240929210844535"></p>
<p>解构赋值：then({data}) 只取resp的data字段</p>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p><strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation js对象表示法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929194822398.png" alt="image-20240929194822398"></p>
<p>字段名要用双引号括起来，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">    <span class="string">&quot;key1&quot;</span>:value1,</span><br><span class="line">    <span class="string">&quot;key2&quot;</span>:value2</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//json.key1 访问value1</span></span><br><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">    <span class="attr">key1</span>:value1,</span><br><span class="line">    <span class="attr">key2</span>:value2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这两个对象的主要区别在于属性名的引号使用。在第一个对象中，所有属性名都用双引号包围，而在第二个对象中，属性名没有引号。根据 JavaScript 的语法，属性名可以不加引号（如果是有效的标识符），但如果包含特殊字符或空格，就需要加引号。功能上，它们是等价的。</p>
<p>axios发送自定义对象会自动转成json的形式</p>
<h2 id="JSON数据和Java对象转换"><a href="#JSON数据和Java对象转换" class="headerlink" title="JSON数据和Java对象转换"></a>JSON数据和Java对象转换</h2><p>Fastjson 高性能JSON库。</p>
<p>导入fastjson坐标</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line"><span class="comment">//对象tostring</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> JSON.parseObject(user, User.class);</span><br><span class="line"><span class="comment">//解析出对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/json;charset=utf-8&quot;</span>);</span><br><span class="line">response.getWriter().write(jsonString)</span><br></pre></td></tr></table></figure>

<h2 id="案例：增删改查"><a href="#案例：增删改查" class="headerlink" title="案例：增删改查"></a>案例：增删改查</h2><p><strong>查询</strong>：把axios发送请求接收响应数据并打印数据的过程 封装成一个函数，跟onload（brandSelect页面加载完成）绑定。</p>
<p>axios+html 接收servlet响应，打印表格</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929200621197.png" alt="image-20240929200621197"></p>
<p>axios这边接收到json，也就是resp.data 是对象的集合，所以用for循环遍历，由于是打印，所以可以用id锚定表格的标签，每遍历一次就累加字符串一次，最后一起写入表格标签的innerHTML中。</p>
<p><strong>新增品牌</strong>：</p>
<p>表单提交的操作是一个同步请求，同步请求是直接发送参数字段，而且需要重新加载页面才能生效，利用不上js的异步高效性，所以提交按钮应该设置成普通button，进行异步操作</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929203719660.png" alt="image-20240929203719660"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929204058611.png" alt="image-20240929204058611"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929204235548.png" alt="image-20240929204235548"></p>
<p>获取表单数据，字符串直接赋值，复选框的结果用checked表示，因为这是两个复选框，名字都叫status，所以返回的是一个元素数组，对这个数组进行便利，被选中的就把自己的value赋给对象。</p>
<p>axios发送自定义对象会自动转成json的形式，直接把封装好的自定义对象添加到axios的data参数中即可</p>
<p>函数绑定提交按钮的onclick事件，设定js函数把表单填入的内容封装成json对象（即为前面的操作），发送ajax请求给addServlet。</p>
<p><strong>addServlet</strong>处，<u>getParameter不能接收json数据</u>，所以应该用<u>getReader.readLine读取字符串</u>，然后把json字符串转成pojo对象，执行添加操作，返回操作成功与否，作为响应数据发出。</p>
<p>axios接收响应数据，如果操作成功，就跳转到第一步做出来的加载html页面中</p>
<p>增删改用post 查用get </p>
<h1 id="Vue-Servlet-开发"><a href="#Vue-Servlet-开发" class="headerlink" title="Vue+Servlet 开发"></a>Vue+Servlet 开发</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul>
<li><strong>Vue</strong>：前端的JS骨架，model view双向绑定，渲染网页</li>
<li><strong>axios</strong>：AJAX请求发送</li>
<li><strong>Element</strong> <strong>UI</strong>：CSS组件库，基于Vue</li>
</ul>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ul>
<li><strong>Web层</strong>：Servlet调用Service层的方法查询，结果转为JSON，响应JSON数据发给客户端</li>
<li><strong>Service层</strong>：BrandService定义selectAll方法，获取sqlSession对象，调用BrandMapper执行SQL语句</li>
<li><strong>DAO层</strong>：BrandMapper定义selectAll方法，方法体为MyBatis执行某条具体的SQL语句</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002150928236.png" alt="image-20241002150928236"></p>
<h2 id="服务端优化"><a href="#服务端优化" class="headerlink" title="服务端优化"></a>服务端优化</h2><h3 id="Service-优化"><a href="#Service-优化" class="headerlink" title="Service 优化"></a>Service 优化</h3><h4 id="Service-接口定义"><a href="#Service-接口定义" class="headerlink" title="Service 接口定义"></a>Service 接口定义</h4><ul>
<li>定义 <strong>BrandService</strong> 接口：定义一些业务的抽象方法，实现类中实现业务方法，在servlet中创建好业务实现对象，这样就解除了service层和servlet层的耦合性</li>
</ul>
<h4 id="ServiceImpl-接口实现"><a href="#ServiceImpl-接口实现" class="headerlink" title="ServiceImpl 接口实现"></a>ServiceImpl 接口实现</h4><ul>
<li>在实现类中，先创建好唯一的的factory工厂，然后在方法中开启sqlSession，执行SQL语句</li>
</ul>
<h4 id="优化结果"><a href="#优化结果" class="headerlink" title="优化结果"></a>优化结果</h4><ul>
<li><strong>UserService:</strong></li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164617150.png" alt="image-20241002164617150"></li>
<li><strong>UserServiceImpl:</strong></li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164523529.png" alt="image-20241002164523529"></li>
</ul>
<h3 id="Servlet-优化"><a href="#Servlet-优化" class="headerlink" title="Servlet 优化"></a>Servlet 优化</h3><h4 id="业务实现类的创建"><a href="#业务实现类的创建" class="headerlink" title="业务实现类的创建"></a>业务实现类的创建</h4><p>为了增强项目的组织度，会进行业务整合，在BrandServlet中，创建一个BrandService的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BrandServlet</span>&#123;</span><br><span class="line">	<span class="type">BrandService</span> <span class="variable">brandService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrandServiceImpl1</span>();</span><br><span class="line">    <span class="comment">//调用service的方法</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="业务功能整合"><a href="#业务功能整合" class="headerlink" title="业务功能整合"></a>业务功能整合</h4><p>一个实体类的一个功能就要新创建一个Servlet，不易管理，要把一个实体类的所有功能都放在一个servlet中。（BrandServlet，UserServlet）通过/brand/*   /user/*来访问上述两个servlet。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002135939524.png" alt="image-20241002135939524"></p>
<ul>
<li>如图，原先<code>HttpServlet</code>的<code>service</code>方法根据请求的方式（<code>getMethod</code>）进行方法的分发（<code>doGe</code>t或<code>doPost</code>）</li>
<li>现在要根据请求的路径来进行方法的分发，因此<code>BrandServlet</code>不能直接继承<code>HttpServlet</code>，要创建一个<code>BaseServlet</code>继承<code>HttpServlet</code>，重写其<code>service</code>方法，根据路径分发方法。同理<code>UserServlet</code>也直接继承<code>Base</code></li>
<li>获取到请求路径的最后一部分（最后一个<code>/</code>之后的内容）就是请求的方法名</li>
<li>方法名称有了还要找<code>对应servlet</code>的字节码文件，<code>baseServlet</code>没有<code>@WebServlet</code>注解，也就不会直接访问了，到时候被访问的应该是<code>BrandServlet</code>和<code>UserServlet</code>这两个子类，子类继承父类的<code>service</code>方法，所以<code>service</code>方法中的<code>this.getClass</code>就能理所应当地拿到子类的字节码文件。</li>
<li>因为<code>BrandServlet</code>和<code>UserServlet </code>都是要先执行<code>service(req,resp)</code>方法，接收<code>request</code>参数和<code>response</code>参数，如果要执行具体的<code>selectAll</code>业务方法，就要在反射调用方法的时候把参数加上，同时在<code>子类servlet</code>中，业务方法接受的参数全部统一成<code>req</code>和<code>resp</code>。</li>
</ul>
<p>如此一来，就能实现：</p>
<ol>
<li>访问<code>/brand/selectAll</code>路径，</li>
<li>调用重写过后的<code>service(HttpServletRequest req,HttpServletResponse resp)</code> 能获取方法名和字节码文件</li>
<li>根据方法名和参数类型（<code>methodName, HttpServletRequest req.class, HttpServletResponse.class</code>）获取Method对象，</li>
<li><code>method.invoke(this, req, resp)</code>，实现业务整合</li>
</ol>
<h4 id="优化结果-1"><a href="#优化结果-1" class="headerlink" title="优化结果"></a>优化结果</h4><ul>
<li><strong>BaseServlet:</strong></li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164451103.png" alt="image-20241002164451103"></li>
<li><strong>UserServlet:</strong> </li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164355800.png" alt="image-20241002164355800"></li>
</ul>
<h3 id="优化后的后端结构"><a href="#优化后的后端结构" class="headerlink" title="优化后的后端结构"></a>优化后的后端结构</h3><p>后端的DAO, Service, Web层分开 各司其职，减少了耦合度</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164240142.png" alt="image-20241002164240142" style="zoom: 50%;" />



<h2 id="其他细节"><a href="#其他细节" class="headerlink" title=" 其他细节 "></a><span id="mybatis"> 其他细节 </span></h2><h3 id="MyBatis-模糊查询"><a href="#MyBatis-模糊查询" class="headerlink" title="MyBatis 模糊查询"></a>MyBatis 模糊查询</h3><h4 id="39-password-39-不行？-39-password-39-行？"><a href="#39-password-39-不行？-39-password-39-行？" class="headerlink" title="&#39;%#{password}%&#39;不行？&#39;%${password}%&#39;行？"></a><code>&#39;%#&#123;password&#125;%&#39;</code>不行？<code>&#39;%$&#123;password&#125;%&#39;</code>行？</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002225509824.png" alt="image-20241002225509824"></p>
<p>${password}就是最简单的文本替换，直接拼接字符串，也不会类型转换（输入参数<code>that</code>会直接拼接成<code>and password like that</code> 很显然少了引号）连SQL都无法注入<code>&#39; OR &#39;1&#39; = &#39;1</code> <code>and password like &#39; OR &#39;1&#39; = &#39;1</code> （语法错误）自然，模糊匹配就变成<code>&#39;%that%&#39;</code>了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002230031380.png" alt="image-20241002230031380"></p>
<p>预编译占位符#{password}会把整个password转换成字符串，输入参数<code>&#39; OR &#39;1&#39; = &#39;1</code>会帮你转义成<code>\&#39; OR \&#39;1\&#39; = \&#39;1</code> 还会贴心地给两边加上引号<code>and password like &#39;\&#39; OR \&#39;1\&#39; = \&#39;1&#39;</code></p>
<p>因此，#{password}本身就自带引号，模糊匹配会解析成<code>&#39;%&#39;that&#39;%&#39;</code> 完全的语法错误。</p>
<h4 id="应该怎么用"><a href="#应该怎么用" class="headerlink" title="应该怎么用"></a>应该怎么用</h4><p>既然返回的是带引号的字符串，可以用拼接字符串函数，也可以用空格把这三个字符串分开</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002231938685.png" alt="image-20241002231938685"></p>
<h3 id="MyBatis-分页查询"><a href="#MyBatis-分页查询" class="headerlink" title="MyBatis 分页查询"></a>MyBatis 分页查询</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002234502508.png" alt="image-20241002234502508"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003001119464.png" alt="image-20241003001119464"></p>
<h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><p>分页查询要两个参数，这一页从哪一行开始和每页显示的条数</p>
<p>前端传递给后台 当前页码和每页显示条数，(当前页码-1)*每行显示条数就是这一页开始的一行</p>
<p>PageBean封装 总条数 和 这一页的查询结果List&lt;User&gt; </p>
<p>list用于显示，总条数返回给前端</p>
<h4 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h4><p>前端刷新表格的操作：发出自己的两个属性，收到PageBean中的rows和totalCount</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003003901994.png" alt="image-20241003003901994"></p>
<p>前端点击页码的操作，设置自身的两个属性，同时刷新表格</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003004044018.png" alt="image-20241003004044018"></p>
<h3 id="插入重复的键——事务回滚"><a href="#插入重复的键——事务回滚" class="headerlink" title="插入重复的键——事务回滚"></a>插入重复的键——事务回滚</h3><p>username是unique 且 not null 的，所以不能重复，在提交表单的时候，如果输入重复数据，就会导致事务提交失败，这是就会出现异常，<strong>如果出现异常不处理</strong>，会一直导致故障。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003005454880.png" alt="image-20241003005454880"></p>
<p>使用try catch 如果出现异常，就调用rollback，同时return false，响应</p>
<p>前端收到响应，会根据结果弹出提示，成功或者失败</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003005659475.png" alt="image-20241003005659475"></p>
<h3 id="优化后的前端结构"><a href="#优化后的前端结构" class="headerlink" title="优化后的前端结构"></a>优化后的前端结构</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003004606856.png" alt="image-20241003004606856"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003004711700.png" alt="image-20241003004711700"></p>
<p>加入了表格loading动画，刷新按钮，以及删除和插入的结果提示</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/08/31/spring-mp+lombok/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/31/spring-mp+lombok/" class="post-title-link" itemprop="url">MyBatis-Plus</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-31 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-31T00:00:00+08:00">2024-08-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-08 13:24:02" itemprop="dateModified" datetime="2025-05-08T13:24:02+08:00">2025-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web-development/" itemprop="url" rel="index"><span itemprop="name">web development</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>大家在日常开发中应该能发现，单表的CRUD功能代码重复度很高，也没有什么难度。而这部分代码量往往比较大，开发起来比较费时。</p>
<p>因此，目前企业中都会使用一些组件来简化或省略单表的CRUD开发工作。目前在国内使用较多的一个组件就是MybatisPlus.</p>
<p>当然，MybatisPlus不仅仅可以简化单表操作，而且还对Mybatis的功能有很多的增强。可以让我们的开发更加的简单，高效。</p>
<p>通过今天的学习，我们要达成下面的目标：</p>
<ul>
<li>能利用MybatisPlus实现基本的CRUD</li>
<li>会使用条件构建造器构建查询和更新语句</li>
<li>会使用MybatisPlus中的常用注解</li>
<li>会使用MybatisPlus处理枚举、JSON类型字段</li>
<li>会使用MybatisPlus实现分页</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://b11et3un53m.feishu.cn/wiki/PsyawI04ei2FQykqfcPcmd7Dnsc">day01-MybatisPlus - 飞书云文档</a> </p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/08/31/spring-mp+lombok/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/08/15/math-hash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/15/math-hash/" class="post-title-link" itemprop="url">哈希函数的工程应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-15 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-15T00:00:00+08:00">2024-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 11:25:31" itemprop="dateModified" datetime="2025-04-27T11:25:31+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/math/" itemprop="url" rel="index"><span itemprop="name">math</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">散列函数 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<h2 id="Hash-是什么"><a href="#Hash-是什么" class="headerlink" title="Hash 是什么"></a>Hash 是什么</h2><p>哈希（Hash）的原理是通过一种<strong>特定的函数</strong>，将任意长度的输入（也称为键）<strong>映射</strong>为固定长度的输出（称为哈希值、哈希码或散列值）。这种函数称为<strong>哈希函数</strong>或<strong>散列函数</strong>。哈希主要用于快速查找、数据完整性验证等方面，下面具体解释其原理和应用：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/08/15/math-hash/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default/">1</a><span class="space">&hellip;</span><a class="page-number" href="/default/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/default/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/default/page/8/">8</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">碎梦</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/scatteredream" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
