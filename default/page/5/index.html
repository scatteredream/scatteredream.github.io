<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Arvo:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scatteredream.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="scatteredream&#39;s blog">
<meta property="og:url" content="http://scatteredream.github.io/default/page/5/index.html">
<meta property="og:site_name" content="scatteredream&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="碎梦">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://scatteredream.github.io/default/page/5/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default/page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>scatteredream's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">scatteredream's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="碎梦"
      src="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
  <p class="site-author-name" itemprop="name">碎梦</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">170</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/08/11/redis-quickstart/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/11/redis-quickstart/" class="post-title-link" itemprop="url">Redis 使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-11 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-11T00:00:00+08:00">2024-08-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 13:26:25" itemprop="dateModified" datetime="2025-04-27T13:26:25+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="初识Redis"><a href="#初识Redis" class="headerlink" title="初识Redis"></a>初识Redis</h1><p>Redis是一种键值型的NoSql数据库，这里有两个关键字：</p>
<ul>
<li><p>键值型</p>
</li>
<li><p>NoSql</p>
</li>
</ul>
<p>其中<strong>键值型</strong>，是指Redis中存储的数据都是以key、value对的形式存储，而value的形式多种多样，可以是字符串、数值、甚至json：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/6U1Rhxo.png" alt="image-20220502190959608"></p>
<p>而NoSql则是相对于传统关系型数据库而言，有很大差异的一种数据库。</p>
<h2 id="认识NoSQL"><a href="#认识NoSQL" class="headerlink" title="认识NoSQL"></a>认识NoSQL</h2><p><strong>NoSql</strong>可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为<strong>非关系型数据库</strong>。</p>
<h3 id="结构化与非结构化"><a href="#结构化与非结构化" class="headerlink" title="结构化与非结构化"></a>结构化与非结构化</h3><p>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名、字段数据类型、字段约束等等信息，插入的数据必须遵守这些约束：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/4tUgFo6.png"></p>
<p>而NoSql则对数据库格式没有严格约束，往往形式松散，自由。</p>
<p>可以是键值型：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/GdqOSsj.png"></p>
<p>也可以是文档型：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/zBBQfcc.png"></p>
<p>甚至可以是图格式：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/zBnKxWf.png"></p>
<h3 id="关联和非关联"><a href="#关联和非关联" class="headerlink" title="关联和非关联"></a>关联和非关联</h3><p>传统数据库的表与表之间往往存在关联，例如外键：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/tXYSl5x.png"></p>
<p>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  name<span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  orders<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	 id<span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;荣耀6&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">4999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	 id<span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;小米11&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">3999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。</p>
<h3 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h3><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；</p>
<p>而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/AzaHOTF.png"></p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>传统关系型数据库能满足事务ACID的原则。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/J1MqOJM.png"></p>
<p>而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>除了上述四点以外，在存储方式、扩展性、查询性能上关系型与非关系型也都有着显著差异，总结如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/kZP40dQ.png"></p>
<ul>
<li>存储方式<ul>
<li>关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响</li>
<li>非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些</li>
</ul>
</li>
</ul>
<ul>
<li>扩展性<ul>
<li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li>
<li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li>
<li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li>
</ul>
</li>
</ul>
<h2 id="认识Redis"><a href="#认识Redis" class="headerlink" title="认识Redis"></a>认识Redis</h2><p>Redis诞生于2009年全称是<strong>Re</strong>mote  <strong>D</strong>ictionary <strong>S</strong>erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p>
<p><strong>特征</strong>：</p>
<ul>
<li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li>
<li>单线程，每个命令具备原子性</li>
<li>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</li>
<li>支持数据持久化</li>
<li>支持主从集群、分片集群</li>
<li>支持多语言客户端</li>
</ul>
<p><strong>作者</strong>：Antirez</p>
<p>Redis的官方网站地址：<a target="_blank" rel="noopener" href="https://redis.io/">https://redis.io/</a></p>
<h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><p>大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis.</p>
<p>此处选择的Linux版本为CentOS 7.</p>
<h3 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a>依赖库</h3><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure>



<h3 id="上传安装包并解压"><a href="#上传安装包并解压" class="headerlink" title="上传安装包并解压"></a>上传安装包并解压</h3><p>然后将课前资料提供的Redis安装包上传到虚拟机的任意目录：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/SyjanS5.png"></p>
<p>例如，我放到了/usr/local/src 目录：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/01DTNCf.png"></p>
<p>解压缩：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure>

<p>解压后：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/8V6zvCD.png" alt="image-20211211080339076"></p>
<p>进入redis目录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-6.2.6</span><br></pre></td></tr></table></figure>



<p>运行编译命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>如果没有出错，应该就安装成功了。</p>
<p>默认的安装路径是在 <code>/usr/local/bin</code>目录下：</p>
<p><img src="https://i.imgur.com/YSxkGm7.png"></p>
<p>该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p>
<ul>
<li>redis-cli：是redis提供的命令行客户端</li>
<li>redis-server：是redis的服务端启动脚本</li>
<li>redis-sentinel：是redis的哨兵启动脚本</li>
</ul>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>redis的启动方式有很多种，例如：</p>
<ul>
<li>默认启动</li>
<li>指定配置启动</li>
<li>开机自启</li>
</ul>
<h3 id="默认启动"><a href="#默认启动" class="headerlink" title="默认启动"></a>默认启动</h3><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/v7xWsqC.png"></p>
<p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p>
<h3 id="指定配置启动"><a href="#指定配置启动" class="headerlink" title="指定配置启动"></a>指定配置启动</h3><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20211211082225509.png" alt="image-20211211082225509"></p>
<p>我们先将这个配置文件备份一份：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure>



<p>然后修改redis.conf文件中的一些配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes </span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123321</span></span><br></pre></td></tr></table></figure>



<p>Redis的其它常见配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">.</span></span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line"><span class="attr">maxmemory</span> <span class="string">512mb</span></span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure>



<p>启动Redis：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure>



<p>停止服务：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span></span><br><span class="line">redis-cli -u 123321 shutdown</span><br></pre></td></tr></table></figure>



<h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><p>我们也可以通过配置来实现开机自启。</p>
<p>首先，新建一个系统服务文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>



<p>然后重载系统服务：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>



<p>现在，我们可以用下面这组命令来操作redis了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure>



<p>执行下面的命令，可以让redis开机自启：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure>



<h2 id="Redis桌面客户端"><a href="#Redis桌面客户端" class="headerlink" title="Redis桌面客户端"></a>Redis桌面客户端</h2><p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p>
<ul>
<li>命令行客户端</li>
<li>图形化桌面客户端</li>
<li>编程客户端</li>
</ul>
<h3 id="Redis命令行客户端"><a href="#Redis命令行客户端" class="headerlink" title="Redis命令行客户端"></a>Redis命令行客户端</h3><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure>

<p>其中常见的options有：</p>
<ul>
<li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li>
<li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li>
<li><code>-a 123321</code>：指定redis的访问密码 </li>
</ul>
<p>其中的commonds就是Redis的操作命令，例如：</p>
<ul>
<li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li>
</ul>
<p>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/OYYWPNo.png"></p>
<h3 id="图形化桌面客户端"><a href="#图形化桌面客户端" class="headerlink" title="图形化桌面客户端"></a>图形化桌面客户端</h3><p>GitHub上的大神编写了Redis的图形化桌面客户端，地址：<a target="_blank" rel="noopener" href="https://github.com/uglide/RedisDesktopManager">https://github.com/uglide/RedisDesktopManager</a></p>
<p>不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。</p>
<p>在下面这个仓库可以找到安装包：<a target="_blank" rel="noopener" href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在课前资料中可以找到Redis的图形化桌面客户端：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/BZ4Agbi.png"></p>
<p>解压缩后，运行安装程序即可安装：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/hguGHbX.png"></p>
<p>安装完成后，在安装目录下找到rdm.exe文件：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/hwK5LQ8.png"></p>
<p>双击即可运行：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/6hUqslY.png"></p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>点击左上角的<code>连接到Redis服务器</code>按钮：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/9qTGyoN.png"></p>
<p>在弹出的窗口中填写Redis服务信息：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/DshNnKC.png"></p>
<p>点击确定后，在左侧菜单会出现这个链接：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/A2cOm7Q.png"></p>
<p>点击即可建立连接了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ja8Fd9s.png"></p>
<p>Redis默认有16个仓库，编号从0至15.  通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p>
<p>如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择 0号库</span></span><br><span class="line"><span class="keyword">select</span> 0</span><br></pre></td></tr></table></figure>



<h1 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a>Redis常见命令</h1><p>Redis是典型的key-value数据库，key一般是字符串，而value包含很多不同的数据类型：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/8tli2o9.png"></p>
<p>Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ <a target="_blank" rel="noopener" href="https://redis.io/commands">https://redis.io/commands </a>）可以查看到不同的命令：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/5Lcr3BE.png"></p>
<p>不同类型的命令称为一个group，我们也可以通过help命令来查看各种不同group的命令：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/suevOIR.png"></p>
<p>接下来，我们就学习常见的五种基本数据类型的相关命令。</p>
<h2 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h2><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p>
<ul>
<li>KEYS：查看符合模板的所有key</li>
<li>DEL：删除一个指定的key</li>
<li>EXISTS：判断key是否存在</li>
<li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li>
<li>TTL：查看一个KEY的剩余有效期</li>
</ul>
<p>通过help [command] 可以查看一个命令的具体用法，例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看keys命令的帮助信息：</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> keys</span><br><span class="line"></span><br><span class="line">KEYS pattern</span><br><span class="line">summary: Find all keys matching the given pattern</span><br><span class="line">since: 1.0.0</span><br><span class="line">group: generic</span><br></pre></td></tr></table></figure>



<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p>
<p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p>
<ul>
<li>string：普通字符串</li>
<li>int：整数类型，可以做自增、自减操作</li>
<li>float：浮点类型，可以做自增、自减操作</li>
</ul>
<p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/VZqpv73.png"></p>
<h3 id="String的常见命令"><a href="#String的常见命令" class="headerlink" title="String的常见命令"></a>String的常见命令</h3><p>String的常见命令有：</p>
<ul>
<li>SET：添加或者修改已经存在的一个String类型的键值对</li>
<li>GET：根据key获取String类型的value</li>
<li>MSET：批量添加多个String类型的键值对</li>
<li>MGET：根据多个key获取多个String类型的value</li>
<li>INCR：让一个整型的key自增1</li>
<li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li>
<li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li>
<li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li>
<li>SETEX：添加一个String类型的键值对，并且指定有效期</li>
</ul>
<h3 id="Key结构"><a href="#Key结构" class="headerlink" title="Key结构"></a>Key结构</h3><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p>
<p>例如，需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p>
<p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p>
<p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目名:业务名:类型:id</span><br></pre></td></tr></table></figure>

<p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。这样以来，我们就可以把不同类型的数据区分开了。从而避免了key的冲突问题。</p>
<p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p>
<ul>
<li><p>user相关的key：<strong>heima:user:1</strong></p>
</li>
<li><p>product相关的key：<strong>heima:product:1</strong></p>
</li>
</ul>
<p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p>
<table>
<thead>
<tr>
<th><strong>KEY</strong></th>
<th><strong>VALUE</strong></th>
</tr>
</thead>
<tbody><tr>
<td>heima:user:1</td>
<td>{“id”:1,  “name”: “Jack”, “age”: 21}</td>
</tr>
<tr>
<td>heima:product:1</td>
<td>{“id”:1,  “name”: “小米11”, “price”: 4999}</td>
</tr>
</tbody></table>
<p>并且，在Redis的桌面客户端中，还会以相同前缀作为层级结构，让数据看起来层次分明，关系清晰：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/InWMfeD.png"></p>
<h2 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h2><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p>
<p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/x2zDBjf.png"></p>
<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/VF2EPt0.png"></p>
<p>Hash的常见命令有：</p>
<ul>
<li><p>HSET key field value：添加或者修改hash类型key的field的值</p>
</li>
<li><p>HGET key field：获取一个hash类型key的field的值</p>
</li>
<li><p>HMSET：批量添加多个hash类型key的field的值</p>
</li>
<li><p>HMGET：批量获取多个hash类型key的field的值</p>
</li>
<li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p>
</li>
<li><p>HKEYS：获取一个hash类型的key中的所有的field</p>
</li>
<li><p>HINCRBY:让一个hash类型key的字段值自增并指定步长</p>
</li>
<li><p>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</p>
</li>
</ul>
<h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p>
<p>特征也与LinkedList类似：</p>
<ul>
<li>有序</li>
<li>元素可以重复</li>
<li>插入和删除快</li>
<li>查询速度一般</li>
</ul>
<p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p>
<p>List的常见命令有：</p>
<ul>
<li>LPUSH key element … ：向列表左侧插入一个或多个元素</li>
<li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li>
<li>RPUSH key element … ：向列表右侧插入一个或多个元素</li>
<li>RPOP key：移除并返回列表右侧的第一个元素</li>
<li>LRANGE key star end：返回一段角标范围内的所有元素</li>
<li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li>
</ul>
<h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p>
<ul>
<li><p>无序</p>
</li>
<li><p>元素不可重复</p>
</li>
<li><p>查找快</p>
</li>
<li><p>支持交集、并集、差集等功能</p>
</li>
</ul>
<p>Set的常见命令有：</p>
<ul>
<li>SADD key member … ：向set中添加一个或多个元素</li>
<li>SREM key member … : 移除set中的指定元素</li>
<li>SCARD key： 返回set中元素的个数</li>
<li>SISMEMBER key member：判断一个元素是否存在于set中</li>
<li>SMEMBERS：获取set中的所有元素</li>
<li>SINTER key1 key2 … ：求key1与key2的交集</li>
</ul>
<p>例如两个集合：s1和s2:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ha8x86R.png"></p>
<p>求交集：SINTER s1 s2</p>
<p>求s1与s2的不同：SDIFF s1 s2</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/L9vTv2X.png"></p>
<p>练习：</p>
<ol>
<li>将下列数据用Redis的Set集合来存储：</li>
</ol>
<ul>
<li>张三的好友有：李四、王五、赵六</li>
<li>李四的好友有：王五、麻子、二狗</li>
</ul>
<ol start="2">
<li>利用Set的命令实现下列功能：</li>
</ol>
<ul>
<li>计算张三的好友有几人</li>
<li>计算张三和李四有哪些共同好友</li>
<li>查询哪些人是张三的好友却不是李四的好友</li>
<li>查询张三和李四的好友总共有哪些人</li>
<li>判断李四是否是张三的好友</li>
<li>判断张三是否是李四的好友</li>
<li>将李四从张三的好友列表中移除</li>
</ul>
<h2 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个<strong>score</strong>属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p>
<p>SortedSet具备下列特性：</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p>
<p>SortedSet的常见命令有：</p>
<ul>
<li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li>
<li>ZREM key member：删除sorted set中的一个指定元素</li>
<li>ZSCORE key member : 获取sorted set中的指定元素的score值</li>
<li>ZRANK key member：获取sorted set 中的指定元素的排名</li>
<li>ZCARD key：获取sorted set中的元素个数</li>
<li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li>
<li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li>
<li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li>
<li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li>
<li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li>
</ul>
<p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p>
<ul>
<li><p><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</p>
</li>
<li><p><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</p>
</li>
</ul>
<p>REVERSE</p>
<p>练习题：</p>
<p>将班级的下列学生得分存入Redis的SortedSet中：</p>
<p>Jack 85, Lucy 89, Rose 82, Tom 95, Jerry 78, Amy 92, Miles 76</p>
<p>并实现下列功能：</p>
<ul>
<li>删除Tom同学</li>
<li>获取Amy同学的分数</li>
<li>获取Rose同学的排名</li>
<li>查询80分以下有几个学生</li>
<li>给Amy同学加2分</li>
<li>查出成绩前3名的同学</li>
<li>查出成绩80分以下的所有同学</li>
</ul>
<p>range 分数条件 </p>
<p>count 分数条件</p>
<h1 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h1><p>在Redis官网中提供了各种语言的客户端，地址：<a target="_blank" rel="noopener" href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/9f68ivq.png"></p>
<p>其中Java客户端也包含很多：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220609102817435-165735883948534.png" alt="image-20220609102817435"></p>
<p>标记为*的就是推荐使用的java客户端，包括：</p>
<ul>
<li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。</li>
<li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。</li>
</ul>
<h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>Jedis的官网地址： <a target="_blank" rel="noopener" href="https://github.com/redis/jedis">https://github.com/redis/jedis</a></p>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>我们先来个快速入门：</p>
<p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jedis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>建立连接</p>
<p>新建一个单元测试类，内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.建立连接</span></span><br><span class="line">    <span class="comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span></span><br><span class="line">    jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">    <span class="comment">// 2.设置密码</span></span><br><span class="line">    jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.选择库</span></span><br><span class="line">    jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 存入数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 插入hash数据</span></span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取</span></span><br><span class="line">    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>释放资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.jedis.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig, <span class="string">&quot;192.168.150.101&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>, <span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心线程数 线程最大数 多余线程自动销毁时间 多余线程自动销毁时间单位 阻塞队列BlockingQueue  拒绝策略abortPolicy 线程工厂</p>
<h2 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p>
<ul>
<li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li>
<li>提供了RedisTemplate统一API来操作Redis</li>
<li>支持Redis的发布订阅模型</li>
<li>支持Redis哨兵和Redis集群</li>
<li>支持基于Lettuce的响应式编程</li>
<li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li>
<li>支持基于Redis的JDKCollection实现</li>
</ul>
<p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/UFlNIV0.png"></p>
<h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><p>SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单。</p>
<p>首先，新建一个maven项目，然后按照下面步骤执行：</p>
<h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redis-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>redis-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Jackson依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="配置Redis"><a href="#配置Redis" class="headerlink" title="配置Redis"></a>配置Redis</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br></pre></td></tr></table></figure>



<h4 id="注入RedisTemplate"><a href="#注入RedisTemplate" class="headerlink" title="注入RedisTemplate"></a>注入RedisTemplate</h4><p>因为有了SpringBoot的自动装配，我们可以拿来就用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="编写测试"><a href="#编写测试" class="headerlink" title="编写测试"></a>编写测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate edisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入一条String数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取string数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h3><p>RedisTemplate可以接收任意Object作为值写入Redis：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/OEMcbuu.png"></p>
<p>一种方法，redistemplate指定泛型，</p>
<p>另外一种，Redis</p>
<p>只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/5FjtWk5.png"></p>
<p>缺点：</p>
<ul>
<li>可读性差</li>
<li>内存占用较大</li>
</ul>
<p>我们可以自定义RedisTemplate的序列化方式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> </span><br><span class="line">            							<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/XOAq3cN.png"></p>
<p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</p>
<h3 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h3><p>为了节省内存空间，我们可以不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Ip9TKSY.png"></p>
<p>因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis了。</p>
<p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/zXH6Qn6.png"></p>
<p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="comment">// JSON序列化工具</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;虎哥&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 手动序列化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">    <span class="comment">// 手动反序列化</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="OperationsForHash"><a href="#OperationsForHash" class="headerlink" title="OperationsForHash"></a>OperationsForHash</h3><p>entries(key) 所有键值对</p>
<p>keys(key) key的所有field</p>
<p>values(key)key的所有value</p>
<p>put(key,field,value)</p>
<p>get(key,field)</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/07/25/mvn%20xml%20mybatis%20jdbc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/07/25/mvn%20xml%20mybatis%20jdbc/" class="post-title-link" itemprop="url">JDBC MyBatis XML Maven</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-25 00:00:00" itemprop="dateCreated datePublished" datetime="2024-07-25T00:00:00+08:00">2024-07-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 16:12:46" itemprop="dateModified" datetime="2025-04-27T16:12:46+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web-development/" itemprop="url" rel="index"><span itemprop="name">web development</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p>标记语言 e<strong>X</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage</p>
<p>自闭合标签 ：标签不包含任何内容可以简化为<code>&lt;br/&gt;</code> </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/XML">XML - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/xml/xml-tutorial.html">XML 教程 | 菜鸟教程 (runoob.com)</a> </p>
<p><strong>XML</strong>（可扩展标记语言，Extensible Markup Language）的核心语法主要用于描述结构化数据。XML 语法非常严格，但也因此具有良好的可读性和可扩展性。以下是 <strong>XML</strong> 的一些重要核心语法规则和概念，它们是理解和正确编写 XML 文档的基础：</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><hr>
<p><strong>元素（Element）</strong></p>
<ul>
<li><strong>元素是 XML 文档的基本构建块</strong>。每个元素有一个<strong>开始标签</strong>和一个<strong>结束标签</strong>，或是自闭合的标签。</li>
</ul>
<p>语法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element</span>&gt;</span>content<span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>开始标签</strong>：<code>&lt;element&gt;</code></li>
<li><strong>结束标签</strong>：<code>&lt;/element&gt;</code></li>
<li><strong>自闭合标签</strong>：<code>&lt;element /&gt;</code></li>
</ul>
<p>元素之间可以嵌套：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span>content<span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>规则：</p>
<ul>
<li>元素名称必须区分大小写。<code>&lt;Element&gt;</code> 与 <code>&lt;element&gt;</code> 是不同的标签。</li>
<li>标签名称不能以数字或特殊符号开头，通常使用字母、数字和某些符号（如 <code>_</code>、<code>-</code>）。</li>
<li>标签必须要有匹配的结束标签，或是用自闭合标签。</li>
</ul>
<hr>
<p><strong>属性（Attributes）</strong></p>
<ul>
<li><strong>属性</strong>为元素提供额外的信息。属性位于开始标签的内部，使用键值对表示，且值必须使用双引号或单引号包裹。</li>
</ul>
<p>语法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element</span> <span class="attr">attribute</span>=<span class="string">&quot;value&quot;</span>&gt;</span>content<span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element</span> <span class="attr">attribute</span>=<span class="string">&quot;value&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>规则：</p>
<ul>
<li>一个元素可以有多个属性，属性的名称必须唯一。</li>
<li>属性值必须用引号包裹（双引号或单引号均可）。</li>
</ul>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">title</span>=<span class="string">&quot;XML Guide&quot;</span> <span class="attr">author</span>=<span class="string">&quot;John Doe&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>声明（XML Declaration）</strong></p>
<ul>
<li>XML 文档通常以声明开头，定义了 XML 版本和编码格式。虽然声明是可选的，但建议在每个 XML 文件开头声明。</li>
</ul>
<p>语法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>version</code>：指定 XML 版本，通常为 <code>1.0</code> 或 <code>1.1</code>。</li>
<li><code>encoding</code>：指定字符编码，通常为 <code>UTF-8</code>。</li>
</ul>
<hr>
<p><strong>注释（Comments）</strong></p>
<ul>
<li><strong>注释</strong>用于对 XML 文档进行说明或标注，注释不会被解析器处理。</li>
</ul>
<p>语法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是一个注释 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>规则：</p>
<ul>
<li>注释不能嵌套，且不能出现在声明之前。</li>
<li>注释内容不能包含 <code>--</code> 连字符。</li>
</ul>
<hr>
<p><strong>CDATA（Character Data，字符数据）</strong></p>
<ul>
<li><strong>CDATA</strong> 区域用于包含原样保留的字符数据。它告诉 XML 解析器不要处理其中的内容为标签或实体。通常用于嵌入包含特殊符号（如 <code>&lt;</code>、<code>&amp;</code>）的文本数据，例如 HTML 代码片段。</li>
</ul>
<p>语法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;![CDATA[</span><br><span class="line">    &lt;content&gt; 这里的内容将不会被解析为标签 &lt;/content&gt;</span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure>

<p>规则：</p>
<ul>
<li>CDATA 区块中的内容不会被解析器处理，即使它包含 <code>&lt;</code>、<code>&gt;</code>、<code>&amp;</code> 等特殊字符。</li>
</ul>
<hr>
<p><strong>实体引用（Entities）</strong></p>
<ul>
<li><strong>实体</strong>用于替代特殊字符或常用的短字符串。常见的实体包括：<code>&amp;amp;</code>、<code>&amp;lt;</code>、<code>&amp;gt;</code>、<code>&amp;apos;</code> 和 <code>&amp;quot;</code>。</li>
</ul>
<p>语法：</p>
<ul>
<li><strong>特殊符号的实体引用</strong>：<ul>
<li><code>&amp;lt;</code> 表示 <code>&lt;</code></li>
<li><code>&amp;gt;</code> 表示 <code>&gt;</code></li>
<li><code>&amp;amp;</code> 表示 <code>&amp;</code></li>
<li><code>&amp;apos;</code> 表示 <code>&#39;</code></li>
<li><code>&amp;quot;</code> 表示 <code>&quot;</code></li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>This is <span class="symbol">&amp;lt;</span>important<span class="symbol">&amp;gt;</span> content <span class="symbol">&amp;amp;</span> data<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此 XML 中的内容表示为 <code>This is &lt;important&gt; content &amp; data</code>。</p>
<hr>
<p><strong>命名空间（Namespaces）</strong></p>
<ul>
<li><strong>命名空间</strong>用于避免不同 XML 文档中的元素或属性发生冲突，尤其在合并两个不同 XML 数据集时更为重要。</li>
</ul>
<p>语法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element</span> <span class="attr">xmlns:prefix</span>=<span class="string">&quot;namespaceURI&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prefix:child</span>&gt;</span>content<span class="tag">&lt;/<span class="name">prefix:child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>xmlns</strong> 是定义命名空间的标准属性。</li>
<li><code>prefix</code> 是命名空间的前缀，<code>namespaceURI</code> 是对应的命名空间地址。</li>
</ul>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span> <span class="attr">xmlns:bk</span>=<span class="string">&quot;http://example.org/book&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bk:book</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bk:title</span>&gt;</span>XML Guide<span class="tag">&lt;/<span class="name">bk:title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bk:book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里定义了一个命名空间 <code>bk</code>，用来区分不同命名空间下的元素。</p>
<hr>
<p><strong>空元素（Empty Elements）</strong></p>
<ul>
<li><strong>空元素</strong>是没有内容的元素。可以用以下两种方式表示：<ul>
<li><code>&lt;element&gt;&lt;/element&gt;</code></li>
<li><code>&lt;element /&gt;</code>（自闭合）</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">emptyElement</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>处理指令（Processing Instructions）</strong></p>
<ul>
<li><strong>处理指令</strong>用于为应用程序提供处理 XML 文档的特定指令。</li>
</ul>
<p>语法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?instruction content?&gt;</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;style.xsl&quot;</span>?&gt;</span></span><br></pre></td></tr></table></figure>

<p>此指令告诉浏览器使用 <code>style.xsl</code> 样式表来展示 XML 数据。</p>
<h2 id="XML-Schema-和-DTD"><a href="#XML-Schema-和-DTD" class="headerlink" title="XML Schema 和 DTD"></a>XML Schema 和 DTD</h2><ul>
<li><strong>XML Schema</strong> 和 <strong>DTD（Document Type Definition）</strong> 是定义 XML 文档结构和约束的工具，帮助确保 XML 数据的有效性和结构一致性。</li>
</ul>
<h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> [</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">to</span>,<span class="keyword">from</span>,<span class="keyword">heading</span>,<span class="keyword">body</span>)&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">to</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">from</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">heading</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">body</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="XML-Schema"><a href="#XML-Schema" class="headerlink" title="XML Schema"></a>XML Schema</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xs:schema</span> <span class="attr">xmlns:xs</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&quot;note&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&quot;to&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xs:string&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&quot;from&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xs:string&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&quot;heading&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xs:string&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&quot;body&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xs:string&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xs:element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>DTD</strong>：早期用来定义 XML 文档结构，较为简单。</li>
<li><strong>XML Schema</strong>：更现代且功能更强大的 XML 定义方式，支持更精确的数据类型定义。</li>
</ul>
<h4 id="Spring-maven中的命名空间是什么？"><a href="#Spring-maven中的命名空间是什么？" class="headerlink" title="Spring maven中的命名空间是什么？"></a>Spring maven中的命名空间是什么？</h4><p>为了避免标签名称冲突创建了namespace的概念，对于beans这个标签：</p>
<ul>
<li>xmlns=”<a target="_blank" rel="noopener" href="https://springframework.org/schema/beans/&quot;">https://springframework.org/schema/beans/&quot;</a> 默认命名空间的namespaceURI指向spring官网</li>
<li>xmlns:context 创建名为context的命名空间</li>
<li>context:property-placeholder 指明property-placeholder这个标签含义从context命名空间解析</li>
</ul>
<p>XML schema(.xsd文件)用于定义xml文档的结构，要说明的是XML作为标记语言本身其实比较自由，如果要严格一些，比如作为框架的配置文件，就需要做出一些限制，XML schema正好是做这个的。</p>
<p><code>xsi</code> 是一个业界默认的用于 XSD(（XML Schema Definition) 文件的命名空间。</p>
<p>如果你创建一个命名空间需要引用别人的schema，需要加上这个schema的namespaceURI，并且在xsi的schemaLocation中加入namespaceURI和xsd文件的准确URL</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span><br></pre></td></tr></table></figure>

<p>上面这行的语法其实是， <code>xsi:schemaLocation = &quot;键&quot; “值”</code><br>即 xsi 命名空间下 schemaLocation 元素的值为一个由空格分开的URI pair。</p>
<blockquote>
<p>The first records the author’s warrant with pairs of URI references (<strong>one for the namespace name</strong>, and <strong>one for a hint as to the location of a schema document</strong> defining names for that namespace name)</p>
</blockquote>
<ul>
<li>前一个“键” <a target="_blank" rel="noopener" href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a> 指代 命名空间， 只是一个全局唯一字符串 URI ，用来表示这个命名空间是唯一的 </li>
<li>后一个值指代 XSD URL , 这个值指示了命名空间所对应的 <u>XSD 文件</u>的位置， xml parser 可以利用这个信息获取到 XSD 文件， 从而通过 XSD 文件对所有属于 URN <a target="_blank" rel="noopener" href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a> 的元素结构进行校验， 因此这个值必然是可以访问的， 且访问到的内容是一个 XSD 文件的内容</li>
</ul>
<h4 id="URI-amp-URL-amp-URN"><a href="#URI-amp-URL-amp-URN" class="headerlink" title="URI &amp; URL &amp; URN"></a>URI &amp; URL &amp; URN</h4><p>Identifier &amp; Locator &amp; Name</p>
<p>URI比URL更加抽象</p>
<p>URN确定了东西的身份，不提供找到资源的方法，URL提供了找到它的方式，点开一个URL就能直接找到资源。</p>
<blockquote>
<p>用于标志唯一书目的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ISBN">ISBN</a>系统是一个典型的URN使用范例。例如，<code>ISBN 0-486-27557-4</code>无二义性地标志出莎士比亚的戏剧《<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%97%E5%AF%86%E6%AC%A7%E4%B8%8E%E6%9C%B1%E4%B8%BD%E5%8F%B6">罗密欧与朱丽叶</a>》的某一特定版本。为获得该资源并阅读该书，人们需要它的位置，也就是一个URL地址。在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B1%BBUnix">类Unix</a>操作系统中，一个典型的URL地址可能是一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95&action=edit&redlink=1">文件目录</a>，例如<code>file:///home/username/RomeoAndJuliet.pdf</code>。该URL标志出存储于本地硬盘中的电子书文件。因此，URL和URN有着互补的作用。</p>
</blockquote>
<p>这里有两个URI，分别是maven和spring的配置xml中的namespaceURI：</p>
<p><a target="_blank" rel="noopener" href="http://springframework.org/schema/beans">http://springframework.org/schema/beans</a> 官方做成了像网盘一样的页面，里面有xsd文件的存储超链接，可以方便地访问xsd文件</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019210205303.png" alt="image-20241019210205303"></p>
<p><a target="_blank" rel="noopener" href="http://maven.apache.org/POM/4.0.0">http://maven.apache.org/POM/4.0.0</a> 就是一个PageNotFound页面</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019210235645.png" alt="image-20241019210235645"></p>
<p>对于schemaLocation中的URI pair，到底能不能通过第一个URI直接定位资源不重要，重要的是它是一个<u>唯一</u>标识这个东西身份的字符串，第二个URI一定是一个URL，能访问到.xsd文件本身</p>
<h4 id="XML-拓展阅读"><a href="#XML-拓展阅读" class="headerlink" title="XML 拓展阅读"></a>XML 拓展阅读</h4><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E8%AF%86%E7%AC%A6">统一资源标识符（URI） - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38120321">URL与URI与URN，有联系有区别？ - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/372022140">XML中的xmlns、xmlns:xsi和xsi:sechemaLoacation的具体含义是什么？ - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lengxiao1993/article/details/77914155">详解 xml 文件头部的 xmlns:xsi-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.w3.org/TR/xmlschema-1/#schema-loc">How schema definitions are located on the Web - w3.org</a> </p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><strong>元素</strong> 是 XML 的核心构建块，标签必须正确匹配或自闭合。</li>
<li><strong>属性</strong> 为元素提供额外信息，值必须用引号包裹。</li>
<li><strong>XML 声明</strong> 用于定义 XML 的版本和字符编码。</li>
<li><strong>注释</strong> 用于在文档中添加说明性文字，不会被解析器执行。</li>
<li><strong>CDATA 区域</strong> 用于保留未解析的原始文本数据。</li>
<li><strong>实体引用</strong> 用于表示特殊字符。</li>
<li><strong>命名空间</strong> 用于避免元素或属性名称冲突。</li>
<li><strong>空元素</strong> 可以通过自闭合标签表示。</li>
<li><strong>DTD 和 XML Schema</strong> 是用于验证 XML 文档结构的工具。</li>
<li><strong>处理指令</strong> 可以传递给应用程序或解析器，提供特定处理逻辑。</li>
</ol>
<p>这些核心语法确保了 XML 文档的规范性和可读性，帮助应用程序和解析器处理结构化数据。</p>
<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><h4 id="项目-Project"><a href="#项目-Project" class="headerlink" title="项目 Project"></a>项目 Project</h4><p>IDEA项目结构：.idea文件代表整个项目（整个窗口）</p>
<p>如果删掉.idea文件，里面的模块都将无法运行</p>
<h4 id="模块-Modules"><a href="#模块-Modules" class="headerlink" title="模块 Modules"></a>模块 Modules</h4><p>创建项目时自动创建一个和项目同名的module，这个module里包含项目的.idea以及自己的示例src等。每个module都有一个iml(information of module)文件，如果从外部导入其他路径的module，会和这个module并列。</p>
<p>模块套模块就是物理上的依赖关系，maven project有一个pom，其子模块也可以有pom，并且可以相互依赖。maven项目创建以后自动创建一个maven父模块，模块路径就是项目所在的路径，包含了iml和.idea，可以手动移除整个模块，但不能删除idea文件。</p>
<p>如果导入不同的modules之间有物理上的嵌套关系，自动变成父子模块关系，如果没有嵌套关系，就是并列的，相互之间不会影响。</p>
<p>项目管理工具</p>
<p><a target="_blank" rel="noopener" href="https://mvnrepository.com/">Maven Repository: Search/Browse/Explore (mvnrepository.com)</a> </p>
<h3 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h3><p>标准化统一的构建路程，编译测试打包发布</p>
<h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>default: compile</p>
<p>编译：main 测试：test 运行：打包以后的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924153605252-1727923499126-1.png" alt="image-20240924153605252"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="POM-对象模型"><a href="#POM-对象模型" class="headerlink" title="POM 对象模型"></a>POM 对象模型</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924151728949-1727923499126-2.png" alt="image-20240924151728949"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924152425583-1727923499126-3.png" alt="image-20240924152425583"></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>clean 清理项目下文件</p>
<p>compile 编译项目下文件生成target目录</p>
<p>test 执行项目下的文件</p>
<p>package 打包成jar包</p>
<p>install 把当前的项目打包jar 放到本地仓库 能对其配置依赖</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924153131022-1727923499126-4.png" alt="image-20240924153131022"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024201235892-1729772077345-1.png" alt="image-20241024201235892"></p>
<h4 id="clean—清理target目录"><a href="#clean—清理target目录" class="headerlink" title="clean—清理target目录"></a><strong>clean</strong>—清理target目录</h4><p>清理当前项目的target目录（上一次构建生成的文件）</p>
<h4 id="validate——验证项目元信息可用"><a href="#validate——验证项目元信息可用" class="headerlink" title="validate——验证项目元信息可用"></a>validate——验证项目元信息可用</h4><h4 id="compile—将src-main-java编译为字节码，输出到target目录"><a href="#compile—将src-main-java编译为字节码，输出到target目录" class="headerlink" title="compile—将src/main/java编译为字节码，输出到target目录"></a><strong>compile</strong>—将src/main/java编译为字节码，输出到target目录</h4><h4 id="test——单元测试（可跳过）"><a href="#test——单元测试（可跳过）" class="headerlink" title="test——单元测试（可跳过）"></a>test——单元测试（可跳过）</h4><h4 id="package—打包-jar-war-pom等"><a href="#package—打包-jar-war-pom等" class="headerlink" title="package—打包(jar,war,pom等)"></a><strong>package</strong>—打包(jar,war,pom等)</h4><h4 id="verify——检查打的包是否有效"><a href="#verify——检查打的包是否有效" class="headerlink" title="verify——检查打的包是否有效"></a>verify——检查打的包是否有效</h4><h4 id="install—将项目部署到本地仓库"><a href="#install—将项目部署到本地仓库" class="headerlink" title="install—将项目部署到本地仓库"></a><strong>install</strong>—将项目部署到本地仓库</h4><h4 id="deploy—将项目部署到远程仓库"><a href="#deploy—将项目部署到远程仓库" class="headerlink" title="deploy—将项目部署到远程仓库"></a><strong>deploy</strong>—将项目部署到远程仓库</h4><p>需要在maven的setting.xml中配置私服的用户名和密码（<server><mirror>的id相同），在pom.xml配置distributionmanagement</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025184411633.png" alt="image-20241025184411633"></p>
<h4 id="site——创建项目站点"><a href="#site——创建项目站点" class="headerlink" title="site——创建项目站点"></a>site——创建项目站点</h4><p>不属于build</p>
<h2 id="高级进阶"><a href="#高级进阶" class="headerlink" title="高级进阶"></a>高级进阶</h2><h3 id="分模块开发"><a href="#分模块开发" class="headerlink" title="分模块开发"></a>分模块开发</h3><p>不同模块之间的依赖关系</p>
<p>添加依赖到pom.xml中的dependency</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>安装依赖到本地仓库：</p>
<p><mark>maven-install<mark></p>
<h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><h4 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a>依赖冲突</h4><p>同一个pom.xml 后配置的覆盖先配置的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024184013133-1729772371846-3.png" alt="image-20241024184013133"></p>
<h3 id="可选依赖-amp-排除依赖"><a href="#可选依赖-amp-排除依赖" class="headerlink" title="可选依赖&amp;排除依赖"></a>可选依赖&amp;排除依赖</h3><h4 id="可选依赖——主动向别人隐藏，别人引用时看不到（被引用者）"><a href="#可选依赖——主动向别人隐藏，别人引用时看不到（被引用者）" class="headerlink" title="可选依赖——主动向别人隐藏，别人引用时看不到（被引用者）"></a>可选依赖——主动向别人隐藏，别人引用时看不到（被引用者）</h4><p><code>&lt;optional&gt;true&lt;optional&gt;</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024184316546-1729772371847-4.png" alt="image-20241024184316546"></p>
<h4 id="排除依赖——引用时主动忽略某个元素（引用者）"><a href="#排除依赖——引用时主动忽略某个元素（引用者）" class="headerlink" title="排除依赖——引用时主动忽略某个元素（引用者）"></a>排除依赖——引用时主动忽略某个元素（引用者）</h4><p><code>&lt;exclusion&gt;&lt;/exclusion&gt;</code> 不用写版本号</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024184835202-1729772371847-7.png" alt="image-20241024184835202"></p>
<h3 id="聚合工程与继承"><a href="#聚合工程与继承" class="headerlink" title="聚合工程与继承"></a>聚合工程与继承</h3><h4 id="聚合——同时构建模块"><a href="#聚合——同时构建模块" class="headerlink" title="聚合——同时构建模块"></a>聚合——同时构建模块</h4><p>某个模块变化了，依赖于它的还要一个一个重新构建。聚合工程可以同时重新构建他们</p>
<h5 id="创建空工程"><a href="#创建空工程" class="headerlink" title="创建空工程"></a>创建空工程</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024185111570-1729772371847-5.png" alt="image-20241024185111570"></p>
<h5 id="改变打包方式——pom"><a href="#改变打包方式——pom" class="headerlink" title="改变打包方式——pom"></a>改变打包方式——pom</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024185202904-1729772371847-6.png" alt="image-20241024185202904"></p>
<h5 id="添加聚合的模块"><a href="#添加聚合的模块" class="headerlink" title="添加聚合的模块"></a>添加聚合的模块</h5><p>顺序会自动根据依赖关系处理</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024185331214-1729772371847-8.png" alt="image-20241024185331214"></p>
<h4 id="继承——简化子工程配置"><a href="#继承——简化子工程配置" class="headerlink" title="继承——简化子工程配置"></a>继承——简化子工程配置</h4><p>多个模块有相同的依赖，更换版本比较繁琐。</p>
<p>简化子工程配置，减少版本冲突</p>
<h5 id="父工程打包方式——pom"><a href="#父工程打包方式——pom" class="headerlink" title="父工程打包方式——pom"></a>父工程打包方式——pom</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024190544704-1729772371847-9.png" alt="image-20241024190544704"></p>
<h5 id="父工程配置子工程共同依赖"><a href="#父工程配置子工程共同依赖" class="headerlink" title="父工程配置子工程共同依赖"></a>父工程配置子工程共同依赖</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024190619020-1729772371847-10.png" alt="image-20241024190619020"></p>
<h5 id="子工程配置parent"><a href="#子工程配置parent" class="headerlink" title="子工程配置parent"></a>子工程配置parent</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024185744377-1729772371847-11.png" alt="image-20241024185744377"></p>
<p>子类会继承父类的全部依赖，父类动一下，子类全部跟着动，</p>
<h5 id="子类可选的继承项"><a href="#子类可选的继承项" class="headerlink" title="子类可选的继承项"></a>子类可选的继承项</h5><p>有些依赖并不是所有的子工程都需要</p>
<h6 id="父工程配置可选依赖管理"><a href="#父工程配置可选依赖管理" class="headerlink" title="父工程配置可选依赖管理"></a>父工程配置可选依赖管理</h6><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024190202481-1729772371847-12.png" alt="image-20241024190202481"></p>
<h6 id="子工程声明需要此依赖"><a href="#子工程声明需要此依赖" class="headerlink" title="子工程声明需要此依赖"></a>子工程声明需要此依赖</h6><p>不要加版本</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024190240611-1729772371848-13.png" alt="image-20241024190240611"></p>
<h4 id="继承-vs-聚合"><a href="#继承-vs-聚合" class="headerlink" title="继承 vs 聚合"></a>继承 vs 聚合</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024190720813-1729772371848-14.png" alt="image-20241024190720813"></p>
<h3 id="属性加载"><a href="#属性加载" class="headerlink" title="属性加载"></a>属性加载</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024190830292-1729772371848-15.png" alt="image-20241024190830292"></p>
<p>定义一个常量，需要的时候直接写<code>$&#123;&#125;</code>，减少硬编码，降低耦合 </p>
<p><code>&lt;properties&gt;</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024191136401-1729772371848-17.png" alt="image-20241024191136401"></p>
<h4 id="properties配置文件-加载属性"><a href="#properties配置文件-加载属性" class="headerlink" title=".properties配置文件 加载属性"></a>.properties配置文件 加载属性</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024191334633-1729772371848-16.png" alt="image-20241024191334633"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024191340916-1729772371848-18.png" alt="image-20241024191340916"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hcgk/p/17600908.html">maven-resources-plugin详解 - 红尘过客2022 - 博客园 (cnblogs.com)</a></p>
<h5 id="指定resources目录，纳入maven管理"><a href="#指定resources目录，纳入maven管理" class="headerlink" title="指定resources目录，纳入maven管理"></a>指定resources目录，纳入maven管理</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024195223511-1729772371848-19.png" alt="image-20241024195223511"></p>
<p>子项目会继承父项目的配置，将自己的resources作为资源</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024191550934-1729772371848-22.png" alt="image-20241024191550934"></p>
<h5 id="解决打war包强制要求WEB-INF-web-xml"><a href="#解决打war包强制要求WEB-INF-web-xml" class="headerlink" title="解决打war包强制要求WEB-INF/web.xml"></a>解决打war包强制要求WEB-INF/web.xml</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024200210773-1729772371848-21.png" alt="image-20241024200210773"></p>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024200423176-1729772371848-23.png" alt="image-20241024200423176"></p>
<p>GA General Availability</p>
<h3 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h3><h4 id="配置多环境"><a href="#配置多环境" class="headerlink" title="配置多环境"></a>配置多环境</h4><h5 id="指定加载某一环境"><a href="#指定加载某一环境" class="headerlink" title="指定加载某一环境"></a>指定加载某一环境</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024200555818-1729772371848-25.png" alt="image-20241024200555818"></p>
<p>profiles id </p>
<p>activeByDefault 默认环境</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024200720633-1729772371848-24.png" alt="image-20241024200720633"></p>
<h5 id="构建指令-P-环境名"><a href="#构建指令-P-环境名" class="headerlink" title="构建指令 -P 环境名"></a>构建指令 -P 环境名</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024200902692-1729772371848-26.png" alt="image-20241024200902692"></p>
<h4 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024201215677-1729772371848-27.png" alt="image-20241024201215677"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024201235892-1729772371848-28.png" alt="image-20241024201235892"></p>
<p>测试，但是忽略一些东西</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024201333235-1729772371848-29.png" alt="image-20241024201333235"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024201411791-1729772371848-30.png" alt="image-20241024201411791"></p>
<h3 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024225654228.png" alt="image-20241024225654228"></p>
<h4 id="私服仓库分类"><a href="#私服仓库分类" class="headerlink" title="私服仓库分类"></a>私服仓库分类</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024230834698.png" alt="image-20241024230834698"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024230845592.png" alt="image-20241024230845592"></p>
<p>第三方资源：oracle的jdbcJar包</p>
<h4 id="资源上传与下载"><a href="#资源上传与下载" class="headerlink" title="资源上传与下载"></a>资源上传与下载</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241024231324939.png" alt="image-20241024231324939"></p>
<p>这些都是本地仓库的配置</p>
<p>需要在maven的xml</p>
<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923155407582-1727923816030-9.png" alt="image-20240923155407582"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923155451882-1727923816031-10.png" alt="image-20240923155451882"></p>
<p>jdbc 接口 </p>
<h2 id="执行SQL步骤"><a href="#执行SQL步骤" class="headerlink" title="执行SQL步骤"></a>执行SQL步骤</h2><p>驱动 实现接口</p>
<ol>
<li>注册Class <code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</code></li>
<li>建立<code>Connection</code>使用<code>DriverManager</code>的<code>getConnenction(url,username,password)</code> 创建连接</li>
<li>建立<code>Statement</code>调用上一部连接对象的<code>createStatement()</code> </li>
<li>调用上一部<code>Statement</code>对象的<code>execute(sql)</code> 执行sql语句，这个函数返回的是操作的数据库的行数</li>
<li>关闭资源，或者try with resource</li>
</ol>
<h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><h4 id="注册驱动，连接数据库"><a href="#注册驱动，连接数据库" class="headerlink" title="注册驱动，连接数据库"></a>注册驱动，连接数据库</h4><p>registerDriver 驱动中自带静态代码块，forname加载之后自动执行（可选）</p>
<p>连接数据库 URL 统一资源定位符</p>
<p><code>jdbc:mysql://localhost:3306/itcast</code> </p>
<p><code>protocol:</code> // <code>ip+port</code> / <code>databaseName</code></p>
<p>DriverManager.getConnection(url, usr, pw)</p>
<h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><h2 id="获取执行sql的对象"><a href="#获取执行sql的对象" class="headerlink" title="获取执行sql的对象"></a>获取执行sql的对象</h2><ul>
<li><code>prepareStatement(sql) </code>  预编译</li>
<li><code>createStatement()</code> 普通执行sql对象</li>
</ul>
<h4 id="管理事务"><a href="#管理事务" class="headerlink" title="管理事务"></a><mark>管理事务<mark></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923195630325-1727923816031-12.png" alt="image-20240923195630325"></p>
<p>mysql自动提交事务，</p>
<p>setAutoCommit(false) 开启事务</p>
<p>commit() 提交事务 rollback() 回滚事务</p>
<p>rollback放到catch块中。</p>
<p>Atomic Consistency Isolational Durability</p>
<h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><h3 id="执行SQL"><a href="#执行SQL" class="headerlink" title="执行SQL"></a>执行SQL</h3><p><code>int executeUpdate(DML, DDL)</code>返回受到影响的行数 </p>
<p><code>ResultSet executeQuery(DQL)</code> 执行DQL，返回结果集</p>
<h2 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h2><h3 id="预防SQL注入"><a href="#预防SQL注入" class="headerlink" title="预防SQL注入"></a>预防SQL注入</h3><p><strong>SQL Injection</strong>：脚本</p>
<p><strong>登录逻辑</strong>：接收username和pswd, 然后在sql语句中插入usrname和pswd</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from tb_user where username = &#x27;&quot;</span> + username + <span class="string">&quot;&#x27;and password = &#x27;&quot;</span> + pswd + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="comment">//结果集没有结果则返回失败</span></span><br></pre></td></tr></table></figure>

<p>登录操作实际上就是查询数据库，pswd = ‘ or ‘1’ =’1 拼接sql语句，改变原先的验证逻辑</p>
<p><strong>解决方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sql = <span class="string">&quot;select * from tb_user where username = ? and password = ?&quot;</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> myConnection.prepareStatement(sql);</span><br><span class="line"><span class="comment">//给参数赋值</span></span><br><span class="line">pstmt.setString(<span class="number">1</span>,username);</span><br><span class="line">pstmt.setString(<span class="number">2</span>,pswd);</span><br><span class="line"><span class="comment">//1,2是问号的位置编号 start from 1</span></span><br><span class="line"></span><br><span class="line">pstmt.executeQuery();</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924163227260-1727923816031-11.png" alt="image-20240924163227260"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">AND</span> password <span class="operator">=</span> <span class="string">&#x27;\&#x27;</span> <span class="keyword">OR</span> \<span class="string">&#x27;1\&#x27;</span><span class="operator">=</span>\<span class="string">&#x27;1&#x27;</span></span><br><span class="line">#用户名为admin 密码为<span class="string">&#x27; OR &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span> </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">AND</span> password <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">OR</span> <span class="string">&#x27;1&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>占位符<strong>将敏感字符变成转义字符</strong>，这样sql就会认为这是一个文本类的单引号而不是格式的单引号</p>
</li>
<li><p>自动进行类型转换，外边加一层引号</p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924165014456-1727923816031-13.png" alt="image-20240924165014456"></p>
<h3 id="预编译SQL语句，高性能"><a href="#预编译SQL语句，高性能" class="headerlink" title="预编译SQL语句，高性能"></a>预编译SQL语句，高性能</h3><p>原来sql执行，要把检查语法和编译sql都交给数据库服务器，<code>?userServerPrepStmts=true</code> 串加到最后的参数后边，默认关闭</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924165716038-1727923816031-15.png" alt="image-20240924165716038"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924165801554-1727923816031-16.png" alt="image-20240924165801554"></p>
<p> 执行两次，只会预编译一次：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924170025388-1727923816032-18.png" alt="image-20240924170025388"></p>
<ul>
<li>PreparedStatement 原理<br>在获取PreparedStatement对象时，将sql语发送给mysqI服务器进行检查，编译(这些步骤很耗时)</li>
<li>执行时就不用再进行这些步骤了，速度更快</li>
<li>如果sql模板一样，则只需要进行一次检查、编译</li>
</ul>
<h2 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h2><p>把查询结果（表）封装起来</p>
<p><code>boolean next()</code> 将光标向下移动一行，判断是否有效</p>
<p><code>int getInt(&quot;id&quot;)</code>获取id列的数据</p>
<p><code>String getString()</code>获取字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(resultset.next())&#123;</span><br><span class="line">    resultset.getInt();</span><br><span class="line">    ... ...</span><br><span class="line"><span class="comment">//可以将查询到的数据封装到自定义类中，然后list存储多个对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环判断游标是否在最后一行的末尾 </span></span><br></pre></td></tr></table></figure>

<h2 id="DataSource-数据库连接池"><a href="#DataSource-数据库连接池" class="headerlink" title="DataSource 数据库连接池"></a>DataSource 数据库连接池</h2><ul>
<li><p>数据库连接池，sun定义的官方接口</p>
</li>
<li><p>connection要调用系统资源，开启关闭都要耗费系统资源。</p>
</li>
<li><p>连接池：资源复用，提升响应速度，避免连接遗漏（连接池资源占满时，如果有新的请求，就会根据一定的算法从已占用资源中空出来一个资源）</p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924170701651-1727923816032-19.png" alt="image-20240924170701651"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924170726525-1727923816031-14.png" alt="image-20240924170726525"></p>
<h3 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924170924469-1727923816031-17.png" alt="image-20240924170924469"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">prop.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;path&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection;</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.getProperty(&quot;user.dir&quot;) 得到当前的相对路径起始点</span></span><br></pre></td></tr></table></figure>

<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>MyBatis：<strong>持久层框架</strong>，可简化JDBC开发</p>
<p><strong>持久层</strong>：数据保存到数据库的一层代码（JavaEE：表现层，业务层，持久层）</p>
<p><strong>框架</strong>：可重用的通用的软件基础代码模型，在框架的基础上构建软件编写更加高效规范</p>
<p>使用XML配置文件进行简化，免除了几乎所有JDBC代码 设置参数 获取结果集，减少硬编码，免除了繁冗步骤。</p>
<p>mybatis-config.xml 记录 JDBC注册连接信息和下方的映射文件</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925145936781.png" alt="image-20240925145936781"></p>
<p>EmployeeMapper.xml 记录映射信息 用session  select 的时候用test.selectAll来执行对应sql语句，<u>resultType是POJO(Plain old java object)的类名（全限定名）</u>  </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925150035852.png" alt="image-20240925150035852"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream); </span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">List&lt;Employee&gt; list = sqlSession.selectList(<span class="string">&quot;test.selectAll&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Mapper-代理"><a href="#Mapper-代理" class="headerlink" title="Mapper 代理"></a>Mapper 代理</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925151447994.png" alt="image-20240925151447994"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925151453517.png" alt="image-20240925151453517"></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>src/main下有java和resources </p>
<p>相对路径：编译之后java下的内容和resources的内容放在同一个classes文件夹下,如果java和resources的目录结构有相同的地方，合并内容。 接口在java文件夹下面新建com.example.mapper 对应的映射文件在resources文件夹下新建com/example/mapper目录放入</p>
<p>对应的，mybatis-config文件中也得修改映射文件的名称。上图所示，可以用包名代替 mapper resource</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925152748288.png" alt="image-20240925152748288"></p>
<p>原来session执行select* 语句调用的是selectList方法，这句话的意思是返回一个表，所以返回值要用List来接，</p>
<p>执行sql语句本质上是调用jdbc的各种api方法，重复性较高，并且有相当数量的硬编码，为了减少硬编码，把参数放入配置文件中，运用了动态代理技术</p>
<h3 id="源码分析（粗浅）"><a href="#源码分析（粗浅）" class="headerlink" title="源码分析（粗浅）"></a>源码分析（粗浅）</h3><p>框架利用java反射机制和动态代理机制，比如上图的select id  = selectAll，重写了mapper的sql方法，并据此生成mapper接口的代理对象                          method.getName == selectAll 执行 sql方法并返回值      </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925155924934.png" alt="image-20240925155924934"></p>
<p>manager的有参构造器，创建了一个代理</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925160215649.png" alt="image-20240925160215649"></p>
<p>InvocationHandler 中 invoke 的 重写 此处代理的是session，替session执行sql语句</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925160058102-1727251872747-1.png" alt="image-20240925160058102"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 处理默认方法（如接口的 `default` 方法）</span></span><br><span class="line">        <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.sqlSession.selectOne(method.getName(), args); <span class="comment">// 根据具体方法执行查询</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="JDK-动态代理的关键点"><a href="#JDK-动态代理的关键点" class="headerlink" title="JDK 动态代理的关键点"></a>JDK 动态代理的关键点</h4><ol>
<li><strong>接口代理</strong>：<ul>
<li>JDK 动态代理只能为实现了接口的类生成代理，因此 MyBatis 的 <code>Mapper</code> 必须是接口。</li>
<li>在运行时生成的代理类实现了 <code>Mapper</code> 接口，并将方法调用委托给 <code>MapperProxy</code>。</li>
</ul>
</li>
<li>**<code>InvocationHandler</code>**：<ul>
<li><code>MapperProxy</code> 作为 <code>InvocationHandler</code>，负责拦截 <code>Mapper</code> 接口的方法调用。</li>
<li><code>invoke</code> 方法中的逻辑决定了如何将接口方法映射到数据库操作。</li>
</ul>
</li>
<li><strong>灵活的 SQL 映射</strong>：<ul>
<li>通过动态代理，MyBatis 可以将 <code>Mapper</code> 接口中的任意方法与对应的 SQL 映射，无需编写具体的实现代码。</li>
</ul>
</li>
</ol>
<h2 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config.xml"></a>mybatis-config.xml</h2><h3 id="environments"><a href="#environments" class="headerlink" title="environments"></a>environments</h3><p>不同的environment对应不同的工作环境，通过default来切换</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925162843370.png" alt="image-20240925162843370"></p>
<p>transaction manage 事务管理 这里是JDBC</p>
<p>datasource  pooled</p>
<p>property xxx 对应数据库的连接信息</p>
<h3 id="mappers"><a href="#mappers" class="headerlink" title="mappers"></a>mappers</h3><p>标注mapper的配置文件的路径或者包名</p>
<h3 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h3><ul>
<li><p><code>&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.Employee&quot; alias=&quot;emp/&gt;</code></p>
<p>为这个类起一个别名emp，不写alias默认是小写employee，这样可以在resultType项用emp来代替全限定名</p>
</li>
<li><p><code>&lt;package name=&quot;com.atguigu.mybatis.bean&quot;/&gt;</code> 对这个包下所有的类起别名，是类本名的小写</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;emp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"><span class="comment">// 类的其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XML配置要遵循如下约束</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925164103152.png" alt="image-20240925164103152"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020124943974.png" alt="image-20241020124943974"></p>
<h2 id="crud"><a href="#crud" class="headerlink" title="crud"></a>crud</h2><p>插件：MyBatisX</p>
<p>三步走：</p>
<ul>
<li>编写Mapper接口 定义抽象方法，注意参数和返回值，还有抽象方法的名字就是 select id，</li>
<li>编写SQL语句：mapper映射文件中的 id resultType sql要齐全</li>
<li>session.getMapper    用 mapper调用</li>
</ul>
<h3 id="实体类字段和数据库名称"><a href="#实体类字段和数据库名称" class="headerlink" title="实体类字段和数据库名称"></a>实体类字段和数据库名称</h3><ul>
<li><p>成员变量名字和数据库字段严格一致</p>
</li>
<li><p>sql语句中，给要查询的列起别名 <code>brand_name as brandName, company_Name as companyName</code></p>
<ul>
<li>每一次都要写一大段，把相同的部分看做<strong>sql片段</strong> 不灵活</li>
<li><code>&lt;sql id=&quot;brand_column&quot;&gt; 相同的部分 &lt;/sql&gt;</code> </li>
<li>sql语句中 select <code>&lt;include refid=&quot;brand_colomn&quot;/&gt;</code> from xxxx</li>
</ul>
</li>
</ul>
<h4 id="最好解决方案：ResultMap"><a href="#最好解决方案：ResultMap" class="headerlink" title="最好解决方案：ResultMap"></a>最好解决方案：ResultMap</h4><ul>
<li><p>定义<code>resultMap</code>标签</p>
</li>
<li><p>把<code>resultType</code>改成<code>resultMap</code> 结果 column行对应的是数据库里的别名 property对应的是pojo的属性 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925175306144.png" alt="image-20240925175306144"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;SELECT id, name, email FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Results(id = &quot;userResultMap&quot;, value = &#123;</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;id&quot;, column = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;name&quot;, column = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;email&quot;, column = &quot;email&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM users&quot;)</span></span><br><span class="line">    <span class="meta">@ResultMap(&quot;userResultMap&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">getAllUsers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//select注解开发，Results注解映射结果，给自己起名userResultMap</span></span><br><span class="line"><span class="comment">//getAllUsers方法就可用ResultMap注解来映射返回值</span></span><br></pre></td></tr></table></figure>

<h3 id="参数占位符"><a href="#参数占位符" class="headerlink" title="参数占位符"></a>参数占位符</h3><p>定义抽象方法selectById(int id) 假如这里定义形参名id，返回值是实体类Brand，sql语句用 where 修饰，<code>where id = #&#123;id&#125; </code> 形参名字用大括号加井号括起来</p>
<p>${id} -&gt;     直接拼接字符串，不能防止<a href="">SQL注入</a></p>
<p>#{id} -&gt; ?  占位符，能将内容转义，防止sql注入</p>
<p>preparedstatement执行，#{id} 会将id视为参数，接收以后把参数填补进去</p>
<p>#{}表名或者列名不固定</p>
<p>parameterType可以省略</p>
<h4 id="特殊字符处理"><a href="#特殊字符处理" class="headerlink" title="特殊字符处理"></a>特殊字符处理</h4><ul>
<li>转义字符 &amp;amp;  &amp;gt;  &amp;lt;  双引号 &amp;quot; 单引号 &amp;apos;</li>
<li><code>&lt;![CDATA[ &lt; ]]&gt;</code> </li>
</ul>
<h3 id="模糊查询-分页查询"><a href="#模糊查询-分页查询" class="headerlink" title="模糊查询 分页查询"></a>模糊查询 分页查询</h3><p>补充见[webfu服务端](Java Web 服务端.md)-其他细节</p>
<h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询<select></select></h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925182248759.png" alt="image-20240925182248759"></p>
<h4 id="参数接收"><a href="#参数接收" class="headerlink" title="参数接收"></a>参数接收</h4><p>模糊条件查询</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925184318146.png" alt="image-20240925184318146"></p>
<ol>
<li>散装参数，多个参数需要加@Param注解 后面要和sql语句占位符一样，最好是pojo类的属性名称</li>
<li>对象参数：对象的属性名称要和参数占位符名称一致</li>
<li>map参数：创建一个map，里面键是sql语句的占位符，值是对象的属性名成员变量</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;status&quot;</span>,status);</span><br><span class="line">map.put(<span class="string">&quot;companyName&quot;</span>,companyName);</span><br><span class="line">map.put(<span class="string">&quot;brandName&quot;</span>,brandName);</span><br></pre></td></tr></table></figure>

<p>传参数进来就是一个填字游戏详见下方的param注解</p>
<h4 id="多条件-动态条件查询-if"><a href="#多条件-动态条件查询-if" class="headerlink" title="多条件 动态条件查询 if"></a>多条件 动态条件查询 if</h4><p>用户查询可能不会把条件全部填满：动态SQL</p>
<h5 id="if-条件判断"><a href="#if-条件判断" class="headerlink" title="if 条件判断"></a>if 条件判断</h5><p>test：逻辑表达式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925184740473.png" alt="image-20240925184740473"></p>
<p><code>&lt;if test = &quot;companyName != null and companyName != &#39; &#39; &quot;&gt;</code> sql条件字段  有选择地拼接</p>
<p>如果map中不包含brandname或者brandname是空的，mybatis 就不会把那一部分拼接到sql语句中，由于是直接拼接，所以不可避免会出现格式问题, 第一个条件不需要逻辑运算符。</p>
<p>if条件后的test 后面是参数的键名</p>
<ul>
<li>可以在条件前面加个and 再用恒等式 缓冲一下</li>
<li><em>where</em> 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，<em>where</em> 元素也会将它们去除。where标签，里面加上判断标签，判断标签里面用and开头 ，如果只有一个判断标签有效，还会自动去掉and<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925185741878.png" alt="image-20240925185741878"></li>
</ul>
<h4 id="单条件动态查询-choose"><a href="#单条件动态查询-choose" class="headerlink" title="单条件动态查询 choose"></a>单条件动态查询 choose</h4><p>还有 choose(when otherwise) 类似 switch-case </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925190242016.png" alt="image-20240925190242016"></p>
<p>用户输入完就是给对象赋值，可能有些字段是空的，这会导致不能正确解析，出现where后面空的情况，此时otherwise标签里要有一个默认保底的查询方法</p>
<p>另外，where标签也可以代替otherwise的功能，如果检测到语法错误他会自动删除where </p>
<p>where标签注意事项</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925192533201.png" alt="image-20240925192533201"></p>
<p>trim(where set) foreach</p>
<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p><code>&lt;insert&gt;&lt;/insert&gt;</code></p>
<p>autocommit 默认 false </p>
<p><code>sqlSession.commit()</code> 提交事务</p>
<p><code>sqlSessionFactory.openSession(true)</code></p>
<h4 id="主键返回"><a href="#主键返回" class="headerlink" title="主键返回"></a>主键返回</h4><p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925221746219.png" alt="image-20240925221746219"></p>
<p><code>&lt;insert&gt; id=&quot;addOrder&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot; &lt;/insert&gt;</code></p>
<p>自动设置主键id的值，即使对象的id没有设定，也能自动设置其ID</p>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p><code>&lt;update&gt;&lt;/update&gt;</code> </p>
<h4 id="修改全部字段"><a href="#修改全部字段" class="headerlink" title="修改全部字段"></a>修改全部字段</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925225339176.png" alt="image-20240925225339176"></p>
<h4 id="动态修改字段"><a href="#动态修改字段" class="headerlink" title="动态修改字段"></a>动态修改字段</h4><p><code>&lt;set&gt;</code>关键字</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925225816604.png" alt="image-20240925225816604"></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>&lt;delete&gt;</code> 关键字</p>
<h4 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h4><p>复选框删除 根据ID数组 批量删除 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240925230216448.png" alt="image-20240925230216448"></p>
<p>foreach能遍历collection或者array，item是给每个元素起的名字，sep分隔符，open close分别代表起始符号和结束符号, ids是数组参数的param注解，如果没有param注解，就要用array</p>
<h3 id="Param-注解"><a href="#Param-注解" class="headerlink" title="@Param 注解"></a>@Param 注解</h3><p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_12393361/5021343">解决mybatis不加@Param报错 org.apache.ibatis.binding.BindingException_51CTO博客_mybatis @Param</a></p>
<p>对于参数，mybatis先使用map集合进行封装，每个参数都有对应的键名，解析sql语句时，遇到占位符就用值填充键的对应位置，或者在<strong>if标签的test</strong>、<strong>foreach的collection标签</strong> 中  用键名来代指参数。如果不使用参数注解，map会为参数生成默认的键，@Param注解用来代替map默认的键arg0, (param1还能用)</p>
<p>(-parameters可以生成元数据用于方法参数的反射，<strong>JDK8起</strong>在反射包中引入了java.lang.reflect.Parameter 来获取参数相关的信息。IDE编译时自动加了参数 -parameters，所以能把方法参数名给解析出来作为key)</p>
<ul>
<li>对于一个基本类型参数，没有指定param，随便都可以, 加了注解就只能用param1和注解的别名</li>
</ul>
<ul>
<li><p>对于多个基本类型参数，如果没有指定param，mybatis底层会自动给予param1+arg0键，param2+arg1键，占位符需要用param1（arg0）和param2（arg1）‘’。IDE会优化，参数的键就变成自己的形参名，但如果形参的名字变化，没有注解，而且对应的占位符没有及时更新，就会出现异常</p>
</li>
<li><p>对于POJO对象类型参数，mybatis底层会给予对象字段键名，键名就是自己的字段名称，只需要保证字段名能和占位符一一对应。<strong>不需要</strong>使用param注解</p>
</li>
<li><p>对于map类参数，<strong>直接使用不需要</strong>注解，只要保证map中键名能和占位符一一对应即可。</p>
</li>
<li><p>对于collection类参数，至少会有arg0和colleciton两个键 ，对于list还会多一个list。key:”list”  value: userList</p>
<ul>
<li>对于数组类参数，至少会有array和arg0键名</li>
</ul>
</li>
</ul>
<p>为了映射结果一致，最好参数全部使用param进行注解，便于后期维护</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul>
<li><p>如果map集合中存储一个user对象(key=”user”)和address对象(key=”address”)，但是在sql语句中要使用他们的字段，占位符应该用user.id user.name进行引用。另外一个user对象(key=”user2”)就需要用user2.name 进行引用。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; paramMap = new HashMap<span class="tag">&lt;&gt;</span>();</span><br><span class="line">paramMap.put(&quot;user&quot;, user);</span><br><span class="line">paramMap.put(&quot;address&quot;, address);</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUserWithAddress&quot;</span>&gt;</span></span><br><span class="line">    INSERT INTO tb_user (id, name, email, address)</span><br><span class="line">    VALUES (#&#123;user.id&#125;, #&#123;user.name&#125;, #&#123;user.email&#125;, #&#123;address.street&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果是collection存储user对象，就要用foreach遍历，item 如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUsers&quot;</span>&gt;</span></span><br><span class="line">    INSERT INTO tb_user (id, name, email)</span><br><span class="line">    VALUES</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;users&quot;</span> <span class="attr">item</span>=<span class="string">&quot;user&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        (#&#123;user.id&#125;, #&#123;user.name&#125;, #&#123;user.email&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>总结：对象map传进来不需要遍历，mybatis会根据对象对应的键找值，用<code>.</code>进行字段引用；对象collection和array需要遍历</p>
</li>
</ul>
<h3 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926100629592.png" alt="image-20240926100629592"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43883917/article/details/113830667">Mybatis注解开发（超详细）-CSDN博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/07/01/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/07/01/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">Java 集合框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-07-01T00:00:00+08:00">2024-07-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 16:02:57" itemprop="dateModified" datetime="2025-04-27T16:02:57+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><p>并发集合见 JUC</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-collection-hierarchy.png" alt="Java 集合框架概览"></p>
<h2 id="Collecion-单列"><a href="#Collecion-单列" class="headerlink" title="Collecion 单列"></a>Collecion 单列</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915133525868-1735477273565-35-1735477280164-37.png" alt="Collection"></p>
<ul>
<li><code>List</code>系列：添加元素有序，可重复，有索引<ul>
<li><code>ArrayList</code></li>
<li><code>LinkedList</code></li>
</ul>
</li>
<li><code>Set</code>系列：添加元素无序，不重复，无索引<ul>
<li><code>HashSet</code> 无序不重复无索引<ul>
<li><code>LinkedHashSet</code> 有序不重复无索引</li>
</ul>
</li>
<li><code>TreeSet</code> 按照大小默认升序排序 不重复 无索引</li>
</ul>
</li>
</ul>
<h3 id="Collection-Methods"><a href="#Collection-Methods" class="headerlink" title="Collection Methods"></a>Collection Methods</h3><ul>
<li><code>boolean add(E e)</code>  <code>boolean isEmpty()</code> <code>boolean remove(E e)</code> <code>boolean contains(Object o)</code> </li>
<li><code>void clear()</code> <code>int size()</code> </li>
<li><code>Object[] toArray()</code>:集合colletion转换成对象<strong>数组</strong> （返回Object数组是为了防止添加不同类型的对象）重载的<code>toArray(String[] strs)</code> 方法能够返回一个String数组<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240914230120510.png" alt="toArray"></li>
<li><code>void addAll(Collections&lt;E&gt; c2)</code> <code>c1.addAll(c2)</code> 把c2的数据全部加入c1中</li>
</ul>
<h3 id="Collection-遍历"><a href="#Collection-遍历" class="headerlink" title="Collection 遍历"></a>Collection 遍历</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = collection.iterator();<span class="comment">//默认在第一个对象</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;<span class="comment">//判断迭代器是否能继续指向下一个</span></span><br><span class="line"> System.out.println(it.next()); <span class="comment">//迭代器返回现在指向的对象，之后指向下一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 最好是一次<code>hasNext()</code>对应一次<code>next()</code></p>
<h4 id="for-Each增强循环"><a href="#for-Each增强循环" class="headerlink" title="for-Each增强循环"></a>for-Each增强循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; colle = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(String name:colle)&#123;</span><br><span class="line">&#125;<span class="comment">//colle代表要遍历的集合名，name代表集合中每个元素的名字</span></span><br><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String name:names)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果等同于迭代器Iterator</p>
<h4 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">colle.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span>&#123;</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">colle.forEach(s-&gt;System.out.println(s));</span><br><span class="line">colle.forEach(System.out::println);<span class="comment">//前后参数一样</span></span><br></pre></td></tr></table></figure>

<p>action已经实现了Consumer接口的accept方法</p>
<p>内部实现还是增强for循环，将colle集合中的元素t送到action的accept()处，相当于用元素t执行accept()方法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240914234023283.png" alt="forEach"></p>
<h3 id="List-支持索引"><a href="#List-支持索引" class="headerlink" title="List 支持索引"></a>List 支持索引</h3><p><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code> </p>
<ul>
<li><code>void add(int index, E e)</code>(add()重载)</li>
<li><code>E remove(int index)</code> 返回remove的数据</li>
<li><code>E get(int index)</code>返回指定索引的数据</li>
<li><code>E set(int index, E e)</code> 修改指定索引数据，返回原来的数据</li>
<li><code>List&lt;E&gt; sublist(int from, int to)</code> 返回一个list里面装有[from,to)部分的list</li>
</ul>
<h4 id="List-遍历"><a href="#List-遍历" class="headerlink" title="List 遍历"></a>List 遍历</h4><ul>
<li>for-Each-Loop Lambda Iterator</li>
<li>for循环（支持索引）</li>
</ul>
<h4 id="ArrayList-基于数组"><a href="#ArrayList-基于数组" class="headerlink" title="ArrayList 基于数组"></a>ArrayList 基于数组</h4><ul>
<li>基于<u><strong>数组</strong></u>实现 <strong>对象数组</strong> </li>
<li>查询速度快 (索引) O(1) 集合末端元素有时可以达到 O(1)</li>
<li>删除效率低，添加效率极低，基本都需要整体移动甚至扩容 都是 O(n) </li>
<li>有参构造：指定长度，不够再添</li>
</ul>
<p>适用场景：索引查询，数据量不大</p>
<p>数据量大还要频繁进行增删操作，不适合！</p>
<ol>
<li>动态扩容</li>
<li>创建指定大小</li>
<li>指定泛型，确保元素安全</li>
<li>线程不安全</li>
</ol>
<h5 id="ArrayList-扩容-源码分析：grow-int-minCapacity"><a href="#ArrayList-扩容-源码分析：grow-int-minCapacity" class="headerlink" title="ArrayList 扩容 源码分析：grow(int minCapacity)"></a>ArrayList <strong>扩容</strong> 源码分析：<code>grow(int minCapacity)</code></h5><p>三种创建方式：默认容量为 10</p>
<ol>
<li>空参：首先创建的是一个<mark>空</mark>数组 <em>懒加载的运用</em>   </li>
<li>参数为 n：创建<mark>容量为n<mark>的对象数组，0则创建空数组</li>
<li>参数为 collection：将 collection 的内容复制进入 新的 ArrayList 中</li>
</ol>
<ol>
<li><mark>无参构造，先使用一个长度为0的对象数组<mark> <ul>
<li><code>Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</code></li>
</ul>
</li>
<li><mark>添加首个元素，创建长度为10的对象数组<mark>  <ul>
<li><code>elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];</code></li>
</ul>
</li>
<li>存满后，再添加时创建扩容1.5倍的数组，原内容加进去<ul>
<li><code>newCap = oldCap + oldCap &gt;&gt; 1</code></li>
<li> <code>Arrays.copyof(elementData,newCap)</code></li>
</ul>
</li>
<li>一次加多个元素，addAll，1.5 倍或者10个放不下，新创建数组长度以实际为准<code>minCapacity</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, Object[] elementData, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入一个元素，此时元素个数size = 0，存放元素的数组容量 length = 0，因此正好符合扩容条件：<code>grow(int minCapacity)</code> 对于普通的add，此处 <code>minCapacity = size + 1</code>，也就是现元素个数+1</p>
<p><strong><mark>扩容逻辑<mark></strong></p>
<p>空数组扩容到<code>max</code>[ <mark>10<mark> , <code>minCapacity</code> ], <code>minCapacity</code>是用来应对<code>addAll()</code>的</p>
<p>非空数组扩容到<mark>原来的1.5倍<mark>，当然1.5倍导致溢出则扩容到minCapacity即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="comment">// 最小容量应为size+1, length为数组的大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;<span class="comment">//当前大小</span></span><br><span class="line">    <span class="comment">// 1. 如果是无参构造就是空数组: DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity &gt; <span class="number">0</span> || </span><br><span class="line">    	elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> ArraysSupport.newLength(oldCapacity,</span><br><span class="line">                minCapacity - oldCapacity, <span class="comment">/* minimum growth  */</span></span><br><span class="line">                oldCapacity &gt;&gt; <span class="number">1</span>  <span class="comment">/* preferred GROWTH 0.5倍 原长度*/</span>);</span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1.1 上面是空数组，那就是默认容量 10 和 size+1 进行比较 创建比较大的那个</span></span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">Object</span>[Math.max(DEFAULT_CAPACITY, minCapacity)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">newLength</span><span class="params">(<span class="type">int</span> oldLength,<span class="type">int</span> minGrowth,<span class="type">int</span> prefGrowth)</span> &#123;</span><br><span class="line">    <span class="comment">// preconditions not checked because of inlining</span></span><br><span class="line">    <span class="comment">// assert oldLength &gt;= 0</span></span><br><span class="line">    <span class="comment">// assert minGrowth &gt; 0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">prefLength</span> <span class="operator">=</span> oldLength + Math.max(minGrowth, prefGrowth); <span class="comment">// might overflow</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt; prefLength &amp;&amp; prefLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> prefLength;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// put code cold in a separate method</span></span><br><span class="line">        <span class="keyword">return</span> hugeLength(oldLength, minGrowth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理论上来说，最好在向 <code>ArrayList</code> 添加大量元素之前用 <code>ensureCapacity(minCapacity)</code> 方法，以减少增量重新分配的次数</p>
<h5 id="Vector-Deprecated"><a href="#Vector-Deprecated" class="headerlink" title="Vector(Deprecated)"></a><del>Vector(Deprecated)</del></h5><p><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，适用于频繁的查找工作，线程不安全 。</p>
<p><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，线程安全，但是并发性能较差。</p>
<h5 id="Stack-Deprecated"><a href="#Stack-Deprecated" class="headerlink" title="Stack(Deprecated)"></a><del>Stack(Deprecated)</del></h5><ul>
<li><code>Vector</code> 和 <code>Stack</code> 两者都是线程安全的，都是使用 <code>synchronized</code> 关键字进行同步处理。</li>
<li><code>Stack</code> 继承自 <code>Vector</code>，是一个后进先出的栈，而 <code>Vector</code> 是一个列表。</li>
</ul>
<p>随着 Java 并发编程的发展，<code>Vector</code> 和 <code>Stack</code> 已经被淘汰，推荐使用并发集合类（例如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。</p>
<h4 id="LinkedList-基于链表"><a href="#LinkedList-基于链表" class="headerlink" title="LinkedList 基于链表"></a>LinkedList 基于链表</h4><ul>
<li>基于<u>双向链表</u>实现，比单链表快</li>
<li>查询速度慢O(n)，<strong>对首尾元素操作极快</strong> O(1)</li>
<li>添加和删除不需要扩容，位移 不过还是O(n)的时间复杂度</li>
<li>线程不安全</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/linkedlist-unlink.jpg" alt="unlink 方法逻辑"></p>
<p>新增双链尾首尾特有方法：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915001950393.png" alt="LinkedList"></p>
<p>适用场景：</p>
<ul>
<li><p>对首尾的操作性能很高，LinkedList可以用来实现先进先出(FIFO)的 <strong>队列</strong></p>
<ul>
<li><p><code>LinkedList queue = new LinkedList&lt;&gt;();</code></p>
</li>
<li><p><code>Enqueue</code>⇔<code>addLast</code> <code>Dequeue</code>⇔<code>removeFirst</code></p>
</li>
</ul>
</li>
<li><p>可以实现<strong>Stack</strong> 栈</p>
<ul>
<li><p><code>LinkedList stack = new LinkedList&lt;&gt;();</code></p>
</li>
<li><p><code>push</code>⇔<code>addFirst</code> <code>Pop</code>⇔<code>removeFirst</code></p>
</li>
<li><p><code>push</code> <code>pop</code>方法已经由官方写入API可直接调用</p>
</li>
</ul>
</li>
</ul>
<h3 id="Queue：FIFO"><a href="#Queue：FIFO" class="headerlink" title="Queue：FIFO"></a>Queue：FIFO</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>add/remove实际上是对offer/poll的封装</p>
<ol>
<li><strong>添加元素的方法</strong></li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>add(E e)</code></strong></td>
<td>将指定元素插入队列，如果队列已满，则抛出 <code>IllegalStateException</code> 异常。</td>
</tr>
<tr>
<td><strong><code>offer(E e)</code></strong></td>
<td>将指定元素插入队列，如果队列已满，则返回 <code>false</code> 而不抛异常。</td>
</tr>
</tbody></table>
<p><strong>2. 移除元素的方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>remove()</code></strong></td>
<td>移除队列头部的元素，如果队列为空，则抛出 <code>NoSuchElementException</code> 异常。</td>
</tr>
<tr>
<td><strong><code>poll()</code></strong></td>
<td>移除队列头部的元素，如果队列为空，则返回 <code>null</code>。</td>
</tr>
</tbody></table>
<p><strong>3. 查看元素的方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>element()</code></strong></td>
<td>查看队列头部的元素，不移除。如果队列为空，则抛出 <code>NoSuchElementException</code> 异常。</td>
</tr>
<tr>
<td><strong><code>peek()</code></strong></td>
<td>查看队列头部的元素，不移除。如果队列为空，则返回 <code>null</code>。</td>
</tr>
</tbody></table>
<h4 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h4><ul>
<li><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循FIFO</li>
<li><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素，LinkedList就实现了Deque，因此可以用来模拟栈和队列<ul>
<li>Deque 常用的方法就是对头尾元素的 <code>add/remove/get</code> <code>offer/poll/peek</code>，前者会抛异常，后者不会抛异常只会返回 false(offer) 或者 null(poll/peek) 。</li>
<li>pop = removeFirst   push = addFirst。</li>
</ul>
</li>
</ul>
<h5 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h5><p>基于可变长的数组和双指针来实现，<code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</p>
<h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>
<p>这里列举其相关的一些要点：</p>
<ul>
<li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>
<li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li>
<li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li>
<li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li>
</ul>
<p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。</p>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>详见 JUC</p>
<h3 id="Set-不重复"><a href="#Set-不重复" class="headerlink" title="Set 不重复"></a>Set 不重复</h3><p><code>Set&lt;Integer&gt; set = new HashSet();</code>//无序</p>
<p><code>Set&lt;Integer&gt; set = new LinkedHashSet();</code> //有序</p>
<p><code>Set&lt;Integer&gt; set = new TreeSet()</code> //排序</p>
<h4 id="HashSet-无序"><a href="#HashSet-无序" class="headerlink" title="HashSet 无序"></a>HashSet 无序</h4><ul>
<li>每个对象都有哈希值，int类型，通过<code>hashCode()</code>返回</li>
<li>也可能相同，大部分情况下是相同的</li>
<li>增删改查性能较好，类比查字典，只要看到偏旁就能定位大概的位置</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915124422018.png" alt="JDK 8 之前的 HashSet">数据过多会导致链表过长，查询性能降低，然后就扩容，加载因子0.75*16=12，占到12个数据就开始扩容，2倍大小</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915125104423.png" alt="HashSet 底层结构"></li>
<li>二叉搜索树：小的存左边，大的存右边，一样的不存</li>
<li>平衡二叉树：左右高度差不超过1</li>
<li>红黑树：自平衡的二叉搜索树 </li>
<li>无序，不重复，无索引！<ul>
<li>内容一样的两个对象s1s2，HashSet认为他们不一样</li>
<li>对于HashSet可以重写对象类的<code>equals()</code>方法，比较对象的内容而不是地址，重写<code>hashCode()</code>方法根据对象的内容计算哈希值。<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915125944598.png" alt="equals hashcode"></li>
</ul>
</li>
</ul>
<h5 id="去重原理：Hashmap-put-k-v"><a href="#去重原理：Hashmap-put-k-v" class="headerlink" title="去重原理：Hashmap put(k,v)"></a>去重原理：Hashmap put(k,v)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns: true if this set did not already contain the specified element</span></span><br><span class="line"><span class="comment">// 返回值：当 set 中没有包含 add 的元素时返回真</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而 map 的 put ，只有在key不存在时返回null，其他时候返回旧值，因此key不存在正好能够去重</p>
<h4 id="LinkedHashSet-有序"><a href="#LinkedHashSet-有序" class="headerlink" title="LinkedHashSet 有序"></a>LinkedHashSet 有序</h4><ul>
<li>在HashSet基础上，每个元素多了一个双链表机制记录前后位置，原来链表依然存在，双链表仅用来记录**<mark>添加<mark>先后顺序**</li>
<li>占用内存相对多</li>
</ul>
<h4 id="TreeSet-可自定义排序"><a href="#TreeSet-可自定义排序" class="headerlink" title="TreeSet 可自定义排序"></a>TreeSet 可自定义排序</h4><ul>
<li>不重复无索引，<strong>可排序</strong>。底层红黑树</li>
<li>对数值类型按照大小升序排序，对字符串类型按照首字符编号升序排序</li>
<li>自定义<code>Student</code>对象无法直接排序<ul>
<li><ol>
<li>让<code>Student</code>类实现<code>Comparable</code>接口，重写<code>int compareTo()</code>方法</li>
</ol>
</li>
<li><ol start="2">
<li><code>TreeSet</code>有参构造，用<code>Comparator</code>实现对象指定比较规则，2规则优先</li>
</ol>
</li>
<li>如果指定排序规则是年龄，年龄相等的是不会存的</li>
</ul>
</li>
</ul>
<h3 id="ConcurrentModificationException"><a href="#ConcurrentModificationException" class="headerlink" title="ConcurrentModificationException"></a><span id="concurrentmodificaiton">ConcurrentModificationException</span></h3><ul>
<li><p>遍历集合并删除集合中的元素时，会导致元素位置移动但索引没有及时更新导致的漏操作</p>
</li>
<li><p>迭代器会报错，<code>fori</code> 循环会正常执行但返回结果错误</p>
</li>
<li><p><code>fori</code> 循环：i– 、倒着遍历</p>
</li>
<li><p>迭代器：不能调用集合自己的删除，要调用迭代器自己的删除，相当于也是做了i–的操作</p>
</li>
<li><p>0     1    2    3<br>a     b    c    d</p>
<p>删除b以后，索引为1，下一步是i++，中间插一个i–让索引不变(正序遍历)<br>删除b以后，索引为1，下一步是i–，不影响正常的遍历（倒序遍历）</p>
</li>
</ul>
<p>迭代器遍历的是开始遍历那一刻拿到的集合拷贝，遍历期间原集合发生的修改迭代器不知道。</p>
<p><strong>不要<mark>在 forEach 循环里进行元素的 <code>remove/add</code> 操作<mark>。remove 元素请使用 <code>Iterator</code> 方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;Hollis&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> userNames.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iterator.next().equals(<span class="string">&quot;Hollis&quot;</span>)) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(userNames);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>removeIf：遍历并删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line">list.removeIf(filter -&gt; filter % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">/* 删除list中的所有偶数 */</span></span><br><span class="line">System.out.println(list); <span class="comment">/* [1, 3, 5, 7, 9] */</span></span><br></pre></td></tr></table></figure>

<p><strong><mark>如果并发操作<mark>，在使用iterator迭代的时候使用synchronized或者Lock进行同步，或者使用JUC</strong> </p>
<p>并发情况下使用juc的并发集合，这样的集合容器在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p>
<p>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul>
<li>可以不传参数，也可以传一个，两个多个，也可以传数组，接收数据比较灵活</li>
<li>对外是灵活接收数据，对内就是一个数组</li>
<li>一个参数列表只有一个可变参数，而且要放在最后</li>
</ul>
<h3 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915140018933.png" alt="Collections"></p>
<ul>
<li><code>addAll(Collection&lt;? super T&gt; c, T...elements)</code>为集合批量添加数据<ul>
<li>泛型属于多态写法，<code>Animal</code>的<code>List</code>可以接收猫<code>Cat</code>和狗<code>Dog</code>作为可变参数</li>
</ul>
</li>
<li><code>shuffle(List&lt;?&gt; list)</code> 打乱 <mark>list<mark> 的顺序</li>
<li><code>sort(List&lt;?&gt; list)</code> 帮助list排好序，自定义类要实现<code>Comparable</code>接口</li>
<li><code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code> 帮助list排好序,自定义排序规则 <code>Animal</code> 的<code>Comparator</code>可以给<code>Cat</code>排序</li>
</ul>
<p>重写T的toString方法，控制println的输出</p>
<h2 id="Map-双列-K-V"><a href="#Map-双列-K-V" class="headerlink" title="Map 双列 (K-V)"></a>Map 双列 (K-V)</h2><ul>
<li>键值对集合 <code>key-value</code></li>
<li><code>key</code>不允许重复 <code>value</code>允许重复</li>
</ul>
<ol>
<li><code>HashMap</code>无序、不重复、无索引,键相同的会覆盖值</li>
<li><code>LinkedHashMap</code>有序(添加顺序)、不重复、无索引</li>
<li><code>TreeMap</code>大小默认升序、不重复、无索引</li>
</ol>
<p><code>Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();</code></p>
<h3 id="Map-常用方法"><a href="#Map-常用方法" class="headerlink" title="Map 常用方法"></a>Map 常用方法</h3><ul>
<li><code>put(K key, V value)</code>把键值对加入Map</li>
<li><code>void clear()</code> <code>int size()</code> <code>boolean isEmpty()</code> </li>
<li><code>boolean containsKey(Object key)</code> 是否有某个键</li>
<li><code>boolean containsValue(V val)</code>是否有值<code>val</code> </li>
<li><code>V get(Object key)</code> 根据键获取值 不存在返回<code>null</code></li>
<li><code>V remove(Object key)</code>根据键获取值, 删除</li>
<li><code>Set&lt;K&gt; keySet()</code> 获取包含所有键的集合，无序不重复无索引</li>
<li><code>Collection&lt;V&gt; values()</code> 获取所有值的集合，<strong>可重复</strong> </li>
<li><code>map1.putAll(Map&lt;E&gt; map2)</code>map2所有元素加入map1，能覆盖的覆盖</li>
</ul>
<h3 id="Map-遍历方式"><a href="#Map-遍历方式" class="headerlink" title="Map 遍历方式"></a>Map 遍历方式</h3><ol>
<li><p>键找值</p>
<ol>
<li><code>keySet()</code> 获取所有键</li>
<li><code>V get(Object key)</code> 根据键找值</li>
</ol>
</li>
<li><p>键值对</p>
<ol>
<li><p><code>Map.Entry&lt;K,V&gt;</code> API自带的Entry类型把Key-Value看做一个整体</p>
</li>
<li><p><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code> 返回一个Set，包含所有Entry对象</p>
</li>
<li><p>增强for循环遍历<code>Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entryset</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry: entryset)&#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Lambda表达式(<strong>Most Simple</strong>)</p>
<ul>
<li><code>map.forEach((k,v)-&gt;&#123;System.out.println(k + &quot;+&quot; + v)&#125;)</code></li>
<li><code>forEach</code>方法的参数是<code>BiConsumer</code>接口的实现对象，要求重写<code>action</code>函数(遍历的时候要做的事情)</li>
<li><code>forEach</code>方法具体的实现：用增强for循环遍历键值对组成的的Set</li>
</ul>
</li>
</ol>
<h3 id="HashMap-无序"><a href="#HashMap-无序" class="headerlink" title="HashMap 无序"></a>HashMap 无序</h3><h4 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a><a href="#hashmap-%E5%92%8C-hashset-%E5%8C%BA%E5%88%AB">HashMap 和 HashSet 区别</a></h4><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p>
<table>
<thead>
<tr>
<th align="center"><code>HashMap</code></th>
<th align="center"><code>HashSet</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现了 <code>Map</code> 接口</td>
<td align="center">实现 <code>Set</code> 接口</td>
</tr>
<tr>
<td align="center">存储键值对</td>
<td align="center">仅存储对象</td>
</tr>
<tr>
<td align="center">调用 <code>put()</code>向 map 中添加元素</td>
<td align="center">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td>
</tr>
<tr>
<td align="center"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td>
<td align="center"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td>
</tr>
</tbody></table>
<ul>
<li>增删改查数据，性能都较好的集合</li>
<li>无序不重复无索引</li>
<li>Key依赖hashCode和equals保证键的唯一性</li>
<li>如果存储自定义对象，重写上述方法即可</li>
<li>HashSet实际上就是HashMap实现的，只关注键</li>
<li>线程不安全</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/jdk1.8_hashmap.png" alt="JDK 1.8 之后的内部结构-HashMap"></p>
<h4 id="HashTable-Deprecated"><a href="#HashTable-Deprecated" class="headerlink" title="HashTable(Deprecated)"></a><del>HashTable(Deprecated)</del></h4><p><code>Hashtable</code>：数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的。基本都是直接在方法中加<code>synchronized</code>，性能比ConcurrentHashMap弱很多。与 Hashmap相比线程安全，不支持null</p>
<h4 id="HashMap-遍历"><a href="#HashMap-遍历" class="headerlink" title="HashMap 遍历"></a>HashMap 遍历</h4><p><code>EntrySet</code> 之所以比 <code>KeySet</code> 的性能高是因为，<code>KeySet</code> 在循环时使用了 <code>map.get(key)</code>，而 <code>map.get(key)</code> 相当于又遍历了一遍 Map 集合去查询 <code>key</code> 所对应的值。为什么要用“又”这个词？那是因为<strong>在使用迭代器或者 for 循环时，其实已经遍历了一遍 Map 集合了，因此再使用 <code>map.get(key)</code> 查询时，相当于遍历了两遍</strong>。</p>
<p>而 <code>EntrySet</code> 只遍历了一遍 Map 集合，之后通过代码“Entry&lt;Integer, String&gt; entry = iterator.next()”把对象的 <code>key</code> 和 <code>value</code> 值都放入到了 <code>Entry</code> 对象中，因此再获取 <code>key</code> 和 <code>value</code> 值时就无需再遍历 Map 集合，只需要从 <code>Entry</code> 对象中取值就可以了。</p>
<p>所以，**<code>EntrySet</code> 的性能比 <code>KeySet</code> 的性能高出了一倍，因为 <code>KeySet</code> 相当于循环了两遍 Map 集合，而 <code>EntrySet</code> 只循环了一遍**。</p>
<h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>默认的<strong>数组长度</strong>为 16，也就是<strong>容量 or 桶数量（capacity / number of buckets）</strong></p>
<p>数据过多会导致链表过长，查询性能降低</p>
<p><strong>加载因子（loadfactor）</strong>为 0.75</p>
<p>元素个数达到<strong>阈值（threshold）</strong>: capacity*loadfactor = 16*0.75 = 12 ，扩容到原来的两倍</p>
<p>扩容后，需要将原数组中的所有元素重新计算哈希值，并放入新的桶中，这个过程称为<strong>rehash</strong>，会有性能损耗，因此要尽量减少扩容次数。</p>
<h5 id="为什么容量必须是-2-n"><a href="#为什么容量必须是-2-n" class="headerlink" title="为什么容量必须是 2^n^"></a>为什么容量必须是 2^n^</h5><ol>
<li>容量cap 参与 hash % cap 运算，相当于截取低位，cap 如果是2的幂次方，cap-1就是全1，hash % cap = hash &amp; (cap-1)，通过位运算提高了效率。</li>
<li>还有一方面，因为cap-1是全1，因此hash的每一位都能充分参与运算，降低了哈希冲突的风险。</li>
<li>扩容后只需检查哈希值高位的变化来决定元素的新位置，要么位置不变（高位为 0），要么就是移动到新位置（高位为 1，原索引位置+原容量）。详见下文的<a href="#rehash">rehashing</a></li>
</ol>
<h4 id="链表转红黑树"><a href="#链表转红黑树" class="headerlink" title="链表转红黑树"></a>链表转红黑树</h4><p>JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，<strong>如果当前数组的长度小于 64</strong>，那么会选择<strong>先进行数组扩容</strong>，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="FIELDs-属性字段"><a href="#FIELDs-属性字段" class="headerlink" title="FIELDs 属性字段"></a>FIELDs 属性字段</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化容量（数组长度），必须是2的幂次方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大容量，必须小于2的30次方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认加载因子 LoadFactor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表转换成树的阈值（链表长度）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树转换回链表的阈值（链表长度）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表转换成树的阈值（数组容量）</span></span><br><span class="line"><span class="comment"> * 应该至少为TREEIFY_THRESHOLD的4倍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<h5 id="节点-Node-lt-K-V-gt"><a href="#节点-Node-lt-K-V-gt" class="headerlink" title="节点 Node&lt;K,V&gt;"></a>节点 Node&lt;K,V&gt;</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">// 哈希值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 下一个节点</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 设置新的返回旧的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;value = newValue;<span class="keyword">return</span> oldValue;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> Map.Entry&lt;?, ?&gt; e</span><br><span class="line">                &amp;&amp; Objects.equals(key, e.getKey())</span><br><span class="line">                &amp;&amp; Objects.equals(value, e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Contructor"><a href="#Contructor" class="headerlink" title="Contructor"></a>Contructor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment"> * for keySet() and values().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> * 数组 table 每个 Entry 都是一个 节点Node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructors</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定“容量大小”和“负载因子”的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    	initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line"><span class="comment">// 初始容量暂时存放到 threshold ，在resize中再赋值给 newCap 进行table初始化</span></span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> (n &lt; <span class="number">0</span>)? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>四个构造方法中，都初始化了负载因子 loadFactor，由于 HashMap 中没有 capacity 这样的字段，即使指定了初始化容量 initialCapacity ，也只是通过 tableSizeFor() 扩容到与 initialCapacity 最接近的 2 的幂次方大小，然后<strong>暂时赋值给 threshold ，后续通过 resize 方法将 threshold 赋值给 newCap 进行 table 的初始化。</strong> </p>
<h6 id="使用另一个map构造-putMapEntries-map"><a href="#使用另一个map构造-putMapEntries-map" class="headerlink" title="使用另一个map构造 putMapEntries(map)"></a>使用另一个map构造 <code>putMapEntries(map)</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// s 是实际个数，dt 就是添加 s 个元素的最小容量 ceil 向上取整</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">dt</span> <span class="operator">=</span> Math.ceil(s / (<span class="type">double</span>)loadFactor);</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((dt &lt; (<span class="type">double</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)dt : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 如果超过</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 已经初始化，只要超过阈值就要 resize</span></span><br><span class="line">            <span class="comment">// Because of linked-list bucket constraints, we cannot</span></span><br><span class="line">            <span class="comment">// expand all at once, but can reduce total resize</span></span><br><span class="line">            <span class="comment">// effort by repeated doubling now vs later</span></span><br><span class="line">            <span class="keyword">while</span> (s &gt; threshold &amp;&amp; table.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="getNode"><a href="#getNode" class="headerlink" title="getNode()"></a><code>getNode()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n, hash; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; (hash = hash(key))]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// 快速检查头节点</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; </span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e; <span class="comment">// 从头节点开始遍历。</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="putVal"><a href="#putVal" class="headerlink" title="putVal()"></a><code>putVal()</code></h5><p>体现了懒加载的思想，只有真正put的时候才初始化资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 1. 如果没有初始化，先调用resize初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 2.1 没有哈希冲突的情况</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 2.2 出现了哈希冲突/值重复，在else逻辑里return</span></span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="comment">// .......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 没有哈希冲突或者值重复，元素自增与扩容策略</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);<span class="comment">// 用于LinkedHashMap支持LRU实现,HashMap无用</span></span><br><span class="line">    <span class="comment">// 4. key值不存在,则返回值是null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="哈希冲突-值重复"><a href="#哈希冲突-值重复" class="headerlink" title="哈希冲突/值重复"></a>哈希冲突/值重复</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p 是链表/树的第一个节点</span></span><br><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="comment">/* 1. 快速判断第一个节点table[i]的key是否与插入的key一样 先判断 hash </span></span><br><span class="line"><span class="comment">				若相同就将现在的节点p赋给e，然后在4中处理。     */</span> 		</span><br><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp; <span class="comment">// key 的 hash </span></span><br><span class="line"><span class="comment">// 1.5 短路逻辑：先用 == 比较地址，地址不同再用equals比较内容（K需要重写equals）</span></span><br><span class="line">	((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    e = p;</span><br><span class="line"><span class="comment">// 2. 树节点去执行树的逻辑</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="comment">// 3. 链表节点</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="comment">// 3.0 边遍历边比较是否出现了重复key, binCount+1 能得出链表长度</span></span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 3.1 一直遍历到了尾部，说明肯定没有重复的，在链表尾端创建新 Node</span></span><br><span class="line">            p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 3.2 如果到了 TREEIFY_THRESHOLD 就触发 treeifyBin 扩容或</span></span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">            <span class="comment">// 3.3 跳出循环 e == null, 不会走重复的逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.5 判断key是否重复 重复就直接跳出，去4处理key的重复情况 e!=null</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        p = e;<span class="comment">// 遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. key 重复 应对1和3.5的重复情况 </span></span><br><span class="line"><span class="comment">// 	在putIfAbsent中，onlyIfAbsent = true, 在put中，onlyIfAbsent = false</span></span><br><span class="line"><span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">    <span class="comment">// putIfAbsent只有原值null才能赋值</span></span><br><span class="line">    <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>) </span><br><span class="line">        e.value = value;</span><br><span class="line">    afterNodeAccess(e);<span class="comment">//回调方法，只在LinkedHashMap中实现,可维护访问顺序(如LRU)</span></span><br><span class="line">    <span class="comment">// 4.5 key值如果存在,则会返回原先被替换掉的value值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="removeNode"><a href="#removeNode" class="headerlink" title="removeNode()"></a><code>removeNode()</code></h5><p>remove主要有两个：一个是remove(key)，返回值为被删除的value，如果节点不存在则返回null</p>
<p>另一个是remove(key,value) 用来表示只有key对应的值为value时才移除，返回值为boolean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">/**  1. 寻找匹配到key的节点</span></span><br><span class="line"><span class="comment">      *  短路条件1: table 不为空(已初始化过)</span></span><br><span class="line"><span class="comment">      *  短路条件2: key 对应的桶不为空</span></span><br><span class="line"><span class="comment">      *  同时满足上述两个条件才会进入正式判断，否则直接返回 null</span></span><br><span class="line"><span class="comment">      *  p 现在是桶的第一个节点。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 1.1 快速检查: 先检查桶的第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">// 1.2 开始遍历， e 相当于 tmp</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">// 树节点</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">// 链表节点</span></span><br><span class="line">                <span class="keyword">do</span> &#123; </span><br><span class="line">                    <span class="comment">// 1.2.1 找到了节点，直接break，将e赋给node</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;<span class="comment">//  p是e的前驱</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 2. 正式开始删除节点</span></span><br><span class="line"><span class="comment">          * node 为将要删除的节点</span></span><br><span class="line"><span class="comment">          * remove(k,v)-&gt;matchValue=true | remove(k)-&gt;matchValue = false</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">// 对应 1.1 快速检查, 将node.next赋值给tab[i]</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//对应 1.2.1, p 是 node 的前驱节点， 直接将node.next赋给p.next</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;<span class="comment">// 减小容量</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;<span class="comment">// 返回被删除的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="resize"><a href="#resize" class="headerlink" title="resize()"></a><code>resize()</code></h5><p>用于初始化或扩容，初始化就调用属性字段里面的 threshold 初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//—————————扩容——————————</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩容两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// threshold * 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//————————初始化——————————</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">    <span class="comment">// 创建时指定了初始化容量或者负载因子 就会把算出的容量暂时存放到threshold中</span></span><br><span class="line">    <span class="comment">// 			在这里进行新容量的初始化</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">// 创建时无参构造，就使用默认的 capacity 和 threshold 对容量和阈值进行初始化</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建时指定了初始化容量或者负载因子，在这里进行新阈值的初始化，</span></span><br><span class="line">        <span class="comment">// 或者扩容前的旧容量小于16，在这里计算新的resize上限</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; <span class="comment">// 新的阈值。</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">// 正式创建新的数组, 可以看到分配大小为 newCap</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// oldTab 的 rehash</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新的 Table 数组;</span></span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="rehashing-oldTab"><a href="#rehashing-oldTab" class="headerlink" title="rehashing oldTab"></a><span id="rehash">rehashing oldTab</span></h6><p>索引本质还是哈希值对容量取余。</p>
<p>HashMap 扩容时采用的容量是 <strong>2 的幂次方</strong>，它的二进制特性使得新容量只在<strong>高位多出一位 1</strong>。</p>
<p>元素 A B 的哈希值分别为 2 和 6，容量从 4 扩容到 8：</p>
<ul>
<li><code>0010 &amp; 0011 = 0010</code> <code>0110 &amp; 0011 = 0010</code>  旧索引均为 2</li>
<li><code>0010 &amp; 0111 = 0010</code> <code>0110 &amp; 0111 = 0110</code>  新索引分别为 2 和 6</li>
</ul>
<p><strong>二者的区别仅在于高位是否为 1</strong>：避免了复杂的哈希重算，仅通过简单的位运算就完成了分配。</p>
<p>本质上还是取hash值的低位，原来只取低两位，只有这两位参与运算，新的需要取低三位，那么此时直接和原容量 <code>0100</code> 相与，看看第三位是不是0，如果第三位是0，索引当然不变，如果第三位是1，新的索引就是原索引+原容量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;<span class="comment">// tmp</span></span><br><span class="line">    <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="literal">null</span>)<span class="comment">// 如果没有后继节点，直接映射到新的哈希位即可</span></span><br><span class="line">            newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">		<span class="comment">// e.hash &amp; (newCap - 1) 等价于 e.hash % newCap</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">// 树：</span></span><br><span class="line">            ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order 保证原来的顺序</span></span><br><span class="line">            Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>; <span class="comment">// 低索引，索引不变</span></span><br><span class="line">            Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>; <span class="comment">// 高索引，索引变化</span></span><br><span class="line">            Node&lt;K,V&gt; next;</span><br><span class="line">            <span class="comment">// 链表尾插法</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                next = e.next;</span><br><span class="line">                <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 还在原桶</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                        loHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 换到新桶</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                        hiHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 在旧桶的，索引不变</span></span><br><span class="line">                loTail.next = <span class="literal">null</span>;</span><br><span class="line">                newTab[j] = loHead;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 在新桶的，新索引为原索引+原容量</span></span><br><span class="line">                hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                newTab[j + oldCap] = hiHead;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newTab;</span><br></pre></td></tr></table></figure>

<h6 id="链表尾插法-防止多线程死循环"><a href="#链表尾插法-防止多线程死循环" class="headerlink" title="链表尾插法 防止多线程死循环"></a><strong>链表尾插法</strong> 防止多线程死循环</h6><p>JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</p>
<p>为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 <code>HashMap</code>，因为多线程下使用 <code>HashMap</code> 还是会存在数据覆盖的问题。并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</p>
<blockquote>
<p><code>if (tail == null)     head = e; </code></p>
<p><code>else tail.next = e;</code>    </p>
<p><code>tail = e;</code>    </p>
</blockquote>
<h5 id="treeifyBin"><a href="#treeifyBin" class="headerlink" title="treeifyBin()"></a><code>treeifyBin()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 如果容量没有超过阈值64，优先扩容！</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedHashMap-有序"><a href="#LinkedHashMap-有序" class="headerlink" title="LinkedHashMap 有序"></a>LinkedHashMap 有序</h3><ul>
<li>有序（添加顺序） 不重复 无索引</li>
<li>HashMap加了双链表机制记录添加顺序</li>
<li>LinkedHashSet实际上就是LinkedHashMap实行的</li>
</ul>
<p>继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看</p>
<h3 id="TreeMap-可自定义排序-定向搜索"><a href="#TreeMap-可自定义排序-定向搜索" class="headerlink" title="TreeMap 可自定义排序 定向搜索"></a>TreeMap 可自定义排序 定向搜索</h3><ul>
<li>基于红黑树，TreeSet跟TreeMap原理一样</li>
<li>排序：自定义排序规则<ul>
<li>自定义的类实现<code>Comparable</code>接口，重写 <code>int compareTo(Object o)</code>方法</li>
<li>TreeMap的有参构造 参数是<code>Comparator</code>的实现对象，重写了<code>int compare()</code>方法</li>
</ul>
</li>
</ul>
<h4 id="集合嵌套"><a href="#集合嵌套" class="headerlink" title="集合嵌套"></a>集合嵌套</h4><p><code>Map&lt;String,List&lt;String&gt;&gt; cityMap = new HashMap&lt;&gt;();</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915170039061.png" alt="嵌套"></p>
<h2 id="Arrays-数组操作"><a href="#Arrays-数组操作" class="headerlink" title="Arrays 数组操作"></a>Arrays 数组操作</h2><ul>
<li><p><code>toString(Object[] arr)</code> 返回一个数组字符串，每个元素调用<code>toString()</code>转换成字符串，用<code>[,,,]</code>拼接成一个总字符串</p>
</li>
<li><p> <code>copyOfRange(Object[] arr, from, to)</code> 返回值为数组， 内容为arr中索引 <strong>[from, to)</strong> 的部分</p>
</li>
<li><p><code>copyOf(Object[] arr, int newlength)</code> 返回值为数组，内容为arr的内容，长度为newlength，不够的用0补齐，索引超出的截断</p>
</li>
<li><p><code>setAll</code>  第二个参数是接口<code>IntToDoubleFunction</code>的实现对象，重写了<code>applyAsDouble(int value)</code>方法，value是数组的索引，返回对数组中内容进行操作的结果，图中是将数组内容乘以0.8。这个对象传进来以后，对数组进行遍历，都用<code>applyAsDouble</code>的方法进行操作。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913170741004.png" alt="applyAsDouble"></p>
</li>
<li><p><code>sort([] arr)</code> 对arr升序排序(默认升序)</p>
</li>
<li><p><code>asList()</code>:只能加<strong>引用类型</strong>，基本数据类型需要改成包装类，并且返回的<code>List</code>是不能运用<code>add remove clear</code>方法的，这个<code>list</code>是<code>AbstractList</code>的子类，如果要访问<code>utils</code>只能将返回的这个<code>List</code>添加到<code>new ArrayList&lt;&gt;()</code>作为有参构造</p>
</li>
</ul>
<h3 id="对象数组排序"><a href="#对象数组排序" class="headerlink" title="对象数组排序"></a>对象数组排序</h3><p><strong>自己指定比较规则</strong> </p>
<ul>
<li><p>方法1：对象类实现<code>Comparable&lt;E&gt;</code>这个泛型接口，类中重写<code>int compareTo(E e)</code> 方法，将E改为自己的对象类型。</p>
<ul>
<li>约定，左边大于右边 return 正整数，小于 return 负整数，等于 return 0;（升序排序）</li>
<li><code>return this.age - o.age</code>  注意返回值是int double可以调用<code>Double.compare(o1.height, o2.height)</code></li>
<li>调用<code>Arrays.sort(students)</code>即可</li>
</ul>
</li>
<li><p>方法2：实现<code>Comparator</code>这个泛型接口，运用</p>
<ul>
<li><p>sort有一个重载函数，第一个参数是对象数组<code>T[] arr</code>，第二个参数是<code>Comparator&lt;? super T&gt; comparator</code></p>
</li>
<li><p>泛型接口做参数用匿名内部类实现，类中重写<code>int compare(T o1,T o2)</code>方法，同时注意返回的是int</p>
</li>
</ul>
</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Students&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(o1.height,o2.height);<span class="comment">//升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>ArrayList有自己的sort方法，实现同Comparator，可以免去泛型的指定</li>
</ul>
<h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><ul>
<li>需要有<strong>数据源</strong>，集合/数组等</li>
<li>调用流水线的方法对集合处理、计算</li>
<li>支持链式方法</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915171033434-1735476275516-27.png" alt="stream 流"></p>
<p>得到流，filter forEach</p>
<h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><h3 id="获取Stream流"><a href="#获取Stream流" class="headerlink" title="获取Stream流"></a>获取Stream流</h3><ul>
<li>流的泛型就是集合中元素的类型</li>
<li><strong>集合</strong>：<code>set.stream()</code> </li>
<li><strong>数组</strong>：<ul>
<li><code>Arrays.stream(T[] array)</code></li>
<li><code>Stream&lt;T&gt;.of(T...values)</code> </li>
</ul>
</li>
<li>Map：处理键用<code>keySet</code>，处理值用<code>values</code> Map.Entry用<code>entrySet</code> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240915171810424-1735476275516-28.png" alt="entrySet"></li>
</ul>
<h3 id="中间方法"><a href="#中间方法" class="headerlink" title="中间方法"></a>中间方法</h3><ul>
<li>返回新的Stream流支持链式编程</li>
<li><code>filter</code>:接口的实现<code>filter(s-&gt;s.getAge&gt;=23 &amp;&amp; s.getAge&lt;=30)</code>重写<code>boolean test()</code>方法返回值是一个布尔变量。<strong>筛选条件</strong> s就代表集合中的元素</li>
<li><code>sorted</code>:无参数默认根据值升序排序，有参数（实现<code>Comparator</code>接口并重写<code>int compare(o1,o2)</code>）自定义排序规则。<strong>排序</strong></li>
<li><code>limit(long maxSize)</code>:取前3个对象 </li>
<li><code>skip(long n)</code>:跳过前n个对象，“指针”移动到对应位置，可以实现逻辑分页</li>
<li><code>distinct()</code>:去重</li>
<li><code>map(mapper)</code>:把集合中元素映射，mapper <code>map(Student::getName)</code> <code>map(s-&gt;s.getName())</code> 把集合中的元素 通过映射方法<code>mapper</code> 转换成对应元素</li>
<li><code>distinct()</code>:去重复，<strong>自定义</strong>类型对象如果希望对比内容，应该重写<code>hashCode()</code> <code>equals()</code>方法</li>
<li><code>Stream.concat(st1,st2)</code>:合并两个流内容,返回新的流</li>
<li><code>boxed()</code> 基本数据类型装箱操作</li>
</ul>
<h3 id="终结方法-void"><a href="#终结方法-void" class="headerlink" title="终结方法 void"></a>终结方法 void</h3><ul>
<li>（没有返回值）</li>
<li><code>void forEach(action)</code>: <code>forEach(s-&gt;System.out.println(s))</code> 元素s -&gt; 指定s想做的事情</li>
<li><code>long count()</code>: 返回经过前面处理以后集合剩下的元素个数</li>
<li><code>max((o1,o2)-&gt;Double.compare(o1.getScore(),o2.getScore()))</code> </li>
<li><code>min()</code>同<code>max()</code> 实现<code>Comparator</code></li>
<li><code>get()</code>:用于在<code>min max</code>后接收对象</li>
<li><code>collect(Collectors.toList())</code> <code>collect(Collectors.toSet())</code> 把流收集起来转换成集合</li>
<li><code>collect(Collectors.toMap(a-&gt;a.getName() , a-&gt;a.getHeight()))</code> 两个接口做参数，Lambda表达式。如果遇到<code>key</code>冲突，<code>toMap</code>需要调用重载函数，启用第三个参数，<code>(o1,o2)-&gt;o2</code>表示前后<code>key</code>冲突时，后添加的<code>value</code>会覆盖之前的<code>value</code></li>
<li><code>collect(Collectors.groupingBy(Shop::getTypeId))</code>把流收集起来，并按照typeId分组，返回一个typeId:集合Map</li>
<li><code>toArray()</code>将流中的元素收集到一个<code>Object</code><strong>数组中</strong> </li>
<li><code>toArray(len -&gt; new Student[len])</code>将流中的元素收集到一个指定<code>Student</code>类型的数组中 方法引用<code>toArray(Student[]::new)</code> 此处参数是<code>IntFunction&lt;A[]&gt;</code>接口的实现对象<code>generator</code> 重写函数需要<code>return</code>一个对应类型的数组，故可以用此写法</li>
</ul>
<h3 id="toList-amp-collect-Collectors-toList"><a href="#toList-amp-collect-Collectors-toList" class="headerlink" title="toList() &amp; collect(Collectors.toList())"></a>toList() &amp; collect(Collectors.toList())</h3><ul>
<li>确定其是一个不再被set/add/remove的list 可使用 Stream <code>toList</code>; 如果使用<code>collect(Collectors.toList())</code> ,sonar或idea自带以及第三方的一些code checker会爆warning, 以本人经验，可以使用<code>collect(Collectors.toCollection(ArrayList::new))</code>来代替</li>
</ul>
<p>另外ListOf也是返回的不可增删改的List</p>
<p>Lambda表达式省略规则 REVIEW</p>
<ul>
<li><p>只有一个参数可以省略<code>()</code> ，没有参数不能省略</p>
</li>
<li><p><code>-&gt;</code>后是具体的函数重写，多条语句需要<code>&#123;&#125;</code> <code>;</code> 单条语句可以省略分号</p>
<ul>
<li>单条语句分为有返回值和无返回值，只有一行<code>return</code>的可以省略<code>return</code>关键字，没有返回值的比如输出<code>System.out.println(s)</code> 就要注意了</li>
<li><code>a-&gt;a.getName()</code> 要么getName()的返回值 matters 要么没有返回值 </li>
</ul>
</li>
<li><p>方法引用</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Item, String&gt; getNameFunction = item -&gt; item.getName();</span><br><span class="line"></span><br><span class="line"><span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> getNameFunction.apply(item);  <span class="comment">// 返回 &quot;Apple&quot;</span></span><br><span class="line"></span><br><span class="line">R <span class="title function_">apply</span><span class="params">(T t)</span>;<span class="comment">//抽象方法 给一个T，返回R类型</span></span><br><span class="line">String <span class="title function_">apply</span><span class="params">(Item item)</span>;<span class="comment">//泛型将接口具体化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">键：return 键 </span></span><br><span class="line"><span class="comment">值：return 值 </span></span><br><span class="line"><span class="comment">转换成 Lambda 表达式 调用的函数必须有返回值的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>操作数组：最终的目的仍然是数组、集合</p>
<h1 id="集合最佳实践"><a href="#集合最佳实践" class="headerlink" title="集合最佳实践"></a>集合最佳实践</h1><p>（1）根据需要选择正确的集合类型。比如，如果指定了大小，我们会选用Array而非ArrayList。如果我们想根据插入顺序遍历一个Map，我们需要使用TreeMap。如果我们不想重复，我们应该使用Set。</p>
<p>（2）一些集合类允许指定初始容量，所以如果我们能够估计到存储元素的数量，我们可以使用它，就避免了重新哈希或大小调整。</p>
<p>（3）基于接口编程，而非基于实现编程，它允许我们后来轻易地改变实现。</p>
<p>（4）总是使用类型安全的泛型，避免在运行时出现ClassCastException。</p>
<p>（5）使用JDK提供的不可变类作为Map的key，可以避免自己实现hashCode()和equals()。</p>
<p>（6）尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的实现。它将会提供代码重用性，它有着更好的稳定性和可维护性。</p>
<h2 id="集合判空"><a href="#集合判空" class="headerlink" title="集合判空"></a>集合判空</h2><p>这是因为 <code>isEmpty()</code> 方法的可读性更好，并且时间复杂度为 <code>O(1)</code>。</p>
<p>绝大部分我们使用的集合的 <code>size()</code> 方法的时间复杂度也是 <code>O(1)</code>，不过，也有很多复杂度不是 <code>O(1)</code> 的，比如 <code>java.util.concurrent</code> 包下的 <code>ConcurrentLinkedQueue</code>。<code>ConcurrentLinkedQueue</code> 的 <code>isEmpty()</code> 方法通过 <code>first()</code> 方法进行判断，其中 <code>first()</code> 方法返回的是队列中第一个值不为 <code>null</code> 的节点（节点值为<code>null</code>的原因是在迭代器中使用的逻辑删除）</p>
<h2 id="集合遍历-iterator-并发修改异常"><a href="#集合遍历-iterator-并发修改异常" class="headerlink" title="集合遍历 iterator 并发修改异常"></a><a href="#concurrentmodificaiton">集合遍历 iterator 并发修改异常</a></h2><h2 id="集合转-Map"><a href="#集合转-Map" class="headerlink" title="集合转 Map"></a>集合转 Map</h2><p>**在使用 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。 **</p>
<h2 id="集合转数组"><a href="#集合转数组" class="headerlink" title="集合转数组"></a>集合转数组</h2><p><code>toArray(T[] array)</code> 方法的参数是一个泛型数组，如果 <code>toArray</code> 方法中没有传递任何参数的话返回的是 <code>Object</code>类 型数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String [] s= <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;lazy&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;over&quot;</span>, <span class="string">&quot;jumps&quot;</span>, <span class="string">&quot;fox&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="string">&quot;quick&quot;</span>, <span class="string">&quot;A&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line"><span class="comment">//没有指定类型的话会报错</span></span><br><span class="line">s=list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>由于 JVM 优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型</p>
<h2 id="数组转集合"><a href="#数组转集合" class="headerlink" title="数组转集合"></a>数组转集合</h2><p><strong><code>Arrays.asList()</code>是泛型方法，传递的数组必须是对象数组，而不是基本类型。</strong> </p>
<p>toList() &amp; collect(Collectors.toList())</p>
<p><code>Arrays.asList()</code> 或者流的<code>toList()</code>或者<code>List.of()</code>，得到的List只能读，不能进行修改操作，因为这个list是AbstarctList的实现类，并没有实现修改的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></span><br><span class="line"><span class="type">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p><code>List list = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</code> 也可以</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2023/12/25/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/25/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-25 00:00:00" itemprop="dateCreated datePublished" datetime="2023-12-25T00:00:00+08:00">2023-12-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 13:48:42" itemprop="dateModified" datetime="2025-04-26T13:48:42+08:00">2025-04-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/12/25/hello-world/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2023/11/23/C++%20%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/23/C++%20%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">cppnotes</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-23 00:00:00" itemprop="dateCreated datePublished" datetime="2023-11-23T00:00:00+08:00">2023-11-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-03 22:42:39" itemprop="dateModified" datetime="2025-05-03T22:42:39+08:00">2025-05-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="C-笔记"><a href="#C-笔记" class="headerlink" title="C++ 笔记"></a>C++ 笔记</h1><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul>
<li><p>如果程序执行错误，就throw一个异常</p>
<p>b是一个int</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> b </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="built_in">catch</span> (<span class="type">int</span> b)&#123;</span><br><span class="line"></span><br><span class="line">cerr &lt;&lt;b&lt;&lt;endl &#125;</span><br></pre></td></tr></table></figure>

<p>throw 一个字符串常量，catch的参数就是一个const char</p>
</li>
<li><p>throw加在函数声明的后边 void fun() throw(A,B,C,D)</p>
<p>表示函数能抛出ABCD四种类型的错误，不加throw表明能抛出任何类型的异常</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> x = <span class="number">50</span>;</span><br><span class="line">   <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">   <span class="type">double</span> z = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     z = <span class="built_in">division</span>(x, y);</span><br><span class="line">     cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">   &#125;<span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">     cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><ul>
<li>using namespace XXX<br>如果不写using namespace std的话<br>用cout函数就得加std::cout<br>尽量别用，容易污染<br>xx::a 与 yy::a不是一个东西<br>全局作用域符号，用来区分同名的的全局变量与局部变量<br>::不跟类名，表示全局的</li>
</ul>
<h2 id="动态数组（new-amp-delete）"><a href="#动态数组（new-amp-delete）" class="headerlink" title="动态数组（new&amp;delete）"></a>动态数组（new&amp;delete）</h2><ul>
<li>```c++<br>int *p=NULL;<br>p=new int;<br>*p=2;<br>delete p;char *p=NULL;<br>p=new char[10];<br>delete []p;//对象数组是同样的处理方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  我们在用动态内存分配时，经常是用`new`来定义一块内存空间，比如说 `int* p = new int(1)；`这时会在堆上分配一块内存，当作int类型使用，内存中存储的值为1并将内存地址赋值给在栈中的int*类型的p。（注意：p只是一个变量，就像是int a=1中的a一样，不过a是整形变量，而p是指针变量）当我们不用p指针时，往往需要用delete p将其释放，我们需要注意的是释放一个指针p（delete p;）实际意思是删除了p所指的目标（变量或对象），释放了它所占的堆空间，而不是删除p本身（指针p本身并没有撤销，它自己仍然存在，该指针所占内存空间并未释放，指针p的真正释放是随着函数调用的结束而消失），释放堆空间后，p成了&quot;空指针&quot;。如果我们在delete p后没有进行指针p的制空（p=NULL)的话，其实指针p这时会成为野指针，为了使用的安全，我们一般在delete p之后还会加上p=NULL这一语句。具体怎么成为野指针的，这有一篇非常详细的介绍[点击打开链接](http://https//www.cnblogs.com/uniqueliu/archive/2011/07/18/2109778.html)</span><br><span class="line"></span><br><span class="line">## 重载</span><br><span class="line"></span><br><span class="line">- 重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。 </span><br><span class="line"></span><br><span class="line">- 当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。</span><br><span class="line"></span><br><span class="line">## 运算符</span><br><span class="line"></span><br><span class="line">- 位运算符（除去“~”都是双目运算符）</span><br><span class="line"></span><br><span class="line">  | &amp;   与   | 只有同时为1才为1         |</span><br><span class="line">  | -------- | ------------------------ |</span><br><span class="line">  | \|    或 | 只有同时为0才为0         |</span><br><span class="line">  | ^  异或  | 一样就是0 不一样就是1    |</span><br><span class="line">  | ~  取反  | 变成负数，1变成0，0变成1 |</span><br><span class="line">  | &lt;&lt; 左移  | 字面意思                 |</span><br><span class="line">  | &gt;&gt; 右移  | 字面意思                 |</span><br><span class="line"></span><br><span class="line">  ​      A = 0011 1100</span><br><span class="line"></span><br><span class="line">  ​      B = 0000 1101</span><br><span class="line"></span><br><span class="line">  A &amp; B = 0000 1100</span><br><span class="line"></span><br><span class="line">  A  |  B = 0011 1101</span><br><span class="line"></span><br><span class="line">  A  ^ B = 0011 0001</span><br><span class="line"></span><br><span class="line">     ~A   = 1100 0011</span><br><span class="line"></span><br><span class="line">  A&lt;&lt;2  = 1111 0000</span><br><span class="line"></span><br><span class="line">  A&gt;&gt;2  = 0000 1111</span><br><span class="line"></span><br><span class="line">- 赋值运算符</span><br><span class="line"></span><br><span class="line">  +=，-=，/=，%=，*=   不做赘述</span><br><span class="line"></span><br><span class="line">  位运算&lt;&lt;=：`a&lt;&lt;=2`   a=a&lt;&lt;2</span><br><span class="line"></span><br><span class="line">  任何数异或 **^0** 得到的值不变:`a^0 = a`</span><br><span class="line"></span><br><span class="line">  任何数异或同一个数两次得到的值不变:`a^b^b = a`</span><br><span class="line"></span><br><span class="line">## 类与对象</span><br><span class="line"></span><br><span class="line">- 访问权限：public private protected</span><br><span class="line"></span><br><span class="line">### 	构造函数</span><br><span class="line"></span><br><span class="line">- 定义一个Line类，有一个length成员变量 初始化列表赋初值</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  Line::Line(int  num0):length (num0)</span><br><span class="line">  Line a(1)</span><br></pre></td></tr></table></figure>

如果声明了任何非默认构造函数、编译器不会提供默认构造函数。构造函数在未指定参数或者提供了一个空初始化器列表，则会调用默认构造函数：<code>vector v1; vector v2&#123;&#125;;</code>引用和const必须被初始化</li>
</ul>
<h3 id="复制构造函数（-amp-引用、const的使用）"><a href="#复制构造函数（-amp-引用、const的使用）" class="headerlink" title="复制构造函数（&amp;引用、const的使用）"></a>复制构造函数（&amp;引用、const的使用）</h3><ul>
<li>```c++<br>Line::Line(const Line&amp;obj)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">​		&amp;是引用号作用类似于指针，引用时必须初始化值</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  a=1 ;   </span><br><span class="line">  int &amp;ra =a ;   </span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    相当于起了个别名ra，这样a在用作参数时候使用ra可以不用调用复制构造函数，因此不会造成无限复制构造函数的无限循环。如果引用对象参数为const类型，则不能通过ra修改a，反过来是可以的，但可以修改指针指向的地方。</p>
<p>​    如果对象中有指针，默认复制时指针的值是不会变的，因为他分配的内存是不在对象里面的，在析构    的时候，会出现两次析构相同位置的情况，所以==有指针的情况下最好自己构建一个复制构造函数==，并分配新的内存空间给新对象的指针。并且析构函数中也要额外释放指针，在系统默认的拷贝构造，**对指针的赋值时为==浅拷贝==<strong>，可能会导致直接对位的赋值，从而导致出现野指针情况，</strong>手动处理为==深拷贝==**。</p>
<ul>
<li><p>用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过const的使用，保证了引用传递的安全性。普通引用在声明时必须用其它的变量进行初始化</p>
</li>
<li><p>引用作为函数参数声明时不进行初始化</p>
</li>
<li><p>传递引用是传递原变量，不需要做变量拷贝，普通的变量做函数参数的时候会开辟内存拷贝数值，而传递引用则不需要开辟内存；</p>
<p>C++ primer p406 ：拷贝构造函数是一种特殊的构造函数，具有单个形参，该形参（常用const修饰）是对该类类型的引用。当定义一个新对象并用一个同类型的对象对它进行初始化时，将显示使用拷贝构造函数。当该类型的对象传递给函数或从函数返回该类型的对象时，将隐式调用拷贝构造函数。</p>
</li>
<li><p>C++支持两种初始化形式：</p>
<ul>
<li><p>拷贝初始化 int a = 5; </p>
</li>
<li><p>直接初始化 int a(5); </p>
</li>
<li><p>对于其他类型没有什么区别，对于类类型直接初始化直接调用实参匹配的构造函数，<u>拷贝初始化总是调用拷贝构造函数</u>，也就是说：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A z;        <span class="comment">//定义，调用无参构造函数</span></span><br><span class="line"><span class="function">A <span class="title">x</span><span class="params">(<span class="number">2</span>)</span></span>;　　 <span class="comment">//直接初始化，调用有参构造函数</span></span><br><span class="line">A y = x;　　<span class="comment">//拷贝初始化，调用拷贝构造函数</span></span><br></pre></td></tr></table></figure></li>
<li><p><u>必须定义拷贝构造函数的情况</u>：</p>
<ol>
<li>只包含类类型成员或内置类型（但不是指针类型）成员的类，无须显式地定义拷贝构造函数也可以拷贝；</li>
<li>有的类有一个数据成员是指针，或者是有成员表示在构造函数中分配的其他资源。</li>
</ol>
</li>
<li><p><u>类的对象需要拷贝时，拷贝构造函数将会被调用。以下情况都会调用拷贝构造函数：</u></p>
<ol>
<li><p>一个对象以值传递的方式传入函数体；</p>
</li>
<li><p>一个对象以值传递的方式从函数返回；</p>
</li>
<li><p>一个对象需要通过另外一个对象进行初始化。</p>
</li>
</ol>
</li>
<li><p>实例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">( <span class="type">void</span> )</span></span>;</span><br><span class="line">      <span class="built_in">Line</span>( <span class="type">int</span> len );             <span class="comment">// 简单的有参构造函数</span></span><br><span class="line">      <span class="built_in">Line</span>( <span class="type">const</span> Line &amp;obj);      <span class="comment">// 拷贝构造函数</span></span><br><span class="line">      ~<span class="built_in">Line</span>();                     <span class="comment">// 析构函数</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">int</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 为指针分配内存</span></span><br><span class="line">    ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *ptr = len;</span><br><span class="line">&#125;</span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="type">const</span> Line &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数并为指针 ptr 分配内存&quot;</span>          &lt;&lt; endl;</span><br><span class="line">    ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *ptr = *obj.ptr; <span class="comment">// 拷贝值</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Line::~<span class="built_in">Line</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;释放内存&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Line::getLength</span><span class="params">( <span class="type">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(Line obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;line 大小 : &quot;</span> &lt;&lt; obj.<span class="built_in">getLength</span>() 		         &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Line <span class="title">line1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">   Line line2 = line1; <span class="comment">// 这里也调用了拷贝构造函数</span></span><br><span class="line">   <span class="built_in">display</span>(line1);</span><br><span class="line">   <span class="built_in">display</span>(line2);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">调用构造函数</span><br><span class="line">调用拷贝构造函数并为指针 ptr 分配内存</span><br><span class="line">调用拷贝构造函数并为指针 ptr 分配内存</span><br><span class="line">line 大小 : 10</span><br><span class="line">释放内存</span><br><span class="line">调用拷贝构造函数并为指针 ptr 分配内存</span><br><span class="line">line 大小 : 10</span><br><span class="line">释放内存</span><br><span class="line">释放内存</span><br><span class="line">释放内存</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul>
<li><p>必须与类同名 再在前部加一个～，删除对象的时候会自动调用</p>
</li>
<li><p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好在销毁类之前显式构造析构函数，释放掉申请的内存空间，避免内存泄漏。</p>
</li>
<li><p><strong>类析构顺序：</strong></p>
<p>1）派生类本身的析构函数；</p>
<p>2）对象成员析构函数；</p>
<p>3）基类析构函数。</p>
</li>
</ul>
<h3 id="友元函数（友元类）"><a href="#友元函数（友元类）" class="headerlink" title="友元函数（友元类）"></a>友元函数（友元类）</h3><ul>
<li>定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。</li>
<li>尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</li>
<li>友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend，没有this指针，访问非static指针要引入对象做参数</li>
</ul>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><ul>
<li><p>不允许使用switch 与loop 语句</p>
</li>
<li><p>定义必须出现在首次调用之前</p>
</li>
<li><p>较为短小的代码</p>
</li>
</ul>
<h2 id="继承、多态"><a href="#继承、多态" class="headerlink" title="继承、多态"></a>继承、多态</h2><h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><h5 id="按权限："><a href="#按权限：" class="headerlink" title="按权限："></a>按权限：</h5><ul>
<li><h5 id="public-保持不变"><a href="#public-保持不变" class="headerlink" title="public  保持不变"></a>public  保持不变</h5></li>
<li><h5 id="protected-原public变成protected"><a href="#protected-原public变成protected" class="headerlink" title="protected  原public变成protected"></a>protected  原public变成protected</h5></li>
<li><h5 id="private-全变成private"><a href="#private-全变成private" class="headerlink" title="private  全变成private"></a>private  全变成private</h5></li>
</ul>
<h5 id="按父类个数："><a href="#按父类个数：" class="headerlink" title="按父类个数："></a>按父类个数：</h5><ul>
<li><h5 id="单继承：只有一个父类"><a href="#单继承：只有一个父类" class="headerlink" title="单继承：只有一个父类"></a>单继承：只有一个父类</h5></li>
<li><h5 id="多继承：有多个父类"><a href="#多继承：有多个父类" class="headerlink" title="多继承：有多个父类"></a>多继承：有多个父类</h5></li>
<li><h5 id="链式继承：一条链，首尾相连"><a href="#链式继承：一条链，首尾相连" class="headerlink" title="链式继承：一条链，首尾相连"></a>链式继承：一条链，首尾相连</h5></li>
<li><h5 id="虚继承：也就是菱形继承"><a href="#虚继承：也就是菱形继承" class="headerlink" title="虚继承：也就是菱形继承"></a><a href="####%E8%99%9A%E7%BB%A7%E6%89%BF">虚继承</a>：也就是菱形继承</h5></li>
</ul>
<h4 id="重载-静态多态"><a href="#重载-静态多态" class="headerlink" title="重载(静态多态)"></a>重载(<strong>静态多态</strong>)</h4><p>静态函数在编译的时候就已经确定运行时机</p>
<h4 id="虚函数-动态多态"><a href="#虚函数-动态多态" class="headerlink" title="虚函数(动态多态)"></a>虚函数(动态多态)</h4><ul>
<li><p>函数只在 code 区存放一份，数据成员则每个对象一份，并按照声明顺序依次存放</p>
</li>
<li><p>在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p>
</li>
<li><p>类A中有了虚函数就会再类的数据成员的最前面添加一个 vfptr 指针(void** vfptr)，这个指针用来指向一个 vtable 表（一个函数指针数组）（一个类只有一个该表），该表存储着当前类的所有 虚函数 的地址。这样 vfptr 就成为了一个类似成员变量的存在。访问虚函数的时候通过 vfptr 间址找到vtable 表，再间址进而找到要调用的函数。这样就在一定程度上摆脱了类型制约。</p>
<p><img src="https://i.imgloc.com/2023/05/25/VDJKFq.png" alt="people派生出student再派生出vtable"></p>
<p>在虚函数表中，基类的虚函数在 vtable 中的索引（下标）是固定的，不会随着继承层次的增加而改变，派生类新增的虚函数放在 vtable 的最后。如果派生类有同名的虚函数遮蔽（覆盖）了基类的虚函数，那么将使用派生类的虚函数替换基类的虚函数，这样具有遮蔽关系的虚函数在 vtable 中只会出现一次。</p>
<p>只要vptr的值不同，那么访问函数成员的时候使用的vtable表就不同，就可能访问到不同类的函数成员。B类对象中的vptr指向B类自己的vtable。</p>
<p>当B类继承A类的时候，因为A中有虚函数，编译器就自动的给B类添加vfprt指针和vtable表。也可以理解为B类继承来了A类中的那个vptr指针成员。</p>
<p>当A类指针指向B类对象时，发生假切割。要知道这个过程只是切掉A类中没有的那些成员。（即当People类指针指向Student类对象时，切割掉m_score这个People类中没有的成员）<br>由于vptr是从A类中继承来的，所以这个量仍将保留。而对于vptr的值则不会改变，仍然指向B类的vtable表。所以访问F1函数的时候是通过B类的vtable表去寻址的，自然就是使用子类的函数（拿图中的情况举例，子类的Student::display()函数已经覆盖了People::display()函数，此时A类指针访问虚函数display()时也是访问到子类的Student::display()函数）。</p>
<p>当B类的指针指向A类的对象时（当B类存在新增数据成员时可能出错），同理。</p>
<p>而对于普通函数则受类型的制约，（因为没有vptr指针）使用哪个类的指针调用函数，那么所调用的就是那个累的函数。<br>总而言之，普通函数通过对象或指针的类型来找所调用的函数，而虚函数是通过一个指针来找到所要调用的函数的。</p>
<p>***==派生类指针指向基类对象==<em><strong>，这里疑问会比较大。首先是为什么这里不会报错，为什么派生类指针指向基类对象可以成立？理论上指针的可访问范围一定大于对象的大小，会指向一些未知区域导致运行出错，但是要注意的是，</strong>这个题目里面B类不存在新增数据成员，所以不会出错</em>*。还有就是由于是基类对象，还没有发生虚函数掩盖</p>
</li>
<li><p>函数要修改数据必须要传入该数据的地址</p>
<p>实现C++的多态，基类与派生类有同名的函数，派生类在调用这个函数的时候不知道调用哪个，因此就要用虚函数，在基类的这个函数加上virtual前缀。</p>
<p>虚函数必须实现也就是定义，不然会报错，</p>
<p><strong>纯虚函数:virtual xxx xxx()=0</strong></p>
<p>声明纯虚函数就代表这个类成了<strong>抽象类，不能进行实例化</strong></p>
<p>这就是在提醒继承这个类的时候要再次定义这个函数，不然还是抽象类没法实例化</p>
<p>定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。</p>
<p>定义一个函数为纯虚函数，才代表函数没有被实现。</p>
<p>定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为”虚”函数。</p>
<p>虚函数只能借助于指针或者引用来达到多态的效果。</p>
<p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加 =0:</p>
<p>那么此时就能<a href="####%E9%80%9A%E8%BF%87%E7%88%B6%E7%B1%BB%E6%8C%87%E9%92%88%E8%B0%83%E7%94%A8%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%88%E5%90%8C%E5%90%8D%E5%90%8C%E5%8F%82%EF%BC%89">通过父类的一个指针来调用子类的方法</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> A <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">class</span> B <span class="type">void</span> <span class="title">sow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">A *pa</span>=<span class="literal">NULL</span>;</span><br><span class="line">B b;</span><br><span class="line">pa=＆b;</span><br><span class="line">pa-&gt;<span class="built_in">sow</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><ul>
<li><p>​    A</p>
<p> /      <br>B      C             D继承了两个A，析构时会造成内存泄露<br> \     /              所以BC在继承A的时候必须要 <code>virtual public A</code> 虚继承</p>
<pre><code>D                 
</code></pre>
<p>​        在一个派生类中保留间接基类的多份同名成员，虽然可以在不同的成员变量中分别存放不同的数据，但大多数情况下这是多余的：因为保留多份成员变量不仅占用较多的存储空间，还容易产生命名冲突。假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 A -&gt;B-&gt;D 这条路径，还是来自 A-&gt;C-&gt;D 这条路径。</p>
<p>​        为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。</p>
<p>​        虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为<strong>虚基类（<em>Virtual Base Class</em>）</strong>，本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p>
</li>
</ul>
<h4 id="子类从基类继承的成员限制"><a href="#子类从基类继承的成员限制" class="headerlink" title="子类从基类继承的成员限制"></a>子类从基类继承的成员限制</h4><ul>
<li>基类的构造函数、析构函数和拷贝构造函数。</li>
<li>基类的重载运算符。</li>
<li>基类的友元函数。</li>
<li>==子类对象中父类成员初始化必须调用父类的构造函数，初始化列表方式==</li>
<li>子类对象中其他类的成员初始化必须使用初始化列表方式</li>
</ul>
<h4 id="构造函数-析构函数调用顺序"><a href="#构造函数-析构函数调用顺序" class="headerlink" title="==构造函数 析构函数调用顺序=="></a>==构造函数 析构函数调用顺序==</h4><ul>
<li><p>仅考虑实例化派生类对象时的情况</p>
</li>
<li><p>构造函数调用顺序：基类 &gt; 派生类里的对象成员 &gt; 派生类； </p>
</li>
<li><p>多继承派生类： 基类的构造顺序依照基类继承顺序调用</p>
</li>
<li><p>对象成员<a href="%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%EF%BC%8C%E6%AD%A4%E6%97%B6%E6%8A%8A%E8%AF%A5%E5%AF%B9%E8%B1%A1%E7%A7%B0%E4%B8%BA%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E3%80%82%E4%B9%9F%E5%8F%AB%E7%B1%BB%E7%9A%84%E7%BB%84%E5%90%88">^2</a>：依照在派生类中对象成员的定义顺序 调用成员的构造函数 与初始化列表顺序无关</p>
</li>
<li><p>```c++<br>#include <iostream><br>using namespace std;<br>class Shape // 基类 Shape<br>{<br>public:</p>
<pre><code>Shape() &#123;cout &lt;&lt; &quot;Shape&quot; &lt;&lt; endl;&#125;
~Shape() &#123;cout &lt;&lt; &quot;~Shape&quot; &lt;&lt; endl;&#125;
</code></pre>
<p>};</p>
<p>class PaintCost // 基类 PaintCost<br>{<br>public:</p>
<pre><code>PaintCost() &#123;cout &lt;&lt; &quot;PaintCost&quot; &lt;&lt; endl;&#125;
~PaintCost() &#123;cout &lt;&lt; &quot;~PaintCost&quot; &lt;&lt; endl;&#125;
</code></pre>
<p>};</p>
<p>// 派生类<br>class Rectangle : public Shape, public PaintCost  //基类构造顺序 依照 继承顺序<br>{<br>public:</p>
<pre><code>Rectangle() :b(), a(), Shape(), PaintCost()
&#123;cout &lt;&lt; &quot;Rectangle&quot; &lt;&lt; endl;&#125;
~Rectangle() 
&#123;cout &lt;&lt; &quot;~Rectangle&quot; &lt;&lt; endl;&#125;
PaintCost b;        // 对象成员依照定义顺序
Shape a; 
</code></pre>
<p>};</p>
<p>int main(void)<br>{</p>
<pre><code>Rectangle Rect;
return 0;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">Shape</span><br><span class="line">PaintCost</span><br><span class="line">PaintCost</span><br><span class="line">Shape</span><br><span class="line">Rectangle</span><br><span class="line">~Rectangle</span><br><span class="line">~Shape</span><br><span class="line">~PaintCost</span><br><span class="line">~PaintCost</span><br><span class="line">~Shape</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="通过父类指针调用子类对象的成员函数（同名同参）"><a href="#通过父类指针调用子类对象的成员函数（同名同参）" class="headerlink" title="通过父类指针调用子类对象的成员函数（同名同参）"></a>通过父类指针调用子类对象的成员函数（同名同参）</h4><ul>
<li><p>基类指针指向基类对象，简单。只需要通过基类指针简单地调用基类的功能。</p>
</li>
<li><p>派生类指针指向派生类对象，简单。只需要通过派生类指针简单地调用派生类功能。</p>
</li>
<li><p>将基类指针指向派生类对象是安全的，因为派生类对象“是”它的基类的对象。</p>
<p>但是要注意的是，这个指针只能用来调用基类的成员函数。</p>
<p>如果试图通过基类指针调用派生类才有的成员函数，则编译器会报错。</p>
<p>为了避免这种错误，必须将基类指针强制转化为派生类指针。然后派生类指针可以用来调用派生类的功能。这称为向下强制类型转换，这是一种潜在的危险操作。</p>
</li>
</ul>
<p>注意：如果在基类和派生类中定义了虚函数（通过继承和重写），并通过基类指针在派生类对象上调用这个虚函数，则实际调用的是这个函数的派生类版本。</p>
<h5 id="出现同时有虚实函数的情况"><a href="#出现同时有虚实函数的情况" class="headerlink" title="出现同时有虚实函数的情况"></a>出现同时有虚实函数的情况</h5><ol>
<li><p>若全为虚函数，则调用子类的函数</p>
</li>
<li><p>若全为实函数，则调用父类的函数</p>
</li>
<li><p>若一实一虚，则调用他们中的实函数</p>
<p><strong>父类没有定义为虚的时候，子类是没办法多态的，而父类定义为虚函数的时候，子类默认也是个虚函数，会根据指针指向的数据类型来选择函数调用</strong></p>
<p><strong>派生类加不加virtual都是虚函数，只要派生类实现了虚函数就会覆盖基类的虚函数，基类指针pBase指向派生类对象basePlus时会调用派生类的虚函数</strong></p>
</li>
</ol>
<h5 id="虚析构函数（delete）"><a href="#虚析构函数（delete）" class="headerlink" title="虚析构函数（delete）"></a><strong>虚析构函数</strong>（delete）</h5><ol>
<li><p>可能通过基类指针删除派生类对象、</p>
</li>
<li><p>如果你打算允许他人通过基类指针调用对象的析构函数（通过delete这样做是正常的），就需要让基类的析构函数变为虚函数，否则执行delete的结果是不确定的</p>
</li>
<li><p>虚构造函数不合法(有了虚函数就要有虚函数表，调用构造函数就要去找vptr，此时vptr还没初始化)</p>
</li>
<li><p>虚析构函数的实现原理：</p>
<p>在父类中通过virtual 修饰析构函数后，通过 父类指针再去指向子类对象，然后通过delete 接父类指针，就可以 释放掉子类对象了</p>
<p>有了这个前提，如果使用父类的指针通过 <a href="##%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%88new&delete%EF%BC%89">delete</a> 的方式去释放子类的 对象，那么只要能够实现通过父类的指针执行到子类的析构函数即可</p>
<p>如果子类中不写虚析构函数，计算机会默认给你定义一个虚析构函数， 前提是你在父类中得有virtual 来修饰父类的析构函数</p>
<p>在使用时： 如果在main() 函数中通过父类指针指向子类对象，然后通过 delete 接父类指针释放子类对象 此时，虚函数表的工作： 如果在父类中定义了虚析构函数，那么在父类的虚函数表中就会 有一个父类析构函数的函数指针，指向父类的析构函数 而在子类的虚函数表中也会产生一个子类析构函数的函数指针， 指向子类的析构函数（注意：虚析构函数会覆盖） 当 父类的指针指向 子类的对象，通过 delete 接 父类的 指针时，就可以通过子类对象的 虚函数表指针 找到子类的 虚函数表，再通过子类 的虚函数表找到子类的析构函数，从而使得子类的析构函数得以执行，子类的析构函数执行完毕后， 系统会自动执行父类的析构函数（这句是重点）！</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;<span class="comment">//虚析构函数应用举例</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> _a) :<span class="built_in">a</span>(_a) &#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">virtual</span>  ~<span class="built_in">A</span>() &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;A deleted.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A::getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>(<span class="type">int</span> _a, <span class="type">int</span> _b) :<span class="built_in">A</span>(_a), <span class="built_in">b</span>(_b) &#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">	~<span class="built_in">B</span>() &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;B deleted.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">B::getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A* pa;<span class="comment">//基类A指针</span></span><br><span class="line">	pa = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//基类A指针指向派生类B</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pa-&gt;<span class="built_in">getValue</span>());</span><br><span class="line">	<span class="keyword">delete</span> pa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">B deleted.A deleted.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">////delete 删除的是指针指向的空间，不代表指针置NULL</span></span><br></pre></td></tr></table></figure>

<h2 id="静态成员、常成员"><a href="#静态成员、常成员" class="headerlink" title="静态成员、常成员"></a>静态成员、常成员</h2><h3 id="静态成员变量："><a href="#静态成员变量：" class="headerlink" title="静态成员变量："></a>静态成员变量：</h3><ul>
<li><p>我们不能把静态成员的初始化放置在类的定义中，它是所有对象共有的</p>
</li>
<li><p>所以应该再类内声明 static int a;</p>
</li>
<li><p>在类外定义 int A::a=0;</p>
</li>
</ul>
<h3 id="静态成员函数："><a href="#静态成员函数：" class="headerlink" title="静态成员函数："></a>静态成员函数：</h3><ul>
<li><p>静态成员函数没有 this 指针，且只能访问静态成员（包括静态成员变量和静态成员函数）</p>
</li>
<li><p>静态成员函数即使在类对象不存在的情况下也能被调用</p>
</li>
</ul>
<h3 id="类中特殊成员变量的初始化问题："><a href="#类中特殊成员变量的初始化问题：" class="headerlink" title="类中特殊成员变量的初始化问题："></a>类中特殊成员变量的初始化问题：</h3><ul>
<li>常量变量：必须通过构造函数参数列表进行初始化。</li>
<li>引用变量：必须通过构造函数参数列表进行初始化。</li>
<li>普通静态变量：要在类外通过”::”初始化。</li>
<li>静态整型常量：可以直接在定义的时候初始化。</li>
<li>静态非整型常量：不能直接在定义的时候初始化。要在类外通过”::”初始化。</li>
</ul>
<h3 id="常成员变量"><a href="#常成员变量" class="headerlink" title="常成员变量"></a>常成员变量</h3><ul>
<li>一经初始化就不能再改变,并且只能通过初始化列表初始</li>
</ul>
<h3 id="常成员函数-常对象"><a href="#常成员函数-常对象" class="headerlink" title="常成员函数/常对象"></a>常成员函数/常对象</h3><ul>
<li>常对象里面的成员变量都不能改变，所以只能用常成员函数</li>
<li>常成员函数只能修改常成员变量，调用同类的常成员函数</li>
<li>不要误认为常对象中的成员函数都是常成员函数，常对象只保证其所有数据成员的值不被修改。</li>
<li>声明时候要把const加在参数表后边，不能加在前边，否则就是返回值是const类型，实现的时候也要把const加上</li>
</ul>
<h3 id="常成员变量的初始化"><a href="#常成员变量的初始化" class="headerlink" title="常成员变量的初始化"></a>常成员变量的初始化</h3><ul>
<li><p>只能通过初始化列表，构造函数里面相当于赋值了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTestBasic</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//常成员：默认初始化</span></span><br><span class="line">	<span class="built_in">CTestBasic</span>() :<span class="built_in">conNum</span>(<span class="number">0</span>) &#123;</span><br><span class="line">		value = <span class="number">-1</span>;</span><br><span class="line">		pValue = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//常成员：重载初始化</span></span><br><span class="line">	<span class="built_in">CTestBasic</span>(<span class="type">int</span> num ) :<span class="built_in">conNum</span>(num) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//常成员函数：又成为只读函数，不能改变成员变量的值</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getsNum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getcNum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">get_scNum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getPointerValue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	~<span class="built_in">CTestBasic</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//const成员变量不能在类定义处初始化，[ 只能通过构造函数初始化列表进行 ]，并且必须有构造函数</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> conNum;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象.</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> sNum;</span><br><span class="line">	</span><br><span class="line">	<span class="type">const</span> <span class="type">static</span>  <span class="type">int</span> scNum = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">	<span class="type">int</span>* pValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员类外初始化</span></span><br><span class="line"><span class="type">int</span> CTestBasic::sNum = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义也必须包含const 关键字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTestBasic::getsNum</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> sNum;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTestBasic::getcNum</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> conNum;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTestBasic::get_scNum</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> scNum;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTestBasic::getPointerValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*pValue = <span class="number">200</span>;</span><br><span class="line">	<span class="comment">//pValue++; Error: pValue的值不能改变</span></span><br><span class="line">	<span class="keyword">return</span> *pValue;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CTestBasic::~<span class="built_in">CTestBasic</span>()&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="一些常用的类"><a href="#一些常用的类" class="headerlink" title="一些常用的类"></a>一些常用的类</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><p>​            append() – 在字符串的末尾添加字符</p>
<p>​            find() – 在字符串中查找字符串</p>
<p>​            insert() – 插入字符</p>
<p>​            length() – 返回字符串的长度</p>
<p>​            replace() – 替换字符串</p>
<p>​            substr() – 返回某个子字符串</p>
<p>​            eg. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个string类对象</span></span><br><span class="line">    string http = <span class="string">&quot;www.runoob.com&quot;</span>;</span><br><span class="line">   <span class="comment">//打印字符串长度</span></span><br><span class="line">   cout&lt;&lt;http.<span class="built_in">length</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//拼接</span></span><br><span class="line">    http.<span class="built_in">append</span>(<span class="string">&quot;/C++&quot;</span>);</span><br><span class="line">    cout&lt;&lt;http&lt;&lt;endl; <span class="comment">//打印结果为：www.runoob.com/C++</span></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="type">int</span> pos = http.<span class="built_in">find</span>(<span class="string">&quot;/C++&quot;</span>); <span class="comment">//查找&quot;C++&quot;在字符串中的位置</span></span><br><span class="line">    cout&lt;&lt;pos&lt;&lt;endl;</span><br><span class="line">    http.<span class="built_in">replace</span>(pos, <span class="number">4</span>, <span class="string">&quot;&quot;</span>);   <span class="comment">//从位置pos开始，之后的4个字符替换为空，即删除</span></span><br><span class="line">    cout&lt;&lt;http&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//找子串runoob</span></span><br><span class="line">    <span class="type">int</span> first = http.<span class="built_in">find_first_of</span>(<span class="string">&quot;.&quot;</span>); <span class="comment">//从头开始寻找字符&#x27;.&#x27;的位置</span></span><br><span class="line">    <span class="type">int</span> last = http.<span class="built_in">find_last_of</span>(<span class="string">&quot;.&quot;</span>);   <span class="comment">//从尾开始寻找字符&#x27;.&#x27;的位置</span></span><br><span class="line">    cout&lt;&lt;http.<span class="built_in">substr</span>(first<span class="number">+1</span>, last-first<span class="number">-1</span>)&lt;&lt;endl; <span class="comment">//提取&quot;runoob&quot;子串并打印</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>几种输入方法的不同</p>
</li>
<li><p><code>cin</code>:遇到tab 空格 enter都结束</p>
</li>
<li><p><code>cin.getline (str,x)</code> x个字符包括反斜杠0 可以有空格</p>
</li>
</ul>
<p>需要&lt;string&gt;头文件：</p>
<ul>
<li><code>getline(cin,str )</code>可以有空格</li>
<li><code>gets(s)</code>可以有空格</li>
</ul>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a><strong>vector</strong></h3><ul>
<li>动态数组——顺序容器——stack（栈）的上位替代</li>
</ul>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul>
<li><code>vector&lt;int\&gt; obj</code>          创造了一个vector int 类的obj数组</li>
<li><code>vector&lt;int\&gt; obj(10)</code>    创建一个obj数组，最多容纳10个数据</li>
<li><code>vector&lt;int\&gt; obj(10,3)</code>  创建一个obj数组，初始化10个数据为3</li>
<li><code>vector&lt; vector&lt;int\&gt; \&gt;</code> 二维数组</li>
</ul>
<h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><ul>
<li><code>begin()</code>,<code>end()</code> 获取首地址与尾地址</li>
<li><code>push_back(m)</code> 在最后插入数据m</li>
<li><code>pop_back()</code> 移除最后的数据</li>
<li><code>back()</code> 返回最后一个数据</li>
<li><code>clear()</code> 清除数据但不回收空间</li>
<li><code>size()</code>,<code>capacity()</code> size是当前容量 capacity是真实最大容量 一般来说相等 但是clear后不等</li>
<li><code>empty()</code> 判断是否为空 空返回1</li>
<li><code>insert(\__position\_\_,x)</code>    在指定位置插入x</li>
<li><code>insert(\__position\_\_,N,x)</code> 从指定位置开始插入N个x</li>
<li><code>erase(\__position\_\_)</code>       删除指定位置的元素</li>
<li><code>erase(\_\_positionBegin\_\_,\__positionEnd\_\_)</code>  删除指定区间内的元素</li>
</ul>
<h4 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器 (iterator)"></a>迭代器 (iterator)</h4><ul>
<li><p>遍历方法除了用数组之外还可以用迭代器（iterator）类似于指针</p>
<p>声明：vector&lt;int&gt;::iterator it;</p>
<p>具体方法：<code>for(it=obj.begin();it!=obj.end();it++)    </code></p>
<p>​               <code>cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</code> </p>
</li>
<li><p>迭代器实际上是对“遍历容器”这一操作进行了封装。</p>
<p>在编程中我们往往会用到各种各样的容器，但由于这些容器的底层实现各不相同，所以对他们进行遍历的方法也是不同的。例如，数组使用指针算数就可以遍历，但链表就要在不同节点直接进行跳转。</p>
<p>这是非常不利于代码重用的。例如你有一个简单的查找容器中最小值的函数findMin，如果没有迭代器，那么你就必须定义适用于数组版本的findMin和适用于链表版本的findMin，如果以后有更多容器需要使用findMin，那就只好继续添加重载……而如果每个容器又需要更多的函数例如findMax，sort，那简直就是重载地狱……</p>
<p>我们的救星就是迭代器啦！如果我们将这些遍历容器的操作都封装成迭代器，那么诸如findMin一类的算法就都可以针对迭代器编程而不是针对具体容器编程，工作量一下子就少了很多！</p>
<p>至于指针，由于指针也可以用来遍历容器(数组)，所以指针也可是算是迭代器的一种。但是指针还有其他功能，并不只局限于遍历数组。因为使用指针变量数组的操作太深入人心，c++stl中的迭代器就是刻意仿照指针来设计接口的</p>
</li>
</ul>
<h3 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43899069/article/details/104450000">algorithm头文件函数全集——史上最全，最贴心_算法头文件_来老铁干了这碗代码的博客-CSDN博客</a></p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="type">const</span>&amp; <span class="title">Max</span> <span class="params">(T <span class="type">const</span>&amp; a, T <span class="type">const</span>&amp; b)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b:a; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">39</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max(i, j): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(i, j) &lt;&lt; endl; </span><br><span class="line">    <span class="type">double</span> f1 = <span class="number">13.5</span>; </span><br><span class="line">    <span class="type">double</span> f2 = <span class="number">20.7</span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max(f1, f2): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(f1, f2) &lt;&lt; endl; </span><br><span class="line">    string s1 = <span class="string">&quot;Hello&quot;</span>; </span><br><span class="line">    string s2 = <span class="string">&quot;World&quot;</span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max(s1, s2): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(s1, s2) &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">Max(i, j): 39</span><br><span class="line">Max(f1, f2): 20.7</span><br><span class="line">Max(s1, s2): World</span><br></pre></td></tr></table></figure>



<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Op</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T <span class="title">peocess</span><span class="params">(T v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v * v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Op&lt;<span class="type">int</span>&gt; opInt;</span><br><span class="line">    Op&lt;<span class="type">double</span>&gt; opDouble;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5 * 5 = &quot;</span> &lt;&lt; opInt.<span class="built_in">peocess</span>(<span class="number">5</span>) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;0.5 * 0.5 = &quot;</span> &lt;&lt; opDouble.<span class="built_in">peocess</span>(<span class="number">0.5</span>) &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<p><strong>函数模板可以重载，只要它们的形参表不同即可。</strong></p>
<h3 id="C-中-typename-和-class-的区别"><a href="#C-中-typename-和-class-的区别" class="headerlink" title="C++ 中 typename 和 class 的区别"></a>C++ 中 typename 和 class 的区别</h3><p>在 C++ Template 中很多地方都用到了 typename 与 class 这两个关键字，而且好像可以替换，是不是这两个关键字完全一样呢?</p>
<p>相信学习 C++ 的人对 class 这个关键字都非常明白，class 用于定义类，在模板引入 c++ 后，最初定义模板的方法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;......</span><br></pre></td></tr></table></figure>

<p>这里 class 关键字表明T是一个类型，后来为了避免 class 在这两个地方的使用可能给人带来混淆，所以引入了 typename 这个关键字，它的作用同 class 一样表明后面的符号为一个类型，这样在定义模板的时候就可以使用下面的方式了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename</span><br><span class="line">T&gt;......</span><br></pre></td></tr></table></figure>

<p>在模板定义语法中关键字 class 与 typename 的作用完全一样。</p>
<p>typename 难道仅仅在模板定义中起作用吗？其实不是这样，typename 另外一个作用为：使用嵌套依赖类型(nested depended name)，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span>：</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> LengthType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyMethod</span><span class="params">( T myarr )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> T::LengthType LengthType; </span><br><span class="line">    LengthType length = myarr.GetLength; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候 typename 的作用就是告诉 c++ 编译器，typename 后面的字符串为一个类型名称，而不是成员函数或者成员变量，这个时候<u>如果前面没有 typename，编译器没有任何办法知道 T::LengthType 是一个类型还是一个成员名称(静态数据成员或者静态函数)</u>，所以编译不能够通过。</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="类指针"><a href="#类指针" class="headerlink" title="类指针"></a>类指针</h3><ul>
<li><code>Student *b = new Student；</code>在定义b这个指针变量的时候并没有分配<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>，只有执行new后才会分配内存，且为内存堆。是个永久变量,除非你释放它</li>
<li>是一个内存地址值，指向内存中存放的类对象（包括一些成员变量赋值；类指针可以指向多个不同的对象，这就是多态）</li>
<li>指针变量是间接访问，但可实现多态（通过父类指针可调用子类对象），并且没有调用构造函数；</li>
</ul>
<h3 id="常指针"><a href="#常指针" class="headerlink" title="常指针"></a>常指针</h3><h4 id="指向-常对象的指针-，指向-对象的常指针"><a href="#指向-常对象的指针-，指向-对象的常指针" class="headerlink" title="指向==常对象的指针==，指向==对象的常指针=="></a>指向==常对象的指针==，指向==对象的常指针==</h4><ul>
<li>```c++<br>class A{<pre><code>A *p0;              //指向对象的指针
const A *p1; //指向常对象的指针，指向常对象的指针只能是这种指针,不能通过此类指针修改A的数据
A *const p2; //指向对象的常指针，p是指针常量，不能改变p的值
    /*主要看const修饰谁，const修饰指针的指向那就是指向常量的指针
</code></pre>
const修饰指针本身*/<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 向上造型（Upcast)</span><br><span class="line"></span><br><span class="line">在C++中，把子类的对象当做父类对象看待，就称为”向上造型“  (upcast)。</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">class manager: pubilc employee</span><br><span class="line">&#123;</span><br><span class="line">manager();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">manager pett;</span><br><span class="line"></span><br><span class="line">employee *ep = &amp;pett;   //就是upcast</span><br><span class="line"></span><br><span class="line">employee &amp;ep = pett;   //也是upcast</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">把父类的对象当做子类来看待，称为 downcast.</span><br><span class="line"></span><br><span class="line">employee mob;</span><br><span class="line"></span><br><span class="line">manager *lowe = &amp;mob;   //downcast, 将父类对象转换成子类对象</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意：向上造型是安全的，向下造型是有风险的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2023/11/11/Mermaid%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/11/Mermaid%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/" class="post-title-link" itemprop="url">mermaid从入门到入土</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-11 00:00:00" itemprop="dateCreated datePublished" datetime="2023-11-11T00:00:00+08:00">2023-11-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-03 22:45:11" itemprop="dateModified" datetime="2025-05-03T22:45:11+08:00">2025-05-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>什么是Mermaid？<ul>
<li>Mermaid是一种基于Javascript的绘图工具，使用类似于Markdown的语法，使用户可以方便快捷地通过代码创建图表。</li>
<li>项目地址：<a target="_blank" rel="noopener" href="https://github.com/mermaid-js/mermaid%EF%BC%88%E9%9C%80%E8%A6%81%E5%B0%86%E6%A2%AF%E5%AD%90%E8%AE%BE%E7%BD%AE%E6%88%90%E5%85%A8%E5%B1%80%E6%A8%A1%E5%BC%8F%E6%89%8D%E8%83%BD%E8%AE%BF%E9%97%AE%EF%BC%89">https://github.com/mermaid-js/mermaid（需要将梯子设置成全局模式才能访问）</a></li>
</ul>
</li>
</ul>
<ul>
<li><p>怎么使用Mermaid？</p>
<ul>
<li>使用特定的Mermaid渲染器；</li>
<li><strong>使用集成了Mermaid渲染功能的Markdown编辑器，如<a target="_blank" rel="noopener" href="https://www.typora.io/">Typora</a>。</strong>使用时，需要将代码块的语言选择为Mermaid。</li>
</ul>
<blockquote>
<p>Typora是宇宙第一笔记软件，不接受反驳</p>
</blockquote>
</li>
<li><p>Mermaid能绘制哪些图？</p>
<ul>
<li>饼状图：使用<code>pie</code>关键字，具体用法后文将详细介绍</li>
<li>流程图：使用<code>graph</code>关键字，具体用法后文将详细介绍</li>
<li>序列图：使用<code>sequenceDiagram</code>关键字</li>
<li>甘特图：使用<code>gantt</code>关键字</li>
<li>类图：使用<code>classDiagram</code>关键字</li>
<li>状态图：使用<code>stateDiagram</code>关键字</li>
<li>用户旅程图：使用<code>journey</code>关键字</li>
</ul>
</li>
<li><p>实例：朱元璋家谱简图，圆圈代表皇帝</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">emperor((朱八八))-.子.-&gt;father(朱五四)-.子.-&gt;朱四九-.子.-&gt;朱百六</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">朱雄英--长子--&gt;朱标--长子--&gt;emperor</span><br><span class="line">emperor2((朱允炆))--次子--&gt;朱标</span><br><span class="line">朱樉--次子--&gt;emperor</span><br><span class="line">朱棡--三子--&gt;emperor</span><br><span class="line">emperor3((朱棣))--四子--&gt;emperor</span><br><span class="line">emperor4((朱高炽))--长子--&gt;emperor3</span><br></pre></td></tr></table></figure>

<p>以上是概述，下面详细介绍饼状图和流程图的语法。其他图的语法可访问上文给出的项目地址，自行学习。（记得挂梯子）</p>
<h1 id="饼状图"><a href="#饼状图" class="headerlink" title="饼状图"></a>饼状图</h1><ul>
<li><p>在线渲染器：<a target="_blank" rel="noopener" href="https://mermaidjs.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoicGllXG5cIkRvZ3NcIiA6IDQyLjk2XG5cIkNhdHNcIiA6IDUwLjA1XG5cIlJhdHNcIiA6IDEwLjAxIiwibWVybWFpZCI6eyJ0aGVtZSI6ImRlZmF1bHQifX0">Online FlowChart &amp; Diagrams Editor</a>（需要梯子）</p>
</li>
<li><p>语法</p>
<ul>
<li>从<code>pie</code>关键字开始图表</li>
<li>然后使用<code>title</code>关键字及其在字符串中的值，为饼图赋予标题。（这是<strong>可选的</strong>）</li>
<li>数据部分<ul>
<li>在<code>&quot; &quot;</code>内写上分区名。</li>
<li>分区名后使用<code>:</code>作为分隔符</li>
<li>分隔符后写上数值，最多支持2位小数——数据会以百分比的形式展示</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>实例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pie</span><br><span class="line">    title 为什么总是宅在家里？</span><br><span class="line">    &quot;喜欢宅&quot; : 15</span><br><span class="line">    &quot;天气太热或太冷&quot; : 20</span><br><span class="line">    &quot;穷&quot; : 500</span><br></pre></td></tr></table></figure>

<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><ul>
<li>在线渲染器：<a target="_blank" rel="noopener" href="https://mermaidjs.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoiZ3JhcGggVERcbiAgICBBW0hhcmRdIC0tPnxUZXh0fCBCKFJvdW5kKVxuICAgIEIgLS0-IEN7RGVjaXNpb259XG4gICAgQyAtLT58T25lfCBEW1Jlc3VsdCAxXVxuICAgIEMgLS0-fFR3b3wgRVtSZXN1bHQgMl0iLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9fQ">Online FlowChart &amp; Diagrams Editor</a>（需要挂梯子）</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[Start] --&gt; B&#123;Is it?&#125;;</span><br><span class="line">    B -- Yes --&gt; C[OK];</span><br><span class="line">    C --&gt; D[Rethink];</span><br><span class="line">    D --&gt; B;</span><br><span class="line">    B -- No ----&gt; E[End];</span><br></pre></td></tr></table></figure>

<h2 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h2><p>用于开头，声明流程图的方向。</p>
<ul>
<li><code>graph</code>或<code>graph TB</code>或<code>graph TD</code>：从上往下</li>
<li><code>graph BT</code>：从下往上</li>
<li><code>graph LR</code>：从左往右</li>
<li><code>graph RL</code>：从右往左</li>
</ul>
<h2 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h2><ul>
<li>无名字的结点：直接写内容，此时结点边框为方形；节点内容不能有空格</li>
<li>有名字的结点：节点名后书写内容，内容左右有特定符号，结点边框由符号决定；节点内容可以有空格</li>
</ul>
<blockquote>
<p>下面的实例中，没有为graph指定方向，因此默认是从上往下的。但是由于各个结点之前没有箭头，所以他们都处于同一排。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph</span><br><span class="line">    默认方形</span><br><span class="line">    id1[方形]</span><br><span class="line">    id2(圆边矩形)</span><br><span class="line">    id3([体育场形])</span><br><span class="line">    id4[[子程序形]]</span><br><span class="line">    id5[(圆柱形)]</span><br><span class="line">    id6((圆形))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph</span><br><span class="line">	id1&#123;菱形&#125;</span><br><span class="line">	id2&#123;&#123;六角形&#125;&#125;</span><br><span class="line">	id3[/平行四边形/]</span><br><span class="line">	id4[\反向平行四边形\]</span><br><span class="line">	id5[/梯形\]</span><br><span class="line">	id6[\反向梯形/]</span><br></pre></td></tr></table></figure>

<h2 id="连线样式"><a href="#连线样式" class="headerlink" title="连线样式"></a>连线样式</h2><ul>
<li>实线箭头：分为无文本箭头和有文本箭头，有文本箭头有2种书写格式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a--&gt;b--文本1--&gt;c--&gt;|文本2|d</span><br></pre></td></tr></table></figure>

<ul>
<li>粗实线箭头：分为无文本箭头和有文本箭头</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a==&gt;b==文本==&gt;c</span><br></pre></td></tr></table></figure>

<ul>
<li>虚线箭头：分为无文本箭头和有文本箭头</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a-.-&gt;b-.文本.-&gt;c</span><br></pre></td></tr></table></figure>

<ul>
<li>无箭头线：即以上三种连线去掉箭头后的形式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a---b</span><br><span class="line">b--文本1---c</span><br><span class="line">c---|文本2|d</span><br><span class="line">d===e</span><br><span class="line">e==文本3===f</span><br><span class="line">f-.-g</span><br><span class="line">g-.文本.-h</span><br></pre></td></tr></table></figure>

<ul>
<li>其他连线：需要将<code>graph</code>关键字改为<code>flowchart</code>，除了新增加的连线形式外，上面三种线的渲染效果也会不同</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    A o--o B</span><br><span class="line">    B &lt;--&gt; C</span><br><span class="line">    C x--x D</span><br><span class="line">    </span><br><span class="line">    旧连线 --文本--&gt; 也会不同</span><br></pre></td></tr></table></figure>

<ul>
<li>延长连线：增加相应字符即可，如下图中的B到E，连线中增加了一个<code>-</code>。字符可多次添加。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[Start] --&gt; B&#123;Is it?&#125;;</span><br><span class="line">    B --&gt;|Yes| C[OK];</span><br><span class="line">    C --&gt; D[Rethink];</span><br><span class="line">    D --&gt; B;</span><br><span class="line">    B ---&gt;|No| E[End];</span><br></pre></td></tr></table></figure>



<h2 id="连线形式"><a href="#连线形式" class="headerlink" title="连线形式"></a>连线形式</h2><ul>
<li>直链</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">   D[Rethink1&lt;br/&gt;Rethink2] -- text --&gt; B -- text2 --&gt; C</span><br></pre></td></tr></table></figure>

<ul>
<li>多重链：可以使用<code>&amp;</code>字符，或单个描述</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">   a --&gt; b &amp; c--&gt; d</span><br><span class="line">   </span><br><span class="line">   A &amp; B--&gt; C &amp; D</span><br><span class="line">   </span><br><span class="line">    X --&gt; M</span><br><span class="line">    X --&gt; N</span><br><span class="line">    Y --&gt; M</span><br><span class="line">    Y --&gt; N</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>子图：需要将<code>graph</code>关键字改为<code>flowchart</code>，在代码段的开始加入<code>subgraph</code>，尾部加入<code>end</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">    c1--&gt;a2</span><br><span class="line">    subgraph one</span><br><span class="line">    a1--&gt;a2</span><br><span class="line">    end</span><br><span class="line">    subgraph two</span><br><span class="line">    b1--&gt;b2</span><br><span class="line">    end</span><br><span class="line">    subgraph three</span><br><span class="line">    c1--&gt;c2</span><br><span class="line">    end</span><br><span class="line">    one --&gt; two</span><br><span class="line">    three --&gt; two</span><br><span class="line">    two --&gt; c2</span><br></pre></td></tr></table></figure>

<ul>
<li>注释：在行首加入<code>%%</code>即可。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">%%这是一条注释，在渲染图中不可见</span><br><span class="line">    A[Hard edge] --&gt;|Link text| B(Round edge)</span><br><span class="line">    B --&gt; C&#123;Decision&#125;</span><br><span class="line">    C --&gt;|One| D[Result one]</span><br><span class="line">    C --&gt;|Two| E[Result two]</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2020/04/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式也可以这么简单(转自JavaDoop)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-30 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-30T00:00:00+08:00">2020-04-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 23:22:01" itemprop="dateModified" datetime="2025-04-27T23:22:01+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Designing-Pattern"><a href="#Designing-Pattern" class="headerlink" title="Designing Pattern"></a>Designing Pattern</h1><p>一直想写一篇介绍设计模式的文章，让读者可以很快看完，而且一看就懂，看懂就会用，同时不会将各个模式搞混。自认为本文还是写得不错的😂😂😂，花了不少心思来写这文章和做图，力求让读者真的能看着简单同时有所收获。</p>
<p>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 <em>Gang of Four</em> (<em>GoF</em>) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。</p>
<p>有一些重要的设计原则在开篇和大家分享下，这些原则将贯通全文：</p>
<ol>
<li>面向接口编程，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。</li>
<li>职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。</li>
<li>对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。</li>
</ol>
<p><strong>创建型模式比较简单，但是会比较没有意思，结构型和行为型比较有意思。</strong></p>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>和名字一样简单，非常简单，直接上代码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;noodle&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Food</span> <span class="variable">noodle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LanZhouNoodle</span>();</span><br><span class="line">            noodle.addSpicy(<span class="string">&quot;more&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> noodle;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;chicken&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Food</span> <span class="variable">chicken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HuangMenChicken</span>();</span><br><span class="line">            chicken.addCondiment(<span class="string">&quot;potato&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> chicken;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。</em></p>
<p>简单地说，简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。</p>
<blockquote>
<p>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。</p>
</blockquote>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line">    Food <span class="title function_">makeFood</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChineseFoodFactory</span> <span class="keyword">implements</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanFoodFactory</span> <span class="keyword">implements</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanFoodA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanFoodB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。</p>
<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 先选择一个具体的工厂</span></span><br><span class="line">        <span class="type">FoodFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodFactory</span>();</span><br><span class="line">        <span class="comment">// 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象</span></span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> factory.makeFood(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然都是调用 makeFood(“A”)  制作 A 类食物，但是，不同的工厂生产出来的完全不一样。</p>
<p>第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。</p>
<p><strong>核心在于，我们需要在第一步选好我们需要的工厂</strong>。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。</p>
<p>虽然简单，不过我也把所有的构件都画到一张图上，这样读者看着比较清晰：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/factory-1.png" alt="factory-1"></p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。</p>
<p>一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。</p>
<p>因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下图：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/abstract-factory-1.png" alt="factory-1"></p>
<p>这个时候的客户端调用是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到 Intel 的 CPU</span></span><br><span class="line"><span class="type">CPUFactory</span> <span class="variable">cpuFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntelCPUFactory</span>();</span><br><span class="line"><span class="type">CPU</span> <span class="variable">cpu</span> <span class="operator">=</span> intelCPUFactory.makeCPU();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到 AMD 的主板</span></span><br><span class="line"><span class="type">MainBoardFactory</span> <span class="variable">mainBoardFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AmdMainBoardFactory</span>();</span><br><span class="line"><span class="type">MainBoard</span> <span class="variable">mainBoard</span> <span class="operator">=</span> mainBoardFactory.make();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组装 CPU 和主板</span></span><br><span class="line"><span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(cpu, mainBoard);</span><br></pre></td></tr></table></figure>

<p>单独看 CPU 工厂和主板工厂，它们分别是前面我们说的<strong>工厂模式</strong>。这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。</p>
<p>但是，这种方式有一个问题，那就是如果 <strong>Intel 家产的 CPU 和 AMD 产的主板不能兼容使用</strong>，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。</p>
<p>下面就是我们要说的<strong>产品族</strong>的概念，它代表了组成某个产品的一系列附件的集合：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/abstract-factory-2.png" alt="abstract-factory-2"></p>
<p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/abstract-factory-3.png" alt="abstract-factory-3"></p>
<p>这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一步就要选定一个“大厂”</span></span><br><span class="line">    <span class="type">ComputerFactory</span> <span class="variable">cf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AmdFactory</span>();</span><br><span class="line">    <span class="comment">// 从这个大厂造 CPU</span></span><br><span class="line">    <span class="type">CPU</span> <span class="variable">cpu</span> <span class="operator">=</span> cf.makeCPU();</span><br><span class="line">    <span class="comment">// 从这个大厂造主板</span></span><br><span class="line">    <span class="type">MainBoard</span> <span class="variable">board</span> <span class="operator">=</span> cf.makeMainBoard();</span><br><span class="line">  	<span class="comment">// 从这个大厂造硬盘</span></span><br><span class="line">  	<span class="type">HardDisk</span> <span class="variable">hardDisk</span> <span class="operator">=</span> cf.makeHardDisk();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将同一个厂子出来的 CPU、主板、硬盘组装在一起</span></span><br><span class="line">    <span class="type">Computer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(cpu, board, hardDisk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>对修改关闭，对扩展开放</strong>这个设计原则。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式用得最多，错得最多。</p>
<p>饿汉模式最简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 首先，将 new Singleton() 堵死</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 瞎写一个静态方法。这里想说的是，如果我们只是要调用 Singleton.getDate(...)，</span></span><br><span class="line">    <span class="comment">// 本来是不想要生成 Singleton 实例的，不过没办法，已经生成了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">getDate</span><span class="params">(String mode)</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>很多人都能说出饿汉模式的缺点，可是我觉得生产过程中，很少碰到这种情况：你定义了一个单例的类，不需要其实例，可是你却把一个或几个你会用到的静态方法塞到这个类中。</p>
</blockquote>
<p>饱汉模式最容易出错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 首先，也是先堵死 new Singleton() 这条路</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 这一次判断也是必须的，不然会有并发问题</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>双重检查，指的是两次检查 instance 是否为 null。</p>
<p>volatile 在这里是需要的，希望能引起读者的关注。</p>
<p>很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。</p>
</blockquote>
<p>嵌套类最经典，以后大家就用它吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton3</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，很多人都会把这个<strong>嵌套类</strong>说成是<strong>静态内部类</strong>，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。</p>
</blockquote>
<p>最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。</p>
<p>虽然我们平时很少看到用枚举来实现单例，但是在 RxJava 的源码中，有很多地方都用了枚举来实现单例。</p>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>经常碰见的 XxxBuilder 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodBuilder</span>().a().b().c().build();</span><br><span class="line"><span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> Food.builder().a().b().c().build();</span><br></pre></td></tr></table></figure>

<p>套路就是先 new 一个 Builder，然后可以链式地调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了。</p>
<p>来一个中规中矩的建造者模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 下面是“一堆”的属性</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化，不然客户端就会直接调用构造方法了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(String name, String password, String nickName, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯，</span></span><br><span class="line">    <span class="comment">// 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserBuilder <span class="title function_">builder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserBuilder</span> &#123;</span><br><span class="line">        <span class="comment">// 下面是和 User 一模一样的一堆属性</span></span><br><span class="line">        <span class="keyword">private</span> String  name;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line">        <span class="keyword">private</span> String nickName;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">UserBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链式调用设置各个属性值，返回 this，即 UserBuilder</span></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">name</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">password</span><span class="params">(String password)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.password = password;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">nickName</span><span class="params">(String nickName)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">age</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。</span></span><br><span class="line">        <span class="comment">// 当然，可以在 “复制” 之前做点检验</span></span><br><span class="line">        <span class="keyword">public</span> User <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (name == <span class="literal">null</span> || password == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名和密码必填&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (age &lt;= <span class="number">0</span> || age &gt;= <span class="number">150</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;年龄不合法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 还可以做赋予”默认值“的功能</span></span><br><span class="line">          	<span class="keyword">if</span> (nickName == <span class="literal">null</span>) &#123;</span><br><span class="line">                nickName = name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(name, password, nickName, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心是：先把所有的属性都设置给 Builder，然后 build() 方法的时候，将这些属性<strong>复制</strong>给实际产生的对象。</p>
<p>看看客户端的调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">d</span> <span class="operator">=</span> User.builder()</span><br><span class="line">                .name(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;pAss12345&quot;</span>)</span><br><span class="line">                .age(<span class="number">25</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说实话，建造者模式的<strong>链式</strong>写法很吸引人，但是，多写了很多“无用”的 builder 的代码，感觉这个模式没什么用。不过，当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多。我们可以在 <strong>Builder 的构造方法</strong>中强制让调用者提供必填字段，还有，在 build() 方法中校验各个参数比在 User 的构造方法中校验，代码要优雅一些。</p>
<blockquote>
<p>题外话，强烈建议读者使用 lombok，用了 lombok 以后，上面的一大堆代码会变成如下这样:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String  name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>怎么样，省下来的时间是不是又可以干点别的了。</p>
</blockquote>
<p>当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，User 的 getter 方法不变，所有的 setter 方法都让其 <strong>return this</strong> 就可以了，然后就可以像下面这样调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>().setName(<span class="string">&quot;&quot;</span>).setPassword(<span class="string">&quot;&quot;</span>).setAge(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>很多人是这么用的，但是笔者觉得其实这种写法非常地不优雅，不是很推荐使用。</p>
</blockquote>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>这是我要说的创建型模式的最后一个设计模式了。</p>
<p>原型模式很简单：有一个原型<strong>实例</strong>，基于这个原型实例产生新的实例，也就是“克隆”了。</p>
<p>Object 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先<strong>实现 Cloneable 接口</strong>，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出 CloneNotSupportedException 异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。</p>
</blockquote>
<p>原型模式了解到这里我觉得就够了，各种变着法子说这种代码或那种代码是原型模式，没什么意义。</p>
<h3 id="创建型模式总结"><a href="#创建型模式总结" class="headerlink" title="创建型模式总结"></a>创建型模式总结</h3><p>创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是<strong>面向对象</strong>的代码，所以我们第一步当然是需要创建一个对象了。</p>
<p>简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。</p>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>前面创建型模式介绍了创建对象的一些设计模式，这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>第一个要介绍的代理模式是最常使用的模式之一了，用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。</p>
<p>既然说是<strong>代理</strong>，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。</p>
<blockquote>
<p>理解<strong>代理</strong>这个词，这个模式其实就简单了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FoodService</span> &#123;</span><br><span class="line">    Food <span class="title function_">makeChicken</span><span class="params">()</span>;</span><br><span class="line">    Food <span class="title function_">makeNoodle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">FoodService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeChicken</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="type">Food</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chicken</span>()</span><br><span class="line">        f.setChicken(<span class="string">&quot;1kg&quot;</span>);</span><br><span class="line">      	f.setSpicy(<span class="string">&quot;1g&quot;</span>);</span><br><span class="line">      	f.setSalt(<span class="string">&quot;3g&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeNoodle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Food</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Noodle</span>();</span><br><span class="line">        f.setNoodle(<span class="string">&quot;500g&quot;</span>);</span><br><span class="line">        f.setSalt(<span class="string">&quot;5g&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理要表现得“就像是”真实实现类，所以需要实现 FoodService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">FoodService</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 内部一定要有一个真实的实现类，当然也可以通过构造方法注入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">FoodService</span> <span class="variable">foodService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodServiceImpl</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeChicken</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们马上要开始制作鸡肉了&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，</span></span><br><span class="line">        <span class="comment">// 代理只是在核心代码前后做些“无足轻重”的事情</span></span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> foodService.makeChicken();</span><br><span class="line">      </span><br><span class="line">        System.out.println(<span class="string">&quot;鸡肉制作完成啦，加点胡椒粉&quot;</span>); <span class="comment">// 增强</span></span><br><span class="line">      	food.addCondiment(<span class="string">&quot;pepper&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeNoodle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备制作拉面~&quot;</span>);</span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> foodService.makeNoodle();</span><br><span class="line">        System.out.println(<span class="string">&quot;制作完成啦&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用，注意，我们要用代理来实例化接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里用代理类来实例化</span></span><br><span class="line"><span class="type">FoodService</span> <span class="variable">foodService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodServiceProxy</span>();</span><br><span class="line">foodService.makeChicken();</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.javadoop.com/blogimages/design-pattern/proxy-1.png" alt="proxy"></p>
<p>我们发现没有，代理模式说白了就是做 <strong>“方法包装”</strong> 或做 <strong>“方法增强”</strong>。在面向切面编程中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。</p>
<p>说到动态代理，又可以展开说，Spring 中实现动态代理有两种，一种是如果我们的类定义了接口，如 UserService 接口和 UserServiceImpl 实现，那么采用 JDK 的动态代理，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包，性能还不错。</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>说完代理模式，说适配器模式，是因为它们很相似，这里可以做个比较。</p>
<p>适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配。</p>
<p>适配器模式总体来说分三种：默认适配器模式、对象适配器模式、类适配器模式。先不急着分清楚这几个，先看看例子再说。</p>
<h4 id="默认适配器模式"><a href="#默认适配器模式" class="headerlink" title="默认适配器模式"></a>默认适配器模式</h4><p>首先，我们先看看最简单的适配器模式**默认适配器模式(Default Adapter)**是怎么样的。</p>
<p>我们用 Appache commons-io 包中的 FileAlterationListener 做例子，此接口定义了很多的方法，用于对文件或文件夹进行监控，一旦发生了对应的操作，就会触发相应的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FileAlterationListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryCreate</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryChange</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryDelete</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileChange</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此接口的一大问题是抽象方法太多了，如果我们要用这个接口，意味着我们要实现每一个抽象方法，如果我们只是想要监控文件夹中的<strong>文件创建</strong>和<strong>文件删除</strong>事件，可是我们还是不得不实现所有的方法，很明显，这不是我们想要的。</p>
<p>所以，我们需要下面的一个<strong>适配器</strong>，它用于实现上面的接口，但是<strong>所有的方法都是空方法</strong>，这样，我们就可以转而定义自己的类来继承下面这个类即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileAlterationListenerAdaptor</span> <span class="keyword">implements</span> <span class="title class_">FileAlterationListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDirectoryCreate</span><span class="params">(<span class="keyword">final</span> File directory)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDirectoryChange</span><span class="params">(<span class="keyword">final</span> File directory)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDirectoryDelete</span><span class="params">(<span class="keyword">final</span> File directory)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileChange</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们可以定义以下类，我们仅仅需要实现我们想实现的方法就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileMonitor</span> <span class="keyword">extends</span> <span class="title class_">FileAlterationListenerAdaptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">        <span class="comment">// 文件创建</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">        <span class="comment">// 文件删除</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，上面说的只是适配器模式的其中一种，也是最简单的一种，无需多言。下面，再介绍<strong>“正统的”</strong>适配器模式。</p>
<h4 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h4><p>来看一个《Head First 设计模式》中的一个例子，我稍微修改了一下，看看怎么将鸡适配成鸭，这样鸡也能当鸭来用。因为，现在鸭这个接口，我们没有合适的实现类可以用，所以需要适配器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span>; <span class="comment">// 鸭的呱呱叫</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 飞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span>; <span class="comment">// 鸡的咕咕叫</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 飞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WildCock</span> <span class="keyword">implements</span> <span class="title class_">Cock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;咕咕叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸡也会飞哦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>鸭接口有 fly() 和 quare() 两个方法，鸡 Cock 如果要冒充鸭，fly() 方法是现成的，但是鸡不会鸭的呱呱叫，没有 quack() 方法。这个时候就需要适配了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CockAdapter</span> <span class="keyword">implements</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">  </span><br><span class="line">    Cock cock;</span><br><span class="line">    <span class="comment">// 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">CockAdapter</span><span class="params">(Cock cock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cock = cock;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 实现鸭的呱呱叫方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 内部其实是一只鸡的咕咕叫</span></span><br><span class="line">        cock.gobble();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        cock.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用很简单了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 有一只野鸡</span></span><br><span class="line">  	<span class="type">Cock</span> <span class="variable">wildCock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WildCock</span>();</span><br><span class="line">  	<span class="comment">// 成功将野鸡适配成鸭</span></span><br><span class="line">  	<span class="type">Duck</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CockAdapter</span>(wildCock);</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，大家也就知道了适配器模式是怎么回事了。无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的。</p>
<p>我们用一个图来简单说明下：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/adapter-1.png" alt="adapter-1"></p>
<p>上图应该还是很容易理解的，我就不做更多的解释了。下面，我们看看类适配模式怎么样的。</p>
<h4 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h4><p>废话少说，直接上图：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/adapter-2.png" alt="adapter-1"></p>
<p>看到这个图，大家应该很容易理解的吧，通过继承的方法，适配器自动获得了所需要的大部分方法。这个时候，客户端使用更加简单，直接 <code>Target t = new SomeAdapter();</code> 就可以了。</p>
<h4 id="适配器模式总结"><a href="#适配器模式总结" class="headerlink" title="适配器模式总结"></a>适配器模式总结</h4><ol>
<li><p>类适配和对象适配的异同</p>
<blockquote>
<p>一个采用继承，一个采用组合；</p>
<p>类适配属于静态实现，对象适配属于组合的动态实现，对象适配需要多实例化一个对象。</p>
<p>总体来说，对象适配用得比较多。</p>
</blockquote>
</li>
<li><p>适配器模式和代理模式的异同</p>
<p>比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/adapter-5.png" alt="adapter-5"></p>
</li>
</ol>
<h3 id="桥梁模式"><a href="#桥梁模式" class="headerlink" title="桥梁模式"></a>桥梁模式</h3><p>理解桥梁模式，其实就是理解代码抽象和解耦。</p>
<p>我们首先需要一个桥梁，它是一个接口，定义提供的接口方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是一系列实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedPen</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用红色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenPen</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用绿色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BluePen</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用蓝色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个抽象类，此类的实现类都需要使用 DrawAPI：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> DrawAPI drawAPI;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Shape</span><span class="params">(DrawAPI drawAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.drawAPI = drawAPI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义抽象类的子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 圆形</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> radius;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">int</span> radius, DrawAPI drawAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(drawAPI);</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        drawAPI.draw(radius, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 长方形</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, DrawAPI drawAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(drawAPI);</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        drawAPI.draw(<span class="number">0</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们来看客户端演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Shape</span> <span class="variable">greenCircle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">10</span>, <span class="keyword">new</span> <span class="title class_">GreenPen</span>());</span><br><span class="line">    <span class="type">Shape</span> <span class="variable">redRectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">4</span>, <span class="number">8</span>, <span class="keyword">new</span> <span class="title class_">RedPen</span>());</span><br><span class="line">    greenCircle.draw();</span><br><span class="line">    redRectangle.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能大家看上面一步步还不是特别清晰，我把所有的东西整合到一张图上：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/bridge-1.png" alt="bridge-1"></p>
<p>这回大家应该就知道抽象在哪里，怎么解耦了吧。桥梁模式的优点也是显而易见的，就是非常容易进行扩展。</p>
<blockquote>
<p>本节引用了<a target="_blank" rel="noopener" href="https://www.tutorialspoint.com/design_pattern/bridge_pattern.htm">这里</a>的例子，并对其进行了修改。</p>
</blockquote>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>要把装饰模式说清楚明白，不是件容易的事情。也许读者知道 <strong>Java IO</strong> 中的几个类是典型的装饰模式的应用，但是读者不一定清楚其中的关系，也许看完就忘了，希望看完这节后，读者可以对其有更深的感悟。</p>
<p>首先，我们先看一个简单的图，看这个图的时候，了解下层次结构就可以了：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/decorator-1.png" alt="decorator-1"></p>
<p>我们来说说装饰模式的出发点，从图中可以看到，接口 <code>Component</code> 其实已经有了 <code>ConcreteComponentA</code> 和 <code>ConcreteComponentB</code> 两个实现类了，但是，如果我们要<strong>增强</strong>这两个实现类的话，我们就可以采用装饰模式，用具体的装饰器来<strong>装饰</strong>实现类，以达到增强的目的。</p>
<blockquote>
<p>从名字来简单解释下装饰器。既然说是装饰，那么往往就是<strong>添加小功能</strong>这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的多层包装方式，但是那样的话代码就复杂了。</p>
</blockquote>
<p>首先明白一些简单的概念，从图中我们看到，所有的具体装饰者们 <strong>ConcreteDecorator</strong>* 都可以作为 Component 来使用，因为它们都实现了 Component 中的所有接口。它们和 Component 实现类 ConcreteComponent* 的区别是，它们只是装饰者，起<strong>装饰</strong>作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中<strong>加了层皮来装饰</strong>而已。</p>
<blockquote>
<p>注意这段话中混杂在各个名词中的 Component 和 Decorator，别搞混了。</p>
</blockquote>
<p>下面来看看一个例子，先把装饰模式弄清楚，然后再介绍下 java io 中的装饰模式的应用。</p>
<p>最近大街上流行起来了“快乐柠檬”，我们把快乐柠檬的饮料分为三类：红茶、绿茶、咖啡，在这三大类的基础上，又增加了许多的口味，什么金桔柠檬红茶、金桔柠檬珍珠绿茶、芒果红茶、芒果绿茶、芒果珍珠红茶、烤珍珠红茶、烤珍珠芒果绿茶、椰香胚芽咖啡、焦糖可可咖啡等等，每家店都有很长的菜单，但是仔细看下，其实原料也没几样，但是可以搭配出很多组合，如果顾客需要，很多没出现在菜单中的饮料他们也是可以做的。</p>
<p>在这个例子中，红茶、绿茶、咖啡是最基础的饮料，其他的像金桔柠檬、芒果、珍珠、椰果、焦糖等都属于装饰用的。当然，在开发中，我们确实可以像门店一样，开发这些类：LemonBlackTea、LemonGreenTea、MangoBlackTea、MangoLemonGreenTea……但是，很快我们就发现，这样子干肯定是不行的，这会导致我们需要组合出所有的可能，而且如果客人需要在红茶中加双份柠檬怎么办？三份柠檬怎么办？</p>
<p>不说废话了，上代码。</p>
<p>首先，定义饮料抽象基类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">  	<span class="comment">// 返回描述</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">  	<span class="comment">// 返回价格</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是三个基础饮料实现类，红茶、绿茶和咖啡：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlackTea</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">  	<span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;红茶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenTea</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;绿茶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...<span class="comment">// 咖啡省略</span></span><br></pre></td></tr></table></figure>

<p>定义调料，也就是装饰者的基类，此类必须继承自 Beverage：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Condiment</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们来定义柠檬、芒果等具体的调料，它们属于装饰者，毫无疑问，这些调料肯定都需要继承调料 Condiment 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lemon</span> <span class="keyword">extends</span> <span class="title class_">Condiment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Beverage bevarage;</span><br><span class="line">    <span class="comment">// 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶，</span></span><br><span class="line">    <span class="comment">// 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Lemon</span><span class="params">(Beverage bevarage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bevarage = bevarage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 装饰</span></span><br><span class="line">        <span class="keyword">return</span> bevarage.getDescription() + <span class="string">&quot;, 加柠檬&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 装饰</span></span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">2</span>; <span class="comment">// 加柠檬需要 2 元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mango</span> <span class="keyword">extends</span> <span class="title class_">Condiment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Beverage bevarage;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mango</span><span class="params">(Beverage bevarage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bevarage = bevarage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bevarage.getDescription() + <span class="string">&quot;, 加芒果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">3</span>; <span class="comment">// 加芒果需要 3 元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...<span class="comment">// 给每一种调料都加一个类</span></span><br></pre></td></tr></table></figure>

<p>看客户端调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先，我们需要一个基础饮料，红茶、绿茶或咖啡</span></span><br><span class="line">    <span class="type">Beverage</span> <span class="variable">beverage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GreenTea</span>();</span><br><span class="line">    <span class="comment">// 开始装饰</span></span><br><span class="line">    beverage = <span class="keyword">new</span> <span class="title class_">Lemon</span>(beverage); <span class="comment">// 先加一份柠檬</span></span><br><span class="line">    beverage = <span class="keyword">new</span> <span class="title class_">Mongo</span>(beverage); <span class="comment">// 再加一份芒果</span></span><br><span class="line"></span><br><span class="line">    System.out.println(beverage.getDescription() + <span class="string">&quot; 价格：￥&quot;</span> + beverage.cost());</span><br><span class="line">    <span class="comment">//&quot;绿茶, 加柠檬, 加芒果 价格：￥16&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们需要 <strong>芒果-珍珠-双份柠檬-红茶</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Beverage</span> <span class="variable">beverage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mongo</span>(<span class="keyword">new</span> <span class="title class_">Pearl</span>(<span class="keyword">new</span> <span class="title class_">Lemon</span>(<span class="keyword">new</span> <span class="title class_">Lemon</span>(<span class="keyword">new</span> <span class="title class_">BlackTea</span>()))));</span><br></pre></td></tr></table></figure>

<p>是不是很变态？</p>
<p>看看下图可能会清晰一些：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/decorator-2.png" alt="decorator-2"></p>
<p>到这里，大家应该已经清楚装饰模式了吧。</p>
<p>下面，我们再来说说 java IO 中的装饰模式。看下图 InputStream 派生出来的部分类：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/decorator-3.png" alt="decorator-3"></p>
<p>我们知道 InputStream 代表了输入流，具体的输入来源可以是文件（FileInputStream）、管道（PipedInputStream）、数组（ByteArrayInputStream）等，这些就像前面奶茶的例子中的红茶、绿茶，属于基础输入流。</p>
<p>FilterInputStream 承接了装饰模式的关键节点，它的实现类是一系列装饰器，比如 BufferedInputStream 代表用缓冲来装饰，也就使得输入流具有了缓冲的功能，LineNumberInputStream 代表用行号来装饰，在操作的时候就可以取得行号了，DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的基本类型值。</p>
<p>当然，在 java IO 中，如果我们使用装饰器的话，就不太适合面向接口编程了，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LineNumberInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>这样的结果是，InputStream 还是不具有读取行号的功能，因为读取行号的方法定义在 LineNumberInputStream 类中。</p>
<p>我们应该像下面这样使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(</span><br><span class="line">  							<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">                              	<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;&quot;</span>)));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的。</p>
</blockquote>
<h3 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h3><p>门面模式（也叫外观模式，Facade Pattern）在许多源码中有使用，比如 slf4j 就可以理解为是门面模式的应用。这是一个简单的设计模式，我们直接上代码再说吧。</p>
<p>首先，我们定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义几个实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Circle::draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Rectangle::draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 画一个圆形</span></span><br><span class="line">  	<span class="type">Shape</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">  	circle.draw();</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 画一个长方形</span></span><br><span class="line">  	<span class="type">Shape</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">  	rectangle.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是我们常写的代码，我们需要画圆就要先实例化圆，画长方形就需要先实例化一个长方形，然后再调用相应的 draw() 方法。</p>
<p>下面，我们看看怎么用门面模式来让客户端调用更加友好一些。</p>
<p>我们先定义一个门面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeMaker</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Shape circle;</span><br><span class="line">   <span class="keyword">private</span> Shape rectangle;</span><br><span class="line">   <span class="keyword">private</span> Shape square;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ShapeMaker</span><span class="params">()</span> &#123;</span><br><span class="line">      circle = <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">      rectangle = <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">      square = <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">()</span>&#123;</span><br><span class="line">      circle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">()</span>&#123;</span><br><span class="line">      rectangle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawSquare</span><span class="params">()</span>&#123;</span><br><span class="line">      square.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看现在客户端怎么调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">ShapeMaker</span> <span class="variable">shapeMaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeMaker</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 客户端调用现在更加清晰了</span></span><br><span class="line">  shapeMaker.drawCircle();</span><br><span class="line">  shapeMaker.drawRectangle();</span><br><span class="line">  shapeMaker.drawSquare();		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>门面模式的优点显而易见，客户端不再需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。</p>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。</p>
<p>直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，同时还有下属员工集合（虽然可能集合为空），而下属员工和自己的结构是一样的，也有姓名、部门这些属性，同时也有他们的下属员工集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String dept;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> salary;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Employee&gt; subordinates; <span class="comment">// 下属</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name,String dept, <span class="type">int</span> sal)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.dept = dept;</span><br><span class="line">      <span class="built_in">this</span>.salary = sal;</span><br><span class="line">      subordinates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Employee e)</span> &#123;</span><br><span class="line">      subordinates.add(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Employee e)</span> &#123;</span><br><span class="line">      subordinates.remove(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getSubordinates</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> subordinates;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="string">&quot;Employee :[ Name : &quot;</span> + name + <span class="string">&quot;, dept : &quot;</span> + dept + <span class="string">&quot;, salary :&quot;</span> + salary+<span class="string">&quot; ]&quot;</span>);</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常，这种类需要定义 add(node)、remove(node)、getChildren() 这些方法。</p>
<p>这说的其实就是组合模式，这种简单的模式我就不做过多介绍了，相信各位读者也不喜欢看我写废话。</p>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>英文是 Flyweight Pattern，不知道是谁最先翻译的这个词，感觉这翻译真的不好理解，我们试着强行关联起来吧。Flyweight 是轻量级的意思，享元分开来说就是 共享 元器件，也就是复用已经生成的对象，这种做法当然也就是轻量级的了。</p>
<p>复用对象最简单的方式是，用一个 HashMap 来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中。</p>
<p>这种简单的代码我就不演示了。</p>
<h3 id="结构型模式总结"><a href="#结构型模式总结" class="headerlink" title="结构型模式总结"></a>结构型模式总结</h3><p>前面，我们说了代理模式、适配器模式、桥梁模式、装饰模式、门面模式、组合模式和享元模式。读者是否可以分别把这几个模式说清楚了呢？在说到这些模式的时候，心中是否有一个清晰的图或处理流程在脑海里呢？</p>
<p>代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。</p>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式太常用了，所以把它放到最前面进行介绍。它比较简单，我就不废话，直接用代码说事吧。</p>
<p>下面设计的场景是，我们需要画一个图形，可选的策略就是用红色笔来画，还是绿色笔来画，或者蓝色笔来画。</p>
<p>首先，先定义一个策略接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们定义具体的几个策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedPen</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;用红色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenPen</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;用绿色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BluePen</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;用蓝色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用策略的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">executeDraw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> strategy.draw(radius, x, y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">BluePen</span>()); <span class="comment">// 使用绿色笔来画</span></span><br><span class="line">  	context.executeDraw(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>放到一张图上，让大家看得清晰些：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/strategy-1.png" alt="strategy-1"></p>
<p>这个时候，大家有没有联想到结构型模式中的桥梁模式，它们其实非常相似，我把桥梁模式的图拿过来大家对比下：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/bridge-1.png" alt="bridge-1"></p>
<p>要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。桥梁模式的耦合更低，结构更复杂一些。</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，观察者订阅自己关心的主题和主题有数据变化后通知观察者们。</p>
<p>首先，需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">        <span class="comment">// 数据已变更，通知观察者们</span></span><br><span class="line">        notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知观察者们</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyAllObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义观察者接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Subject subject;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。</p>
<p>我们来定义具体的几个观察者类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryObserver</span> <span class="keyword">extends</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">// 在构造方法中进行订阅主题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryObserver</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">        <span class="comment">// 通常在构造方法中将 this 发布出去的操作一定要小心</span></span><br><span class="line">        <span class="built_in">this</span>.subject.attach(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该方法由主题类在数据变更的时候进行调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> Integer.toBinaryString(subject.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;订阅的数据发生变化，新的数据处理为二进制值为：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HexaObserver</span> <span class="keyword">extends</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HexaObserver</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">        <span class="built_in">this</span>.subject.attach(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> Integer.toHexString(subject.getState()).toUpperCase();</span><br><span class="line">        System.out.println(<span class="string">&quot;订阅的数据发生变化，新的数据处理为十六进制值为：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端使用也非常简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 先定义一个主题</span></span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line">    <span class="comment">// 定义观察者</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BinaryObserver</span>(subject1);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HexaObserver</span>(subject1);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 模拟数据变更，这个时候，观察者们的 update 方法将会被调用</span></span><br><span class="line">    subject.setState(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">订阅的数据发生变化，新的数据处理为二进制值为：1011</span><br><span class="line">订阅的数据发生变化，新的数据处理为十六进制值为：B</span><br></pre></td></tr></table></figure>

<p>当然，jdk 也提供了相似的支持，具体的大家可以参考 java.util.Observable 和 java.util.Observer 这两个类。</p>
<p>实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。</p>
<p>还有，即使是上面的这个代码，也会有很多变种，大家只要记住核心的部分，那就是一定有一个地方存放了所有的观察者，然后在事件发生的时候，遍历观察者，调用它们的回调函数。</p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了。</p>
<p>有这么一个场景，用户参加一个活动可以领取奖品，但是活动需要进行很多的规则校验然后才能放行，比如首先需要校验用户是否是新用户、今日参与人数是否有限额、全场参与人数是否有限额等等。设定的规则都通过后，才能让用户领走奖品。</p>
<blockquote>
<p>如果产品给你这个需求的话，我想大部分人一开始肯定想的就是，用一个 List 来存放所有的规则，然后 foreach 执行一下每个规则就好了。不过，读者也先别急，看看责任链模式和我们说的这个有什么不一样？</p>
</blockquote>
<p>首先，我们要定义流程上节点的基类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">protected</span> RuleHandler successor;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(RuleHandler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> RuleHandler <span class="title function_">getSuccessor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们需要定义具体的每个节点了。</p>
<p>校验用户是否是新用户：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewUserRuleHandler</span> <span class="keyword">extends</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.isNewUser()) &#123;</span><br><span class="line">            <span class="comment">// 如果有后继节点的话，传递下去</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该活动仅限新用户参与&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>校验用户所在地区是否可以参与：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocationRuleHandler</span> <span class="keyword">extends</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allowed</span> <span class="operator">=</span> activityService.isSupportedLocation(context.getLocation);</span><br><span class="line">        <span class="keyword">if</span> (allowed) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;非常抱歉，您所在的地区无法参与本次活动&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>校验奖品是否已领完：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LimitRuleHandler</span> <span class="keyword">extends</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">remainedTimes</span> <span class="operator">=</span> activityService.queryRemainedTimes(context); <span class="comment">// 查询剩余奖品</span></span><br><span class="line">        <span class="keyword">if</span> (remainedTimes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.getSuccessor().apply(userInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;您来得太晚了，奖品被领完了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">RuleHandler</span> <span class="variable">newUserHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewUserRuleHandler</span>();</span><br><span class="line">    <span class="type">RuleHandler</span> <span class="variable">locationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocationRuleHandler</span>();</span><br><span class="line">    <span class="type">RuleHandler</span> <span class="variable">limitHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LimitRuleHandler</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 假设本次活动仅校验地区和奖品数量，不校验新老用户</span></span><br><span class="line">    locationHandler.setSuccessor(limitHandler);</span><br><span class="line">  </span><br><span class="line">    locationHandler.apply(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码其实很简单，就是先定义好一个链表，然后在通过任意一节点后，如果此节点有后继节点，那么传递下去。</p>
<p>至于它和我们前面说的用一个 List 存放需要执行的规则的做法有什么异同，留给读者自己琢磨吧。</p>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>在含有继承结构的代码中，模板方法模式是非常常用的。</p>
<p>通常会有一个抽象类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractTemplate</span> &#123;</span><br><span class="line">    <span class="comment">// 这就是模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        init();</span><br><span class="line">        apply(); <span class="comment">// 这个是重点</span></span><br><span class="line">        end(); <span class="comment">// 可以作为钩子方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init 抽象层已经实现，子类也可以选择覆写&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 留给子类实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。</p>
<p>我们写一个实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteTemplate</span> <span class="keyword">extends</span> <span class="title class_">AbstractTemplate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类实现抽象方法 apply&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AbstractTemplate</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteTemplate</span>();</span><br><span class="line">    <span class="comment">// 调用模板方法</span></span><br><span class="line">    t.templateMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码其实很简单，基本上看到就懂了，关键是要学会用到自己的代码中。</p>
<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>update: 2017-10-19</p>
<p>废话我就不说了，我们说一个简单的例子。商品库存中心有个最基本的需求是减库存和补库存，我们看看怎么用状态模式来写。</p>
<p>核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。</p>
<p>定义状态接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">(Context context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义减库存的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeductState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;商品卖出，准备减库存&quot;</span>);</span><br><span class="line">        context.setState(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 执行减库存的具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Deduct State&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>定义补库存状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RevertState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;给此商品补库存&quot;</span>);</span><br><span class="line">        context.setState(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 执行加库存的具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Revert State&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面用到了 context.setState(this)，我们来看看怎么定义 Context 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">  	<span class="keyword">private</span> String name;</span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看下客户端调用，大家就一清二楚了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 我们需要操作的是 iPhone X</span></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="string">&quot;iPhone X&quot;</span>);</span><br><span class="line">  	</span><br><span class="line">    <span class="comment">// 看看怎么进行补库存操作</span></span><br><span class="line">  	<span class="type">State</span> <span class="variable">revertState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RevertState</span>();</span><br><span class="line">  	revertState.doAction(context);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 同样的，减库存操作也非常简单</span></span><br><span class="line">  	<span class="type">State</span> <span class="variable">deductState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeductState</span>();</span><br><span class="line">  	deductState.doAction(context);</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 如果需要我们可以获取当前的状态</span></span><br><span class="line">    <span class="comment">// context.getState().toString();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读者可能会发现，在上面这个例子中，如果我们不关心当前 context 处于什么状态，那么 Context 就可以不用维护 state 属性了，那样代码会简单很多。</p>
<p>不过，商品库存这个例子毕竟只是个例，我们还有很多实例是需要知道当前 context 处于什么状态的。</p>
<h3 id="行为型模式总结"><a href="#行为型模式总结" class="headerlink" title="行为型模式总结"></a>行为型模式总结</h3><p>行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 学习设计模式的目的是为了让我们的代码更加的优雅、易维护、易扩展。这次整理这篇文章，让我重新审视了一下各个设计模式，对我自己而言收获还是挺大的。我想，文章的最大收益者一般都是作者本人，为了写一篇文章，需要巩固自己的知识，需要寻找各种资料，而且，自己写过的才最容易记住，也算是我给读者的建议吧。</p>
<p>（全文完）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2018/11/03/netty-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/03/netty-2/" class="post-title-link" itemprop="url">认真的 Netty 源码解析（二）(转自JavaDoop)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-03 00:00:00" itemprop="dateCreated datePublished" datetime="2018-11-03T00:00:00+08:00">2018-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 15:17:04" itemprop="dateModified" datetime="2025-04-27T15:17:04+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/netty/" itemprop="url" rel="index"><span itemprop="name">netty</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Channel-的-register-操作"><a href="#Channel-的-register-操作" class="headerlink" title="Channel 的 register 操作"></a>Channel 的 register 操作</h2><p>经过前面的铺垫，我们已经具备一定的基础了，我们开始来把前面学到的内容揉在一起。这节，我们会介绍 register 操作，这一步其实是非常关键的，对于我们源码分析非常重要。</p>
<h3 id="register"><a href="#register" class="headerlink" title="register"></a>register</h3><p>我们从 EchoClient 中的 connect() 方法出发，或者 EchoServer 的 bind(port) 方法出发，都会走到 initAndRegister() 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        <span class="comment">// 2 对于 Bootstrap 和 ServerBootstrap，这里面有些不一样</span></span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 3 我们这里要说的是这行</span></span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>initAndRegister() 这个方法我们已经接触过两次了，前面介绍了 1️⃣ Channel 的实例化，实例化过程中，会执行 Channel 内部 Unsafe 和 Pipeline 的实例化，以及在上面 2️⃣ init(channel) 方法中，会往 pipeline 中添加 handler（pipeline 此时是 head+channelnitializer+tail）。</p>
<blockquote>
<p>我们这节终于要揭秘 ChannelInitializer 中的 initChannel 方法了~~~</p>
</blockquote>
<p>现在，我们继续往下走，看看 3️⃣ <strong>register</strong> 这一步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> config().group().register(channel);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们说了，register 这一步是非常关键的，它发生在 channel 实例化以后，大家回忆一下当前 channel 中的一些情况：</p>
<p>实例化了 JDK 底层的 Channel，设置了非阻塞，实例化了 Unsafe，实例化了 Pipeline，同时往 pipeline 中添加了 head、tail 以及一个 ChannelInitializer 实例。</p>
</blockquote>
<p>上面的 <code>config().group()</code> 方法会返回前面实例化的 NioEventLoopGroup 的实例，然后调用其 register(channel) 方法：</p>
<p>// MultithreadEventLoopGroup</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> next().register(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>next() 方法很简单，就是选择线程池中的一个线程（还记得 chooserFactory 吗），也就是选择一个 NioEventLoop 实例，这个时候我们就进入到 NioEventLoop 了。</p>
<p>NioEventLoop 的 register(channel) 方法实现在它的父类 <strong>SingleThreadEventLoop</strong> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> register(<span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(channel, <span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码实例化了一个 Promise，将当前 channel 带了进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">&quot;promise&quot;</span>);</span><br><span class="line">    <span class="comment">// promise 关联了 channel，channel 持有 Unsafe 实例，register 操作就封装在 Unsafe 中</span></span><br><span class="line">    promise.channel().unsafe().register(<span class="built_in">this</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到 channel 中关联的 Unsafe 实例，然后调用它的 register 方法：</p>
<blockquote>
<p>我们说过，Unsafe 专门用来封装底层实现，当然这里也没那么“底层”</p>
</blockquote>
<p>// AbstractChannel#<strong>AbstractUnsafe</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将这个 eventLoop 实例设置给这个 channel，从此这个 channel 就是有 eventLoop 的了</span></span><br><span class="line">    <span class="comment">// 我觉得这一步其实挺关键的，因为后续该 channel 中的所有异步操作，都要提交给这个 eventLoop 来执行</span></span><br><span class="line">    AbstractChannel.<span class="built_in">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果发起 register 动作的线程就是 eventLoop 实例中的线程，那么直接调用 register0(promise)</span></span><br><span class="line">    <span class="comment">// 对于我们来说，它不会进入到这个分支，</span></span><br><span class="line">    <span class="comment">//     之所以有这个分支，是因为我们是可以 unregister，然后再 register 的，后面再仔细看</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，提交任务给 eventLoop，eventLoop 中的线程会负责调用 register0(promise)</span></span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>到这里，我们要明白，NioEventLoop 中是还没有实例化 Thread 实例的。</p>
</blockquote>
<p>这几步涉及到了好几个类：NioEventLoop、Promise、Channel、Unsafe 等，大家要仔细理清楚它们的关系。</p>
<p>对于我们前面过来的 register 操作，其实提交到 eventLoop 以后，就直接返回 promise 实例了，剩下的register0 是异步操作，它由 NioEventLoop 实例来完成。</p>
<p>我们这边先不继续往里分析 register0(promise) 方法，先把前面欠下的 NioEventLoop 中的线程介绍清楚，然后再回来介绍这个 register0 方法。</p>
<blockquote>
<p>Channel 实例一旦 register 到了 NioEventLoopGroup 实例中的某个 NioEventLoop 实例，那么后续该 Channel 的所有操作，都是由该 NioEventLoop 实例来完成的。</p>
<p>这个也非常简单，因为 Selector 实例是在 NioEventLoop 实例中的，Channel 实例一旦注册到某个 Selector 实例中，当然也只能在这个实例中处理 NIO 事件。</p>
</blockquote>
<h3 id="NioEventLoop-工作流程"><a href="#NioEventLoop-工作流程" class="headerlink" title="NioEventLoop 工作流程"></a>NioEventLoop 工作流程</h3><p>前面，我们在分析线程池的实例化的时候说过，NioEventLoop 中并没有启动 Java 线程。这里我们来仔细分析下在 register 过程中调用的 <strong>eventLoop.execute(runnable)</strong> 这个方法，这个代码在父类 SingleThreadEventExecutor 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 判断添加任务的线程是否就是当前 EventLoop 中的线程</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">inEventLoop</span> <span class="operator">=</span> inEventLoop();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加任务到之前介绍的 taskQueue 中，</span></span><br><span class="line">    <span class="comment">// 	如果 taskQueue 满了(默认大小 16)，根据我们之前说的，默认的策略是抛出异常</span></span><br><span class="line">    addTask(task);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">        <span class="comment">// 如果不是 NioEventLoop 内部线程提交的 task，那么判断下线程是否已经启动，没有的话，就启动线程</span></span><br><span class="line">        startThread();</span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原来启动 NioEventLoop 中的线程的方法在这里。</p>
<p>另外，上节我们说的 register 操作进到了 taskQueue 中，所以它其实是被归类到了非 IO 操作的范畴。</p>
</blockquote>
<p>下面是 startThread 的源码，判断线程是否已经启动来决定是否要进行启动操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="built_in">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                doStartThread();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">                STATE_UPDATER.set(<span class="built_in">this</span>, ST_NOT_STARTED);</span><br><span class="line">                PlatformDependent.throwException(cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们按照前面的思路，根据线程没有启动的情况，来看看 doStartThread() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doStartThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> thread == <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 这里的 executor 大家是不是有点熟悉的感觉，它就是一开始我们实例化 NioEventLoop 的时候传进来的 ThreadPerTaskExecutor 的实例。它是每次来一个任务，创建一个线程的那种 executor。</span></span><br><span class="line">    <span class="comment">// 一旦我们调用它的 execute 方法，它就会创建一个新的线程，所以这里终于会创建 Thread 实例</span></span><br><span class="line">    executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 看这里，将 “executor” 中创建的这个线程设置为 NioEventLoop 的线程！！！</span></span><br><span class="line">            thread = Thread.currentThread();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            updateLastExecutionTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行 SingleThreadEventExecutor 的 run() 方法，它在 NioEventLoop 中实现了</span></span><br><span class="line">                SingleThreadEventExecutor.<span class="built_in">this</span>.run();</span><br><span class="line">                success = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Unexpected exception from an event executor: &quot;</span>, t);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// ... 我们直接忽略掉这里的代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面线程启动以后，会执行 NioEventLoop 中的 run() 方法，这是一个<strong>非常重要</strong>的方法，这个方法肯定是没那么容易结束的，必然是像 JDK 线程池的 Worker 那样，不断地循环获取新的任务的。它需要不断地做 select 操作和轮询 taskQueue 这个队列。</p>
<p>我们先来简单地看一下它的源码，这里先不做深入地介绍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 代码嵌套在 for 循环中</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// selectStrategy 终于要派上用场了</span></span><br><span class="line">            <span class="comment">// 它有两个值，一个是 CONTINUE 一个是 SELECT</span></span><br><span class="line">            <span class="comment">// 针对这块代码，我们分析一下。</span></span><br><span class="line">            <span class="comment">// 1. 如果 taskQueue 不为空，也就是 hasTasks() 返回 true，</span></span><br><span class="line">            <span class="comment">// 		那么执行一次 selectNow()，该方法不会阻塞</span></span><br><span class="line">            <span class="comment">// 2. 如果 hasTasks() 返回 false，那么执行 SelectStrategy.SELECT 分支，</span></span><br><span class="line">            <span class="comment">//    进行 select(...)，这块是带阻塞的</span></span><br><span class="line">            <span class="comment">// 这个很好理解，就是按照是否有任务在排队来决定是否可以进行阻塞</span></span><br><span class="line">            <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                    <span class="comment">// 如果 !hasTasks()，那么进到这个 select 分支，这里 select 带阻塞的</span></span><br><span class="line">                    select(wakenUp.getAndSet(<span class="literal">false</span>));</span><br><span class="line">                    <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                        selector.wakeup();</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 默认地，ioRatio 的值是 50</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ioRatio</span> <span class="operator">=</span> <span class="built_in">this</span>.ioRatio;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 ioRatio 设置为 100，那么先执行 IO 操作，然后在 finally 块中执行 taskQueue 中的任务</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1. 执行 IO 操作。因为前面 select 以后，可能有些 channel 是需要处理的。</span></span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 2. 执行非 IO 任务，也就是 taskQueue 中的任务</span></span><br><span class="line">                    runAllTasks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果 ioRatio 不是 100，那么根据 IO 操作耗时，限制非 IO 操作耗时</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioStartTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行 IO 操作</span></span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 根据 IO 操作消耗的时间，计算执行非 IO 操作（runAllTasks）可以用多少时间.</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioTime</span> <span class="operator">=</span> System.nanoTime() - ioStartTime;</span><br><span class="line">                    runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Always handle shutdown even if the loop processing threw an exception.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                closeAll();</span><br><span class="line">                <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码是 NioEventLoop 的核心，这里介绍两点：</p>
<ol>
<li>首先，会根据 hasTasks() 的结果来决定是执行 selectNow() 还是 select(oldWakenUp)，这个应该好理解。如果有任务正在等待，那么应该使用无阻塞的 selectNow()，如果没有任务在等待，那么就可以使用带阻塞的 select 操作。</li>
<li>ioRatio 控制 IO 操作所占的时间比重：<ul>
<li>如果设置为 100%，那么先执行 IO 操作，然后再执行任务队列中的任务。</li>
<li>如果不是 100%，那么先执行 IO 操作，然后执行 taskQueue 中的任务，但是需要控制执行任务的总时间。也就是说，非 IO 操作可以占用的时间，通过 ioRatio 以及这次 IO 操作耗时计算得出。</li>
</ul>
</li>
</ol>
<p>我们这里先不要去关心 select(oldWakenUp)、processSelectedKeys() 方法和 runAllTasks(…) 方法的细节，只要先理解它们分别做什么事情就可以了。</p>
<p>回过神来，我们前面在 register 的时候提交了 register 任务给 NioEventLoop，这是 NioEventLoop 接收到的第一个任务，所以这里会实例化 Thread 并且启动，然后进入到 NioEventLoop 中的 run 方法。</p>
<h3 id="继续-register"><a href="#继续-register" class="headerlink" title="继续 register"></a>继续 register</h3><p>我们回到前面的 register0(promise) 方法，我们知道，这个 register 任务进入到了 NioEventLoop 的 taskQueue 中，然后会启动 NioEventLoop 中的线程，该线程会轮询这个 taskQueue，然后执行这个 register 任务。</p>
<p>注意，此时执行该方法的是 eventLoop 中的线程：</p>
<p>// AbstractChannel</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register0</span><span class="params">(ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		...</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">firstRegistration</span> <span class="operator">=</span> neverRegistered;</span><br><span class="line">        <span class="comment">// *** 进行 JDK 底层的操作：Channel 注册到 Selector 上 ***</span></span><br><span class="line">        doRegister();</span><br><span class="line">        </span><br><span class="line">        neverRegistered = <span class="literal">false</span>;</span><br><span class="line">        registered = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 到这里，就算是 registered 了</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这一步也很关键，因为这涉及到了 ChannelInitializer 的 init(channel)</span></span><br><span class="line">        <span class="comment">// 我们之前说过，init 方法会将 ChannelInitializer 内部添加的 handlers 添加到 pipeline 中</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置当前 promise 的状态为 success</span></span><br><span class="line">        <span class="comment">//   因为当前 register 方法是在 eventLoop 中的线程中执行的，需要通知提交 register 操作的线程</span></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当前的 register 操作已经成功，该事件应该被 pipeline 上</span></span><br><span class="line">        <span class="comment">//   所有关心 register 事件的 handler 感知到，往 pipeline 中扔一个事件</span></span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里 active 指的是 channel 已经打开</span></span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="comment">// 如果该 channel 是第一次执行 register，那么 fire ChannelActive 事件</span></span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                <span class="comment">// 该 channel 之前已经 register 过了，</span></span><br><span class="line">                <span class="comment">// 这里让该 channel 立马去监听通道中的 OP_READ 事件</span></span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先说掉上面的 doRegister() 方法，然后再说 pipeline。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">selected</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 附 JDK 中 Channel 的 register 方法：</span></span><br><span class="line">            <span class="comment">// public final SelectionKey register(Selector sel, int ops, Object att) &#123;...&#125;</span></span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这里做了 JDK 底层的 register 操作，将 SocketChannel(或 ServerSocketChannel) 注册到 Selector 中，并且可以看到，这里的监听集合设置为了 <strong>0</strong>，也就是什么都不监听。</p>
<blockquote>
<p>当然，也就意味着，后续一定有某个地方会需要修改这个 selectionKey 的监听集合，不然啥都干不了</p>
</blockquote>
<p>我们重点来说说 <strong>pipeline</strong> 操作，我们之前在介绍 NioSocketChannel 的 pipeline 的时候介绍到，我们的 pipeline 现在长这个样子：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/20.png" alt="20"></p>
<blockquote>
<p>现在，我们将看到这里会把 LoggingHandler 和 EchoClientHandler 添加到 pipeline。</p>
</blockquote>
<p>我们继续看代码，register 成功以后，执行了以下操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline.invokeHandlerAddedIfNeeded();</span><br></pre></td></tr></table></figure>

<p>大家可以跟踪一下，这一步会执行到 pipeline 中 ChannelInitializer 实例的 handlerAdded 方法，在这里会执行它的 init(context) 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.channel().isRegistered()) &#123;</span><br><span class="line">        initChannel(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们看下 initChannel(ctx)，这里终于来了我们之前介绍过的 init(channel) 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (initMap.putIfAbsent(ctx, Boolean.TRUE) == <span class="literal">null</span>) &#123; <span class="comment">// Guard against re-entrance.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 将把我们自定义的 handlers 添加到 pipeline 中</span></span><br><span class="line">            initChannel((C) ctx.channel());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 将 ChannelInitializer 实例从 pipeline 中删除</span></span><br><span class="line">            remove(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们前面也说过，ChannelInitializer 的 init(channel) 被执行以后，那么其内部添加的 handlers 会进入到 pipeline 中，然后上面的 finally 块中将 ChannelInitializer 的实例从 pipeline 中删除，那么此时 pipeline 就算建立起来了，如下图：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/21.png" alt="21"></p>
<blockquote>
<p>其实这里还有个问题，如果我们在 ChannelInitializer 中添加的是一个 ChannelInitializer 实例呢？大家可以考虑下这个情况。</p>
</blockquote>
<p>pipeline 建立了以后，然后我们继续往下走，会执行到这一句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline.fireChannelRegistered();</span><br></pre></td></tr></table></figure>

<p>我们只要摸清楚了 fireChannelRegistered() 方法，以后碰到其他像 fireChannelActive()、fireXxx() 等就知道怎么回事了，它们都是类似的。我们来看看这句代码会发生什么：</p>
<p>// DefaultChannelPipeline</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title function_">fireChannelRegistered</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 注意这里的传参是 head</span></span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelRegistered(head);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，我们往 pipeline 中扔了一个 <strong>channelRegistered</strong> 事件，这里的 register 属于 Inbound 事件，pipeline 接下来要做的就是执行 pipeline 中的 Inbound 类型的 handlers 中的 channelRegistered() 方法。</p>
<p>从上面的代码，我们可以看出，往 pipeline 中扔出 channelRegistered 事件以后，第一个处理的 handler 是 <strong>head</strong>。</p>
<p>接下来，我们还是跟着代码走，此时我们来到了 pipeline 的第一个节点 <strong>head</strong> 的处理中：</p>
<p>// AbstractChannelHandlerContext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next 此时是 head</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeChannelRegistered</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">    <span class="comment">// 执行 head 的 invokeChannelRegistered()</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRegistered();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                next.invokeChannelRegistered();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，这里会先执行 head.invokeChannelRegistered() 方法，而且是放到 NioEventLoop 中的 taskQueue 中执行的：</p>
<p>// AbstractChannelHandlerContext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeChannelRegistered</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// handler() 方法此时会返回 head</span></span><br><span class="line">            ((ChannelInboundHandler) handler()).channelRegistered(<span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            notifyHandlerException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fireChannelRegistered();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们去看 head 的 channelRegistered 方法：</p>
<p>// HeadContext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1. 这一步是 head 对于 channelRegistered 事件的处理。没有我们要关心的</span></span><br><span class="line">    invokeHandlerAddedIfNeeded();</span><br><span class="line">    <span class="comment">// 2. 向后传播 Inbound 事件</span></span><br><span class="line">    ctx.fireChannelRegistered();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 head 会执行 fireChannelRegister() 方法：</p>
<p>// AbstractChannelHandlerContext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelHandlerContext <span class="title function_">fireChannelRegistered</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这里很关键</span></span><br><span class="line">    <span class="comment">// findContextInbound() 方法会沿着 pipeline 找到下一个 Inbound 类型的 handler</span></span><br><span class="line">    invokeChannelRegistered(findContextInbound());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：pipeline.fireChannelRegistered() 是将 channelRegistered 事件抛到 pipeline 中，pipeline 中的 handlers 准备处理该事件。而 context.fireChannelRegistered() 是一个 handler 处理完了以后，向后传播给下一个 handler。</p>
<p>它们两个的方法名字是一样的，但是来自于不同的类。</p>
</blockquote>
<p>findContextInbound() 将找到下一个 Inbound 类型的 handler，然后又是重复上面的几个方法。</p>
<blockquote>
<p>我觉得上面这块代码没必要太纠结，总之就是从 head 中开始，依次往下寻找所有 Inbound handler，执行其 channelRegistered(ctx) 操作。</p>
</blockquote>
<p>说了这么多，我们的 register 操作算是真正完成了。</p>
<p>下面，我们回到 initAndRegister 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们上面说完了这行</span></span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> config().group().register(channel);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果在 register 的过程中，发生了错误</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 源码中说得很清楚，如果到这里，说明后续可以进行 connect() 或 bind() 了，因为两种情况：</span></span><br><span class="line">    <span class="comment">// 1. 如果 register 动作是在 eventLoop 中发起的，那么到这里的时候，register 一定已经完成</span></span><br><span class="line">    <span class="comment">// 2. 如果 register 任务已经提交到 eventLoop 中，也就是进到了 eventLoop 中的 taskQueue 中，</span></span><br><span class="line">    <span class="comment">//    由于后续的 connect 或 bind 也会进入到同一个 eventLoop 的 queue 中，所以一定是会先 register 成功，才会执行 connect 或 bind</span></span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要知道，不管是服务端的 NioServerSocketChannel 还是客户端的 NioSocketChannel，在 bind 或 connect 时，都会先进入 initAndRegister 这个方法，所以我们上面说的那些，对于两者都是通用的。</p>
<p>大家要记住，register 操作是非常重要的，要知道这一步大概做了哪些事情，register 操作以后，将进入到 bind 或 connect 操作中。</p>
<h2 id="connect-过程和-bind-过程分析"><a href="#connect-过程和-bind-过程分析" class="headerlink" title="connect 过程和 bind 过程分析"></a>connect 过程和 bind 过程分析</h2><p>上面我们介绍的 register 操作非常关键，它建立起来了很多的东西，它是 Netty 中 NioSocketChannel 和 NioServerSocketChannel 开始工作的起点。</p>
<p>这一节，我们来说说 register 之后的 connect 操作和 bind 操作。这节非常简单。</p>
<h3 id="connect-过程分析"><a href="#connect-过程分析" class="headerlink" title="connect 过程分析"></a>connect 过程分析</h3><p>对于客户端 NioSocketChannel 来说，前面 register 完成以后，就要开始 connect 了，这一步将连接到服务端。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">doResolveAndConnect</span><span class="params">(<span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里完成了 register 操作</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> regFuture.channel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里我们不去纠结 register 操作是否 isDone()</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!regFuture.isSuccess()) &#123;</span><br><span class="line">            <span class="keyword">return</span> regFuture;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 看这里</span></span><br><span class="line">        <span class="keyword">return</span> doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里大家自己一路点进去，我就不浪费篇幅了。最后，我们会来到 AbstractChannel 的 connect 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">connect</span><span class="params">(SocketAddress remoteAddress, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.connect(remoteAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，connect 操作是交给 pipeline 来执行的。进入 pipeline 中，我们会发现，connect 这种 Outbound 类型的操作，是从 pipeline 的 tail 开始的：</p>
<blockquote>
<p>前面我们介绍的 register 操作是 Inbound 的，是从 head 开始的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title function_">connect</span><span class="params">(SocketAddress remoteAddress, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tail.connect(remoteAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是 pipeline 的操作了，从 tail 开始，执行 pipeline 上的 Outbound 类型的 handlers 的 connect(…) 方法，那么真正的底层的 connect 的操作发生在哪里呢？还记得我们的 pipeline 的图吗？</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/22.png" alt="22"></p>
<p>从 tail 开始往前找 out 类型的 handlers，每经过一个 handler，都执行里面的 connect() 方法，最后会到 head 中，因为 head 也是 Outbound 类型的，我们需要的 connect 操作就在 head 中，它会负责调用 unsafe 中提供的 connect 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HeadContext</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(</span></span><br><span class="line"><span class="params">        ChannelHandlerContext ctx,</span></span><br><span class="line"><span class="params">        SocketAddress remoteAddress, SocketAddress localAddress,</span></span><br><span class="line"><span class="params">        ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    unsafe.connect(remoteAddress, localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们来看一看 connect 在 unsafe 类中所谓的底层操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractNioChannel.AbstractNioUnsafe</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">		......</span><br><span class="line">            </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">wasActive</span> <span class="operator">=</span> isActive();</span><br><span class="line">        <span class="comment">// 大家自己点进去看 doConnect 方法</span></span><br><span class="line">        <span class="comment">// 这一步会做 JDK 底层的 SocketChannel connect，然后设置 interestOps 为 SelectionKey.OP_CONNECT</span></span><br><span class="line">        <span class="comment">// 返回值代表是否已经连接成功</span></span><br><span class="line">        <span class="keyword">if</span> (doConnect(remoteAddress, localAddress)) &#123;</span><br><span class="line">            <span class="comment">// 处理连接成功的情况</span></span><br><span class="line">            fulfillConnectPromise(promise, wasActive);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            connectPromise = promise;</span><br><span class="line">            requestedRemoteAddress = remoteAddress;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面这块代码，在处理连接超时的情况，代码很简单</span></span><br><span class="line">            <span class="comment">// 这里用到了 NioEventLoop 的定时任务的功能，这个我们之前一直都没有介绍过，因为我觉得也不太重要</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">connectTimeoutMillis</span> <span class="operator">=</span> config().getConnectTimeoutMillis();</span><br><span class="line">            <span class="keyword">if</span> (connectTimeoutMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                connectTimeoutFuture = eventLoop().schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="type">ChannelPromise</span> <span class="variable">connectPromise</span> <span class="operator">=</span> AbstractNioChannel.<span class="built_in">this</span>.connectPromise;</span><br><span class="line">                        <span class="type">ConnectTimeoutException</span> <span class="variable">cause</span> <span class="operator">=</span></span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">ConnectTimeoutException</span>(<span class="string">&quot;connection timed out: &quot;</span> + remoteAddress);</span><br><span class="line">                        <span class="keyword">if</span> (connectPromise != <span class="literal">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;</span><br><span class="line">                            close(voidPromise());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            promise.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">if</span> (future.isCancelled()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (connectTimeoutFuture != <span class="literal">null</span>) &#123;</span><br><span class="line">                            connectTimeoutFuture.cancel(<span class="literal">false</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        connectPromise = <span class="literal">null</span>;</span><br><span class="line">                        close(voidPromise());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        promise.tryFailure(annotateConnectException(t, remoteAddress));</span><br><span class="line">        closeIfClosed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上面的 doConnect 方法返回 false，那么后续是怎么处理的呢？</p>
<p>在上一节介绍的 register 操作中，channel 已经 register 到了 selector 上，只不过将 interestOps 设置为了 0，也就是什么都不监听。</p>
<p>而在上面的 doConnect 方法中，我们看到它在调用底层的 connect 方法后，会设置 interestOps 为 <code>SelectionKey.OP_CONNECT</code>。</p>
<p>剩下的就是 NioEventLoop 的事情了，还记得 NioEventLoop 的 run() 方法吗？也就是说这里的 connect 成功以后，这个 TCP 连接就建立起来了，后续的操作会在 <code>NioEventLoop.run()</code> 方法中被 <code>processSelectedKeys()</code> 方法处理掉。</p>
<h3 id="bind-过程分析"><a href="#bind-过程分析" class="headerlink" title="bind 过程分析"></a>bind 过程分析</h3><p>说完 connect 过程，我们再来简单看下 bind 过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class="line">    <span class="comment">// **前面说的 initAndRegister**</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> initAndRegister();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        <span class="comment">// register 动作已经完成，那么执行 bind 操作</span></span><br><span class="line">        <span class="type">ChannelPromise</span> <span class="variable">promise</span> <span class="operator">=</span> channel.newPromise();</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后一直往里看，会看到，bind 操作也是要由 pipeline 来完成的：</p>
<p>// AbstractChannel</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bind 操作和 connect 一样，都是 Outbound 类型的，所以都是 tail 开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title function_">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tail.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的 bind 操作又到了 head 中，由 head 来调用 unsafe 提供的 bind 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(</span></span><br><span class="line"><span class="params">        ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    unsafe.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>感兴趣的读者自己去看一下 unsafe 中的 bind 方法，非常简单，bind 操作也不是什么异步方法，我们就介绍到这里了。</p>
<p>本节非常简单，就是想和大家介绍下 Netty 中各种操作的套路。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2018/11/03/netty-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/03/netty-1/" class="post-title-link" itemprop="url">认真的 Netty 源码解析（一）(转自JavaDoop)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-03 00:00:00" itemprop="dateCreated datePublished" datetime="2018-11-03T00:00:00+08:00">2018-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 15:16:47" itemprop="dateModified" datetime="2025-04-27T15:16:47+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/netty/" itemprop="url" rel="index"><span itemprop="name">netty</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文又是一篇源码分析文章，其实除了 Doug Lea 的并发包源码，我是真不太爱写源码分析。因为要花非常多的时间，而且很多地方需要反复组织语言。</p>
<p>本文将介绍 Netty，Java 平台上使用最广泛的 NIO 包，它是对 JDK 中的 NIO 实现的一层封装，让我们能更方便地开发 NIO 程序。其实，Netty 不仅仅是 NIO 吧，但是，基本上大家都冲着 NIO 来的。</p>
<p>个人感觉国内对于 Netty 的吹嘘是有点过了，主要是很多人靠它吃饭，要么是搞培训的，要么是出书的，恨不得把 Netty 吹上天去，这种现象也是挺不好的，反而使得初学者觉得 Netty 是什么高深的技术一样。</p>
<p>Netty 的源码不是很简单，因为它比较多，而且各个类之间的关系错综复杂，很多人说它的源码很好，这点我觉得一般，真要说好代码，还得 Doug Lea 的并发源码比较漂亮，一行行都是精华，不过它们是不同类型的，也没什么好对比的。Netty 源码好就好在它的接口使用比较灵活，往往接口好用的框架，源码都不会太简单。</p>
<p>本文将立足于源码分析，所以读者需要先掌握 NIO 的基础知识，至少我之前写的 <a href="/post/java-nio">《Java NIO：Buffer、Channel 和 Selector》</a> 中介绍的基础知识要清楚，如果读者已经对 Netty 有些了解，或者使用过，那就更好了。</p>
<ul>
<li>本文只介绍 TCP 相关的内容，Netty 对于其他协议的支持，不在本文的讨论范围内。</li>
<li>和并发包的源码分析不一样，我不可能一行一行源码说，所以有些异常分支是会直接略过，除非我觉得需要介绍。</li>
<li>Netty 源码一直在更新，各版本之间有些差异，我是按照 2018-09-06 的最新版本 <strong>4.1.25.Final</strong> 来进行介绍的。</li>
</ul>
<p>建议初学者在看完本文以后，可以去翻翻《Netty In Action》，网上也可以找到中文文字版的。</p>
<!-- toc -->

<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>学习源码，一开始肯定是准备环境。</p>
<p>我喜欢用 maven，也喜欢 Spring Boot，所以我一般先到 <a target="_blank" rel="noopener" href="https://start.spring.io/">https://start.spring.io/</a> 准备一个最简单的脚手架。</p>
<p>10 秒搞定脚手架，然后就是导入到 Intellij 中，如果用新版本的 Spring Boot，可能还需要等待下载依赖，期间打开 <a target="_blank" rel="noopener" href="https://mvnrepository.com/">https://mvnrepository.com/</a> 搜索马上要用到的 maven 依赖。</p>
<p>Netty 分为好些模块，有 <a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/io.netty/netty-handler">netty-handler</a>、<a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/io.netty/netty-buffer">netty-buffer</a>、<a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/io.netty/netty-transport">netty-transport</a>、<a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/io.netty/netty-common">netty-common</a> 等等，也有一个 <a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/io.netty/netty-all">netty-all</a>，它包含了所有的模块。</p>
<p>既然我们是源码分析，那么自然是用一个最简单的。netty-all 不是最好的选择，netty-example 才是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-example<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.25.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>它不仅可以解决我们的依赖，而且 example 里面的示例非常适合我们学习使用。</p>
<h2 id="Echo-例子"><a href="#Echo-例子" class="headerlink" title="Echo 例子"></a>Echo 例子</h2><p>Netty 作为 NIO 的库，自然既可以作为服务端接受请求，也可以作为客户端发起请求。使用 Netty 开发客户端或服务端都是非常简单的，Netty 做了很好的封装，我们通常只要开发一个或多个 <strong>handler</strong> 用来处理我们的自定义逻辑就可以了。</p>
<p>下面，我们来看一个经常会见到的例子，它叫 <strong>Echo</strong>，也就是<strong>回声</strong>，客户端传过去什么值，服务端原样返回什么值。</p>
<blockquote>
<p>打开 netty-example 的源码，把 <code>echo</code> 包下面的代码复制出来玩一玩。</p>
</blockquote>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/5.png" alt="5"></p>
<blockquote>
<p>左边是服务端代码，右边是客户端代码。</p>
</blockquote>
<p>上面的代码基本就是模板代码，每次使用都是这一个套路，唯一需要我们开发的部分是 handler(…) 和 childHandler(…) 方法中指定的各个 handler，如 <strong>EchoServerHandler</strong> 和 <strong>EchoClientHandler</strong>，当然 Netty 源码也给我们提供了很多的 handler，比如上面的 LoggingHandler，它就是 Netty 源码中为我们提供的，需要的时候直接拿过来用就好了。</p>
<p>我们先来看一下上述代码中涉及到的一些内容：</p>
<ul>
<li><p>ServerBootstrap 类用于创建服务端实例，Bootstrap 用于创建客户端实例。</p>
</li>
<li><p>两个 EventLoopGroup：bossGroup 和 workerGroup，它们涉及的是 Netty 的线程模型，可以看到服务端有两个 group，而客户端只有一个，它们就是 Netty 中的线程池。</p>
</li>
<li><p>Netty 中的 Channel，没有直接使用 Java 原生的 ServerSocketChannel 和 SocketChannel，而是包装了 NioServerSocketChannel 和 NioSocketChannel 与之对应。</p>
<blockquote>
<p>当然，也有对其他协议的支持，如支持 UDP 协议的 NioDatagramChannel，本文只关心 TCP 相关的。</p>
</blockquote>
</li>
<li><p>左边 handler(…) 方法指定了一个 handler（LoggingHandler），这个 handler 是给服务端收到新的请求的时候处理用的。右边 handler(…) 方法指定了客户端处理请求过程中需要使用的 handlers。</p>
<blockquote>
<p>如果你想在 EchoServer 中也指定多个 handler，也可以像右边的 EchoClient 一样使用 ChannelInitializer</p>
</blockquote>
</li>
<li><p>左边 childHandler(…) 指定了 childHandler，这边的 handlers 是给新创建的连接用的，我们知道服务端 ServerSocketChannel 在 accept 一个连接以后，需要创建 SocketChannel 的实例，childHandler(…) 中设置的 handler 就是用于处理新创建的 SocketChannel 的，而不是用来处理 ServerSocketChannel 实例的。</p>
</li>
<li><p>pipeline：handler 可以指定多个（需要上面的 ChannelInitializer 类辅助），它们会组成了一个 pipeline，它们其实就类似拦截器的概念，现在只要记住一点，每个 NioSocketChannel 或 NioServerSocketChannel 实例内部都会有一个 pipeline 实例。pipeline 中还涉及到 handler 的执行顺序。</p>
</li>
<li><p>ChannelFuture：这个涉及到 Netty 中的异步编程，和 JDK 中的 Future 接口类似。</p>
</li>
</ul>
<p>对于不了解 Netty 的读者，也不要有什么压力，我会一一介绍它们，本文主要面向新手，我觉得比较难理解或比较重要的部分，会花比较大的篇幅来介绍清楚。</p>
<p>上面的源码中没有展示消息发送和消息接收的处理，此部分我会在介绍完上面的这些内容以后再进行介绍。</p>
<p>下面，将分块来介绍这些内容。鉴于读者对 NIO 或 Netty 的了解程度可能参差不齐，为了照顾初学者，很多地方需要啰嗦一些，所以希望读者一节一节往下看，对于自己熟悉的内容可以适当看快一些。</p>
<h2 id="Netty-中的-Channel"><a href="#Netty-中的-Channel" class="headerlink" title="Netty 中的 Channel"></a>Netty 中的 Channel</h2><p>这节我们来看看 NioSocketChannel 是怎么和 JDK 底层的 SocketChannel 联系在一起的，它们是一对一的关系。NioServerSocketChannel 和 ServerSocketChannel 同理，也是一对一的关系。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/3.png" alt="3"></p>
<p>在 Bootstrap（客户端） 和 ServerBootstrap（服务端） 的启动过程中都会调用 channel(…) 方法：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/10.png" alt="10"></p>
<p>下面，我们来看 channel(…) 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractBootstrap</span></span><br><span class="line"><span class="keyword">public</span> B <span class="title function_">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (channelClass == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;channelClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> <span class="title class_">ReflectiveChannelFactory</span>&lt;C&gt;(channelClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这个方法只是设置了 channelFactory 为 ReflectiveChannelFactory 的一个实例，然后我们看下这里的 ReflectiveChannelFactory 到底是什么：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/1.png" alt="1"></p>
<p><strong>newChannel()</strong> 方法是 ChannelFactory 接口中的唯一方法，<strong>工厂模式</strong>大家都很熟悉。我们可以看到，<code>ReflectiveChannelFactory#newChannel()</code> 方法中使用了反射调用 Channel 的无参构造方法来创建 Channel，我们只要知道，ChannelFactory 的 newChannel() 方法什么时候会被调用就可以了。</p>
<ul>
<li>对于 NioSocketChannel，由于它充当客户端的功能，它的创建时机在 <code>connect(…)</code> 的时候；</li>
<li>对于 NioServerSocketChannel 来说，它充当服务端功能，它的创建时机在绑定端口 <code>bind(…)</code> 的时候。</li>
</ul>
<p>接下来，我们来简单追踪下充当客户端的 Bootstrap 中 NioSocketChannel 的创建过程，看看 NioSocketChannel 是怎么和 JDK 中的 SocketChannel 关联在一起的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bootstrap</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">connect</span><span class="params">(String inetHost, <span class="type">int</span> inetPort)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> connect(InetSocketAddress.createUnresolved(inetHost, inetPort));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再往里看，到这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">connect</span><span class="params">(SocketAddress remoteAddress)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (remoteAddress == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;remoteAddress&quot;</span>);</span><br><span class="line">    <span class="comment">// validate 只是校验一下各个参数是不是正确设置了</span></span><br><span class="line">    validate();</span><br><span class="line">    <span class="keyword">return</span> doResolveAndConnect(remoteAddress, config.localAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 再往里就到这里了</span></span><br><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">doResolveAndConnect</span><span class="params">(<span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class="line">    <span class="comment">// 我们要说的部分在这里</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> regFuture.channel();</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们看 <code>initAndRegister()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 前面我们说过，这里会进行 Channel 的实例化</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们找到了 <code>channel = channelFactory.newChannel()</code> 这行代码，根据前面说的，这里会调用相应 Channel 的无参构造方法。</p>
<p>然后我们就可以去看 NioSocketChannel 的构造方法了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioSocketChannel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// SelectorProvider 实例用于创建 JDK 的 SocketChannel 实例</span></span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_SELECTOR_PROVIDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioSocketChannel</span><span class="params">(SelectorProvider provider)</span> &#123;</span><br><span class="line">    <span class="comment">// 看这里，newSocket(provider) 方法会创建 JDK 的 SocketChannel</span></span><br><span class="line">    <span class="built_in">this</span>(newSocket(provider));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在调用 newSocket(provider) 的时候，会创建 JDK NIO 的一个 SocketChannel 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SocketChannel <span class="title function_">newSocket</span><span class="params">(SelectorProvider provider)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 SocketChannel 实例</span></span><br><span class="line">        <span class="keyword">return</span> provider.openSocketChannel();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ChannelException</span>(<span class="string">&quot;Failed to open a socket.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NioServerSocketChannel 同理，也非常简单，从 <code>ServerBootstrap#bind(...)</code> 方法一路点进去就清楚了。</p>
<p>所以我们知道了，NioSocketChannel 在实例化过程中，会先实例化 JDK 底层的 SocketChannel，NioServerSocketChannel 也一样，会先实例化 ServerSocketChannel 实例：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/18.png" alt="18"></p>
<p>说到这里，我们顺便再继续往里看一下 NioSocketChannel 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioSocketChannel</span><span class="params">(SelectorProvider provider)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(newSocket(provider));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚才我们看到这里，newSocket(provider) 创建了底层的 SocketChannel 实例，我们继续往下看构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioSocketChannel</span><span class="params">(Channel parent, SocketChannel socket)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent, socket);</span><br><span class="line">    config = <span class="keyword">new</span> <span class="title class_">NioSocketChannelConfig</span>(<span class="built_in">this</span>, socket.socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面有两行代码，第二行代码很简单，实例化了内部的 NioSocketChannelConfig 实例，它用于保存 channel 的配置信息，这里没有我们现在需要关心的内容，直接跳过。</p>
<p>第一行调用父类构造器，除了设置属性外，还设置了 SocketChannel 的非阻塞模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractNioByteChannel</span><span class="params">(Channel parent, SelectableChannel ch)</span> &#123;</span><br><span class="line">    <span class="comment">// 毫无疑问，客户端关心的是 OP_READ 事件，等待读取服务端返回数据</span></span><br><span class="line">    <span class="built_in">super</span>(parent, ch, SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后是到这里</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="type">int</span> readInterestOp)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">    <span class="built_in">this</span>.ch = ch;</span><br><span class="line">    <span class="comment">// 我们看到这里只是保存了 SelectionKey.OP_READ 这个信息，在后面的时候会用到</span></span><br><span class="line">    <span class="built_in">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ******设置 channel 的非阻塞模式******</span></span><br><span class="line">        ch.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NioServerSocketChannel 的构造方法类似，也设置了非阻塞，然后设置服务端关心的 SelectionKey.OP_ACCEPT 事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> &#123;</span><br><span class="line">    <span class="comment">// 对于服务端来说，关心的是 SelectionKey.OP_ACCEPT 事件，等待客户端连接</span></span><br><span class="line">    <span class="built_in">super</span>(<span class="literal">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    config = <span class="keyword">new</span> <span class="title class_">NioServerSocketChannelConfig</span>(<span class="built_in">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这节关于 Channel 的内容我们先介绍这么多，主要就是实例化了 JDK 层的 SocketChannel 或 ServerSocketChannel，然后设置了非阻塞模式，我们后面再继续深入下去。</p>
<h2 id="Netty-中的-Future、Promise"><a href="#Netty-中的-Future、Promise" class="headerlink" title="Netty 中的 Future、Promise"></a>Netty 中的 Future、Promise</h2><p>Netty 中非常多的异步调用，所以在介绍更多 NIO 相关的内容之前，我们来看看它的异步接口是怎么使用的。</p>
<p>前面我们在介绍 Echo 例子的时候，已经用过了 ChannelFuture 这个接口了：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/6.png" alt="6"></p>
<p>争取在看完本节后，读者能搞清楚上面的这几行划线部分是怎么走的。</p>
<p>关于 Future 接口，我想大家应该都很熟悉，用得最多的就是在使用 Java 的线程池 ThreadPoolExecutor 的时候了。在 <strong>submit</strong> 一个任务到线程池中的时候，返回的就是一个 <strong>Future</strong> 实例，通过它来获取提交的任务的执行状态和最终的执行结果，我们最常用它的 <code>isDone()</code> 和 <code>get()</code> 方法。</p>
<p>下面是 JDK  中的 Future 接口 java.util.concurrent.Future：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">	<span class="comment">// 取消该任务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="comment">// 任务是否已取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">// 任务是否已完成</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 阻塞获取任务执行结果</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    <span class="comment">// 带超时参数的获取任务执行结果</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Netty 中的 Future 接口（同名）继承了 JDK 中的 Future 接口，然后添加了一些方法：</p>
<p>// io.netty.util.concurrent.Future</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">java</span>.util.concurrent.Future&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSuccess</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 是否可取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancellable</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果任务执行失败，这个方法返回异常信息</span></span><br><span class="line">    Throwable <span class="title function_">cause</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 Listener 来进行回调</span></span><br><span class="line">    Future&lt;V&gt; <span class="title function_">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt; listener)</span>;</span><br><span class="line">    Future&lt;V&gt; <span class="title function_">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt;... listeners)</span>;</span><br><span class="line"></span><br><span class="line">    Future&lt;V&gt; <span class="title function_">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt; listener)</span>;</span><br><span class="line">    Future&lt;V&gt; <span class="title function_">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt;... listeners)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待任务结束，如果任务失败，将“导致失败的异常”重新抛出来</span></span><br><span class="line">    Future&lt;V&gt; <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="comment">// 不响应中断的 sync()，这个大家应该都很熟了</span></span><br><span class="line">    Future&lt;V&gt; <span class="title function_">syncUninterruptibly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待任务结束，和 sync() 功能是一样的，不过如果任务失败，它不会抛出执行过程中的异常</span></span><br><span class="line">    Future&lt;V&gt; <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    Future&lt;V&gt; <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeoutMillis)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitUninterruptibly</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitUninterruptibly</span><span class="params">(<span class="type">long</span> timeoutMillis)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取执行结果，不阻塞。我们都知道 java.util.concurrent.Future 中的 get() 是阻塞的</span></span><br><span class="line">    V <span class="title function_">getNow</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消任务执行，如果取消成功，任务会因为 CancellationException 异常而导致失败</span></span><br><span class="line">    <span class="comment">//	  也就是 isSuccess()==false，同时上面的 cause() 方法返回 CancellationException 的实例。</span></span><br><span class="line">    <span class="comment">// mayInterruptIfRunning 说的是：是否对正在执行该任务的线程进行中断(这样才能停止该任务的执行)，</span></span><br><span class="line">    <span class="comment">// 	  似乎 Netty 中 Future 接口的各个实现类，都没有使用这个参数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完上面的 Netty 的 Future 接口，我们可以发现，它加了 sync() 和 await() 用于阻塞等待，还加了 Listeners，只要任务结束去回调 Listener 们就可以了，那么我们就不一定要主动调用 isDone() 来获取状态，或通过 get() 阻塞方法来获取值。</p>
<blockquote>
<p>所以它其实有两种使用范式</p>
</blockquote>
<p>顺便说下 sync() 和 await() 的区别：sync() 内部会先调用 await() 方法，等 await() 方法返回后，会检查下<strong>这个任务是否失败</strong>，如果失败，重新将导致失败的异常抛出来。也就是说，如果使用 await()，任务抛出异常后，await() 方法会返回，但是不会抛出异常，而 sync() 方法返回的同时会抛出异常。</p>
<blockquote>
<p>我们也可以看到，Future 接口没有和 IO 操作关联在一起，还是比较<em>纯净</em>的接口。</p>
</blockquote>
<p>接下来，我们来看 Future 接口的子接口 ChannelFuture，这个接口用得最多，它将和 IO 操作中的 Channel 关联在一起了，用于异步处理 Channel 中的事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChannelFuture</span> <span class="keyword">extends</span> <span class="title class_">Future</span>&lt;Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ChannelFuture 关联的 Channel</span></span><br><span class="line">    Channel <span class="title function_">channel</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆写以下几个方法，使得它们返回值为 ChannelFuture 类型 </span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt; listener)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt;... listeners)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt; listener)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt;... listeners)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">syncUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来标记该 future 是 void 的，</span></span><br><span class="line">    <span class="comment">// 这样就不允许使用 addListener(...), sync(), await() 以及它们的几个重载方法</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isVoid</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，ChannelFuture 接口相对于 Future 接口，除了将 channel 关联进来，没有增加什么东西。还有个 isVoid() 方法算是不那么重要的存在吧。其他几个都是方法覆写，为了让返回值类型变为 ChannelFuture，而不是原来的 Future。</p>
<p>这里有点跳，我们来介绍下 Promise 接口，它和 ChannelFuture 接口无关，而是和前面的 Future 接口相关，Promise 这个接口非常重要。</p>
<p>Promise 接口和 ChannelFuture 一样，也继承了 Netty 的 Future 接口，然后加了一些 Promise 的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Promise</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记该 future 成功及设置其执行结果，并且会通知所有的 listeners。</span></span><br><span class="line">    <span class="comment">// 如果该操作失败，将抛出异常(失败指的是该 future 已经有了结果了，成功的结果，或者失败的结果)</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">setSuccess</span><span class="params">(V result)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和 setSuccess 方法一样，只不过如果失败，它不抛异常，返回 false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">trySuccess</span><span class="params">(V result)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记该 future 失败，及其失败原因。</span></span><br><span class="line">    <span class="comment">// 如果失败，将抛出异常(失败指的是已经有了结果了)</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">setFailure</span><span class="params">(Throwable cause)</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 标记该 future 失败，及其失败原因。</span></span><br><span class="line">    <span class="comment">// 如果已经有结果，返回 false，不抛出异常</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryFailure</span><span class="params">(Throwable cause)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记该 future 不可以被取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">setUncancellable</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里和 ChannelFuture 一样，对这几个方法进行覆写，目的是为了返回 Promise 类型的实例</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt; listener)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt;... listeners)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt; listener)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt;... listeners)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">syncUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能有些读者对 Promise 的概念不是很熟悉，这里简单说两句。</p>
<p>我觉得只要明白一点，Promise 实例内部是一个任务，任务的执行往往是异步的，通常是一个线程池来处理任务。Promise 提供的 setSuccess(V result) 或 setFailure(Throwable t) 将来会被某个执行任务的线程在执行完成以后调用，同时那个线程在调用 setSuccess(result) 或 setFailure(t) 后会回调 listeners 的回调函数（当然，回调的具体内容不一定要由执行任务的线程自己来执行，它可以创建新的线程来执行，也可以将回调任务提交到某个线程池来执行）。而且，一旦 setSuccess(…) 或 setFailure(…) 后，那些 await() 或 sync() 的线程就会从等待中返回。</p>
<p><strong>所以这里就有两种编程方式，一种是用 await()，等 await() 方法返回后，得到 promise 的执行结果，然后处理它；另一种就是提供 Listener 实例，我们不太关心任务什么时候会执行完，只要它执行完了以后会去执行 listener 中的处理方法就行。</strong></p>
<p>接下来，我们再来看下 <strong>ChannelPromise</strong>，它继承了前面介绍的 ChannelFuture 和 Promise 接口。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/4.png" alt="4"></p>
<p>ChannelPromise 接口在 Netty 中使用得比较多，因为它综合了 ChannelFuture 和 Promise 两个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Special &#123;<span class="doctag">@link</span> ChannelFuture&#125; which is writable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChannelPromise</span> <span class="keyword">extends</span> <span class="title class_">ChannelFuture</span>, Promise&lt;Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆写 ChannelFuture 中的 channel() 方法，其实这个方法一点没变</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Channel <span class="title function_">channel</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面几个方法是覆写 Promise 中的接口，为了返回值类型是 ChannelPromise</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">setSuccess</span><span class="params">(Void result)</span>;</span><br><span class="line">    ChannelPromise <span class="title function_">setSuccess</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">trySuccess</span><span class="params">()</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">setFailure</span><span class="params">(Throwable cause)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里大家应该都熟悉了，下面几个方法的覆写也是为了得到 ChannelPromise 类型的实例</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt; listener)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt;... listeners)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt; listener)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt;... listeners)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">syncUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a new &#123;<span class="doctag">@link</span> ChannelPromise&#125; if &#123;<span class="doctag">@link</span> #isVoid()&#125; returns &#123;<span class="doctag">@code</span> true&#125; otherwise itself.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 我们忽略这个方法吧。</span></span><br><span class="line">    ChannelPromise <span class="title function_">unvoid</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，它综合了 ChannelFuture 和 Promise 中的方法，只不过通过覆写将返回值都变为 ChannelPromise 了而已，<strong>没有增加什么新的功能</strong>。</p>
<p>小结一下，我们上面介绍了几个接口，Future 以及它的子接口 ChannelFuture 和 Promise，然后是 ChannelPromise 接口同时继承了 ChannelFuture 和 Promise。</p>
<p>我把这几个接口的主要方法列在一起，这样大家看得清晰些：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/7.png" alt="4"></p>
<p>接下来，我们需要来一个实现类，这样才能比较直观地看出它们是怎么使用的，因为上面的这些都是接口定义，具体还得看实现类是怎么工作的。</p>
<p>下面，我们来介绍下 <strong>DefaultPromise</strong> 这个实现类，这个类很常用，它的源码也不短，我们先介绍几个关键的内容，然后介绍一个示例使用。</p>
<p>首先，我们看下它有哪些属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultPromise</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractFuture</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">Promise</span>&lt;V&gt; &#123;</span><br><span class="line">	  <span class="comment">// 保存执行结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Object result;</span><br><span class="line">    <span class="comment">// 执行任务的线程池，promise 持有 executor 的引用，这个其实有点奇怪了</span></span><br><span class="line">    <span class="comment">// 因为“任务”其实没必要知道自己在哪里被执行的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor executor;</span><br><span class="line">	  <span class="comment">// 监听者，回调函数，任务结束后（正常或异常结束）执行</span></span><br><span class="line">    <span class="keyword">private</span> Object listeners;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待这个 promise 的线程数(调用sync()/await()进行等待的线程数量)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">short</span> waiters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否正在唤醒等待线程，用于防止重复执行唤醒，不然会重复执行 listeners 的回调方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> notifyingListeners;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看出，此类实现了 Promise，但是没有实现 ChannelFuture，所以它和 Channel 联系不起来。</p>
<p>别急，我们后面会碰到另一个类 DefaultChannelPromise 的使用，这个类是综合了 ChannelFuture 和 Promise 的，但是它的实现其实大部分都是继承自这里的 DefaultPromise 类的。</p>
</blockquote>
<p>说完上面的属性以后，大家可以看下 <code>setSuccess(V result)</code> 、<code>trySuccess(V result)</code> 和 <code>setFailure(Throwable cause)</code> 、 <code>tryFailure(Throwable cause)</code> 这几个方法：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/8.png" alt="8"></p>
<blockquote>
<p>看出 setSuccess(result) 和 trySuccess(result) 的区别了吗？</p>
</blockquote>
<p>上面几个方法都非常简单，先设置好值，然后执行监听者们的回调方法。notifyListeners() 方法感兴趣的读者也可以看一看，不过它还涉及到 Netty 线程池的一些内容，我们还没有介绍到线程池，这里就不展开了。上面的代码，在 setSuccess0 或 setFailure0 方法中都会唤醒阻塞在 sync() 或 await() 的线程</p>
<p>另外，就是可以看下 sync() 和 await() 的区别，其他的我觉得随便看看就好了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    await();</span><br><span class="line">    <span class="comment">// 如果任务是失败的，重新抛出相应的异常</span></span><br><span class="line">    rethrowIfFailed();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们来写个实例代码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造线程池</span></span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventExecutor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 DefaultPromise 实例</span></span><br><span class="line">    <span class="type">Promise</span> <span class="variable">promise</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>(executor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面给这个 promise 添加两个 listener</span></span><br><span class="line">    promise.addListener(<span class="keyword">new</span> <span class="title class_">GenericFutureListener</span>&lt;Future&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务结束，结果：&quot;</span> + future.get());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务失败，异常：&quot;</span> + future.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).addListener(<span class="keyword">new</span> <span class="title class_">GenericFutureListener</span>&lt;Future&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务结束，balabala...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务到线程池，五秒后执行结束，设置执行 promise 的结果</span></span><br><span class="line">    executor.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置 promise 的结果</span></span><br><span class="line">            <span class="comment">// promise.setFailure(new RuntimeException());</span></span><br><span class="line">            promise.setSuccess(<span class="number">123456</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main 线程阻塞等待执行结果</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        promise.sync();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码，两个 listener 将在 5 秒后将输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">任务结束，结果：123456</span><br><span class="line">任务结束，balabala...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>读者这里可以试一下 sync() 和 await() 的区别，在任务中调用 promise.setFailure(new RuntimeException()) 试试看。</p>
</blockquote>
<p>上面的代码中，大家可能会对线程池 executor 和 promise 之间的关系感到有点迷惑。读者应该也要清楚，具体的任务不一定就要在这个 executor 中被执行。任务结束以后，需要调用 promise.setSuccess(result) 作为通知。</p>
<p>通常来说，promise 代表的 future 是不需要和线程池搅在一起的，future 只关心任务是否结束以及任务的执行结果，至于是哪个线程或哪个线程池执行的任务，future 其实是不关心的。</p>
<p>不过 Netty 毕竟不是要创建一个通用的线程池实现，而是和它要处理的 IO 息息相关的，所以我们只不过要理解它就好了。</p>
<p>这节就说这么多吧，我们回过头来再看一下这张图，看看大家是不是看懂了这节内容：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/6.png" alt="6"></p>
<p>我们就说说上图左边的部分吧，虽然我们还不知道 bind() 操作中具体会做什么工作，但是我们应该可以猜出一二。</p>
<p>显然，main 线程调用 b.bind(port) 这个方法会返回一个 ChannelFuture，bind() 是一个异步方法，当某个执行线程执行了真正的绑定操作后，那个执行线程一定会标记这个 future 为成功（我们假定 bind 会成功），然后这里的 sync() 方法（main 线程）就会返回了。</p>
<blockquote>
<p>如果 bind(port) 失败，我们知道，sync() 方法会将异常抛出来，然后就会执行到 finally 块了。 </p>
</blockquote>
<p>一旦绑定端口 bind 成功，进入下面一行，f.channel() 方法会返回该 future 关联的 channel。</p>
<p>channel.closeFuture() 也会返回一个 ChannelFuture，然后调用了 sync() 方法，这个 sync() 方法返回的条件是：<strong>有其他的线程关闭了 NioServerSocketChannel</strong>，往往是因为需要停掉服务了，然后那个线程会设置 future 的状态（ setSuccess(result) 或 setFailure(cause) ），这个 sync() 方法才会返回。</p>
<p>这节就到这里，希望大家对 Netty 中的异步编程有些了解，后续碰到源码的时候能知道是怎么使用的了。</p>
<h2 id="ChannelPipeline，和-Inbound、Outbound"><a href="#ChannelPipeline，和-Inbound、Outbound" class="headerlink" title="ChannelPipeline，和 Inbound、Outbound"></a>ChannelPipeline，和 Inbound、Outbound</h2><p>我想很多读者应该或多或少都有 Netty 中 pipeline 的概念。前面我们说了，使用 Netty 的时候，我们通常就只要写一些自定义的 handler 就可以了，我们定义的这些 handler 会组成一个 pipeline，用于处理 IO 事件，这个和我们平时接触的 Filter 或 Interceptor 表达的差不多是一个意思。</p>
<p>每个 Channel 内部都有一个 pipeline，pipeline 由多个 handler 组成，handler 之间的顺序是很重要的，因为 IO 事件将按照顺序顺次经过 pipeline 上的 handler，这样每个 handler 可以专注于做一点点小事，由多个 handler 组合来完成一些复杂的逻辑。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/11.png" alt="11"></p>
<p>从图中，我们知道这是一个双向链表。</p>
<p>首先，我们看两个重要的概念：<strong>Inbound</strong> 和 <strong>Outbound</strong>。在 Netty 中，IO 事件被分为 Inbound 事件和 Outbound 事件。</p>
<p><strong>Outbound</strong> 的 <strong>out</strong> 指的是 <strong>出去</strong>，有哪些 IO 事件属于此类呢？比如 connect、write、flush 这些 IO 操作是往外部方向进行的，它们就属于 Outbound 事件。</p>
<p>其他的，诸如 accept、read 这种就属于 Inbound 事件。</p>
<blockquote>
<p>比如客户端在发起请求的时候，需要 1️⃣connect 到服务器，然后 2️⃣write 数据传到服务器，再然后 3️⃣read 服务器返回的数据，前面的 connect 和 write 就是 <strong>out</strong> 事件，后面的 read 就是 <strong>in</strong> 事件。</p>
</blockquote>
<p>比如很多初学者看不懂下面的这段代码，这段代码用于服务端的 childHandler 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line"><span class="number">2.</span> pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line"><span class="number">3.</span> pipeline.addLast(<span class="keyword">new</span> <span class="title class_">BizHandler</span>());</span><br></pre></td></tr></table></figure>

<p>初学者肯定都纳闷，以为这个顺序写错了，应该是先 decode 客户端过来的数据，然后用 BizHandler 处理业务逻辑，最后再 encode 数据然后返回给客户端，所以添加的顺序应该是 <strong>1 -&gt; 3 -&gt; 2</strong> 才对。</p>
<p>其实这里的三个 handler 是分组的，分为 Inbound（1 和 3） 和 Outbound（2）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line"><span class="number">2.</span> pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line"><span class="number">3.</span> pipeline.addLast(<span class="keyword">new</span> <span class="title class_">BizHandler</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端连接进来的时候，读取（read）客户端请求数据的操作是 Inbound 的，所以会先使用 1，然后是 3 对处理进行处理；</li>
<li>处理完数据后，返回给客户端数据的 write 操作是 Outbound 的，此时使用的是 2。</li>
</ul>
<p>所以虽然添加顺序有点怪，但是执行顺序其实是按照 1 -&gt; 3 -&gt; 2 进行的。</p>
<blockquote>
<p>如果我们在上面的基础上，加上下面的第四行，这是一个 OutboundHandler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.</span> pipeline.addLast(<span class="keyword">new</span> <span class="title class_">OutboundHandlerA</span>());</span><br></pre></td></tr></table></figure>

<p>那么执行顺序是不是就是 1 -&gt; 3 -&gt; 2 -&gt; 4 呢？答案是：不是的。</p>
<p>对于 Inbound 操作，按照添加顺序执行每个 Inbound 类型的 handler；而对于 Outbound 操作，是反着来的，从后往前，顺次执行 Outbound 类型的 handler。</p>
<p>所以，上面的顺序应该是先 1 后 3，它们是 Inbound 的，然后是 4，最后才是 2，它们两个是 Outbound 的。说实话，我真不喜欢这种组织方式。</p>
</blockquote>
<p>到这里，我想大家应该都知道 Inbound 和 Outbound 了吧？下面我们来介绍它们的接口使用。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/9.png" alt="9"></p>
<p>定义处理 Inbound 事件的 handler 需要实现 ChannelInboundHandler，定义处理 Outbound 事件的 handler 需要实现 ChannelOutboundHandler。最下面的三个类，是 Netty 提供的适配器，特别的，如果我们希望定义一个 handler 能同时处理 Inbound 和 Outbound 事件，可以通过继承中间的 <strong>ChannelDuplexHandler</strong> 的方式，比如 <strong>LoggingHandler</strong> 这种既可以用来处理 Inbound 也可以用来处理 Outbound 事件的 handler。</p>
<p>有了 Inbound 和 Outbound 的概念以后，我们来开始介绍 Pipeline 的源码。</p>
<p>我们说过，一个 Channel 关联一个 pipeline，NioSocketChannel 和 NioServerSocketChannel 在执行构造方法的时候，都会走到它们的父类 AbstractChannel 的构造方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractChannel</span><span class="params">(Channel parent)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    <span class="comment">// 给每个 channel 分配一个唯一 id</span></span><br><span class="line">    id = newId();</span><br><span class="line">    <span class="comment">// 每个 channel 内部需要一个 Unsafe 的实例</span></span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    <span class="comment">// 每个 channel 内部都会创建一个 pipeline</span></span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的三行代码中，id 比较不重要，Netty 中的 Unsafe 实例其实挺重要的，这里简单介绍一下。</p>
<p>在 JDK 的源码中，sun.misc.Unsafe 类提供了一些底层操作的能力，它设计出来是给 JDK 中的源码使用的，比如 AQS、ConcurrentHashMap 等，我们在之前的并发包的源码分析中也看到了很多它们使用 Unsafe 的场景，这个 Unsafe 类不是给我们的代码使用的，是给 JDK 源码使用的（需要的话，我们也是可以获取它的实例的）。</p>
<blockquote>
<p>Unsafe 类的构造方法是 private 的，但是它提供了 getUnsafe() 这个静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br></pre></td></tr></table></figure>
<p>大家可以试一下，上面这行代码编译没有问题，但是执行的时候会抛 <code>java.lang.SecurityException</code> 异常，因为它就不是给我们的代码用的。</p>
<p>但是如果你就是想获取 Unsafe 的实例，可以通过下面这个代码获取到:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) f.get(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Netty 中的 Unsafe 也是同样的意思，它封装了 Netty 中会使用到的 JDK 提供的 NIO 接口，比如将 channel 注册到 selector 上，比如 bind 操作，比如 connect 操作等，<strong>这些操作都是稍微偏底层一些</strong>。Netty 同样也是不希望我们的业务代码使用 Unsafe 的实例，它是提供给 Netty 中的源码使用的。</p>
<blockquote>
<p>不过，对于我们源码分析来说，我们还是会有很多时候需要分析 Unsafe 中的源码的</p>
</blockquote>
<p>关于 Unsafe，我们后面用到了再说，这里只要知道，它封装了大部分需要访问 JDK 的 NIO 接口的操作就好了。这里我们继续将焦点放在实例化 pipeline 上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title function_">newChannelPipeline</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelPipeline</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里开始调用 DefaultChannelPipeline 的构造方法，并把当前 channel 的引用传入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">    succeededFuture = <span class="keyword">new</span> <span class="title class_">SucceededChannelFuture</span>(channel, <span class="literal">null</span>);</span><br><span class="line">    voidPromise =  <span class="keyword">new</span> <span class="title class_">VoidChannelPromise</span>(channel, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    tail = <span class="keyword">new</span> <span class="title class_">TailContext</span>(<span class="built_in">this</span>);</span><br><span class="line">    head = <span class="keyword">new</span> <span class="title class_">HeadContext</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里实例化了 tail 和 head 这两个 handler。tail 实现了 ChannelInboundHandler 接口，而 head 实现了 ChannelOutboundHandler 和 ChannelInboundHandler 两个接口，并且最后两行代码将 tail 和 head 连接起来:</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/12.png" alt="12"></p>
<blockquote>
<p>注意，在不同的版本中，源码也略有差异，head 不一定是 in + out，大家知道这点就好了。</p>
<p>还有，从上面的 head 和 tail 我们也可以看到，其实 pipeline 中的每个元素是 <strong>ChannelHandlerContext</strong> 的实例，而不是 ChannelHandler 的实例，context 包装了一下 handler，但是，后面我们都会用 handler 来描述一个 pipeline 上的节点，而不是使用 context，希望读者知道这一点。</p>
</blockquote>
<p>这里只是构造了 pipeline，并且添加了两个固定的 handler 到其中（head + tail），还不涉及到自定义的 handler 代码执行。我们回过头来看下面这段代码：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/13.png" alt="13"></p>
<blockquote>
<p>我们说过 childHandler 中指定的 handler 不是给 NioServerSocketChannel 使用的，是给 NioSocketChannel 使用的，所以这里我们不看它。</p>
</blockquote>
<p>这里调用 handler(…) 方法指定了一个 LoggingHandler 的实例，然后我们再进去下面的 bind(…) 方法中看看这个 LoggingHandler 实例是怎么进入到我们之前构造的 pipeline 内的。</p>
<p>顺着 bind() 一直往前走，bind() -&gt; doBind() -&gt; initAndRegister()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 构造 channel 实例，同时会构造 pipeline 实例，</span></span><br><span class="line">        <span class="comment">// 现在 pipeline 中有 head 和 tail 两个 handler 了</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        <span class="comment">// 2. 看这里</span></span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的两行代码，第一行实现了构造 channel 和 channel 内部的 pipeline，我们来看第二行 init 代码：</p>
<p>// ServerBootstrap：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 拿到刚刚创建的 channel 内部的 pipeline 实例</span></span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> channel.pipeline();</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 开始往 pipeline 中添加一个 handler，这个 handler 是 ChannelInitializer 的实例</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们以后会看到，下面这个 initChannel 方法何时会被调用</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">            <span class="comment">// 这个方法返回我们最开始指定的 LoggingHandler 实例</span></span><br><span class="line">            <span class="type">ChannelHandler</span> <span class="variable">handler</span> <span class="operator">=</span> config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 添加 LoggingHandler</span></span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先不用管这里的 eventLoop</span></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 添加一个 handler 到 pipeline 中：ServerBootstrapAcceptor</span></span><br><span class="line">                    <span class="comment">// 从名字可以看到，这个 handler 的目的是用于接收客户端请求</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ServerBootstrapAcceptor</span>(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及到 pipeline 中的辅助类 ChannelInitializer，我们看到，它本身是一个 handler（Inbound 类型），但是它的作用和普通 handler 有点不一样，它纯碎是用来辅助将其他的 handler 加入到 pipeline 中的。</p>
<p>大家可以稍微看一下 ChannelInitializer 的 initChannel 方法，有个简单的认识就好，此时的 pipeline 应该是这样的：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/14.png" alt="14"></p>
<p>ChannelInitializer 的 initChannel(channel) 方法被调用的时候，会往 pipeline 中添加我们最开始指定的 <strong>LoggingHandler</strong> 和添加一个 <strong>ServerBootstrapAcceptor</strong>。但是我们现在还不知道这个 initChannel 方法何时会被调用。</p>
<p>上面我们说的是作为服务端的 NioServerSocketChannel 的 pipeline，NioSocketChannel 也是差不多的，我们可以看一下 Bootstrap 类的 init(channel) 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> channel.pipeline();</span><br><span class="line">    p.addLast(config.handler());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/23.png" alt="23"></p>
<p>它和服务端 ServerBootstrap 要添加 ServerBootstrapAcceptor 不一样，它只需要将 EchoClient 类中的 ChannelInitializer 实例加进来就可以了，它的 ChannelInitializer 中添加了两个 handler，LoggingHandler 和 EchoClientHandler：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/16.png" alt="16"></p>
<p>很显然，我们需要的是像 LoggingHandler 和 EchoClientHandler 这样的 handler，但是，它们现在还不在 pipeline 中，那么它们什么时候会真正进入到 pipeline 中呢？以后我们再揭晓。</p>
<p>还有，为什么 Server 端我们指定的是一个 handler 实例，而 Client 指定的是一个 ChannelInitializer 实例？其实它们是可以随意搭配使用的，你甚至可以在 ChannelInitializer 实例中添加 ChannelInitializer 的实例。</p>
<p>非常抱歉，这里又要断了，下面要先介绍线程池了，大家要记住 pipeline 现在的样子，<strong>head + channelInitializer + tail</strong>。</p>
<p>本节没有介绍 handler 的向后传播，就是一个 handler 处理完了以后，怎么传递给下一个 handler 来处理？比如我们熟悉的 JavaEE 中的 Filter 是采用在一个 Filter 实例中调用 chain.doFilter(request, response) 来传递给下一个 Filter 这种方式的。</p>
<p>我们用下面这张图结束本节。下图展示了传播的方法，但我其实是更想让大家看一下，哪些事件是 Inbound 类型的，哪些是 Outbound 类型的：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/19.png" alt="19"></p>
<p>Outbound 类型的几个事件大家应该比较好认，注意 bind 也是 Outbound 类型的。</p>
<h2 id="Netty-中的线程池-EventLoopGroup"><a href="#Netty-中的线程池-EventLoopGroup" class="headerlink" title="Netty 中的线程池 EventLoopGroup"></a>Netty 中的线程池 EventLoopGroup</h2><p>接下来，我们来分析 Netty 中的线程池。Netty 中的线程池比较不好理解，因为它的类比较多，而且它们之间的关系错综复杂。看下图，感受下 NioEventLoop 类和 NioEventLoopGroup 类的继承结构：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/2.png" alt="2"></p>
<p>这张图我按照继承关系整理而来，大家仔细看一下就会发现，涉及到的类确实挺多的。本节来给大家理理清楚这部分内容。</p>
<p>首先，我们说的 Netty 的线程池，指的就是 <strong>NioEventLoopGroup</strong> 的实例；线程池中的单个线程，指的是右边 <strong>NioEventLoop</strong> 的实例。</p>
<p>我们第一节介绍的 Echo 例子，客户端和服务端的启动代码中，最开始我们总是先实例化 NioEventLoopGroup：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EchoClient 代码最开始：</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// EchoServer 代码最开始：</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br></pre></td></tr></table></figure>

<p>下面，我们就从 NioEventLoopGroup 的源码开始进行分析。</p>
<p>我们打开 NioEventLoopGroup 的源码，可以看到，NioEventLoopGroup 有多个构造方法用于参数设置，最简单地，我们采用无参构造函数，或仅仅设置线程数量就可以了，其他的参数采用默认值。</p>
<blockquote>
<p>比如上面的代码中，我们只在实例化 bossGroup 的时候指定了参数，代表该线程池需要一个线程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(nThreads, (Executor) <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 参数最全的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor, EventExecutorChooserFactory chooserFactory,</span></span><br><span class="line"><span class="params">                         <span class="keyword">final</span> SelectorProvider selectorProvider,</span></span><br><span class="line"><span class="params">                         <span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory,</span></span><br><span class="line"><span class="params">                         <span class="keyword">final</span> RejectedExecutionHandler rejectedExecutionHandler)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">    <span class="built_in">super</span>(nThreads, executor, chooserFactory, selectorProvider, selectStrategyFactory, rejectedExecutionHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来稍微看一下构造方法中的各个参数：</p>
<ul>
<li>nThreads：这个最简单，就是线程池中的线程数，也就是 NioEventLoop 的实例数量。</li>
<li>executor：我们知道，我们本身就是要构造一个线程池（Executor），为什么这里传一个 executor 实例呢？它其实不是给线程池用的，而是给 NioEventLoop 用的，以后再说。</li>
<li>chooserFactory：当我们提交一个任务到线程池的时候，线程池需要选择（choose）其中的一个线程来执行这个任务，这个就是用来实现选择策略的。</li>
<li>selectorProvider：这个简单，我们需要通过它来实例化 JDK 的 Selector，可以看到每个线程池都持有一个 selectorProvider 实例。</li>
<li>selectStrategyFactory：这个涉及到的是线程池中线程的工作流程，在介绍 NioEventLoop 的时候会说。</li>
<li>rejectedExecutionHandler：这个也是线程池的好朋友了，用于处理线程池中没有可用的线程来执行任务的情况。在 Netty 中稍微有一点点不一样，这个是给 NioEventLoop 实例用的，以后我们再详细介绍。</li>
</ul>
<p>这里介绍这些参数是希望大家有个印象而已，大家发现没有，在构造 NioEventLoopGroup 实例时的好几个参数，都是用来构造 NioEventLoop 用的。</p>
<p>下面，我们从 NioEventLoopGroup 的无参构造方法开始，跟着源码走：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后一步步走下去，到这个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory, <span class="keyword">final</span> SelectorProvider selectorProvider, <span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">super</span>(nThreads, threadFactory, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家自己要去跟一下源码，这样才知道中间设置了哪些默认值，下面这几个参数都被设置了默认值： </p>
<ul>
<li><p>selectorProvider = SelectorProvider.provider()</p>
<blockquote>
<p>这个没什么好说的，调用了 JDK 提供的方法</p>
</blockquote>
</li>
<li><p>selectStrategyFactory = DefaultSelectStrategyFactory.INSTANCE</p>
<blockquote>
<p>这个涉及到的是线程在做 select 操作和执行任务过程中的策略选择问题，在介绍 NioEventLoop 的时候会用到。 </p>
</blockquote>
</li>
<li><p>rejectedExecutionHandler = RejectedExecutionHandlers.reject()</p>
<blockquote>
<p>大家进去看一下 reject() 方法，也就是说，Netty 选择的默认拒绝策略是：抛出异常</p>
</blockquote>
</li>
</ul>
<p>跟着源码走，我们会来到父类 MultithreadEventLoopGroup 的构造方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory, Object... args)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们发现，如果采用无参构造函数，那么到这里的时候，默认地 nThreads 会被设置为 **CPU 核心数 *2**。大家可以看下 DEFAULT_EVENT_LOOP_THREADS 的默认值，以及 static 代码块的设值逻辑。</p>
<p>我们继续往下走：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventExecutorGroup</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory, Object... args)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(nThreads, threadFactory == <span class="literal">null</span> ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">ThreadPerTaskExecutor</span>(threadFactory), args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这一步的时候，<code>new ThreadPerTaskExecutor(threadFactory)</code> 会构造一个 executor。</p>
<blockquote>
<p>我们现在还不知道这个 executor 怎么用。这里我们先看下它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPerTaskExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (threadFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;threadFactory&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">        <span class="comment">// 为每个任务新建一个线程</span></span><br><span class="line">        threadFactory.newThread(command).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Executor 作为线程池的最顶层接口， 我们知道，它只有一个 execute(runnable) 方法，从上面我们可以看到，实现类 ThreadPerTaskExecutor 的逻辑就是<strong>每来一个任务，新建一个线程</strong>。</p>
<p>我们先记住这个，前面也说了，它是给 NioEventLoop 用的，不是给 NioEventLoopGroup 用的。</p>
</blockquote>
<p>上一步设置完了 executor，我们继续往下看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventExecutorGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor, Object... args)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步设置了 chooserFactory，用来实现从线程池中选择一个线程的选择策略。</p>
<blockquote>
<p>ChooserFactory 的逻辑比较简单，我们看下 DefaultEventExecutorChooserFactory 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> EventExecutorChooser <span class="title function_">newChooser</span><span class="params">(EventExecutor[] executors)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPowerOfTwo(executors.length)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PowerOfTwoEventExecutorChooser</span>(executors);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GenericEventExecutorChooser</span>(executors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里设置的策略也很简单：</p>
<p>1、如果线程池的线程数量是 2^n，采用下面的方式会高效一些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> EventExecutor <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、如果不是，用取模的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> EventExecutor <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> executors[Math.abs(idx.getAndIncrement() % executors.length)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>走了这么久，我们终于到了一个<strong>干实事</strong>的构造方法中了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventExecutorGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor,</span></span><br><span class="line"><span class="params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// executor 如果是 null，做一次和前面一样的默认设置。</span></span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="literal">null</span>) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> <span class="title class_">ThreadPerTaskExecutor</span>(newDefaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的 children 数组非常重要，它就是线程池中的线程数组，这么说不太严谨，但是就大概这个意思</span></span><br><span class="line">    children = <span class="keyword">new</span> <span class="title class_">EventExecutor</span>[nThreads];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这个 for 循环将实例化 children 数组中的每一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化！！！！！！</span></span><br><span class="line">            children[i] = newChild(executor, args);</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Think about if this is a good exception type</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;failed to create a child event loop&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果有一个 child 实例化失败，那么 success 就会为 false，然后进入下面的失败处理逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="comment">// 把已经成功实例化的“线程” shutdown，shutdown 是异步操作</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    children[j].shutdownGracefully();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待这些线程成功 shutdown</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    <span class="type">EventExecutor</span> <span class="variable">e</span> <span class="operator">=</span> children[j];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> (!e.isTerminated()) &#123;</span><br><span class="line">                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException interrupted) &#123;</span><br><span class="line">                        <span class="comment">// 把中断状态设置回去，交给关心的线程来处理.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ================================================</span></span><br><span class="line">    <span class="comment">// === 到这里，就是代表上面的实例化所有线程已经成功结束 ===</span></span><br><span class="line">    <span class="comment">// ================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过之前设置的 chooserFactory 来实例化 Chooser，把线程池数组传进去，</span></span><br><span class="line">    <span class="comment">//     这就不必再说了吧，实现线程选择策略</span></span><br><span class="line">    chooser = chooserFactory.newChooser(children);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置一个 Listener 用来监听该线程池的 termination 事件</span></span><br><span class="line">    <span class="comment">// 下面的代码逻辑是：给池中每一个线程都设置这个 listener，当监听到所有线程都 terminate 以后，这个线程池就算真正的 terminate 了。</span></span><br><span class="line">    <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> <span class="title class_">FutureListener</span>&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                terminationFuture.setSuccess(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (EventExecutor e: children) &#123;</span><br><span class="line">        e.terminationFuture().addListener(terminationListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 readonlyChildren，它是只读集合，以后用到再说</span></span><br><span class="line">    Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;EventExecutor&gt;(children.length);</span><br><span class="line">    Collections.addAll(childrenSet, children);</span><br><span class="line">    readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码非常简单吧，没有什么需要特别说的，接下来，我们来看看 newChild() 这个方法，这个方法非常重要，它将创建线程池中的线程。</p>
<blockquote>
<p>我上面已经用过很多次”线程”这个词了，它可不是 Thread 的意思，而是指池中的个体，后面我们会看到每个”线程”在什么时候会真正创建 Thread 实例。反正每个 NioEventLoop 实例内部都会有一个自己的 Thread 实例，所以把这两个概念混在一起也无所谓吧。</p>
</blockquote>
<p><code>newChild(…)</code> 方法在 NioEventLoopGroup 中覆写了，上面说的”线程”其实就是 NioEventLoop：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> EventLoop <span class="title function_">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NioEventLoop</span>(<span class="built_in">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>],</span><br><span class="line">        ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它调用了 NioEventLoop 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;</span><br><span class="line">    <span class="comment">// 调用父类构造器</span></span><br><span class="line">    <span class="built_in">super</span>(parent, executor, <span class="literal">false</span>, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);</span><br><span class="line">    <span class="keyword">if</span> (selectorProvider == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;selectorProvider&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strategy == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;selectStrategy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    provider = selectorProvider;</span><br><span class="line">    <span class="comment">// 开启 NIO 中最重要的组件：Selector</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SelectorTuple</span> <span class="variable">selectorTuple</span> <span class="operator">=</span> openSelector();</span><br><span class="line">    selector = selectorTuple.selector;</span><br><span class="line">    unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">    selectStrategy = strategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先粗略观察一下，然后再往下看：</p>
<ul>
<li>在 Netty 中，NioEventLoopGroup 代表线程池，NioEventLoop 就是其中的线程。</li>
<li>线程池 NioEventLoopGroup 是池中的线程 NioEventLoop 的 <strong>parent</strong>，从上面的代码中的取名可以看出。</li>
<li>每个 NioEventLoop 都有自己的 Selector，上面的代码也反应了这一点，这和 Tomcat 中的 NIO 模型有点区别。</li>
<li>executor、selectStrategy 和 rejectedExecutionHandler 从 NioEventLoopGroup 中一路传到了 NioEventLoop 中。</li>
</ul>
<p>这个时候，我们来看一下 NioEventLoop 类的属性都有哪些，我们先忽略它继承自父类的属性，单单看它自己的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Selector selector;</span><br><span class="line"><span class="keyword">private</span> Selector unwrappedSelector;</span><br><span class="line"><span class="keyword">private</span> SelectedSelectionKeySet selectedKeys;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectorProvider provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">wakenUp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectStrategy selectStrategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">ioRatio</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> cancelledKeys;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> needsToSelectAgain;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结合它的构造方法我们来总结一下：</p>
<ul>
<li>provider：它由 NioEventLoopGroup 传进来，前面我们说了一个线程池有一个 selectorProvider，用于创建 Selector 实例</li>
<li>selector：虽然我们还没看创建 selector 的代码，但我们已经知道，在 Netty 中 Selector 是跟着线程池中的线程走的。也就是说，并非一个线程池一个 Selector 实例，而是线程池中每一个线程都有一个 Selector 实例。</li>
<li>selectStrategy：select 操作的策略，这个不急。</li>
<li>ioRatio：这是 IO 任务的执行时间比例，因为每个线程既有 IO 任务执行，也有非 IO 任务需要执行，所以该参数为了保证有足够时间是给 IO 的。这里也不需要急着去理解什么 IO 任务、什么非 IO 任务。</li>
</ul>
<p>然后我们继续走它的构造方法，我们看到上面的构造方法调用了父类的构造器，它的父类是 SingleThreadEventLoop。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">SingleThreadEventLoop</span><span class="params">(EventLoopGroup parent, Executor executor,</span></span><br><span class="line"><span class="params">                                <span class="type">boolean</span> addTaskWakesUp, <span class="type">int</span> maxPendingTasks,</span></span><br><span class="line"><span class="params">                                RejectedExecutionHandler rejectedExecutionHandler)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent, executor, addTaskWakesUp, maxPendingTasks, rejectedExecutionHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们可以直接忽略这个东西，以后我们也不会再介绍它</span></span><br><span class="line">    tailTasks = newTaskQueue(maxPendingTasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SingleThreadEventLoop 这个名字很诡异有没有？然后它的构造方法又调用了父类 SingleThreadEventExecutor 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">SingleThreadEventExecutor</span><span class="params">(EventExecutorGroup parent, Executor executor,</span></span><br><span class="line"><span class="params">                                    <span class="type">boolean</span> addTaskWakesUp, <span class="type">int</span> maxPendingTasks,</span></span><br><span class="line"><span class="params">                                    RejectedExecutionHandler rejectedHandler)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">    <span class="built_in">this</span>.addTaskWakesUp = addTaskWakesUp;</span><br><span class="line">    <span class="built_in">this</span>.maxPendingTasks = Math.max(<span class="number">16</span>, maxPendingTasks);</span><br><span class="line">    <span class="built_in">this</span>.executor = ObjectUtil.checkNotNull(executor, <span class="string">&quot;executor&quot;</span>);</span><br><span class="line">    <span class="comment">// taskQueue，这个东西很重要，提交给 NioEventLoop 的任务都会进入到这个 taskQueue 中等待被执行</span></span><br><span class="line">    <span class="comment">// 这个 queue 的默认容量是 16</span></span><br><span class="line">    taskQueue = newTaskQueue(<span class="built_in">this</span>.maxPendingTasks);</span><br><span class="line">    rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, <span class="string">&quot;rejectedHandler&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里就更加诡异了，NioEventLoop 的父类是 SingleThreadEventLoop，而 SingleThreadEventLoop 的父类是 <strong>SingleThreadEventExecutor</strong>，它的名字告诉我们，它是一个 Executor，是一个线程池，而且是 Single Thread 单线程的。</p>
<p>也就是说，线程池 NioEventLoopGroup 中的每一个线程 NioEventLoop 也可以当做一个线程池来用，只不过它只有一个线程。这种设计虽然看上去很巧妙，不过有点反人类的样子。</p>
<p>上面这个构造函数比较简单：</p>
<ul>
<li><p>设置了 parent，也就是之前创建的线程池 NioEventLoopGroup 实例</p>
</li>
<li><p>executor：它是我们之前实例化的 ThreadPerTaskExecutor，我们说过，这个东西在线程池中没有用，它是给 NioEventLoop 用的，马上我们就要看到它了。提前透露一下，它用来开启 NioEventLoop 中的线程（Thread 实例）。</p>
</li>
<li><p>taskQueue：这算是该构造方法中新的东西，它是任务队列。我们前面说过，NioEventLoop 需要负责 IO 事件和非 IO 事件，通常它都在执行 selector 的 select 方法或者正在处理 selectedKeys，如果我们要 submit 一个任务给它，任务就会被放到 taskQueue 中，等它来轮询。该队列是线程安全的 LinkedBlockingQueue，默认容量为 16。</p>
</li>
<li><p>rejectedExecutionHandler：taskQueue 的默认容量是 16，所以，如果 submit 的任务堆积了到了 16，再往里面提交任务会触发 rejectedExecutionHandler 的执行策略。</p>
<blockquote>
<p>还记得默认策略吗：抛出RejectedExecutionException 异常。</p>
<p>在 NioEventLoopGroup 的默认构造中，它的实现是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">REJECT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionHandler</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejected</span><span class="params">(Runnable task, SingleThreadEventExecutor executor)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p>然后，我们再回到 NioEventLoop 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;</span><br><span class="line">    <span class="comment">// 我们刚刚说完了这个</span></span><br><span class="line">    <span class="built_in">super</span>(parent, executor, <span class="literal">false</span>, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);</span><br><span class="line">    <span class="keyword">if</span> (selectorProvider == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;selectorProvider&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strategy == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;selectStrategy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    provider = selectorProvider;</span><br><span class="line">    <span class="comment">// 创建 selector 实例</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SelectorTuple</span> <span class="variable">selectorTuple</span> <span class="operator">=</span> openSelector();</span><br><span class="line">    selector = selectorTuple.selector;</span><br><span class="line">    unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">    </span><br><span class="line">    selectStrategy = strategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最重要的方法其实就是 openSelector() 方法，它将创建 NIO 中最重要的一个组件 <strong>Selector</strong>。在这个方法中，Netty 也做了一些优化，这部分我们就不去分析它了。</p>
<p>到这里，我们的线程池 NioEventLoopGroup 创建完成了，并且实例化了池中的所有 NioEventLoop 实例。</p>
<p>同时，大家应该已经看到，上面并没有真正创建 NioEventLoop 中的线程（没有创建 Thread 实例）。</p>
<p>提前透露一下，创建线程的时机在第一个任务提交过来的时候，那么第一个任务是什么呢？是我们马上要说的 channel 的 <strong>register</strong> 操作。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2018/09/12/G1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/09/12/G1/" class="post-title-link" itemprop="url">G1 垃圾收集器介绍(转自Javadoop)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-12 00:00:00" itemprop="dateCreated datePublished" datetime="2018-09-12T00:00:00+08:00">2018-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 23:21:07" itemprop="dateModified" datetime="2025-04-27T23:21:07+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h1><p>之前根据 Sun 的内存管理白皮书介绍了在 HotSpot JVM 分代算法中的几个垃圾收集器，本文将介绍 G1 垃圾收集器。</p>
<p>G1 的主要关注点在于达到<strong>可控的停顿时间</strong>，在这个基础上尽可能提高吞吐量，这一点非常重要。</p>
<p>G1 被设计用来长期取代 CMS 收集器，和 CMS 相同的地方在于，它们都属于并发收集器，在大部分的收集阶段都不需要挂起应用程序。区别在于，G1 没有 CMS 的碎片化问题（或者说不那么严重），同时提供了更加可控的停顿时间。</p>
<p>如果你的应用使用了较大的堆（如 6GB 及以上）而且还要求有较低的垃圾收集停顿时间（如 0.5 秒），那么 G1 是你绝佳的选择，是时候放弃 CMS 了。</p>
<p><strong>阅读建议</strong>：本文力求用简单的话介绍清楚 G1 收集器，但是并不会重复介绍每一个细节，所以希望读者了解其他几个收集器的工作过程，尤其是 CMS 收集器。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/09/12/G1/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default/">1</a><span class="space">&hellip;</span><a class="page-number" href="/default/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/default/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">碎梦</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/scatteredream" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
