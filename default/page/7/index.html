<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Arvo:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scatteredream.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="scatteredream&#39;s blog">
<meta property="og:url" content="http://scatteredream.github.io/default/page/7/index.html">
<meta property="og:site_name" content="scatteredream&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="碎梦">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://scatteredream.github.io/default/page/7/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default/page/7/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>scatteredream's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">scatteredream's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="碎梦"
      src="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
  <p class="site-author-name" itemprop="name">碎梦</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">82</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">126</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/05/01/math-distribute-math-logic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/01/math-distribute-math-logic/" class="post-title-link" itemprop="url">离散数学：数理逻辑、集合论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-05-01T00:00:00+08:00">2024-05-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-08 13:22:44" itemprop="dateModified" datetime="2025-05-08T13:22:44+08:00">2025-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/math/" itemprop="url" rel="index"><span itemprop="name">math</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="distribute"><a href="#distribute" class="headerlink" title="distribute"></a>distribute</h1><h2 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a>（一）</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240526213759080.png" alt="image-20240526213759080"></p>
<p>上面的蕴含等值式和等价等值式 </p>
<p>A-&gt;B</p>
<p>“¬”、“∧”、“∨”</p>
<p>p→q 等价于 ¬p∨q</p>
<p>A↔️B 等价于 (A→B)  ∧（B←A）</p>
<p>德摩根</p>
<p>分配率</p>
<p>归谬论</p>
<p>假言易位 </p>
<p>等值演算法的步骤，分配率化到最后，然后观察</p>
<h6 id="对偶"><a href="#对偶" class="headerlink" title="对偶"></a>对偶</h6><p>并换成交 T换成F</p>
<h6 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h6><p>析取范式 合取范式 </p>
<ul>
<li><p>主析取范式：给定的析取范式，每一个合取式都是极小项，m010 ∨ m011 ∨ m100 </p>
<p>极小项: 每个命题变元都要出现，也就是一直交，交到最小</p>
<p>极小项析取（并），极大项合取（交）</p>
<p>极小项是各个命题变元交得来的。极大项是各个命题变元并来的</p>
</li>
<li><p>主析取范式和主合取范式互补。</p>
</li>
<li><p>如果出现极小项并一个简单Q或者R，扩充成1∧Q∧1 也就是 (P∨¬P)∧Q∧(R∨¬R)</p>
</li>
</ul>
<h6 id="完备集"><a href="#完备集" class="headerlink" title="完备集"></a>完备集</h6><p>只要出现∧或者∨中的任何一个，再加¬，就是完备集</p>
<h5 id="命题逻辑的推理理论"><a href="#命题逻辑的推理理论" class="headerlink" title="命题逻辑的推理理论"></a>命题逻辑的推理理论</h5><p>前提引入和结论 ==附加前提（结论是蕴含）== ==归谬法== </p>
<ul>
<li><p>附加律 ==A       推出     A∨B== </p>
</li>
<li><p>化简律 ==A∧B 推出        A==                </p>
</li>
<li><p>假言推理 ==(A→B)∧A     推出   B==     A真，B一定真</p>
</li>
<li><p>拒取式   ==(A→B) ∧ ¬B   推出 ¬A==    B是假的 A也一定是假的</p>
</li>
<li><p>析取三段论  ==(A∨B)∧¬B  推出 A==    B是假的 A并B真 A肯定真</p>
</li>
<li><p>假言三段论   ==(A→B)∧(B→C) 推出 A→C== 传递</p>
</li>
<li><p>等价三段论  等价的传递性</p>
</li>
<li><p>构造性二难 ==(A→B) ∧ (C→D) ∧ (A∨C) 推出  B∨D== </p>
</li>
<li><p>破坏性二难附加律</p>
</li>
<li><p>1 2 合取</p>
</li>
<li></li>
</ul>
<h6 id="谓词逻辑"><a href="#谓词逻辑" class="headerlink" title="谓词逻辑"></a>谓词逻辑</h6><p>把一句话改写成函数的形式，共同点  </p>
<p>Fx x是素数 F1 1是素数 F2 2是素数</p>
<p>全称量词和存在量词</p>
<p>蕴含               合取（命题符号化的时候）</p>
<p>∀                    ∃</p>
<p>合取               析取（消去量词的时候）</p>
<p>指导变元   辖域：约束出现 自由出现</p>
<p>辖域收缩：跟X没关系的，比如y 直接剥离出去</p>
<ul>
<li><p>量词分配律：</p>
<p>全称量词对合取 存在量词对析取 这样才是等价</p>
<p>否则 全称A ∨ 全称B → 全称A∨B</p>
</li>
</ul>
<p>​         存在A ∧ B   →   存在A∧存在B</p>
<p>​    个体域abc，代表三个实数，如果遇到x，y共同约束，先解决其中一个。此即为谓词公式的置换，能够求出谓词公式的真值</p>
<ul>
<li>前束范式 ：约束全在前面<ul>
<li>改写成前束范式：否定换到后面，多个量词指导变元相同，应该换元。如果之前是自由变元，后来又有了约束，那也一样要换元，以保持前面的自由度</li>
<li>两种情况需要进行换名：<ul>
<li>当辖域不同的重名变量存在时，需要使用不同的名字</li>
<li>当 <strong>约束变元</strong> 和 <strong>自由变元</strong> 命名发生冲突时，最好将 <strong>约束变元</strong> 及其 <strong>指导变元</strong> 进行改名</li>
</ul>
</li>
<li>当进行量词合并或者拆分的时候，一定不要想当然，要根据合并或者拆分的规则和定理进行。</li>
<li>先看量词的辖域，看约束变元和自由变元</li>
</ul>
</li>
</ul>
<p>推理理论<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240528012816323.png" alt="image-20240528012816323"></p>
<p><strong><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240528101406789.png" alt="image-20240528101406789"></strong></p>
<ul>
<li> 全称A∨全称B →        全称 (A∨B)</li>
</ul>
<p>​        存在  (A∧B)    →      存在A∧存在B</p>
<p>​    全称（A→B)   推出   全称A→全称B</p>
<p>​                           存在A→存在B</p>
<p>逆向 附加 归谬;引入错误结论，推出与前提矛盾的点</p>
<p>证明中间把量词去掉，也就是代入，最后再加上量词</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240528013613611.png" alt="image-20240528013613611"></p>
<p>引入量词要注意加上对应规则</p>
<h3 id="集合论"><a href="#集合论" class="headerlink" title="集合论"></a>集合论</h3><p>包含关系：子集包含于某个集合</p>
<p>属于关系：元素属于某个集合</p>
<p>对称差：A并B-A交B</p>
<p>差运算：A-B 属于A不属于B</p>
<p>A的绝对补集 ~A = E-A</p>
<p>有穷集计数：</p>
<p>多个并：奇+偶-  每个加数都是交集</p>
<p>A并B并C  </p>
<p>非A交非B交非C</p>
<p>二者互补</p>
<p>A-B并C  =   A-B 交 A-C</p>
<p>A-B交C  =  A-B  并  A-C </p>
<p>A-B = A交~B</p>
<p>A是B的子集, A-B等于🈳</p>
<p>对称差：交换性 结合性 </p>
<p>A 对称差 🈳 =A </p>
<p>A 对称差 A = 🈳</p>
<p>A和~A的对称差为 E</p>
<p>AB对称差等于AC对称差 推出 B=C</p>
<p>证明集合恒等式 可以额外添加一个A</p>
<h3 id="二元关系"><a href="#二元关系" class="headerlink" title="二元关系"></a>二元关系</h3><p>笛卡尔积，有序对，AB笛卡尔积为mn个元素，不满足交换律和结合律，满足分配率</p>
<p>非空，元素是有序对 为二元关系，空集是个二元关系</p>
<p>AXB <strong>的子集</strong> 叫做 A到B的二元关系 ，特别的AXA为A上的二元关系，所以A的二元关系为 2^n^^2^  个</p>
<p>空关系🈳</p>
<p>全域关系 AXA E<del>A</del> 全集</p>
<p>恒等关系  &lt;x,x&gt;  I<del>A</del>   {&lt;1,1&gt;&lt;2,2&gt;&lt;3,3&gt;}</p>
<p><strong>关系矩阵</strong> 按照数对的顺序填1或0 用M<del>R</del> 表示</p>
<p><strong>关系图</strong> 恒等关系就是环，自己画一个圈，剩下的画有向边</p>
<h3 id="关系运算-domR-ranR-domain-and-range"><a href="#关系运算-domR-ranR-domain-and-range" class="headerlink" title="关系运算 domR ranR domain and range"></a>关系运算 domR ranR domain and range</h3><p>R的定义域和值域的并集 为  域   fldR=domR 并 ranR</p>
<p>domR有序对的第一元素构成的集合</p>
<p>ranR有序对的第二元素构成的集合</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240528151530508.png" alt="image-20240528151530508"></p>
<p>F⭕️G G对F的右复合 F中有3,3和6,2 G中有2,3  那么F⭕️G为 6,3   G⭕️F为2,3</p>
<h3 id="关系性质和闭包"><a href="#关系性质和闭包" class="headerlink" title="关系性质和闭包"></a>关系性质和闭包</h3><p><u>自反，对称，闭包</u></p>
<p>R在A上  <strong>自反</strong>   R，对于A中每个元素都有 11 22 33 的恒等关系          主对角线为1 有环</p>
<p>​        <strong>反自反</strong> R，对于A中每个元素都没有 11 22 33 的恒等关系       主对角线为0  没环</p>
<p><strong>对称</strong>   任两个元素组合都有其 逆关系 有xy必有yx  对称矩阵。如果两点有边，只能是双向</p>
<p><strong>反对称</strong> 任意两个元素的组合都没有其 逆关系             如果两点有边，只能是单向                      </p>
<p>传递：任意              的xy属于R yz属于R 能推出xz属于R 如果x到y y到z 那么x到z肯定有边</p>
<p>先给出全域关系</p>
<p>反对称，关于对称轴对称过去的值相反 1对称过去是0, 0对称过去是1</p>
<p>传递性图解</p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>R是A上的关系，R的xx闭包是A上的关系R’ </p>
<p> <strong>R’⊂R</strong></p>
<p>rst 分别对应自反对称传递闭包</p>
<p>自反闭包：把R补全，然后不要漏掉原来的元素</p>
<h4 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h4><p>R是自反对称且传递的关系</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240528192239902.png" alt="image-20240528192239902"></p>
<p>自反性，代入x.x 得x,x∈T 运用了</p>
<p>传递性，代入xy，</p>
<p>对称性，代入y，x，其实就是反着代了一下，原式子还是不变的</p>
<p>划分：：不能有空集，且各个集合之间不能有交集</p>
<h4 id="偏序关系"><a href="#偏序关系" class="headerlink" title="偏序关系"></a>偏序关系</h4><p>自反 反对称 传递 </p>
<p><strong>树 上 的 小于等于关系</strong> , <strong>集合上的包含关系</strong> , <strong>非 *<em>0 00*</em> 自然数之间的整除关系</strong> , 都是常见的偏序关系 ;</p>
<p>哈斯图</p>
<p>没关系的画在一排上，有关系的画成层次结构</p>
<p>第一部：排点的层数</p>
<p>第二部：把有关系的点连接起来，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240528203053473.png" alt="image-20240528203053473"></p>
<p>在哈斯图中的位置：只有有层次结构的才可以比较，23不可比（最大最小）</p>
<p>​                 极大极小，就是没有最大最小值时候的权宜之计,把不可比的全扔上去</p>
<p>上界：只要有大于等于这些元素就可以</p>
<p>上确界：最小上界    下确界：最大下界 （必须可比）</p>
<p>上下界是针对全体集合来说的，下界</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240528214006655.png" alt="image-20240528214006655"></p>
<p>射： 单射 必须一一对应 dom &lt; ran</p>
<p>​    满射 值域都取到了 dom &gt; ran</p>
<p>​         双射  dom = ran</p>
<p>f AtoB</p>
<p>g BtoC</p>
<p>f⭕️g AtoC</p>
<p>fx⭕️gx = g（fx）本质就是复合运输</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/02/05/jvm-gc-zgc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/05/jvm-gc-zgc/" class="post-title-link" itemprop="url">ZGC 介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-05 00:00:00" itemprop="dateCreated datePublished" datetime="2024-02-05T00:00:00+08:00">2024-02-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-08 13:32:28" itemprop="dateModified" datetime="2025-05-08T13:32:28+08:00">2025-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ZGC 于 2017 由 Oracle 贡献给社区，在 JDK 11 及以上版本的各种 release 中几乎都包含该 GC。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.openjdk.org/display/shenandoah/Main">Shenandoah</a> 是 Red Hat 主导的另一个低延迟的 GC，也承诺 pause time 低于 10ms，这两个项目目前处于竞争状态。该 GC 在 Oracle JDK 中不存在，但是在其他几个主流厂商的 JDK 中都包含，具体内容请参考项目主页。</p>
<h3 id="ZGC-的-“Z”-代表什么？"><a href="#ZGC-的-“Z”-代表什么？" class="headerlink" title="ZGC 的 “Z” 代表什么？"></a>ZGC 的 “Z” 代表什么？</h3><p>ZGC 只是一个名字，<strong>Z</strong> 不代表任何含义，不要把它理解为最后一代 GC，随着大家的探索，技术总是存在更优解。</p>
<p>It doesn’t stand for anything, ZGC is just a name. It was originally inspired by, or a homage to, ZFS (the filesystem) which in many ways was revolutionary when it first came out. Originally, ZFS was an acronym for “Zettabyte File System”, but that meaning was abandoned and it was later said to not stand for anything. It’s just a name. See <a target="_blank" rel="noopener" href="https://web.archive.org/web/20170223222515/https://blogs.oracle.com/bonwick/en_US/entry/you_say_zeta_i_say">Jeff Bonwick’s Blog</a> for more details.</p>
<h3 id="ZGC-的读法，”zed-gee-see”-or-“zee-gee-see”"><a href="#ZGC-的读法，”zed-gee-see”-or-“zee-gee-see”" class="headerlink" title="ZGC 的读法，”zed gee see” or “zee gee see”?"></a>ZGC 的读法，”zed gee see” or “zee gee see”?</h3><p>怎么读都行，无所谓。</p>
<p>There’s no preferred pronunciation, both are fine.</p>
<h2 id="ZGC-简单介绍"><a href="#ZGC-简单介绍" class="headerlink" title="ZGC 简单介绍"></a>ZGC 简单介绍</h2><p>ZGC 的口号是：<strong>A Scalable Low-Latency Garbage Collector</strong></p>
<ul>
<li>Scalable：可以管理小堆(8M)和大堆，支持 TB 级别的 heap size。</li>
<li>Low-Latency：停顿时间永远不会超过 10ms，通常情况，都在 1-2ms 内。</li>
</ul>
<p>对比前面几代 GC 的设计目标：</p>
<ul>
<li>Serial: Low Memory Footpoint</li>
<li>Parallel: Througput</li>
<li>CMS: 第一个 Concurrent GC（JDK14以后被删除）</li>
<li>G1: Throughput/Latency Balance</li>
<li>ZGC: Low Latency</li>
</ul>
<h3 id="ZGC-的设计目标"><a href="#ZGC-的设计目标" class="headerlink" title="ZGC 的设计目标"></a>ZGC 的设计目标</h3><p>  <img src="https://assets.javadoop.com/imgs/20510079/zgc/goals.png" alt="goals"></p>
<ul>
<li>达到 TB 级别的堆内存管理；</li>
<li>最大 10ms 的停顿时间；</li>
<li>易于调优、配置；</li>
<li>15% 以内的吞吐量下降（应该是相比于 default GC，也就是 G1)</li>
</ul>
<h3 id="ZGC-一览"><a href="#ZGC-一览" class="headerlink" title="ZGC 一览"></a>ZGC 一览</h3><p><img src="https://assets.javadoop.com/imgs/20510079/zgc/glance.png" alt="glance"></p>
<ul>
<li>Concurrent: 和 java 线程并发执行</li>
<li>Tracing: ZGC 通过对象引用关系图可以知道哪些是活的对象，哪些是垃圾</li>
<li>Compacting: 采用压缩算法，减少碎片</li>
<li>Single generation: 没有使用分代（在 JDK21实现了分代）</li>
<li>Region-based: 将 heap 分为一个个 region，在 GC 期间，可以只回收垃圾比较多的 region</li>
<li>Load barriers 和 Colored pointers 用来实现 concurrency </li>
</ul>
<h2 id="ZGC-设计"><a href="#ZGC-设计" class="headerlink" title="ZGC 设计"></a>ZGC 设计</h2><p>首先，我们先介绍 ZGC 的一个 GC 周期主要做哪些事情，然后介绍染色指针的技术细节。</p>
<h3 id="GC-周期"><a href="#GC-周期" class="headerlink" title="GC 周期"></a>GC 周期</h3><p><img src="https://assets.javadoop.com/imgs/20510079/zgc/gc_phases.png" alt="image-20240205214631419"></p>
<p>ZGC 在一个 GC 周期中，只有 3 次非常短暂的 STW。这是 ZGC 的杀手锏，也就是毫秒或亚毫秒级别的停顿时间。</p>
<p>10ms 的停顿时间是保守策略，通常情况都是在 2ms 以内。这个时间主要跟 GC Roots 的大小有关，说白了就是跟<strong>线程数的大小</strong>直接相关。</p>
<p>简单先分解一下这几个 GC 阶段：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/gc_phase_details.png" alt="gc_phase_details"></p>
<ol>
<li>扫描线程堆栈，确定 GC roots，stop the world</li>
<li>耗时的对象标记，concurrent</li>
<li>同步检查点，因为在并发标记阶段，有新的对象产生，stop the world</li>
<li>处理 soft, weak, phantom 引用，确定下一阶段要回收哪些 region 等，concurrent，耗时通常比较短</li>
<li>扫描线程堆栈，找到那些引用了 relocation set 的 roots，因为这些对象即将被移动，stop the world</li>
<li>复制压缩，concurrent，任务重，耗时长</li>
</ol>
<h3 id="染色指针设计"><a href="#染色指针设计" class="headerlink" title="染色指针设计"></a>染色指针设计</h3><p>在介绍染色指针之前，我们要先知道一些基本的背景。</p>
<p>现在大部分平台都是 64 位的，意味着理论上最大寻址空间可以达到 2^64，这是一个很大的内存空间。</p>
<p>但是 JDK 通常会做一些优化，就是仅使用 32 位的地址空间，来得到最高的执行效率。但是我们知道 2^32=4G，也就是说 32 位最大寻址空间只能达到 4G，但是我们很多场景下，堆内存都是超过 4G 的，这就会牵扯到另一项技术，指针压缩。</p>
<p>通过 padding，可以让原本只有 4G 的地址空间支持 32G（padding=8位，支持<code>4G*8</code>）、64G（padding=16位，支持 <code>4G*16</code>）等更大的堆。</p>
<blockquote>
<p>当然 padding 的副作用就是一些内存被白白浪费掉</p>
</blockquote>
<p>使用了染色指针以后，会导致没法使用指针压缩，每个指针必须占用 64 位，意味着 ZGC 会需要更多的内存消耗。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/colored_pointer.png" alt="image-20240126080622192"></p>
<p>染色指针，用空间换时间的思想。使用了指针中的 4 位来记录 metadata。告诉我们这个引用指向的对象的一些信息，比如这个对象是否被标记了，或者被移动了。</p>
<blockquote>
<p>为什么不直接使用最高的 4 位来染色，这样设计岂不是最简单？因为 64 位寻址是理论最大值，需要 64 条地址总线来寻址，而目前还远没有达到这个规格的内存，所以硬件厂商实际并没有设置那么多的地址总线，通常有 50 根地址总线就不错了。</p>
</blockquote>
<p>ZGC 目前支持 3 种指针 layout，也就是低位部分可以使用 42 位来支持 4TB 的内存（2^42=4TB），也可以使用 43 或 44 位，用于支持 8TB 或 16TB 内存。按照现在的硬件，这么大的内存空间，肯定是足够了，目前比较大的堆通常是几百 G 的规模。</p>
<p>下面，我们用 44 位的 layout 来进行实例介绍。</p>
<p>当我们要 new 一个对象的时候，首先需要申请一块堆内存，假设这块内存的起始地址是 <code>000...0001111</code>。</p>
<p>JVM 不是使用 <code>000...0001111</code>这个地址，而是申请了下面 3 个地址：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/colored_pointer_example.png" alt="image-20240205130820816"></p>
<p>这三个虚拟地址指向同一个物理内存。下面示意了在 4TB layout 的情况下，三个不同视图空间的地址，指向了相同的一个堆内存。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/colored_pointer_example_2.png" alt="image-20240205131011536"></p>
<h3 id="Load-Barrier-介绍"><a href="#Load-Barrier-介绍" class="headerlink" title="Load Barrier 介绍"></a>Load Barrier 介绍</h3><p>Load Barrier 是由 JIT 在执行过程中插入的一小段代码，当我们需要从堆中加载一个对象引用的时候，此时需要插入 Load Barrier 的代码。如果 JVM 发现这个引用的颜色是 bad 的，会做一些特殊处理，实现自愈。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/load_barrier.png" alt="image-20240204224240977"></p>
<p>比如下面这段代码，我们从堆中加载 person.name 这个引用，此时我们需要检查 person.name 这个引用是否是正确的颜色，所以在这段代码的后面，会插入 load barrier：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/load_barrier_example_1.png" alt="image-20240204224308148"></p>
<p>下面是一段伪代码，我们通过指针中的 metadata 判断此引用是否是 bad 的：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/load_barrier_example_2.png" alt="image-20240204224500895"></p>
<p>当前 bad_bit_mask 是啥，取决于当前的 GC phase 是啥。如果是 bad，就需要走 slow_path 实现自愈。</p>
<blockquote>
<p>据统计，Load barriers 的性能消耗大概在 5% 以内。</p>
</blockquote>
<h3 id="GC-Cycle-示例"><a href="#GC-Cycle-示例" class="headerlink" title="GC Cycle 示例"></a>GC Cycle 示例</h3><p>首先，整个堆分为一个个 region，对象引用通常是非常复杂的。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/gc_example_1.png" alt="image-20240205144323875"></p>
<p>在第一个 STW 期间，完成 GC Roots 的扫描：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/gc_example_2.png" alt="image-20240205144437649"></p>
<p>然后开始进入并发扫描阶段，最终得到所有对象引用关系图：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/gc_example_3.png" alt="image-20240205144545724"></p>
<p>然后进入第二次 STW，这里结束并发扫描过程，在示例中，对象图没有发生变化，但是通常来说，由于在并发扫描期间有新的对象产生，所以引用图是会有一些变化的。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/gc_example_4.png" alt="image-20240205144649423"></p>
<p>然后开始并发压缩的前置准备阶段，这个阶段完成最重要的事情是对象引用的处理，以及确定接下来要做 relocation 的 region 是哪些，比如下图中，第 2 和第 3 个 region 被选中为将被移动的区域，因为它们的垃圾比较多。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/gc_example_5.png" alt="image-20240205144855388"></p>
<p>然后要为这些区域建立 forwarding table 来记录存活对象被移动到哪里了：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/gc_example_6.png" alt="image-20240205145016203"></p>
<p>接下来我们开始 relocation，首先是一次短暂的 STW，处理 GC Roots 引用的对象：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/gc_example_7.png" alt="image-20240205145125532"></p>
<p>GC roots 引用了对象 <strong>1，2，4</strong>，其中 1 和 2 是不需要移动的，4 需要被移动到新的 region 的，最终形成如下：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/gc_example_8.png" alt="image-20240205145355998"></p>
<p>第 2 个 region 的 forwarding table 记录了 4 的最新地址 4’。</p>
<p>处理完了 GC Roots 以后，开始做并发 relocation，这个过程通常比较长，但是我们的示例中，只有 5 和 8 是需要被移动的。</p>
<p>我们先把 5 移动到新的 region：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/gc_example_9.png" alt="image-20240205145612388"></p>
<p>记录 forwarding table 5-&gt;5’，这样 2 在访问 5 的时候，可以通过这个信息，知道 5‘ 的地址；</p>
<p>此时第 2 个 region 就打扫干净了：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/gc_example_10.png" alt="image-20240205145847989"></p>
<p>接下来，我们处理第 3 个 region，把 8 移动到新的 region：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/gc_example_11.png" alt="image-20240205145942141"></p>
<p>此时第 3 个 region 也清空了。自此完成了这个 GC 周期所有的工作。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/gc_example_12.png" alt="image-20240205155049870"></p>
<p>但是我们可以很明显地看出来一个问题，对象 4 -&gt; 5 的引用需要绕一圈，从 region 2 的 forwarding table 中找 5’ 的地址才能访问到 5。</p>
<p>如果有 java 线程在访问这个路径，那么 java 线程会帮助修复这个问题，因为 load barrier 会发现 5 被移动了，会进入到 slow path，找到最新的地址，并且更新这个引用关系实现自愈。如下：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/gc_example_13.png" alt="image-20240205160823771"></p>
<p>当然，还剩下一个问题，主要就是 5 -&gt; 8 此时也是长路径，2 -&gt; 5 也是，它们还需要通过 forwarding table 的信息帮助寻址。这个问题会在下一个 GC Cycle 的 remap 阶段被修复：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/gc_phases_remap.png" alt="image-20240205155301933"></p>
<p>remap 顾名思义，就是重新 map 最新的对象地址。这也是为什么，我们说 ZGC 的回收周期是重叠的：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/gc_phases_overlap.png" alt="image-20240205155419822"></p>
<p>下一个周期的 remap 结束后，我们才认为是上一个周期的完整结束。</p>
<p>下图示意了第二个 GC Cycle 的 remap 阶段将 2-&gt;5 和 5-&gt;8 的引用更新为最新状态：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/gc_example_14.png" alt="image-20240205161653581"></p>
<p>然后就可以把 forwarding table 清掉了，这个过程会在压缩的前置准备阶段完成：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/gc_example_15.png" alt="image-20240205161814444"></p>
<h2 id="ZGC-调优"><a href="#ZGC-调优" class="headerlink" title="ZGC 调优"></a>ZGC 调优</h2><p>首先，建议使用最新版本的 JDK，因为 ZGC 随着 JDK 一直在优化。目前 (2024.02) JDK 的最新版本是 21，其中长期维护版本是 8、11、17。</p>
<p>开启 ZGC：**-XX:+UseZGC**</p>
<p>JDK 14 以及之前的版本，需要添加 <strong>-XX:+UnlockExperimentalVMOptions</strong></p>
<p>关于调优，ZGC 几乎没什么可做的，它的设计目标也是让更多的不了解 ZGC 细节的开发，可以非常容易地使用 ZGC。它被设计成非常 adaptive，通常我们只要调整堆内存即可：**-Xmx{size}**，如 -Xmx4G</p>
<p>另外我们可以设置并发期间 GC 的线程数，**-XX:ConcGCThreads={number}**，这个就有点微妙了，设置多了，GC 就会得到更多的 CPU 时间，应用就会被拖慢，设置少了，会导致一定的系统风险，因为所有的并发回收器，都有一个问题，一边 GC 在打扫一边应用在扔垃圾。通常使用 ZGC 的默认策略就行。</p>
<p>其他的几个参数简单介绍一下：</p>
<p>开启简单的 GC 日志 <strong>-Xlog:gc</strong>，打印出来的日志是这样的：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/gc_log.png" alt="image-20240204225632420"></p>
<p>如果使用 <strong>-Xlog:gc</strong>*，那么我们可以得到更加详细的日志信息，例如：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/zgc/gc_log_detailed.png" alt="image-20240204225604765"></p>
<p>这里面记录了非常详细的信息，大家可以看一下，也可以从这里面了解一些 ZGC 的设计。</p>
<h2 id="ZGC-现状"><a href="#ZGC-现状" class="headerlink" title="ZGC 现状"></a>ZGC 现状</h2><p>当前到 JDK 21 已经解决了之前 roadmap 上的一些计划事项。</p>
<p>首先是达到了之前想要承诺的 pause time 低于 1ms，也就是说真正地做到了 pause time 与 GC Roots 大小也无关。</p>
<p>另外就是一直被诟病的没有使用分代算法，也在 JDK 21 实现了。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>ZGC 主页：<a target="_blank" rel="noopener" href="https://wiki.openjdk.java.net/display/zgc">https://wiki.openjdk.java.net/display/zgc</a></p>
<p>ZGC 调优介绍：<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/21/gctuning/introduction-garbage-collection-tuning.html">https://docs.oracle.com/en/java/javase/21/gctuning/introduction-garbage-collection-tuning.html</a></p>
<p>ZGC 开发负责人 Per Liden 博客: <a target="_blank" rel="noopener" href="https://malloc.se/">https://malloc.se</a> 以及他对 ZGC 的介绍视频：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=88E86quLmQA">https://www.youtube.com/watch?v=88E86quLmQA</a></p>
<p>本文大部分内容来自于 Per Liden 的这个 PPT：<a target="_blank" rel="noopener" href="https://cr.openjdk.org/~pliden/slides/ZGC-PLMeetup-2019.pdf">https://cr.openjdk.org/~pliden/slides/ZGC-PLMeetup-2019.pdf</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>好久没有发博客了，本文完成度大概在 80% 左右，其中缺失了一些非常细节的内容，会在后续收集了大家的反馈后进行更新。比如没有介绍在 mark、remap 过程中，怎么修改指针的染色位，如果大家感兴趣，可以先自行去研究一下。</p>
<p>本文质量相对我之前写的其他文章来说，稍微偏低一些，因为它来自于我在团队内部做的技术分享，所以深度上我认为是不够的。我也是真的很久没写文章了，这篇文章没有花太多的时间就成文了，暂时先抛出来看看大家的反馈，再决定是否做一些优化。</p>
<p>（全文完）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2023/12/25/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/25/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-25 00:00:00" itemprop="dateCreated datePublished" datetime="2023-12-25T00:00:00+08:00">2023-12-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 13:48:42" itemprop="dateModified" datetime="2025-04-26T13:48:42+08:00">2025-04-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/12/25/hello-world/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2023/11/23/cpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/23/cpp/" class="post-title-link" itemprop="url">cppnotes</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-23 00:00:00" itemprop="dateCreated datePublished" datetime="2023-11-23T00:00:00+08:00">2023-11-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-16 19:45:06" itemprop="dateModified" datetime="2025-05-16T19:45:06+08:00">2025-05-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="C-笔记"><a href="#C-笔记" class="headerlink" title="C++ 笔记"></a>C++ 笔记</h1><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul>
<li><p>如果程序执行错误，就throw一个异常</p>
<p>b是一个int</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> b </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="built_in">catch</span> (<span class="type">int</span> b)&#123;</span><br><span class="line"></span><br><span class="line">cerr &lt;&lt;b&lt;&lt;endl &#125;</span><br></pre></td></tr></table></figure>

<p>throw 一个字符串常量，catch的参数就是一个const char</p>
<ul>
<li><p>throw加在函数声明的后边 void fun() throw(A,B,C,D)</p>
<p>表示函数能抛出ABCD四种类型的错误，不加throw表明能抛出任何类型的异常</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> x = <span class="number">50</span>;</span><br><span class="line">   <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">   <span class="type">double</span> z = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     z = <span class="built_in">division</span>(x, y);</span><br><span class="line">     cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">   &#125;<span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">     cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><ul>
<li>using namespace XXX<br>如果不写using namespace std的话<br>用cout函数就得加std::cout<br>尽量别用，容易污染<br>xx::a 与 yy::a不是一个东西<br>全局作用域符号，用来区分同名的的全局变量与局部变量<br>::不跟类名，表示全局的</li>
</ul>
<h2 id="动态数组（new-amp-delete）"><a href="#动态数组（new-amp-delete）" class="headerlink" title="动态数组（new&amp;delete）"></a>动态数组（new&amp;delete）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">p=<span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">*p=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">p=<span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> []p;<span class="comment">//对象数组是同样的处理方法</span></span><br></pre></td></tr></table></figure>

<p>我们在用动态内存分配时，经常是用<code>new</code>来定义一块内存空间，比如说 <code>int* p = new int(1)；</code>这时会在堆上分配一块内存，当作int类型使用，内存中存储的值为1并将内存地址赋值给在栈中的int*类型的p。（注意：p只是一个变量，就像是int a=1中的a一样，不过a是整形变量，而p是指针变量）当我们不用p指针时，往往需要用delete p将其释放，我们需要注意的是释放一个指针p（delete p;）实际意思是删除了p所指的目标（变量或对象），释放了它所占的堆空间，而不是删除p本身（指针p本身并没有撤销，它自己仍然存在，该指针所占内存空间并未释放，指针p的真正释放是随着函数调用的结束而消失），释放堆空间后，p成了”空指针”。如果我们在delete p后没有进行指针p的制空（p=NULL)的话，其实指针p这时会成为野指针，为了使用的安全，我们一般在delete p之后还会加上p=NULL这一语句。具体怎么成为野指针的，这有一篇非常详细的介绍<a target="_blank" rel="noopener" href="http://https//www.cnblogs.com/uniqueliu/archive/2011/07/18/2109778.html">点击打开链接</a></p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><ul>
<li><p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。 </p>
</li>
<li><p>当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。</p>
</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>位运算符（除去“~”都是双目运算符）</p>
<table>
<thead>
<tr>
<th>&amp;   与</th>
<th>只有同时为1才为1</th>
</tr>
</thead>
<tbody><tr>
<td>|    或</td>
<td>只有同时为0才为0</td>
</tr>
<tr>
<td>^  异或</td>
<td>一样就是0 不一样就是1</td>
</tr>
<tr>
<td>~  取反</td>
<td>变成负数，1变成0，0变成1</td>
</tr>
<tr>
<td>&lt;&lt; 左移</td>
<td>字面意思</td>
</tr>
<tr>
<td>&gt;&gt; 右移</td>
<td>字面意思</td>
</tr>
</tbody></table>
<p>​      A = 0011 1100</p>
<p>​      B = 0000 1101</p>
<p>A &amp; B = 0000 1100</p>
<p>A  |  B = 0011 1101</p>
<p>A  ^ B = 0011 0001</p>
<p>   ~A   = 1100 0011</p>
<p>A&lt;&lt;2  = 1111 0000</p>
<p>A&gt;&gt;2  = 0000 1111</p>
<ul>
<li><p>赋值运算符</p>
<p>+=，-=，/=，%=，*=   不做赘述</p>
<p>位运算&lt;&lt;=：<code>a&lt;&lt;=2</code>   a=a&lt;&lt;2</p>
<p>任何数异或 <strong>^0</strong> 得到的值不变:<code>a^0 = a</code></p>
<p>任何数异或同一个数两次得到的值不变:<code>a^b^b = a</code></p>
</li>
</ul>
<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><ul>
<li>访问权限：public private protected</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>定义一个Line类，有一个length成员变量 初始化列表赋初值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Line::<span class="built_in">Line</span>(<span class="type">int</span>  num0):<span class="built_in">length</span> (num0)</span><br><span class="line"><span class="function">Line <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>如果声明了任何非默认构造函数、编译器不会提供默认构造函数。</p>
<p>构造函数在未指定参数或者提供了一个空初始化器列表，则会调用默认构造函数：<code>vector v1; vector v2&#123;&#125;;</code></p>
<p>引用和const必须被初始化</p>
<h3 id="复制构造函数（-amp-引用、const的使用）"><a href="#复制构造函数（-amp-引用、const的使用）" class="headerlink" title="复制构造函数（&amp;引用、const的使用）"></a>复制构造函数（&amp;引用、const的使用）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Line::<span class="built_in">Line</span>(<span class="type">const</span> Line&amp;obj)</span><br></pre></td></tr></table></figure>

<p>&amp;是引用号作用类似于指针，引用时必须初始化值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span> ;   </span><br><span class="line"><span class="type">int</span> &amp;ra =a ;   </span><br></pre></td></tr></table></figure>

<p>​    相当于起了个别名ra，这样a在用作参数时候使用ra可以不用调用复制构造函数，因此不会造成无限复制构造函数的无限循环。如果引用对象参数为const类型，则不能通过ra修改a，反过来是可以的，但可以修改指针指向的地方。</p>
<p>​    如果对象中有指针，默认复制时指针的值是不会变的，因为他分配的内存是不在对象里面的，在析构    的时候，会出现两次析构相同位置的情况，所以==有指针的情况下最好自己构建一个复制构造函数==，并分配新的内存空间给新对象的指针。并且析构函数中也要额外释放指针，在系统默认的拷贝构造，**对指针的赋值时为==浅拷贝==<strong>，可能会导致直接对位的赋值，从而导致出现野指针情况，</strong>手动处理为==深拷贝==**。</p>
<ul>
<li><p>用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过const的使用，保证了引用传递的安全性。普通引用在声明时必须用其它的变量进行初始化</p>
</li>
<li><p>引用作为函数参数声明时不进行初始化</p>
</li>
<li><p>传递引用是传递原变量，不需要做变量拷贝，普通的变量做函数参数的时候会开辟内存拷贝数值，而传递引用则不需要开辟内存；</p>
<p>C++ primer p406 ：拷贝构造函数是一种特殊的构造函数，具有单个形参，该形参（常用const修饰）是对该类类型的引用。当定义一个新对象并用一个同类型的对象对它进行初始化时，将显示使用拷贝构造函数。当该类型的对象传递给函数或从函数返回该类型的对象时，将隐式调用拷贝构造函数。</p>
</li>
<li><p>C++支持两种初始化形式：</p>
<ul>
<li>拷贝初始化 int a = 5; </li>
</ul>
</li>
<li><p>直接初始化 int a(5); </p>
<ul>
<li>对于其他类型没有什么区别，对于类类型直接初始化直接调用实参匹配的构造函数，<u>拷贝初始化总是调用拷贝构造函数</u>，也就是说：</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A z;        <span class="comment">//定义，调用无参构造函数</span></span><br><span class="line"><span class="function">A <span class="title">x</span><span class="params">(<span class="number">2</span>)</span></span>;　　 <span class="comment">//直接初始化，调用有参构造函数</span></span><br><span class="line">A y = x;　　<span class="comment">//拷贝初始化，调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><u>必须定义拷贝构造函数的情况</u>：</p>
<ol>
<li>只包含类类型成员或内置类型（但不是指针类型）成员的类，无须显式地定义拷贝构造函数也可以拷贝；</li>
<li>有的类有一个数据成员是指针，或者是有成员表示在构造函数中分配的其他资源。</li>
</ol>
</li>
<li><p><u>类的对象需要拷贝时，拷贝构造函数将会被调用。以下情况都会调用拷贝构造函数：</u></p>
<ol>
<li><p>一个对象以值传递的方式传入函数体；</p>
</li>
<li><p>一个对象以值传递的方式从函数返回；</p>
</li>
<li><p>一个对象需要通过另外一个对象进行初始化。</p>
</li>
</ol>
</li>
<li><p>实例</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">( <span class="type">void</span> )</span></span>;</span><br><span class="line">      <span class="built_in">Line</span>( <span class="type">int</span> len );             <span class="comment">// 简单的有参构造函数</span></span><br><span class="line">      <span class="built_in">Line</span>( <span class="type">const</span> Line &amp;obj);      <span class="comment">// 拷贝构造函数</span></span><br><span class="line">      ~<span class="built_in">Line</span>();                     <span class="comment">// 析构函数</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">int</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 为指针分配内存</span></span><br><span class="line">    ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *ptr = len;</span><br><span class="line">&#125;</span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="type">const</span> Line &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数并为指针 ptr 分配内存&quot;</span>          &lt;&lt; endl;</span><br><span class="line">    ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *ptr = *obj.ptr; <span class="comment">// 拷贝值</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Line::~<span class="built_in">Line</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;释放内存&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Line::getLength</span><span class="params">( <span class="type">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(Line obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;line 大小 : &quot;</span> &lt;&lt; obj.<span class="built_in">getLength</span>() 		         &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Line <span class="title">line1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">   Line line2 = line1; <span class="comment">// 这里也调用了拷贝构造函数</span></span><br><span class="line">   <span class="built_in">display</span>(line1);</span><br><span class="line">   <span class="built_in">display</span>(line2);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行结果：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">调用构造函数</span><br><span class="line">调用拷贝构造函数并为指针 ptr 分配内存</span><br><span class="line">调用拷贝构造函数并为指针 ptr 分配内存</span><br><span class="line">line 大小 : 10</span><br><span class="line">释放内存</span><br><span class="line">调用拷贝构造函数并为指针 ptr 分配内存</span><br><span class="line">line 大小 : 10</span><br><span class="line">释放内存</span><br><span class="line">释放内存</span><br><span class="line">释放内存</span><br></pre></td></tr></table></figure>

<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul>
<li><p>必须与类同名 再在前部加一个～，删除对象的时候会自动调用</p>
</li>
<li><p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好在销毁类之前显式构造析构函数，释放掉申请的内存空间，避免内存泄漏。</p>
</li>
<li><p><strong>类析构顺序：</strong></p>
<p>1）派生类本身的析构函数；</p>
<p>2）对象成员析构函数；</p>
<p>3）基类析构函数。</p>
</li>
</ul>
<h3 id="友元函数（友元类）"><a href="#友元函数（友元类）" class="headerlink" title="友元函数（友元类）"></a>友元函数（友元类）</h3><ul>
<li>定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。</li>
<li>尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</li>
<li>友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend，没有this指针，访问非static指针要引入对象做参数</li>
</ul>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><ul>
<li><p>不允许使用switch 与loop 语句</p>
</li>
<li><p>定义必须出现在首次调用之前</p>
</li>
<li><p>较为短小的代码</p>
</li>
</ul>
<h2 id="继承、多态"><a href="#继承、多态" class="headerlink" title="继承、多态"></a>继承、多态</h2><h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><h5 id="按权限："><a href="#按权限：" class="headerlink" title="按权限："></a>按权限：</h5><ul>
<li><h5 id="public-保持不变"><a href="#public-保持不变" class="headerlink" title="public  保持不变"></a>public  保持不变</h5></li>
<li><h5 id="protected-原public变成protected"><a href="#protected-原public变成protected" class="headerlink" title="protected  原public变成protected"></a>protected  原public变成protected</h5></li>
<li><h5 id="private-全变成private"><a href="#private-全变成private" class="headerlink" title="private  全变成private"></a>private  全变成private</h5></li>
</ul>
<h5 id="按父类个数："><a href="#按父类个数：" class="headerlink" title="按父类个数："></a>按父类个数：</h5><ul>
<li><h5 id="单继承：只有一个父类"><a href="#单继承：只有一个父类" class="headerlink" title="单继承：只有一个父类"></a>单继承：只有一个父类</h5></li>
<li><h5 id="多继承：有多个父类"><a href="#多继承：有多个父类" class="headerlink" title="多继承：有多个父类"></a>多继承：有多个父类</h5></li>
<li><h5 id="链式继承：一条链，首尾相连"><a href="#链式继承：一条链，首尾相连" class="headerlink" title="链式继承：一条链，首尾相连"></a>链式继承：一条链，首尾相连</h5></li>
<li><h5 id="虚继承：也就是菱形继承"><a href="#虚继承：也就是菱形继承" class="headerlink" title="虚继承：也就是菱形继承"></a><a href="####%E8%99%9A%E7%BB%A7%E6%89%BF">虚继承</a>：也就是菱形继承</h5></li>
</ul>
<h4 id="重载-静态多态"><a href="#重载-静态多态" class="headerlink" title="重载(静态多态)"></a>重载(<strong>静态多态</strong>)</h4><p>静态函数在编译的时候就已经确定运行时机</p>
<h4 id="虚函数-动态多态"><a href="#虚函数-动态多态" class="headerlink" title="虚函数(动态多态)"></a>虚函数(动态多态)</h4><ul>
<li><p>函数只在 code 区存放一份，数据成员则每个对象一份，并按照声明顺序依次存放</p>
</li>
<li><p>在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p>
</li>
<li><p>类A中有了虚函数就会再类的数据成员的最前面添加一个 vfptr 指针(void** vfptr)，这个指针用来指向一个 vtable 表（一个函数指针数组）（一个类只有一个该表），该表存储着当前类的所有 虚函数 的地址。这样 vfptr 就成为了一个类似成员变量的存在。访问虚函数的时候通过 vfptr 间址找到vtable 表，再间址进而找到要调用的函数。这样就在一定程度上摆脱了类型制约。</p>
<p><img src="https://i.imgloc.com/2023/05/25/VDJKFq.png" alt="people派生出student再派生出vtable"></p>
<p>在虚函数表中，基类的虚函数在 vtable 中的索引（下标）是固定的，不会随着继承层次的增加而改变，派生类新增的虚函数放在 vtable 的最后。如果派生类有同名的虚函数遮蔽（覆盖）了基类的虚函数，那么将使用派生类的虚函数替换基类的虚函数，这样具有遮蔽关系的虚函数在 vtable 中只会出现一次。</p>
<p>只要vptr的值不同，那么访问函数成员的时候使用的vtable表就不同，就可能访问到不同类的函数成员。B类对象中的vptr指向B类自己的vtable。</p>
<p>当B类继承A类的时候，因为A中有虚函数，编译器就自动的给B类添加vfprt指针和vtable表。也可以理解为B类继承来了A类中的那个vptr指针成员。</p>
<p>当A类指针指向B类对象时，发生假切割。要知道这个过程只是切掉A类中没有的那些成员。（即当People类指针指向Student类对象时，切割掉m_score这个People类中没有的成员）<br>由于vptr是从A类中继承来的，所以这个量仍将保留。而对于vptr的值则不会改变，仍然指向B类的vtable表。所以访问F1函数的时候是通过B类的vtable表去寻址的，自然就是使用子类的函数（拿图中的情况举例，子类的Student::display()函数已经覆盖了People::display()函数，此时A类指针访问虚函数display()时也是访问到子类的Student::display()函数）。</p>
<p>当B类的指针指向A类的对象时（当B类存在新增数据成员时可能出错），同理。</p>
<p>而对于普通函数则受类型的制约，（因为没有vptr指针）使用哪个类的指针调用函数，那么所调用的就是那个累的函数。<br>总而言之，普通函数通过对象或指针的类型来找所调用的函数，而虚函数是通过一个指针来找到所要调用的函数的。</p>
<p>***==派生类指针指向基类对象==<em><strong>，这里疑问会比较大。首先是为什么这里不会报错，为什么派生类指针指向基类对象可以成立？理论上指针的可访问范围一定大于对象的大小，会指向一些未知区域导致运行出错，但是要注意的是，</strong>这个题目里面B类不存在新增数据成员，所以不会出错</em>*。还有就是由于是基类对象，还没有发生虚函数掩盖</p>
</li>
<li><p>函数要修改数据必须要传入该数据的地址</p>
<p>实现C++的多态，基类与派生类有同名的函数，派生类在调用这个函数的时候不知道调用哪个，因此就要用虚函数，在基类的这个函数加上virtual前缀。</p>
<p>虚函数必须实现也就是定义，不然会报错，</p>
<p><strong>纯虚函数:virtual xxx xxx()=0</strong></p>
<p>声明纯虚函数就代表这个类成了<strong>抽象类，不能进行实例化</strong></p>
<p>这就是在提醒继承这个类的时候要再次定义这个函数，不然还是抽象类没法实例化</p>
<p>定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。</p>
<p>定义一个函数为纯虚函数，才代表函数没有被实现。</p>
<p>定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为”虚”函数。</p>
<p>虚函数只能借助于指针或者引用来达到多态的效果。</p>
<p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加 =0:</p>
<p>那么此时就能<a href="####%E9%80%9A%E8%BF%87%E7%88%B6%E7%B1%BB%E6%8C%87%E9%92%88%E8%B0%83%E7%94%A8%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%88%E5%90%8C%E5%90%8D%E5%90%8C%E5%8F%82%EF%BC%89">通过父类的一个指针来调用子类的方法</a></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> A <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">class</span> B <span class="type">void</span> <span class="title">sow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">A *pa</span>=<span class="literal">NULL</span>;</span><br><span class="line">B b;</span><br><span class="line">pa=＆b;</span><br><span class="line">pa-&gt;<span class="built_in">sow</span>()</span><br></pre></td></tr></table></figure>


<h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><ul>
<li><p>​    A</p>
<p> /      <br>B      C             D继承了两个A，析构时会造成内存泄露<br> \     /              所以BC在继承A的时候必须要 <code>virtual public A</code> 虚继承</p>
<pre><code>D                 
</code></pre>
<p>​        在一个派生类中保留间接基类的多份同名成员，虽然可以在不同的成员变量中分别存放不同的数据，但大多数情况下这是多余的：因为保留多份成员变量不仅占用较多的存储空间，还容易产生命名冲突。假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 A -&gt;B-&gt;D 这条路径，还是来自 A-&gt;C-&gt;D 这条路径。</p>
<p>​        为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。</p>
<p>​        虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为<strong>虚基类（<em>Virtual Base Class</em>）</strong>，本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p>
</li>
</ul>
<h4 id="子类从基类继承的成员限制"><a href="#子类从基类继承的成员限制" class="headerlink" title="子类从基类继承的成员限制"></a>子类从基类继承的成员限制</h4><ul>
<li>基类的构造函数、析构函数和拷贝构造函数。</li>
<li>基类的重载运算符。</li>
<li>基类的友元函数。</li>
<li>==子类对象中父类成员初始化必须调用父类的构造函数，初始化列表方式==</li>
<li>子类对象中其他类的成员初始化必须使用初始化列表方式</li>
</ul>
<h4 id="构造函数-析构函数调用顺序"><a href="#构造函数-析构函数调用顺序" class="headerlink" title="==构造函数 析构函数调用顺序=="></a>==构造函数 析构函数调用顺序==</h4><ul>
<li>仅考虑实例化派生类对象时的情况</li>
<li>构造函数调用顺序：基类 &gt; 派生类里的对象成员 &gt; 派生类； </li>
<li>多继承派生类： 基类的构造顺序依照基类继承顺序调用</li>
<li>对象成员<a href="%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%EF%BC%8C%E6%AD%A4%E6%97%B6%E6%8A%8A%E8%AF%A5%E5%AF%B9%E8%B1%A1%E7%A7%B0%E4%B8%BA%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E3%80%82%E4%B9%9F%E5%8F%AB%E7%B1%BB%E7%9A%84%E7%BB%84%E5%90%88">^2</a>：依照在派生类中对象成员的定义顺序 调用成员的构造函数 与初始化列表顺序无关</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> <span class="comment">// 基类 Shape</span></span><br><span class="line">&#123;   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>() &#123;cout &lt;&lt; <span class="string">&quot;Shape&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    ~<span class="built_in">Shape</span>() &#123;cout &lt;&lt; <span class="string">&quot;~Shape&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaintCost</span> <span class="comment">// 基类 PaintCost</span></span><br><span class="line">&#123;   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PaintCost</span>() &#123;cout &lt;&lt; <span class="string">&quot;PaintCost&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    ~<span class="built_in">PaintCost</span>() &#123;cout &lt;&lt; <span class="string">&quot;~PaintCost&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost  <span class="comment">//基类构造顺序 依照 继承顺序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>() :<span class="built_in">b</span>(), <span class="built_in">a</span>(), <span class="built_in">Shape</span>(), <span class="built_in">PaintCost</span>()</span><br><span class="line">    &#123;cout &lt;&lt; <span class="string">&quot;Rectangle&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    ~<span class="built_in">Rectangle</span>() </span><br><span class="line">    &#123;cout &lt;&lt; <span class="string">&quot;~Rectangle&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    PaintCost b;        <span class="comment">// 对象成员依照定义顺序</span></span><br><span class="line">    Shape a; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rectangle Rect;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Shape</span><br><span class="line">PaintCost</span><br><span class="line">PaintCost</span><br><span class="line">Shape</span><br><span class="line">Rectangle</span><br><span class="line">~Rectangle</span><br><span class="line">~Shape</span><br><span class="line">~PaintCost</span><br><span class="line">~PaintCost</span><br><span class="line">~Shape</span><br></pre></td></tr></table></figure>

<h4 id="通过父类指针调用子类对象的成员函数（同名同参）"><a href="#通过父类指针调用子类对象的成员函数（同名同参）" class="headerlink" title="通过父类指针调用子类对象的成员函数（同名同参）"></a>通过父类指针调用子类对象的成员函数（同名同参）</h4><ul>
<li><p>基类指针指向基类对象，简单。只需要通过基类指针简单地调用基类的功能。</p>
</li>
<li><p>派生类指针指向派生类对象，简单。只需要通过派生类指针简单地调用派生类功能。</p>
</li>
<li><p>将基类指针指向派生类对象是安全的，因为派生类对象“是”它的基类的对象。</p>
<p>但是要注意的是，这个指针只能用来调用基类的成员函数。</p>
<p>如果试图通过基类指针调用派生类才有的成员函数，则编译器会报错。</p>
<p>为了避免这种错误，必须将基类指针强制转化为派生类指针。然后派生类指针可以用来调用派生类的功能。这称为向下强制类型转换，这是一种潜在的危险操作。</p>
</li>
</ul>
<p>注意：如果在基类和派生类中定义了虚函数（通过继承和重写），并通过基类指针在派生类对象上调用这个虚函数，则实际调用的是这个函数的派生类版本。</p>
<h5 id="出现同时有虚实函数的情况"><a href="#出现同时有虚实函数的情况" class="headerlink" title="出现同时有虚实函数的情况"></a>出现同时有虚实函数的情况</h5><ol>
<li><p>若全为虚函数，则调用子类的函数</p>
</li>
<li><p>若全为实函数，则调用父类的函数</p>
</li>
<li><p>若一实一虚，则调用他们中的实函数</p>
<p><strong>父类没有定义为虚的时候，子类是没办法多态的，而父类定义为虚函数的时候，子类默认也是个虚函数，会根据指针指向的数据类型来选择函数调用</strong></p>
<p><strong>派生类加不加virtual都是虚函数，只要派生类实现了虚函数就会覆盖基类的虚函数，基类指针pBase指向派生类对象basePlus时会调用派生类的虚函数</strong></p>
</li>
</ol>
<h5 id="虚析构函数（delete）"><a href="#虚析构函数（delete）" class="headerlink" title="虚析构函数（delete）"></a><strong>虚析构函数</strong>（delete）</h5><ol>
<li><p>可能通过基类指针删除派生类对象、</p>
</li>
<li><p>如果你打算允许他人通过基类指针调用对象的析构函数（通过delete这样做是正常的），就需要让基类的析构函数变为虚函数，否则执行delete的结果是不确定的</p>
</li>
<li><p>虚构造函数不合法(有了虚函数就要有虚函数表，调用构造函数就要去找vptr，此时vptr还没初始化)</p>
</li>
<li><p>虚析构函数的实现原理：</p>
<p>在父类中通过virtual 修饰析构函数后，通过 父类指针再去指向子类对象，然后通过delete 接父类指针，就可以 释放掉子类对象了</p>
<p>有了这个前提，如果使用父类的指针通过 <a href="##%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%88new&delete%EF%BC%89">delete</a> 的方式去释放子类的 对象，那么只要能够实现通过父类的指针执行到子类的析构函数即可</p>
<p>如果子类中不写虚析构函数，计算机会默认给你定义一个虚析构函数， 前提是你在父类中得有virtual 来修饰父类的析构函数</p>
<p>在使用时： 如果在main() 函数中通过父类指针指向子类对象，然后通过 delete 接父类指针释放子类对象 此时，虚函数表的工作： 如果在父类中定义了虚析构函数，那么在父类的虚函数表中就会 有一个父类析构函数的函数指针，指向父类的析构函数 而在子类的虚函数表中也会产生一个子类析构函数的函数指针， 指向子类的析构函数（注意：虚析构函数会覆盖） 当 父类的指针指向 子类的对象，通过 delete 接 父类的 指针时，就可以通过子类对象的 虚函数表指针 找到子类的 虚函数表，再通过子类 的虚函数表找到子类的析构函数，从而使得子类的析构函数得以执行，子类的析构函数执行完毕后， 系统会自动执行父类的析构函数（这句是重点）！</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;<span class="comment">//虚析构函数应用举例</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> _a) :<span class="built_in">a</span>(_a) &#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">virtual</span>  ~<span class="built_in">A</span>() &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;A deleted.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A::getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>(<span class="type">int</span> _a, <span class="type">int</span> _b) :<span class="built_in">A</span>(_a), <span class="built_in">b</span>(_b) &#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">	~<span class="built_in">B</span>() &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;B deleted.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">B::getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A* pa;<span class="comment">//基类A指针</span></span><br><span class="line">	pa = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//基类A指针指向派生类B</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pa-&gt;<span class="built_in">getValue</span>());</span><br><span class="line">	<span class="keyword">delete</span> pa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">B deleted.A deleted.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">////delete 删除的是指针指向的空间，不代表指针置NULL</span></span><br></pre></td></tr></table></figure>

<h2 id="静态成员、常成员"><a href="#静态成员、常成员" class="headerlink" title="静态成员、常成员"></a>静态成员、常成员</h2><h3 id="静态成员变量："><a href="#静态成员变量：" class="headerlink" title="静态成员变量："></a>静态成员变量：</h3><ul>
<li><p>我们不能把静态成员的初始化放置在类的定义中，它是所有对象共有的</p>
</li>
<li><p>所以应该再类内声明 static int a;</p>
</li>
<li><p>在类外定义 int A::a=0;</p>
</li>
</ul>
<h3 id="静态成员函数："><a href="#静态成员函数：" class="headerlink" title="静态成员函数："></a>静态成员函数：</h3><ul>
<li><p>静态成员函数没有 this 指针，且只能访问静态成员（包括静态成员变量和静态成员函数）</p>
</li>
<li><p>静态成员函数即使在类对象不存在的情况下也能被调用</p>
</li>
</ul>
<h3 id="类中特殊成员变量的初始化问题："><a href="#类中特殊成员变量的初始化问题：" class="headerlink" title="类中特殊成员变量的初始化问题："></a>类中特殊成员变量的初始化问题：</h3><ul>
<li>常量变量：必须通过构造函数参数列表进行初始化。</li>
<li>引用变量：必须通过构造函数参数列表进行初始化。</li>
<li>普通静态变量：要在类外通过”::”初始化。</li>
<li>静态整型常量：可以直接在定义的时候初始化。</li>
<li>静态非整型常量：不能直接在定义的时候初始化。要在类外通过”::”初始化。</li>
</ul>
<h3 id="常成员变量"><a href="#常成员变量" class="headerlink" title="常成员变量"></a>常成员变量</h3><ul>
<li>一经初始化就不能再改变,并且只能通过初始化列表初始</li>
</ul>
<h3 id="常成员函数-常对象"><a href="#常成员函数-常对象" class="headerlink" title="常成员函数/常对象"></a>常成员函数/常对象</h3><ul>
<li>常对象里面的成员变量都不能改变，所以只能用常成员函数</li>
<li>常成员函数只能修改常成员变量，调用同类的常成员函数</li>
<li>不要误认为常对象中的成员函数都是常成员函数，常对象只保证其所有数据成员的值不被修改。</li>
<li>声明时候要把const加在参数表后边，不能加在前边，否则就是返回值是const类型，实现的时候也要把const加上</li>
</ul>
<h3 id="常成员变量的初始化"><a href="#常成员变量的初始化" class="headerlink" title="常成员变量的初始化"></a>常成员变量的初始化</h3><ul>
<li>只能通过初始化列表，构造函数里面相当于赋值了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTestBasic</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//常成员：默认初始化</span></span><br><span class="line">	<span class="built_in">CTestBasic</span>() :<span class="built_in">conNum</span>(<span class="number">0</span>) &#123;</span><br><span class="line">		value = <span class="number">-1</span>;</span><br><span class="line">		pValue = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//常成员：重载初始化</span></span><br><span class="line">	<span class="built_in">CTestBasic</span>(<span class="type">int</span> num ) :<span class="built_in">conNum</span>(num) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//常成员函数：又成为只读函数，不能改变成员变量的值</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getsNum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getcNum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">get_scNum</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getPointerValue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	~<span class="built_in">CTestBasic</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//const成员变量不能在类定义处初始化，[ 只能通过构造函数初始化列表进行 ]，并且必须有构造函数</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> conNum;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象.</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> sNum;</span><br><span class="line">	</span><br><span class="line">	<span class="type">const</span> <span class="type">static</span>  <span class="type">int</span> scNum = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">	<span class="type">int</span>* pValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员类外初始化</span></span><br><span class="line"><span class="type">int</span> CTestBasic::sNum = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义也必须包含const 关键字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTestBasic::getsNum</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> sNum;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTestBasic::getcNum</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> conNum;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTestBasic::get_scNum</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> scNum;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTestBasic::getPointerValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*pValue = <span class="number">200</span>;</span><br><span class="line">	<span class="comment">//pValue++; Error: pValue的值不能改变</span></span><br><span class="line">	<span class="keyword">return</span> *pValue;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CTestBasic::~<span class="built_in">CTestBasic</span>()&#123;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="一些常用的类"><a href="#一些常用的类" class="headerlink" title="一些常用的类"></a>一些常用的类</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><p>​            append() – 在字符串的末尾添加字符</p>
<p>​            find() – 在字符串中查找字符串</p>
<p>​            insert() – 插入字符</p>
<p>​            length() – 返回字符串的长度</p>
<p>​            replace() – 替换字符串</p>
<p>​            substr() – 返回某个子字符串</p>
<p>​            eg. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个string类对象</span></span><br><span class="line">    string http = <span class="string">&quot;www.runoob.com&quot;</span>;</span><br><span class="line">   <span class="comment">//打印字符串长度</span></span><br><span class="line">   cout&lt;&lt;http.<span class="built_in">length</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//拼接</span></span><br><span class="line">    http.<span class="built_in">append</span>(<span class="string">&quot;/C++&quot;</span>);</span><br><span class="line">    cout&lt;&lt;http&lt;&lt;endl; <span class="comment">//打印结果为：www.runoob.com/C++</span></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="type">int</span> pos = http.<span class="built_in">find</span>(<span class="string">&quot;/C++&quot;</span>); <span class="comment">//查找&quot;C++&quot;在字符串中的位置</span></span><br><span class="line">    cout&lt;&lt;pos&lt;&lt;endl;</span><br><span class="line">    http.<span class="built_in">replace</span>(pos, <span class="number">4</span>, <span class="string">&quot;&quot;</span>);   <span class="comment">//从位置pos开始，之后的4个字符替换为空，即删除</span></span><br><span class="line">    cout&lt;&lt;http&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//找子串runoob</span></span><br><span class="line">    <span class="type">int</span> first = http.<span class="built_in">find_first_of</span>(<span class="string">&quot;.&quot;</span>); <span class="comment">//从头开始寻找字符&#x27;.&#x27;的位置</span></span><br><span class="line">    <span class="type">int</span> last = http.<span class="built_in">find_last_of</span>(<span class="string">&quot;.&quot;</span>);   <span class="comment">//从尾开始寻找字符&#x27;.&#x27;的位置</span></span><br><span class="line">    cout&lt;&lt;http.<span class="built_in">substr</span>(first<span class="number">+1</span>, last-first<span class="number">-1</span>)&lt;&lt;endl; <span class="comment">//提取&quot;runoob&quot;子串并打印</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>几种输入方法的不同</p>
</li>
<li><p><code>cin</code>:遇到tab 空格 enter都结束</p>
</li>
<li><p><code>cin.getline (str,x)</code> x个字符包括反斜杠0 可以有空格</p>
</li>
</ul>
<p>需要&lt;string&gt;头文件：</p>
<ul>
<li><code>getline(cin,str )</code>可以有空格</li>
<li><code>gets(s)</code>可以有空格</li>
</ul>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a><strong>vector</strong></h3><ul>
<li>动态数组——顺序容器——stack（栈）的上位替代</li>
</ul>
<h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><ul>
<li><code>vector&lt;int\&gt; obj</code>          创造了一个vector int 类的obj数组</li>
<li><code>vector&lt;int\&gt; obj(10)</code>    创建一个obj数组，最多容纳10个数据</li>
<li><code>vector&lt;int\&gt; obj(10,3)</code>  创建一个obj数组，初始化10个数据为3</li>
<li><code>vector&lt; vector&lt;int\&gt; \&gt;</code> 二维数组</li>
</ul>
<h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><ul>
<li><code>begin()</code>,<code>end()</code> 获取首地址与尾地址</li>
<li><code>push_back(m)</code> 在最后插入数据m</li>
<li><code>pop_back()</code> 移除最后的数据</li>
<li><code>back()</code> 返回最后一个数据</li>
<li><code>clear()</code> 清除数据但不回收空间</li>
<li><code>size()</code>,<code>capacity()</code> size是当前容量 capacity是真实最大容量 一般来说相等 但是clear后不等</li>
<li><code>empty()</code> 判断是否为空 空返回1</li>
<li><code>insert(\__position\_\_,x)</code>    在指定位置插入x</li>
<li><code>insert(\__position\_\_,N,x)</code> 从指定位置开始插入N个x</li>
<li><code>erase(\__position\_\_)</code>       删除指定位置的元素</li>
<li><code>erase(\_\_positionBegin\_\_,\__positionEnd\_\_)</code>  删除指定区间内的元素</li>
</ul>
<h4 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器 (iterator)"></a>迭代器 (iterator)</h4><ul>
<li><p>遍历方法除了用数组之外还可以用迭代器（iterator）类似于指针</p>
<p>声明：vector&lt;int&gt;::iterator it;</p>
<p>具体方法：<code>for(it=obj.begin();it!=obj.end();it++)    </code></p>
<p>​               <code>cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</code> </p>
</li>
<li><p>迭代器实际上是对“遍历容器”这一操作进行了封装。</p>
<p>在编程中我们往往会用到各种各样的容器，但由于这些容器的底层实现各不相同，所以对他们进行遍历的方法也是不同的。例如，数组使用指针算数就可以遍历，但链表就要在不同节点直接进行跳转。</p>
<p>这是非常不利于代码重用的。例如你有一个简单的查找容器中最小值的函数findMin，如果没有迭代器，那么你就必须定义适用于数组版本的findMin和适用于链表版本的findMin，如果以后有更多容器需要使用findMin，那就只好继续添加重载……而如果每个容器又需要更多的函数例如findMax，sort，那简直就是重载地狱……</p>
<p>我们的救星就是迭代器啦！如果我们将这些遍历容器的操作都封装成迭代器，那么诸如findMin一类的算法就都可以针对迭代器编程而不是针对具体容器编程，工作量一下子就少了很多！</p>
<p>至于指针，由于指针也可以用来遍历容器(数组)，所以指针也可是算是迭代器的一种。但是指针还有其他功能，并不只局限于遍历数组。因为使用指针变量数组的操作太深入人心，c++stl中的迭代器就是刻意仿照指针来设计接口的</p>
</li>
</ul>
<h3 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43899069/article/details/104450000">algorithm头文件函数全集——史上最全，最贴心_算法头文件_来老铁干了这碗代码的博客-CSDN博客</a></p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="type">const</span>&amp; <span class="title">Max</span> <span class="params">(T <span class="type">const</span>&amp; a, T <span class="type">const</span>&amp; b)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b:a; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">39</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max(i, j): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(i, j) &lt;&lt; endl; </span><br><span class="line">    <span class="type">double</span> f1 = <span class="number">13.5</span>; </span><br><span class="line">    <span class="type">double</span> f2 = <span class="number">20.7</span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max(f1, f2): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(f1, f2) &lt;&lt; endl; </span><br><span class="line">    string s1 = <span class="string">&quot;Hello&quot;</span>; </span><br><span class="line">    string s2 = <span class="string">&quot;World&quot;</span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max(s1, s2): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(s1, s2) &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">Max(i, j): 39</span><br><span class="line">Max(f1, f2): 20.7</span><br><span class="line">Max(s1, s2): World</span><br></pre></td></tr></table></figure>



<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Op</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T <span class="title">peocess</span><span class="params">(T v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v * v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Op&lt;<span class="type">int</span>&gt; opInt;</span><br><span class="line">    Op&lt;<span class="type">double</span>&gt; opDouble;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5 * 5 = &quot;</span> &lt;&lt; opInt.<span class="built_in">peocess</span>(<span class="number">5</span>) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;0.5 * 0.5 = &quot;</span> &lt;&lt; opDouble.<span class="built_in">peocess</span>(<span class="number">0.5</span>) &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<p><strong>函数模板可以重载，只要它们的形参表不同即可。</strong></p>
<h3 id="C-中-typename-和-class-的区别"><a href="#C-中-typename-和-class-的区别" class="headerlink" title="C++ 中 typename 和 class 的区别"></a>C++ 中 typename 和 class 的区别</h3><p>在 C++ Template 中很多地方都用到了 typename 与 class 这两个关键字，而且好像可以替换，是不是这两个关键字完全一样呢?</p>
<p>相信学习 C++ 的人对 class 这个关键字都非常明白，class 用于定义类，在模板引入 c++ 后，最初定义模板的方法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;......</span><br></pre></td></tr></table></figure>

<p>这里 class 关键字表明T是一个类型，后来为了避免 class 在这两个地方的使用可能给人带来混淆，所以引入了 typename 这个关键字，它的作用同 class 一样表明后面的符号为一个类型，这样在定义模板的时候就可以使用下面的方式了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename</span><br><span class="line">T&gt;......</span><br></pre></td></tr></table></figure>

<p>在模板定义语法中关键字 class 与 typename 的作用完全一样。</p>
<p>typename 难道仅仅在模板定义中起作用吗？其实不是这样，typename 另外一个作用为：使用嵌套依赖类型(nested depended name)，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span>：</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> LengthType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyMethod</span><span class="params">( T myarr )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> T::LengthType LengthType; </span><br><span class="line">    LengthType length = myarr.GetLength; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候 typename 的作用就是告诉 c++ 编译器，typename 后面的字符串为一个类型名称，而不是成员函数或者成员变量，这个时候<u>如果前面没有 typename，编译器没有任何办法知道 T::LengthType 是一个类型还是一个成员名称(静态数据成员或者静态函数)</u>，所以编译不能够通过。</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="类指针"><a href="#类指针" class="headerlink" title="类指针"></a>类指针</h3><ul>
<li><code>Student *b = new Student；</code>在定义b这个指针变量的时候并没有分配<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>，只有执行new后才会分配内存，且为内存堆。是个永久变量,除非你释放它</li>
<li>是一个内存地址值，指向内存中存放的类对象（包括一些成员变量赋值；类指针可以指向多个不同的对象，这就是多态）</li>
<li>指针变量是间接访问，但可实现多态（通过父类指针可调用子类对象），并且没有调用构造函数；</li>
</ul>
<h3 id="常指针"><a href="#常指针" class="headerlink" title="常指针"></a>常指针</h3><h4 id="指向-常对象的指针-，指向-对象的常指针"><a href="#指向-常对象的指针-，指向-对象的常指针" class="headerlink" title="指向==常对象的指针==，指向==对象的常指针=="></a>指向==常对象的指针==，指向==对象的常指针==</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    A *p0; 			 <span class="comment">//指向对象的指针</span></span><br><span class="line">    <span class="type">const</span> A *p1; <span class="comment">//指向常对象的指针，指向常对象的指针只能是这种指针,不能通过此类指针修改A的数据</span></span><br><span class="line">    A *<span class="type">const</span> p2; <span class="comment">//指向对象的常指针，p是指针常量，不能改变p的值</span></span><br><span class="line">		<span class="comment">/*主要看const修饰谁，const修饰指针的指向那就是指向常量的指针</span></span><br><span class="line"><span class="comment">const修饰指针本身*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="向上造型（Upcast"><a href="#向上造型（Upcast" class="headerlink" title="向上造型（Upcast)"></a>向上造型（Upcast)</h2><p>在C++中，把子类的对象当做父类对象看待，就称为”向上造型“  (upcast)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">manager</span>: pubilc employee</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">manager</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">manager pett;</span><br><span class="line"></span><br><span class="line">employee *ep = &amp;pett;   <span class="comment">//就是upcast</span></span><br><span class="line"></span><br><span class="line">employee &amp;ep = pett;   <span class="comment">//也是upcast</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">把父类的对象当做子类来看待，称为 downcast.</span><br><span class="line"></span><br><span class="line">employee mob;</span><br><span class="line"></span><br><span class="line">manager *lowe = &amp;mob;   <span class="comment">//downcast, 将父类对象转换成子类对象</span></span><br></pre></td></tr></table></figure>

<p>注意：向上造型是安全的，向下造型是有风险的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2023/11/11/Mermaid%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/11/Mermaid%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/" class="post-title-link" itemprop="url">mermaid从入门到入土</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-11 00:00:00" itemprop="dateCreated datePublished" datetime="2023-11-11T00:00:00+08:00">2023-11-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-03 22:45:11" itemprop="dateModified" datetime="2025-05-03T22:45:11+08:00">2025-05-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>什么是Mermaid？<ul>
<li>Mermaid是一种基于Javascript的绘图工具，使用类似于Markdown的语法，使用户可以方便快捷地通过代码创建图表。</li>
<li>项目地址：<a target="_blank" rel="noopener" href="https://github.com/mermaid-js/mermaid%EF%BC%88%E9%9C%80%E8%A6%81%E5%B0%86%E6%A2%AF%E5%AD%90%E8%AE%BE%E7%BD%AE%E6%88%90%E5%85%A8%E5%B1%80%E6%A8%A1%E5%BC%8F%E6%89%8D%E8%83%BD%E8%AE%BF%E9%97%AE%EF%BC%89">https://github.com/mermaid-js/mermaid（需要将梯子设置成全局模式才能访问）</a></li>
</ul>
</li>
</ul>
<ul>
<li><p>怎么使用Mermaid？</p>
<ul>
<li>使用特定的Mermaid渲染器；</li>
<li><strong>使用集成了Mermaid渲染功能的Markdown编辑器，如<a target="_blank" rel="noopener" href="https://www.typora.io/">Typora</a>。</strong>使用时，需要将代码块的语言选择为Mermaid。</li>
</ul>
<blockquote>
<p>Typora是宇宙第一笔记软件，不接受反驳</p>
</blockquote>
</li>
<li><p>Mermaid能绘制哪些图？</p>
<ul>
<li>饼状图：使用<code>pie</code>关键字，具体用法后文将详细介绍</li>
<li>流程图：使用<code>graph</code>关键字，具体用法后文将详细介绍</li>
<li>序列图：使用<code>sequenceDiagram</code>关键字</li>
<li>甘特图：使用<code>gantt</code>关键字</li>
<li>类图：使用<code>classDiagram</code>关键字</li>
<li>状态图：使用<code>stateDiagram</code>关键字</li>
<li>用户旅程图：使用<code>journey</code>关键字</li>
</ul>
</li>
<li><p>实例：朱元璋家谱简图，圆圈代表皇帝</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">emperor((朱八八))-.子.-&gt;father(朱五四)-.子.-&gt;朱四九-.子.-&gt;朱百六</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">朱雄英--长子--&gt;朱标--长子--&gt;emperor</span><br><span class="line">emperor2((朱允炆))--次子--&gt;朱标</span><br><span class="line">朱樉--次子--&gt;emperor</span><br><span class="line">朱棡--三子--&gt;emperor</span><br><span class="line">emperor3((朱棣))--四子--&gt;emperor</span><br><span class="line">emperor4((朱高炽))--长子--&gt;emperor3</span><br></pre></td></tr></table></figure>

<p>以上是概述，下面详细介绍饼状图和流程图的语法。其他图的语法可访问上文给出的项目地址，自行学习。（记得挂梯子）</p>
<h1 id="饼状图"><a href="#饼状图" class="headerlink" title="饼状图"></a>饼状图</h1><ul>
<li><p>在线渲染器：<a target="_blank" rel="noopener" href="https://mermaidjs.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoicGllXG5cIkRvZ3NcIiA6IDQyLjk2XG5cIkNhdHNcIiA6IDUwLjA1XG5cIlJhdHNcIiA6IDEwLjAxIiwibWVybWFpZCI6eyJ0aGVtZSI6ImRlZmF1bHQifX0">Online FlowChart &amp; Diagrams Editor</a>（需要梯子）</p>
</li>
<li><p>语法</p>
<ul>
<li>从<code>pie</code>关键字开始图表</li>
<li>然后使用<code>title</code>关键字及其在字符串中的值，为饼图赋予标题。（这是<strong>可选的</strong>）</li>
<li>数据部分<ul>
<li>在<code>&quot; &quot;</code>内写上分区名。</li>
<li>分区名后使用<code>:</code>作为分隔符</li>
<li>分隔符后写上数值，最多支持2位小数——数据会以百分比的形式展示</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>实例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pie</span><br><span class="line">    title 为什么总是宅在家里？</span><br><span class="line">    &quot;喜欢宅&quot; : 15</span><br><span class="line">    &quot;天气太热或太冷&quot; : 20</span><br><span class="line">    &quot;穷&quot; : 500</span><br></pre></td></tr></table></figure>

<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><ul>
<li>在线渲染器：<a target="_blank" rel="noopener" href="https://mermaidjs.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoiZ3JhcGggVERcbiAgICBBW0hhcmRdIC0tPnxUZXh0fCBCKFJvdW5kKVxuICAgIEIgLS0-IEN7RGVjaXNpb259XG4gICAgQyAtLT58T25lfCBEW1Jlc3VsdCAxXVxuICAgIEMgLS0-fFR3b3wgRVtSZXN1bHQgMl0iLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9fQ">Online FlowChart &amp; Diagrams Editor</a>（需要挂梯子）</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[Start] --&gt; B&#123;Is it?&#125;;</span><br><span class="line">    B -- Yes --&gt; C[OK];</span><br><span class="line">    C --&gt; D[Rethink];</span><br><span class="line">    D --&gt; B;</span><br><span class="line">    B -- No ----&gt; E[End];</span><br></pre></td></tr></table></figure>

<h2 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h2><p>用于开头，声明流程图的方向。</p>
<ul>
<li><code>graph</code>或<code>graph TB</code>或<code>graph TD</code>：从上往下</li>
<li><code>graph BT</code>：从下往上</li>
<li><code>graph LR</code>：从左往右</li>
<li><code>graph RL</code>：从右往左</li>
</ul>
<h2 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h2><ul>
<li>无名字的结点：直接写内容，此时结点边框为方形；节点内容不能有空格</li>
<li>有名字的结点：节点名后书写内容，内容左右有特定符号，结点边框由符号决定；节点内容可以有空格</li>
</ul>
<blockquote>
<p>下面的实例中，没有为graph指定方向，因此默认是从上往下的。但是由于各个结点之前没有箭头，所以他们都处于同一排。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph</span><br><span class="line">    默认方形</span><br><span class="line">    id1[方形]</span><br><span class="line">    id2(圆边矩形)</span><br><span class="line">    id3([体育场形])</span><br><span class="line">    id4[[子程序形]]</span><br><span class="line">    id5[(圆柱形)]</span><br><span class="line">    id6((圆形))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph</span><br><span class="line">	id1&#123;菱形&#125;</span><br><span class="line">	id2&#123;&#123;六角形&#125;&#125;</span><br><span class="line">	id3[/平行四边形/]</span><br><span class="line">	id4[\反向平行四边形\]</span><br><span class="line">	id5[/梯形\]</span><br><span class="line">	id6[\反向梯形/]</span><br></pre></td></tr></table></figure>

<h2 id="连线样式"><a href="#连线样式" class="headerlink" title="连线样式"></a>连线样式</h2><ul>
<li>实线箭头：分为无文本箭头和有文本箭头，有文本箭头有2种书写格式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a--&gt;b--文本1--&gt;c--&gt;|文本2|d</span><br></pre></td></tr></table></figure>

<ul>
<li>粗实线箭头：分为无文本箭头和有文本箭头</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a==&gt;b==文本==&gt;c</span><br></pre></td></tr></table></figure>

<ul>
<li>虚线箭头：分为无文本箭头和有文本箭头</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a-.-&gt;b-.文本.-&gt;c</span><br></pre></td></tr></table></figure>

<ul>
<li>无箭头线：即以上三种连线去掉箭头后的形式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a---b</span><br><span class="line">b--文本1---c</span><br><span class="line">c---|文本2|d</span><br><span class="line">d===e</span><br><span class="line">e==文本3===f</span><br><span class="line">f-.-g</span><br><span class="line">g-.文本.-h</span><br></pre></td></tr></table></figure>

<ul>
<li>其他连线：需要将<code>graph</code>关键字改为<code>flowchart</code>，除了新增加的连线形式外，上面三种线的渲染效果也会不同</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    A o--o B</span><br><span class="line">    B &lt;--&gt; C</span><br><span class="line">    C x--x D</span><br><span class="line">    </span><br><span class="line">    旧连线 --文本--&gt; 也会不同</span><br></pre></td></tr></table></figure>

<ul>
<li>延长连线：增加相应字符即可，如下图中的B到E，连线中增加了一个<code>-</code>。字符可多次添加。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[Start] --&gt; B&#123;Is it?&#125;;</span><br><span class="line">    B --&gt;|Yes| C[OK];</span><br><span class="line">    C --&gt; D[Rethink];</span><br><span class="line">    D --&gt; B;</span><br><span class="line">    B ---&gt;|No| E[End];</span><br></pre></td></tr></table></figure>



<h2 id="连线形式"><a href="#连线形式" class="headerlink" title="连线形式"></a>连线形式</h2><ul>
<li>直链</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">   D[Rethink1&lt;br/&gt;Rethink2] -- text --&gt; B -- text2 --&gt; C</span><br></pre></td></tr></table></figure>

<ul>
<li>多重链：可以使用<code>&amp;</code>字符，或单个描述</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">   a --&gt; b &amp; c--&gt; d</span><br><span class="line">   </span><br><span class="line">   A &amp; B--&gt; C &amp; D</span><br><span class="line">   </span><br><span class="line">    X --&gt; M</span><br><span class="line">    X --&gt; N</span><br><span class="line">    Y --&gt; M</span><br><span class="line">    Y --&gt; N</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>子图：需要将<code>graph</code>关键字改为<code>flowchart</code>，在代码段的开始加入<code>subgraph</code>，尾部加入<code>end</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">    c1--&gt;a2</span><br><span class="line">    subgraph one</span><br><span class="line">    a1--&gt;a2</span><br><span class="line">    end</span><br><span class="line">    subgraph two</span><br><span class="line">    b1--&gt;b2</span><br><span class="line">    end</span><br><span class="line">    subgraph three</span><br><span class="line">    c1--&gt;c2</span><br><span class="line">    end</span><br><span class="line">    one --&gt; two</span><br><span class="line">    three --&gt; two</span><br><span class="line">    two --&gt; c2</span><br></pre></td></tr></table></figure>

<ul>
<li>注释：在行首加入<code>%%</code>即可。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">%%这是一条注释，在渲染图中不可见</span><br><span class="line">    A[Hard edge] --&gt;|Link text| B(Round edge)</span><br><span class="line">    B --&gt; C&#123;Decision&#125;</span><br><span class="line">    C --&gt;|One| D[Result one]</span><br><span class="line">    C --&gt;|Two| E[Result two]</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2020/04/30/designing-pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/30/designing-pattern/" class="post-title-link" itemprop="url">设计模式也可以这么简单(转自JavaDoop)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-30 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-30T00:00:00+08:00">2020-04-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 23:22:01" itemprop="dateModified" datetime="2025-04-27T23:22:01+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Designing-Pattern"><a href="#Designing-Pattern" class="headerlink" title="Designing Pattern"></a>Designing Pattern</h1><p>一直想写一篇介绍设计模式的文章，让读者可以很快看完，而且一看就懂，看懂就会用，同时不会将各个模式搞混。自认为本文还是写得不错的😂😂😂，花了不少心思来写这文章和做图，力求让读者真的能看着简单同时有所收获。</p>
<p>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 <em>Gang of Four</em> (<em>GoF</em>) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。</p>
<p>有一些重要的设计原则在开篇和大家分享下，这些原则将贯通全文：</p>
<ol>
<li>面向接口编程，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。</li>
<li>职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。</li>
<li>对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。</li>
</ol>
<p><strong>创建型模式比较简单，但是会比较没有意思，结构型和行为型比较有意思。</strong></p>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>和名字一样简单，非常简单，直接上代码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;noodle&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Food</span> <span class="variable">noodle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LanZhouNoodle</span>();</span><br><span class="line">            noodle.addSpicy(<span class="string">&quot;more&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> noodle;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;chicken&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Food</span> <span class="variable">chicken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HuangMenChicken</span>();</span><br><span class="line">            chicken.addCondiment(<span class="string">&quot;potato&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> chicken;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。</em></p>
<p>简单地说，简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。</p>
<blockquote>
<p>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。</p>
</blockquote>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line">    Food <span class="title function_">makeFood</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChineseFoodFactory</span> <span class="keyword">implements</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanFoodFactory</span> <span class="keyword">implements</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanFoodA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanFoodB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。</p>
<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 先选择一个具体的工厂</span></span><br><span class="line">        <span class="type">FoodFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodFactory</span>();</span><br><span class="line">        <span class="comment">// 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象</span></span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> factory.makeFood(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然都是调用 makeFood(“A”)  制作 A 类食物，但是，不同的工厂生产出来的完全不一样。</p>
<p>第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。</p>
<p><strong>核心在于，我们需要在第一步选好我们需要的工厂</strong>。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。</p>
<p>虽然简单，不过我也把所有的构件都画到一张图上，这样读者看着比较清晰：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/factory-1.png" alt="factory-1"></p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。</p>
<p>一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。</p>
<p>因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下图：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/abstract-factory-1.png" alt="factory-1"></p>
<p>这个时候的客户端调用是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到 Intel 的 CPU</span></span><br><span class="line"><span class="type">CPUFactory</span> <span class="variable">cpuFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntelCPUFactory</span>();</span><br><span class="line"><span class="type">CPU</span> <span class="variable">cpu</span> <span class="operator">=</span> intelCPUFactory.makeCPU();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到 AMD 的主板</span></span><br><span class="line"><span class="type">MainBoardFactory</span> <span class="variable">mainBoardFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AmdMainBoardFactory</span>();</span><br><span class="line"><span class="type">MainBoard</span> <span class="variable">mainBoard</span> <span class="operator">=</span> mainBoardFactory.make();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组装 CPU 和主板</span></span><br><span class="line"><span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(cpu, mainBoard);</span><br></pre></td></tr></table></figure>

<p>单独看 CPU 工厂和主板工厂，它们分别是前面我们说的<strong>工厂模式</strong>。这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。</p>
<p>但是，这种方式有一个问题，那就是如果 <strong>Intel 家产的 CPU 和 AMD 产的主板不能兼容使用</strong>，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。</p>
<p>下面就是我们要说的<strong>产品族</strong>的概念，它代表了组成某个产品的一系列附件的集合：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/abstract-factory-2.png" alt="abstract-factory-2"></p>
<p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/abstract-factory-3.png" alt="abstract-factory-3"></p>
<p>这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一步就要选定一个“大厂”</span></span><br><span class="line">    <span class="type">ComputerFactory</span> <span class="variable">cf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AmdFactory</span>();</span><br><span class="line">    <span class="comment">// 从这个大厂造 CPU</span></span><br><span class="line">    <span class="type">CPU</span> <span class="variable">cpu</span> <span class="operator">=</span> cf.makeCPU();</span><br><span class="line">    <span class="comment">// 从这个大厂造主板</span></span><br><span class="line">    <span class="type">MainBoard</span> <span class="variable">board</span> <span class="operator">=</span> cf.makeMainBoard();</span><br><span class="line">  	<span class="comment">// 从这个大厂造硬盘</span></span><br><span class="line">  	<span class="type">HardDisk</span> <span class="variable">hardDisk</span> <span class="operator">=</span> cf.makeHardDisk();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将同一个厂子出来的 CPU、主板、硬盘组装在一起</span></span><br><span class="line">    <span class="type">Computer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(cpu, board, hardDisk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>对修改关闭，对扩展开放</strong>这个设计原则。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式用得最多，错得最多。</p>
<p>饿汉模式最简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 首先，将 new Singleton() 堵死</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 瞎写一个静态方法。这里想说的是，如果我们只是要调用 Singleton.getDate(...)，</span></span><br><span class="line">    <span class="comment">// 本来是不想要生成 Singleton 实例的，不过没办法，已经生成了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">getDate</span><span class="params">(String mode)</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>很多人都能说出饿汉模式的缺点，可是我觉得生产过程中，很少碰到这种情况：你定义了一个单例的类，不需要其实例，可是你却把一个或几个你会用到的静态方法塞到这个类中。</p>
</blockquote>
<p>饱汉模式最容易出错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 首先，也是先堵死 new Singleton() 这条路</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 这一次判断也是必须的，不然会有并发问题</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>双重检查，指的是两次检查 instance 是否为 null。</p>
<p>volatile 在这里是需要的，希望能引起读者的关注。</p>
<p>很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。</p>
</blockquote>
<p>嵌套类最经典，以后大家就用它吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton3</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，很多人都会把这个<strong>嵌套类</strong>说成是<strong>静态内部类</strong>，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。</p>
</blockquote>
<p>最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。</p>
<p>虽然我们平时很少看到用枚举来实现单例，但是在 RxJava 的源码中，有很多地方都用了枚举来实现单例。</p>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>经常碰见的 XxxBuilder 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodBuilder</span>().a().b().c().build();</span><br><span class="line"><span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> Food.builder().a().b().c().build();</span><br></pre></td></tr></table></figure>

<p>套路就是先 new 一个 Builder，然后可以链式地调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了。</p>
<p>来一个中规中矩的建造者模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 下面是“一堆”的属性</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化，不然客户端就会直接调用构造方法了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(String name, String password, String nickName, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯，</span></span><br><span class="line">    <span class="comment">// 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserBuilder <span class="title function_">builder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserBuilder</span> &#123;</span><br><span class="line">        <span class="comment">// 下面是和 User 一模一样的一堆属性</span></span><br><span class="line">        <span class="keyword">private</span> String  name;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line">        <span class="keyword">private</span> String nickName;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">UserBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链式调用设置各个属性值，返回 this，即 UserBuilder</span></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">name</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">password</span><span class="params">(String password)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.password = password;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">nickName</span><span class="params">(String nickName)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder <span class="title function_">age</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。</span></span><br><span class="line">        <span class="comment">// 当然，可以在 “复制” 之前做点检验</span></span><br><span class="line">        <span class="keyword">public</span> User <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (name == <span class="literal">null</span> || password == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名和密码必填&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (age &lt;= <span class="number">0</span> || age &gt;= <span class="number">150</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;年龄不合法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 还可以做赋予”默认值“的功能</span></span><br><span class="line">          	<span class="keyword">if</span> (nickName == <span class="literal">null</span>) &#123;</span><br><span class="line">                nickName = name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(name, password, nickName, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心是：先把所有的属性都设置给 Builder，然后 build() 方法的时候，将这些属性<strong>复制</strong>给实际产生的对象。</p>
<p>看看客户端的调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">d</span> <span class="operator">=</span> User.builder()</span><br><span class="line">                .name(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;pAss12345&quot;</span>)</span><br><span class="line">                .age(<span class="number">25</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说实话，建造者模式的<strong>链式</strong>写法很吸引人，但是，多写了很多“无用”的 builder 的代码，感觉这个模式没什么用。不过，当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多。我们可以在 <strong>Builder 的构造方法</strong>中强制让调用者提供必填字段，还有，在 build() 方法中校验各个参数比在 User 的构造方法中校验，代码要优雅一些。</p>
<blockquote>
<p>题外话，强烈建议读者使用 lombok，用了 lombok 以后，上面的一大堆代码会变成如下这样:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String  name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>怎么样，省下来的时间是不是又可以干点别的了。</p>
</blockquote>
<p>当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，User 的 getter 方法不变，所有的 setter 方法都让其 <strong>return this</strong> 就可以了，然后就可以像下面这样调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>().setName(<span class="string">&quot;&quot;</span>).setPassword(<span class="string">&quot;&quot;</span>).setAge(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>很多人是这么用的，但是笔者觉得其实这种写法非常地不优雅，不是很推荐使用。</p>
</blockquote>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>这是我要说的创建型模式的最后一个设计模式了。</p>
<p>原型模式很简单：有一个原型<strong>实例</strong>，基于这个原型实例产生新的实例，也就是“克隆”了。</p>
<p>Object 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先<strong>实现 Cloneable 接口</strong>，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出 CloneNotSupportedException 异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。</p>
</blockquote>
<p>原型模式了解到这里我觉得就够了，各种变着法子说这种代码或那种代码是原型模式，没什么意义。</p>
<h3 id="创建型模式总结"><a href="#创建型模式总结" class="headerlink" title="创建型模式总结"></a>创建型模式总结</h3><p>创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是<strong>面向对象</strong>的代码，所以我们第一步当然是需要创建一个对象了。</p>
<p>简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。</p>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>前面创建型模式介绍了创建对象的一些设计模式，这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>第一个要介绍的代理模式是最常使用的模式之一了，用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。</p>
<p>既然说是<strong>代理</strong>，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。</p>
<blockquote>
<p>理解<strong>代理</strong>这个词，这个模式其实就简单了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FoodService</span> &#123;</span><br><span class="line">    Food <span class="title function_">makeChicken</span><span class="params">()</span>;</span><br><span class="line">    Food <span class="title function_">makeNoodle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">FoodService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeChicken</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="type">Food</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chicken</span>()</span><br><span class="line">        f.setChicken(<span class="string">&quot;1kg&quot;</span>);</span><br><span class="line">      	f.setSpicy(<span class="string">&quot;1g&quot;</span>);</span><br><span class="line">      	f.setSalt(<span class="string">&quot;3g&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeNoodle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Food</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Noodle</span>();</span><br><span class="line">        f.setNoodle(<span class="string">&quot;500g&quot;</span>);</span><br><span class="line">        f.setSalt(<span class="string">&quot;5g&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理要表现得“就像是”真实实现类，所以需要实现 FoodService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">FoodService</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 内部一定要有一个真实的实现类，当然也可以通过构造方法注入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">FoodService</span> <span class="variable">foodService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodServiceImpl</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeChicken</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们马上要开始制作鸡肉了&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，</span></span><br><span class="line">        <span class="comment">// 代理只是在核心代码前后做些“无足轻重”的事情</span></span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> foodService.makeChicken();</span><br><span class="line">      </span><br><span class="line">        System.out.println(<span class="string">&quot;鸡肉制作完成啦，加点胡椒粉&quot;</span>); <span class="comment">// 增强</span></span><br><span class="line">      	food.addCondiment(<span class="string">&quot;pepper&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeNoodle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备制作拉面~&quot;</span>);</span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> foodService.makeNoodle();</span><br><span class="line">        System.out.println(<span class="string">&quot;制作完成啦&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用，注意，我们要用代理来实例化接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里用代理类来实例化</span></span><br><span class="line"><span class="type">FoodService</span> <span class="variable">foodService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodServiceProxy</span>();</span><br><span class="line">foodService.makeChicken();</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.javadoop.com/blogimages/design-pattern/proxy-1.png" alt="proxy"></p>
<p>我们发现没有，代理模式说白了就是做 <strong>“方法包装”</strong> 或做 <strong>“方法增强”</strong>。在面向切面编程中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。</p>
<p>说到动态代理，又可以展开说，Spring 中实现动态代理有两种，一种是如果我们的类定义了接口，如 UserService 接口和 UserServiceImpl 实现，那么采用 JDK 的动态代理，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包，性能还不错。</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>说完代理模式，说适配器模式，是因为它们很相似，这里可以做个比较。</p>
<p>适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配。</p>
<p>适配器模式总体来说分三种：默认适配器模式、对象适配器模式、类适配器模式。先不急着分清楚这几个，先看看例子再说。</p>
<h4 id="默认适配器模式"><a href="#默认适配器模式" class="headerlink" title="默认适配器模式"></a>默认适配器模式</h4><p>首先，我们先看看最简单的适配器模式**默认适配器模式(Default Adapter)**是怎么样的。</p>
<p>我们用 Appache commons-io 包中的 FileAlterationListener 做例子，此接口定义了很多的方法，用于对文件或文件夹进行监控，一旦发生了对应的操作，就会触发相应的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FileAlterationListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryCreate</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryChange</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDirectoryDelete</span><span class="params">(<span class="keyword">final</span> File directory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileChange</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此接口的一大问题是抽象方法太多了，如果我们要用这个接口，意味着我们要实现每一个抽象方法，如果我们只是想要监控文件夹中的<strong>文件创建</strong>和<strong>文件删除</strong>事件，可是我们还是不得不实现所有的方法，很明显，这不是我们想要的。</p>
<p>所以，我们需要下面的一个<strong>适配器</strong>，它用于实现上面的接口，但是<strong>所有的方法都是空方法</strong>，这样，我们就可以转而定义自己的类来继承下面这个类即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileAlterationListenerAdaptor</span> <span class="keyword">implements</span> <span class="title class_">FileAlterationListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDirectoryCreate</span><span class="params">(<span class="keyword">final</span> File directory)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDirectoryChange</span><span class="params">(<span class="keyword">final</span> File directory)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDirectoryDelete</span><span class="params">(<span class="keyword">final</span> File directory)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileChange</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们可以定义以下类，我们仅仅需要实现我们想实现的方法就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileMonitor</span> <span class="keyword">extends</span> <span class="title class_">FileAlterationListenerAdaptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">        <span class="comment">// 文件创建</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span> &#123;</span><br><span class="line">        <span class="comment">// 文件删除</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，上面说的只是适配器模式的其中一种，也是最简单的一种，无需多言。下面，再介绍<strong>“正统的”</strong>适配器模式。</p>
<h4 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h4><p>来看一个《Head First 设计模式》中的一个例子，我稍微修改了一下，看看怎么将鸡适配成鸭，这样鸡也能当鸭来用。因为，现在鸭这个接口，我们没有合适的实现类可以用，所以需要适配器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span>; <span class="comment">// 鸭的呱呱叫</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 飞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span>; <span class="comment">// 鸡的咕咕叫</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 飞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WildCock</span> <span class="keyword">implements</span> <span class="title class_">Cock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;咕咕叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸡也会飞哦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>鸭接口有 fly() 和 quare() 两个方法，鸡 Cock 如果要冒充鸭，fly() 方法是现成的，但是鸡不会鸭的呱呱叫，没有 quack() 方法。这个时候就需要适配了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CockAdapter</span> <span class="keyword">implements</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">  </span><br><span class="line">    Cock cock;</span><br><span class="line">    <span class="comment">// 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">CockAdapter</span><span class="params">(Cock cock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cock = cock;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 实现鸭的呱呱叫方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 内部其实是一只鸡的咕咕叫</span></span><br><span class="line">        cock.gobble();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="meta">@Override</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        cock.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用很简单了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 有一只野鸡</span></span><br><span class="line">  	<span class="type">Cock</span> <span class="variable">wildCock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WildCock</span>();</span><br><span class="line">  	<span class="comment">// 成功将野鸡适配成鸭</span></span><br><span class="line">  	<span class="type">Duck</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CockAdapter</span>(wildCock);</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，大家也就知道了适配器模式是怎么回事了。无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的。</p>
<p>我们用一个图来简单说明下：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/adapter-1.png" alt="adapter-1"></p>
<p>上图应该还是很容易理解的，我就不做更多的解释了。下面，我们看看类适配模式怎么样的。</p>
<h4 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h4><p>废话少说，直接上图：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/adapter-2.png" alt="adapter-1"></p>
<p>看到这个图，大家应该很容易理解的吧，通过继承的方法，适配器自动获得了所需要的大部分方法。这个时候，客户端使用更加简单，直接 <code>Target t = new SomeAdapter();</code> 就可以了。</p>
<h4 id="适配器模式总结"><a href="#适配器模式总结" class="headerlink" title="适配器模式总结"></a>适配器模式总结</h4><ol>
<li><p>类适配和对象适配的异同</p>
<blockquote>
<p>一个采用继承，一个采用组合；</p>
<p>类适配属于静态实现，对象适配属于组合的动态实现，对象适配需要多实例化一个对象。</p>
<p>总体来说，对象适配用得比较多。</p>
</blockquote>
</li>
<li><p>适配器模式和代理模式的异同</p>
<p>比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/adapter-5.png" alt="adapter-5"></p>
</li>
</ol>
<h3 id="桥梁模式"><a href="#桥梁模式" class="headerlink" title="桥梁模式"></a>桥梁模式</h3><p>理解桥梁模式，其实就是理解代码抽象和解耦。</p>
<p>我们首先需要一个桥梁，它是一个接口，定义提供的接口方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是一系列实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedPen</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用红色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenPen</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用绿色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BluePen</span> <span class="keyword">implements</span> <span class="title class_">DrawAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用蓝色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个抽象类，此类的实现类都需要使用 DrawAPI：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> DrawAPI drawAPI;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Shape</span><span class="params">(DrawAPI drawAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.drawAPI = drawAPI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义抽象类的子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 圆形</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> radius;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">int</span> radius, DrawAPI drawAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(drawAPI);</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        drawAPI.draw(radius, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 长方形</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, DrawAPI drawAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(drawAPI);</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        drawAPI.draw(<span class="number">0</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们来看客户端演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Shape</span> <span class="variable">greenCircle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">10</span>, <span class="keyword">new</span> <span class="title class_">GreenPen</span>());</span><br><span class="line">    <span class="type">Shape</span> <span class="variable">redRectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">4</span>, <span class="number">8</span>, <span class="keyword">new</span> <span class="title class_">RedPen</span>());</span><br><span class="line">    greenCircle.draw();</span><br><span class="line">    redRectangle.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能大家看上面一步步还不是特别清晰，我把所有的东西整合到一张图上：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/bridge-1.png" alt="bridge-1"></p>
<p>这回大家应该就知道抽象在哪里，怎么解耦了吧。桥梁模式的优点也是显而易见的，就是非常容易进行扩展。</p>
<blockquote>
<p>本节引用了<a target="_blank" rel="noopener" href="https://www.tutorialspoint.com/design_pattern/bridge_pattern.htm">这里</a>的例子，并对其进行了修改。</p>
</blockquote>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>要把装饰模式说清楚明白，不是件容易的事情。也许读者知道 <strong>Java IO</strong> 中的几个类是典型的装饰模式的应用，但是读者不一定清楚其中的关系，也许看完就忘了，希望看完这节后，读者可以对其有更深的感悟。</p>
<p>首先，我们先看一个简单的图，看这个图的时候，了解下层次结构就可以了：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/decorator-1.png" alt="decorator-1"></p>
<p>我们来说说装饰模式的出发点，从图中可以看到，接口 <code>Component</code> 其实已经有了 <code>ConcreteComponentA</code> 和 <code>ConcreteComponentB</code> 两个实现类了，但是，如果我们要<strong>增强</strong>这两个实现类的话，我们就可以采用装饰模式，用具体的装饰器来<strong>装饰</strong>实现类，以达到增强的目的。</p>
<blockquote>
<p>从名字来简单解释下装饰器。既然说是装饰，那么往往就是<strong>添加小功能</strong>这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的多层包装方式，但是那样的话代码就复杂了。</p>
</blockquote>
<p>首先明白一些简单的概念，从图中我们看到，所有的具体装饰者们 <strong>ConcreteDecorator</strong>* 都可以作为 Component 来使用，因为它们都实现了 Component 中的所有接口。它们和 Component 实现类 ConcreteComponent* 的区别是，它们只是装饰者，起<strong>装饰</strong>作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中<strong>加了层皮来装饰</strong>而已。</p>
<blockquote>
<p>注意这段话中混杂在各个名词中的 Component 和 Decorator，别搞混了。</p>
</blockquote>
<p>下面来看看一个例子，先把装饰模式弄清楚，然后再介绍下 java io 中的装饰模式的应用。</p>
<p>最近大街上流行起来了“快乐柠檬”，我们把快乐柠檬的饮料分为三类：红茶、绿茶、咖啡，在这三大类的基础上，又增加了许多的口味，什么金桔柠檬红茶、金桔柠檬珍珠绿茶、芒果红茶、芒果绿茶、芒果珍珠红茶、烤珍珠红茶、烤珍珠芒果绿茶、椰香胚芽咖啡、焦糖可可咖啡等等，每家店都有很长的菜单，但是仔细看下，其实原料也没几样，但是可以搭配出很多组合，如果顾客需要，很多没出现在菜单中的饮料他们也是可以做的。</p>
<p>在这个例子中，红茶、绿茶、咖啡是最基础的饮料，其他的像金桔柠檬、芒果、珍珠、椰果、焦糖等都属于装饰用的。当然，在开发中，我们确实可以像门店一样，开发这些类：LemonBlackTea、LemonGreenTea、MangoBlackTea、MangoLemonGreenTea……但是，很快我们就发现，这样子干肯定是不行的，这会导致我们需要组合出所有的可能，而且如果客人需要在红茶中加双份柠檬怎么办？三份柠檬怎么办？</p>
<p>不说废话了，上代码。</p>
<p>首先，定义饮料抽象基类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">  	<span class="comment">// 返回描述</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">  	<span class="comment">// 返回价格</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是三个基础饮料实现类，红茶、绿茶和咖啡：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlackTea</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">  	<span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;红茶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenTea</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;绿茶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...<span class="comment">// 咖啡省略</span></span><br></pre></td></tr></table></figure>

<p>定义调料，也就是装饰者的基类，此类必须继承自 Beverage：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Condiment</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们来定义柠檬、芒果等具体的调料，它们属于装饰者，毫无疑问，这些调料肯定都需要继承调料 Condiment 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lemon</span> <span class="keyword">extends</span> <span class="title class_">Condiment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Beverage bevarage;</span><br><span class="line">    <span class="comment">// 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶，</span></span><br><span class="line">    <span class="comment">// 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Lemon</span><span class="params">(Beverage bevarage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bevarage = bevarage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 装饰</span></span><br><span class="line">        <span class="keyword">return</span> bevarage.getDescription() + <span class="string">&quot;, 加柠檬&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 装饰</span></span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">2</span>; <span class="comment">// 加柠檬需要 2 元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mango</span> <span class="keyword">extends</span> <span class="title class_">Condiment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Beverage bevarage;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mango</span><span class="params">(Beverage bevarage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bevarage = bevarage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bevarage.getDescription() + <span class="string">&quot;, 加芒果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">3</span>; <span class="comment">// 加芒果需要 3 元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...<span class="comment">// 给每一种调料都加一个类</span></span><br></pre></td></tr></table></figure>

<p>看客户端调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先，我们需要一个基础饮料，红茶、绿茶或咖啡</span></span><br><span class="line">    <span class="type">Beverage</span> <span class="variable">beverage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GreenTea</span>();</span><br><span class="line">    <span class="comment">// 开始装饰</span></span><br><span class="line">    beverage = <span class="keyword">new</span> <span class="title class_">Lemon</span>(beverage); <span class="comment">// 先加一份柠檬</span></span><br><span class="line">    beverage = <span class="keyword">new</span> <span class="title class_">Mongo</span>(beverage); <span class="comment">// 再加一份芒果</span></span><br><span class="line"></span><br><span class="line">    System.out.println(beverage.getDescription() + <span class="string">&quot; 价格：￥&quot;</span> + beverage.cost());</span><br><span class="line">    <span class="comment">//&quot;绿茶, 加柠檬, 加芒果 价格：￥16&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们需要 <strong>芒果-珍珠-双份柠檬-红茶</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Beverage</span> <span class="variable">beverage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mongo</span>(<span class="keyword">new</span> <span class="title class_">Pearl</span>(<span class="keyword">new</span> <span class="title class_">Lemon</span>(<span class="keyword">new</span> <span class="title class_">Lemon</span>(<span class="keyword">new</span> <span class="title class_">BlackTea</span>()))));</span><br></pre></td></tr></table></figure>

<p>是不是很变态？</p>
<p>看看下图可能会清晰一些：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/decorator-2.png" alt="decorator-2"></p>
<p>到这里，大家应该已经清楚装饰模式了吧。</p>
<p>下面，我们再来说说 java IO 中的装饰模式。看下图 InputStream 派生出来的部分类：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/decorator-3.png" alt="decorator-3"></p>
<p>我们知道 InputStream 代表了输入流，具体的输入来源可以是文件（FileInputStream）、管道（PipedInputStream）、数组（ByteArrayInputStream）等，这些就像前面奶茶的例子中的红茶、绿茶，属于基础输入流。</p>
<p>FilterInputStream 承接了装饰模式的关键节点，它的实现类是一系列装饰器，比如 BufferedInputStream 代表用缓冲来装饰，也就使得输入流具有了缓冲的功能，LineNumberInputStream 代表用行号来装饰，在操作的时候就可以取得行号了，DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的基本类型值。</p>
<p>当然，在 java IO 中，如果我们使用装饰器的话，就不太适合面向接口编程了，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LineNumberInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>这样的结果是，InputStream 还是不具有读取行号的功能，因为读取行号的方法定义在 LineNumberInputStream 类中。</p>
<p>我们应该像下面这样使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(</span><br><span class="line">  							<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">                              	<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;&quot;</span>)));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的。</p>
</blockquote>
<h3 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h3><p>门面模式（也叫外观模式，Facade Pattern）在许多源码中有使用，比如 slf4j 就可以理解为是门面模式的应用。这是一个简单的设计模式，我们直接上代码再说吧。</p>
<p>首先，我们定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义几个实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Circle::draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Rectangle::draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 画一个圆形</span></span><br><span class="line">  	<span class="type">Shape</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">  	circle.draw();</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 画一个长方形</span></span><br><span class="line">  	<span class="type">Shape</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">  	rectangle.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是我们常写的代码，我们需要画圆就要先实例化圆，画长方形就需要先实例化一个长方形，然后再调用相应的 draw() 方法。</p>
<p>下面，我们看看怎么用门面模式来让客户端调用更加友好一些。</p>
<p>我们先定义一个门面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeMaker</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Shape circle;</span><br><span class="line">   <span class="keyword">private</span> Shape rectangle;</span><br><span class="line">   <span class="keyword">private</span> Shape square;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ShapeMaker</span><span class="params">()</span> &#123;</span><br><span class="line">      circle = <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">      rectangle = <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">      square = <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">()</span>&#123;</span><br><span class="line">      circle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">()</span>&#123;</span><br><span class="line">      rectangle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawSquare</span><span class="params">()</span>&#123;</span><br><span class="line">      square.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看现在客户端怎么调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">ShapeMaker</span> <span class="variable">shapeMaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeMaker</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 客户端调用现在更加清晰了</span></span><br><span class="line">  shapeMaker.drawCircle();</span><br><span class="line">  shapeMaker.drawRectangle();</span><br><span class="line">  shapeMaker.drawSquare();		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>门面模式的优点显而易见，客户端不再需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。</p>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。</p>
<p>直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，同时还有下属员工集合（虽然可能集合为空），而下属员工和自己的结构是一样的，也有姓名、部门这些属性，同时也有他们的下属员工集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String dept;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> salary;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Employee&gt; subordinates; <span class="comment">// 下属</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name,String dept, <span class="type">int</span> sal)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.dept = dept;</span><br><span class="line">      <span class="built_in">this</span>.salary = sal;</span><br><span class="line">      subordinates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Employee e)</span> &#123;</span><br><span class="line">      subordinates.add(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Employee e)</span> &#123;</span><br><span class="line">      subordinates.remove(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getSubordinates</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> subordinates;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="string">&quot;Employee :[ Name : &quot;</span> + name + <span class="string">&quot;, dept : &quot;</span> + dept + <span class="string">&quot;, salary :&quot;</span> + salary+<span class="string">&quot; ]&quot;</span>);</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常，这种类需要定义 add(node)、remove(node)、getChildren() 这些方法。</p>
<p>这说的其实就是组合模式，这种简单的模式我就不做过多介绍了，相信各位读者也不喜欢看我写废话。</p>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>英文是 Flyweight Pattern，不知道是谁最先翻译的这个词，感觉这翻译真的不好理解，我们试着强行关联起来吧。Flyweight 是轻量级的意思，享元分开来说就是 共享 元器件，也就是复用已经生成的对象，这种做法当然也就是轻量级的了。</p>
<p>复用对象最简单的方式是，用一个 HashMap 来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中。</p>
<p>这种简单的代码我就不演示了。</p>
<h3 id="结构型模式总结"><a href="#结构型模式总结" class="headerlink" title="结构型模式总结"></a>结构型模式总结</h3><p>前面，我们说了代理模式、适配器模式、桥梁模式、装饰模式、门面模式、组合模式和享元模式。读者是否可以分别把这几个模式说清楚了呢？在说到这些模式的时候，心中是否有一个清晰的图或处理流程在脑海里呢？</p>
<p>代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。</p>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式太常用了，所以把它放到最前面进行介绍。它比较简单，我就不废话，直接用代码说事吧。</p>
<p>下面设计的场景是，我们需要画一个图形，可选的策略就是用红色笔来画，还是绿色笔来画，或者蓝色笔来画。</p>
<p>首先，先定义一个策略接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们定义具体的几个策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedPen</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;用红色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreenPen</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;用绿色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BluePen</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;用蓝色笔画图，radius:&quot;</span> + radius + <span class="string">&quot;, x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用策略的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">executeDraw</span><span class="params">(<span class="type">int</span> radius, <span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> strategy.draw(radius, x, y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">BluePen</span>()); <span class="comment">// 使用绿色笔来画</span></span><br><span class="line">  	context.executeDraw(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>放到一张图上，让大家看得清晰些：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/strategy-1.png" alt="strategy-1"></p>
<p>这个时候，大家有没有联想到结构型模式中的桥梁模式，它们其实非常相似，我把桥梁模式的图拿过来大家对比下：</p>
<p><img src="https://assets.javadoop.com/blogimages/design-pattern/bridge-1.png" alt="bridge-1"></p>
<p>要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。桥梁模式的耦合更低，结构更复杂一些。</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，观察者订阅自己关心的主题和主题有数据变化后通知观察者们。</p>
<p>首先，需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">        <span class="comment">// 数据已变更，通知观察者们</span></span><br><span class="line">        notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知观察者们</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyAllObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义观察者接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Subject subject;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。</p>
<p>我们来定义具体的几个观察者类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryObserver</span> <span class="keyword">extends</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">// 在构造方法中进行订阅主题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryObserver</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">        <span class="comment">// 通常在构造方法中将 this 发布出去的操作一定要小心</span></span><br><span class="line">        <span class="built_in">this</span>.subject.attach(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该方法由主题类在数据变更的时候进行调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> Integer.toBinaryString(subject.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;订阅的数据发生变化，新的数据处理为二进制值为：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HexaObserver</span> <span class="keyword">extends</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HexaObserver</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">        <span class="built_in">this</span>.subject.attach(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> Integer.toHexString(subject.getState()).toUpperCase();</span><br><span class="line">        System.out.println(<span class="string">&quot;订阅的数据发生变化，新的数据处理为十六进制值为：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端使用也非常简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 先定义一个主题</span></span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line">    <span class="comment">// 定义观察者</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BinaryObserver</span>(subject1);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HexaObserver</span>(subject1);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 模拟数据变更，这个时候，观察者们的 update 方法将会被调用</span></span><br><span class="line">    subject.setState(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">订阅的数据发生变化，新的数据处理为二进制值为：1011</span><br><span class="line">订阅的数据发生变化，新的数据处理为十六进制值为：B</span><br></pre></td></tr></table></figure>

<p>当然，jdk 也提供了相似的支持，具体的大家可以参考 java.util.Observable 和 java.util.Observer 这两个类。</p>
<p>实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。</p>
<p>还有，即使是上面的这个代码，也会有很多变种，大家只要记住核心的部分，那就是一定有一个地方存放了所有的观察者，然后在事件发生的时候，遍历观察者，调用它们的回调函数。</p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了。</p>
<p>有这么一个场景，用户参加一个活动可以领取奖品，但是活动需要进行很多的规则校验然后才能放行，比如首先需要校验用户是否是新用户、今日参与人数是否有限额、全场参与人数是否有限额等等。设定的规则都通过后，才能让用户领走奖品。</p>
<blockquote>
<p>如果产品给你这个需求的话，我想大部分人一开始肯定想的就是，用一个 List 来存放所有的规则，然后 foreach 执行一下每个规则就好了。不过，读者也先别急，看看责任链模式和我们说的这个有什么不一样？</p>
</blockquote>
<p>首先，我们要定义流程上节点的基类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">protected</span> RuleHandler successor;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(RuleHandler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> RuleHandler <span class="title function_">getSuccessor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们需要定义具体的每个节点了。</p>
<p>校验用户是否是新用户：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewUserRuleHandler</span> <span class="keyword">extends</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.isNewUser()) &#123;</span><br><span class="line">            <span class="comment">// 如果有后继节点的话，传递下去</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该活动仅限新用户参与&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>校验用户所在地区是否可以参与：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocationRuleHandler</span> <span class="keyword">extends</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allowed</span> <span class="operator">=</span> activityService.isSupportedLocation(context.getLocation);</span><br><span class="line">        <span class="keyword">if</span> (allowed) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;非常抱歉，您所在的地区无法参与本次活动&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>校验奖品是否已领完：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LimitRuleHandler</span> <span class="keyword">extends</span> <span class="title class_">RuleHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">remainedTimes</span> <span class="operator">=</span> activityService.queryRemainedTimes(context); <span class="comment">// 查询剩余奖品</span></span><br><span class="line">        <span class="keyword">if</span> (remainedTimes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.getSuccessor().apply(userInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;您来得太晚了，奖品被领完了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">RuleHandler</span> <span class="variable">newUserHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewUserRuleHandler</span>();</span><br><span class="line">    <span class="type">RuleHandler</span> <span class="variable">locationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocationRuleHandler</span>();</span><br><span class="line">    <span class="type">RuleHandler</span> <span class="variable">limitHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LimitRuleHandler</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 假设本次活动仅校验地区和奖品数量，不校验新老用户</span></span><br><span class="line">    locationHandler.setSuccessor(limitHandler);</span><br><span class="line">  </span><br><span class="line">    locationHandler.apply(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码其实很简单，就是先定义好一个链表，然后在通过任意一节点后，如果此节点有后继节点，那么传递下去。</p>
<p>至于它和我们前面说的用一个 List 存放需要执行的规则的做法有什么异同，留给读者自己琢磨吧。</p>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>在含有继承结构的代码中，模板方法模式是非常常用的。</p>
<p>通常会有一个抽象类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractTemplate</span> &#123;</span><br><span class="line">    <span class="comment">// 这就是模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        init();</span><br><span class="line">        apply(); <span class="comment">// 这个是重点</span></span><br><span class="line">        end(); <span class="comment">// 可以作为钩子方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init 抽象层已经实现，子类也可以选择覆写&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 留给子类实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。</p>
<p>我们写一个实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteTemplate</span> <span class="keyword">extends</span> <span class="title class_">AbstractTemplate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类实现抽象方法 apply&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AbstractTemplate</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteTemplate</span>();</span><br><span class="line">    <span class="comment">// 调用模板方法</span></span><br><span class="line">    t.templateMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码其实很简单，基本上看到就懂了，关键是要学会用到自己的代码中。</p>
<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>update: 2017-10-19</p>
<p>废话我就不说了，我们说一个简单的例子。商品库存中心有个最基本的需求是减库存和补库存，我们看看怎么用状态模式来写。</p>
<p>核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。</p>
<p>定义状态接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">(Context context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义减库存的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeductState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;商品卖出，准备减库存&quot;</span>);</span><br><span class="line">        context.setState(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 执行减库存的具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Deduct State&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>定义补库存状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RevertState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;给此商品补库存&quot;</span>);</span><br><span class="line">        context.setState(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 执行加库存的具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Revert State&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面用到了 context.setState(this)，我们来看看怎么定义 Context 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">  	<span class="keyword">private</span> String name;</span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看下客户端调用，大家就一清二楚了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 我们需要操作的是 iPhone X</span></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="string">&quot;iPhone X&quot;</span>);</span><br><span class="line">  	</span><br><span class="line">    <span class="comment">// 看看怎么进行补库存操作</span></span><br><span class="line">  	<span class="type">State</span> <span class="variable">revertState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RevertState</span>();</span><br><span class="line">  	revertState.doAction(context);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 同样的，减库存操作也非常简单</span></span><br><span class="line">  	<span class="type">State</span> <span class="variable">deductState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeductState</span>();</span><br><span class="line">  	deductState.doAction(context);</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 如果需要我们可以获取当前的状态</span></span><br><span class="line">    <span class="comment">// context.getState().toString();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读者可能会发现，在上面这个例子中，如果我们不关心当前 context 处于什么状态，那么 Context 就可以不用维护 state 属性了，那样代码会简单很多。</p>
<p>不过，商品库存这个例子毕竟只是个例，我们还有很多实例是需要知道当前 context 处于什么状态的。</p>
<h3 id="行为型模式总结"><a href="#行为型模式总结" class="headerlink" title="行为型模式总结"></a>行为型模式总结</h3><p>行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 学习设计模式的目的是为了让我们的代码更加的优雅、易维护、易扩展。这次整理这篇文章，让我重新审视了一下各个设计模式，对我自己而言收获还是挺大的。我想，文章的最大收益者一般都是作者本人，为了写一篇文章，需要巩固自己的知识，需要寻找各种资料，而且，自己写过的才最容易记住，也算是我给读者的建议吧。</p>
<p>（全文完）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2020/01/09/jvm-string-constant-pool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/09/jvm-string-constant-pool/" class="post-title-link" itemprop="url">Java 字符串常量池介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-09 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-09T00:00:00+08:00">2020-01-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-29 13:38:15" itemprop="dateModified" datetime="2024-12-29T13:38:15+08:00">2024-12-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文将介绍 HotSpot 中的 String Pool，字符串常量池。相对是一篇比较简单的文章，大家花几分钟就看完了。</p>
<p>在 Java 世界中，构造一个 Java 对象是一个相对比较重的活，而且还需要垃圾回收，而缓存池就是为了缓解这个问题的。</p>
<p>我们来看下基础类型的包装类的缓存，Integer 默认缓存 -128 ~ 127 区间的值，Long 和 Short 也是缓存了这个区间的值，Byte 只能表示 -127 ~ 128 范围的值，全部缓存了，Character 缓存了 0 ~ 127 的值。Float 和 Double 没有缓存的意义。</p>
<blockquote>
<p>Integer 可通过设置 java.lang.Integer.IntegerCache.high 扩大缓存区间</p>
</blockquote>
<p>String 不是基础类型，但是它也有同样的机制，通过 String Pool 来缓存 String 对象。假设 “Java” 这个字符串我们会在应用程序中使用多次，我们肯定不希望在每次使用到的时候，都重新在堆中创建一个新的对象。</p>
<blockquote>
<p>当然，之所以 Integer、Long、String 这些类的对象可以缓存，是因为它们是不可变类</p>
</blockquote>
<p>基础类型包装类的缓存池使用一个数组进行缓存，而 String 类型，JVM 内部使用 HashTable 进行缓存，我们知道，HashTable 的结构是一个数组，数组中每个元素是一个链表。和我们平时使用的 HashTable 不同，JVM 内部的这个 HashTable 是不可以动态扩容的。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/string/1.png" alt="1"></p>
<h2 id="创建和回收"><a href="#创建和回收" class="headerlink" title="创建和回收"></a>创建和回收</h2><p>当我们在程序中使用双引号来表示一个字符串时，这个字符串就会进入到 String Pool 中。当然，这里说的是已被加载到 JVM 中的类。</p>
<blockquote>
<p>这是一个不够严谨的说法，请参见评论区的讨论。</p>
</blockquote>
<p>另外，就是 <strong>String#intern()</strong> 方法，这个方法的作用就是：</p>
<ul>
<li>如果字符串未在 Pool 中，那么就往 Pool 中增加一条记录，然后返回 Pool 中的引用。</li>
<li>如果已经在 Pool 中，直接返回 Pool 中的引用。</li>
</ul>
<p>只要 String Pool 中的 String 对象对于 GC Roots 来说不可达，那么它们就是可以被回收的。</p>
<p>如果 Pool 中对象过多，可能导致 YGC 变长，因为 YGC 的时候，需要扫描 String Pool，可以看看笨神大佬的文章《<a target="_blank" rel="noopener" href="http://lovestblog.cn/blog/2016/11/06/string-intern/">JVM源码分析之String.intern()导致的YGC不断变长</a>》。</p>
<h2 id="讨论-String-Pool-的实现"><a href="#讨论-String-Pool-的实现" class="headerlink" title="讨论 String Pool 的实现"></a>讨论 String Pool 的实现</h2><p><strong>1、首先，我们先考虑 String Pool 的空间问题。</strong></p>
<p>在 Java 6 中，String Pool 置于 PermGen Space 中，PermGen 有一个问题，那就是它是一个固定大小的区域，虽然我们可以通过 <code>-XX:MaxPermSize=N</code> 来设置永久代的空间大小，但是不管我们设置成多少，它终归是固定的。</p>
<p>所以，在 Java 6 中，我们应该尽量小心使用 String.intern() 方法，否则容易导致 OutOfMemoryError。</p>
<p>到了 Java 7，大佬们已经着手去掉 PermGen Space 了，首先，就是将 String Pool 移到了堆中。</p>
<p>把 String Pool 放到堆中，即使堆的大小也是固定的，但是这个时候，对于应用调优工作，只需要调整堆大小就行了。</p>
<p><del>到了 Java 8，PermGen 已经被彻底废弃，出现了堆外内存区域 MetaSpace，String Pool 相应的从堆转移到了 MetaSpace 中。</del></p>
<blockquote>
<p>在 Java 8 中，String Pool 依然还是在 Heap Space 中。感谢评论区的读者指出错误。大家可以看一下我后面写的关于 MetaSpace 的文章，那篇文章深入分析了 MetaSpace 的构成。</p>
</blockquote>
<p><strong>2、其次，我们再讨论 String Pool 的实现问题。</strong></p>
<p>前面我们说了 String Pool 使用一个 HashTable 来实现，这个 HashTable <strong>不可以扩容</strong>，也就意味着极有可能出现单个 bucket 中的链表很长，导致性能降低。</p>
<p>在 Java 6 中，这个 HashTable 固定的 bucket 数量是 1009，后来添加了选项（**-XX:StringTableSize=N**）可以配置这个值。到 Java 7（7u40），大佬们提高了这个默认值到 60013，Java 8 依然也是使用这个值，对于绝大部分应用来说，这个值是足够用的。当然，如果你会在代码中大量使用 String#intern()，那么有必要手动设置一下这个值。</p>
<blockquote>
<p>为什么是 1009，而不是 1000 或者 1024？因为 1009 是质数，有利于达到更好的散列。60013 同理。</p>
</blockquote>
<p> JVM 内部的 HashTable 是不扩容的，但是不代表它不 rehash，它会在发现散列不均匀的时候进行 rehash，这里不展开介绍。</p>
<p><strong>3、观察 String Pool 的使用情况。</strong></p>
<p>JVM 提供了 <code>-XX:+PrintStringTableStatistics</code> 启动参数来帮助我们获取统计数据。</p>
<p>遗憾的是，只有在 JVM 退出的时候，JVM 才会将统计数据打印出来，JVM 没有提供接口给我们实时获取统计数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SymbolTable statistics:</span><br><span class="line">Number of buckets       :     20011 =    160088 bytes, avg   8.000</span><br><span class="line">Number of entries       :     10923 =    262152 bytes, avg  24.000</span><br><span class="line">Number of literals      :     10923 =    425192 bytes, avg  38.926</span><br><span class="line">Total footprint         :           =    847432 bytes</span><br><span class="line">Average bucket size     :     0.546</span><br><span class="line">Variance of bucket size :     0.545</span><br><span class="line">Std. dev. of bucket size:     0.738</span><br><span class="line">Maximum bucket size     :         6</span><br><span class="line">## 看下面这部分：</span><br><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     60003 =    480024 bytes, avg   8.000</span><br><span class="line">Number of entries       :   4000774 =  96018576 bytes, avg  24.000</span><br><span class="line">Number of literals      :   4000774 = 1055252184 bytes, avg 263.762</span><br><span class="line">Total footprint         :           = 1151750784 bytes</span><br><span class="line">Average bucket size     :    66.676</span><br><span class="line">Variance of bucket size :    19.843</span><br><span class="line">Std. dev. of bucket size:     4.455</span><br><span class="line">Maximum bucket size     :        84</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>统计数据中包含了 buckets 的数量，总的 String 对象的数量，占用的总空间，单个 bucket 的链表平均长度和最大长度等。</p>
<p>上面的数据是在 Java 8 的环境中打印出来的，Java 7 的信息稍微少一些，主要是没有 footprint 的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :   60003</span><br><span class="line">Average bucket size     :      67</span><br><span class="line">Variance of bucket size :      20</span><br><span class="line">Std. dev. of bucket size:       4</span><br><span class="line">Maximum bucket size     :      84</span><br></pre></td></tr></table></figure>

<h2 id="测试-String-Pool-的性能"><a href="#测试-String-Pool-的性能" class="headerlink" title="测试 String Pool 的性能"></a>测试 String Pool 的性能</h2><p>接下来，我们来跑个测试，测试下 String Pool 的性能问题，并讨论 -XX:StringTableSize=N 参数的作用。</p>
<p>我们将使用 <code>String#intern()</code> 往字符串常量池中添加 <strong>400万</strong> 个不同的长字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javadoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.WeakHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test(<span class="number">4000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> cnt)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;String&gt; lst = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Very very very very very very very very very very very very very very &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;very long string: &quot;</span> + i;</span><br><span class="line">            lst.add(str.intern());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">200000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i + <span class="number">200000</span> + <span class="string">&quot;; time = &quot;</span> + (System.currentTimeMillis() - start) / <span class="number">1000.0</span> + <span class="string">&quot; sec&quot;</span>);</span><br><span class="line">                start = System.currentTimeMillis();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Total length = &quot;</span> + lst.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们每插入 20万 条数据，输出一次耗时。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译</span></span><br><span class="line">javac -d . StringTest.java</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用默认 table size (60013) 运行一次</span></span><br><span class="line">java -Xms2g -Xmx2g com.javadoop.StringTest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 table size 为 400031，再运行一次</span></span><br><span class="line">java -Xms2g -Xmx2g -XX:StringTableSize=400031 com.javadoop.StringTest</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.javadoop.com/imgs/20510079/string/2.png" alt="2"></p>
<p>从左右两部分数据可以很直观看出来，插入的性能主要取决于链表的平均长度。当链表平均长度为 10 的时候，我们看到性能是几乎没有任何损失的。</p>
<p>还是那句话，根据自己的实际情况，考虑是否要设置 -XX:StringTableSize=N，还是使用默认值。</p>
<h2 id="讨论自建-String-Pool"><a href="#讨论自建-String-Pool" class="headerlink" title="讨论自建 String Pool"></a>讨论自建 String Pool</h2><p>这一节我们来看下自己使用 HashMap 来实现 String Pool。</p>
<p>这里我们需要使用 WeakReference：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakHashMap&lt;String, WeakReference&lt;String&gt;&gt; pool</span><br><span class="line">            = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;String, WeakReference&lt;String&gt;&gt;(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">manualIntern</span><span class="params">(<span class="keyword">final</span> String str)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> WeakReference&lt;String&gt; cached = pool.get(str);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cached.get();</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pool.put(str, <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;String&gt;(str));</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用 1000 * 1000 * 1000 作为入参 cnt 的值进行测试，分别测试 [1] 和 [2]：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> cnt)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; lst = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(<span class="number">1024</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">      	<span class="comment">// [1]</span></span><br><span class="line">        lst.add(String.valueOf(i).intern());</span><br><span class="line">        <span class="comment">// [2]</span></span><br><span class="line">        <span class="comment">// lst.add(manualIntern(String.valueOf(i)));</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">200000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(i + <span class="number">200000</span> + <span class="string">&quot;; time = &quot;</span> + (System.currentTimeMillis() - start) / <span class="number">1000.0</span> + <span class="string">&quot; sec&quot;</span>);</span><br><span class="line">            start = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Total length = &quot;</span> + lst.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果，2G 的堆大小，如果使用 <code>String#intern()</code>，大概在插入 3000万 数据的时候，开始进入大量的 FullGC。</p>
<p>而使用自己写的 <code>manualIntern()</code>，大概到 1400万 的时候，就已经不行了。</p>
<p>没什么结论，如果要说点什么的话，那就是不要自建 String Pool，没必要。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>记住有两个 JVM 参数可以设置：-XX:StringTableSize=N、-XX:+PrintStringTableStatistics</p>
<p>StringTableSize，在 Java 6 中，是 1009；在 Java 7 和 Java 8 中，默认都是 60013，如果有必要请自行扩大这个值。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Java Performance Tuning Guide: <a target="_blank" rel="noopener" href="http://java-performance.info/string-intern-in-java-6-7-8/">String.intern in Java 6, 7 and 8 – string pooling</a></p>
<p>笨神是真正的大佬：<a target="_blank" rel="noopener" href="http://lovestblog.cn/blog/2016/11/06/string-intern/">JVM源码分析之String.intern()导致的YGC不断变长</a></p>
<p>（全文完）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2019/12/24/jvm-metaspace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/24/jvm-metaspace/" class="post-title-link" itemprop="url">深入理解堆外内存 Metaspace</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-24 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-24T00:00:00+08:00">2019-12-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-08 13:32:41" itemprop="dateModified" datetime="2025-05-08T13:32:41+08:00">2025-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在之前介绍的分代垃圾回收算法中，我们一直有一个<strong>永久代</strong>存在，叫 PermGen，内存上它是挨着堆的。为了垃圾回收方便，HotSpot 在永久代上一直是使用老年代的垃圾回收算法。</p>
<p>永久代主要存放以下数据：</p>
<ul>
<li>JVM internal representation of classes and their metadata</li>
<li>Class statics</li>
<li>Interned strings</li>
</ul>
<p>从 JDK7 开始，JDK 开发者们就有消灭永久代的打算了。有部分数据移到永久代之外了：</p>
<ul>
<li>Symbols =&gt; native memory</li>
<li>Interned strings =&gt; Java Heap </li>
<li>Class statics =&gt; Java Heap</li>
</ul>
<p>到了 JDK8，这个工作终于完成了，彻底废弃了 PermGen，Metaspace 取而代之。</p>
<p>本文的内容主要是翻译 Thomas Stüfe 的 <a target="_blank" rel="noopener" href="https://stuefe.de/posts/metaspace/what-is-metaspace/">Metaspace 系列文章</a>，他是 OpenJDK Committer/Reviewer. JVM developer at SAP，一看 Title 就很靠谱，因为他是 JVM 开发者，当然主要是内容也写得非常棒。</p>
<p>当然了，我不是一字一句翻译，文中会删掉部分累赘的内容，讲清楚就可以了。同时，原文第五篇是介绍使用 jcmd 工具观察 Metaspace 的空间使用情况，这一节我觉得没有必要介绍，所以没有加进来。</p>
<h2 id="1、什么是-Metaspace"><a href="#1、什么是-Metaspace" class="headerlink" title="1、什么是 Metaspace"></a>1、什么是 Metaspace</h2><p>Metaspace 区域位于堆外，所以它的最大内存大小取决于系统内存，而不是堆大小，我们可以指定 MaxMetaspaceSize 参数来限定它的最大内存。</p>
<p>Metaspace 是用来存放 class metadata 的，class metadata 用于记录一个 Java 类在 JVM 中的信息，包括但不限于 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">JVM class file format</a> 的运行时数据： </p>
<p>1、Klass 结构，这个非常重要，把它理解为一个 Java 类在虚拟机内部的表示吧；</p>
<p>2、method metadata，包括方法的字节码、局部变量表、异常表、参数信息等；</p>
<p>3、常量池；</p>
<p>4、注解；</p>
<p>5、方法计数器，记录方法被执行的次数，用来辅助 JIT 决策；</p>
<p>6、 其他</p>
<p>虽然每个 Java 类都关联了一个 <code>java.lang.Class</code> 的实例，而且它是一个贮存在堆中的 Java 对象。但是类的 class metadata 不是一个 Java 对象，它不在堆中，而是在 Metaspace 中。</p>
<h3 id="什么时候分配-Metaspace-空间"><a href="#什么时候分配-Metaspace-空间" class="headerlink" title="什么时候分配 Metaspace 空间"></a>什么时候分配 Metaspace 空间</h3><p>当一个类被加载时，它的类加载器会负责在 Metaspace 中分配空间用于存放这个类的元数据。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-lifecycle-allocation.png" alt="Metadata lifecycle - Allocation"></p>
<p>上面这个示意图非常简单，可以看到在 <code>Id</code> 这个类加载器第一次加载类 <code>X</code> 和 <code>Y</code> 的时候，在 Metaspace 中为它们开辟空间存放元信息。</p>
<h3 id="什么时候回收-Metaspace-空间"><a href="#什么时候回收-Metaspace-空间" class="headerlink" title="什么时候回收 Metaspace 空间"></a>什么时候回收 Metaspace 空间</h3><p>分配给一个类的空间，是归属于这个类的类加载器的，只有当这个类加载器卸载的时候，这个空间才会被释放。</p>
<p>所以，只有当这个类加载器加载的所有类都没有存活的对象，并且没有到达这些类和类加载器的引用时，相应的 Metaspace 空间才会被 GC 释放。看下图：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-lifecycle-deallocation.png" alt="Metadata lifecycle - Deallocation"></p>
<p>所以，一个 Java 类在 Metaspace 中占用的空间，它是否释放，取决于这个类的类加载器是否被卸载。</p>
<h3 id="内存通常会被保留"><a href="#内存通常会被保留" class="headerlink" title="内存通常会被保留"></a>内存通常会被保留</h3><p>释放 Metaspace 的空间，并不意味着将这部分空间还给系统内存，这部分空间通常会被 JVM 保留下来。</p>
<p>这部分被保留的空间有多大，取决于 Metaspace 的碎片化程度。另外，Metaspace 中有一部分区域 Compressed Class Space 是一定不会还给操作系统的。</p>
<blockquote>
<p>这里先了解概念，后面都会展开来说。</p>
</blockquote>
<h3 id="配置-Metaspace-空间"><a href="#配置-Metaspace-空间" class="headerlink" title="配置 Metaspace 空间"></a>配置 Metaspace 空间</h3><p>我们只需要关心两个配置参数：</p>
<ul>
<li><p><code>-XX:MaxMetaspaceSize</code>：Metaspace 总空间的最大允许使用内存，默认是不限制。</p>
</li>
<li><p><code>-XX:CompressedClassSpaceSize</code>：Metaspace 中的 Compressed Class Space 的最大允许内存，默认值是 1G，这部分会在 JVM 启动的时候向操作系统申请 1G 的虚拟地址映射，但不是真的就用了操作系统的 1G 内存。</p>
</li>
</ul>
<h3 id="Metaspace-和-GC"><a href="#Metaspace-和-GC" class="headerlink" title="Metaspace 和 GC"></a>Metaspace 和 GC</h3><p>Metaspace 只在 GC 运行并且卸载类加载器的时候才会释放空间。当然，在某些时候，需要主动触发 GC 来回收一些没用的 class metadata，即使这个时候对于堆空间来说，还达不到 GC 的条件。</p>
<p>Metaspace 可能在两种情况下触发 GC：</p>
<p>1、分配空间时：虚拟机维护了一个阈值，如果 Metaspace 的空间大小超过了这个阈值，那么在新的空间分配申请时，虚拟机首先会通过收集可以卸载的类加载器来达到复用空间的目的，而不是扩大 Metaspace 的空间，这个时候会触发 GC。这个阈值会上下调整，和 Metaspace 已经占用的操作系统内存保持一个距离。</p>
<p>2、碰到 Metaspace OOM：Metaspace 的总使用空间达到了 MaxMetaspaceSize 设置的阈值，或者 Compressed Class Space 被使用光了，如果这次 GC 真的通过卸载类加载器腾出了很多的空间，这很好，否则的话，我们会进入一个糟糕的 GC 周期，即使我们有足够的堆内存。</p>
<blockquote>
<p>所以大家千万不要把 MaxMetaspaceSize 设置得太小。</p>
</blockquote>
<h2 id="2、Metaspace-的架构"><a href="#2、Metaspace-的架构" class="headerlink" title="2、Metaspace 的架构"></a>2、Metaspace 的架构</h2><p>这一节将深入到 Metaspace 的架构实现，将描述它的每一层和每一个组件，以及它们是怎么工作的。</p>
<p>对于开发者来说，这一定是非常有趣的一件事情，我们大部分开发者都不可能去开发 JDK，但是了解这些总是充满着乐趣。</p>
<p>Metaspace 在实现上分为多层。最底层，负责向操作系统申请大块的内存；中间的一层，负责分出一小块一小块给每个类加载器；最顶层，类加载器负责把这些申请到的内存块用来存放 class metadata。</p>
<h3 id="最底层：the-space-list"><a href="#最底层：the-space-list" class="headerlink" title="最底层：the space list"></a>最底层：the space list</h3><p>在最底层，JVM 通过 <code>mmap(3)</code> 接口向操作系统申请内存映射，在 64 位平台上，每次申请 <strong>2MB</strong> 空间。</p>
<blockquote>
<p>当然，这里的 2MB 不是真的就消耗了主存的 2MB，只有之后在使用的时候才会真的消耗内存。这里是虚拟内存映射。</p>
</blockquote>
<p>每次申请过来的内存区域，放到一个链表中 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/share/memory/metaspace/virtualSpaceList.hpp#l39"><em>VirtualSpaceList</em></a>，作为其中的一个 Node。看下图。</p>
<p>一个 Node 是 2MB 的空间，前面说了在使用的时候再向操作系统申请实际的内存，但是频繁的系统调用会降低性能，所以 Node 内部需要维护一个水位线，当 Node 内已使用内存快达到水位线的时候，向操作系统要新的内存页。并且相应地提高水位线。</p>
<p>直到一个 Node 被完全用完，会分配一个新的 Node，并且将其加入到链表中，老的 Node 就 “退休” 了。下图中，前面的三个 Node 就是退休状态了。</p>
<p>从一个 Node 中分配内存，每一块称为 MetaChunk，chunk 有三种规格，在 64 位系统中分别为 1K、4K、64K。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-vslist.png" alt="alt text"></p>
<p>链表 VirtualSpaceList 和每个节点 Node 是全局的，而 Node 内部的一个个 MetaChunk 是分配给每个类加载器的。所以一个 Node 通常由分配给多个类加载器的 chunks 组成。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-vsnode-multiple-loaders.png" alt="alt text"></p>
<p>当一个类加载器和它加载的所有的类都卸载的时候，它占用的 chunks 就会加入到一个全局的空闲列表中：<a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/share/memory/metaspace/chunkManager.hpp#l44"><em>ChunkManager</em></a>，看下图：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-vsnode-multiple-loaders-one-dies.png" alt="alt text"></p>
<p>这些 chunks 会被复用：如果其他的类加载器加载新的类，它可能就会得到一个空闲列表中的 chunk，而不是去 Node 中申请一个新的 chunk。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-vsnode-multiple-loaders-chunk-reused.png" alt="alt text"></p>
<blockquote>
<p>后面会说到，如果刚好把整个 Node 都清空了，那么这整个 Node 的内存会直接还给操作系统。</p>
<p>当然，由这个 Node 进入到空闲列表的节点也要删除。</p>
</blockquote>
<h3 id="中间层：Metachunk"><a href="#中间层：Metachunk" class="headerlink" title="中间层：Metachunk"></a>中间层：Metachunk</h3><p>通常一个类加载器在申请 Metaspace 空间用来存放 metadata 的时候，也就需要几十到几百个字节，但是它会得到一个 Metachunk，一个比要求的内存大得多的内存块。</p>
<p>为什么？因为前面说了，要从全局的 <code>VirtualSpaceList</code> 链表的 Node 中分配内存是昂贵的操作，需要加锁。我们不希望这个操作太频繁，所以一次性给一个大的 MetaChunk，以便于这个类加载器之后加载其他的类，这样就可以做到多个类加载器并发分配了。只有当这个 chunk 用完了，类加载器才需要又去 <code>VirtualSpaceList</code> 申请新的 chunk。</p>
<p>前面说了，chunk 有三种规格，那 Metaspace 的分配器怎么知道一个类加载器每次要多大的 chunk 呢？这当然是基于猜测的：</p>
<ul>
<li>通常，一个标准的类加载器在第一次申请空间时，会得到一个 4K 的 chunk，直到它达到了一个随意设置的阈值（4），此时分配器失去了耐心，之后会一次性给它一个 64K 的大 chunk。</li>
<li>bootstrap classloader 是一个公认的会加载大量的类的加载器，所以分配器会给它一个巨大的 chunk，一开始就会给它 4M。可以通过 InitialBootClassLoaderMetaspaceSize 进行调优。</li>
<li>反射类类加载器 (<code>jdk.internal.reflect.DelegatingClassLoader</code>) 和匿名类类加载器只会加载一个类，所以一开始只会给它们一个非常小的 chunk（1K），因为给它们太多就是一种浪费。</li>
</ul>
<p>类加载器申请空间的时候，每次都给类加载器一个 chunk，这种优化，是建立在假设它们立马就会需要新的空间的基础上的。这种假设可能正确也可能错误，可能在拿到一个很大的 chunk 后，这个类加载器恰巧就不再需要加载新的类了。</p>
<blockquote>
<p>对于这部分可能的空间浪费，可以在后面介绍的系统工具中观察到。</p>
</blockquote>
<h3 id="最顶层：Metablock"><a href="#最顶层：Metablock" class="headerlink" title="最顶层：Metablock"></a>最顶层：Metablock</h3><p>在 Metachunk 上，我们有一个二级分配器（class-loader-local allocator），它将一个 Metachunk 分割成一个个小的单元，这些小的单元称为 Metablock，它们是实际分配给每个调用者的。</p>
<p>这个二级分配器非常原始，它的速度也非常快：</p>
<p>前面说过，class metadata 的生命周期是和类加载器绑定的，所以在类加载器卸载的时候，JVM 可以大块大块地释放这些空间。</p>
<p>下面展示一个 Metachunk 的结构：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-metachunk.png" alt="alt text"></p>
<p>这个 chunk 诞生的时候，它只有一个 header，之后的分配都只要在顶部进行分配就行。</p>
<p>由于这个 chunk 是归属于一个类加载器的，所以如果它不再加载新的类，那么 unused 空间就将真的浪费掉。</p>
<h3 id="ClassloaderData-and-ClassLoaderMetaspace"><a href="#ClassloaderData-and-ClassLoaderMetaspace" class="headerlink" title="ClassloaderData and ClassLoaderMetaspace"></a>ClassloaderData and ClassLoaderMetaspace</h3><p>在 JVM 内部，一个类加载器以一个 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/share/classfile/classLoaderData.hpp#l176"><em>ClassLoaderData</em></a> 结构标识，这个结构引用了一个 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/share/memory/metaspace.hpp#l230"><em>ClassLoaderMetaspace</em></a> 结构，它维护了该加载器使用的所有的 Metachunk。</p>
<p>当这个类加载器被卸载的时候，这个 <code>ClassLoaderData</code> 和 <code>ClassLoaderMetaspace</code> 会被删除。并且会将所有的这个加载器用到的 chunks 归还到空闲列表中。这部分内存是否可以直接归还给操作系统取决于是否满足其他条件，后面会介绍。</p>
<blockquote>
<p>就是前面提过的，如果恰好把整个 Node 都清空了，那么这个 Node 的内存直接还给操作系统</p>
</blockquote>
<h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h3><p><code>ClassloaderData != ClassLoaderMetaspace</code></p>
<p>注意，我们前面说，“Metaspace 内存是属于类加载器的”，但是，这里其实撒了一个小谎，如果将匿名类考虑进去，那就更加复杂了：</p>
<p>当类加载器加载一个匿名类时，这个类有自己独立的 <code>ClassLoaderData</code>，它的生命周期是跟随着这个匿名类的，而不是这个类加载器（所以，和它相关的空间可以在类加载器卸载前得到释放）。所以，一个类加载器有一个主要的 ClassLoaderData 结构用来服务所有的正常的类，对于每一个匿名类，还有一个二级的 ClassLoaderData 结构来维护。</p>
<p>这样做的目的之一，其实就是没有必要扩大大量的 Lambdas 和 method  handlers 在 Metaspace 中的空间的生命周期。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-classloadermetaspace.png" alt="alt text"></p>
<h3 id="内存什么时候会还给操作系统"><a href="#内存什么时候会还给操作系统" class="headerlink" title="内存什么时候会还给操作系统"></a>内存什么时候会还给操作系统</h3><p>当一个 VirtualSpaceListNode 中的所有 chunk 都是空闲的时候，这个 Node 就会从链表 VirtualSpaceList 中移除，它的 chunks 也会从空闲列表中移除，这个 Node 就没有被使用了，会将其内存归还给操作系统。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-vsnode-purged.png" alt="alt text"></p>
<p>对于一个空闲的 Node 来说，拥有其上面的 chunks 的所有的类加载器必然都是被卸载了的。</p>
<p>至于这个情况是否可能发生，主要就是取决于碎片化：</p>
<p>一个 Node 是 2M，chunks 的大小为 1K, 4K 或 64K，所以通常一个 Node 上有约 150-200 个 chunks，如果这些 chunks 全部由同一个类加载器拥有，回收这个类加载器就可以一次性回收这个 Node，并且把它的空间还给操作系统。</p>
<p>但是，如果这些 chunks 分配给不同的类加载器，每个类加载器都有不同的生命周期，那么什么都不会被释放。这也许就是在告诉我们，要小心对待大量的小的类加载器，如那些负责加载匿名类或反射类的加载器。</p>
<p>同时也要清楚，Metaspace 中的 <em>Compressed Class Space</em> 是永远不会将内存还给操作系统的。我们马上就要介绍这部分内容了。</p>
<h3 id="本节小结"><a href="#本节小结" class="headerlink" title="本节小结"></a>本节小结</h3><ul>
<li>每次向操作系统申请 2M 的虚拟空间映射，放置到全局链表中，待需要使用的时候申请内存。</li>
<li>一个 Node 会分割为一个个的 chunks，分配给类加载器，一个 chunk 属于一个类加载器。</li>
<li>chunk 再细分为一个个 Metablock，这是分配给调用者的最小单元。</li>
<li>当一个类加载器被卸载，它占有的 chunks 会进入到空闲列表，以便复用，如果运气好的话，有可能会直接把内存归还给操作系统。</li>
</ul>
<h2 id="3、什么是-Compressed-Class-Space"><a href="#3、什么是-Compressed-Class-Space" class="headerlink" title="3、什么是 Compressed Class Space"></a>3、什么是 Compressed Class Space</h2><p>在 64 位平台上，HotSpot 使用了两个压缩优化技术，<strong>Compressed Object Pointers</strong> (<em>“CompressedOops”</em>) 和 <strong>Compressed Class Pointers</strong>。</p>
<p>压缩指针，指的是在 64 位的机器上，使用 32 位的指针来访问数据（堆中的对象或 Metaspace 中的元数据）的一种方式。</p>
<p>这样有很多的好处，比如 32 位的指针占用更小的内存，可以更好地使用缓存，在有些平台，还可以使用到更多的寄存器。</p>
<p>当然，在 64 位的机器中，最终还是需要一个 64 位的地址来访问数据的，所以这个 32 位的值是相对于一个基准地址的值。</p>
<blockquote>
<p>CompressedOops 说的是对象引用的压缩，它不在本文的讨论范围内。</p>
<p>在 64 位平台上，本质上还是需要使用 64 位地址来引用每一个对象的，但是这项技术使得可以只使用 32 位地址来实现引用。大家可以参考一下评论区的讨论，这里就不展开了。</p>
</blockquote>
<p>由于本文在描述的是 Metaspace，所以我们这里不关心 <strong>Compressed Object Pointers</strong>，下面将描述 <strong>Compressed Class Pointers</strong>：</p>
<p>每个 Java 对象，在它的头部，有一个引用指向 Metaspace 中的 Klass 结构。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-uncompressed-class-ptr.png" alt="alt text"></p>
<p>当使用了 compressed class pointers，这个引用是 32 位的值，为了找到真正的 64 位地址，需要加上一个 base 值：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-compressed-class-ptr.png" alt="alt text"></p>
<p>上面的内容应该很好理解，这项技术对 Klass 的分配带来的问题是：由于 32 位地址只能访问到 4G 的空间，所以<strong>最大只允许 4G</strong> 的 Klass 地址。这项限制也意味着，JVM 需要向 Metaspace 分配一个<strong>连续的地址空间</strong>。</p>
<p>当从系统申请内存时，通过调用系统接口 malloc(3) 或 mmap(3)，操作系统可能返回任意一个地址值，所以在 64位系统中，它并不能保证在 4G 的范围内。</p>
<p>所以，我们只能用一个 mmap() 来申请一个区域单独用来存放 Klass 对象。我们需要提前知道这个区域的大小，而且不能超过 4G。显然，这种方式是不能扩展的，因为这个地址后面的内存可能是被占用的。</p>
<p>只有 Klass 结构有这个限制，对于其他的 class metadata 没有这个必要: 因为只有 Klass 实例是通过 Java 对象 header  中的压缩指针访问的。其他的 metadata 都是通过 64 位的地址进行访问的，所以它们可以被放到任意的地址上。</p>
<p>所以，我们决定将 Metaspace 分为两个区域：non-class part 和 class part。</p>
<ul>
<li>class part：存放 Klass 对象，需要一个连续的不超过 4G 的内存</li>
<li>non-class part：包含其他的所有 metadata</li>
</ul>
<blockquote>
<p>class part 被称作 <strong>Compressed Class Space</strong>，这个名字会有点怪，因为 Klass 本身其实没有使用压缩技术，而是引用它们的指针被压缩了。</p>
</blockquote>
<p>compressed class space 空间的大小，是通过 -XX:CompressedClassSpaceSize 指定的。</p>
<p>我们需要提前知道自己需要多少内存，它的<strong>默认值是 1G</strong>。当然这个 1G 并不是真的使用了操作系统的 1G，而是虚拟地址映射。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>为了复用已有的 Metaspace 空间，使用了一个小技巧：</p>
<p>在 Class Space 和 Non-Class Space 中，分别都有 VirtualSpaceList 和 ChunkManager 两个结构。</p>
<p>但是对于 Class Space，既然我们需要一个连续的空间我们不能使用一个链表来存放所有的 Node，所以这个链表退化为只有一个节点，并且不能扩展。这个 Node 就是 compressed class space，和 Non-Class Space 中的 Node 相比，它可是巨大无比。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-classspace-duality.png" alt="alt text"></p>
<p>ClassLoaderMetaspace（记录当前类加载器持有哪些 chunks）需要两个链表，一个用于记录 Class Space 中的 chunks，一个用于记录 Non-Class Space 中的 chunks。</p>
<blockquote>
<p>到这里应该也很好理解，就是对于一个类加载器来说，它需要知道自己使用了 non-class part 中的哪些 chunks 和 class part 中的哪些 chunks。</p>
</blockquote>
<h3 id="开关-UseCompressedClassPointers-UseCompressedOops"><a href="#开关-UseCompressedClassPointers-UseCompressedOops" class="headerlink" title="开关: UseCompressedClassPointers, UseCompressedOops"></a>开关: UseCompressedClassPointers, UseCompressedOops</h3><p><code>-XX:+UseCompressedOops</code> 允许对象指针压缩。</p>
<p><code>-XX:+UseCompressedClassPointers</code>  允许类指针压缩。</p>
<p>它们默认都是开启的，可以手动关闭它们。</p>
<p>如果不允许类指针压缩，那么将没有 compressed class space 这个空间，并且<code>-XX:CompressedClassSpaceSize</code> 这个参数无效。</p>
<p><code>-XX:-UseCompressedClassPointers</code> 需要搭配 <code>-XX:+UseCompressedOops</code>，但是反过来不是: 我们可以只压缩对象指针，不压缩类指针。</p>
<blockquote>
<p>这里面为什么这么规定我也不懂，但是从直觉上来说，压缩对象指针显然是比较重要的，能获得较大的收益。也许就是基于这种考量吧：你连对象指针都不压缩，类指针压缩不压缩又有什么关系呢？</p>
</blockquote>
<p>注意，对象指针压缩要求堆小于 32G，所以如果堆大于等于 32G，那么对象指针压缩和类指针压缩都会被关闭。</p>
<blockquote>
<p>32G 可不是一个掐指一算随便指定的数字，看下评论区就知道原因了。</p>
</blockquote>
<h2 id="4、度量-Metaspace"><a href="#4、度量-Metaspace" class="headerlink" title="4、度量 Metaspace"></a>4、度量 Metaspace</h2><p>前面我们介绍过，<strong>MaxMetaspaceSize</strong> 和 <strong>CompressedClassSpaceSize</strong> 是控制 Metaspace 的两个配置。</p>
<p>回顾一下：</p>
<ul>
<li><p><strong>MaxMetaspaceSize</strong></p>
<p>最大允许 Metaspace 使用的内存，包括 Class Space 和 Non-Class Space，默认是不限制。</p>
</li>
<li><p><strong>CompressedClassSpaceSize</strong></p>
<p>在启动的时候就限制 Class Space 的大小，默认值是 1G，启动后不可以修改。再说一遍，它是 reserved 不是 committed 的内存。</p>
</li>
</ul>
<p>下图展示了它们是怎么工作的：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-sizing-params.png" alt="MaxMetaspaceSize and CompressedClassSpaceSize"></p>
<p>红色部分是 Metaspace 中已使用的系统内存，包括 Non-Class Space 链表中的红色部分和 Class Space 中大 Node 的红色部分。这个总和受到 <code>-XX:MaxMetaspaceSize</code> 的限制，超出将抛出 **OutOfMemoryError(“Metaspace”)**。</p>
<p><code>-XX:CompressedClassSpaceSize</code> 限制了下方的 Class Space 中，这个大 Node 的大小，包括了红色已使用的内存和蓝色未使用的内存。如果这个 Node 被用完了，会抛出 **OutOfMemoryError(“Compressed Class Space”)**。</p>
<h3 id="所以这意味着什么？"><a href="#所以这意味着什么？" class="headerlink" title="所以这意味着什么？"></a>所以这意味着什么？</h3><p>当一个 Java 类被加载后，它需要 Non-Class Space 和 Class Space 的空间，而且后者通常都是被限制的(默认 1G)，所以我们总是有那么一个上限存在，即使 -XX:MaxMetaspaceSize 没有配置。</p>
<p>所以，是否会触及到这个上限，取决于 Non-Class Space 和 Class Space 的使用比例。</p>
<p>对于每个类，我们假设这个比例是 1: 5 （class:non-class） 。</p>
<p>这意味着，对于 -XX:CompressedClassSpaceSize 的 1G 的默认值，我们的上限约 6G，1G 的 Class Space 再加约 5G 的 Non-Class Space。</p>
<h3 id="一个类大概需要多大的-Metaspace-空间"><a href="#一个类大概需要多大的-Metaspace-空间" class="headerlink" title="一个类大概需要多大的 Metaspace 空间"></a>一个类大概需要多大的 Metaspace 空间</h3><p>对于一个被加载到虚拟机中的类，Metaspace 需要分配 class 和 non-class 空间，那么这些空间花在哪里了呢？看下图：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/metaspace/metaspace-class-metadata.png" alt="How much space does a Java class need?"></p>
<h4 id="深入-Class-Space："><a href="#深入-Class-Space：" class="headerlink" title="深入 Class Space："></a>深入 Class Space：</h4><p>最大的一部分是 Klass 结构，它是固定大小的。</p>
<p>然后紧跟着两个可变大小的 vtable 和 itable，前者由类中方法的数量决定，后者由这个类所实现接口的方法数量决定。</p>
<p>随后是一个 map，记录了类中引用的 Java 对象的地址，尽管该结构一般都很小，不过也是可变的。</p>
<p>vtable 和 itable 通常也很小，但是对于一些巨大的类，它们也可以很大，一个有 30000 个方法的类，vtable 的大小会达到 240k，如果类派生自一个拥有 30000 个方法的接口，也是同理。但是这些都是测试案例，除了自动生成代码，你从来不会看到这样的类。</p>
<h4 id="深入-Non-Class-Space"><a href="#深入-Non-Class-Space" class="headerlink" title="深入 Non-Class Space"></a>深入 Non-Class Space</h4><p>这个区域有很多的东西，下面这些占用了最多的空间：</p>
<ul>
<li><p>常量池，可变大小；</p>
</li>
<li><p>每个成员方法的 metadata：ConstMethod 结构，包含了好几个可变大小的内部结构，如方法字节码、局部变量表、异常表、参数信息、方法签名等；</p>
</li>
<li><p>运行时数据，用来控制 JIT 的行为；</p>
</li>
<li><p>注解</p>
</li>
</ul>
<blockquote>
<p>Metaspace 中的结构都继承自 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/share/memory/allocation.hpp#l239">MetaspaceObj</a>，所以查看它的类继承结构能了解更详细的信息。</p>
</blockquote>
<h4 id="Class-space-和-Non-Class-Space-比例"><a href="#Class-space-和-Non-Class-Space-比例" class="headerlink" title="Class space 和 Non-Class Space 比例"></a>Class space 和 Non-Class Space 比例</h4><p>下面看一下在一些典型的应用中，它们之间的大小比例数据。</p>
<p>下面是 WildFly 应用服务器，16.0.0，运行在 SAPMachine 11 平台上，没有加载任何应用。我们检查下总共需要多少 Metaspace 空间，然后计算平均每个类所需要的空间。我们使用  <code>jcmd VM.metaspace</code> 进行度量。</p>
<table>
<thead>
<tr>
<th>loader</th>
<th>#classes</th>
<th>non-class space <em>(avg per class)</em></th>
<th>class space <em>(/avg per class)</em></th>
<th>ratio non-class/class</th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td>11503</td>
<td>60381k <em>(5.25k)</em></td>
<td>9957k <em>(0.86k)</em></td>
<td>6.0 : 1</td>
</tr>
<tr>
<td>bootstrap</td>
<td>2819</td>
<td>16720k <em>(5.93k)</em></td>
<td>1768k <em>(0.62k)</em></td>
<td>9.5 : 1</td>
</tr>
<tr>
<td>app</td>
<td>185</td>
<td>1320k <em>(7.13k)</em></td>
<td>136k <em>(0.74k)</em></td>
<td>9.7 : 1</td>
</tr>
<tr>
<td>anonymous</td>
<td>869</td>
<td>1013k <em>(1.16k)</em></td>
<td>475k <em>(0.55k)</em></td>
<td>2.1 : 1</td>
</tr>
</tbody></table>
<p>这个表告诉我们：</p>
<ul>
<li>对于正常的类（我们假设通过 bootstrap 和 app 加载的类是正常的），我可以得到平均每个类需要约 5-7k 的 Non-Class Space 和 600-900 bytes 的 Class Space。</li>
<li>匿名类要小得多，但是也有一个有趣的事情，Class 和 Non-Class Space 之间的比例，相对的，我们需要更多的 Class Space。这也不奇怪，因为诸如 Lambda 类都是很小的，但是它的 Klass 结构不可能小于 sizeof(Klass)。所以，我们得到 1k Non-Class Space 和 0.5k Class Space。</li>
</ul>
<p>注意，在我们的案例中，匿名类的数据可能没有代表性，需要收集更多的匿名类，才能得到更准确的数据。</p>
<h3 id="Metaspace-默认大小"><a href="#Metaspace-默认大小" class="headerlink" title="Metaspace 默认大小"></a>Metaspace 默认大小</h3><p>如果我们完全不设置限制 Metaspace 的大小，那么 Metaspace 可以容纳多少类呢？</p>
<p>MaxMetaspaceSize 默认是没有限制的，CompressedClassSpaceSize 默认是 1G，所以我们唯一会触碰到的是 Class Space 空间的上限。</p>
<p>使用上面的数据，每个类约 5-7k 的 Non-Class Space 和 600-900 bytes 的 Class Space，我们可以估算出大约 1-1.5 百万的类（假设没有碎片、没有浪费）以后会触碰到 Class Space 的 OOM。这是一个很大的数值了。</p>
<h3 id="限制-Metaspace-空间大小"><a href="#限制-Metaspace-空间大小" class="headerlink" title="限制 Metaspace 空间大小"></a>限制 Metaspace 空间大小</h3><p><strong>免责声明：不要盲目使用你在网络上找到的规则，尤其是这些数据并非来自生产数据。</strong></p>
<p>其实我们没有什么选择，你确实可以限制 Metaspace 的空间增长，但是如果你的程序需要更多的空间用来存放 class metadata，那么你就会碰到 OOM，除了让你的代码加载更少的类，否则，你几乎是无能为力。</p>
<p>和堆进行比较：你可以增加和减少堆的大小，而不必影响代码功能，所以堆的配置是比较灵活的，而 Metaspace 不具备这个特性。</p>
<p>那么你为什么要限制 Metaspace 的大小呢？</p>
<ul>
<li>告警系统需要知道，为什么 Metaspace 空间以一个异常的速度在消耗，需要有人去看一下发生了什么。</li>
<li>有时候需要限制虚拟内存地址的大小。通常我们感兴趣的是实际消耗内存，但是虚拟内存大小可能会导致虚拟机进程达到系统限制。</li>
</ul>
<blockquote>
<p>注意：JDK 版本依赖：与 JDK 11或更高版本相比，JDK 8 中的元空间受到碎片的影响更大。所以在 JDK 8 环境下分配的时候，需要设置更多的缓冲。</p>
</blockquote>
<p>如果要限制 Metaspace 大小使得系统更容易被监控，同时不用在乎虚拟地址空间的大小，那么最好只设置 MaxMetaspaceSize 而不用设置 CompressedClassSpaceSize。如果要单独设置，那么最好设置 CompressedClassSpaceSize 为 MaxMetaspaceSize 的 80% 左右。</p>
<p>除了 MaxMetaspaceSize 之外，<strong>减小 CompressedClassSpaceSize 的唯一原因是减小虚拟机进程的虚拟内存大小</strong>。 但是，如果将 CompressedClassSpaceSize 设置得太低，则可能在用完 MaxMetaspaceSize 之前先用完了 Compressed Class Space。 在大多数情况下，比率为1：2（CompressedClassSpaceSize = MaxMetaspaceSize / 2）应该是安全的。</p>
<p>那么，你应该将 MaxMetaspaceSize 设置为多大呢？ 首先应该是计算预期的 Metaspace 使用量。你可以使用上面给出的数字，然后给每个类约 1K 的 Class Space 和 3~8K 的 Non-Class Space 作为缓冲。</p>
<p>因此，如果你的应用程序计划加载10000个类，那么从理论上讲，你只需要 10M 的 Class Space 和 80M Non-Class Space。</p>
<p>然后，你需要考虑安全系数。在大多数情况下，因子 2 是比较安全的。你当然也可以碰运气，设置低一点，但是要做好在碰到 OOM 后调大 Metaspace 空间的准备。</p>
<p>如果设置安全因子为 2，那么需要 20M 的 Class Space 和 160M 的 Non-Class Space，也就是总大小为 180M。因此，在这里 <code>-XX:MaxMetaspaceSize=180M</code> 是一个很好的选择。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这是一篇快速写完的文章，不过我仔细检查过了几遍，应该不会有太多的出入。</p>
<p>如果你发现有些地方看得不是很懂，希望你可以先对比一下 <a target="_blank" rel="noopener" href="https://stuefe.de/posts/metaspace/what-is-metaspace/">原文</a>，如果是我的翻译问题，烦请告知。</p>
<p>虽然只是一篇翻译的文章，甚至对于你来说可能还不如看原文来得舒适，不过也同样欢迎大家留言探讨或吐槽。</p>
<p>（全文完）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2018/11/03/netty-source-code-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/03/netty-source-code-2/" class="post-title-link" itemprop="url">认真的 Netty 源码解析（二）(转自JavaDoop)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-03 00:00:00" itemprop="dateCreated datePublished" datetime="2018-11-03T00:00:00+08:00">2018-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 15:17:04" itemprop="dateModified" datetime="2025-04-27T15:17:04+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/netty/" itemprop="url" rel="index"><span itemprop="name">netty</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Channel-的-register-操作"><a href="#Channel-的-register-操作" class="headerlink" title="Channel 的 register 操作"></a>Channel 的 register 操作</h2><p>经过前面的铺垫，我们已经具备一定的基础了，我们开始来把前面学到的内容揉在一起。这节，我们会介绍 register 操作，这一步其实是非常关键的，对于我们源码分析非常重要。</p>
<h3 id="register"><a href="#register" class="headerlink" title="register"></a>register</h3><p>我们从 EchoClient 中的 connect() 方法出发，或者 EchoServer 的 bind(port) 方法出发，都会走到 initAndRegister() 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        <span class="comment">// 2 对于 Bootstrap 和 ServerBootstrap，这里面有些不一样</span></span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 3 我们这里要说的是这行</span></span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>initAndRegister() 这个方法我们已经接触过两次了，前面介绍了 1️⃣ Channel 的实例化，实例化过程中，会执行 Channel 内部 Unsafe 和 Pipeline 的实例化，以及在上面 2️⃣ init(channel) 方法中，会往 pipeline 中添加 handler（pipeline 此时是 head+channelnitializer+tail）。</p>
<blockquote>
<p>我们这节终于要揭秘 ChannelInitializer 中的 initChannel 方法了~~~</p>
</blockquote>
<p>现在，我们继续往下走，看看 3️⃣ <strong>register</strong> 这一步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> config().group().register(channel);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们说了，register 这一步是非常关键的，它发生在 channel 实例化以后，大家回忆一下当前 channel 中的一些情况：</p>
<p>实例化了 JDK 底层的 Channel，设置了非阻塞，实例化了 Unsafe，实例化了 Pipeline，同时往 pipeline 中添加了 head、tail 以及一个 ChannelInitializer 实例。</p>
</blockquote>
<p>上面的 <code>config().group()</code> 方法会返回前面实例化的 NioEventLoopGroup 的实例，然后调用其 register(channel) 方法：</p>
<p>// MultithreadEventLoopGroup</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> next().register(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>next() 方法很简单，就是选择线程池中的一个线程（还记得 chooserFactory 吗），也就是选择一个 NioEventLoop 实例，这个时候我们就进入到 NioEventLoop 了。</p>
<p>NioEventLoop 的 register(channel) 方法实现在它的父类 <strong>SingleThreadEventLoop</strong> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> register(<span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(channel, <span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码实例化了一个 Promise，将当前 channel 带了进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">&quot;promise&quot;</span>);</span><br><span class="line">    <span class="comment">// promise 关联了 channel，channel 持有 Unsafe 实例，register 操作就封装在 Unsafe 中</span></span><br><span class="line">    promise.channel().unsafe().register(<span class="built_in">this</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到 channel 中关联的 Unsafe 实例，然后调用它的 register 方法：</p>
<blockquote>
<p>我们说过，Unsafe 专门用来封装底层实现，当然这里也没那么“底层”</p>
</blockquote>
<p>// AbstractChannel#<strong>AbstractUnsafe</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将这个 eventLoop 实例设置给这个 channel，从此这个 channel 就是有 eventLoop 的了</span></span><br><span class="line">    <span class="comment">// 我觉得这一步其实挺关键的，因为后续该 channel 中的所有异步操作，都要提交给这个 eventLoop 来执行</span></span><br><span class="line">    AbstractChannel.<span class="built_in">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果发起 register 动作的线程就是 eventLoop 实例中的线程，那么直接调用 register0(promise)</span></span><br><span class="line">    <span class="comment">// 对于我们来说，它不会进入到这个分支，</span></span><br><span class="line">    <span class="comment">//     之所以有这个分支，是因为我们是可以 unregister，然后再 register 的，后面再仔细看</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，提交任务给 eventLoop，eventLoop 中的线程会负责调用 register0(promise)</span></span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>到这里，我们要明白，NioEventLoop 中是还没有实例化 Thread 实例的。</p>
</blockquote>
<p>这几步涉及到了好几个类：NioEventLoop、Promise、Channel、Unsafe 等，大家要仔细理清楚它们的关系。</p>
<p>对于我们前面过来的 register 操作，其实提交到 eventLoop 以后，就直接返回 promise 实例了，剩下的register0 是异步操作，它由 NioEventLoop 实例来完成。</p>
<p>我们这边先不继续往里分析 register0(promise) 方法，先把前面欠下的 NioEventLoop 中的线程介绍清楚，然后再回来介绍这个 register0 方法。</p>
<blockquote>
<p>Channel 实例一旦 register 到了 NioEventLoopGroup 实例中的某个 NioEventLoop 实例，那么后续该 Channel 的所有操作，都是由该 NioEventLoop 实例来完成的。</p>
<p>这个也非常简单，因为 Selector 实例是在 NioEventLoop 实例中的，Channel 实例一旦注册到某个 Selector 实例中，当然也只能在这个实例中处理 NIO 事件。</p>
</blockquote>
<h3 id="NioEventLoop-工作流程"><a href="#NioEventLoop-工作流程" class="headerlink" title="NioEventLoop 工作流程"></a>NioEventLoop 工作流程</h3><p>前面，我们在分析线程池的实例化的时候说过，NioEventLoop 中并没有启动 Java 线程。这里我们来仔细分析下在 register 过程中调用的 <strong>eventLoop.execute(runnable)</strong> 这个方法，这个代码在父类 SingleThreadEventExecutor 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 判断添加任务的线程是否就是当前 EventLoop 中的线程</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">inEventLoop</span> <span class="operator">=</span> inEventLoop();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加任务到之前介绍的 taskQueue 中，</span></span><br><span class="line">    <span class="comment">// 	如果 taskQueue 满了(默认大小 16)，根据我们之前说的，默认的策略是抛出异常</span></span><br><span class="line">    addTask(task);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">        <span class="comment">// 如果不是 NioEventLoop 内部线程提交的 task，那么判断下线程是否已经启动，没有的话，就启动线程</span></span><br><span class="line">        startThread();</span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原来启动 NioEventLoop 中的线程的方法在这里。</p>
<p>另外，上节我们说的 register 操作进到了 taskQueue 中，所以它其实是被归类到了非 IO 操作的范畴。</p>
</blockquote>
<p>下面是 startThread 的源码，判断线程是否已经启动来决定是否要进行启动操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="built_in">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                doStartThread();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">                STATE_UPDATER.set(<span class="built_in">this</span>, ST_NOT_STARTED);</span><br><span class="line">                PlatformDependent.throwException(cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们按照前面的思路，根据线程没有启动的情况，来看看 doStartThread() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doStartThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> thread == <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 这里的 executor 大家是不是有点熟悉的感觉，它就是一开始我们实例化 NioEventLoop 的时候传进来的 ThreadPerTaskExecutor 的实例。它是每次来一个任务，创建一个线程的那种 executor。</span></span><br><span class="line">    <span class="comment">// 一旦我们调用它的 execute 方法，它就会创建一个新的线程，所以这里终于会创建 Thread 实例</span></span><br><span class="line">    executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 看这里，将 “executor” 中创建的这个线程设置为 NioEventLoop 的线程！！！</span></span><br><span class="line">            thread = Thread.currentThread();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            updateLastExecutionTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行 SingleThreadEventExecutor 的 run() 方法，它在 NioEventLoop 中实现了</span></span><br><span class="line">                SingleThreadEventExecutor.<span class="built_in">this</span>.run();</span><br><span class="line">                success = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Unexpected exception from an event executor: &quot;</span>, t);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// ... 我们直接忽略掉这里的代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面线程启动以后，会执行 NioEventLoop 中的 run() 方法，这是一个<strong>非常重要</strong>的方法，这个方法肯定是没那么容易结束的，必然是像 JDK 线程池的 Worker 那样，不断地循环获取新的任务的。它需要不断地做 select 操作和轮询 taskQueue 这个队列。</p>
<p>我们先来简单地看一下它的源码，这里先不做深入地介绍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 代码嵌套在 for 循环中</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// selectStrategy 终于要派上用场了</span></span><br><span class="line">            <span class="comment">// 它有两个值，一个是 CONTINUE 一个是 SELECT</span></span><br><span class="line">            <span class="comment">// 针对这块代码，我们分析一下。</span></span><br><span class="line">            <span class="comment">// 1. 如果 taskQueue 不为空，也就是 hasTasks() 返回 true，</span></span><br><span class="line">            <span class="comment">// 		那么执行一次 selectNow()，该方法不会阻塞</span></span><br><span class="line">            <span class="comment">// 2. 如果 hasTasks() 返回 false，那么执行 SelectStrategy.SELECT 分支，</span></span><br><span class="line">            <span class="comment">//    进行 select(...)，这块是带阻塞的</span></span><br><span class="line">            <span class="comment">// 这个很好理解，就是按照是否有任务在排队来决定是否可以进行阻塞</span></span><br><span class="line">            <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                    <span class="comment">// 如果 !hasTasks()，那么进到这个 select 分支，这里 select 带阻塞的</span></span><br><span class="line">                    select(wakenUp.getAndSet(<span class="literal">false</span>));</span><br><span class="line">                    <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                        selector.wakeup();</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 默认地，ioRatio 的值是 50</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ioRatio</span> <span class="operator">=</span> <span class="built_in">this</span>.ioRatio;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 ioRatio 设置为 100，那么先执行 IO 操作，然后在 finally 块中执行 taskQueue 中的任务</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1. 执行 IO 操作。因为前面 select 以后，可能有些 channel 是需要处理的。</span></span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 2. 执行非 IO 任务，也就是 taskQueue 中的任务</span></span><br><span class="line">                    runAllTasks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果 ioRatio 不是 100，那么根据 IO 操作耗时，限制非 IO 操作耗时</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioStartTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行 IO 操作</span></span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 根据 IO 操作消耗的时间，计算执行非 IO 操作（runAllTasks）可以用多少时间.</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioTime</span> <span class="operator">=</span> System.nanoTime() - ioStartTime;</span><br><span class="line">                    runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Always handle shutdown even if the loop processing threw an exception.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                closeAll();</span><br><span class="line">                <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码是 NioEventLoop 的核心，这里介绍两点：</p>
<ol>
<li>首先，会根据 hasTasks() 的结果来决定是执行 selectNow() 还是 select(oldWakenUp)，这个应该好理解。如果有任务正在等待，那么应该使用无阻塞的 selectNow()，如果没有任务在等待，那么就可以使用带阻塞的 select 操作。</li>
<li>ioRatio 控制 IO 操作所占的时间比重：<ul>
<li>如果设置为 100%，那么先执行 IO 操作，然后再执行任务队列中的任务。</li>
<li>如果不是 100%，那么先执行 IO 操作，然后执行 taskQueue 中的任务，但是需要控制执行任务的总时间。也就是说，非 IO 操作可以占用的时间，通过 ioRatio 以及这次 IO 操作耗时计算得出。</li>
</ul>
</li>
</ol>
<p>我们这里先不要去关心 select(oldWakenUp)、processSelectedKeys() 方法和 runAllTasks(…) 方法的细节，只要先理解它们分别做什么事情就可以了。</p>
<p>回过神来，我们前面在 register 的时候提交了 register 任务给 NioEventLoop，这是 NioEventLoop 接收到的第一个任务，所以这里会实例化 Thread 并且启动，然后进入到 NioEventLoop 中的 run 方法。</p>
<h3 id="继续-register"><a href="#继续-register" class="headerlink" title="继续 register"></a>继续 register</h3><p>我们回到前面的 register0(promise) 方法，我们知道，这个 register 任务进入到了 NioEventLoop 的 taskQueue 中，然后会启动 NioEventLoop 中的线程，该线程会轮询这个 taskQueue，然后执行这个 register 任务。</p>
<p>注意，此时执行该方法的是 eventLoop 中的线程：</p>
<p>// AbstractChannel</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register0</span><span class="params">(ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		...</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">firstRegistration</span> <span class="operator">=</span> neverRegistered;</span><br><span class="line">        <span class="comment">// *** 进行 JDK 底层的操作：Channel 注册到 Selector 上 ***</span></span><br><span class="line">        doRegister();</span><br><span class="line">        </span><br><span class="line">        neverRegistered = <span class="literal">false</span>;</span><br><span class="line">        registered = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 到这里，就算是 registered 了</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这一步也很关键，因为这涉及到了 ChannelInitializer 的 init(channel)</span></span><br><span class="line">        <span class="comment">// 我们之前说过，init 方法会将 ChannelInitializer 内部添加的 handlers 添加到 pipeline 中</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置当前 promise 的状态为 success</span></span><br><span class="line">        <span class="comment">//   因为当前 register 方法是在 eventLoop 中的线程中执行的，需要通知提交 register 操作的线程</span></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当前的 register 操作已经成功，该事件应该被 pipeline 上</span></span><br><span class="line">        <span class="comment">//   所有关心 register 事件的 handler 感知到，往 pipeline 中扔一个事件</span></span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里 active 指的是 channel 已经打开</span></span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="comment">// 如果该 channel 是第一次执行 register，那么 fire ChannelActive 事件</span></span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                <span class="comment">// 该 channel 之前已经 register 过了，</span></span><br><span class="line">                <span class="comment">// 这里让该 channel 立马去监听通道中的 OP_READ 事件</span></span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先说掉上面的 doRegister() 方法，然后再说 pipeline。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">selected</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 附 JDK 中 Channel 的 register 方法：</span></span><br><span class="line">            <span class="comment">// public final SelectionKey register(Selector sel, int ops, Object att) &#123;...&#125;</span></span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这里做了 JDK 底层的 register 操作，将 SocketChannel(或 ServerSocketChannel) 注册到 Selector 中，并且可以看到，这里的监听集合设置为了 <strong>0</strong>，也就是什么都不监听。</p>
<blockquote>
<p>当然，也就意味着，后续一定有某个地方会需要修改这个 selectionKey 的监听集合，不然啥都干不了</p>
</blockquote>
<p>我们重点来说说 <strong>pipeline</strong> 操作，我们之前在介绍 NioSocketChannel 的 pipeline 的时候介绍到，我们的 pipeline 现在长这个样子：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/20.png" alt="20"></p>
<blockquote>
<p>现在，我们将看到这里会把 LoggingHandler 和 EchoClientHandler 添加到 pipeline。</p>
</blockquote>
<p>我们继续看代码，register 成功以后，执行了以下操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline.invokeHandlerAddedIfNeeded();</span><br></pre></td></tr></table></figure>

<p>大家可以跟踪一下，这一步会执行到 pipeline 中 ChannelInitializer 实例的 handlerAdded 方法，在这里会执行它的 init(context) 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.channel().isRegistered()) &#123;</span><br><span class="line">        initChannel(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们看下 initChannel(ctx)，这里终于来了我们之前介绍过的 init(channel) 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (initMap.putIfAbsent(ctx, Boolean.TRUE) == <span class="literal">null</span>) &#123; <span class="comment">// Guard against re-entrance.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 将把我们自定义的 handlers 添加到 pipeline 中</span></span><br><span class="line">            initChannel((C) ctx.channel());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 将 ChannelInitializer 实例从 pipeline 中删除</span></span><br><span class="line">            remove(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们前面也说过，ChannelInitializer 的 init(channel) 被执行以后，那么其内部添加的 handlers 会进入到 pipeline 中，然后上面的 finally 块中将 ChannelInitializer 的实例从 pipeline 中删除，那么此时 pipeline 就算建立起来了，如下图：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/21.png" alt="21"></p>
<blockquote>
<p>其实这里还有个问题，如果我们在 ChannelInitializer 中添加的是一个 ChannelInitializer 实例呢？大家可以考虑下这个情况。</p>
</blockquote>
<p>pipeline 建立了以后，然后我们继续往下走，会执行到这一句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline.fireChannelRegistered();</span><br></pre></td></tr></table></figure>

<p>我们只要摸清楚了 fireChannelRegistered() 方法，以后碰到其他像 fireChannelActive()、fireXxx() 等就知道怎么回事了，它们都是类似的。我们来看看这句代码会发生什么：</p>
<p>// DefaultChannelPipeline</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title function_">fireChannelRegistered</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 注意这里的传参是 head</span></span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelRegistered(head);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，我们往 pipeline 中扔了一个 <strong>channelRegistered</strong> 事件，这里的 register 属于 Inbound 事件，pipeline 接下来要做的就是执行 pipeline 中的 Inbound 类型的 handlers 中的 channelRegistered() 方法。</p>
<p>从上面的代码，我们可以看出，往 pipeline 中扔出 channelRegistered 事件以后，第一个处理的 handler 是 <strong>head</strong>。</p>
<p>接下来，我们还是跟着代码走，此时我们来到了 pipeline 的第一个节点 <strong>head</strong> 的处理中：</p>
<p>// AbstractChannelHandlerContext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next 此时是 head</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeChannelRegistered</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">    <span class="comment">// 执行 head 的 invokeChannelRegistered()</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRegistered();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                next.invokeChannelRegistered();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，这里会先执行 head.invokeChannelRegistered() 方法，而且是放到 NioEventLoop 中的 taskQueue 中执行的：</p>
<p>// AbstractChannelHandlerContext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeChannelRegistered</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// handler() 方法此时会返回 head</span></span><br><span class="line">            ((ChannelInboundHandler) handler()).channelRegistered(<span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            notifyHandlerException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fireChannelRegistered();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们去看 head 的 channelRegistered 方法：</p>
<p>// HeadContext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1. 这一步是 head 对于 channelRegistered 事件的处理。没有我们要关心的</span></span><br><span class="line">    invokeHandlerAddedIfNeeded();</span><br><span class="line">    <span class="comment">// 2. 向后传播 Inbound 事件</span></span><br><span class="line">    ctx.fireChannelRegistered();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 head 会执行 fireChannelRegister() 方法：</p>
<p>// AbstractChannelHandlerContext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelHandlerContext <span class="title function_">fireChannelRegistered</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这里很关键</span></span><br><span class="line">    <span class="comment">// findContextInbound() 方法会沿着 pipeline 找到下一个 Inbound 类型的 handler</span></span><br><span class="line">    invokeChannelRegistered(findContextInbound());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：pipeline.fireChannelRegistered() 是将 channelRegistered 事件抛到 pipeline 中，pipeline 中的 handlers 准备处理该事件。而 context.fireChannelRegistered() 是一个 handler 处理完了以后，向后传播给下一个 handler。</p>
<p>它们两个的方法名字是一样的，但是来自于不同的类。</p>
</blockquote>
<p>findContextInbound() 将找到下一个 Inbound 类型的 handler，然后又是重复上面的几个方法。</p>
<blockquote>
<p>我觉得上面这块代码没必要太纠结，总之就是从 head 中开始，依次往下寻找所有 Inbound handler，执行其 channelRegistered(ctx) 操作。</p>
</blockquote>
<p>说了这么多，我们的 register 操作算是真正完成了。</p>
<p>下面，我们回到 initAndRegister 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们上面说完了这行</span></span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> config().group().register(channel);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果在 register 的过程中，发生了错误</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 源码中说得很清楚，如果到这里，说明后续可以进行 connect() 或 bind() 了，因为两种情况：</span></span><br><span class="line">    <span class="comment">// 1. 如果 register 动作是在 eventLoop 中发起的，那么到这里的时候，register 一定已经完成</span></span><br><span class="line">    <span class="comment">// 2. 如果 register 任务已经提交到 eventLoop 中，也就是进到了 eventLoop 中的 taskQueue 中，</span></span><br><span class="line">    <span class="comment">//    由于后续的 connect 或 bind 也会进入到同一个 eventLoop 的 queue 中，所以一定是会先 register 成功，才会执行 connect 或 bind</span></span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要知道，不管是服务端的 NioServerSocketChannel 还是客户端的 NioSocketChannel，在 bind 或 connect 时，都会先进入 initAndRegister 这个方法，所以我们上面说的那些，对于两者都是通用的。</p>
<p>大家要记住，register 操作是非常重要的，要知道这一步大概做了哪些事情，register 操作以后，将进入到 bind 或 connect 操作中。</p>
<h2 id="connect-过程和-bind-过程分析"><a href="#connect-过程和-bind-过程分析" class="headerlink" title="connect 过程和 bind 过程分析"></a>connect 过程和 bind 过程分析</h2><p>上面我们介绍的 register 操作非常关键，它建立起来了很多的东西，它是 Netty 中 NioSocketChannel 和 NioServerSocketChannel 开始工作的起点。</p>
<p>这一节，我们来说说 register 之后的 connect 操作和 bind 操作。这节非常简单。</p>
<h3 id="connect-过程分析"><a href="#connect-过程分析" class="headerlink" title="connect 过程分析"></a>connect 过程分析</h3><p>对于客户端 NioSocketChannel 来说，前面 register 完成以后，就要开始 connect 了，这一步将连接到服务端。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">doResolveAndConnect</span><span class="params">(<span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里完成了 register 操作</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> regFuture.channel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里我们不去纠结 register 操作是否 isDone()</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!regFuture.isSuccess()) &#123;</span><br><span class="line">            <span class="keyword">return</span> regFuture;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 看这里</span></span><br><span class="line">        <span class="keyword">return</span> doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里大家自己一路点进去，我就不浪费篇幅了。最后，我们会来到 AbstractChannel 的 connect 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">connect</span><span class="params">(SocketAddress remoteAddress, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.connect(remoteAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，connect 操作是交给 pipeline 来执行的。进入 pipeline 中，我们会发现，connect 这种 Outbound 类型的操作，是从 pipeline 的 tail 开始的：</p>
<blockquote>
<p>前面我们介绍的 register 操作是 Inbound 的，是从 head 开始的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title function_">connect</span><span class="params">(SocketAddress remoteAddress, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tail.connect(remoteAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是 pipeline 的操作了，从 tail 开始，执行 pipeline 上的 Outbound 类型的 handlers 的 connect(…) 方法，那么真正的底层的 connect 的操作发生在哪里呢？还记得我们的 pipeline 的图吗？</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/22.png" alt="22"></p>
<p>从 tail 开始往前找 out 类型的 handlers，每经过一个 handler，都执行里面的 connect() 方法，最后会到 head 中，因为 head 也是 Outbound 类型的，我们需要的 connect 操作就在 head 中，它会负责调用 unsafe 中提供的 connect 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HeadContext</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(</span></span><br><span class="line"><span class="params">        ChannelHandlerContext ctx,</span></span><br><span class="line"><span class="params">        SocketAddress remoteAddress, SocketAddress localAddress,</span></span><br><span class="line"><span class="params">        ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    unsafe.connect(remoteAddress, localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们来看一看 connect 在 unsafe 类中所谓的底层操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractNioChannel.AbstractNioUnsafe</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">		......</span><br><span class="line">            </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">wasActive</span> <span class="operator">=</span> isActive();</span><br><span class="line">        <span class="comment">// 大家自己点进去看 doConnect 方法</span></span><br><span class="line">        <span class="comment">// 这一步会做 JDK 底层的 SocketChannel connect，然后设置 interestOps 为 SelectionKey.OP_CONNECT</span></span><br><span class="line">        <span class="comment">// 返回值代表是否已经连接成功</span></span><br><span class="line">        <span class="keyword">if</span> (doConnect(remoteAddress, localAddress)) &#123;</span><br><span class="line">            <span class="comment">// 处理连接成功的情况</span></span><br><span class="line">            fulfillConnectPromise(promise, wasActive);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            connectPromise = promise;</span><br><span class="line">            requestedRemoteAddress = remoteAddress;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面这块代码，在处理连接超时的情况，代码很简单</span></span><br><span class="line">            <span class="comment">// 这里用到了 NioEventLoop 的定时任务的功能，这个我们之前一直都没有介绍过，因为我觉得也不太重要</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">connectTimeoutMillis</span> <span class="operator">=</span> config().getConnectTimeoutMillis();</span><br><span class="line">            <span class="keyword">if</span> (connectTimeoutMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                connectTimeoutFuture = eventLoop().schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="type">ChannelPromise</span> <span class="variable">connectPromise</span> <span class="operator">=</span> AbstractNioChannel.<span class="built_in">this</span>.connectPromise;</span><br><span class="line">                        <span class="type">ConnectTimeoutException</span> <span class="variable">cause</span> <span class="operator">=</span></span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">ConnectTimeoutException</span>(<span class="string">&quot;connection timed out: &quot;</span> + remoteAddress);</span><br><span class="line">                        <span class="keyword">if</span> (connectPromise != <span class="literal">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;</span><br><span class="line">                            close(voidPromise());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            promise.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">if</span> (future.isCancelled()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (connectTimeoutFuture != <span class="literal">null</span>) &#123;</span><br><span class="line">                            connectTimeoutFuture.cancel(<span class="literal">false</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        connectPromise = <span class="literal">null</span>;</span><br><span class="line">                        close(voidPromise());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        promise.tryFailure(annotateConnectException(t, remoteAddress));</span><br><span class="line">        closeIfClosed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上面的 doConnect 方法返回 false，那么后续是怎么处理的呢？</p>
<p>在上一节介绍的 register 操作中，channel 已经 register 到了 selector 上，只不过将 interestOps 设置为了 0，也就是什么都不监听。</p>
<p>而在上面的 doConnect 方法中，我们看到它在调用底层的 connect 方法后，会设置 interestOps 为 <code>SelectionKey.OP_CONNECT</code>。</p>
<p>剩下的就是 NioEventLoop 的事情了，还记得 NioEventLoop 的 run() 方法吗？也就是说这里的 connect 成功以后，这个 TCP 连接就建立起来了，后续的操作会在 <code>NioEventLoop.run()</code> 方法中被 <code>processSelectedKeys()</code> 方法处理掉。</p>
<h3 id="bind-过程分析"><a href="#bind-过程分析" class="headerlink" title="bind 过程分析"></a>bind 过程分析</h3><p>说完 connect 过程，我们再来简单看下 bind 过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class="line">    <span class="comment">// **前面说的 initAndRegister**</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> initAndRegister();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        <span class="comment">// register 动作已经完成，那么执行 bind 操作</span></span><br><span class="line">        <span class="type">ChannelPromise</span> <span class="variable">promise</span> <span class="operator">=</span> channel.newPromise();</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后一直往里看，会看到，bind 操作也是要由 pipeline 来完成的：</p>
<p>// AbstractChannel</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bind 操作和 connect 一样，都是 Outbound 类型的，所以都是 tail 开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title function_">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tail.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的 bind 操作又到了 head 中，由 head 来调用 unsafe 提供的 bind 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(</span></span><br><span class="line"><span class="params">        ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    unsafe.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>感兴趣的读者自己去看一下 unsafe 中的 bind 方法，非常简单，bind 操作也不是什么异步方法，我们就介绍到这里了。</p>
<p>本节非常简单，就是想和大家介绍下 Netty 中各种操作的套路。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2018/11/03/netty-source-code-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/03/netty-source-code-1/" class="post-title-link" itemprop="url">认真的 Netty 源码解析（一）(转自JavaDoop)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-03 00:00:00" itemprop="dateCreated datePublished" datetime="2018-11-03T00:00:00+08:00">2018-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 15:16:47" itemprop="dateModified" datetime="2025-04-27T15:16:47+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/netty/" itemprop="url" rel="index"><span itemprop="name">netty</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文又是一篇源码分析文章，其实除了 Doug Lea 的并发包源码，我是真不太爱写源码分析。因为要花非常多的时间，而且很多地方需要反复组织语言。</p>
<p>本文将介绍 Netty，Java 平台上使用最广泛的 NIO 包，它是对 JDK 中的 NIO 实现的一层封装，让我们能更方便地开发 NIO 程序。其实，Netty 不仅仅是 NIO 吧，但是，基本上大家都冲着 NIO 来的。</p>
<p>个人感觉国内对于 Netty 的吹嘘是有点过了，主要是很多人靠它吃饭，要么是搞培训的，要么是出书的，恨不得把 Netty 吹上天去，这种现象也是挺不好的，反而使得初学者觉得 Netty 是什么高深的技术一样。</p>
<p>Netty 的源码不是很简单，因为它比较多，而且各个类之间的关系错综复杂，很多人说它的源码很好，这点我觉得一般，真要说好代码，还得 Doug Lea 的并发源码比较漂亮，一行行都是精华，不过它们是不同类型的，也没什么好对比的。Netty 源码好就好在它的接口使用比较灵活，往往接口好用的框架，源码都不会太简单。</p>
<p>本文将立足于源码分析，所以读者需要先掌握 NIO 的基础知识，至少我之前写的 <a href="/post/java-nio">《Java NIO：Buffer、Channel 和 Selector》</a> 中介绍的基础知识要清楚，如果读者已经对 Netty 有些了解，或者使用过，那就更好了。</p>
<ul>
<li>本文只介绍 TCP 相关的内容，Netty 对于其他协议的支持，不在本文的讨论范围内。</li>
<li>和并发包的源码分析不一样，我不可能一行一行源码说，所以有些异常分支是会直接略过，除非我觉得需要介绍。</li>
<li>Netty 源码一直在更新，各版本之间有些差异，我是按照 2018-09-06 的最新版本 <strong>4.1.25.Final</strong> 来进行介绍的。</li>
</ul>
<p>建议初学者在看完本文以后，可以去翻翻《Netty In Action》，网上也可以找到中文文字版的。</p>
<!-- toc -->

<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>学习源码，一开始肯定是准备环境。</p>
<p>我喜欢用 maven，也喜欢 Spring Boot，所以我一般先到 <a target="_blank" rel="noopener" href="https://start.spring.io/">https://start.spring.io/</a> 准备一个最简单的脚手架。</p>
<p>10 秒搞定脚手架，然后就是导入到 Intellij 中，如果用新版本的 Spring Boot，可能还需要等待下载依赖，期间打开 <a target="_blank" rel="noopener" href="https://mvnrepository.com/">https://mvnrepository.com/</a> 搜索马上要用到的 maven 依赖。</p>
<p>Netty 分为好些模块，有 <a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/io.netty/netty-handler">netty-handler</a>、<a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/io.netty/netty-buffer">netty-buffer</a>、<a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/io.netty/netty-transport">netty-transport</a>、<a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/io.netty/netty-common">netty-common</a> 等等，也有一个 <a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/io.netty/netty-all">netty-all</a>，它包含了所有的模块。</p>
<p>既然我们是源码分析，那么自然是用一个最简单的。netty-all 不是最好的选择，netty-example 才是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-example<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.25.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>它不仅可以解决我们的依赖，而且 example 里面的示例非常适合我们学习使用。</p>
<h2 id="Echo-例子"><a href="#Echo-例子" class="headerlink" title="Echo 例子"></a>Echo 例子</h2><p>Netty 作为 NIO 的库，自然既可以作为服务端接受请求，也可以作为客户端发起请求。使用 Netty 开发客户端或服务端都是非常简单的，Netty 做了很好的封装，我们通常只要开发一个或多个 <strong>handler</strong> 用来处理我们的自定义逻辑就可以了。</p>
<p>下面，我们来看一个经常会见到的例子，它叫 <strong>Echo</strong>，也就是<strong>回声</strong>，客户端传过去什么值，服务端原样返回什么值。</p>
<blockquote>
<p>打开 netty-example 的源码，把 <code>echo</code> 包下面的代码复制出来玩一玩。</p>
</blockquote>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/5.png" alt="5"></p>
<blockquote>
<p>左边是服务端代码，右边是客户端代码。</p>
</blockquote>
<p>上面的代码基本就是模板代码，每次使用都是这一个套路，唯一需要我们开发的部分是 handler(…) 和 childHandler(…) 方法中指定的各个 handler，如 <strong>EchoServerHandler</strong> 和 <strong>EchoClientHandler</strong>，当然 Netty 源码也给我们提供了很多的 handler，比如上面的 LoggingHandler，它就是 Netty 源码中为我们提供的，需要的时候直接拿过来用就好了。</p>
<p>我们先来看一下上述代码中涉及到的一些内容：</p>
<ul>
<li><p>ServerBootstrap 类用于创建服务端实例，Bootstrap 用于创建客户端实例。</p>
</li>
<li><p>两个 EventLoopGroup：bossGroup 和 workerGroup，它们涉及的是 Netty 的线程模型，可以看到服务端有两个 group，而客户端只有一个，它们就是 Netty 中的线程池。</p>
</li>
<li><p>Netty 中的 Channel，没有直接使用 Java 原生的 ServerSocketChannel 和 SocketChannel，而是包装了 NioServerSocketChannel 和 NioSocketChannel 与之对应。</p>
<blockquote>
<p>当然，也有对其他协议的支持，如支持 UDP 协议的 NioDatagramChannel，本文只关心 TCP 相关的。</p>
</blockquote>
</li>
<li><p>左边 handler(…) 方法指定了一个 handler（LoggingHandler），这个 handler 是给服务端收到新的请求的时候处理用的。右边 handler(…) 方法指定了客户端处理请求过程中需要使用的 handlers。</p>
<blockquote>
<p>如果你想在 EchoServer 中也指定多个 handler，也可以像右边的 EchoClient 一样使用 ChannelInitializer</p>
</blockquote>
</li>
<li><p>左边 childHandler(…) 指定了 childHandler，这边的 handlers 是给新创建的连接用的，我们知道服务端 ServerSocketChannel 在 accept 一个连接以后，需要创建 SocketChannel 的实例，childHandler(…) 中设置的 handler 就是用于处理新创建的 SocketChannel 的，而不是用来处理 ServerSocketChannel 实例的。</p>
</li>
<li><p>pipeline：handler 可以指定多个（需要上面的 ChannelInitializer 类辅助），它们会组成了一个 pipeline，它们其实就类似拦截器的概念，现在只要记住一点，每个 NioSocketChannel 或 NioServerSocketChannel 实例内部都会有一个 pipeline 实例。pipeline 中还涉及到 handler 的执行顺序。</p>
</li>
<li><p>ChannelFuture：这个涉及到 Netty 中的异步编程，和 JDK 中的 Future 接口类似。</p>
</li>
</ul>
<p>对于不了解 Netty 的读者，也不要有什么压力，我会一一介绍它们，本文主要面向新手，我觉得比较难理解或比较重要的部分，会花比较大的篇幅来介绍清楚。</p>
<p>上面的源码中没有展示消息发送和消息接收的处理，此部分我会在介绍完上面的这些内容以后再进行介绍。</p>
<p>下面，将分块来介绍这些内容。鉴于读者对 NIO 或 Netty 的了解程度可能参差不齐，为了照顾初学者，很多地方需要啰嗦一些，所以希望读者一节一节往下看，对于自己熟悉的内容可以适当看快一些。</p>
<h2 id="Netty-中的-Channel"><a href="#Netty-中的-Channel" class="headerlink" title="Netty 中的 Channel"></a>Netty 中的 Channel</h2><p>这节我们来看看 NioSocketChannel 是怎么和 JDK 底层的 SocketChannel 联系在一起的，它们是一对一的关系。NioServerSocketChannel 和 ServerSocketChannel 同理，也是一对一的关系。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/3.png" alt="3"></p>
<p>在 Bootstrap（客户端） 和 ServerBootstrap（服务端） 的启动过程中都会调用 channel(…) 方法：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/10.png" alt="10"></p>
<p>下面，我们来看 channel(…) 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractBootstrap</span></span><br><span class="line"><span class="keyword">public</span> B <span class="title function_">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (channelClass == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;channelClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> <span class="title class_">ReflectiveChannelFactory</span>&lt;C&gt;(channelClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这个方法只是设置了 channelFactory 为 ReflectiveChannelFactory 的一个实例，然后我们看下这里的 ReflectiveChannelFactory 到底是什么：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/1.png" alt="1"></p>
<p><strong>newChannel()</strong> 方法是 ChannelFactory 接口中的唯一方法，<strong>工厂模式</strong>大家都很熟悉。我们可以看到，<code>ReflectiveChannelFactory#newChannel()</code> 方法中使用了反射调用 Channel 的无参构造方法来创建 Channel，我们只要知道，ChannelFactory 的 newChannel() 方法什么时候会被调用就可以了。</p>
<ul>
<li>对于 NioSocketChannel，由于它充当客户端的功能，它的创建时机在 <code>connect(…)</code> 的时候；</li>
<li>对于 NioServerSocketChannel 来说，它充当服务端功能，它的创建时机在绑定端口 <code>bind(…)</code> 的时候。</li>
</ul>
<p>接下来，我们来简单追踪下充当客户端的 Bootstrap 中 NioSocketChannel 的创建过程，看看 NioSocketChannel 是怎么和 JDK 中的 SocketChannel 关联在一起的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bootstrap</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">connect</span><span class="params">(String inetHost, <span class="type">int</span> inetPort)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> connect(InetSocketAddress.createUnresolved(inetHost, inetPort));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再往里看，到这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">connect</span><span class="params">(SocketAddress remoteAddress)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (remoteAddress == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;remoteAddress&quot;</span>);</span><br><span class="line">    <span class="comment">// validate 只是校验一下各个参数是不是正确设置了</span></span><br><span class="line">    validate();</span><br><span class="line">    <span class="keyword">return</span> doResolveAndConnect(remoteAddress, config.localAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 再往里就到这里了</span></span><br><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">doResolveAndConnect</span><span class="params">(<span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class="line">    <span class="comment">// 我们要说的部分在这里</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> regFuture.channel();</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们看 <code>initAndRegister()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 前面我们说过，这里会进行 Channel 的实例化</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们找到了 <code>channel = channelFactory.newChannel()</code> 这行代码，根据前面说的，这里会调用相应 Channel 的无参构造方法。</p>
<p>然后我们就可以去看 NioSocketChannel 的构造方法了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioSocketChannel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// SelectorProvider 实例用于创建 JDK 的 SocketChannel 实例</span></span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_SELECTOR_PROVIDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioSocketChannel</span><span class="params">(SelectorProvider provider)</span> &#123;</span><br><span class="line">    <span class="comment">// 看这里，newSocket(provider) 方法会创建 JDK 的 SocketChannel</span></span><br><span class="line">    <span class="built_in">this</span>(newSocket(provider));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在调用 newSocket(provider) 的时候，会创建 JDK NIO 的一个 SocketChannel 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SocketChannel <span class="title function_">newSocket</span><span class="params">(SelectorProvider provider)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 SocketChannel 实例</span></span><br><span class="line">        <span class="keyword">return</span> provider.openSocketChannel();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ChannelException</span>(<span class="string">&quot;Failed to open a socket.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NioServerSocketChannel 同理，也非常简单，从 <code>ServerBootstrap#bind(...)</code> 方法一路点进去就清楚了。</p>
<p>所以我们知道了，NioSocketChannel 在实例化过程中，会先实例化 JDK 底层的 SocketChannel，NioServerSocketChannel 也一样，会先实例化 ServerSocketChannel 实例：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/18.png" alt="18"></p>
<p>说到这里，我们顺便再继续往里看一下 NioSocketChannel 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioSocketChannel</span><span class="params">(SelectorProvider provider)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(newSocket(provider));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚才我们看到这里，newSocket(provider) 创建了底层的 SocketChannel 实例，我们继续往下看构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioSocketChannel</span><span class="params">(Channel parent, SocketChannel socket)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent, socket);</span><br><span class="line">    config = <span class="keyword">new</span> <span class="title class_">NioSocketChannelConfig</span>(<span class="built_in">this</span>, socket.socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面有两行代码，第二行代码很简单，实例化了内部的 NioSocketChannelConfig 实例，它用于保存 channel 的配置信息，这里没有我们现在需要关心的内容，直接跳过。</p>
<p>第一行调用父类构造器，除了设置属性外，还设置了 SocketChannel 的非阻塞模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractNioByteChannel</span><span class="params">(Channel parent, SelectableChannel ch)</span> &#123;</span><br><span class="line">    <span class="comment">// 毫无疑问，客户端关心的是 OP_READ 事件，等待读取服务端返回数据</span></span><br><span class="line">    <span class="built_in">super</span>(parent, ch, SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后是到这里</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="type">int</span> readInterestOp)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">    <span class="built_in">this</span>.ch = ch;</span><br><span class="line">    <span class="comment">// 我们看到这里只是保存了 SelectionKey.OP_READ 这个信息，在后面的时候会用到</span></span><br><span class="line">    <span class="built_in">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ******设置 channel 的非阻塞模式******</span></span><br><span class="line">        ch.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NioServerSocketChannel 的构造方法类似，也设置了非阻塞，然后设置服务端关心的 SelectionKey.OP_ACCEPT 事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> &#123;</span><br><span class="line">    <span class="comment">// 对于服务端来说，关心的是 SelectionKey.OP_ACCEPT 事件，等待客户端连接</span></span><br><span class="line">    <span class="built_in">super</span>(<span class="literal">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    config = <span class="keyword">new</span> <span class="title class_">NioServerSocketChannelConfig</span>(<span class="built_in">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这节关于 Channel 的内容我们先介绍这么多，主要就是实例化了 JDK 层的 SocketChannel 或 ServerSocketChannel，然后设置了非阻塞模式，我们后面再继续深入下去。</p>
<h2 id="Netty-中的-Future、Promise"><a href="#Netty-中的-Future、Promise" class="headerlink" title="Netty 中的 Future、Promise"></a>Netty 中的 Future、Promise</h2><p>Netty 中非常多的异步调用，所以在介绍更多 NIO 相关的内容之前，我们来看看它的异步接口是怎么使用的。</p>
<p>前面我们在介绍 Echo 例子的时候，已经用过了 ChannelFuture 这个接口了：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/6.png" alt="6"></p>
<p>争取在看完本节后，读者能搞清楚上面的这几行划线部分是怎么走的。</p>
<p>关于 Future 接口，我想大家应该都很熟悉，用得最多的就是在使用 Java 的线程池 ThreadPoolExecutor 的时候了。在 <strong>submit</strong> 一个任务到线程池中的时候，返回的就是一个 <strong>Future</strong> 实例，通过它来获取提交的任务的执行状态和最终的执行结果，我们最常用它的 <code>isDone()</code> 和 <code>get()</code> 方法。</p>
<p>下面是 JDK  中的 Future 接口 java.util.concurrent.Future：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">	<span class="comment">// 取消该任务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="comment">// 任务是否已取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">// 任务是否已完成</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 阻塞获取任务执行结果</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    <span class="comment">// 带超时参数的获取任务执行结果</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Netty 中的 Future 接口（同名）继承了 JDK 中的 Future 接口，然后添加了一些方法：</p>
<p>// io.netty.util.concurrent.Future</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">java</span>.util.concurrent.Future&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSuccess</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 是否可取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancellable</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果任务执行失败，这个方法返回异常信息</span></span><br><span class="line">    Throwable <span class="title function_">cause</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 Listener 来进行回调</span></span><br><span class="line">    Future&lt;V&gt; <span class="title function_">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt; listener)</span>;</span><br><span class="line">    Future&lt;V&gt; <span class="title function_">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt;... listeners)</span>;</span><br><span class="line"></span><br><span class="line">    Future&lt;V&gt; <span class="title function_">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt; listener)</span>;</span><br><span class="line">    Future&lt;V&gt; <span class="title function_">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt;... listeners)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待任务结束，如果任务失败，将“导致失败的异常”重新抛出来</span></span><br><span class="line">    Future&lt;V&gt; <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="comment">// 不响应中断的 sync()，这个大家应该都很熟了</span></span><br><span class="line">    Future&lt;V&gt; <span class="title function_">syncUninterruptibly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待任务结束，和 sync() 功能是一样的，不过如果任务失败，它不会抛出执行过程中的异常</span></span><br><span class="line">    Future&lt;V&gt; <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    Future&lt;V&gt; <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeoutMillis)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitUninterruptibly</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitUninterruptibly</span><span class="params">(<span class="type">long</span> timeoutMillis)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取执行结果，不阻塞。我们都知道 java.util.concurrent.Future 中的 get() 是阻塞的</span></span><br><span class="line">    V <span class="title function_">getNow</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消任务执行，如果取消成功，任务会因为 CancellationException 异常而导致失败</span></span><br><span class="line">    <span class="comment">//	  也就是 isSuccess()==false，同时上面的 cause() 方法返回 CancellationException 的实例。</span></span><br><span class="line">    <span class="comment">// mayInterruptIfRunning 说的是：是否对正在执行该任务的线程进行中断(这样才能停止该任务的执行)，</span></span><br><span class="line">    <span class="comment">// 	  似乎 Netty 中 Future 接口的各个实现类，都没有使用这个参数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完上面的 Netty 的 Future 接口，我们可以发现，它加了 sync() 和 await() 用于阻塞等待，还加了 Listeners，只要任务结束去回调 Listener 们就可以了，那么我们就不一定要主动调用 isDone() 来获取状态，或通过 get() 阻塞方法来获取值。</p>
<blockquote>
<p>所以它其实有两种使用范式</p>
</blockquote>
<p>顺便说下 sync() 和 await() 的区别：sync() 内部会先调用 await() 方法，等 await() 方法返回后，会检查下<strong>这个任务是否失败</strong>，如果失败，重新将导致失败的异常抛出来。也就是说，如果使用 await()，任务抛出异常后，await() 方法会返回，但是不会抛出异常，而 sync() 方法返回的同时会抛出异常。</p>
<blockquote>
<p>我们也可以看到，Future 接口没有和 IO 操作关联在一起，还是比较<em>纯净</em>的接口。</p>
</blockquote>
<p>接下来，我们来看 Future 接口的子接口 ChannelFuture，这个接口用得最多，它将和 IO 操作中的 Channel 关联在一起了，用于异步处理 Channel 中的事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChannelFuture</span> <span class="keyword">extends</span> <span class="title class_">Future</span>&lt;Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ChannelFuture 关联的 Channel</span></span><br><span class="line">    Channel <span class="title function_">channel</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆写以下几个方法，使得它们返回值为 ChannelFuture 类型 </span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt; listener)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt;... listeners)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt; listener)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt;... listeners)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">syncUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelFuture <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来标记该 future 是 void 的，</span></span><br><span class="line">    <span class="comment">// 这样就不允许使用 addListener(...), sync(), await() 以及它们的几个重载方法</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isVoid</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，ChannelFuture 接口相对于 Future 接口，除了将 channel 关联进来，没有增加什么东西。还有个 isVoid() 方法算是不那么重要的存在吧。其他几个都是方法覆写，为了让返回值类型变为 ChannelFuture，而不是原来的 Future。</p>
<p>这里有点跳，我们来介绍下 Promise 接口，它和 ChannelFuture 接口无关，而是和前面的 Future 接口相关，Promise 这个接口非常重要。</p>
<p>Promise 接口和 ChannelFuture 一样，也继承了 Netty 的 Future 接口，然后加了一些 Promise 的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Promise</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记该 future 成功及设置其执行结果，并且会通知所有的 listeners。</span></span><br><span class="line">    <span class="comment">// 如果该操作失败，将抛出异常(失败指的是该 future 已经有了结果了，成功的结果，或者失败的结果)</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">setSuccess</span><span class="params">(V result)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和 setSuccess 方法一样，只不过如果失败，它不抛异常，返回 false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">trySuccess</span><span class="params">(V result)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记该 future 失败，及其失败原因。</span></span><br><span class="line">    <span class="comment">// 如果失败，将抛出异常(失败指的是已经有了结果了)</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">setFailure</span><span class="params">(Throwable cause)</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 标记该 future 失败，及其失败原因。</span></span><br><span class="line">    <span class="comment">// 如果已经有结果，返回 false，不抛出异常</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryFailure</span><span class="params">(Throwable cause)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记该 future 不可以被取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">setUncancellable</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里和 ChannelFuture 一样，对这几个方法进行覆写，目的是为了返回 Promise 类型的实例</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt; listener)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt;... listeners)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt; listener)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt;... listeners)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">syncUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能有些读者对 Promise 的概念不是很熟悉，这里简单说两句。</p>
<p>我觉得只要明白一点，Promise 实例内部是一个任务，任务的执行往往是异步的，通常是一个线程池来处理任务。Promise 提供的 setSuccess(V result) 或 setFailure(Throwable t) 将来会被某个执行任务的线程在执行完成以后调用，同时那个线程在调用 setSuccess(result) 或 setFailure(t) 后会回调 listeners 的回调函数（当然，回调的具体内容不一定要由执行任务的线程自己来执行，它可以创建新的线程来执行，也可以将回调任务提交到某个线程池来执行）。而且，一旦 setSuccess(…) 或 setFailure(…) 后，那些 await() 或 sync() 的线程就会从等待中返回。</p>
<p><strong>所以这里就有两种编程方式，一种是用 await()，等 await() 方法返回后，得到 promise 的执行结果，然后处理它；另一种就是提供 Listener 实例，我们不太关心任务什么时候会执行完，只要它执行完了以后会去执行 listener 中的处理方法就行。</strong></p>
<p>接下来，我们再来看下 <strong>ChannelPromise</strong>，它继承了前面介绍的 ChannelFuture 和 Promise 接口。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/4.png" alt="4"></p>
<p>ChannelPromise 接口在 Netty 中使用得比较多，因为它综合了 ChannelFuture 和 Promise 两个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Special &#123;<span class="doctag">@link</span> ChannelFuture&#125; which is writable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChannelPromise</span> <span class="keyword">extends</span> <span class="title class_">ChannelFuture</span>, Promise&lt;Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆写 ChannelFuture 中的 channel() 方法，其实这个方法一点没变</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Channel <span class="title function_">channel</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面几个方法是覆写 Promise 中的接口，为了返回值类型是 ChannelPromise</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">setSuccess</span><span class="params">(Void result)</span>;</span><br><span class="line">    ChannelPromise <span class="title function_">setSuccess</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">trySuccess</span><span class="params">()</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">setFailure</span><span class="params">(Throwable cause)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里大家应该都熟悉了，下面几个方法的覆写也是为了得到 ChannelPromise 类型的实例</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt; listener)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt;... listeners)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt; listener)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt;... listeners)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">syncUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ChannelPromise <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a new &#123;<span class="doctag">@link</span> ChannelPromise&#125; if &#123;<span class="doctag">@link</span> #isVoid()&#125; returns &#123;<span class="doctag">@code</span> true&#125; otherwise itself.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 我们忽略这个方法吧。</span></span><br><span class="line">    ChannelPromise <span class="title function_">unvoid</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，它综合了 ChannelFuture 和 Promise 中的方法，只不过通过覆写将返回值都变为 ChannelPromise 了而已，<strong>没有增加什么新的功能</strong>。</p>
<p>小结一下，我们上面介绍了几个接口，Future 以及它的子接口 ChannelFuture 和 Promise，然后是 ChannelPromise 接口同时继承了 ChannelFuture 和 Promise。</p>
<p>我把这几个接口的主要方法列在一起，这样大家看得清晰些：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/7.png" alt="4"></p>
<p>接下来，我们需要来一个实现类，这样才能比较直观地看出它们是怎么使用的，因为上面的这些都是接口定义，具体还得看实现类是怎么工作的。</p>
<p>下面，我们来介绍下 <strong>DefaultPromise</strong> 这个实现类，这个类很常用，它的源码也不短，我们先介绍几个关键的内容，然后介绍一个示例使用。</p>
<p>首先，我们看下它有哪些属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultPromise</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractFuture</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">Promise</span>&lt;V&gt; &#123;</span><br><span class="line">	  <span class="comment">// 保存执行结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Object result;</span><br><span class="line">    <span class="comment">// 执行任务的线程池，promise 持有 executor 的引用，这个其实有点奇怪了</span></span><br><span class="line">    <span class="comment">// 因为“任务”其实没必要知道自己在哪里被执行的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor executor;</span><br><span class="line">	  <span class="comment">// 监听者，回调函数，任务结束后（正常或异常结束）执行</span></span><br><span class="line">    <span class="keyword">private</span> Object listeners;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待这个 promise 的线程数(调用sync()/await()进行等待的线程数量)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">short</span> waiters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否正在唤醒等待线程，用于防止重复执行唤醒，不然会重复执行 listeners 的回调方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> notifyingListeners;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看出，此类实现了 Promise，但是没有实现 ChannelFuture，所以它和 Channel 联系不起来。</p>
<p>别急，我们后面会碰到另一个类 DefaultChannelPromise 的使用，这个类是综合了 ChannelFuture 和 Promise 的，但是它的实现其实大部分都是继承自这里的 DefaultPromise 类的。</p>
</blockquote>
<p>说完上面的属性以后，大家可以看下 <code>setSuccess(V result)</code> 、<code>trySuccess(V result)</code> 和 <code>setFailure(Throwable cause)</code> 、 <code>tryFailure(Throwable cause)</code> 这几个方法：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/8.png" alt="8"></p>
<blockquote>
<p>看出 setSuccess(result) 和 trySuccess(result) 的区别了吗？</p>
</blockquote>
<p>上面几个方法都非常简单，先设置好值，然后执行监听者们的回调方法。notifyListeners() 方法感兴趣的读者也可以看一看，不过它还涉及到 Netty 线程池的一些内容，我们还没有介绍到线程池，这里就不展开了。上面的代码，在 setSuccess0 或 setFailure0 方法中都会唤醒阻塞在 sync() 或 await() 的线程</p>
<p>另外，就是可以看下 sync() 和 await() 的区别，其他的我觉得随便看看就好了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    await();</span><br><span class="line">    <span class="comment">// 如果任务是失败的，重新抛出相应的异常</span></span><br><span class="line">    rethrowIfFailed();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们来写个实例代码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造线程池</span></span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventExecutor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 DefaultPromise 实例</span></span><br><span class="line">    <span class="type">Promise</span> <span class="variable">promise</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>(executor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面给这个 promise 添加两个 listener</span></span><br><span class="line">    promise.addListener(<span class="keyword">new</span> <span class="title class_">GenericFutureListener</span>&lt;Future&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务结束，结果：&quot;</span> + future.get());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务失败，异常：&quot;</span> + future.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).addListener(<span class="keyword">new</span> <span class="title class_">GenericFutureListener</span>&lt;Future&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务结束，balabala...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务到线程池，五秒后执行结束，设置执行 promise 的结果</span></span><br><span class="line">    executor.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置 promise 的结果</span></span><br><span class="line">            <span class="comment">// promise.setFailure(new RuntimeException());</span></span><br><span class="line">            promise.setSuccess(<span class="number">123456</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main 线程阻塞等待执行结果</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        promise.sync();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码，两个 listener 将在 5 秒后将输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">任务结束，结果：123456</span><br><span class="line">任务结束，balabala...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>读者这里可以试一下 sync() 和 await() 的区别，在任务中调用 promise.setFailure(new RuntimeException()) 试试看。</p>
</blockquote>
<p>上面的代码中，大家可能会对线程池 executor 和 promise 之间的关系感到有点迷惑。读者应该也要清楚，具体的任务不一定就要在这个 executor 中被执行。任务结束以后，需要调用 promise.setSuccess(result) 作为通知。</p>
<p>通常来说，promise 代表的 future 是不需要和线程池搅在一起的，future 只关心任务是否结束以及任务的执行结果，至于是哪个线程或哪个线程池执行的任务，future 其实是不关心的。</p>
<p>不过 Netty 毕竟不是要创建一个通用的线程池实现，而是和它要处理的 IO 息息相关的，所以我们只不过要理解它就好了。</p>
<p>这节就说这么多吧，我们回过头来再看一下这张图，看看大家是不是看懂了这节内容：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/6.png" alt="6"></p>
<p>我们就说说上图左边的部分吧，虽然我们还不知道 bind() 操作中具体会做什么工作，但是我们应该可以猜出一二。</p>
<p>显然，main 线程调用 b.bind(port) 这个方法会返回一个 ChannelFuture，bind() 是一个异步方法，当某个执行线程执行了真正的绑定操作后，那个执行线程一定会标记这个 future 为成功（我们假定 bind 会成功），然后这里的 sync() 方法（main 线程）就会返回了。</p>
<blockquote>
<p>如果 bind(port) 失败，我们知道，sync() 方法会将异常抛出来，然后就会执行到 finally 块了。 </p>
</blockquote>
<p>一旦绑定端口 bind 成功，进入下面一行，f.channel() 方法会返回该 future 关联的 channel。</p>
<p>channel.closeFuture() 也会返回一个 ChannelFuture，然后调用了 sync() 方法，这个 sync() 方法返回的条件是：<strong>有其他的线程关闭了 NioServerSocketChannel</strong>，往往是因为需要停掉服务了，然后那个线程会设置 future 的状态（ setSuccess(result) 或 setFailure(cause) ），这个 sync() 方法才会返回。</p>
<p>这节就到这里，希望大家对 Netty 中的异步编程有些了解，后续碰到源码的时候能知道是怎么使用的了。</p>
<h2 id="ChannelPipeline，和-Inbound、Outbound"><a href="#ChannelPipeline，和-Inbound、Outbound" class="headerlink" title="ChannelPipeline，和 Inbound、Outbound"></a>ChannelPipeline，和 Inbound、Outbound</h2><p>我想很多读者应该或多或少都有 Netty 中 pipeline 的概念。前面我们说了，使用 Netty 的时候，我们通常就只要写一些自定义的 handler 就可以了，我们定义的这些 handler 会组成一个 pipeline，用于处理 IO 事件，这个和我们平时接触的 Filter 或 Interceptor 表达的差不多是一个意思。</p>
<p>每个 Channel 内部都有一个 pipeline，pipeline 由多个 handler 组成，handler 之间的顺序是很重要的，因为 IO 事件将按照顺序顺次经过 pipeline 上的 handler，这样每个 handler 可以专注于做一点点小事，由多个 handler 组合来完成一些复杂的逻辑。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/11.png" alt="11"></p>
<p>从图中，我们知道这是一个双向链表。</p>
<p>首先，我们看两个重要的概念：<strong>Inbound</strong> 和 <strong>Outbound</strong>。在 Netty 中，IO 事件被分为 Inbound 事件和 Outbound 事件。</p>
<p><strong>Outbound</strong> 的 <strong>out</strong> 指的是 <strong>出去</strong>，有哪些 IO 事件属于此类呢？比如 connect、write、flush 这些 IO 操作是往外部方向进行的，它们就属于 Outbound 事件。</p>
<p>其他的，诸如 accept、read 这种就属于 Inbound 事件。</p>
<blockquote>
<p>比如客户端在发起请求的时候，需要 1️⃣connect 到服务器，然后 2️⃣write 数据传到服务器，再然后 3️⃣read 服务器返回的数据，前面的 connect 和 write 就是 <strong>out</strong> 事件，后面的 read 就是 <strong>in</strong> 事件。</p>
</blockquote>
<p>比如很多初学者看不懂下面的这段代码，这段代码用于服务端的 childHandler 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line"><span class="number">2.</span> pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line"><span class="number">3.</span> pipeline.addLast(<span class="keyword">new</span> <span class="title class_">BizHandler</span>());</span><br></pre></td></tr></table></figure>

<p>初学者肯定都纳闷，以为这个顺序写错了，应该是先 decode 客户端过来的数据，然后用 BizHandler 处理业务逻辑，最后再 encode 数据然后返回给客户端，所以添加的顺序应该是 <strong>1 -&gt; 3 -&gt; 2</strong> 才对。</p>
<p>其实这里的三个 handler 是分组的，分为 Inbound（1 和 3） 和 Outbound（2）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line"><span class="number">2.</span> pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line"><span class="number">3.</span> pipeline.addLast(<span class="keyword">new</span> <span class="title class_">BizHandler</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端连接进来的时候，读取（read）客户端请求数据的操作是 Inbound 的，所以会先使用 1，然后是 3 对处理进行处理；</li>
<li>处理完数据后，返回给客户端数据的 write 操作是 Outbound 的，此时使用的是 2。</li>
</ul>
<p>所以虽然添加顺序有点怪，但是执行顺序其实是按照 1 -&gt; 3 -&gt; 2 进行的。</p>
<blockquote>
<p>如果我们在上面的基础上，加上下面的第四行，这是一个 OutboundHandler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.</span> pipeline.addLast(<span class="keyword">new</span> <span class="title class_">OutboundHandlerA</span>());</span><br></pre></td></tr></table></figure>

<p>那么执行顺序是不是就是 1 -&gt; 3 -&gt; 2 -&gt; 4 呢？答案是：不是的。</p>
<p>对于 Inbound 操作，按照添加顺序执行每个 Inbound 类型的 handler；而对于 Outbound 操作，是反着来的，从后往前，顺次执行 Outbound 类型的 handler。</p>
<p>所以，上面的顺序应该是先 1 后 3，它们是 Inbound 的，然后是 4，最后才是 2，它们两个是 Outbound 的。说实话，我真不喜欢这种组织方式。</p>
</blockquote>
<p>到这里，我想大家应该都知道 Inbound 和 Outbound 了吧？下面我们来介绍它们的接口使用。</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/9.png" alt="9"></p>
<p>定义处理 Inbound 事件的 handler 需要实现 ChannelInboundHandler，定义处理 Outbound 事件的 handler 需要实现 ChannelOutboundHandler。最下面的三个类，是 Netty 提供的适配器，特别的，如果我们希望定义一个 handler 能同时处理 Inbound 和 Outbound 事件，可以通过继承中间的 <strong>ChannelDuplexHandler</strong> 的方式，比如 <strong>LoggingHandler</strong> 这种既可以用来处理 Inbound 也可以用来处理 Outbound 事件的 handler。</p>
<p>有了 Inbound 和 Outbound 的概念以后，我们来开始介绍 Pipeline 的源码。</p>
<p>我们说过，一个 Channel 关联一个 pipeline，NioSocketChannel 和 NioServerSocketChannel 在执行构造方法的时候，都会走到它们的父类 AbstractChannel 的构造方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractChannel</span><span class="params">(Channel parent)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    <span class="comment">// 给每个 channel 分配一个唯一 id</span></span><br><span class="line">    id = newId();</span><br><span class="line">    <span class="comment">// 每个 channel 内部需要一个 Unsafe 的实例</span></span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    <span class="comment">// 每个 channel 内部都会创建一个 pipeline</span></span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的三行代码中，id 比较不重要，Netty 中的 Unsafe 实例其实挺重要的，这里简单介绍一下。</p>
<p>在 JDK 的源码中，sun.misc.Unsafe 类提供了一些底层操作的能力，它设计出来是给 JDK 中的源码使用的，比如 AQS、ConcurrentHashMap 等，我们在之前的并发包的源码分析中也看到了很多它们使用 Unsafe 的场景，这个 Unsafe 类不是给我们的代码使用的，是给 JDK 源码使用的（需要的话，我们也是可以获取它的实例的）。</p>
<blockquote>
<p>Unsafe 类的构造方法是 private 的，但是它提供了 getUnsafe() 这个静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br></pre></td></tr></table></figure>
<p>大家可以试一下，上面这行代码编译没有问题，但是执行的时候会抛 <code>java.lang.SecurityException</code> 异常，因为它就不是给我们的代码用的。</p>
<p>但是如果你就是想获取 Unsafe 的实例，可以通过下面这个代码获取到:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) f.get(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Netty 中的 Unsafe 也是同样的意思，它封装了 Netty 中会使用到的 JDK 提供的 NIO 接口，比如将 channel 注册到 selector 上，比如 bind 操作，比如 connect 操作等，<strong>这些操作都是稍微偏底层一些</strong>。Netty 同样也是不希望我们的业务代码使用 Unsafe 的实例，它是提供给 Netty 中的源码使用的。</p>
<blockquote>
<p>不过，对于我们源码分析来说，我们还是会有很多时候需要分析 Unsafe 中的源码的</p>
</blockquote>
<p>关于 Unsafe，我们后面用到了再说，这里只要知道，它封装了大部分需要访问 JDK 的 NIO 接口的操作就好了。这里我们继续将焦点放在实例化 pipeline 上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title function_">newChannelPipeline</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelPipeline</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里开始调用 DefaultChannelPipeline 的构造方法，并把当前 channel 的引用传入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">    succeededFuture = <span class="keyword">new</span> <span class="title class_">SucceededChannelFuture</span>(channel, <span class="literal">null</span>);</span><br><span class="line">    voidPromise =  <span class="keyword">new</span> <span class="title class_">VoidChannelPromise</span>(channel, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    tail = <span class="keyword">new</span> <span class="title class_">TailContext</span>(<span class="built_in">this</span>);</span><br><span class="line">    head = <span class="keyword">new</span> <span class="title class_">HeadContext</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里实例化了 tail 和 head 这两个 handler。tail 实现了 ChannelInboundHandler 接口，而 head 实现了 ChannelOutboundHandler 和 ChannelInboundHandler 两个接口，并且最后两行代码将 tail 和 head 连接起来:</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/12.png" alt="12"></p>
<blockquote>
<p>注意，在不同的版本中，源码也略有差异，head 不一定是 in + out，大家知道这点就好了。</p>
<p>还有，从上面的 head 和 tail 我们也可以看到，其实 pipeline 中的每个元素是 <strong>ChannelHandlerContext</strong> 的实例，而不是 ChannelHandler 的实例，context 包装了一下 handler，但是，后面我们都会用 handler 来描述一个 pipeline 上的节点，而不是使用 context，希望读者知道这一点。</p>
</blockquote>
<p>这里只是构造了 pipeline，并且添加了两个固定的 handler 到其中（head + tail），还不涉及到自定义的 handler 代码执行。我们回过头来看下面这段代码：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/13.png" alt="13"></p>
<blockquote>
<p>我们说过 childHandler 中指定的 handler 不是给 NioServerSocketChannel 使用的，是给 NioSocketChannel 使用的，所以这里我们不看它。</p>
</blockquote>
<p>这里调用 handler(…) 方法指定了一个 LoggingHandler 的实例，然后我们再进去下面的 bind(…) 方法中看看这个 LoggingHandler 实例是怎么进入到我们之前构造的 pipeline 内的。</p>
<p>顺着 bind() 一直往前走，bind() -&gt; doBind() -&gt; initAndRegister()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 构造 channel 实例，同时会构造 pipeline 实例，</span></span><br><span class="line">        <span class="comment">// 现在 pipeline 中有 head 和 tail 两个 handler 了</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        <span class="comment">// 2. 看这里</span></span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的两行代码，第一行实现了构造 channel 和 channel 内部的 pipeline，我们来看第二行 init 代码：</p>
<p>// ServerBootstrap：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 拿到刚刚创建的 channel 内部的 pipeline 实例</span></span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> channel.pipeline();</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 开始往 pipeline 中添加一个 handler，这个 handler 是 ChannelInitializer 的实例</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们以后会看到，下面这个 initChannel 方法何时会被调用</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">            <span class="comment">// 这个方法返回我们最开始指定的 LoggingHandler 实例</span></span><br><span class="line">            <span class="type">ChannelHandler</span> <span class="variable">handler</span> <span class="operator">=</span> config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 添加 LoggingHandler</span></span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先不用管这里的 eventLoop</span></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 添加一个 handler 到 pipeline 中：ServerBootstrapAcceptor</span></span><br><span class="line">                    <span class="comment">// 从名字可以看到，这个 handler 的目的是用于接收客户端请求</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ServerBootstrapAcceptor</span>(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及到 pipeline 中的辅助类 ChannelInitializer，我们看到，它本身是一个 handler（Inbound 类型），但是它的作用和普通 handler 有点不一样，它纯碎是用来辅助将其他的 handler 加入到 pipeline 中的。</p>
<p>大家可以稍微看一下 ChannelInitializer 的 initChannel 方法，有个简单的认识就好，此时的 pipeline 应该是这样的：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/14.png" alt="14"></p>
<p>ChannelInitializer 的 initChannel(channel) 方法被调用的时候，会往 pipeline 中添加我们最开始指定的 <strong>LoggingHandler</strong> 和添加一个 <strong>ServerBootstrapAcceptor</strong>。但是我们现在还不知道这个 initChannel 方法何时会被调用。</p>
<p>上面我们说的是作为服务端的 NioServerSocketChannel 的 pipeline，NioSocketChannel 也是差不多的，我们可以看一下 Bootstrap 类的 init(channel) 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> channel.pipeline();</span><br><span class="line">    p.addLast(config.handler());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/23.png" alt="23"></p>
<p>它和服务端 ServerBootstrap 要添加 ServerBootstrapAcceptor 不一样，它只需要将 EchoClient 类中的 ChannelInitializer 实例加进来就可以了，它的 ChannelInitializer 中添加了两个 handler，LoggingHandler 和 EchoClientHandler：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/16.png" alt="16"></p>
<p>很显然，我们需要的是像 LoggingHandler 和 EchoClientHandler 这样的 handler，但是，它们现在还不在 pipeline 中，那么它们什么时候会真正进入到 pipeline 中呢？以后我们再揭晓。</p>
<p>还有，为什么 Server 端我们指定的是一个 handler 实例，而 Client 指定的是一个 ChannelInitializer 实例？其实它们是可以随意搭配使用的，你甚至可以在 ChannelInitializer 实例中添加 ChannelInitializer 的实例。</p>
<p>非常抱歉，这里又要断了，下面要先介绍线程池了，大家要记住 pipeline 现在的样子，<strong>head + channelInitializer + tail</strong>。</p>
<p>本节没有介绍 handler 的向后传播，就是一个 handler 处理完了以后，怎么传递给下一个 handler 来处理？比如我们熟悉的 JavaEE 中的 Filter 是采用在一个 Filter 实例中调用 chain.doFilter(request, response) 来传递给下一个 Filter 这种方式的。</p>
<p>我们用下面这张图结束本节。下图展示了传播的方法，但我其实是更想让大家看一下，哪些事件是 Inbound 类型的，哪些是 Outbound 类型的：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/19.png" alt="19"></p>
<p>Outbound 类型的几个事件大家应该比较好认，注意 bind 也是 Outbound 类型的。</p>
<h2 id="Netty-中的线程池-EventLoopGroup"><a href="#Netty-中的线程池-EventLoopGroup" class="headerlink" title="Netty 中的线程池 EventLoopGroup"></a>Netty 中的线程池 EventLoopGroup</h2><p>接下来，我们来分析 Netty 中的线程池。Netty 中的线程池比较不好理解，因为它的类比较多，而且它们之间的关系错综复杂。看下图，感受下 NioEventLoop 类和 NioEventLoopGroup 类的继承结构：</p>
<p><img src="https://assets.javadoop.com/imgs/20510079/netty-source/2.png" alt="2"></p>
<p>这张图我按照继承关系整理而来，大家仔细看一下就会发现，涉及到的类确实挺多的。本节来给大家理理清楚这部分内容。</p>
<p>首先，我们说的 Netty 的线程池，指的就是 <strong>NioEventLoopGroup</strong> 的实例；线程池中的单个线程，指的是右边 <strong>NioEventLoop</strong> 的实例。</p>
<p>我们第一节介绍的 Echo 例子，客户端和服务端的启动代码中，最开始我们总是先实例化 NioEventLoopGroup：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EchoClient 代码最开始：</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// EchoServer 代码最开始：</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br></pre></td></tr></table></figure>

<p>下面，我们就从 NioEventLoopGroup 的源码开始进行分析。</p>
<p>我们打开 NioEventLoopGroup 的源码，可以看到，NioEventLoopGroup 有多个构造方法用于参数设置，最简单地，我们采用无参构造函数，或仅仅设置线程数量就可以了，其他的参数采用默认值。</p>
<blockquote>
<p>比如上面的代码中，我们只在实例化 bossGroup 的时候指定了参数，代表该线程池需要一个线程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(nThreads, (Executor) <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 参数最全的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor, EventExecutorChooserFactory chooserFactory,</span></span><br><span class="line"><span class="params">                         <span class="keyword">final</span> SelectorProvider selectorProvider,</span></span><br><span class="line"><span class="params">                         <span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory,</span></span><br><span class="line"><span class="params">                         <span class="keyword">final</span> RejectedExecutionHandler rejectedExecutionHandler)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">    <span class="built_in">super</span>(nThreads, executor, chooserFactory, selectorProvider, selectStrategyFactory, rejectedExecutionHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来稍微看一下构造方法中的各个参数：</p>
<ul>
<li>nThreads：这个最简单，就是线程池中的线程数，也就是 NioEventLoop 的实例数量。</li>
<li>executor：我们知道，我们本身就是要构造一个线程池（Executor），为什么这里传一个 executor 实例呢？它其实不是给线程池用的，而是给 NioEventLoop 用的，以后再说。</li>
<li>chooserFactory：当我们提交一个任务到线程池的时候，线程池需要选择（choose）其中的一个线程来执行这个任务，这个就是用来实现选择策略的。</li>
<li>selectorProvider：这个简单，我们需要通过它来实例化 JDK 的 Selector，可以看到每个线程池都持有一个 selectorProvider 实例。</li>
<li>selectStrategyFactory：这个涉及到的是线程池中线程的工作流程，在介绍 NioEventLoop 的时候会说。</li>
<li>rejectedExecutionHandler：这个也是线程池的好朋友了，用于处理线程池中没有可用的线程来执行任务的情况。在 Netty 中稍微有一点点不一样，这个是给 NioEventLoop 实例用的，以后我们再详细介绍。</li>
</ul>
<p>这里介绍这些参数是希望大家有个印象而已，大家发现没有，在构造 NioEventLoopGroup 实例时的好几个参数，都是用来构造 NioEventLoop 用的。</p>
<p>下面，我们从 NioEventLoopGroup 的无参构造方法开始，跟着源码走：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后一步步走下去，到这个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory, <span class="keyword">final</span> SelectorProvider selectorProvider, <span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">super</span>(nThreads, threadFactory, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家自己要去跟一下源码，这样才知道中间设置了哪些默认值，下面这几个参数都被设置了默认值： </p>
<ul>
<li><p>selectorProvider = SelectorProvider.provider()</p>
<blockquote>
<p>这个没什么好说的，调用了 JDK 提供的方法</p>
</blockquote>
</li>
<li><p>selectStrategyFactory = DefaultSelectStrategyFactory.INSTANCE</p>
<blockquote>
<p>这个涉及到的是线程在做 select 操作和执行任务过程中的策略选择问题，在介绍 NioEventLoop 的时候会用到。 </p>
</blockquote>
</li>
<li><p>rejectedExecutionHandler = RejectedExecutionHandlers.reject()</p>
<blockquote>
<p>大家进去看一下 reject() 方法，也就是说，Netty 选择的默认拒绝策略是：抛出异常</p>
</blockquote>
</li>
</ul>
<p>跟着源码走，我们会来到父类 MultithreadEventLoopGroup 的构造方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory, Object... args)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们发现，如果采用无参构造函数，那么到这里的时候，默认地 nThreads 会被设置为 **CPU 核心数 *2**。大家可以看下 DEFAULT_EVENT_LOOP_THREADS 的默认值，以及 static 代码块的设值逻辑。</p>
<p>我们继续往下走：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventExecutorGroup</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory, Object... args)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(nThreads, threadFactory == <span class="literal">null</span> ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">ThreadPerTaskExecutor</span>(threadFactory), args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这一步的时候，<code>new ThreadPerTaskExecutor(threadFactory)</code> 会构造一个 executor。</p>
<blockquote>
<p>我们现在还不知道这个 executor 怎么用。这里我们先看下它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPerTaskExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (threadFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;threadFactory&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">        <span class="comment">// 为每个任务新建一个线程</span></span><br><span class="line">        threadFactory.newThread(command).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Executor 作为线程池的最顶层接口， 我们知道，它只有一个 execute(runnable) 方法，从上面我们可以看到，实现类 ThreadPerTaskExecutor 的逻辑就是<strong>每来一个任务，新建一个线程</strong>。</p>
<p>我们先记住这个，前面也说了，它是给 NioEventLoop 用的，不是给 NioEventLoopGroup 用的。</p>
</blockquote>
<p>上一步设置完了 executor，我们继续往下看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventExecutorGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor, Object... args)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步设置了 chooserFactory，用来实现从线程池中选择一个线程的选择策略。</p>
<blockquote>
<p>ChooserFactory 的逻辑比较简单，我们看下 DefaultEventExecutorChooserFactory 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> EventExecutorChooser <span class="title function_">newChooser</span><span class="params">(EventExecutor[] executors)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPowerOfTwo(executors.length)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PowerOfTwoEventExecutorChooser</span>(executors);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GenericEventExecutorChooser</span>(executors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里设置的策略也很简单：</p>
<p>1、如果线程池的线程数量是 2^n，采用下面的方式会高效一些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> EventExecutor <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、如果不是，用取模的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> EventExecutor <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> executors[Math.abs(idx.getAndIncrement() % executors.length)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>走了这么久，我们终于到了一个<strong>干实事</strong>的构造方法中了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventExecutorGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor,</span></span><br><span class="line"><span class="params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// executor 如果是 null，做一次和前面一样的默认设置。</span></span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="literal">null</span>) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> <span class="title class_">ThreadPerTaskExecutor</span>(newDefaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的 children 数组非常重要，它就是线程池中的线程数组，这么说不太严谨，但是就大概这个意思</span></span><br><span class="line">    children = <span class="keyword">new</span> <span class="title class_">EventExecutor</span>[nThreads];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这个 for 循环将实例化 children 数组中的每一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化！！！！！！</span></span><br><span class="line">            children[i] = newChild(executor, args);</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Think about if this is a good exception type</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;failed to create a child event loop&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果有一个 child 实例化失败，那么 success 就会为 false，然后进入下面的失败处理逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="comment">// 把已经成功实例化的“线程” shutdown，shutdown 是异步操作</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    children[j].shutdownGracefully();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待这些线程成功 shutdown</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    <span class="type">EventExecutor</span> <span class="variable">e</span> <span class="operator">=</span> children[j];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> (!e.isTerminated()) &#123;</span><br><span class="line">                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException interrupted) &#123;</span><br><span class="line">                        <span class="comment">// 把中断状态设置回去，交给关心的线程来处理.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ================================================</span></span><br><span class="line">    <span class="comment">// === 到这里，就是代表上面的实例化所有线程已经成功结束 ===</span></span><br><span class="line">    <span class="comment">// ================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过之前设置的 chooserFactory 来实例化 Chooser，把线程池数组传进去，</span></span><br><span class="line">    <span class="comment">//     这就不必再说了吧，实现线程选择策略</span></span><br><span class="line">    chooser = chooserFactory.newChooser(children);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置一个 Listener 用来监听该线程池的 termination 事件</span></span><br><span class="line">    <span class="comment">// 下面的代码逻辑是：给池中每一个线程都设置这个 listener，当监听到所有线程都 terminate 以后，这个线程池就算真正的 terminate 了。</span></span><br><span class="line">    <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> <span class="title class_">FutureListener</span>&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                terminationFuture.setSuccess(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (EventExecutor e: children) &#123;</span><br><span class="line">        e.terminationFuture().addListener(terminationListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 readonlyChildren，它是只读集合，以后用到再说</span></span><br><span class="line">    Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;EventExecutor&gt;(children.length);</span><br><span class="line">    Collections.addAll(childrenSet, children);</span><br><span class="line">    readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码非常简单吧，没有什么需要特别说的，接下来，我们来看看 newChild() 这个方法，这个方法非常重要，它将创建线程池中的线程。</p>
<blockquote>
<p>我上面已经用过很多次”线程”这个词了，它可不是 Thread 的意思，而是指池中的个体，后面我们会看到每个”线程”在什么时候会真正创建 Thread 实例。反正每个 NioEventLoop 实例内部都会有一个自己的 Thread 实例，所以把这两个概念混在一起也无所谓吧。</p>
</blockquote>
<p><code>newChild(…)</code> 方法在 NioEventLoopGroup 中覆写了，上面说的”线程”其实就是 NioEventLoop：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> EventLoop <span class="title function_">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NioEventLoop</span>(<span class="built_in">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>],</span><br><span class="line">        ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它调用了 NioEventLoop 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;</span><br><span class="line">    <span class="comment">// 调用父类构造器</span></span><br><span class="line">    <span class="built_in">super</span>(parent, executor, <span class="literal">false</span>, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);</span><br><span class="line">    <span class="keyword">if</span> (selectorProvider == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;selectorProvider&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strategy == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;selectStrategy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    provider = selectorProvider;</span><br><span class="line">    <span class="comment">// 开启 NIO 中最重要的组件：Selector</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SelectorTuple</span> <span class="variable">selectorTuple</span> <span class="operator">=</span> openSelector();</span><br><span class="line">    selector = selectorTuple.selector;</span><br><span class="line">    unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">    selectStrategy = strategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先粗略观察一下，然后再往下看：</p>
<ul>
<li>在 Netty 中，NioEventLoopGroup 代表线程池，NioEventLoop 就是其中的线程。</li>
<li>线程池 NioEventLoopGroup 是池中的线程 NioEventLoop 的 <strong>parent</strong>，从上面的代码中的取名可以看出。</li>
<li>每个 NioEventLoop 都有自己的 Selector，上面的代码也反应了这一点，这和 Tomcat 中的 NIO 模型有点区别。</li>
<li>executor、selectStrategy 和 rejectedExecutionHandler 从 NioEventLoopGroup 中一路传到了 NioEventLoop 中。</li>
</ul>
<p>这个时候，我们来看一下 NioEventLoop 类的属性都有哪些，我们先忽略它继承自父类的属性，单单看它自己的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Selector selector;</span><br><span class="line"><span class="keyword">private</span> Selector unwrappedSelector;</span><br><span class="line"><span class="keyword">private</span> SelectedSelectionKeySet selectedKeys;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectorProvider provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">wakenUp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectStrategy selectStrategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">ioRatio</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> cancelledKeys;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> needsToSelectAgain;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结合它的构造方法我们来总结一下：</p>
<ul>
<li>provider：它由 NioEventLoopGroup 传进来，前面我们说了一个线程池有一个 selectorProvider，用于创建 Selector 实例</li>
<li>selector：虽然我们还没看创建 selector 的代码，但我们已经知道，在 Netty 中 Selector 是跟着线程池中的线程走的。也就是说，并非一个线程池一个 Selector 实例，而是线程池中每一个线程都有一个 Selector 实例。</li>
<li>selectStrategy：select 操作的策略，这个不急。</li>
<li>ioRatio：这是 IO 任务的执行时间比例，因为每个线程既有 IO 任务执行，也有非 IO 任务需要执行，所以该参数为了保证有足够时间是给 IO 的。这里也不需要急着去理解什么 IO 任务、什么非 IO 任务。</li>
</ul>
<p>然后我们继续走它的构造方法，我们看到上面的构造方法调用了父类的构造器，它的父类是 SingleThreadEventLoop。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">SingleThreadEventLoop</span><span class="params">(EventLoopGroup parent, Executor executor,</span></span><br><span class="line"><span class="params">                                <span class="type">boolean</span> addTaskWakesUp, <span class="type">int</span> maxPendingTasks,</span></span><br><span class="line"><span class="params">                                RejectedExecutionHandler rejectedExecutionHandler)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent, executor, addTaskWakesUp, maxPendingTasks, rejectedExecutionHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们可以直接忽略这个东西，以后我们也不会再介绍它</span></span><br><span class="line">    tailTasks = newTaskQueue(maxPendingTasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SingleThreadEventLoop 这个名字很诡异有没有？然后它的构造方法又调用了父类 SingleThreadEventExecutor 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">SingleThreadEventExecutor</span><span class="params">(EventExecutorGroup parent, Executor executor,</span></span><br><span class="line"><span class="params">                                    <span class="type">boolean</span> addTaskWakesUp, <span class="type">int</span> maxPendingTasks,</span></span><br><span class="line"><span class="params">                                    RejectedExecutionHandler rejectedHandler)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">    <span class="built_in">this</span>.addTaskWakesUp = addTaskWakesUp;</span><br><span class="line">    <span class="built_in">this</span>.maxPendingTasks = Math.max(<span class="number">16</span>, maxPendingTasks);</span><br><span class="line">    <span class="built_in">this</span>.executor = ObjectUtil.checkNotNull(executor, <span class="string">&quot;executor&quot;</span>);</span><br><span class="line">    <span class="comment">// taskQueue，这个东西很重要，提交给 NioEventLoop 的任务都会进入到这个 taskQueue 中等待被执行</span></span><br><span class="line">    <span class="comment">// 这个 queue 的默认容量是 16</span></span><br><span class="line">    taskQueue = newTaskQueue(<span class="built_in">this</span>.maxPendingTasks);</span><br><span class="line">    rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, <span class="string">&quot;rejectedHandler&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里就更加诡异了，NioEventLoop 的父类是 SingleThreadEventLoop，而 SingleThreadEventLoop 的父类是 <strong>SingleThreadEventExecutor</strong>，它的名字告诉我们，它是一个 Executor，是一个线程池，而且是 Single Thread 单线程的。</p>
<p>也就是说，线程池 NioEventLoopGroup 中的每一个线程 NioEventLoop 也可以当做一个线程池来用，只不过它只有一个线程。这种设计虽然看上去很巧妙，不过有点反人类的样子。</p>
<p>上面这个构造函数比较简单：</p>
<ul>
<li><p>设置了 parent，也就是之前创建的线程池 NioEventLoopGroup 实例</p>
</li>
<li><p>executor：它是我们之前实例化的 ThreadPerTaskExecutor，我们说过，这个东西在线程池中没有用，它是给 NioEventLoop 用的，马上我们就要看到它了。提前透露一下，它用来开启 NioEventLoop 中的线程（Thread 实例）。</p>
</li>
<li><p>taskQueue：这算是该构造方法中新的东西，它是任务队列。我们前面说过，NioEventLoop 需要负责 IO 事件和非 IO 事件，通常它都在执行 selector 的 select 方法或者正在处理 selectedKeys，如果我们要 submit 一个任务给它，任务就会被放到 taskQueue 中，等它来轮询。该队列是线程安全的 LinkedBlockingQueue，默认容量为 16。</p>
</li>
<li><p>rejectedExecutionHandler：taskQueue 的默认容量是 16，所以，如果 submit 的任务堆积了到了 16，再往里面提交任务会触发 rejectedExecutionHandler 的执行策略。</p>
<blockquote>
<p>还记得默认策略吗：抛出RejectedExecutionException 异常。</p>
<p>在 NioEventLoopGroup 的默认构造中，它的实现是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">REJECT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionHandler</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejected</span><span class="params">(Runnable task, SingleThreadEventExecutor executor)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p>然后，我们再回到 NioEventLoop 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;</span><br><span class="line">    <span class="comment">// 我们刚刚说完了这个</span></span><br><span class="line">    <span class="built_in">super</span>(parent, executor, <span class="literal">false</span>, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);</span><br><span class="line">    <span class="keyword">if</span> (selectorProvider == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;selectorProvider&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strategy == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;selectStrategy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    provider = selectorProvider;</span><br><span class="line">    <span class="comment">// 创建 selector 实例</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SelectorTuple</span> <span class="variable">selectorTuple</span> <span class="operator">=</span> openSelector();</span><br><span class="line">    selector = selectorTuple.selector;</span><br><span class="line">    unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">    </span><br><span class="line">    selectStrategy = strategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最重要的方法其实就是 openSelector() 方法，它将创建 NIO 中最重要的一个组件 <strong>Selector</strong>。在这个方法中，Netty 也做了一些优化，这部分我们就不去分析它了。</p>
<p>到这里，我们的线程池 NioEventLoopGroup 创建完成了，并且实例化了池中的所有 NioEventLoop 实例。</p>
<p>同时，大家应该已经看到，上面并没有真正创建 NioEventLoop 中的线程（没有创建 Thread 实例）。</p>
<p>提前透露一下，创建线程的时机在第一个任务提交过来的时候，那么第一个任务是什么呢？是我们马上要说的 channel 的 <strong>register</strong> 操作。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default/">1</a><span class="space">&hellip;</span><a class="page-number" href="/default/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/default/page/8/">8</a><a class="page-number" href="/default/page/9/">9</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">碎梦</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/scatteredream" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
