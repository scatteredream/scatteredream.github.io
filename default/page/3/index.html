<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Arvo:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scatteredream.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="scatteredream&#39;s blog">
<meta property="og:url" content="http://scatteredream.github.io/default/page/3/index.html">
<meta property="og:site_name" content="scatteredream&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="碎梦">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://scatteredream.github.io/default/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default/page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>scatteredream's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">scatteredream's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="碎梦"
      src="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
  <p class="site-author-name" itemprop="name">碎梦</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">126</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/01/20/408-OS-%E8%99%9A%E6%8B%9F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/20/408-OS-%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="post-title-link" itemprop="url">虚拟机</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-20 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-20T00:00:00+08:00">2025-01-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:51:29" itemprop="dateModified" datetime="2025-05-05T11:51:29+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Hypervisor-VMM"><a href="#Hypervisor-VMM" class="headerlink" title="Hypervisor (VMM)"></a>Hypervisor (VMM)</h1><p>Hypervisor 是一种运行在基础硬件和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件。也可叫做虚拟机监视器，即 VMM（ virtual machine monitor ）。（操作系统的操作系统）</p>
<p>动机：</p>
<ol>
<li>提高硬件的利用率，一套硬件跑多个操作系统</li>
<li>方便多平台软件的开发与调试</li>
</ol>
<ul>
<li>当服务器启动并执行 Hypervisor 时，它会加载所有虚拟机客户端的操作系统同时会分配给每一台虚拟机适量的内存，CPU，网络和磁盘。它允许多个操作系统（称为<strong>Guest OS</strong>）在同一台物理机器（称为<strong>Host</strong>）上同时运行，每个操作系统被隔离在独立的虚拟机中。</li>
<li>Hypervisor 负责资源分配，如 CPU、内存和存储，协调着这些硬件资源的访问，而且在各个虚拟机之间施加防护，处理虚拟机之间的通信和安全隔离。</li>
</ul>
<h2 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/VMwarevsKVM1.png" alt="KVM vs VMware – Uma comparação de Hypervisors - Wintech"></p>
<ul>
<li><p><strong>Type 1 (裸机型):</strong> 直接运行在物理硬件上，例如 VMware ESXi、Microsoft Hyper-V、KVM。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/virtual-machine-diagram.svg" alt="体系结构图，显示 VM 如何运行完整的操作系统（独立于主机操作系统）"></p>
<p>KVM (Kernel-Based Virtual Machine) 是 x86 硬件上 Linux 的完整虚拟化解决方案。它由提供核心虚拟化基础设施的可加载内核模块 kvm.ko 和处理器特定模块 kvm-intel.ko 或 kvm-amd.ko 组成。采用硬件辅助虚拟化技术 Intel-VT、AMD-V，内存的相关如 Intel 的 EPT 和 AMD 的 RVI 技术</p>
</li>
<li><p><strong>Type 2 (托管型):</strong> 运行在操作系统之上，例如 VMware Workstation、Oracle VirtualBox。</p>
</li>
<li><p><strong>QEMU</strong>: </p>
<ul>
<li><p>最初 <strong>QEMU</strong>(Quick Emulator)是一个系统模拟器，它可以在一种体系结构的系统上模拟另一种体系结构的系统。不但模拟 CPU，还模拟各种外设。其中 CPU 的模拟主要是通过指令翻译的方式，所以速度比较慢：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/e45iakbuhu.jpeg" alt="img"></p>
</li>
<li><p>KVM 只靠上面的两个内核模块不能创建完整的虚拟机，KVM 是一种中间件，属于 Linux 的内核模块，将 Linux 变成一个 Hypervisor，可以虚拟化 CPU 和内存，在系统需要虚拟化功能的时候，内核把 KVM 模块调入内存中运行。但用户无法直接控制内核，所以需要一个处于内核和用户之间的一个桥梁 QEMU。KVM 团队 fork 了 QEMU 作为用户态的部分，一起实现了虚拟机(QEMU 模拟系统的其他组件如磁盘等；KVM 模拟 CPU 和内存)。</p>
</li>
<li><p>从 KVM 的角度看，它的用户态部分在 QEMU 里，一起虚拟出完整 Guest OS；</p>
</li>
<li><p>从 QEMU 的角度看，它有一个 Virtualization 模式，就是使用 KVM 来模拟 CPU 内存网络，实现加速。QEMU 通过 KVM 的用户态部分访问 KVM 的内核态部分。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/kvm-qemu-1735307591402-91.png" alt="figure1"></p>
</li>
</ul>
</li>
</ul>
<p>某些文献中，VMM 特指 Type 2 Hypervisor 中用于模拟 CPU 指令集和设备驱动的核心软件组件，特别是在微内核环境中，对 Hypervisor 和 VMM 进行了区分。在那里，两个组件形成了某个系统的整体虚拟化堆栈。 Hypervisor 指的是内核空间功能，VMM 指的是用户空间功能。具体来说，在这些上下文中，Hypervisor 是实现虚拟化基础设施的微内核，由于技术原因必须在内核空间中运行，例如 Intel VMX。实现虚拟化机制的微内核也称为微管理程序。将此术语应用到 Linux 中，KVM 是一个 Hypervisor，而 QEMU 是利用 KVM 作为 Hypervisor 的 VMM。</p>
<h2 id="CPU-Virtualization"><a href="#CPU-Virtualization" class="headerlink" title="CPU Virtualization"></a>CPU Virtualization</h2><h2 id="Memory-Virtualization"><a href="#Memory-Virtualization" class="headerlink" title="Memory Virtualization"></a>Memory Virtualization</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/01/18/408-OS-%E8%99%9A%E6%8B%9F%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/18/408-OS-%E8%99%9A%E6%8B%9F%E5%8C%96/" class="post-title-link" itemprop="url">虚拟化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-18 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-18T00:00:00+08:00">2025-01-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:42:43" itemprop="dateModified" datetime="2025-05-05T11:42:43+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="CPU-Virtualization"><a href="#CPU-Virtualization" class="headerlink" title="CPU Virtualization"></a>CPU Virtualization</h1><h2 id="进程（process）"><a href="#进程（process）" class="headerlink" title="进程（process）"></a>进程（process）</h2><p><strong>操作系统</strong>：早期是一些函数库，然后发展出了保护的作用（内核态与用户态），之后是多道程序（多进程、多线程）</p>
<p><strong>软件设计思维</strong>：分离机制与策略</p>
<ul>
<li>机制：如何进行上下文切换？</li>
<li>策略：什么情况下，应该切换到谁？</li>
</ul>
<p><strong>进程</strong>：程序没有运行的时候，就是硬盘中静态的代码，程序开始运行了，就在内存中开辟属于自己的空间，进程可以看作是操作系统对程序运行的一种抽象。</p>
<h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><ul>
<li>内存地址空间，特定CPU寄存器的值</li>
<li><strong>内存分配</strong>：程序代码、静态数据、运行时数据（包括堆栈和IO设置）</li>
<li><strong>栈空间</strong>（Stack）：可以由<code>main</code>传参进行初始化，主要存放局部变量、函数参数和返回地址</li>
<li><strong>用于IO的文件描述符</strong>（Descriptor）：默认开启<code>stdin</code> <code>stdout</code> <code>stderr</code>三个文件</li>
<li><strong>堆空间</strong>（Heap）：用于在程序运行时动态地向OS申请一片内存(<code>malloc</code>)</li>
<li>在进程创建之后，OS将CPU控制权给到程序，开始执行<code>main</code></li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241207204834626.png" alt="image-20241207204834626"></p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>加载到内存的进程基本状态如下三种</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241207204852570.png" alt="image-20241207204852570"></p>
<ul>
<li><strong>运行中</strong>：运行中的进程，也可以被反向调度</li>
<li><strong>待运行</strong>（就绪）：就绪的程序随时可以运行，等待调度</li>
<li><strong>阻塞</strong>：程序运行到不需要CPU的部分（比如IO）就会到阻塞状态，等IO任务完成会变成就绪</li>
<li>OS选择在进程发起IO时切换到别的进程，这样可以保持CPU繁忙，<strong>在IO结束时没有选择切换回去，这就是策略</strong></li>
</ul>
<h3 id="进程的数据结构"><a href="#进程的数据结构" class="headerlink" title="进程的数据结构"></a>进程的数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the registers xv6 will save and restore</span></span><br><span class="line"><span class="comment">// to stop and subsequently restart a process</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> eip;<span class="comment">//instruction ptr </span></span><br><span class="line">    <span class="type">int</span> esp;<span class="comment">//stack ptr</span></span><br><span class="line">    <span class="type">int</span> ebx;</span><br><span class="line">    <span class="type">int</span> ecx;</span><br><span class="line">    <span class="type">int</span> edx;</span><br><span class="line">    <span class="type">int</span> esi;</span><br><span class="line">    <span class="type">int</span> edi;</span><br><span class="line">    <span class="type">int</span> ebp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the different states a process can be in</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> &#123;</span> UNUSED, EMBRYO, SLEEPING,</span><br><span class="line">RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the information xv6 tracks about each process</span></span><br><span class="line"><span class="comment">// including its register context and state</span></span><br><span class="line"><span class="comment">// PCB</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *mem; <span class="comment">// Start of process memory</span></span><br><span class="line">    uint sz; <span class="comment">// Size of process memory</span></span><br><span class="line">    <span class="type">char</span> *kstack; <span class="comment">// Bottom of kernel stack for this process</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span> <span class="comment">// Process state</span></span><br><span class="line">    <span class="type">int</span> pid; <span class="comment">// Process ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span> <span class="comment">// Parent process</span></span><br><span class="line">    <span class="type">void</span> *chan; <span class="comment">// If !zero, sleeping on chan</span></span><br><span class="line">    <span class="type">int</span> killed; <span class="comment">// If !zero, has been killed</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span> <span class="comment">// Open files</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span> <span class="comment">// Current directory</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span> <span class="comment">// Switch here to run process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span> <span class="comment">// Trap frame for the current interrupt</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p> A process list contains information about all processes in the system. Each entry is found in what is sometimes called a process control block (<strong>PCB</strong>), which is really just a structure that contains information about a specific process. </p>
</blockquote>
<ul>
<li><strong>上下文</strong>：指令指针、栈指针等都是CPU物理寄存器的内容，指令得以继续执行的关键，在恢复进程时很重要。</li>
<li><strong>进程状态</strong></li>
<li><strong>其他的静态信息</strong>：进程地址空间，父进程、中断信息、打开的文件等。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/202209241609976.png" alt="vfs"></p>
<h3 id="进程API"><a href="#进程API" class="headerlink" title="进程API"></a>进程API</h3><h4 id="fork-wait-exec"><a href="#fork-wait-exec" class="headerlink" title="fork wait exec"></a>fork wait exec</h4><ul>
<li><strong>fork</strong>：复制一个和父进程一样的子进程（子进程直接从fork返回然后继续执行）子进程的内存空间和父进程是独立的，并且变量的值大部分一样，</li>
<li><strong>wait</strong>：子进程创建后，根据OS调度（schedule）决定先后顺序，wait可以使父进程等子进程执行完再开始运行</li>
<li><strong>exec</strong>：当前进程不想运行和之前一样的代码，可以调用exec加参数运行其他代码，新的程序会替代原来进程的所有信息，因此exec后边的代码是不会被执行的。</li>
</ul>
<h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><ul>
<li>shell的基本原理就是主进程fork wait 子进程这边exec 运行其他程序，运行完成主进程wait结束，继续进行其他操作</li>
<li><strong>输出重定向</strong>（redirecting）：默认输出就是标准输出流，如果你想重定向到一个文件，应当关闭stdout然后重新打开一个你想要的文件描述符。</li>
<li><strong>管道</strong>（pipe）：也类似与输出重定向，上一个的输出无缝作为下一个的输入</li>
<li><strong>有用的cli工具</strong>：top(table of processes), ps(process status), man(manual)…</li>
</ul>
<h4 id="signals-and-users"><a href="#signals-and-users" class="headerlink" title="signals and users"></a>signals and users</h4><blockquote>
<p>For example, control-c sends a SIGINT (interrupt) to the process (normally terminating it) and control-z sends a SIGTSTP (stop) signal thus pausing the process in mid-execution (you can resume it later with a command, e.g., the fg built-in command found in many shells).</p>
<p>receive and process those signals within individual processes, and  send signals to individual processes as well as entire process groups.</p>
</blockquote>
<p><code>signal()</code>可以使进程能够监听到上述这些信号，暂停现有程序执行，然后对信号做出一定的响应</p>
<blockquote>
<p>Users generally can only control their own processes; it is the job of the operating system to parcel out resources (such as CPU, memory, and disk) to each user (and their processes) to meet overall system goals.</p>
</blockquote>
<p>用户等级决定他们是否有权利发出某些特定的信号</p>
<hr>
<h2 id="机制：受限-直接执行"><a href="#机制：受限-直接执行" class="headerlink" title="机制：受限 直接执行"></a>机制：受限 直接执行</h2><h3 id="Limited-Direct-Execution"><a href="#Limited-Direct-Execution" class="headerlink" title="Limited Direct Execution"></a>Limited Direct Execution</h3><p><strong>直接执行</strong>：直接在CPU上运行程序。</p>
<p><strong>受限</strong>：一个进程要调用I/O，但是还不能让进程完全控制系统。</p>
<p><strong>用户模式</strong>（user mode）：应用程序不能完全控制硬件资源，如果硬要发起IO请求，CPU会出现异常，OS将终止进程</p>
<p><strong>内核模式</strong>（kernel mode）：操作系统可以完全掌控硬件。</p>
<blockquote>
<p>When changing protection levels from user to kernel mode, the kernel shouldn’t use the stack of the user process, because it may not be valid. The user process may be <strong>malicious</strong> or <strong>contain an error that causes the user %esp to contain an address that is not part of the process’s user memory</strong>.</p>
</blockquote>
<h4 id="syscall-amp-trap"><a href="#syscall-amp-trap" class="headerlink" title="syscall &amp; trap"></a>syscall &amp; trap</h4><p><strong>系统调用</strong>（system call）：允许内核小心地向用户暴露某些关键功能。执行<strong>trap</strong>指令，进入操作系统内核，将特权级别提升至内核模式，完成之后return from trap，返回值并将特权级别降低至用户模式。</p>
<blockquote>
<p>Typical user applications run in user mode, and use a system call to trap into the kernel to request operating system services.</p>
</blockquote>
<p>系统调用的参数放到一个指定的寄存器处，系统调用号也放到指定寄存器，需要仔细遵循约定来正确处理参数与返回值，高级语言通常屏蔽了底层硬件细节，因此需要使用汇编语言：</p>
<ul>
<li><strong>系统调用</strong>：用户程序通过陷阱指令请求内核服务（如文件操作、进程管理）。例如，在x86中：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 1   ; 系统调用号 (exit)</span><br><span class="line">mov ebx, 0   ; 参数 (退出码)</span><br><span class="line">int 0x80     ; 触发陷阱</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>中断处理</strong>：硬件设备通过中断向量触发陷阱，操作系统用汇编语言编写中断向量表。</li>
<li><strong>异常处理</strong>：陷阱用于处理非法操作（如除零或非法内存访问）。</li>
</ul>
<p><strong>陷阱表</strong>（trap table）：用户态不能执行io等直接操控底层硬件，否则就是非法的。进入内核态以后也不能随便寻址执行程序，必须跳到指定地址去执行对应的程序，这个指定的程序地址是<strong>内核</strong>（kernel）在启动时通过<strong>陷阱表</strong>告诉硬件的。用户程序也不能够识别陷阱表的内容。</p>
<blockquote>
<p>The trap instruction saves register state carefully, changes the hardware status to kernel mode, and jumps into the OS to a pre-specified destination: the trap table.</p>
<p>When the OS finishes servicing a system call, it returns to the user program via another special return-from-trap instruction, which reduces privilege and returns control to the instruction after the trap that jumped into the OS</p>
</blockquote>
<p>Limited Direct Execution Timeline：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241207194358704.png" alt="image-20241207194358704"></p>
<ul>
<li><p>要么是内核态要么是用户态，在用户进程开始执行之前（main）的准备工作肯定是由内核态完成，因此就要return from trap，切换到用户态。跳转到main函数</p>
</li>
<li><p>执行系统调用或者响应中断时，通过trap指令，cpu控制权腾给os，陷入内核态，执行的是与之前不同的程序，就需要保存执行的现场以便之后继续执行，将cpu寄存器上的内容先保存到<strong>内核栈（kernel stack）</strong>。</p>
</li>
<li><p>在系统调用结束之后把内核栈的内容弹出恢复到CPU寄存器上，切换回用户模式，继续执行之前的内容，最后main函数返回，同时通过exit()进行trap，进入内核态，做清理工作。</p>
</li>
</ul>
<h3 id="Limited-Direct-Execution-Timer-Interrupt"><a href="#Limited-Direct-Execution-Timer-Interrupt" class="headerlink" title="Limited Direct Execution(Timer Interrupt)"></a>Limited Direct Execution(Timer Interrupt)</h3><p><strong>直接执行（Direct Execution）</strong>：用户进程占用CPU，OS作为一个程序并没有在运行。问题在于OS如何重新获得CPU的控制权，以便在操控程序运行取得主动权。</p>
<p><strong>协作</strong>：OS只能等待被动的系统调用或者触发异常才会重新获得CPU控制权。</p>
<p><strong>非协作</strong>：时钟硬件设备可以编程为若干毫秒产生一次中断信号，CPU 检测到时钟中断信号后，暂停当前正在运行的任务，跳转到内核中预定义的<strong>中断服务例程（ISR, Interrupt Service Routine）</strong>处理</p>
<p>CPU必须在硬件层面实现能够保存用户程序运行的现场（trap的精髓）</p>
<ul>
<li><p><strong>操作系统处理时钟中断</strong>操作系统在时钟中断处理程序中执行以下任务：</p>
<ul>
<li><p>更新系统时间。</p>
</li>
<li><p>检查是否需要切换任务（触发<strong>任务调度</strong>）。</p>
</li>
<li><p>处理延迟或周期性任务（如超时处理、定时器事件等）。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241207200809875.png" alt="image-20241207200809875"></p>
<p>如图 hardware部分 需要在响应时钟中断时，把进程A的运行现场（寄存器）保存到内核栈中，然后跳转到trap处理程序。</p>
<h4 id="上下文切换（context-switch）"><a href="#上下文切换（context-switch）" class="headerlink" title="上下文切换（context switch）"></a>上下文切换（context switch）</h4><p>然后操作系统调用switch进行进程的切换A到B，因为一段时间内A都不会再运行，这时候就需要把A的寄存器内容保存到其进程空间（内存空间）</p>
<h5 id="kernel-stack-vs-Process-Control-Block"><a href="#kernel-stack-vs-Process-Control-Block" class="headerlink" title="kernel stack  vs Process Control Block"></a><code>kernel stack</code>  vs <code>Process Control Block</code></h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/likui360/p/6224624.html">Linux 系统中堆栈的使用方法 - 扫地猿 - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/188577062">浅谈Linux 中的进程栈、线程栈、内核栈、中断栈 - 知乎</a></p>
<p>当进程在用户态运行时，使用的是用户栈，当进程陷入到内核态时，这些内核代码所使用的栈并不是原先进程用户空间中的栈，而是一个单独内核空间的栈，这个称作进程内核栈，内核栈保存进程在内核态运行的相关信息，一旦进程返回到用户态后，内核栈中保存的信息无效，会全部恢复，因此每次进程从用户态陷入内核的时候得到的内核栈都是空的。所以在进程陷入内核的时候，直接把内核栈的栈顶地址给堆栈指针寄存器就可以了。</p>
<p>当位于用户空间的进程进行系统调用时，进程用户栈的地址会被存进内核栈中，CPU堆栈指针寄存器中的内容也会变为内核栈的地址。当系统调用执行完毕，进程从内核栈找到用户栈的地址，继续在用户空间中执行，此时CPU堆栈指针寄存器就变为了用户栈的地址。各进程独立的。进程运行时分用户态跟内核态，所以需要有内核栈和常说的堆栈段，寻址方式是相同的，都是查LDT和页表进行地址映射，但二者段描述符里的特权级不同，为了区分用户态和内核态。</p>
<p>为什么每个进程都有一个内核栈，而不是所有进程共用一个。老的UNIX和Linux当时就是每个CPU只有一个内核栈，那个时候不会出现“执行到一半的时候上下文切换”，因为不允许用户态程序抢占正在执行系统调用的另一个用户态程序。后来每个进程一个内核栈了，就可以发生“执行到一半的时候上下文切换”了</p>
<p>语言书里面讲的堆、栈大部分都是用户态的概念，用户态的堆、栈对应用户进程虚拟地址空间里的一个区域，栈向下增长，堆用malloc分配，向上增长。</p>
<ul>
<li>中断发生时，寄存器先保存到内核栈；如果需要切换进程，内核会将内核栈中的寄存器内容转存到进程结构中。</li>
<li><strong>内核栈</strong>主要用于快速保存和恢复寄存器内容，适用于临时的上下文切换或中断处理。</li>
<li><strong>进程结构</strong>适用于更复杂的进程调度和长时间的上下文切换，提供长期的状态保存。proc结构体中的context字段就是用来保存寄存器信息的（xv6）</li>
</ul>
<table>
<thead>
<tr>
<th><strong>方面</strong></th>
<th><strong>内核栈</strong></th>
<th><strong>进程结构（PCB）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>保存时机</strong></td>
<td>短暂事件（如中断、系统调用）</td>
<td>进程调度时</td>
</tr>
<tr>
<td><strong>存储位置</strong></td>
<td>当前进程的内核栈</td>
<td>PCB 或其他持久性数据结构</td>
</tr>
<tr>
<td><strong>存储时间</strong></td>
<td><strong>临时保存</strong>，内核处理结束后直接恢复</td>
<td><strong>长期保存</strong>，直至进程切换回来</td>
</tr>
<tr>
<td><strong>访问开销</strong></td>
<td>较低，直接访问内核栈</td>
<td>较高，涉及更多内存操作</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>快速上下文切换、临时中断处理</td>
<td>进程调度或长时间上下文切换</td>
</tr>
<tr>
<td><strong>局限性</strong></td>
<td>不能长期存储</td>
<td>开销大，需要额外的数据结构</td>
</tr>
<tr>
<td>优点</td>
<td>连续内存块，访问效率较高，内核处理完直接恢复</td>
<td>寄存器信息可以跨多个调度周期存储</td>
</tr>
</tbody></table>
<p>进程调度，需要把B的现场信息从进程空间中恢复到寄存器里，然后恢复到用户态，跳转到B的PC，执行B的内容。</p>
<p><strong>并发</strong>：系统调用时触发中断。</p>
<hr>
<h2 id="策略：CPU-调度"><a href="#策略：CPU-调度" class="headerlink" title="策略：CPU 调度"></a>策略：CPU 调度</h2><h3 id="基本策略"><a href="#基本策略" class="headerlink" title="基本策略"></a>基本策略</h3><h4 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h4><p><strong>FIFO</strong>：先到先得，计算密集型会阻塞io密集型，降低效率</p>
<p><strong>SJF</strong>：Shortest Job First 最短工作优先，<u>同时到达</u>，先进行最短的工作</p>
<p><strong>STCF</strong>：Shortest Time-to-Complete First 最短完成时间优先，针对<u>随时到达</u>的情况，到达时比较里完成还有多少时间，首次出现了任务切换的概念。</p>
<h4 id="交互式"><a href="#交互式" class="headerlink" title="交互式"></a>交互式</h4><p>以上能够逐步优化 T<del>周转</del> = T<del>完成</del> - T<del>到达</del>，但是对于T<del>响应</del> = T<del>首次运行</del> - T<del>到达</del> 不友好，因为完成时间最长的必须等其他任务完成，自己才能继续。</p>
<p>交互式的任务对于响应时间很敏感。因此需要另外一种调度策略</p>
<p><strong>RR</strong>：Round-Robin 轮转，运行一个任务到时间片就切换到下一个任务（context switch）</p>
<ul>
<li>上下文的切换需要时间，因此时间片的大小也应该选择恰当</li>
</ul>
<p><strong>Overlap</strong>：重叠，如果A任务有IO，当A因为IO而空出CPU时，CPU就应该去服务B</p>
<p><strong>不可预知性</strong>：调度程序不知道到来的任务持续多长时间。</p>
<h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h4><p>准时比准确更加重要</p>
<h3 id="基于优先级且无需先验知识的调度：多级反馈队列-MLFQ"><a href="#基于优先级且无需先验知识的调度：多级反馈队列-MLFQ" class="headerlink" title="基于优先级且无需先验知识的调度：多级反馈队列 MLFQ"></a>基于优先级且无需先验知识的调度：多级反馈队列 MLFQ</h3><p>MLFQ：Multi-Level Feedback Queue，多级反馈队列</p>
<ul>
<li>设置不同的优先级，每个任务刚到达都是最高级</li>
<li>级别低的任务必须先让级别高的执行完</li>
<li>相同级别的任务轮转执行</li>
<li>在同一个优先级执行时间达到阈值就降低优先级：防止高优先级一直占据CPU，如果采用每次执行的计时方法可能会有恶意占据CPU的情况发生</li>
<li>每隔一段时间就重置所有任务的优先级为最高：防止低优先级变成饥饿状态</li>
</ul>
<h1 id="Memory-Virtualization"><a href="#Memory-Virtualization" class="headerlink" title="Memory Virtualization"></a>Memory Virtualization</h1><h2 id="每个程序员都应该知道的时延"><a href="#每个程序员都应该知道的时延" class="headerlink" title="每个程序员都应该知道的时延"></a>每个程序员都应该知道的时延</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/687474703a2f2f692e696d6775722e636f6d2f6b307431652e706e67" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">L1 cache reference ......................... 0.5 ns</span><br><span class="line">Branch mispredict ............................ 5 ns</span><br><span class="line">L2 cache reference ........................... 7 ns</span><br><span class="line">Mutex lock/unlock ........................... 25 ns</span><br><span class="line">Main memory reference ...................... 100 ns             </span><br><span class="line">Compress 1 KB with Zippy ................. 3,000 ns  =       3 µs</span><br><span class="line">Send 2 KB over 1 Gbps network ........... 20,000 ns  =      20 µs</span><br><span class="line">SSD random read ........................ 150,000 ns  =     150 µs</span><br><span class="line">Read 1 MB sequentially from memory ..... 250,000 ns  =     250 µs</span><br><span class="line">Round trip within same datacenter ...... 500,000 ns  =     500 µs  =  0.5 ms</span><br><span class="line">Read 1 MB sequentially from SSD ...... 1,000,000 ns  =   1,000 µs  =    1 ms</span><br><span class="line">Disk seek ........................... 10,000,000 ns  =  10,000 µs  =   10 ms</span><br><span class="line">Read 1 MB sequentially from disk .... 20,000,000 ns  =  20,000 µs  =   20 ms</span><br><span class="line">Send packet CA-&gt;Netherlands-&gt;CA .... 150,000,000 ns  = 150,000 µs  =  150 ms</span><br></pre></td></tr></table></figure>

<h2 id="地址空间、分段（segmentation）"><a href="#地址空间、分段（segmentation）" class="headerlink" title="地址空间、分段（segmentation）"></a>地址空间、分段（segmentation）</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/7/70/VirtualMem01.png" alt="img"></p>
<p><strong>地址空间</strong>：程序认为自己独占了这片内存空间，以为自己是连续的内存空间。低位是代码，堆往上递增，栈往下反向增长。</p>
<p>实际上是在物理内存中申请了一片连续的内存空间分配给进程，进程根据指令寻址的时候，操作系统将虚拟地址 <strong>重定位</strong> 到真正的物理地址。虚拟地址从0开始，因此虚拟地址实际上就是物理地址的偏移量。直接打印指针变量的值是虚拟地址而不是物理地址。</p>
<h3 id="虚拟内存的作用"><a href="#虚拟内存的作用" class="headerlink" title="虚拟内存的作用"></a>虚拟内存的作用</h3><p><strong>隔离进程</strong>：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</p>
<p><strong>提升物理内存利用率</strong>：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。</p>
<p><strong>简化内存管理</strong>：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。</p>
<p><strong>多个进程共享物理内存</strong>：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。</p>
<p><strong>提高内存使用安全性</strong>：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。</p>
<p><strong>提供更大的可使用内存空间</strong>：可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。</p>
<hr>
<p>著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：<a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-02.html">https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-02.html</a></p>
<h3 id="重定位（relocation）"><a href="#重定位（relocation）" class="headerlink" title="重定位（relocation）"></a>重定位（relocation）</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241210205158811.png" alt="image-20241210205158811"></p>
<p><code>Virtual Address + Base = Physical Address</code> </p>
<p><strong>静态重定位</strong>：用软件实现，直接将指令中的虚拟地址用计算的真实物理地址覆盖。</p>
<ul>
<li>缺点：不安全，不方便更改。</li>
</ul>
<p><strong>动态重定位</strong>：用硬件实现，也就是CPU中的==MMU==，里面两个最基本的寄存器：<strong>基址寄存器</strong>、<strong>界限寄存器</strong>。将指令中的虚拟地址和基址相加得出真实物理地址，然后取得从硬件层面取得对应地址的值。这一切都是用硬件进行的。</p>
<ul>
<li>安全性：用界限（bound）和虚拟地址比较，如果超过了界限，说明虚拟地址访问越界，抛出异常</li>
<li>便于更改：改变寄存器的值即可实现基址的改变</li>
<li>性能高：硬件实现性能好</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241210205227715.png" alt="image-20241210205227715"></p>
<h3 id="实现虚拟内存"><a href="#实现虚拟内存" class="headerlink" title="实现虚拟内存"></a>实现虚拟内存</h3><p><strong>实现虚拟内存机制的硬件支持：MMU</strong></p>
<ul>
<li><p>划分用户空间和内核空间</p>
</li>
<li><p>一对基址寄存器和界限寄存器，专门用来进行地址转换的电路</p>
</li>
<li><p>专门用来判断是否越界的电路，判断越界之后应当向CPU抛出异常</p>
</li>
<li><p>特权指令：操作系统应当能够设置上述寄存器的值</p>
</li>
<li><p>特权指令：操作系统应当告诉硬件发现异常应该执行哪些代码（Exception Handler）</p>
</li>
</ul>
<p><strong>实现虚拟内存机制的软件支持：OS</strong></p>
<ul>
<li>内存管理：分配机制、释放机制、空闲空间的管理——free list</li>
<li>切换上下文时正确设置对应的寄存器</li>
<li>抛出异常（内存访问越界、非法指令）时执行特定的处理代码</li>
</ul>
<p><strong>地址空间的不足</strong>：内部碎片（inner fragment）栈和堆之间未使用的空间也分配给整个地址空间，浪费较大</p>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><h4 id="segmentation"><a href="#segmentation" class="headerlink" title="segmentation"></a>segmentation</h4><p><strong>段式管理</strong>：以段(—段连续的物理内存)的形式管理/分配物理内存。应用程序的虚拟地址空间被分为大小不等的段，段是有实际意义的，每个段定义了一组逻辑信息，例如有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。然后给每个段都配一对基址寄存器和界限寄存器。</p>
<p>例：0-16KB的虚拟地址空间，虚拟地址14位，高2位为段号，低12位为最大4KB的段空间。虚拟地址 = 段号 + 偏移 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get top 2 bits of 14-bit VA</span></span><br><span class="line">Segment = (VirtualAddress &amp; SEG_MASK) &gt;&gt; SEG_SHIFT</span><br><span class="line"><span class="comment">// now get offset</span></span><br><span class="line">Offset = VirtualAddress &amp; OFFSET_MASK</span><br><span class="line"><span class="keyword">if</span> (Offset &gt;= Bounds[Segment])</span><br><span class="line">	RaiseException(PROTECTION_FAULT)<span class="comment">//抛出异常</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	PhysAddr = Base[Segment] + Offset<span class="comment">//基址+偏移</span></span><br><span class="line">	Register = AccessMemory(PhysAddr)<span class="comment">//访存</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241210205528802.png" alt="image-20241210205528802"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241210205438635.png" alt="image-20241210205438635"></p>
<table>
<thead>
<tr>
<th>段名称</th>
<th>段号</th>
<th>基址寄存器</th>
<th>界限寄存器</th>
<th>是否正向增长</th>
</tr>
</thead>
<tbody><tr>
<td>代码</td>
<td>00</td>
<td>26 KB</td>
<td>2 KB</td>
<td>1</td>
</tr>
<tr>
<td>堆</td>
<td>01</td>
<td>28 KB</td>
<td>2 KB</td>
<td>1</td>
</tr>
<tr>
<td>栈</td>
<td>11</td>
<td>18 KB</td>
<td>2 KB</td>
<td>0</td>
</tr>
</tbody></table>
<p>现在要判断虚拟地址15KB的真实地址：<code>11 11 00000 00000</code> 可见段号为 11，偏移 3 KB，栈空间反向增长，最大段空间为 4 KB，实际上就是计算15KB离全1有多远：3KB - 4KB = -1 KB,因此在基址寄存器减1KB即为实际物理地址。</p>
<h5 id="用于保护的额外状态字"><a href="#用于保护的额外状态字" class="headerlink" title="用于保护的额外状态字"></a>用于保护的额外状态字</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241211001125226.png" alt="image-20241211001125226"></p>
<h5 id="分段的问题"><a href="#分段的问题" class="headerlink" title="分段的问题"></a>分段的问题</h5><ul>
<li><strong>外部碎片</strong>：每个分段的大小不一致，因此产生了大小不一致的碎片，无法使空间得到有效利用。</li>
<li><strong>不支持稀疏的大堆</strong>：Another problem is that some segments could have a larger size and since this segment can’t be “broken” into smaller pieces, it must be fully allocated in memory. 分段大小是固定的，并不能将其拆成小段，申请了一段物理内存，寄存器的基址和界限已经确定好，这部分物理空间就不能再由其他的进程使用了，因此不支持按需分配。</li>
<li>Segments of unequal size not suited as well for swapping.</li>
</ul>
<h5 id="段表：更细粒度的分段"><a href="#段表：更细粒度的分段" class="headerlink" title="段表：更细粒度的分段"></a>段表：更细粒度的分段</h5><p>细粒度分段需要进一步硬件支持，并且在内存中存储 段表 （segment table）</p>
<p>分段机制下的虚拟地址由两部分组成：</p>
<ul>
<li><strong>段号</strong>：标识着该虚拟地址属于整个虚拟地址空间中的哪一个段。</li>
<li><strong>段内偏移量</strong>：相对于该段起始地址的偏移量。</li>
</ul>
<p>具体的地址翻译过程如下：</p>
<ol>
<li>MMU 首先解析得到虚拟地址中的段号；</li>
<li>通过段号去该应用程序的段表中取出对应的段信息（找到对应的段表项）；</li>
<li>从段信息中取出该段的起始地址（物理地址）加上虚拟地址中的段内偏移量得到最终的物理地址。</li>
</ol>
<p><img src="https://miro.medium.com/v2/resize:fit:1313/1*82aSNHRAkNNinGuPpsl6TQ.png" alt="img">分段机制下的地址翻译过程</p>
<p>段表中还存有诸如段长(可用于检查虚拟地址是否超出合法范围)、段类型（该段的类型，例如代码段、数据段等）等信息。</p>
<p><strong>通过段号一定要找到对应的段表项吗？得到最终的物理地址后对应的物理内存一定存在吗？</strong></p>
<p>不一定。段表项可能并不存在：</p>
<ul>
<li><strong>段表项被删除</strong>：软件错误、软件恶意行为等情况可能会导致段表项被删除。</li>
<li><strong>段表项还未创建</strong>：如果系统内存不足或者无法分配到连续的物理内存块就会导致段表项无法被创建。</li>
</ul>
<h4 id="减少碎片"><a href="#减少碎片" class="headerlink" title="减少碎片"></a>减少碎片</h4><ul>
<li><p><strong>内存紧缩</strong>（compact）：内存存储不下程序，会把暂时休息的第一个进程方法放入磁盘，过段时间移除进程b放入进程a，这样会让内存中出现空洞，所以要将进程整体往下移动。必须将运行中的进程中断，将所有分散的内存碎片压到连续的部分中，然后再将新的基址和界限移动到寄存器中，进程按照新的上下文继续执行。缺点是代价太高，性能不好</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240922142056246.png" alt="image-20240922142056246"></p>
</li>
<li><p><strong>改善空闲列表</strong>（free list）：分配内存的时候采取一定的策略，尽量减轻内存碎片的现象，但也无法根除碎片的出现</p>
</li>
</ul>
<h2 id="空闲空间的管理"><a href="#空闲空间的管理" class="headerlink" title="空闲空间的管理"></a>空闲空间的管理</h2><p>维护一个空闲空间的列表（freelist）</p>
<h3 id="机制：分割与合并"><a href="#机制：分割与合并" class="headerlink" title="机制：分割与合并"></a>机制：分割与合并</h3><p>splitting</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241210222509968.png" alt="image-20241210222509968"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241210222527700.png" alt="image-20241210222527700"></p>
<p>coalescing</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241210222438918.png" alt="image-20241210222438918"></p>
<h3 id="内存-API"><a href="#内存-API" class="headerlink" title="内存 API"></a>内存 API</h3><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p><code>void* malloc(int size)</code> 申请大小为size的连续字节空间（虚拟意义上的连续），返回一个指向这个空间首部的指针</p>
<p>除了用户申请的空间之外，在malloc时还会申请一个头部Header，size用来表示申请空间的大小，magic魔数用来验证完整性<a target="_blank" rel="noopener" href="https://www.cnblogs.com/whiteBear/p/16729327.html">延迟分配：提供内存利用率的三种机制 - 牛犁heart - 博客园</a></p>
<ul>
<li>malloc只是分配了虚拟内存，程序真正访问才会触发页错误给这些虚拟页分配物理页框（demand paging）</li>
<li>在标准 C 库中，提供了 malloc / free 函数分配释放内存，这两个函数底层是由 brk，mmap，munmap 这些系统调用实现的。 (<em>详见Linux虚拟内存系统</em>) 不过跟直接调用还是有区别的。</li>
</ul>
<h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p><code>void free(void* ptr)</code> 将指针ptr所指向的已分配空间释放掉，依据的信息是<strong>分配内存的Header部分</strong> ，因此malloc的size并不是真正的大小，还要分配头部<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241210221647796.png" alt="image-20241210221647796"></p>
<h3 id="嵌入-free-list-到内存中"><a href="#嵌入-free-list-到内存中" class="headerlink" title="嵌入 free list 到内存中"></a>嵌入 free list 到内存中</h3><p>free list 本身也需要存储在内存中，这里我们知道：空闲的块作为空闲节点有额外的简单数据结构（int size, node* next），已分配的块同样也有简单的数据结构（int size, int magic），因此堆实际上是一个空闲内存和已分配的内存的混合。</p>
<ul>
<li>未分配空间</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241210222820688.png" alt="image-20241210222820688"></p>
<ul>
<li>连续分配了3个100字节的空间</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241210223130088.png" alt="image-20241210223130088"></p>
<ul>
<li>中间出现了空隙，可以看到空闲列表的头节点（head）发生了变化，两个空闲的块通过链表连接起来</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241210223253160.png" alt="image-20241210223253160"></p>
<ul>
<li>全部释放之后，出现了4个空闲的块，但是还没有合并（merge）</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241210223340586.png" alt="image-20241210223340586"></p>
<h3 id="策略：连续内存分配"><a href="#策略：连续内存分配" class="headerlink" title="策略：连续内存分配"></a>策略：连续内存分配</h3><h4 id="基本策略：空闲链表"><a href="#基本策略：空闲链表" class="headerlink" title="基本策略：空闲链表"></a>基本策略：空闲链表</h4><ul>
<li><strong>Best Fit</strong>：遍历整个列表，找到跟分配块大小最接近的空闲块，尽量减少碎片大小。细小碎片多，开销大。</li>
<li><strong>Worst Fit</strong>：遍历整个列表，找到跟分配块大小差距最大的，分割之后将剩余块加入空闲列表。碎片过量，开销大。</li>
<li><strong>First Fit</strong>：第一次找到足够大的块就直接分配。会让开头部分有许多小的碎片，可以通过按地址排序，便于合并操作。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240922142709440.png" alt="image-20240922142709440"></p>
<ul>
<li><strong>Next Fit</strong>：每次查找都从上次结束的地方开始，剩下逻辑依然是首次匹配，可以减少开头部分过多的小碎片，将其分散到其他地方。</li>
</ul>
<p><strong>位图</strong>：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/v2-ccf3e0ea94a135e7f8548f3e9ef42813_1440w.jpg" alt="img"></p>
<h4 id="内存池（memory-pool）"><a href="#内存池（memory-pool）" class="headerlink" title="内存池（memory pool）"></a>内存池（memory pool）</h4><p>如果能将一大块内存分成多个小内存（称为内存池），不同的内存池又按照不同的「尺寸」分成大小相同的内存块（比如分别按照32, 64, 128……字节），同一内存池中的空闲内存块按照free list的方式连接。每次分配的时候，选择和申请的的内存在「尺寸」上最接近的内存池，比如申请60字节的内存，就直接从单个内存块大小为64字节的内存池的free list上分配。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/v2-12148c36cd07924a26e0ce35b67f29eb_1440w.jpg" alt="img" style="zoom:150%;" />

<p>需要结合系统实际的内存分配需求，对内存池的大小进行合理的划分。比如一个系统常用的是256字节以下的内存申请，那设置过多的256字节以上的内存池，就会造成内存资源的闲置和浪费。</p>
<h4 id="其他策略"><a href="#其他策略" class="headerlink" title="其他策略"></a>其他策略</h4><p>Linux 发展出两种基于内存池的分配策略，<em>详见 Linux 实现</em></p>
<ul>
<li><strong>Buddy system</strong>: 将内存池划分为以2^n^为大小的类型，同一内存池中的空闲块大小相同，如果空闲块是相邻的则合并，将合并后的块加入更大的内存池中</li>
<li><strong>SLAB</strong>: 伙伴系统是按页分配的，但内核经常会申请一些特定大小的内存，往往不到一页，如果仍然使用伙伴系统将造成很多内部碎片，SLAB为它们分配了内核对象缓存，专门的连续内存区，依然使用内存池的思路，但是池子变得比以前更小。</li>
</ul>
<h2 id="分页（paging）"><a href="#分页（paging）" class="headerlink" title="分页（paging）"></a>分页（paging）</h2><h3 id="虚拟——物理页号转换"><a href="#虚拟——物理页号转换" class="headerlink" title="虚拟——物理页号转换"></a>虚拟——物理页号转换</h3><h4 id="页帧、页帧号、虚拟页号"><a href="#页帧、页帧号、虚拟页号" class="headerlink" title="页帧、页帧号、虚拟页号"></a>页帧、页帧号、虚拟页号</h4><p><strong>分页机制</strong>：将虚拟的地址替换成物理地址，用大小相等的页代替大小不等的段。原来一个进程是代码段和数据段不等，分配的内存空间也不一样，现在将段继续拆分成大小相等的页表项，这样从根本上解决了外部碎片的问题。</p>
<p><strong>页帧（Page Frame）</strong>：物理内存中存放数据的最小单位。当一个虚拟页被映射到物理页时，数据会存放在对应的<strong>页帧</strong>中。假设一个进程的虚拟地址空间中有一个虚拟页，虚拟地址 <code>0x1000</code> 对应的虚拟页页号是 <code>0x1</code>，偏移量为0。此时，操作系统通过页表将虚拟页 <code>0x1</code> 映射到物理内存中的一个页帧 <code>0x3</code>，即物理地址为 <code>0x3000</code>。那么，当该进程访问虚拟地址 <code>0x1000</code> 时，CPU 会通过页表将其转换为物理地址 <code>0x3000</code>，并在页帧 <code>0x3</code> 中访问数据。页帧大小固定为PageSize</p>
<p><strong>虚拟地址（Virtual Address）= 虚拟页号（VPN, Virtual Page Number） + 偏移量（Offset）</strong></p>
<p><strong>页表项（Page Table Entry）= 物理页号（PFN, Page Frame Number）+ 保留的功能位</strong></p>
<p><strong>页表的物理地址</strong>：加载到<strong>页表基址寄存器（PTBR, Page Table Base Register）</strong>，一个<strong>页表项（PTE）</strong>分为<strong>物理页号（PFN）</strong>，有效位valid，读写权限位protection，内核模式位，脏位dirty，引用reference，存在位present等功能位。</p>
<h4 id="从虚拟地址访存基本步骤"><a href="#从虚拟地址访存基本步骤" class="headerlink" title="从虚拟地址访存基本步骤"></a>从虚拟地址访存基本步骤</h4><ul>
<li><p><code>VirtualAddress = VPN + Offset</code> </p>
</li>
<li><p><code>PTE Address(Physical) = VPN * PageSize + PTBR</code> PTE保存着PFN以及其他功能位</p>
</li>
<li><p><code>Physical Address = PFN * PageSize + Offset</code> </p>
</li>
<li><p>实际上VPN PFN Offset都是通过和MASK（作用和子网掩码相同）相与，然后PFN移位后和Offset相或。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Extract the VPN from the virtual address</span></span><br><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT</span><br><span class="line"><span class="comment">// Form the address of the page-table entry (PTE)</span></span><br><span class="line">PTEAddr = PTBR + (VPN * <span class="keyword">sizeof</span>(PTE))</span><br><span class="line"><span class="comment">// Fetch the PTE</span></span><br><span class="line">PTE = AccessMemory(PTEAddr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if process can access the page</span></span><br><span class="line"><span class="keyword">if</span> (PTE.Valid == False)<span class="comment">// Valid bit = 0</span></span><br><span class="line">	RaiseException(SEGMENTATION_FAULT) <span class="comment">//illegal memory access</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (CanAccess(PTE.ProtectBits) == False)</span><br><span class="line">	RaiseException(PROTECTION_FAULT)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// Access OK: form physical address and fetch it</span></span><br><span class="line">    offset = VirtualAddress &amp; OFFSET_MASK</span><br><span class="line">    PhysAddr = (PTE.PFN &lt;&lt; PFN_SHIFT) | offset</span><br><span class="line">    Register = AccessMemory(PhysAddr)</span><br></pre></td></tr></table></figure>

<p><strong>一些功能位</strong></p>
<ul>
<li>Protection bit：权限位，保护位 r w x，如果违反了越权访问，就要陷入OS</li>
<li>Valid bit：有效位，虚拟地址空间并不是全部都要分配，如果访问了还没有分配的（valid bit = 0）就是非法访问，将会抛出异常陷入OS</li>
<li>Dirty bit：脏位，页面带入内存之后是否被修改过</li>
<li>Present bit：存在位，表示内存页在内存中还是已经被换出</li>
<li>Reference bit：参考位，追踪页面是否被访问</li>
</ul>
<h4 id="页表开销"><a href="#页表开销" class="headerlink" title="页表开销"></a>页表开销</h4><ul>
<li><strong>内存开销</strong>：每个页表项需要4B，页大小（PageSize）是4KB，要虚拟出一个4GB的空间，就要有4GB/4KB * 4B =4MB 空间来存储。对每个进程操作系统都要有4MB的空间用于页表的储存，开销很大。页表是按照页号进行索引查找的，这就需要本身是一段连续的内存空间，页表就是一个大的数组，实际上页表在物理上也连续。</li>
<li><strong>性能开销</strong>：对于每个内存引用，都要额外引入一次内存引用，效率不高,每一次访存都多了一步访问页表，性能显著下降</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1075436-20190809172852450-661010612.png" alt="img"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241212120853391.png" alt="image-20241212120853391"></p>
<h4 id="页表总结"><a href="#页表总结" class="headerlink" title="页表总结"></a>页表总结</h4><p><strong>Pros</strong>:</p>
<ul>
<li>No external fragments</li>
<li>Flexible, good support for sparse address space</li>
</ul>
<p><strong>Cons</strong>:</p>
<ul>
<li>Physical Space costs (Page table)</li>
<li>Speed Costs (extra memory access)</li>
</ul>
<h3 id="快表-TLB"><a href="#快表-TLB" class="headerlink" title="快表 TLB"></a>快表 TLB</h3><p><strong>如果想要快速的缓存，他就必须小，因为光速和其他物理限制会起作用</strong></p>
<p><strong>TLB</strong>：因为有二八定律，所以MMU要记下经常使用的虚拟页号，将VPN与PFN的映射关系存在 <strong>TLB</strong> 快表中（<strong>Translation Lookaside Buffer</strong> aka. <strong>Address Translation Cache</strong>）</p>
<h4 id="硬件实现-TLB-控制流"><a href="#硬件实现-TLB-控制流" class="headerlink" title="硬件实现 TLB 控制流"></a>硬件实现 TLB 控制流</h4><p>CISC 将tlb miss逻辑全权交给硬件负责，拿着虚拟页号 VPN 去 TLB 中查询</p>
<ul>
<li>TLB hit：直接访存(<code>AccessMemory</code>)</li>
<li><strong>TLB miss：查页表，查到PFN后写入TLB（<code>TLB_Insert</code>），重新执行TLB查询操作（<code>RetryInstruction</code>）</strong>  </li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241212122549686.png" alt="image-20241212122549686"></p>
<p>硬件实现：需要PTBR（x86架构中为CR3寄存器），页表的确切格式是写死在硬件里的（x86中为多级页表）</p>
<h4 id="软件实现-TLB-控制流"><a href="#软件实现-TLB-控制流" class="headerlink" title="软件实现 TLB 控制流"></a>软件实现 TLB 控制流</h4><p>RISC 将tlb miss看作一个异常，陷入OS，执行对应的处理程序</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241212124132429.png" alt="image-20241212124132429"></p>
<p><strong>软件实现的好处</strong>：可以随时更改，可扩展性强，页表的数据结构由操作系统自行决定，</p>
<p><strong>注意的问题</strong>：</p>
<ul>
<li>TLBmissHandler和一般的trap不同，一般return from trap 会从陷入后的地方继续执行，而TLBmiss则会从<strong>重试</strong>陷入之前的程序，因此保存的上下文很重要，尤其是程序计数器</li>
<li>TLBmissHandler也是代码，要访存，须谨防无限递归tlb miss的问题，可以专门把一块TLB的空间划给TLBmiss处理程序使用；或者也可以不使用虚拟内存，直接把代码物理地址告诉硬件（unmapped，陷阱表）</li>
</ul>
<h4 id="TLB-内容"><a href="#TLB-内容" class="headerlink" title="TLB 内容"></a>TLB 内容</h4><h5 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h5><p><code>VPN | PFN | other bits</code></p>
<p>是一个全相联（fully-associative）的cache结构，硬件会并行地查找这些项，</p>
<p><strong>other bits</strong>：</p>
<ul>
<li><p>protection：访问权限</p>
</li>
<li><p>valid：表示TLB是否记录着一个有效的<code>VPN-&gt;PFN</code>映射，PTE的有效位为0表示这是一个并未被应用申请过的非法地址</p>
</li>
<li><p>dirty：脏位</p>
</li>
<li><p>asid：access space id，地址空间id，用来标识不同进程的TLB条目<a target="_blank" rel="noopener" href="https://blog.csdn.net/Rong_Toa/article/details/110758233">Linux进程管理+内存管理：进程切换的TLB处理（ASID-address space ID、PCID-process context ID）_进程的asid-CSDN博客</a> </p>
</li>
</ul>
<h5 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h5><p>TLB集成在CPU内部的MMU，因此一定会有上下文切换的问题，VPN一样的条目会导致数据错误</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241212131757567.png" alt="image-20241212131757567"></p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>上下文切换的时候将所有 TLB 条目的<strong>有效位</strong>置0（flush），下一个进程可以随便覆盖</li>
<li>使用ASID（类似于pid）记录这个TLB条目属于哪个进程</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241212131846711.png" alt="image-20241212131846711"></p>
<p><strong>PFN一样的条目</strong>：可能是共享代码页，这样可以减少额外分配物理页</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241212131859962.png" alt="image-20241212131859962"></p>
<h5 id="例：MIPS-TLB-Entry"><a href="#例：MIPS-TLB-Entry" class="headerlink" title="例：MIPS TLB Entry"></a>例：MIPS TLB Entry</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241212134843225.png" alt="image-20241212134843225"></p>
<p>0-18 VPN  19 Global 进程间共享  24-31 ASID 进程空间 </p>
<h4 id="刷新、替换"><a href="#刷新、替换" class="headerlink" title="刷新、替换"></a>刷新、替换</h4><h5 id="TLB-flush"><a href="#TLB-flush" class="headerlink" title="TLB flush"></a>TLB flush</h5><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/66971714">TLB之flush操作[一] - 知乎</a> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/66994486">TLB之flush操作[二] - 知乎</a> <a target="_blank" rel="noopener" href="https://blog.csdn.net/Rong_Toa/article/details/110760995">Linux内存管理：TLB flush操作-CSDN博客</a> </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Rong_Toa/article/details/110758233">Linux进程管理+内存管理：进程切换的TLB处理（ASID-address space ID、PCID-process context ID）_进程的asid-CSDN博客</a> </p>
<p>在页表PTE的内容出现变化时，比如page fault时页面被换出，munmap()时映射被解除，就需要invalidate对应的TLB entry，有时这个操作也被称为flush（以下的讨论将统一称为flush）。</p>
<p>当系统中各个cpu的TLB中的asid合起来不大于256个的时候，系统正常运行，一旦超过256的上限后，我们将全部TLB flush掉，并重新分配ASID，每达到256上限，都需要flush tlb并重新分配HW ASID。</p>
<p>在多核系统中，虽然每个核心的MMU是独立的，但它们在访问<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=695131149&content_type=Answer&match_order=1&q=%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98&zhida_source=entity">共享内存</a>时需要进行协调。共享内存区域允许多个核心同时访问相同的物理内存，这对于核心间的通信或共享数据非常关键。MMU可以通过为不同的内存区域设置权限和属性，确保多个核心在访问这些共享区域时不会出现数据冲突或不一致的情况。这在多线程或多进程系统中，尤其在同步和内存一致性方面，显得尤为重要。</p>
<h5 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a><a href="#eviction">缓存更新策略</a></h5><h2 id="优化分页"><a href="#优化分页" class="headerlink" title="优化分页"></a>优化分页</h2><h3 id="扩大页面大小（Bigger-Pages）"><a href="#扩大页面大小（Bigger-Pages）" class="headerlink" title="扩大页面大小（Bigger Pages）"></a>扩大页面大小（Bigger Pages）</h3><p>Linux</p>
<ul>
<li><p>对TLB更加友好，考虑到空间局部性，同一页能够访问更多数据，也就不用频繁地查页表了</p>
</li>
<li><p>增大页面大小，VPN<del>max</del>变小，每个虚拟页占空间4B，页表占用总空间减小；</p>
</li>
<li><p>但应用程序申请的并不一定是会充满整个页，所以会出现内部碎片（internal fragment）</p>
</li>
</ul>
<h3 id="分段-分页（Hybrid-Approach）"><a href="#分段-分页（Hybrid-Approach）" class="headerlink" title="分段 + 分页（Hybrid Approach）"></a>分段 + 分页（Hybrid Approach）</h3><h4 id="线性页表的局限"><a href="#线性页表的局限" class="headerlink" title="线性页表的局限"></a>线性页表的局限</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241212210406110.png" alt="image-20241212210406110"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241212210703824.png" alt="image-20241212210703824"></p>
<p>如图，虚拟空间是16KB，页面大小为1KB，因此页表共有16 entries，除去代码段，堆栈之间的空间是严重浪费的，就像分段会导致内部碎片一样，连续的线性页表也会导致内部碎片。</p>
<h4 id="段页结合"><a href="#段页结合" class="headerlink" title="段页结合"></a>段页结合</h4><p>VAX/VMS</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241212213305035-1734010396522-12.png" alt="image-20241212213305035"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/8904fb89ae0c49c4b0f2f7b5a0a7b099.png" alt="img"></p>
<p>可以根据代码、堆、栈对页表进行分类，然后使用三个base-bound寄存器对，上下文切换时保存、恢复寄存器内容。更细粒度的分段可以使用段表。base存储段在物理内存的位置，bound表示段大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SN  = (VirtualAddress &amp; SEG_MASK) &gt;&gt; SN_SHIFT</span><br><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; VPN_SHIFT</span><br><span class="line">AddressOfPTE = Base[SN] + (VPN * <span class="keyword">sizeof</span>(PTE))</span><br></pre></td></tr></table></figure>

<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><ul>
<li>与分段的缺陷一样，只不过是将真正的数据部分换成了页表</li>
<li>不灵活，假设地址空间有一定的使用模式，分段则需要为整个堆段预留连续空间，即使中间部分未使用也无法释放。<ul>
<li>a large but sparsely-used heap 仍然可能导致大量的页表浪费</li>
</ul>
</li>
<li>由于界限寄存器的存在，每个段有多少页是不确定的，因此每个段的页表大小也不确定，导致寻找足够的连续自由空间比较复杂。虽然节省内存但是有外部碎片问题</li>
</ul>
<h3 id="多级页表（Multi-level-Page-Tables）"><a href="#多级页表（Multi-level-Page-Tables）" class="headerlink" title="多级页表（Multi-level Page Tables）"></a>多级页表（Multi-level Page Tables）</h3><p>x86 ARM Linux Windows</p>
<p>减小页表占用的空间，分散成多个页表，<strong>每张页表大小==相同==<strong>，</strong>并且刚好能填满一整个内存页</strong>，消灭了外部碎片</p>
<p><strong>如果整页的PTE都是无效的（未分配），则完全不分配该页面的页表。</strong></p>
<ul>
<li>PDE的有效位：此条目指向的页是否有页表？PTE的有效位：此条目是否是一个有效的PFN映射？</li>
<li>树形结构，不用的可以不分配页表空间。支持稀疏空间：不用的就不分配物理内存页</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241212214704876.png" alt="image-20241212214704876"></p>
<h4 id="页表目录-页表-内存"><a href="#页表目录-页表-内存" class="headerlink" title="页表目录-页表-内存"></a>页表目录-页表-内存</h4><p>CR3存的是页表目录（Page Directory）的基址，假设虚拟地址前4位是页表目录的编号，中间4位是页表（Page Table）编号，后12位为偏移。CR3找到了页表目录，根据前4位索引到PTE的PFN，根据中间4位找到页表中的PTE，PTE中存储着物理页的PFN。</p>
<ul>
<li><p>基本思想：基址 + 偏移 </p>
</li>
<li><p><code>VPN = PD_index | PT_index</code> </p>
</li>
<li><p><strong>页目录项</strong>地址: <code>PD_Entry_Addr = Page_Dir_Base + PD_index * sizeof(PD_Entry_Addr)</code> </p>
</li>
<li><p><strong>页表项</strong>地址：  <code>PT_Entry_Addr = PD_Entry.PFN &lt;&lt; SHIFT + PT_index * sizeof(PT_Entry_Addr)</code> </p>
</li>
<li><p>页面地址 ：<code>Page_Entry_Addr = PT_Entry.PFN &lt;&lt; SHIFT + Offset</code> </p>
</li>
</ul>
<p>以16位虚拟地址为例：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240924221042539.png" alt="image-20240924221042539"></p>
<ul>
<li><strong>虚拟内存的要求</strong>：每一层级内部必须是连续的，因为分配物理内存空间只能一次性分配连续的一段</li>
<li>单级页表要想实现页表只能一次性分配256个连续的entries。</li>
<li>多级页表如果<strong>真的只有</strong>这3个地址所在的physical page被用到，那么只需要48 个entries就可以了</li>
</ul>
<p>在32位系统中，进程的虚拟地址空间为4GB，但某个进程实际使用的页只占其中的一小部分，其分布是稀疏的，因此非常适合使用多级页表这种稀疏的级联数组(<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Radix_tree">radix tree</a>)来表示。</p>
<h4 id="fill-the-pages"><a href="#fill-the-pages" class="headerlink" title="fill the pages"></a>fill the pages</h4><h5 id="例：30位虚拟地址"><a href="#例：30位虚拟地址" class="headerlink" title="例：30位虚拟地址"></a>例：30位虚拟地址</h5><p>目标：每张表填满一整个内存页 Page Size = 2^7^ * 4 B = 512 B，二级页表不能刚好占满一页</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241213134804005.png" alt="image-20241213134804005"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241213135215659.png" alt="image-20241213135215659"></p>
<h5 id="实际的32位和64位页表"><a href="#实际的32位和64位页表" class="headerlink" title="实际的32位和64位页表"></a>实际的32位和64位页表</h5><p>在32位处理器中，采用4KB的page大小，则虚拟地址中低12位为offest，剩下高20位给页表，<strong>分成两级</strong>，每个级别占10个bit（10+10）。为什么32位系统的页表每级占10位，每个页的大小被设定为<code>4KB</code>而不是2KB或者8KB？</p>
<p>如果index为10位，则其可索引的范围是1024个entris，32位系统中，每级页表的每个entry的大小为4个字节，则每个页表的大小刚好是4KB。页表首地址也是要按页对齐的，如果占不满一个页，页中剩下的空间也就浪费了。80386引入<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=102569108&content_type=Article&match_order=1&q=%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6&zhida_source=entity">分页机制</a>的时候应该就考虑过把页设置为多大是最合适的，显然4KB的页大小对内存的利用是最充分的。1024 * 4 = 4 K</p>
<p><img src="https://i.stack.imgur.com/R19zY.png" alt="memory management - Why 32-bit Windows can maximum have 16TB Page File ..."></p>
<p>为什么64位系统的页表<strong>每级占9位</strong>呢？为了和硬件配合，基于i386编写的linux也采用4KB的页大小作为<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=102569108&content_type=Article&match_order=1&q=%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86&zhida_source=entity">内存管理</a>的基本单位。处理器进入64位时代后，其实可以不再使用4KB作为一个页帧的大小，但可能为了提供硬件的向前兼容性以及和操作系统的兼容性吧，大部分64位处理器依然使用4KB作为默认的页大小（ARMv8-A还支持16KB和64KB的页大小）。因为64位系统中，每级页表的每个entry的大小为8个字节，如果index为9位，则每个页表的大小也刚好是4KB。</p>
<p>512 * 8 = 4K </p>
<p><img src="https://i.sstatic.net/Bswtz.png" alt="img"></p>
<h4 id="TLB-控制流"><a href="#TLB-控制流" class="headerlink" title="TLB 控制流"></a>TLB 控制流</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241213141353216.png" alt="image-20241213141353216"></p>
<p>依然是先查TLB，TLB没有再查页表，先用PDBR加偏移 算出PDE的物理地址得到PTE所在的PFN，找到PTE之后根据PTE里面的PFN加偏移算出真实的物理地址。</p>
<h3 id="倒排页表（Inverted-Page-Table）"><a href="#倒排页表（Inverted-Page-Table）" class="headerlink" title="倒排页表（Inverted Page Table）"></a>倒排页表（Inverted Page Table）</h3><p>PowerPC</p>
<p>页表的映射反过来，PFN-&gt;VPN，除了VPN，还有使用此页的进程标识。通常使用Hash散列表来加快搜索。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1006507-20161224105816979-1390337413.png" alt="img"></p>
<h3 id="交换到磁盘（Swap）"><a href="#交换到磁盘（Swap）" class="headerlink" title="交换到磁盘（Swap）"></a>交换到磁盘（Swap）</h3><p>之前的页表都需要直接访问物理内存，页表本身并没有在程序的地址空间中，因此页表必须时时刻刻在物理内存中</p>
<p>VAX/VMS 把页表纳入内核的虚拟内存，允许在内存压力较大时将页表的一部分交换到磁盘。</p>
<h2 id="超越物理内存"><a href="#超越物理内存" class="headerlink" title="超越物理内存"></a>超越物理内存</h2><p>虚拟内存本质是虚的，实际数据可以存储在任何地方：<strong>寄存器（TLB）</strong>、<strong>物理内存（DRAM）</strong>，甚至是<strong>磁盘（HDD SSD）</strong>，因此虚拟内存大小跟物理内存大小并没有直接的关系，编程人员只需提供<code>Virtual Address</code>，由硬件和OS负责剩下的步骤，这就提升了程序的易用性，也提升了处理程序的多样性，考虑页表的数据结构，页表存储的位置等问题。</p>
<h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><h4 id="交换空间"><a href="#交换空间" class="headerlink" title="交换空间"></a>交换空间</h4><p>硬盘需要腾出一片专门的空间用来存放物理内存的内容，因此也需要进行编址。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241213145818889.png" alt="image-20241213145818889"></p>
<blockquote>
<p>The code pages from this binary are initially found on disk, and when the program runs, they are loaded into memory (either all at once when the program starts execution, or, as in modern systems, one page at a time when needed). However, if the system needs to <strong>make room in physical memory for other needs</strong>, it can safely re-use the memory space for these code pages, knowing that it can later swap them in again from the on-disk binary in the file system.</p>
</blockquote>
<p><strong>虚拟内存提供了一种将磁盘和物理内存结合起来的方式</strong>：</p>
<ul>
<li>代码页从磁盘加载到内存，过一段时间被换出，随后在需要的时候又被换入。</li>
<li>操作系统将整个物理内存看作“缓存”。</li>
<li>当内存不足时，系统会将不常用的内存页换出到磁盘（称为交换或分页）。</li>
<li>反之，如果需要使用换出的页面，系统会从磁盘重新加载到内存。</li>
</ul>
<h4 id="页错误（page-fault）"><a href="#页错误（page-fault）" class="headerlink" title="页错误（page fault）"></a>页错误（page fault）</h4><p><strong>存在位（presentation bit）</strong>：用来标识一个页是否在物理内存中，如果不在，对此内存地址的访问就会触发page fault（实际上是page miss），陷入OS</p>
<p><strong>Why OS</strong> <strong>Handles This?：</strong>TLB miss可以由硬件实现，但是Page Fault并不需要，因为Page Fault的处理性能瓶颈在硬盘：硬盘的读写速度比内存慢很多，硬件处理性能提升并不明显，并且硬件必须添加其他复杂的机制（写死在硬件里）</p>
<p>硬盘IO完成，更新PTE的PFN和存在位（也可以同时写入TLB中）然后Retry Instruction，IO过程中进程处于<strong>阻塞状态（blocked state）</strong>，OS可以在这段时间内切换到其他进程以提高CPU利用率。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/121-1.png" alt="Lightbox"></p>
<p>上述是硬性的页错误（虚拟内存地址不在物理内存中），还有一种软性页错误（虚拟内存地址在物理内存中），<em>详见VAX/VMS</em></p>
<p><strong>控制流</strong>：</p>
<ul>
<li>错误的严重程度：<ol>
<li><code>segmentation fault</code>（<code>valid bit = 0</code>, 没有分配） </li>
<li><code>protection fault</code>（<code>protect bits</code>, 权限不够）</li>
<li><code>page fault</code>（<code>present bit = 0</code>, 不在内存里）</li>
</ol>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241213153405737.png" alt="image-20241213153405737"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241213153341054.png" alt="image-20241213153341054"></p>
<p><strong>Page-Fault Handler by OS</strong>：</p>
<ul>
<li>找空闲的物理内存，记录其PFN<ul>
<li>找不到就使用<strong>淘汰策略</strong>，把现在的物理内存页换一部分到磁盘里，腾出空间</li>
<li>如果找到了就进行磁盘 I/O，系统调用会<strong>休眠</strong>，直到 I/O 完成。</li>
</ul>
</li>
<li>换入完成就更新页表的存在位和PFN</li>
</ul>
<h4 id="访存机制总结"><a href="#访存机制总结" class="headerlink" title="访存机制总结"></a>访存机制总结</h4><p>首先到 MMU 集成的 TLB 中查询，TLB 中存储的是虚拟地址页号（VPN）和物理地址页号（PFN）的映射关系，TLB 命中则直接访问物理页框；之后就是之前正常的 CPU 访存过程，与操作系统没有关系。TLB 未命中则去找 CPU 集成的 Table Walk Unit，TWU 中的 CR3 寄存器存储着当前页目录（Page Directory）的物理地址页号PFN，如果内存中的页表没有对应的内容，则触发页错误（Page Fault）去磁盘中寻找，页表命中则更新 TLB，重试指令。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/slide_1.jpg" alt="Virtual to Physical Address Translation Effective Address TLB Lookup Page  Table Walk Update TLBPage Fault OS Table Walk Protection Check Physical  Address. - ppt download"></p>
<h3 id="Swap-页面置换策略"><a href="#Swap-页面置换策略" class="headerlink" title="Swap 页面置换策略"></a><span id="eviction">Swap 页面置换策略</span></h3><p>$$<br>AMAT=(P_\text{Hit} \cdot T_\text{Mem})+(P_\text{Miss} \cdot T_\text{Disk})<br>$$</p>
<p>Tmem = 100ns(100个时钟周期) Tdisk = 10ms（10000个时钟周期） 对性能影响极大</p>
<h4 id="基本策略-1"><a href="#基本策略-1" class="headerlink" title="基本策略"></a>基本策略</h4><p>将物理内存看作虚拟内存的缓存，置换策略实际上就是缓存淘汰策略</p>
<p><strong>局部性原理</strong></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000043722445">缓存算法：LRU、LFU、随机替换等常见算法简介 - 个人文章 - SegmentFault 思否</a> </p>
<p>我们能不能既享受 CPU Cache 的速度，又享受内存、硬盘巨大的容量和低廉的价格呢？前辈们已经探索出了答案，那就是，存储器中数据的局部性原理（Principle of Locality）</p>
<ul>
<li><p>**时间局部性(temporal locality)**：如果一个数据被访问了，那么它在短时间内还会被再次访问。如 LRU 缓存机制，将频繁访问的数据保存在内存中。</p>
</li>
<li><p>**空间局部性(spatial locality)**：如果一个数据被访问了，那么和它相邻的数据也很快会被访问。如果数组的 CPU 预读功能。</p>
</li>
<li><p><strong>OPT 最优</strong>：事先知道缓存的访问顺序（不可能）但是可以作为一个比较指标。</p>
</li>
<li><p><strong>无状态策略</strong>：</p>
<ul>
<li><p>FIFO：先进先出</p>
</li>
<li><p>Random：随机</p>
</li>
</ul>
</li>
<li><p><strong>LRU</strong>(Recently)基于上次被访问时间，<strong>LFU</strong>(Frequently)基于被访问的频率</p>
</li>
</ul>
<p>基本有LRU FIFO Random，时钟算法（近似LRU），SecondChance（完善的FIFO），2Q（LRU+FIFO）</p>
<p>LFU：当使用 mmap() 访问文件缓存页面时，无法计数，实现较为复杂，不适合操作系统对虚拟内存的管理</p>
<h4 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h4><h5 id="完全随机访问"><a href="#完全随机访问" class="headerlink" title="完全随机访问"></a>完全随机访问</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241213175231404.png" alt="image-20241213175231404"></p>
<h5 id="二八定律"><a href="#二八定律" class="headerlink" title="二八定律"></a>二八定律</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241213175332544.png" alt="image-20241213175332544"></p>
<h5 id="循环顺序访问"><a href="#循环顺序访问" class="headerlink" title="循环顺序访问"></a>循环顺序访问</h5><p>依次引用第0到第49页，LRU和FIFO，缓存在50以内，命中率为0</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241213175411886.png" alt="image-20241213175411886"></p>
<ul>
<li><p>LRU，基于<strong>时间局部性</strong>的策略，<strong>预测性强</strong>：对于访问频繁的页表项保留效果好。</p>
<ul>
<li>循环访问 n+1 页，但TLB只有n页容量，第一次TLB空的，全部 miss，由于空间限制，最后第n+1页会覆盖第1页。下一个循环开始第1页又 miss，第1页覆盖第2页内容，连锁的 miss</li>
</ul>
</li>
<li><p>Random，实现简单，避免出现极端情况下LRU命中率极低的情况，<strong>不可预测</strong>：无法优化特定程序的访问模式。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>策略</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>LRU</strong></td>
<td>高命中率，适应访问局部性</td>
<td>实现复杂，硬件成本高</td>
<td>对性能敏感的高端系统</td>
</tr>
<tr>
<td><strong>随机</strong></td>
<td>实现简单，硬件成本低，性能稳定</td>
<td>命中率较低，忽略访问规律</td>
<td>简单的嵌入式系统或硬件资源有限的场景</td>
</tr>
</tbody></table>
<h4 id="LRU-实现"><a href="#LRU-实现" class="headerlink" title="LRU 实现"></a>LRU 实现</h4><ul>
<li>可以对每一页添加时间字段，可以在页表中也可以专门在物理内存中的一片区域（redis就是这么做的），但代价高。</li>
</ul>
<p>添加一个 <strong>reference bit</strong> 使用位（用页表或者bitmap存储）当页被访问（读或写）时，由硬件（MMU）将其置1，操作系统负责将其置0，1代表最近用过了，0代表最近没用过</p>
<h5 id="近似-LRU：时钟算法"><a href="#近似-LRU：时钟算法" class="headerlink" title="近似 LRU：时钟算法"></a>近似 LRU：时钟算法</h5><p>维护一个循环列表，里面放着所有页的使用情况，时钟指针指向其中的一页，当需要替换页，如果use bit=1，将其置0，然后移动到下一页，直到寻找到第一个use bit = 0的页，将其换出</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241213184105746.png" alt="image-20241213184105746"></p>
<h5 id="脏位"><a href="#脏位" class="headerlink" title="脏位"></a>脏位</h5><p>dirty bit的优先级大于use bit 也由MMU维护，硬件会在发生<strong>写操作</strong>时自动设置脏位，页面换出首先考虑的是未被访问过的干净页，然后是被访问过的干净页。</p>
<ol>
<li><strong>标记页面是否被修改过</strong><ul>
<li>当一个页面被写入（例如进程对该页面的内容进行了修改），操作系统会将该页面的脏位置为 <code>1</code>。</li>
<li>如果页面从加载到内存以来未被修改，脏位保持为 <code>0</code>。</li>
</ul>
</li>
<li><strong>决定页面是否需要写回磁盘</strong><ul>
<li>如果一个页面需要被换出（从内存移到磁盘），操作系统会检查其脏位：<ul>
<li><strong>脏位为 1</strong>：表示页面内容已被修改，需要将修改后的内容写回磁盘（例如文件或交换区）。</li>
<li><strong>脏位为 0</strong>：页面未被修改，可以直接丢弃内存中的内容，因为磁盘上已有最新副本。</li>
</ul>
</li>
</ul>
</li>
<li><strong>减少不必要的磁盘写入</strong><ul>
<li>通过脏位的判断，可以避免无意义的磁盘写入操作，提高性能。例如，如果页面内容没有修改，就无需将内存中的数据写回磁盘。</li>
</ul>
</li>
</ol>
<h5 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h5><p>LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/41aee01a98aa03f4c3d75ef4c2c7749a.png" alt="img" style="zoom:200%;" /> 

<ol>
<li>数据第一次被访问，加入到访问历史列表；</li>
<li>如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；</li>
<li>当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</li>
<li>缓存数据队列中被再次访问后，重新排序；</li>
<li>需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。</li>
</ol>
<p>LRU-K具有LRU的优点，同时能够避免LRU的缺点，实际应用中LRU-2是综合各种因素后最优的选择，LRU-3或者更大的K值命中率会高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉。</p>
<h3 id="其他-Swap-策略"><a href="#其他-Swap-策略" class="headerlink" title="其他 Swap 策略"></a>其他 Swap 策略</h3><p><strong>页面置换策略</strong>：<u>which</u> page to <u>swap out</u>?</p>
<p><strong>页面选择策略</strong>：when to <u>swap in</u> which page? </p>
<ul>
<li>OS决定何时将页面载入内存，大多数页面是按需载入(demand paging)</li>
<li>有时会提前载入(prefetching)马上可能要被访问的页面，比如连续的代码页</li>
</ul>
<p><strong>写入磁盘策略</strong>：when and how to <u>swap out</u>? or not?</p>
<ul>
<li>不一定是内存满了才会开始交换，OS预留部分空闲空间，设置HW和LW，当可用页少于LW，就swap out，直到可用页数达到HW，有一个守护进程 <code>swapd</code> 专门做这件事情。</li>
<li>交换本身是IO操作，可以通过聚集/分组的方式将多个等待写入写出的页合并操作，提高硬盘效率，执行单次大的写操作比许多小的写操作有效。</li>
<li>数据一致性：脏页需要被换出（刷盘, sync）</li>
</ul>
<p><strong>颠簸（thrashing）</strong>: 内存被超额请求，os需要不断进行页面的置换，此时可能会考虑终止一些进程(linux oom killer会杀死内存密集型，一般这些都是低优先级的，也有一定的风险)</p>
<h2 id="完整的虚拟内存系统"><a href="#完整的虚拟内存系统" class="headerlink" title="完整的虚拟内存系统"></a>完整的虚拟内存系统</h2><h3 id="VAX-VMS-虚拟内存系统"><a href="#VAX-VMS-虚拟内存系统" class="headerlink" title="VAX/VMS 虚拟内存系统"></a>VAX/VMS 虚拟内存系统</h3><h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><h5 id="应用进程共享内核空间"><a href="#应用进程共享内核空间" class="headerlink" title="应用进程共享内核空间"></a>应用进程共享内核空间</h5><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241213214150106.png" alt="image-20241213214150106" style="zoom:150%;" />

<ul>
<li>地址空间的下半部分称为进程空间，前半段是代码和向下增长的堆（P0），后半段是向上增长的堆（P1），<strong>各自拥有一个页表</strong>，减少了内部碎片。</li>
<li>地址空间的上半段称为系统空间S，只使用其中一半</li>
</ul>
<p>内核段包含在用户空间中，是所有的进程共享的，这样使得内核与用户程序之间数据交互更加方便，OS可以轻松地解析用户程序传入的指针。通过给系统空间设置保护位来确保内核的安全。</p>
<h5 id="优化页表"><a href="#优化页表" class="headerlink" title="优化页表"></a>优化页表</h5><ul>
<li>分出来的两个段，各自有一个页表[段页式管理]，减少了内部碎片 </li>
<li>进程的虚拟地址空间也包含了内核段，因此可以把用户<strong>页表纳入受保护的内核虚拟内存</strong>中，当存储压力巨大时可以将页表换出到磁盘，有一定的访问性能开销。</li>
</ul>
<h5 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h5><p>NULL是一个宏，实际上就是0，虚拟地址0有效位始终是0，因此试图访问这个有效位会出现段错误异常，陷入OS终止进程</p>
<h4 id="惰性优化（Lazy）"><a href="#惰性优化（Lazy）" class="headerlink" title="惰性优化（Lazy）"></a>惰性优化（Lazy）</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/whiteBear/p/16729327.html">延迟分配：提供内存利用率的三种机制 - 牛犁heart - 博客园</a> </p>
<h5 id="写入时复制-copy-on-write"><a href="#写入时复制-copy-on-write" class="headerlink" title="写入时复制 copy-on-write"></a>写入时复制 copy-on-write</h5><p>如果要将一个页面从一个地址空间复制到另一个地址空间，会获取相同的指针，指向相同的资源。这个资源或许是内存中的数据，又或许是硬盘中的文件，直到某个应用真正需要<strong>修改某一页</strong>时，操作系统才会（惰性地）<strong>复制一份该页的专用副本</strong>给该应用，填充数据而其他所见的最初资源仍然保持不变。</p>
<p>COW的优点：<strong>如果应用没有修改该资源，就不会产生副本，因此多个应用只是在读取操作时可以共享同一份资源，从而节省内存空间。</strong> <strong>fork 会复制应用 A 的很多关键数据，但不会复制应用 A 对应的物理内存页面，而是要监测这些物理内存的读写，只有这样才能让应用 A 和应用 B 正常运行</strong></p>
<ul>
<li>fork但未写入</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1059417-20220925215845353-1129676397.png" alt="image"></p>
<ul>
<li>fork后写入</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1059417-20220925221038426-1637796167.png" alt="image"></p>
<p>fork()需要复制整个地址空间的内容，如果fork之后还调用了exec，这些地址空间内容又会被马上覆盖，做无用功，cow避免了大量不必要的复制操作，仍然保留正确的语义。</p>
<h5 id="按需调页-demand-paging"><a href="#按需调页-demand-paging" class="headerlink" title="按需调页 demand paging"></a>按需调页 demand paging</h5><ul>
<li><p><strong>按需调页</strong>是一种<strong>动态内存分配技术</strong>，更是一种优化技术，它把<strong>物理内存页面的分配推迟到不能再推迟为止</strong>。之所以能实现，是因为应用程序开始运行时，并不会访问虚拟内存空间中的全部内容。</p>
</li>
<li><p>由于<strong>程序的局部性原理</strong>，使得应用程序在执行的每个阶段，真正使用的内存页面只有一小部分，对于暂时不用的物理内存页，就可以分配由其他应用程序使用。因此，在不改变物理内存页面数量的情况下，请求调页能够提高系统的吞吐量。</p>
</li>
</ul>
<p>当页添加到地址空间时，会在页表做一个标记（保留的操作系统字段），当进程真正访问到这个虚拟页时，操作系统才会真正寻找物理页并将其置零，映射到地址空间，这样就避免了申请了但是从来不访问 导致浪费的情况。</p>
<h4 id="SWAP-策略"><a href="#SWAP-策略" class="headerlink" title="SWAP 策略"></a>SWAP 策略</h4><h5 id="替换策略：Second-Chance-FIFO"><a href="#替换策略：Second-Chance-FIFO" class="headerlink" title="替换策略：Second Chance FIFO"></a>替换策略：Second Chance FIFO</h5><p>利用的是软性的页错误</p>
<ul>
<li>用RSS(Resident Set Size)限制每个进程可以保存在内存中的最大页数，超过RSS就要“First out”，防止自私进程</li>
<li>引入两个全局的页面表，一个记录空闲干净页，另一个记录脏页</li>
<li>First Out 被换出的页面根据脏位添加到 干净页列表 或 脏页列表 的<strong>末尾</strong> </li>
<li>另一个进程需要空闲页，会先去干净页列表中取出<strong>第一个</strong>空闲页</li>
<li>如果换出页面的进程触发了page fault，则会从表中重新回收页，避免磁盘I/O </li>
</ul>
<h5 id="批量换出：page-clustering"><a href="#批量换出：page-clustering" class="headerlink" title="批量换出：page clustering"></a>批量换出：page clustering</h5><p>把大批量的页从上述的全局脏页列表中分组聚集到一起，一起写入到磁盘中，使IO次数减少，单次IO写入量更大，提高性能</p>
<h3 id="Linux-虚拟内存系统"><a href="#Linux-虚拟内存系统" class="headerlink" title="Linux 虚拟内存系统"></a>Linux 虚拟内存系统</h3><p><strong>Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理</strong>。于是 Linux 就把所有段的基地址设为 <code>0</code>，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。虚拟空间分布可分为<strong>用户态</strong>和<strong>内核态</strong>两部分</p>
<h4 id="地址空间-1"><a href="#地址空间-1" class="headerlink" title="地址空间"></a>地址空间</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/v2-50e72a482d4b10604708f5e6a6c76435_r.jpg" alt="img"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241213232325106.png" alt="image-20241213232325106"></p>
<ul>
<li>0-3GB是用户空间，其中用户态的分布：代码段(.ELF)、全局变量（初始化的数据段）、BSS（未初始化的数据段）、堆内存（Heap）、映射区（mmap）、函数栈（Stack）、初始化参数（argument, environment）</li>
<li>最高1GB为内核空间，存放内核的代码以及其他受保护的数据；像VAX/VMS一样，每个用户的进程空间内有着相同的内核。</li>
<li>64位的地址空间：低128T为用户空间，高128T为内核空间，中间未定义</li>
</ul>
<h5 id="逻辑内核空间（kmalloc）"><a href="#逻辑内核空间（kmalloc）" class="headerlink" title="逻辑内核空间（kmalloc）"></a>逻辑内核空间（kmalloc）</h5><ul>
<li><p>内核代码需要调用<code>kmalloc</code>申请，内核栈、页表等数据结构存储在这里</p>
</li>
<li><p>只能在物理内存中，不能被换出到磁盘</p>
</li>
<li><p><strong>严格的一对一直接映射</strong>：<code>0xC0000000</code> to <code>0x00000000</code>, <code>0xC0000FFF</code> to <code>0x00000FFF</code></p>
<ul>
<li><p>不需要进行复杂地址转换，直接将其当成物理地址即可，因此也不需要页表结构</p>
</li>
<li><p>连续的虚拟地址在物理上也一定是连续的</p>
</li>
<li><p>适合DMA</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>This makes memory allocated in this part of the kernel’s address space suitable for operations which need contiguous physical memory to work correctly, such as I/O transfers to and from devices via <strong>direct memory access (DMA)</strong></p>
</blockquote>
<h5 id="虚拟内核空间（vmalloc）"><a href="#虚拟内核空间（vmalloc）" class="headerlink" title="虚拟内核空间（vmalloc）"></a>虚拟内核空间（vmalloc）</h5><ul>
<li>内核代码需要调用<code>vmalloc</code>申请，returns 指向连续虚拟内存区域的指针</li>
<li>不是直接映射，因此连续的虚拟地址在物理上并不一定连续</li>
<li>容易分配(easy to allocate), 因此适合大块缓冲区，因为连续的大块物理内存显然不容易找到</li>
</ul>
<p>在32位Linux中，虚拟内核空间可以让内核空间大于1GB</p>
<blockquote>
<p>Kernel virtual addresses, and their disconnection from <strong>a strict one-to-one mapping to physical memory</strong>, make this possible. However, with the move to 64-bit Linux, the need is less urgent, because the kernel is not confined to only the last 1 GB of the virtual address space. （64位就没那么重要了）</p>
</blockquote>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/overview.png" style="zoom:150%;" />

<h5 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h5><h6 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h6><ul>
<li><p>在不同OS中，malloc的实现也不同，有 dlmalloc, jemalloc, tcmalloc等实现</p>
</li>
<li><p>Linux中，用户可以显式调用mmap或者malloc分配，malloc底层基于mmap（大于128K）或brk（小于128K）</p>
</li>
<li><p>这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</p>
</li>
<li><p>大部分不建议使用brk，brk和sbrk分配的堆空间类似于缓冲池，调用它相当于增大缓冲池。用malloc可以重用前面空闲的内存空间，每次malloc从缓冲池获得内存，如果缓冲池不够了，malloc才会调用brk或sbrk扩充缓冲池，直到达到缓冲池大小的上限，free则将应用程序使用的内存空间归还给缓冲池。而free mmap会直接释放，将空间给操作系统，无法复用，一定会触发缺页中断。</p>
</li>
</ul>
<h6 id="brk"><a href="#brk" class="headerlink" title="brk"></a>brk</h6><p>brk 的实现方式是移动Program break，将数据段的最高地址指针 _edata(end of data) 往高地址推（分配的内存小于 128KB），sbrk是通过增量来控制的，原理类似。</p>
<ul>
<li><p>同一个程序bss的结束地址是固定的，而heap的起始地址在每次运行的时候都会改变 <strong>ASLR</strong>。</p>
</li>
<li><p>当<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Address_space_layout_randomization">ASLR</a>（Address Space Layout Randomization）关闭时，<code>start_brk</code>和brk同时指向<code>data/bss</code>段的结束位置（<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/include/linux/mm_types.h?v=3.8#L364">end_data</a>）。</p>
</li>
<li><p>当ASLR打开时，<code>start_brk</code>和brk同时指向<code>data/bss</code>段的结束位置（<code>end_data</code>）再加上一个随机的brk偏移。</p>
</li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/20032_0.png" alt="img" style="zoom:150%;" />

<p>brk的问题：</p>
<p>使用brk连续申请了10K, 20K, 30K内存，前两部分释放了，但是不会归还给操作系统，如果再次申请内存小于30K，就可以复用空闲区域，但是如果申请40K，就会出现内部碎片问题，只能继续新申请40K内存，导致大量内存碎片问题</p>
<h6 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h6><p>在用户进程空间内的内存映射段找一块空闲的虚拟内存（分配的内存大于 128k））—匿名空间，具体使用可见: <em>Memory-mapped I/O</em> </p>
<h5 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h5><h6 id="伙伴系统（Buddy-system）"><a href="#伙伴系统（Buddy-system）" class="headerlink" title="伙伴系统（Buddy system）"></a>伙伴系统（Buddy system）</h6><p>Buddy分配系统在普通内存池的基础上，允许两个<strong>大小相同且相邻</strong>的内存块合并，合并之后的内存块的「尺寸」增大，因而将被移动到另一个内存池的free list上。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241210230312259.png" alt="image-20241210230312259"></p>
<p>总空间为2^N^，按照递归二分法分配内存，直到块大小刚好满足要求（显然这会导致内部碎片）当一个块释放的时候，allocator会检验与他相同大小的相邻块（buddy）是否空闲，若是则将二者合并，直到合并全部空闲内存。</p>
<p>优点：buddy的地址很容易确认，既然是相邻，说明首部地址只差一位，这个位决定了他们在整个数中的层次</p>
<p>在 Linux 系统中，连续内存管理采用了 <strong>伙伴系统（Buddy System）算法</strong> 来实现，对于内部碎片的问题，采用了SLAB进行解决。</p>
<p>它把所有的空闲页放到11个链表中，每个链表分别管理大小为1，2，4，8，16，32，64，128，256，512，1024个页的内存块。当系统需要分配内存时，就可以从buddy系统中获取。当分配内存时，会优先从需要分配的内存块链表上查找空闲内存块，当发现对应大小的内存块都已经被使用后，那么会从更大一级的内存块上分配一块内存，并且分成一半给我们使用，剩余的一半释放到对应大小的内存块链表上。</p>
<p>想要分配一个8KB大小的内存，但是发现对应大小的内存已经没有了，那么伙伴系统会从16KB的链表中查找一个空闲内存块，分成两个8KB大小，把其中的一个8KB大小返回给申请者使用，剩下的8KB放到8KB对应的内存块链表中进行管理。更坏的一种情况是，系统发现16KB大小的连续内存页已经没有了，那么以此会向更高的32KB链表中查找，如果找到了空闲内存块，那么就把32KB分成一个16KB和两个8KB，16KB的内存块放到16KB的链表进行管理，两个8KB的内存块一个返回给申请者，另一个放到8KB大小的链表进行管理。</p>
<p>当释放内存时，会扫描对应大小的内存块链表，查看是否存在地址能够连续在一起的内存块，如果发现有，那么就合并两个内存块放置到更大一级的内存块链表上，以此类推。比如我们释放8KB大小的内存，那么会从对应的链表扫描是否有能够合并的内存块，如果有另一个8KB大小的内存和我们使用的内存地址连续，那么就合并它们组成一个16KB大小的内存块，然后接着扫描16KB大小的内存块链表，继续查找合并的可能，以此类推下去。</p>
<p>操作系统的内存管理通常是基于<strong>页（page）</strong>的概念，即操作系统将物理内存分为固定大小的页。页是内存管理的基本单位，这样可以统一管理和访问内存。页的大小通常是2的幂次方，例如4KB、8KB或16KB等。</p>
<ul>
<li><strong>操作系统需要高效地管理内存</strong>，而将内存管理的单位限定为页大小可以简化这一过程。每一页都有一个对应的页表项，操作系统只需要管理页而不是单个字节或更小的单位。这减少了管理开销。</li>
</ul>
<h6 id="分离空闲列表（SLAB-segregated-free-lists）"><a href="#分离空闲列表（SLAB-segregated-free-lists）" class="headerlink" title="分离空闲列表（SLAB, segregated free lists）"></a>分离空闲列表（SLAB, segregated free lists）</h6><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/slab-org.png" alt="slab org" style="zoom:150%;" />



<p>为了方便管理，Linux中的buddy allocator以物理页框为最小粒度，而现实的应用中，操作系统作为一个一直在运行的程序，多是以<strong>内核objects</strong>（比如描述文件的”struct inode”）的大小来申请和释放内存的，这些内核objects的大小通常从几十字节到几百字节不等，远远小于一个page的大小。如果程序固定分配一个或者几个大小的的内存，那就专门给他分配一块内存用于分配这些固定大小空间，减少了大小上的差异，碎片自然也就少了</p>
<p>在内核启动时，为诸如锁、文件inode之类频繁请求的内核object分配 <strong>Object cache</strong>，他们的对象缓存分离了特定大小的空闲列表，获得了性能上的提升，当cache将要耗尽时从通用的内存分配程序申请slab（总量是page size和object size的最小公倍数）例如，2.5KB objectsize, 4KB pagesize 就去申请5个页, 专门用来放这种object,一个页能放5个</p>
<p>当cache中内核object的引用计数变为0，通用的内存分配程序会从专用的分配器中回收这些资源。同时还使空闲对象保持在预初始化的状态，避免频繁销毁、初始化的开销。</p>
<p>Linux实现</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/understand-html037.png" alt="img" style="zoom:150%;" />

<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/v2-90fe0938cf0c8ab8836257ed587654d1_1440w.jpg" alt="img" style="zoom:150%;" />

<p>每个<code>kmem_cache</code>都是链接在一起形成一个全局的双向链表，系统可以从Cache_chain开始扫描每个<code>kmem_cache</code>（相当于上面说的内存池, fixed size）</p>
<p><code>slab</code>是内存池从系统申请内存的最小单位，在实现上一个<code>slab</code>有一个或多个连续的物理页组成（通常只有一页）单个<code>slab</code>可以在<code>slab</code>链表之间移动，例如如果一个<code>slabs_partial</code>中的slab被分配了对象后变满了，就要从<code>slabs_partial</code>中被删除，同时插入到<code>slabs_full</code>中去。</p>
<h4 id="页表结构"><a href="#页表结构" class="headerlink" title="页表结构"></a>页表结构</h4><p>虚拟地址：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241214003409861.png" alt="image-20241214003409861"></p>
<p>4KB的页大小对应12位offset，共四级页表，每级索引为9位，一个表条目占用4B空间，一张表正好占满一页</p>
<h4 id="更大的页大小（huge-pages）"><a href="#更大的页大小（huge-pages）" class="headerlink" title="更大的页大小（huge pages）"></a>更大的页大小（huge pages）</h4><blockquote>
<p>Specifically, recent designs support 2-MB and even 1-GB pages in hardware. Thus, over time, Linux has evolved to allow applications to utilize these <strong>huge pages</strong> (as they are called in the world of Linux).</p>
</blockquote>
<h5 id="提升-TLB-命中率"><a href="#提升-TLB-命中率" class="headerlink" title="提升 TLB 命中率"></a>提升 TLB 命中率</h5><p>一方面是减少了页表项数，更重要的是<strong>提升了TLB的命中率（hit rate）</strong>：</p>
<ul>
<li><strong>TLB的条目数(slots)是固定的，因为空间局部性，同一页放更多数据，将更多的物理内存空间纳入到TLB中</strong></li>
<li>换个角度，如果发生TLBmiss，因为页表项数的减少，遍历速度就会加快</li>
<li>与此同时，某些情况下也可以加快分配内存</li>
</ul>
<h5 id="如何申请"><a href="#如何申请" class="headerlink" title="如何申请"></a>如何申请</h5><p>一些对性能要求严格的应用如大型数据库应该使用更大的页大小，用来提高性能，必须通过<code>mmap</code>或者<code>shmget</code>进行显式申请，因此其他正常使用4KB页大小的程序不受影响。</p>
<p>**透明大页(transparent huge pages)**：不需要应用程序修改源代码，OS 会自动根据情况决定是否分配大页。</p>
<h5 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h5><blockquote>
<p>Huge pages are not without their costs. The biggest potential cost is <strong>internal fragmentation</strong>, i.e., a page that is large but sparsely used. This form of waste can fill memory with large but little used pages. <strong>Swapping</strong>, if enabled, also does not work well with huge pages, sometimes greatly amplifying the amount of I/O a system does.</p>
</blockquote>
<ol>
<li><strong>内部碎片</strong>：由于各种内存操作基本都要求按照page对齐，比如一个可执行文件映射到进程地址空间，根据文件大小的不同，平均算下来会浪费掉半个page size的物理内存，使用large page的话这个消耗就显得比较大了。</li>
<li><strong>需要连续大块的物理内存</strong>：系统运行一段时间后，会很难再也大块的连续物理内存，这时分配large page将会变的很困难，所以通常需要在系统初始化的时候就划分出一段物理内存给large page用（类似于DMA的内存分配），这样就减少了一些灵活性。</li>
<li><strong>swap开销大</strong>：动态large page（THP）在换出到外部的flash/disk和从flash/disk换入物理内存的过程会比normal size的page带来更大的开销（可参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/117239320">这篇文章</a>）。</li>
</ol>
<h4 id="Page-Cache-Disk-Cache"><a href="#Page-Cache-Disk-Cache" class="headerlink" title="Page Cache/Disk Cache"></a>Page Cache/Disk Cache</h4><p><a target="_blank" rel="noopener" href="https://www.mazhen.tech/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-page-cache/">深入理解 Page Cache</a></p>
<p><strong>Page Cache</strong> 是由内核管理的内存，位于 <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html">VFS(Virtual File System)</a> 层和具体文件系统层（例如ext4，ext3）之间。应用进程使用 <code>read</code>/<code>write</code> 等文件操作，通过系统调用进入到 <strong>VFS</strong> 层，根据 <strong>O_DIRECT</strong> 标志，可以使用 <strong>Page Cache</strong> 作为文件内容的缓存，也可以跳过 <strong>Page Cache</strong> 不使用内核提供的缓存功能</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/vzb3z8uo.png" alt="vzb3z8uo"></p>
<blockquote>
<p>aggressive caching subsystem to <strong>keep popular data items from persistent storage</strong> in memory</p>
</blockquote>
<ul>
<li><p><strong>Buffered I/O</strong>: IO缓存 (<code>read()</code>, <code>write()</code>) [<code>dentry, inode cache</code>]</p>
</li>
<li><p><strong>Memory-mapped I/O</strong>: 内存映射 mmap()</p>
<ul>
<li><strong>File-backed 文件映射</strong>: 其可以将文件内容映射到用户空间，虚拟内存和磁盘文件中间通过 Page Cache 进行数据中转，因此可以像普通虚拟内存一样访问文件，这些虚拟内存<strong>在磁盘中有对应的文件</strong>，读取这部分内容就像是文件I/O一样</li>
<li><strong>Anonymous Mapping 匿名映射</strong>: mmap以<code>MAP_ANONYMOUS</code>方式申请内存，这些虚拟内存在磁盘中<strong>没有确切的文件，持久化到swap space</strong>，全部初始化为0，</li>
</ul>
</li>
<li><p>通过<code>page_cache_hashtable</code>搜索，加快访问速度。</p>
</li>
</ul>
<h5 id="Memory-mapped-I-O"><a href="#Memory-mapped-I-O" class="headerlink" title="Memory-mapped I/O"></a>Memory-mapped I/O</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/longerzone/article/details/12948925#">Linux 下的两个特殊的文件 – /dev/null 和 /dev/zero 简介及对比_linux空洞文件null-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangle4695/article/details/52139585">Linux 内存映射函数 mmap（）函数详解_mmap fb-CSDN博客</a>  </p>
<ul>
<li><code>void* mmap(void* start, size_t length, int prot, int flags, int fd, off_t offset);</code> </li>
<li><code>int munmap(void* start, size_t length);</code> <ul>
<li><code>prot:</code> 保护位 <code>PROT_EXEC</code>, <code>PROT_READ</code> , <code>PROT_WRITE</code> , <code>PROT_NONE</code></li>
<li><code>flags:</code> <code>MAP_SHARED</code>共享模式 <code>MAP_PRIVATE</code>写时复制，不共享 <code>MAP_ANONYMOUS</code>匿名模式fd无效</li>
<li><code>fd:</code> 文件描述符，如果是匿名模式可以置为<code>-1</code>，或者打开<code>/dev/zero</code>获取其fd</li>
<li><code>offset:</code>文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。</li>
</ul>
</li>
</ul>
<ol>
<li><code>fopen()</code> 系统调用打开文件，并返回描述符 <code>fd</code>。</li>
<li><code>mmap(start,...)</code>建立内存映射并返回映射首地址指针 <code>start</code>参数start可以是空指针，系统自动分配地址</li>
<li>通过对<code>start</code> 对文件进行各种操作，首次访问start指向的内容会触发页错误(demand paging)</li>
<li><code>munmap (start,...)</code> 关闭内存映射</li>
<li><code>fclose(fd)</code> 系统调用关闭文件 <code>fd</code> </li>
</ol>
<img src="https://miro.medium.com/v2/resize:fit:1313/0*DgRx8tGpS1T0St_b.png" alt="img" style="zoom:150%;" />

<p>通过对一个打开的FD调用<code>mmap()</code>，进程能够获得一个指向内存映射区的指针，内存映射区是一个独立区域，因此可以独立释放。通过这个指针就能够对文件进行操作。这里采用了demand paging——<strong>懒加载</strong>的策略，直到第一次访问触发页错误，才会真正把文件内容分配到物理页中。</p>
<p>数据一致性：</p>
<ul>
<li><strong>files</strong>：程序通过 <code>mmap</code> 映射文件时，如果页面未修改（脏位为 <code>0</code>），无需将内存中的数据写回磁盘</li>
<li><strong>Swap space</strong>：当内存不足时，未被修改的页面无需写回磁盘的 Swap space，节省时间和空间</li>
</ul>
<p>即使不显式调用<code>mmap</code>也会使用这个共享的文件映射区域，比如从可执行文件中加载的代码、进程之间共享的库代码</p>
<p>使用<code>pmap</code>分析<code>tcsh</code>进程的虚拟内存映射情况如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Virtual Address  	Size  	Protection  Source</span><br><span class="line">0000000000400000 	372K  	r-x--       tcsh</span><br><span class="line">00000000019d5000 	1780K 	rw---       [anon ]</span><br><span class="line">00007f4e7cf06000 	1792K 	r-x--       libc-2.23.so</span><br><span class="line">00007f4e7d2d0000	36K   	r-x--       libcrypt-2.23.so</span><br><span class="line">00007f4e7d508000	148K  	r-x--       libtinfo.so.5.9</span><br><span class="line">00007f4e7d731000 	152K  	r-x--       ld-2.23.so</span><br><span class="line">00007f4e7d932000 	16K   	rw---       [stack ]</span><br></pre></td></tr></table></figure>

<p>除了<code>tcsh</code>自己的代码，<code>libc, libcrypt, libtinfo</code> 这些共享库代码也被加载到tcsh的虚拟地址空间中，连接器<code>ld</code>的可执行代码也在其中。[anon]表示自己的heap堆空间，[stack]表示自己的stack栈空间</p>
<p>和 <strong>shmem</strong> 的区别：</p>
<p>System V 共享内存是持久的：除非被进程显式删除，否则它会保留在内存中并保持可用，直到系统关闭。 mmap 内存在应用程序的执行之间不是持久的（除非它由文件支持，<code>MAP_SHARED</code>）</p>
<h5 id="Buffered-I-O"><a href="#Buffered-I-O" class="headerlink" title="Buffered I/O"></a>Buffered I/O</h5><p><strong>Buffered I/O</strong> 与 <strong>内存映射文件</strong> 的区别：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/202209241611674.png" alt="d"></p>
<h6 id="读取机制"><a href="#读取机制" class="headerlink" title="读取机制"></a>读取机制</h6><ol>
<li><p><code>int fd = open(file_path)</code></p>
<ul>
<li>fd是内核对打开的文件的编号，通过fd就可以操作文件</li>
</ul>
</li>
<li><p><code>int c = read(fd, buf, 512)</code>  </p>
<ul>
<li>由内核负责将 fd 翻译成 inode+offset</li>
<li>读取inode，如果page cache没有就从磁盘读，然后写入inode到Page cache中</li>
<li>读取对应偏移的block，如果page cache没有就从磁盘读，然后写入block到Page cache中</li>
<li>从内存中的 cached block 复制 512 B 到 buf 中</li>
</ul>
</li>
</ol>
<h6 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h6><p><strong>Write-back (default)</strong> </p>
<p>write back 写回 只对缓存进行操作 read-allocate 先把数据读取到Cache中，再从Cache中读数据</p>
<blockquote>
<p>By default, kernel marks written pages dirty and flushes after a delay:</p>
</blockquote>
<ol>
<li><p><code>int fd = open(&quot;myfile&quot;);</code> </p>
</li>
<li><p><code>write(fd, &quot;hello world&quot;, 11)</code></p>
<ul>
<li>内核将hello world字符串写入到 cached block 对应的 page cache 页中</li>
<li>内核将被修改的页加入脏页列表中</li>
<li>按照一定的策略进行刷盘</li>
</ul>
</li>
</ol>
<p>在系统发生宕机的情况下无法确保数据已经落盘，因此存在数据丢失的问题。不过，在程序挂了，例如被 kill -9，Page Cache 中的数据操作系统还是会确保落盘；</p>
<p><strong>Write-through</strong></p>
<p>直写，在更改page cache的<strong>同时</strong>刷盘(synchoronized)</p>
<blockquote>
<p><strong>O_SYNC</strong> flag converts file descriptor to write-through</p>
</blockquote>
<ul>
<li><code>int fd = open(&quot;myfile&quot;, O_SYNC |...); </code></li>
<li><code>write(fd, &quot;hello world&quot;, 11);</code> <ul>
<li>This affects all accesses to the same disk blocks</li>
</ul>
</li>
</ul>
<p>以牺牲系统 I/O 吞吐量作为代价，向上层应用确保一旦写入，数据就已经落盘，不会丢失</p>
<h5 id="脏页刷盘"><a href="#脏页刷盘" class="headerlink" title="脏页刷盘"></a>脏页刷盘</h5><p>Page cache 追踪脏页，保存一个脏文件inode链表，脏页需要写入到磁盘的文件或者swap space中，确保内存数据的持久化，可以由叫做<code>pdflush</code>的后台线程，唤醒方式有如下</p>
<ul>
<li><p><strong>定期</strong>唤起<code>pdflush</code>，确保不会有脏页驻留时间过长</p>
</li>
<li><p>在脏页比例达到<strong>阈值</strong>时，按照一定速率刷盘（1024）</p>
</li>
<li><p>内存可用空间低到一定<strong>阈值</strong>，刷脏页释放内存</p>
</li>
<li><p>响应特定的系统调用</p>
<ul>
<li><p><code>fsync(int fd)</code> 将fd的脏数据和所有脏元数据刷盘</p>
</li>
<li><p><code>fdatasync(int fd)</code> 将fd的脏数据和必要的脏元数据刷盘</p>
</li>
<li><p><code>sync()</code> 将全部脏页刷盘</p>
</li>
<li><p><code>O_SYNC</code> 文件打开方式要求同步写操作</p>
</li>
</ul>
</li>
</ul>
<p><strong>应用</strong></p>
<ul>
<li><strong>文件映射</strong>：程序通过 <code>mmap</code> 映射文件时，如果页面未修改（脏位为 <code>0</code>），无需将内存中的数据写回磁盘。</li>
<li><strong>交换区</strong>：当内存不足时，未被修改的页面无需写回交换区，节省时间和空间。</li>
</ul>
<h5 id="Direct-I-O"><a href="#Direct-I-O" class="headerlink" title="Direct I/O"></a>Direct I/O</h5><p>Buffered I/O要在磁盘和VFS之间加一层Page cache，对于写入操作，需要在cache中开辟新页，然后将其标记为脏。</p>
<p>OS cache提供的这些预读取、顺序读取等特性，这些特性并不适用于所有的场景，比如数据库，数据库通常都有自己的一套缓存机制，就像mysql的innodb存储引擎，它有自己的缓存页，有自己的落盘机制，如果不使用directIO，这明显就会存在双重的cache，一个是OS设计的，一个是DB设计的，而通常，DB需要更加符合自己使用的cache机制，而非OS提供的通用化的缓存机制。直接写入不会将要写入的数据先从磁盘读到cache，而是直接将要写的数据写入磁盘。</p>
<p>O_DIRECT 下的 I/O 操作是直达磁盘的，用户空间通过 DMA 的方式与磁盘以及网卡进行数据拷贝。</p>
<h4 id="页面置换：2Q"><a href="#页面置换：2Q" class="headerlink" title="页面置换：2Q"></a>页面置换：2Q</h4><p>关键词：<strong>预读失效 + 缓存污染</strong> </p>
<ul>
<li><strong>预读失效：提前加载到内存，但是并没有访问</strong></li>
<li><strong>缓存污染：加载到内存，但是只访问一次</strong></li>
</ul>
<p><strong>LRU</strong>：如果打开一个非常大的文件，LRU会把其他在内存中的文件都淘汰掉，但是写入这个文件到内存中并没有什么用，就和循环访问一样，文件之前的数据在被淘汰掉之前再也被访问。</p>
<p><strong>Linux的2Q(Two queue)策略</strong></p>
<p>该算法类似于LRU-2，不同点在于2Q将LRU-2算法中的访问历史队列（注意这不是缓存数据的）改为一个FIFO缓存队列，即：2Q算法有两个缓存队列，一个是FIFO队列，一个是LRU队列。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/73bc553b295b04f7a2bc634b6bd10ab9.png" alt="img" style="zoom:200%;" />

<p>Linux对于2Q的实现，只淘汰FIFO队列里面的数据：</p>
<p>Page cache（Buffered I/O或mmap）维护两个队列:</p>
<p><code>inactive list(FIFO), active list(LRU)</code> </p>
<ul>
<li>第一次被访问，将页面加入<code>inactive list</code></li>
<li>之后的访问，将页面升至<code>active list</code> </li>
<li>需要进行替换时，<code>inactive list</code>进行FIFO</li>
<li><code>active list</code>对定期 LRU 到<code>inactive list</code>，使<code>active list</code>占 Page cache 的2/3左右。</li>
<li>循环访问大文件时，大文件的页面不会跑到<code>active list</code>中，因此原来<code>active list</code>的页面就不会被迫换出</li>
</ul>
<h4 id="其他策略-1"><a href="#其他策略-1" class="headerlink" title="其他策略"></a>其他策略</h4><ul>
<li><code>fork()</code> 采用COW写时复制的策略，减少无效的复制</li>
<li><code>swapd</code> 可以监控内存状况，内存占用过高（watermark）换出页面，释放到安全水平（异步）</li>
<li><strong>swappiness</strong>：修改换出页面的积极性，0为不主动换出</li>
<li><strong>关闭swap</strong>：服务器内存本身足够大，不需要换出操作，因为会降低效率</li>
<li><strong>内存颠簸（thrashing）</strong> 虚拟内存申请，但是物理内存几乎占满，导致同时出现大量缺页错误，此时linux oom killer会杀死内存密集型，一般这些都是低优先级的，也有一定的风险)</li>
</ul>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>现代操作系统最大的一个特点就是对安全的注重，仅仅使用内核</p>
<h4 id="针对用户程序：缓冲区溢出攻击"><a href="#针对用户程序：缓冲区溢出攻击" class="headerlink" title="针对用户程序：缓冲区溢出攻击"></a>针对用户程序：缓冲区溢出攻击</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">some_function</span><span class="params">(<span class="type">char</span> *input)</span> &#123;</span><br><span class="line">    <span class="type">char</span> dest_buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(dest_buffer, input); <span class="comment">// oops, unbounded copy!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果输入超过缓冲区，input就会开始覆盖其他数据，攻击者可以利用缓冲区溢出注入他们的恶意代码，在页表中引入<code>NX</code>bit能够在一定程度上解决问题，但是黑客可以更改函数的执行栈，将函数的返回值指向恶意代码的地址。</p>
<p>return-to-libc attack:==ROP==</p>
<blockquote>
<p>Thus, an attacker can overwrite the stack such that the <strong>return address in the currently executing function</strong> points to <strong>a desired malicious instruction (or series of instructions)</strong>, followed by a return instruction.</p>
<p>By stringing together a large number of gadgets (i.e., ensuring each return jumps to the next gadget), the attacker can execute arbitrary code. Amazing!</p>
</blockquote>
<p>address space layout randomization:==ASLR==</p>
<blockquote>
<p>Instead of placing code, stack, and the heap <strong>at fixed locations</strong> within the virtual address space, the OS <strong>randomizes their placement</strong>, thus making it quite challenging to craft the intricate code sequence required to implement this class of attacks.</p>
</blockquote>
<p>ASLR可以确保客户的程序只崩溃不执行恶意代码，ASLR将brk、mmap、stack的开始段加一些随机数，</p>
<p>由此衍生出了KASLR，内核的地址空间也可以随机生成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//random.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">stack</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    prompt&gt; ./random</span></span><br><span class="line"><span class="comment">    0x7ffd3e55d2b4</span></span><br><span class="line"><span class="comment">    prompt&gt; ./random</span></span><br><span class="line"><span class="comment">    0x7ffe1033b8f4</span></span><br><span class="line"><span class="comment">    prompt&gt; ./random</span></span><br><span class="line"><span class="comment">    0x7ffe45522e94</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="针对内核程序：Meltdown-amp-Spectre"><a href="#针对内核程序：Meltdown-amp-Spectre" class="headerlink" title="针对内核程序：Meltdown &amp; Spectre"></a>针对内核程序：Meltdown &amp; Spectre</h4><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23973128">CPU 的分支預測器是怎樣工作的？ - 知乎</a> </p>
<p>利用了 CPU 预测执行的漏洞，分支预测将串行的程序变成了并行的，而前后数据依赖，不可避免地在硬件上留下了踪迹，造成了并发安全问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rax byte[x]  ; 非法操作 将x的数据拷贝到rax</span><br><span class="line">shl rax 0xC  ; rax * 4096, 页对齐</span><br><span class="line">mov rbx qword [rbx + rax]  ; [rbx] 为用户空间的一个array，合法操作</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32757727">解读 Meltdown &amp; Spectre CPU 漏洞 - 知乎</a> </p>
<p>操作系统会事先标注好内核的内存地址范围，如果 x 在内核的这个地址范围内，并且 CPU 不是以内核模式运行的话，那么该指令会被 CPU 标注为非法，引起异常，异常处理程序会将 rax 清空为0，并且终结此程序，这样后续指令再来读 rax 的时候就只能读到0了。</p>
<p>理论上讲，在执行第二条指令之前，rax应该已经被清零了。然而在实际的 CPU 运行中，为了达到更好的性能，第二条和第三条指令在异常处理生效之前都会被<strong>部分执行</strong>，直到异常处理时 rax 和 rbx 被清零。</p>
<p>但问题的关键就在第三行指令：<strong>如果地址 rbx + rax 不在cache中的话，CPU 会自动将这一地址调入cache中，以便之后访问时获得更好的性能，然而异常处理并不会将这个cache flush掉。而这条 cache 的地址是和 rax 直接相关的，这样就相当于在 CPU 硬件中留下了和rax 相关的信息。</strong>  </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241214175132236.png" alt="image-20241214175132236"></p>
<p>那么如何还原 rbx + rax 这个被cache的地址呢？这时候需要用到的原理就是利用cache的访问延时，即已经被cache的数据访问时间短，没有被cache的数据访问时间长。由于[rbx]这个array是在用户地址空间内的，可以自由操作，首先我们要确保整个 [rbx]这个array 都是没有被cache的，然后执行上述攻击代码，这时候 rbx + rax 这个地址就已经被cache了，接下来遍历整个[rbx] array，来测量访问时间，访问时间最短的那个 page 就可以确定为 rbx + rax。</p>
<p>对于个人终端用户，利用Meltdown与Spectre漏洞，低权限用户可以访问内核的内容，泄露本地操作系统底层的信息、秘钥信息等，通过获取泄露的信息，可以绕过内核的隔离防护;如果配合其它漏洞，可以利用该漏洞泄露内核模块地址绕过KASLR等防护机制实现其他类型的攻击进行提权。另外，利用浏览器JIT特性预测执行特殊的JIT代码，从而读取整个浏览器内存中的数据，泄露用户帐号，密码，邮箱, cookie等隐私信息。</p>
<p>因此，增强内核保护的一种途径是从每个用户进程中删除尽可能多的内核地址空间，并为大多数内核数据提供单独的内核页表（称为内核页表隔离，或 KPTI）[G+17]。因此，不是将内核的代码和数据结构映射到每个进程中，而是只保留最低限度的代码和数据结构；当切换到内核时，现在需要切换到内核页表。这样做可以提高安全性并避免一些攻击媒介，但代价是：性能。切换页表的成本很高。</p>
<h2 id="内存虚拟化总结"><a href="#内存虚拟化总结" class="headerlink" title="内存虚拟化总结"></a>内存虚拟化总结</h2><ul>
<li><p>虚拟地址的作用</p>
</li>
<li><p>虚拟地址的翻译（重定位）</p>
<ul>
<li>段式 base+bound, bound varies from each other</li>
<li>页式 fixed bound</li>
<li>段页式 </li>
<li>多级页表 fill one page with one table, hi-level table points to low-level table</li>
<li>TLB：翻译缓存</li>
</ul>
</li>
<li><p>Swap：将物理内存看作虚拟内存的缓存</p>
<ul>
<li>机制：Page Fault &amp; Disk I/O </li>
<li>策略：<ul>
<li>是否需要SWAP？物理内存充足就没必要开启</li>
<li>具体换<strong>出</strong>哪一页？LRU, FIFO, Random, Second Chance, LRU-K, 2Q, Clock</li>
<li>何时换<strong>出</strong>？(被动watermark、主动swappiness&gt;0)</li>
<li>一次 I/O 换<strong>出</strong>多少页？(clustering)</li>
<li>何时换<strong>入</strong>？(lazy aka. demand paging)</li>
<li>一次 I/O 只换<strong>入</strong>一页<strong>吗</strong>？(prefetching)</li>
</ul>
</li>
</ul>
</li>
<li><p>内存分配:</p>
<ul>
<li>机制：空闲空间链表节点的分割与合并</li>
<li>物理：Buddy, SLAB</li>
<li>虚拟：mmap malloc brk</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/01/14/408-%E8%AE%A1%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/14/408-%E8%AE%A1%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/" class="post-title-link" itemprop="url">应用层</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-14 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-14T00:00:00+08:00">2025-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-14 15:48:32" itemprop="dateModified" datetime="2025-05-14T15:48:32+08:00">2025-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="域名系统（DNS）"><a href="#域名系统（DNS）" class="headerlink" title="域名系统（DNS）"></a>域名系统（DNS）</h1><p>Domain Name System based on UDP port 53 </p>
<h2 id="域名-名字空间"><a href="#域名-名字空间" class="headerlink" title="域名 名字空间"></a>域名 名字空间</h2><p><strong>层次结构</strong>：………三级域名.二级域名.顶级域名</p>
<p><strong>根</strong>：无名字</p>
<p><strong>顶级域名</strong>：国家、组织</p>
<p><strong>二级域名</strong>（我国）：类别域名、行政区域名</p>
<p>属于不同父亲的孩子节点可以有相同的名称: <a target="_blank" rel="noopener" href="http://www.example.cn/">www.example.cn</a>  <a target="_blank" rel="noopener" href="http://www.example.com/">www.example.com</a> </p>
<h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><p>DNS服务器实际是一个分布式的数据库。主从复制，读写分离，增强可用性。服务器可以采用anycast任播技术，多台服务器使用同一IP地址，路由自动选择最近的服务器。</p>
<p>分类：</p>
<ul>
<li><strong>根域名服务器</strong>（Root）：所有的根域名服务器都知道所有顶级域名服务器的IP地址和域名<ul>
<li>根域名有13个，分布于全球的若干根域名服务器，使用IP anycast技术，每个域名有多个物理实例，但对外展示同一个 IP。</li>
</ul>
</li>
<li><strong>顶级域名服务器</strong>（Top Level Domain）：管辖属于自己的二级域名</li>
<li><strong>权限域名服务器</strong>（Authoriative Name Server）：管辖区内的域名，一个服务器管一个域名，效率比较低，所以采用 <strong>区</strong> 的概念，区是域的子集。</li>
<li><strong>本地域名服务器</strong>：不在上述层次中，但是离客户最近的DNS服务器。</li>
</ul>
<h2 id="DNS-查询顺序"><a href="#DNS-查询顺序" class="headerlink" title="DNS 查询顺序"></a>DNS 查询顺序</h2><h3 id="先查缓存的查询流程"><a href="#先查缓存的查询流程" class="headerlink" title="先查缓存的查询流程"></a>先查缓存的查询流程</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241129143353140.png" alt="image-20241129143353140"></p>
<ol>
<li>浏览器 DNS 缓存：首先，浏览器会检查自己的缓存中是否已经有该域名的IP地址记录。如果有，则直接使用这个IP地址，而不会发起DNS查询</li>
<li>操作系统 DNS 缓存：如果浏览器缓存中没有找到，浏览器会请求操作系统进行DNS解析。操作系统会先检查自己的DNS缓存。大多数现代操作系统都会维护一个 DNS 缓存来存储最近解析过的域名和对应的IP地址</li>
<li>本地 hosts 文件：如果操作系统缓存中也没有找到对应的记录，并且您使用的是Unix-like系统（如Linux或macOS），操作系统会查询本地的/etc/hosts文件。这个文件通常包含静态的IP地址到域名的映射</li>
<li>路由器DNS缓存：我们常用的路由器也带有自动缓存功能，路由器DNS被篡改会造成<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=216036547&content_type=Article&match_order=1&q=%E5%9F%9F%E5%90%8D%E5%8A%AB%E6%8C%81&zhida_source=entity">域名劫持</a>，将访问网址定位到另外一个服务器；</li>
<li>本地DNS服务器（递归查询，本地DNS服务器替主机查询，主机作为DNS客户端向DNS服务器请求服务）：如果/etc/hosts文件中也没有找到，操作系统会向配置的本地DNS服务器发送查询请求。这个本地DNS服务器可能是您的网络服务提供商提供的，或者是您在公司或学校网络中配置的，也具有缓存功能。本地DNS将解析结果告知客户端的同时，将记录缓存下来，当下次请求同一个域名时，直接会将记录返回，而无需再进行全球查询。</li>
<li>根域名服务器（迭代查询，从此开始就是本地DNS服务器反复查询）：如果本地DNS服务器无法解析该域名，它会向根域名服务器发送查询请求。根域名服务器会返回负责顶级域名（如.com）的权威DNS服务器的地址</li>
<li>顶级域名服务器：本地DNS服务器然后会向顶级域名服务器发送查询请求，获取该域名的权威DNS服务器的地址</li>
<li>权威DNS服务器：最后，本地DNS服务器会向权威DNS服务器发送查询请求，获取该域名的IP地址</li>
<li>返回IP地址：一旦本地DNS服务器从权威DNS服务器那里获得了IP地址，它就会将这个IP地址返回给操作系统，操作系统再返回给浏览器。浏览器最后使用这个IP地址来建立与服务器的连接</li>
</ol>
<p>在查询的过程中，一旦在某一环节找到有效的IP地址记录，就会停止后续的查询。而且，为了提高效率，本地DNS服务器和操作系统通常会对查询结果进行缓存，以便在后续请求中直接使用，减少网络延迟</p>
<h3 id="DNS-缓存"><a href="#DNS-缓存" class="headerlink" title="DNS 缓存"></a>DNS 缓存</h3><p>所谓DNS缓存是指DNS返回正确的IP地址之后，系统会将这个结果临时储存起来，并为缓存设定一个失效时间（<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=216036547&content_type=Article&match_order=1&q=TTL%E5%80%BC&zhida_source=entity">TTL值</a>），在TTL失效前，当再次访问这个网站，系统就会直接从<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=216036547&content_type=Article&match_order=1&q=DNS+%E7%BC%93%E5%AD%98&zhida_source=entity">DNS 缓存</a>中将结果返回，而不必再次委托递归服务器进行全球解析查询，加快了<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=216036547&content_type=Article&match_order=4&q=DNS%E8%A7%A3%E6%9E%90&zhida_source=entity">DNS解析</a>的流程。</p>
<p>当然TTL值失效后，系统还会自动再次询问DNS服务器以获取最新的解析结果。</p>
<h4 id="DNS-污染"><a href="#DNS-污染" class="headerlink" title="DNS 污染"></a>DNS 污染</h4><p>在中国大陆，对所有经过<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E9%95%B7%E5%9F%8E">防火长城</a>（英语：Great Firewall，常用简称：GFW）的在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE">UDP</a>的53<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E4%BF%A1%E7%AB%AF%E5%8F%A3">端口</a>上的域名查询进行IDS<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B">入侵检测</a>，一经发现与黑名单关键词相匹配的域名查询请求，会马上伪装成目标解析服务器注入伪造的查询结果。攻击仅出现在DNS查询之路由经过防火长城时。伪造的查询结果中的IP地址不是一成不变的，在一段时间后会更新。</p>
<p>对于TCP协议下的域名查询，防火长城可使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TCP%E9%87%8D%E7%BD%AE%E6%94%BB%E5%87%BB">TCP重置攻击</a>的方法进行干扰。</p>
<blockquote>
<p>重置（reset）是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">传输控制协议</a>（TCP）的一种消息，例如服务器端在没有客户端请求的端口或者其它连接信息不符时，系统的TCP协议栈就会给客户端回复一个重置通知消息，该功能本来用于应对例如服务器意外重启等情况，而防火长城阻止TCP连接的技术实际上就是比连接双方更快地发送连接重置消息，使连接双方以为对方终止了连接[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E9%95%BF%E5%9F%8E#cite_note-clayton2006-66">65]</a>。</p>
</blockquote>
<h1 id="动态主机配置协议（DHCP）"><a href="#动态主机配置协议（DHCP）" class="headerlink" title="动态主机配置协议（DHCP）"></a>动态主机配置协议（DHCP）</h1><p>Dynamic Host Configuration Protocol based on <code>UDP</code> port <code>68</code> for <code>client</code>, <code>67</code> for <code>server</code></p>
<p>采用C/S通信模式，由客户端（DHCP Client）向服务器（DHCP Server）提出配置申请</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241129172615802.png" alt="image-20241129172615802"></p>
<h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/scanf_linux/article/details/89415965#t2">报文格式</a></h2><p><strong>dhcp offer</strong>:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241129175130504.png" alt="image-20241129175130504"></p>
<ul>
<li>Relay Agent 中继</li>
<li>Next Server 其他DHCP服务器</li>
<li>Client MAC Address 之前 Discover含有 客户端的MAC地址</li>
<li>bootp flags unicast 单播</li>
</ul>
<p><strong>dhcp offer:</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241129175445723.png" alt="image-20241129175445723"></p>
<h2 id="分配IP"><a href="#分配IP" class="headerlink" title="分配IP"></a>分配IP</h2><p>  <strong>内网 使用DHCP协议</strong></p>
<ul>
<li><p>首次接入网络的DHCP客户端不知道DHCP服务器的<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/IPv4.html">IP地址</a>，为了学习到DHCP服务器的IP地址，DHCP客户端以广播方式发送<code>DHCP DISCOVER</code>报文（目的IP地址为255.255.255.255）给同一网段内的所有设备（包括DHCP服务器或中继）。<code>DHCP DISCOVER</code>报文中携带了客户端的MAC地址（<a target="_blank" rel="noopener" href="https://support.huawei.com/hedex/pages/EDOC1100087046AZJ0324D/10/EDOC1100087046AZJ0324D/10/resources/dc/dc_cfg_dhcp_6005.html#ZH-CN_CONCEPT_0176371535__c1">chaddr字段</a>）、需要请求的参数列表选项（<a target="_blank" rel="noopener" href="https://support.huawei.com/hedex/pages/EDOC1100087046AZJ0324D/10/EDOC1100087046AZJ0324D/10/resources/dc/dc_cfg_dhcp_6005.html#ZH-CN_CONCEPT_0176371535__op55">Option55</a>）、广播标志位（<a target="_blank" rel="noopener" href="https://support.huawei.com/hedex/pages/EDOC1100087046AZJ0324D/10/EDOC1100087046AZJ0324D/10/resources/dc/dc_cfg_dhcp_6005.html#ZH-CN_CONCEPT_0176371535__f1">flags字段</a>）等信息。源IP 地址0.0.0.0   目的IP:255.255.255.255</p>
</li>
<li><p>某个（可能有多个服务器）DHCP服务器A监听到了DHCP请求，能够<strong>动态</strong>管理自己的IP池，通过<code>DHCP Offer</code>给计算机分配IP地址和默认网关（用于访问外部地址）以及子网掩码和<strong>DNS</strong>、租约信息，注意并不一定要全部提供。源IP为DHCP服务器的IP  目的IP:分配给客户端的IP，里面也有客户端的MAC地址。</p>
</li>
<li><p>设备收到以后会正式提出租用请求，<code>DHCP Request</code>，源IP为0.0.0.0  目的IP:255.255.255.255，==广播==形式可以告诉其他可能存在的DHCP服务器已经向DHCP服务器A提出租用请求，。</p>
</li>
<li><p>路由器收到以后发送<code>DHCP ACK</code>，确认分配并连接成功。源IP为DHCP服务器的IP  目的IP:分配给</p>
</li>
<li><p>客户端收到<code>DHCP ACK</code>报文，会广播发送<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/ARP.html">免费ARP</a>报文，探测本网段是否有其他终端使用服务器分配的IP地址，如果在指定时间内没有收到回应，表示客户端可以使用此地址。如果收到了回应，说明有其他终端使用了此地址，客户端会向服务器发送<code>DHCP DECLINE</code>报文，并重新向服务器请求IP地址，同时，服务器会将此地址列为冲突地址。当服务器没有空闲地址可分配时，再选择冲突地址进行分配，尽量减少分配出去的地址冲突。</p>
</li>
<li><p>设备使用某个IP地址的时间有限，==单播==发送<code>DHCP Request</code>报文进行续约，如果收到<code>DHCP NAK</code>报文说明续租失败；如果到时间如果设备不再续用发送<code>DHCP Release</code>报文进行释放，DHCP服务器会回收，设备收到<code>DHCP</code>。某些设备可能需要为静态的IP，这个可以通过MAC绑定也可以手动配置。</p>
</li>
</ul>
<p><strong>宽带</strong>：</p>
<ul>
<li><p><strong>静态IP</strong>：根据运营商提供的静态IP，子网掩码，网关，DNS手动配置，是固定的IP。</p>
</li>
<li><p><strong>动态DHCP</strong> ：自动从ISP获取IP地址等网络配置信息。</p>
</li>
<li><p><strong>ADSL虚拟拨号</strong> ：使用PPPoE协议向运营商动态租用（PPPoE提供了身份验证功能，也就是宽带账号)。</p>
</li>
</ul>
<h2 id="典型场景"><a href="#典型场景" class="headerlink" title="典型场景"></a>典型场景</h2><ol>
<li><p>路由器从运营商的网络获取一个公网IP地址（通过运营商的DHCP服务器分配）。</p>
</li>
<li><p>路由器在局域网内充当DHCP服务器，为局域网设备分配私有IP地址（如192.168.0.x）。</p>
</li>
</ol>
<h2 id="RARP-协议"><a href="#RARP-协议" class="headerlink" title="RARP 协议"></a>RARP 协议</h2><p>RARP（反向地址转换协议，Reverse Address Resolution Protocol）是局域网的物理机器从网关服务器的ARP表或者缓存上根据MAC地址请求IP地址的协议。它的功能与ARP协议相反。</p>
<ol>
<li><strong>请求IP地址</strong>：当局域网中的某个物理机器只知道自己的MAC地址而不知道IP地址时，它可以通过RARP协议向RARP服务器发送一个请求，请求分配一个IP地址。</li>
<li><strong>服务器响应</strong>：RARP服务器在收到请求后，会查找其RARP列表或ARP表，查找该MAC地址对应的IP地址。如果找到匹配的MAC地址，RARP服务器就会将对应的IP地址发送给请求者。</li>
<li><strong>获取IP地址并通信</strong>：请求者在收到RARP服务器的响应后，就可以利用得到的IP地址进行网络通信。</li>
</ol>
<p><strong>RARP</strong>（Reverse Address Resolution Protocol）和<strong>DHCP</strong>（Dynamic Host Configuration Protocol）是两种网络协议，它们都可以为某个刚接入网络的设备提供IP地址以实现互联通信。区别主要有以下几点：</p>
<ol>
<li>RARP是数据链路层的协议，无法跨路由器和网段工作，每个本地网络都必须配置一台RARP服务器；而DHCP属于应用层协议，可以跨路由器和网段工作，因此多个网段可以共享同一个DHCP服务器。</li>
<li>RARP协议中，必须提前在RAPR服务器中手工配置好MAC地址和IP地址之间的映射；而DHCP允许动态的分配IP，更适应当前网络的需求。</li>
<li>RARP协议仅仅是分配IP地址，而DHCP协议不仅提供IP地址，还提供其他网络配置信息，如子网掩码、网关、DNS服务器</li>
</ol>
<h1 id="万维网（WWW）"><a href="#万维网（WWW）" class="headerlink" title="万维网（WWW）"></a>万维网（WWW）</h1><h2 id="超文本传输协议（HTTP）"><a href="#超文本传输协议（HTTP）" class="headerlink" title="超文本传输协议（HTTP）"></a><a href="https://scatteredream.github.io/2025/05/14/408-%E8%AE%A1%E7%BD%91-HTTP/">超文本传输协议（HTTP）</a></h2><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/http_websocket.html">WebSocket</a></h2><h2 id="内容分发网络（CDN）"><a href="#内容分发网络（CDN）" class="headerlink" title="内容分发网络（CDN）"></a>内容分发网络（CDN）</h2><p><strong>Content Distribution Network</strong></p>
<p><strong>push</strong>： 源服务器将内容推送给CDN</p>
<p><strong>pull</strong>：CDN遇到自己没有的资源就从源服务器pull过来</p>
<p><strong>anycast</strong>: 任播，与DNS服务器类似，很多CDN具有相同的IP地址，可以负载均衡。</p>
<p>CDN所需要的节点数量随着需求而不同，依照所需要服务的对象大小，有可能有数万台服务器。</p>
<p>服务器的运作方式一般是基于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Nginx">nginx</a>的模式，通过HTTP头的Host字段等方式区分服务域名来提供HTTP服务。不过，随着2017年世界各地CDN服务商纷纷推出<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTTPS">HTTPS</a>加速功能，运作方式也变得略有不同，变成了nginx+<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8D%E7%A7%B0%E6%8C%87%E7%A4%BA">SNI</a>模式，同一个CDN节点上可以借此机制绑定多个域名而为不同域名提供HTTPS服务。同时，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/BGP">BGP</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Anycast">anycast</a>技术也逐渐引入了CDN领域中。</p>
<p>P2P CDN(PCDN)：用户自愿以PC或专用设备利用闲置上行带宽充当CDN缓存节点</p>
<h1 id="进程间通信（IPC）"><a href="#进程间通信（IPC）" class="headerlink" title="进程间通信（IPC）"></a>进程间通信（IPC）</h1><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/http_rpc.html">既然有 HTTP 协议，为什么还要有 RPC？</a> </p>
<h1 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h1><h1 id="文件传送协议（FTP）"><a href="#文件传送协议（FTP）" class="headerlink" title="文件传送协议（FTP）"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">文件传送协议（FTP）</a></h1><p><strong>FTP 协议</strong> 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。</p>
<p>FTP 是基于客户—服务器（C/S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。如果我们要基于 FTP 协议开发一个文件传输的软件的话，首先需要搞清楚 FTP 的原理。关于 FTP 的原理，很多书籍上已经描述的非常详细了：</p>
<blockquote>
<p>FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：</p>
<ol>
<li>控制连接：用于传送控制信息（命令和响应）</li>
<li>数据连接：用于数据传送；</li>
</ol>
<p>这种将命令和数据分开传送的思想大大提高了 FTP 的效率。</p>
</blockquote>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ftp.png" alt="FTP工作过程">FTP工作过程</p>
<p>注意 ：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。因此，FTP 传输的文件可能会被窃听或篡改。建议在传输敏感数据时使用更安全的协议，如 SFTP（SSH File Transfer Protocol，一种基于 SSH 协议的安全文件传输协议，用于在网络上安全地传输文件）。</p>
<h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><h2 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E7%9B%B8%E5%85%B3_RFC">SMTP</a></h2><p><strong>简单邮件传输(发送)协议（SMTP，Simple Mail Transfer Protocol）</strong> 基于 TCP 协议，是一种用于发送电子邮件的协议</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/what-is-smtp.png" alt="SMTP 协议">SMTP 协议</p>
<p>注意 ⚠️：<strong>接受邮件的协议不是 SMTP 而是 POP3 协议。</strong></p>
<p>SMTP 协议这块涉及的内容比较多，下面这两个问题比较重要：</p>
<ol>
<li>电子邮件的发送过程</li>
<li>如何判断邮箱是真正存在的？</li>
</ol>
<p><strong>电子邮件的发送过程？</strong></p>
<p>比如我的邮箱是“<a href="mailto:dabai@cszhinan.com">dabai@cszhinan.com</a>”，我要向“<a href="mailto:xiaoma@qq.com">xiaoma@qq.com</a>”发送邮件，整个过程可以简单分为下面几步：</p>
<ol>
<li>通过 <strong>SMTP</strong> 协议，我将我写好的邮件交给 163 邮箱服务器（邮局）。</li>
<li>163 邮箱服务器发现我发送的邮箱是 qq 邮箱，然后它使用 SMTP 协议将我的邮件转发到 qq 邮箱服务器。</li>
<li>qq 邮箱服务器接收邮件之后就通知邮箱为“<a href="mailto:xiaoma@qq.com">xiaoma@qq.com</a>”的用户来收邮件，然后用户就通过 <strong>POP3/IMAP</strong> 协议将邮件取出。</li>
</ol>
<p><strong>如何判断邮箱是真正存在的？</strong></p>
<p>很多场景(比如邮件营销)下面我们需要判断我们要发送的邮箱地址是否真的存在，这个时候我们可以利用 SMTP 协议来检测：</p>
<ol>
<li>查找邮箱域名对应的 SMTP 服务器地址</li>
<li>尝试与服务器建立连接</li>
<li>连接成功后尝试向需要验证的邮箱发送邮件</li>
<li>根据返回结果判定邮箱地址的真实性</li>
</ol>
<p>推荐几个在线邮箱是否有效检测工具：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://verify-email.org/">https://verify-email.org/</a></li>
<li><a target="_blank" rel="noopener" href="http://tool.chacuo.net/mailverify">http://tool.chacuo.net/mailverify</a></li>
<li><a target="_blank" rel="noopener" href="https://www.emailcamel.com/">https://www.emailcamel.com/</a></li>
</ol>
<h2 id="IMAP-POP3"><a href="#IMAP-POP3" class="headerlink" title="IMAP/POP3"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E4%BF%A1%E6%81%AF%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE">IMAP</a>/<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%83%B5%E5%B1%80%E5%8D%94%E5%AE%9A">POP3</a></h2><p>这两个协议没必要多做阐述，只需要了解 <strong>POP3 和 IMAP 两者都是负责邮件接收的协议</strong> 即可（二者也是基于 TCP 协议）。另外，需要注意不要将这两者和 SMTP 协议搞混淆了。<strong>SMTP 协议只负责邮件的发送，真正负责接收的协议是 POP3/IMAP。</strong></p>
<p>IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。</p>
<h2 id="E-mail-on-WWW"><a href="#E-mail-on-WWW" class="headerlink" title="E-mail on WWW"></a>E-mail on WWW</h2><h2 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B">MIME</a>改善了由 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc822">RFC 822</a> 转变而来的 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2822">RFC 2822</a> ，这些旧标准规定<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E9%83%B5%E4%BB%B6">电子邮件</a>标准并不允许在邮件消息中使用7位ASCII字符集以外的字符。正因如此，一些非英语字符消息和二进制文件，图像，声音等非文字消息原本都不能在电子邮件中传输（MIME可以）。MIME规定了用于表示各种各样的数据类型的符号化方法。此外，在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91">万维网</a>中使用的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTTP">HTTP协议</a>中也使用了MIME的框架，标准被扩展为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B">互联网媒体形式</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: [type]/[subtype]; parameter</span><br></pre></td></tr></table></figure>

<h1 id="Telnet-amp-SSH"><a href="#Telnet-amp-SSH" class="headerlink" title="Telnet &amp; SSH"></a>Telnet &amp; SSH</h1><p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Telnet">Telnet</a> 协议</strong> 基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Telnet_is_vulnerable_to_eavesdropping-2.png" alt="Telnet:远程登陆协议"></p>
<p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Secure_Shell">SSH</a> （Secure Shell）</strong> 基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13P4y1o76u">SSH 握手详解 - bilibili 技术蛋老师</a> </p>
<p>SSH 的经典用途是登录到远程电脑中执行命令。除此之外，SSH 也支持隧道协议、端口映射和 X11 连接（允许用户在本地运行远程服务器上的图形应用程序）。借助 SFTP（SSH File Transfer Protocol） 或 SCP（Secure Copy Protocol） 协议，SSH 还可以安全传输文件。</p>
<p>SSH 使用客户端-服务器模型，默认端口是 22。SSH 是一个守护进程，负责实时监听客户端请求，并进行处理。大多数现代操作系统都提供了 SSH。</p>
<p>如下图所示，SSH Client（SSH 客户端）和 SSH Server（SSH 服务器）通过公钥交换生成共享的对称加密密钥，用于后续的加密通信。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ssh-client-server.png" alt="SSH:安全的网络传输协议"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/01/13/iot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/13/iot/" class="post-title-link" itemprop="url">物联网就业</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-13 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-13T00:00:00+08:00">2025-01-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-03 22:46:01" itemprop="dateModified" datetime="2025-05-03T22:46:01+08:00">2025-05-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="物联网"><a href="#物联网" class="headerlink" title="物联网"></a>物联网</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/331782286">物联网专业好就业吗？ - 知乎 (zhihu.com)</a></li>
</ul>
<p>物联网行业很有前景，但不代表<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%89%A9%E8%81%94%E7%BD%91%E4%B8%93%E4%B8%9A&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2767766898%7D">物联网专业</a>好，两者不是一码事。</p>
<p>从实际情况看，物联网不应该也没办法成为一个具体的专业。</p>
<p>物联网涵盖的内容太多，许多大学在本科开设物联网专业确实有点坑。</p>
<p>物联网和人工智能和金融很像，没有具体的、统一的概念，没有具体的指向。就像一个金融业人士自我介绍，如果是对非业内人士一般就说我是做金融的，对业内人士一般会说我是做量化的、做风头的、做<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%A7%81%E5%8B%9F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%223041148568%22%7D">私募</a>的、做基金的、做行研的、做柜员的、做大堂经理、做理财的、做风控的……</p>
<p>人工智能也是这样，对非业内人士一般就说我是做人工智能的的，对业内人士一般会说做<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2767766898%7D">算法优化</a>、做<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%BF%90%E7%AD%B9%E6%8E%A7%E5%88%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2632452604%7D">运筹控制</a>、做计算机<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2915052959%7D">神经网络</a>、做<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2632452604%7D">自然语言处理</a>（比如语言识别、自动翻译）、做机器学习（深度学习）、做<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BD%B1%E5%83%8F%E5%AD%A6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2632452604%7D">计算机影像学</a>（比如人脸、虹膜和指纹识别）……</p>
<p>物联网也是如此，对非业内人士一般就说我是做物联网的，对业内人士一般会说做<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2767766898%7D">嵌入式开发</a>、做信号处理、做传感技术、做<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2767766898%7D">网络技术</a>、做RFID技术……</p>
<p>所以物联网能包含的范围太大，而且作为一项新兴科技是不断变化和延伸的，根本不是固有的、静态的。以上任何一个方向、岗位都是博大精深探索无止境的，跟很多岗位都是有密切关系的，很多专业都可以从事的。</p>
<p>所以这些工作根本不是你学了物联网就可以做的，学物联网和做物联网是两码事，学很多专业都可以做物联网，学物联网的反而因为学的多而杂不知道怎么定位自己了。比如你学<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%94%B5%E5%AD%90%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2632452604%7D">电子科学与技术</a>、<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2632452604%7D">电子信息科学与技术</a>、<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2632452604%7D">网络工程</a>、嵌入式开发、<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BF%A1%E6%81%AF%E5%B7%A5%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2915052959%7D">信息工程</a>（信息技术）、<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E5%B7%A5%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2915052959%7D">电子信息工程</a>、电波传导和天线、<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%94%B5%E7%A3%81%E5%9C%BA%E4%B8%8E%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2632452604%7D">电磁场与无线技术</a>、自动化都可以从事物联网相关工作，毕竟物联网的范围太大了，涉及的专业、行业、岗位、工种太多了。</p>
<p>一些儿可行性建议：</p>
<p><strong>1.明确正确的技术观</strong>，物联网是一个行业，而不是一个专业。学好物联网里任何一项技术，都可以独当一面，迅速实现个人<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BB%B7%E5%80%BC%E7%A7%AF%E7%B4%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3024228794%7D">价值积累</a>。如果贪多贪快，除了给自己带来无尽的失望和打击，没什么好处。</p>
<p><strong>2.明确正确的发展方向</strong>，物联网涉及软硬件、互联网、App等多个领域，作为个人而言，只可能精其一样。如果是做硬件，那就好好学数电模电、<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%BA%94%E7%94%A8%E7%94%B5%E8%B7%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3024228794%7D">应用电路</a>、布线画板、传感器特性等等。如果是做软件，明确方向，一般建议本科阶段学好<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%8D%95%E7%89%87%E6%9C%BA&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2915052959%7D">单片机</a>编程、熟悉一两种传感器或应用，做一两款小产品即可。毕业后，可逐步过渡，学会和其他工程师配合，学会<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%BB%84%E7%BD%91&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3024228794%7D">组网</a>应用，多出作品练手。</p>
<p><strong>3.实践大于理论</strong>，学物联网或者嵌入式一定要勤上手，多出作品。多出作品，不仅可以增长技术能力、了解物联网构架，最重要的是可以提高自信心。人与人的区别，大部分都在教育，而教育成功与否，自信是非常重要的评估法则。当然，由于物联网一般都是系统产品，建议学习者可以基于成熟的构架去做产品，这样容易成功做出完整产品。</p>
<p><strong>4.毕业后，尽量不要去初创公司</strong>，一定要去中型企业或大企业的核心团队，哪怕打杂都行。无论未来是打算做市场还是做技术，一定要记得毕业招工作的时候，要想办法进企业的核心研发团队，大公司进不了，就进小一点的，再进不了，就再小一点。可能有人会问，人家不一定要我啊。对，人家不一定要你，你本科期间作出的物联网作品，就是敲门砖。</p>
<p><strong>5. 就业后，不要急于成功，闷下心思，跟着团队技术带头人做技术</strong>。有什么做什么，尽多培养不同领域的应用，多结实靠谱的技术朋友。三五年后，某一天，你会发现你自己有技术、有团队，可以做任何产品的时候，你的路也会宽阔起来。</p>
<p>人才有两种，一种是<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%BA%94%E7%94%A8%E5%9E%8B%E4%BA%BA%E6%89%8D&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2767766898%7D">应用型人才</a>，把各种技术结合起来，组装成一样东西解决某个问题：例如硬件方面，第一境界是使用各种模块接线；第二境界是使用万用板自己焊接；第三境界是自己画电路图和PCB图打板；软件方面，第一境界，抄别人的代码；第二境界，移植别人的代码然后修改；第三境界，调用库的代码，如果没有就抄；第四境界，熟知各种库的API，自己写代码；应用型人才找工作是最方便的，大公司小公司都会要，只要老板请你做并你愿意做，就会给你开工资。</p>
<p>第二种是是理论型人才，理论知识非常强，数学非常棒，使用<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2767766898%7D">仿真软件</a>验证了一遍，还会拿纸和笔自己再算一遍。一般这样人才不是考研就是去国企等大型企业或<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%A0%94%E7%A9%B6%E6%89%80&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2915052959%7D">研究所</a>从事理论性非常强的工作，比如算法、 <a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E9%AB%98%E9%A2%91%E7%94%B5%E8%B7%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3019505700%7D">高频电路</a>、芯片研发、<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2632452604%7D">信号处理</a>等。</p>
<p>物联网的真正技术，大学是学不完的，它是一个庞大的体系，研究生的话会细分方向，让你更加清晰自己在做什么。大学学习的大多数理论知识，一定要私下多多学点儿东西，没有坏处。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/551003511">物联网工程以后就业前景怎么样? - 知乎 (zhihu.com)</a></li>
</ul>
<p>就业前景很好，跟计算机专业的就业前景差不多。</p>
<p>可以从事纯硬件工作，比如画PCB电路板，画<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%8E%9F%E7%90%86%E5%9B%BE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%222654139657%22%7D">原理图</a>等。可以从事纯软件工作，比如做网页，做APP等。还可以从事嵌入式行业，嵌入式行业分类很多，我所熟悉的是<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%222654139657%22%7D">嵌入式软件工程师</a>，该类工程师不仅需要懂硬件原理图，还需要会编程，编写程序来操作硬件。</p>
<p>总之，选<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%89%A9%E8%81%94%E7%BD%91%E5%B7%A5%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%222654139657%22%7D">物联网工程</a>专业，可以从事的行业很多，并不用害怕找不到工作。希望对题主有所帮助。</p>
<p>其实一个行业的前景不代表个人的前景，一个人在这个行业里面发展的怎么样，能走多远看的是个人能力和付出了多少努力。</p>
<p>但是物联网这个领域本身还是可以的，现在万物互联，发展肯定是可以的。</p>
<p>唯一的问题是大学里面学的知识比较乱，也比较基础，加上物联网的市场需求还没有那么高，所以在找工作的时候机会少一些。</p>
<p>物联网也算是计算机的相关专业，你可以选择一门编程语言深入学习之后就业的。</p>
<p>这么跟你说吧，物联网是一个行业不是一个专业，是行业就有很多岗位，所以物联网找工作不上不下的，软件有软工，硬件有电气，学的东西太杂乱，好像什么都会一点，但多数企业要的是一个方面专精的，如果真想读物联网一定要大一就确定一门语言去学精他，真不好找工作</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/64290050">各位前辈，请问一下为什么有的人说物联网工程是个坑，学的杂而不精，然而它的就业平均薪酬还那么高呢？ - 知乎 (zhihu.com)</a></li>
</ul>
<p>简答：物联网工程是坑，行业平均薪资也确实有竞争力</p>
<p>原因：物联网工程其实也属于工程技术，只是它属于近代技术广泛应用，你去学这个。</p>
<p>打个比方你要搞特斯拉，其实这玩意并没有啥高精尖的技术，大部分还是原来传统车积累下来的。真正变更的是类似特斯拉自动驾驶以及电池管理技术：对比物联网中云技术以及射频技术。</p>
<p>如果你在物联网行业，并没有负责核心技术抑或不能有独特竞争力，那么与其他行业没有太多变化。只是公司如果发展好，你的待遇可能会跟上。</p>
<p>现在物联网行业比传统企业待遇个人觉得是会好一点，因为缺口稍微大一点。毕竟搞智能硬件的需要一批新人才，也比传统硬件复杂一点。</p>
<p>而且物联网技术人员是跟互联网大厂抢人，能搞云架构，云安全，语音，嵌入式，前后端这些哪些不是本来就高待遇。</p>
<p>认清物联网本质，这个问题就好理解了。</p>
<p>谢邀，15年某211物联网毕业生，女生，同班同学，包括上一届学长学姐，没有说哪个毕业后是以物联网相关岗位进去工作的，要么硬件工程师要么软件，只要有一项精通的，进去做技术之后再慢慢转，而且国内大部分都是打着物联网的旗号该干嘛还是干嘛，真正做的好的就是小米智能家居，据我所知，没有应届生能进得去，都是个行业的大牛，加油吧</p>
<p>大四二本物联网工程在读，这就是个通信软硬件杂交专业，还是不建议你选择这个专业，目前我们班44人就业选择：Java、C++、前端、测试、运维、嵌入式、大数据、Android，射频工程师，你可以看出就业方向五花八门，但都是互联网计算机岗位，所以薪资还是不错的。这个专业怎么说呢。你只要不是太划水。懂点物联网知识，对于你找你自己选择的方向很有帮助。因为物联网工程归根究底还是属于工科计算机学科，算科班。我自己是选择了Java，拿了3，4个工业软件和物联网方向公司的Java offer</p>
<p>16年电子信息工程专业学生，19年开始北漂，目前在做数字智能化的相关业务。</p>
<p>当时我们的系叫做计算机科学与技术专业，然后分三个通信工程，物联网，和电信。然后上了半学期大家觉得都挺坑的，课程很难且不专一，一开始我认为我是一个很喜欢创造的人，我想借此学习很多知识然后去做一个什么事情，但是我被这一堆课程以及每周日一整天的实验课给干趴下了，到大三还有实验课。然后成绩一般，也少了跟老师做项目的机会，我记得当时系里面有一个电脑鼠竞速比赛的项目，就是一个电子老鼠跑迷宫。算是国际上相对知名的智能电子开发的比赛了。然后很多同学都参与了一开始学校的内选，但是物联的队伍就很突出。</p>
<p>他们的队伍有几个特点，你问的所谓杂而不精，其实在大多数时候，杂与精的距离没那么远，而且一个团队大家可以相互配合，你清楚所有的链路之后就可以衔接各位在各方面有突出的队员去实现一个目标。</p>
<p>而且真正在毕业之后还在做这一行的同学，他们的薪酬影响因素根本就不是专业什么的，就他们的技术能力，对于技术开发的热情，学校时期就一屁股的参赛奖项，他的工资就低不了，老板太清楚什么事人才了。</p>
<p>这些长期坚持的兄弟要么之后自己创业搞个小队伍自己创造去了，要么一早靠着奖项进大厂深造去了，去其他厂的时候面试的时候知识面也足够应对大多数问题了，凭啥薪资不高。</p>
<p>我一开始去干市场，干媒体，最后回到这个行业做解决方案的时候，才后悔，当初要是认真学点技术，现在焊面包板一定比写PPT有趣多了。</p>
<p>选专业什么的不用想那么多，如果奔着薪资去的，那努力就好。</p>
<p>各位学弟，看看up“01星球”的吧，没必要焦虑具体的专业是什么，尽管学习内容有偏差，说实话，计算机类包括计科和互联网在内的许多细分专业，但大学的课都比较水（名校除外），其核心是围绕计算机4大件展开的，只不过有些具体的专业内容更深入（比如计科要学硬件，软件工程主要是软件，很少设计到硬件，除非以后你去人家公司做别的复杂点的项目)，其实本科选什么专业差别对你以后所想去的具体岗位影响不大，关键是看你们在学校有没有好好“自学”（尽早出去实习给自己接触社会的机会）.好好学习热爱技术，把技术学精湛，管你什么专业，只要你给企业带来价值，走什么技术岗位人家都要你的</p>
<p>后端springboot springcloud netty，数据库Redis MySQL influxdb，运维docker Jenkins，嵌入式 rtthread stm32， 4g模组 蓝牙WiFi模组，电源设计，还能画下原理图和pcb，阁下又如何应对呢？</p>
<p>真正在班上拔尖的同学，参加比赛，研究代码年年拿奖学金。软硬件虽说不特别牛逼，但是做项目刚刚好，学完Linux环境编译，<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2630753191%7D">多线程</a>。真的，每次做成功一个属于自己的项目真的特别开心。特别是在硬件和软件结合起来用。</p>
<p>真正看的还是自学能力，难道到了计科就完美了吗，不计科还要拉跨，我有接触过计科的教学大纲和她们也有朋友，毕竟之前还是一个宿舍，换校区就不是了。计科也要学硬件和软件。我们的大纲还重合了很多，只是在某些硬件上更加仔细。<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%89%A9%E7%90%86%E7%BD%91&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2630753191%7D">物理网</a>工程的话，因为要上云服务，所以还要学习Java，Javaweb，Python。不做网页，所以这些不用特别专业。更加注重是<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%BC%80%E5%8F%91%E7%89%88&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2630753191%7D">开发版</a>驱动和传感器方面，是我们核心专业课。还有物联网控制技术，各种组网ZIgbee，wife，蓝牙，也是重点。</p>
<p>往下阅读之前，先问问自己，BATD四大厂，工农建交四大行，快手华为爱奇艺，京东网易拼夕夕，还有哔哩哔哩和滴滴……这些大厂都投完简历了么？</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/01/06/408-OS-Boot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/06/408-OS-Boot/" class="post-title-link" itemprop="url">操作系统启动 CPU模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-06 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-06T00:00:00+08:00">2025-01-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-22 19:07:17" itemprop="dateModified" datetime="2025-05-22T19:07:17+08:00">2025-05-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Operating-Modes"><a href="#Operating-Modes" class="headerlink" title="Operating Modes"></a>Operating Modes</h1><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241219213730449.png" alt="image-20241219213730449"></p>
<ul>
<li>x86-64 架构的处理器正常工作在 <u>Long Mode</u>，支持 64 位 OS/UEFI，有两个子模式<ul>
<li><u>64-bit Mode</u>: 只能运行 64 位软件，32 位软件需要重新编译</li>
<li><u>Compatibility Mode</u>: 兼容 32 位和 16 位保护模式软件，不支持实模式/虚拟86</li>
</ul>
</li>
<li>IA-32 或 x86 架构的处理器(i286后)正常工作在 <u>Protected Mode</u>，支持 32 位 OS/UEFI<ul>
<li><u>Protected Mode</u>: 支持运行 32 位 和 16 位保护模式的软件</li>
<li><u>Virtual 8086 Mode</u>: 类似 Compatibility Mode，可直接向下兼容运行 real mode 软件</li>
</ul>
</li>
<li>8086 处理器的 <u>Real Mode</u>，最高支持 16 位的操作系统，只能运行实模式软件</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220141424897.png" alt="image-20241220141424897"></p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/80186">80186</a> 和早期的 CPU 仅仅只有一种操作模式，也就是相当于后来芯片的这种 Real Mode；</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/80286">80286</a> 和之后的 x86 CPU 都是以 Real Mode 开机，然后经过 BIOS/UEFI, Bootloader 等引导程序切换到 Protected Mode 或 Long Mode，以便运行 32 或 64 位的操作系统。</p>
</li>
<li><p>启动操作系统之后，通常是在对应模式下运行，如果要运行向前兼容的程序只能使用子模式，切换模式需要重新初始化 CPU 代价太大</p>
</li>
</ul>
<h2 id="Real-Mode：实模式"><a href="#Real-Mode：实模式" class="headerlink" title="Real Mode：实模式"></a>Real Mode：实模式</h2><p>80286 以前：</p>
<p><strong>Intel 80186</strong>是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Intel">Intel</a>针对<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E4%B8%9A%E6%8E%A7%E5%88%B6">工业控制</a>／<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E4%BF%A1">通信</a>等嵌入式市场，于1982年推出的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/8086">8086</a>处理器的扩展产品，除8086内核，另外包括了中断控制器、定时器、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%8E%A5%E8%A8%98%E6%86%B6%E9%AB%94%E5%AD%98%E5%8F%96">DMA</a>、I/O、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/UART">UART</a>、片选电路等外设。</p>
<p><strong>实模式</strong>，Real mode[Real-Address Mode]，是Intel <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/80286">80286</a>和之后的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X86">x86</a>兼容<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CPU">CPU</a>的操作模式。实模式的特性是20位寻址空间，最大寻址空间1MB，最大分段64KB，可以直接软件访问<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/BIOS">BIOS</a>以及周边硬件，没有任何硬件等级的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6%E9%AB%94%E4%BF%9D%E8%AD%B7">保护</a>观念或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%B7%A5">多任务</a>支持。所有的80286系列和之后的x86 CPU都是以实模式下开机；<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/80186">80186</a>和早期的CPU仅仅只有一种操作模式，也就是相当于后来芯片的这种实模式。CPU <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%8D%E4%BD%8D/6156307?fromModule=lemma_inlink">复位</a>（reset）或加电（power on）的时候以实模式启动。</p>
<p>实模式出现于早期 8088 CPU 时期。当时由于 CPU 的性能有限，一共有 20 位<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=8464187&content_type=Article&match_order=1&q=%E5%9C%B0%E5%9D%80%E7%BA%BF&zhida_source=entity">地址线</a>（所以地址空间只有1MB），以及 8 个 16 位的通用寄存器，以及 4 个 16 位的段寄存器。16 位寄存器只能支持64KB的线性地址空间，需要使用另外一个寄存器配合才能利用所有的地址线，因此这种管理内存的方式称为<strong>段式管理</strong>（segmentation）由于 80286 以前只有实模式一种，当时并不叫实模式，286 以后出现保护模式才给以前这个模式取名叫实模式，而硬件上有一定改进，因此 8086 和 80286 的实模式还有有一些细微区别的。详见A20 Gate</p>
<h3 id="x86-寄存器"><a href="#x86-寄存器" class="headerlink" title="x86 寄存器"></a>x86 寄存器</h3><p>图中绿色标记为 8086 的 4 个段寄存器，还有剩下的 16 位寄存器</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241221225031752.png" alt="image-20241221225031752"></p>
<ul>
<li>4 个段寄存器 <strong>CS</strong>、<strong>SS</strong>、<strong>DS</strong> 和 <strong>ES</strong>，用来描述特定段的基址，不能混用，都是 16 位；</li>
<li>1 个指令指针寄存器 <strong>IP</strong> ， 用于和 CS 组成 <strong>CS:IP</strong> 逻辑地址，指向下一条要执行的指令，16 位；</li>
<li>8 个通用寄存器，其中 <strong>SP</strong> 一般固定用于保存堆栈指针，其他可以任意混用，16 位；</li>
<li>1 个程序状态字 <strong>FLAGS</strong>(<strong>PSW</strong>, Program Status Word) 16 位，保存当前程序执行的一些状态和结果的某些信息</li>
</ul>
<h3 id="分段（80286-之前）"><a href="#分段（80286-之前）" class="headerlink" title="分段（80286 之前）"></a>分段（80286 之前）</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/20131020015240765.jpeg" alt="img"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220001927471.png" alt="image-20241220001927471"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220141646817.png" alt="image-20241220141646817"></p>
<p>当某个指令想要访问某个内存地址时，它通常需要用下面的这种格式来表示：(段基址：段偏移量) </p>
<ul>
<li><p>段基址：它的值是由<strong>段寄存器</strong>提供的(一般来说，段寄存器有6种，分别为cs，ds，ss，es，fs，gs，这几种段寄存器都有自己的特殊意义，这里不做介绍)</p>
<ul>
<li>段寄存器除了有 16 位的可见部分，还有不可见的隐藏部分：描述符缓存“descriptor cache”或隐藏寄存器“shadow register” 当一个段选择子装入段寄存器的可见部分，处理器同时也把它指向的段表内容缓存cache中，避免在翻译逻辑地址时花费额外的开销去访问段表。处理器指令中可以明示使用哪些段寄存器，这将替换掉默认使用的段寄存器。</li>
</ul>
</li>
<li><p>段内偏移量：代表你要访问的这个内存地址距离这个段基址的偏移。它的值由<strong>通用数据寄存器</strong>来提供的，所以也是 16 位。那么两个 16 位的值如何组合成一个20位的地址呢？CPU采用的方式是把段寄存器所提供的段基址先向左移4位。这样就变成了一个20位的值，然后再与段偏移量相加。段偏移量16位，因此最大分段为 64 KB</p>
</li>
<li><p><code>物理地址 = 段基址 &lt;&lt; 4 位 + 段内偏移</code> </p>
<ul>
<li>段寄存器是0xff00，段偏移量为0x0110，物理地址 0xff00&lt;&lt;4 + 0x0110 = 0xff110</li>
</ul>
</li>
</ul>
<p>实模式的”实”更多地体现在其地址是<strong>真实的物理地址</strong>(Real-Address Mode)</p>
<p>段基址 + 偏移，Segmentation 分段的雏形，逻辑地址</p>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>由于程序可以任意修改当前的 CS/DS 值，所有程序可以使用全部  1 MB 的内存，所以这个CPU几乎没有办法有效地支持多任务，因为两个程序一起运行的话很容易互相踩到内存。所以当时的使用的方式系统中同时运行的只有一个应用程序和一个DOS操作系统。操作系统和应用规定了各自能使用的内存地址范围，比如说DOS只使用高 64KB 的内存，其它的内存给应用程序使用。这样就可以互不影响。要想运行另一个应用程序必须先退出当前运行的应用程序。</p>
<h3 id="A20-Gate"><a href="#A20-Gate" class="headerlink" title="A20 Gate"></a>A20 Gate</h3><p>在 8086 时代使用CS&lt;&lt; 4 + IP计算物理地址， 从理论上讲，最大可以表示的数值是 0xFFFF0 + 0xFFFF = 0x10FFEF，即大约1M+64KB-16B,然而由于当时的地址线只有 20 根（A0~A19)，这个地址最前面的1无法被表示，当CS=0xFFFF时，实际访问的地址0x10FFEF就变成了0xFFEF，这也导致当时程序编写者为了适应这个问题使用了特殊的技巧。到了80286，地址线变成24位，此时0x10FFEF可以访问到了。为了兼容性考虑，由A20 Gate来控制第21根地址总线的开关。能够在实模式下增加了对额外 65,520 字节（64 KB - 16 字节）内存的访问，而无需进行重大软件更改。</p>
<ul>
<li>开关打开：实模式能访问10000-10FFEF的高地址</li>
<li>开关关闭：实模式无法访问10000-10FFEF，保护模式只能访问 0到1M，2M到3M，寻址空间减少一半。</li>
</ul>
<p>另外实模式和8086还有中断向量的区别，详见虚拟 86 模式</p>
<h2 id="Protected-Mode：保护模式"><a href="#Protected-Mode：保护模式" class="headerlink" title="Protected Mode：保护模式"></a>Protected Mode：保护模式</h2><p>80286 到 80386 开始：<br><strong>保护模式</strong>，Protected Mode，内存保护模式，寻址采用32位段和偏移量，最大寻址空间为4GB，最大分段4GB 。保护模式拥有内存保护，分页系统，以及硬件支持的虚拟内存等功能，支持抢占式多任务调度，CPU 特权模式。在保护模式下，进行寻址时，段寄存器值不再被简单的解析为段基址，而是全局/局部描述符表（GDT/LDT）的索引，也即是所谓的段选择子。</p>
<p>80286 开始支持保护模式，但是寄存器仍然是 16 位，属于 16 位的保护模式。</p>
<p>80386 以后，CPU 寄存器变成 32 位，IA-32 的保护模式寻址发生了一定变化: 地址线的个数从原来的20根变为现在的32根，所以可以访问的内存空间也从 1 MB 变为 4 GB。实模式下的内存地址计算方式就已经不再适合了。</p>
<h3 id="80286-保护模式-16-bit"><a href="#80286-保护模式-16-bit" class="headerlink" title="80286 保护模式(16-bit)"></a>80286 保护模式(16-bit)</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/080810-protected-286-segments.png" alt="undefined"></p>
<h4 id="80286-新特性"><a href="#80286-新特性" class="headerlink" title="80286 新特性"></a>80286 新特性</h4><ul>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/80286">Intel 80286</a> 的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E7%B8%BD%E7%B7%9A">地址总线</a>增加到 24 位，物理最大可寻址空间为 2^24^（即16 MB）</p>
</li>
<li><p>寄存器：</p>
<ul>
<li><p>通用寄存器的位数仍为 16 位，只能使用段式管理，增加了保护模式通过段表间接访存</p>
</li>
<li><p>引入了 机器状态字 <strong>MSW</strong>(Machine Status Word)寄存器用来控制处理器整体的状态，比如保护模式与实模式的切换</p>
</li>
<li><p>引入 <strong>GDTR</strong> <strong>LDTR</strong> <strong>IDTR</strong> <strong>TR</strong>，工作在保护模式，为分段服务，是多任务实现的基础</p>
</li>
</ul>
</li>
<li><p>80286 保护模式下的应用程序能访问的内存<strong>线性地址空间仅为 64 KB</strong>，非常有限。所以程序员编写使用大内存的应用程序时还必须使用远指针、近指针，相当繁琐。这影响了 80286 保护模式的推广使用。</p>
</li>
</ul>
<h4 id="x86-分段"><a href="#x86-分段" class="headerlink" title="x86 分段"></a>x86 分段</h4><h5 id="Descriptor-Table：描述符表"><a href="#Descriptor-Table：描述符表" class="headerlink" title="Descriptor Table：描述符表"></a>Descriptor Table：描述符表</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220142126857-1734679595859-13-1734679601817-15.png" alt="image-20241220142126857"></p>
<p>在80286中，CS/DS/ES/FS寄存器存储的内容变成了选择子。使用段表管理之后，CPU 使用的就是逻辑地址（段选择子+偏移量），经过段表翻译才能有实际物理地址，而段描述符表只有系统内核才能修改。这就保证了一个进程只能访问内核分配给他的段上的物理内存。寻址时，依然是 base and bound 的思想，只不过要先去段表中查找段表项，里面有对应段的物理地址以及界限以及权限位，这里就体现出了虚拟内存的保护作用，之前偏移量受位数限制，现在偏移量不能超过界限，并且必须通过权限鉴别。</p>
<p>下图为段表（描述符表）的基本情况：共 3 个，可直接访问的有 GDT 与 LDT 两个，IDT 是中断表，里面的描述符指向的都是特定的段，也叫 Gate</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220152155629.png" alt="image-20241220152155629"></p>
<p>选择子一共有 16 位：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220175738856.png" alt="image-20241220175738856"></p>
<ul>
<li><p>高 13 位是段表的 index；</p>
</li>
<li><p>TI(Table Index)为第 2 位，表示选择 GDT 还是 LDT，有专门的 GDTR、LDTR 寄存器保存段表基址 STBaseAddress。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220142058130-1734679404141-3.png" alt="image-20241220142058130"></p>
<ul>
<li><p>LDT 存放在 GPT 的 LDT 类型描述符中，LDT 本身是一个段，而 GDT 不是一个段</p>
</li>
<li><p>访问 LDT 需要使用段选择子，为了减少访问 LDT 时段转换的次数，LDT 的段选择符，段基址，界限都要放在 LDTR 寄存器之中。</p>
</li>
<li><p>GDT 本身不是一个段，而是线性地址空间的一个数据结构；GDT 的线性基地址和长度必须加载进 GDTR 之中。因为每个描述符长度是8，所以 GDT 的基地址最好进行8字节对齐。</p>
</li>
<li><p>段寄存器仍然有之前类似 TLB 的 <strong>缓存</strong> 机制，有可见和不可见两个部分：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220180035716.png" alt="image-20241220180035716"></p>
</li>
</ul>
</li>
<li><p>0 - 1 为权限位(RPL) RPL 称为<strong>请求</strong>权限级别。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241221224507677.png" alt="image-20241221224507677"></p>
<ul>
<li><strong>CPL</strong> 是当前<strong>正在执行的代码段</strong>的特权级（CS 寄存器的低 2 位）<ul>
<li>0 和 3 分别表示用户态和内核态.中间是驱动程序的优先界别</li>
<li>CPL只在代码段改变时改变，即跳转指令 JMP CALL</li>
</ul>
</li>
<li>RPL 是对于一个段的请求特权级别</li>
<li><code>max&#123;RPL,CPL&#125; &lt; DPL</code> 方可访问此段</li>
</ul>
</li>
</ul>
<h4 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220180347195.png" alt="image-20241220180347195"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220141603315.png" alt="image-20241220141603315"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/929457-20161229210613367-1902103210-1734526656105-28.png" alt="img"></p>
<p><code>STEntry Address = STBaseAddress + 8 * index</code>  DTEntry 的大小 = 每条目 8 字节</p>
<p>Descriptor(DTEntry) 中含有段基址 界限 DPL 等       物理地址 = 段基址 + 偏移 </p>
<p>CS:IP 组合称为逻辑地址，CS 唯一对应到段表的一个条目，应用程序内存不够用时，需要调用一些系统调用，让 DOS 分配一段内存，把这段内存的 base, limit 做成一个条目（Descriptor）加入到GDT或LDT中， 只有OS能更改CS，如果用户擅自更改CS，段表中找不到对应条目，会发生segmentation fault。逻辑地址一共有13+1=14位有效，偏移16位，因此虚拟内存 1 GB。但是地址线数量限制了物理内存大小最大 16 MB。</p>
<p>基于这种内存管理方式，用户应用程序可以实现动态链接。比如说一个程序分为代码段、数据段、零初始化段等，它依赖的库也是分段的，系统在加载程序时，只需为每个段分配一段内存，并为每个段设置一个描述符即可。 每个段的起始地址可以在加载时根据实际情况修改。</p>
<p>为了区分不同段的功能，可以在TYPE字段设置，比如代码段可读可执行，数据段可读可写等。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220180319764.png" alt="image-20241220180319764"></p>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>为了加深理解，用一个简单的指令执行流程来说明：</p>
<ol>
<li>取指：CPU 从 CS:IP 逻辑地址 获取指令的物理地址，取指令(16bit)，CS不变，IP+2；<ul>
<li>CS 此时就是一个选择子，只要代码段无变化，当前指令的执行权限就不变</li>
</ul>
</li>
<li>译码：翻译指令，指令被解析为 <code>MOV AX, [BX]</code> 操作数的逻辑地址 DS:BX 算出物理地址</li>
<li>执行：从物理地址取数，将 取来的数存到 AX 通用寄存器</li>
</ol>
<h3 id="IA-32-保护模式-32-bit"><a href="#IA-32-保护模式-32-bit" class="headerlink" title="IA-32 保护模式(32-bit)"></a>IA-32 保护模式(32-bit)</h3><h4 id="80386-保护模式"><a href="#80386-保护模式" class="headerlink" title="80386 保护模式"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/80386">80386</a> 保护模式</h4><ol>
<li><p>首次在 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X86">x86</a> 处理器中实现了 32 位系统（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IA-32">IA-32</a>）；</p>
</li>
<li><p>可配合使用 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=80387&action=edit&redlink=1">80387</a> 数字<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BC%94%E5%8A%A9%E8%99%95%E7%90%86%E5%99%A8">辅助处理器</a>增强<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B5%AE%E7%82%B9">浮点</a>运算能力；</p>
</li>
<li><p>首次采用 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98">高速缓存</a>（外置）解决内存速度瓶颈问题；</p>
</li>
<li><p>在 IA-32 保护模式下，CPU 的 32 条地址线全部有效，可寻址高达 4 GB 的物理地址空间；</p>
<p>Descriptor 的变化，可以看到变成 32位 基地址：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/929457-20161230154447711-2105143159-1734688534787-30.png" alt="img"></p>
</li>
<li><p>寄存器变化：</p>
<ol>
<li><p>在原来的四个段寄存器的基础上引入两个通用数据段寄存器 FS 和 GS；</p>
</li>
<li><p>除了段寄存器，其他寄存器全部升级到 32 位，名称加前缀 E，代表扩展；</p>
</li>
<li><p>将 80286 引入的 16 位 <strong>MSW</strong> 扩展为几个 32 位控制寄存器 <strong>CRx</strong> 用于控制机器特性。比如实模式、保护模式的切换以及分页机制的开启(CR0)页表的物理地址(CR3)，相对静态，初始化或特性切换时才改动，因此只有内核态可访问，以及还有用于调试的DRx寄存器；</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220175501376.png" alt="image-20241220175501376"></p>
</li>
<li><p>保护模式下的分段机制使用的寄存器 GDTR IDTR LDTR TR 有一些变化</p>
</li>
</ol>
</li>
</ol>
<h4 id="扁平内存模型"><a href="#扁平内存模型" class="headerlink" title="扁平内存模型"></a>扁平内存模型</h4><p><strong>最初的 Flat Model</strong>: </p>
<p>8086 以前，地址总线和数据寄存器只有 16 位，线性地址<strong>等于</strong>物理地址，最多支持64 KB的内存</p>
<p><strong>Real-Address Mode model</strong>: 实模式分段</p>
<p>1978 年的 8086 开始引入了内存<strong>分段</strong>，这使得 16 位 CPU 可以访问超过 64 KB (65,536字节)的内存，实际上 8086 CPU到内存的地址总线是 20 位，即可访问2^20^=1MB内存。</p>
<p>在 16 位模式，要让应用程序使用多个存储器分段（能够访问大于64K的内存）相当复杂。根源在于：数据总线位数少于地址总线，并且没有适当的地址算术指令适合做整个存储器范围的平面寻址，平面寻址方式也可以用像实模式那样的两个寄存器配合的乘法操作完成，但这会导致较慢的程序执行速度。并且 8086 只支持固定大小的段，这就引出了真正的分段机制</p>
<p><strong>Segmented Model</strong>: 保护模式分段</p>
<p>1982 年面世的 80286 不再将段寄存器左移 4 位作为段基址，而是索引到段表中获取段基址，这就是虚拟地址。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220002439505-1734680053190-17.png" alt="image-20241220002439505"></p>
<p>分段机制有固有的问题：处理器的实模式与保护模式，以及 80386 推出的虚拟 86 模式，分段最大 64 KiB（使用 16 位索引寄存器）。在实模式下的分段架构的内存空间会有所重叠，这是一种不好的设计。</p>
<p><strong>32-bit Flat Memory Model</strong>: 32 位分页</p>
<p>1985 年面世的 80386 及其后续处理器的 32 位保护模式下，一个分段长度上限是2^20^个粒度单位，粒度可以是 1 字节或 4K 字节（一页），因此分段长度上限可以是 4 GB，与 32 位数据寄存器匹配。随着 32 位操作系统的推出，以及更舒适的 32-bit Flat Memory Model，到 1990 年末期几乎淘汰了使用分段寻址，转而使用分页寻址。</p>
<p>然而使用 32-bit Flat Memory Model 最多只能访问 4 GB 的线性地址空间，这种限制并没有远离日常。此时，分段机制可以支持更多根地址线，比如奔腾Pro, 2, 3在 IA-32 的架构下拥有 36 条地址线，最大64 GB的内存，就靠分段的支持，但这种最终回归到分段的尴尬，经常被引述为朝着 64 位处理器发展的动机。</p>
<p><strong>真正的 Flat Memory Model</strong>: 64 位分页</p>
<p>2003 年问世的 x86-64 架构下，强制实现了 Flat Memory Model 这种最简明有效的寻址模型，但保留了使用段寄存器 FS 或 GS 的 64 位下的分段寻址。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220153250680.png" alt="image-20241220153250680"></p>
<h4 id="分页：Paging"><a href="#分页：Paging" class="headerlink" title="分页：Paging"></a>分页：Paging</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2560px-080810-protected-386-paging.svg.png" alt="undefined"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241219214149653.png" alt="image-20241219214149653"></p>
<p><strong>页表</strong>：采用二级页表，10+10+12 划分</p>
<p><strong>多进程</strong>：每个进程有一个页表，页表的物理地址存储在 CR3 寄存器</p>
<p>在Intel 80386及以后的版本中，保护模式保留了 80286 保护模式的分段机制，但增加了分页单元作为分段单元和物理总线之间的第二层地址转换。</p>
<ol>
<li>逻辑地址是 48 位，16 位属于段号，32 位偏移量，段表项中的段基址也是 32 位</li>
<li>应用程序寻址首先根据段号和段表基址定位到段表项，段的基地址加上偏移量算出线性地址</li>
<li>若关闭分页单元，段基址就是物理地址，直接送到地址总线上进行访存。</li>
<li>若启用分页单元，段表项存储的段基址是线性地址，而不是 80286 那样的物理地址。分页单元负责最终查询页表将这些线性地址转换为物理地址。</li>
</ol>
<p>80386 分页内存管理，比 80286 保护模式寻址具有更多的优点：</p>
<ul>
<li>操作系统可以控制与限制进程对页面的访问权限</li>
<li>为应用程序创造一个连续的、独立的、线性的虚拟内存空间</li>
<li>页面可以移出<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AD%98">主存</a>，存入更慢速的次级<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%96%E5%AD%98%E5%82%A8%E5%99%A8">外存</a>如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98">硬盘</a>。这使得操作系统可以使用比物理内存更大的存储空间。</li>
</ul>
<h4 id="CR0-开启特性"><a href="#CR0-开启特性" class="headerlink" title="CR0: 开启特性"></a>CR0: 开启特性</h4><ol>
<li>通过清除 CR0 控制寄存器中的最低位，可以返回实模式，但这是一项特权操作，以增强安全性和鲁棒性。相比之下，80286 只能通过强制处理器重置来返回实模式，例如由三重故障或使用外部硬件。</li>
<li>控制寄存器 CR0 中的位 0 用 PE 标记，控制分段管理机制的操作，所以把它们称为保护控制位。 PE 控制分段管理机制。 PE=0，处理器运行于实模式； PE=1，处理器运行于保护方式。</li>
<li>是否启用分页由 CR0 的位 31 标记</li>
</ol>
<h4 id="开启保护模式"><a href="#开启保护模式" class="headerlink" title="开启保护模式"></a>开启保护模式</h4><p>进入保护模式前，必须初始化 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8">GDT</a>，并最少包含三个描述符：空描述符、CS 描述符以及 DS 描述符。并把（全局描述符表的所占用的字节数-1）和 GDT 的物理地址保存到 GDTR 寄存器中。如果是IBM兼容的机器，则还需要打开 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/A20%E6%80%BB%E7%BA%BF">A20总线</a> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; 设置CR0寄存器的PE位</span><br><span class="line">mov eax, cr0       ; 必须通过其他寄存器来修改CR0寄存器</span><br><span class="line">or eax, 1</span><br><span class="line">mov cr0, eax</span><br><span class="line"></span><br><span class="line">; 远转移 (cs = 代码段描述符)</span><br><span class="line">jmp cs:@pmode</span><br><span class="line"></span><br><span class="line">[bits 32]</span><br><span class="line">@pmode:</span><br><span class="line">; 现在已经进入了保护模式</span><br></pre></td></tr></table></figure>

<h3 id="Virtual-8086-Mode"><a href="#Virtual-8086-Mode" class="headerlink" title="Virtual 8086 Mode"></a>Virtual 8086 Mode</h3><p>80286 开始的保护模式支持<strong>更大的寻址空间</strong>和<strong>一定程度的保护措施</strong>，但是为了<strong>向下兼容</strong>运行在实模式下的软件，仍然保留了实模式（BIOS 工作在实模式，因此在正式启动操作系统之前必须运行在实模式，开始启动的<strong>第一步就是将实模式转换为保护模式</strong>）启动系统之后，80286 的 16 位保护模式，受硬件的限制，不支持分页，多任务支持也有限，因此不能向下兼容实模式的软件，<strong>必须遵循一定的标准将实模式代码重新编译、汇编才能在 16 位的保护模式运行</strong>，这就造成了诸多不便。</p>
<p>80386 开始的 IA-32 架构中，寄存器扩展至 32 位，随之而来的 32 位保护模式较完整，因此可以<strong>在 32 位保护模式直接运行 16 位实模式程序</strong>，也就是虚拟 8086 模式。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241219214209871.png" alt="image-20241219214209871"></p>
<ul>
<li>利用健全的多任务机制，多个虚拟 86 程序可以和 32 位程序并发执行，提升效率</li>
<li>利用分页机制，模拟出和 8086 一样的寻址方式，段基址 &lt;&lt; 4 + 段内的偏移地址，寻址空间为1 MB，将不同虚拟 86 程序的地址空间映射到不同的物理地址上，这样每个虚拟86任务看起来都认为自己在 0 ~ 1 MB 的地址空间。</li>
</ul>
<h4 id="实模式-Virtual-8086-8086"><a href="#实模式-Virtual-8086-8086" class="headerlink" title="实模式/Virtual 8086/8086"></a>实模式/Virtual 8086/8086</h4><p>下表可以看出 实模式、8086、虚拟 86 的中断向量表是不完全一致的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220173857308.png" alt="image-20241220173857308"></p>
<ul>
<li>和实模式、8086相比：</li>
</ul>
<ol>
<li>段描述符加载之后会缓存，加快之后的访存速度</li>
<li>虚拟 8086 模式并不是完美兼容的，因为在 16 位架构里没有保护概念，CPU 也没有特权指令这一说，所以改变段寄存器、直接访问硬件等操作会陷入 OS 或者抛出异常，这就导致这些指令无法正常运行，但也没有办法，为了适应现代操作系统，只能放弃对这些应用的支持。</li>
</ol>
<h3 id="IA-32-地址翻译"><a href="#IA-32-地址翻译" class="headerlink" title="IA-32 地址翻译"></a>IA-32 地址翻译</h3><p>在 x86-64 架构下，长模式以外的三种模式也叫做 Legacy Mode </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241219214044009-1734615684145-17.png" alt="image-20241219214044009"></p>
<h2 id="长模式-IA-32e-Mode"><a href="#长模式-IA-32e-Mode" class="headerlink" title="长模式 (IA-32e Mode)"></a>长模式 (IA-32e Mode)</h2><p>在x86-64 等现代新架构中，长模式是64位操作系统可以访问64位指令和寄存器的模式，有两个子模式。 </p>
<p>64位程序在称为 64-bit Mode 的子模式下运行，32 位和 16 位保护模式程序在称为 Compatibility Mode 的子模式下执行，其允许 64 位操作系统运行现有的 16 位和 32 位 x86 应用程序。 在兼容模式下运行的应用程序使用 32 位或 16 位寻址，并且可以访问前 4 GB 虚拟地址空间。传统 x86 指令前缀在 16 位和 32 位地址和操作数大小之间切换。 与 64 位模式一样，兼容性模式由操作系统在单个代码段的基础上启用。</p>
<p>然而，与 64-bit Mode 不同的是，x86 分段功能与传统 x86 架构中相同，使用 16 位或 32 位保护模式语义。从应用程序的角度来看，兼容模式看起来就像传统的 x86 保护模式环境。然而，从操作系统的角度来看，地址转换、中断和异常处理以及系统数据结构都使用 64 位长模式机制。</p>
<p>删除了 HW Task Switch, TSS 变成一个堆栈表, 不再存储段相关的信息</p>
<h3 id="x86-64-寄存器"><a href="#x86-64-寄存器" class="headerlink" title="x86-64 寄存器"></a>x86-64 寄存器</h3><p>x86-64 架构在长模式（64 位模式）下，大部分寄存器位数增加为 64 位，前缀位为 R</p>
<ul>
<li>分段的概念被无限弱化：其中四个段寄存器 CS、SS、DS 和 ES 被强制设置为基地址 0，并且限制为 2^64^ ，形式上还有内存分段，但实际上所有内存都在唯一的一个分段中。</li>
<li>段寄存器 FS 和 GS 仍然可以具有非零基地址，这允许操作系统将这些段用于特殊目的。与传统模式使用的 GDT 机制不同，这些段的基地址存储在特定于模型的寄存器中。 x86-64架构还提供了特殊的 SWAPGS 指令，该指令允许交换内核模式和用户模式基地址。例如，x86-64 上的 Microsoft Windows 使用 FS 段指向线程环境块(TEB)，这是每个线程的一个小型数据结构，其中包含有关异常处理、线程局部变量和其他每线程状态的信息。同样，Linux 内核使用 GS 段来进行类似的线程本地存储(TLS)</li>
</ul>
<p><strong>应用程序编程</strong>使用如下寄存器：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220183652263.png" alt="image-20241220183652263"></p>
<p>系统编程使用如下寄存器：    </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220183817147.png" alt="image-20241220183817147"></p>
<h3 id="地址翻译-1"><a href="#地址翻译-1" class="headerlink" title="地址翻译"></a>地址翻译</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241219213948185.png" alt="image-20241219213948185"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220183850040.png" alt="image-20241220183850040"></p>
<h3 id="Legacy-Mode"><a href="#Legacy-Mode" class="headerlink" title="Legacy Mode"></a>Legacy Mode</h3><p>以前的模式统称 Legacy Mode</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220184344031.png" alt="image-20241220184344031"></p>
<h1 id="Interrupt-and-Exception-Handling"><a href="#Interrupt-and-Exception-Handling" class="headerlink" title="Interrupt and Exception Handling"></a>Interrupt and Exception Handling</h1><h2 id="概念：中断和异常"><a href="#概念：中断和异常" class="headerlink" title="概念：中断和异常"></a>概念：中断和异常</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/computer-interrupt1-l.jpg" alt="PPT - BIOS and DOS Interrupts PowerPoint Presentation, free download ..."></p>
<h3 id="Interrupt（中断）"><a href="#Interrupt（中断）" class="headerlink" title="Interrupt（中断）"></a>Interrupt（中断）</h3><p>中断可以分为硬件和软件引起的中断</p>
<ul>
<li><p>硬件中断(Hardware) 通常是 CPU 执行指令过程中收到外部硬件的中断信号，属于外部中断</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/273421-20210821212504824-517540124.png" alt="img"></p>
<ul>
<li>可屏蔽中断：<strong>INTR</strong> 引脚传入，可以通过 <code>IF</code> 标志位屏蔽</li>
<li>不可屏蔽中断：<strong>NMI</strong> 引脚传入(Non-maskable Interrupt)，电源掉电、内存读写错误、总线奇偶校验错误等灾难性的错误，不可屏蔽，CPU 必须立刻处理。有一个专用的中断向量号，一般是不可屏蔽的，这样可以防止嵌套执行，直到 <code>IRET</code> 从中断返回</li>
<li>通过中断控制器从总线读取中断向量，高级可编程中断控制器 <strong>APIC</strong> 可以通过 LINT 引脚接收中断，可以处理 INTR 和 NMI，如果 APIC 禁用则会使用 INTR 和 NMI</li>
<li>CPU 收到硬中断以后需要保存执行现场，转去执行中断服务程序（ISR, Interrupt Service Routine）硬中断是异步、随机、无法预知的。</li>
</ul>
</li>
<li><p>软件中断(Software) 通常显式调用中断指令触发的中断，属于内部中断</p>
<ul>
<li>基础的汇编指令，由指令提供中断向量号 <code>INT n</code> </li>
</ul>
</li>
<li><p>中断服务程序的最后一条一定是 <code>IRET</code> 指令，恢复原先程序的执行</p>
</li>
</ul>
<h3 id="Exception（处理器）"><a href="#Exception（处理器）" class="headerlink" title="Exception（处理器）"></a>Exception（处理器）</h3><p>异常主要是 CPU 执行指令过程中发现的，属于内部中断,从源头来看，大体分为三类：</p>
<ol>
<li>处理器在执行指令的过程中检测到的程序错误(program error)，比如 <code>zero division</code> </li>
<li>软件生成的异常：<code>INTO, INT1, INT2, INT3, BOUND</code> 指令。有一些异常提供错误码，发生异常需要将错误码压栈，以便正确处理。如果使用 <code>INT n</code> 模拟异常，不会提供错误码，会将 EIP 指令指针错误提供，可能会出现错误。<ul>
<li><code>INTO</code>: Overflow</li>
<li><code>INT3</code>: Breakpoint, debugging</li>
<li><code>BOUND</code>: Bound Range Exceeded</li>
<li><code>UD</code>: Invalid Opcode</li>
</ul>
</li>
<li>还有一些异常源是机器检查（Machine-check）提供的</li>
</ol>
<h2 id="Restart"><a href="#Restart" class="headerlink" title="Restart"></a>Restart</h2><p>下文的 中断/异常处理程序 泛指 处理中断或异常的程序</p>
<ol>
<li><code>Fault</code>: (<strong>RETRY</strong>) 异常处理程序 返回指向 <strong>异常源指令</strong> 的指针，因此将会<strong>重新执行</strong>这条指令。一般是在无法正常通过地址访问到操作数就会触发这种异常，最典型的比如 Page Fault，为了能正确恢复需要 CPU 保存必要的寄存器（上下文）。</li>
<li><code>Trap</code>: (<strong>CONTINUE</strong>) 异常处理程序 返回指向 <strong>异常源的后一条指令</strong> 的指针，因此将会从下一条指令开始，最大特点就是不会影响程序执行的连贯性。比如 INTO 溢出异常，不过这里的下一条指的是逻辑上的下一条，他不一定和异常源相邻。比如执行 JMP 指令，返回的是指向 JMP 目的地的指针。</li>
<li><code>Abort</code>: (<strong>EXIT</strong>) 会影响程序的执行的连贯性，具体来说就是 异常处理程序 不能保证可靠的返回，旨在发生abort异常时收集有关处理器状态的诊断信息，然后尽可能优雅地关闭应用程序和系统。</li>
<li><code>Interrupt</code>: 中断严格支持程序的正确返回，不会影响可靠性与程序执行的连贯性，除非是掉电或者是硬件错误。中断虽然不可预知，但是 CPU 有完善的应对策略：首先，CPU 在每个指令周期都会检查是否有中断，一般是在最后阶段。第二，在开始执行 中断处理程序 之前，一定会保存当时指令执行的现场以便恢复执行，比如 I/O 操作，恢复时执行的指令就是中断前执行的最后一条指令的下一条</li>
</ol>
<h2 id="IDT"><a href="#IDT" class="headerlink" title="IDT"></a>IDT</h2><h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241219181455217.png" alt="image-20241219181455217"></p>
<p>中断描述符表是一张用于存储<strong>中断处理程序入口</strong>的表格，每个表项（Entry）是一个中断描述符（Gate Descriptor），用于指明当某个中断或异常发生时，中断/异常处理程序 的入口地址、权限等信息。为了帮助处理异常和中断，需要处理器进行特殊处理的每个体系结构定义的异常和每个中断条件都被分配了一个唯一的标识号，称为中断向量号。处理器使用分配给异常或中断的向量号作为中断描述符表 (IDT) 的索引。该表提供了异常或中断 中断/异常处理程序 的入口点。中断表的索引范围是 0 到 255。</p>
<ul>
<li><p><code>0</code> 到 <code>31</code> 范围内的向量编号由 Intel 64 和 IA-32 体系结构保留，用于体系结构定义的异常和中断。并非所有中断都有相应的处理函数。该范围内未分配的向量编号被保留，不能使用。 </p>
</li>
<li><p><code>32</code> 到 <code>255</code> 范围内的向量编号被指定为用户定义的中断，并且不被 Intel 64 和 IA-32 体系结构保留，这些中断通常分配给外部 I/O 设备，以使这些设备能够通过外部硬件中断机制之一向处理器发送中断。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th><strong>Trap Table</strong></th>
<th><strong>IDT</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>适用范围</strong></td>
<td>较简单的操作系统或教学架构中使用</td>
<td>主要用于 x86 架构的保护模式</td>
</tr>
<tr>
<td><strong>数据结构</strong></td>
<td>简单的映射表</td>
<td>复杂的描述符表，包含地址和其他元信息</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>仅存储中断处理程序地址</td>
<td>支持权限管理、段选择、复杂异常和硬件中断处理</td>
</tr>
<tr>
<td><strong>实现机制</strong></td>
<td>直接使用固定大小的数组存储入口地址</td>
<td>通过描述符表实现，包含段选择子和偏移地址的组合</td>
</tr>
</tbody></table>
<p><strong>CPU 上电后（Real Mode阶段）：</strong> </p>
<ul>
<li>在实模式下，CPU 使用一个简单的中断向量表（Interrupt Vector Table, IVT），这是一个固定位置的内存表，系统刚引导时，内存0x00000到0x0003FF共1KB的空间用于存放中断向量表。每个中断向量占用4个字节，共可存储 256 个中断向量，中断向量表中存储的是异常处理程序的起始地址。</li>
<li>这个 IVT 是 16 位架构的中断处理机制，和 IDT 不同。</li>
</ul>
<p><strong>进入保护模式（Protected Mode）时：</strong> </p>
<ul>
<li>当系统进入保护模式后，操作系统需要配置自己的 IDT，因为保护模式支持更复杂的中断和异常处理。</li>
<li>操作系统初始化过程中会：<ol>
<li>分配一块内存用于存储 IDT。</li>
<li>填充 IDT 条目（包括中断号、处理程序地址、权限等）。</li>
<li>使用 <code>lidt</code> 指令加载 IDT 的基址和限制到 CPU 的 IDTR 寄存器。</li>
</ol>
</li>
</ul>
<p><strong>进入长模式（Long Mode）时：</strong></p>
<ul>
<li>在 64 位模式（长模式）下，IDT 同样需要重新设置，因为长模式支持更复杂的地址模式和更大的描述符。</li>
<li>通常操作系统会重新配置或直接复用保护模式下的 IDT。</li>
</ul>
<p>不过，本质都是中断向量表，本质存储的都是Handler入口</p>
<h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241219204336594.png" alt="image-20241219204336594"></p>
<ol>
<li><p><strong>中断或异常发生</strong>：</p>
<ul>
<li>CPU 收到一个中断或异常信号。</li>
<li>信号对应一个中断号（Interrupt Vector），范围是 <code>0-255</code>。</li>
</ul>
</li>
<li><p><strong>查找 IDT</strong>（interrupt Descriptor Table）</p>
<ul>
<li>CPU 从 <strong>IDTR 寄存器</strong> 中读取 IDT 的基地址（起始地址）。</li>
</ul>
</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220095504456.png" alt="image-20241220095504456"></p>
<ol start="3">
<li><p><strong>跳转到处理程序</strong>：</p>
<ul>
<li><p>根据中断向量在 IDT 中找到对应的 Descriptor (比如中断门和陷阱门)</p>
</li>
<li><p>Descriptor 中存储了 段选择器（Selector）和偏移量用来定位 中断/异常处理程序 的位置、特权级、类型（中断门、陷阱门、任务门等）</p>
</li>
<li><p>CPU 跳转到 中断/异常处理程序 并开始执行中断或异常的处理。</p>
</li>
</ul>
</li>
</ol>
<h3 id="Gate-Descriptors"><a href="#Gate-Descriptors" class="headerlink" title="Gate Descriptors"></a>Gate Descriptors</h3><h4 id="Interrupt-Trap-Gate"><a href="#Interrupt-Trap-Gate" class="headerlink" title="Interrupt/Trap Gate"></a>Interrupt/Trap Gate</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241219204408842.png" alt="image-20241219204408842"></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>中断门(Interrupt Gate)</th>
<th>陷阱门(Trap Gate)</th>
<th align="left">任务门(Task Gate)</th>
</tr>
</thead>
<tbody><tr>
<td>触发来源</td>
<td>硬件中断/软件中断</td>
<td>异常/软件触发</td>
<td align="left">任务切换</td>
</tr>
<tr>
<td>IF 标志位</td>
<td><code>IF</code> 自动清零（关中断）</td>
<td><code>IF</code> 不变（不屏蔽中断）</td>
<td align="left">与任务无关</td>
</tr>
<tr>
<td>跳转目标</td>
<td>中断服务例程</td>
<td>异常或调试服务例程</td>
<td align="left">任务状态段（TSS）</td>
</tr>
<tr>
<td>返回方式</td>
<td><code>IRET</code> 指令</td>
<td><code>IRET</code> 指令</td>
<td align="left">任务切换完成后返回</td>
</tr>
<tr>
<td>典型用途</td>
<td>硬件中断处理</td>
<td>调试、异常处理</td>
<td align="left">多任务</td>
</tr>
</tbody></table>
<h4 id="Call-Gate"><a href="#Call-Gate" class="headerlink" title="Call Gate"></a>Call Gate</h4><p><strong>调用门</strong>(Call Gate)：调用门可以通过 <code>CALL</code> <code>JMP</code> 调用，从一个低特权级代码段跳转到另外一个高特权级的代码段，存在 GDT 和 LDT 中，但从未被实际使用过。对于系统调用的实现来说，这是不方便的并且不是最佳实现。大多数操作系统使用<strong>陷阱门</strong>（Linux 中的 <code>INT 0x80</code> 和 Windows 中的 <code>INT 0x2E</code>）或更强大的 <code>SYSENTER/SYSEXIT</code> 指令来代替调用门</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; CALL 指令与 JMP 指令示例</span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    call 0x10:0x0000      ; 调用子程序 需要返回(my_function)</span><br><span class="line">    jmp  0x18:0x0000      ; 无条件跳转 不需要返回(end_program)</span><br><span class="line"></span><br><span class="line">0x10:0x0000:</span><br><span class="line">    ; 子程序代码</span><br><span class="line">    ret                   ; 返回主程序</span><br><span class="line"></span><br><span class="line">0x18:0x0000:</span><br><span class="line">    ; 程序结束</span><br><span class="line">    mov eax, 1            ; 系统调用号（exit）</span><br><span class="line">    xor ebx, ebx          ; 返回值（0）</span><br><span class="line">    int 0x80              ; TRAP into kernel</span><br></pre></td></tr></table></figure>

<h4 id="Task-Gate"><a href="#Task-Gate" class="headerlink" title="Task Gate"></a>Task Gate</h4><p>详见下文的硬件任务切换</p>
<h2 id="HW-Task-Switch（硬件任务切换）"><a href="#HW-Task-Switch（硬件任务切换）" class="headerlink" title="HW Task Switch（硬件任务切换）"></a>HW Task Switch（硬件任务切换）</h2><h3 id="Task-Gate-1"><a href="#Task-Gate-1" class="headerlink" title="Task Gate"></a>Task Gate</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220170638814-1734685697132-27.png" alt="image-20241220170638814"></p>
<p>在中断处理过程(IDT)或者在GDT LDT里索引到任务门，会开启硬件任务切换，影响着。</p>
<p><strong>任务门</strong>(Task Gate)：为多任务处理提供<strong>硬件</strong>支持，跳转到 TSS，目前不被使用。</p>
<p><strong>任务状态段</strong>(TSS, Task Status Segment): 保存了任务的执行上下文环境</p>
<h3 id="Task-Status-Segment"><a href="#Task-Status-Segment" class="headerlink" title="Task Status Segment"></a>Task Status Segment</h3><p><strong>TSS Descriptor 的结构，位于 GDT 中：</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220094926788-1734660034533-1.png" alt="image-20241220094926788"></p>
<p>一般 TSS 的 DPL 是小于3的，因为只有操作系统内核才有权调度任务</p>
<hr>
<p><strong>IA-32 TSS 内部的结构</strong>：</p>
<ul>
<li><p>I/O map的基地址， bitmap 本体通常映射到 TSS，通过 bitmap 限制进程对 IO 端口的访问</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220180936358.png" alt="image-20241220180936358"></p>
</li>
<li><p>本进程对应的 LDT Selector</p>
</li>
<li><p>所有的x86普通寄存器：6 个段，8个通用，1 个指令指针，1 个程序状态字</p>
</li>
<li><p>CR3 页表地址</p>
</li>
<li><p>其他特权级别的栈段和栈指针 SS2<del>0 ESP2</del>0 (内核栈)</p>
</li>
<li><p>用于嵌套任务的 link，也就是上一个 父任务的 TSS Selector</p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220001641685.png" alt="image-20241220001641685"></p>
<p><strong>TSS 寻址：</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220001517922-1734684881103-23.png" alt="image-20241220001517922"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220094649039.png" alt="image-20241220094649039"></p>
<hr>
<h3 id="Workflow"><a href="#Workflow" class="headerlink" title="Workflow"></a>Workflow</h3><p>处理器能够<strong>自动</strong>保存执行上下文，响应来自硬件或软件的请求，恢复另一任务的上下文：</p>
<ol>
<li>显式切换：<code>CALL/JMP tss_selector</code> <code>CALL/JMP task_gate_selector</code></li>
<li>隐式切换：中断/错误处理程序触发</li>
<li>可以通过控制特定的中断向量陷入 IDT 中的特定 Task Gate 来完成跳转，比如<code>INT n</code></li>
<li>嵌套任务的 <code>IRET</code>，EFLAGS 的 <code>NT</code> 标志位(Nested Tasks) 置位用于嵌套任务的跳转。</li>
</ol>
<p>下面为通过 IDT 的 Task Gate 进行任务切换的例子：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220100119251.png" alt="image-20241220100119251"></p>
<ul>
<li><p>TR 寄存器结构如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220001552753-1734684981103-25.png" alt="image-20241220001552753"></p>
</li>
<li><p>当 依赖 TSS 进行任务切换的时候，CPU 做了以下几件事情：</p>
</li>
</ul>
<ol>
<li><strong>保存现场</strong>：当前 TSS 中所有寄存器值填写到当前的 <strong>TR</strong> 寄存器（task register）指向的 TSS 中</li>
<li><strong>加载新现场</strong>：把新 TSS Selector 载入 <strong>TR</strong> ，<strong>按照一定的检验流程</strong>把新的 TSS 覆盖到寄存器。</li>
<li><strong>开始执行新代码</strong>：新设置的 EIP 指向将要执行的新代码</li>
</ol>
<ul>
<li><strong>缺点</strong>： 受硬件限制较大，且流程繁杂，不灵活也不便于调试</li>
</ul>
<ol>
<li>TSS 只能存在 GDT （最大长度只有 8,192）(TSS+LDT)*2+12=8192,最多 4090 个进程    </li>
<li>算上检验流程要消耗 200 多个时钟周期，全部串行，中间出现一个差错就无法切换成功。</li>
<li>硬件的切换过于重量级，保存完整的上下文，实际上任务切换不一定需要那么多寄存器</li>
</ol>
<p>ex. <strong>嵌套任务切换</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220172753514.png" alt="image-20241220172753514"></p>
<h3 id="SW-Task-Switch"><a href="#SW-Task-Switch" class="headerlink" title="SW Task Switch"></a>SW Task Switch</h3><p><strong>操作系统</strong> 将关键的上下文内容存到类似 PCB 等自由可控的轻量环境中，可以完全控制任务切换逻辑，能够支持指令流水的并行优化技术，更加适合复杂的多任务调度算法，提升性能。</p>
<p>Linux 2.4之前的内核有进程最大数的限制，受限制的原因是，每一个进程都有自已的 TSS 和 LDT。Linux 2.4以后，在同一个CPU上的进程使用同一个 TSS，有效内容只剩下 <code>ESP0</code> 和<code>IO MAP Address</code> </p>
<ul>
<li><code>ESP0</code>: 内核堆栈指针，因为linux完全使用分页，所以SS段没有用处</li>
<li><code>IO bitmap</code>: 控制进程的 I/O 许可</li>
</ul>
<h2 id="Stack-Usage-by-Handler"><a href="#Stack-Usage-by-Handler" class="headerlink" title="Stack Usage by Handler"></a>Stack Usage by Handler</h2><p><strong>有特权级别的转换</strong>（为防止恶意程序,一般会切换，比如系统调用、异常 陷入 OS 的内核模式）:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220162644295.png" alt="image-20241220162644295"></p>
<p>因为有特权级别切换，因此要根据 TSS 里的内核栈段 SS0 和 ESP0 切换到处理程序自己的栈上，保存好被中断程序原先的 SS 和 ESP，将他的 CS, EIP, EFLAGS 也搬过去，最后将错误码压栈。</p>
<hr>
<p>如果没有特权级别转换，就不会切换执行堆栈，内核中发生了中断或者异常：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220165159628.png" alt="image-20241220165159628"></p>
<h2 id="并发事件"><a href="#并发事件" class="headerlink" title="并发事件"></a>并发事件</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241219194949413.png" alt="image-20241219194949413"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241219204058993.png" alt="image-20241219204058993"></p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>从 0 到 32 的任何向量的中断都可以通过 INTR 引脚传递到处理器，并且从 16 到 32 的任何向量都可以通过本地 APIC 传递。当通过 INTR 引脚模拟异常向量中断(比如 Page Fault)，处理器不会将错误码压栈，因此异常处理程序可能无法正确运行。（和 <code>INT n</code> 的问题一样） </p>
<h4 id="EFLAGS-PSW"><a href="#EFLAGS-PSW" class="headerlink" title="EFLAGS(PSW)"></a>EFLAGS(PSW)</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220002704824.png" alt="image-20241220002704824"></p>
<h4 id="屏蔽中断（Masking）"><a href="#屏蔽中断（Masking）" class="headerlink" title="屏蔽中断（Masking）"></a>屏蔽中断（Masking）</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2f761a5d7cb13f08919db2447c92f0aa.png" alt="在这里插入图片描述"></p>
<ol>
<li><code>STI</code><del>SET</del>, <code>CLI</code><del>CLEAR</del>这两个特权指令可以改变 <code>IF</code> 标志位（位于程序状态字 PSW, aka EFLAGS）控制 CPU 是否能够响应外部中断请求，是多重中断的基本条件，<code>IRET</code>也可以改变</li>
<li><strong>关中断</strong>：将 <code>IF</code> 中断标志位置零，用于保护现场、恢复现场和跳转到 ISR。</li>
<li>在执行 ISR 之前可以<strong>开中断</strong>，执行 ISR 的过程可以被其他中断打断，如果使用中断屏蔽技术(MASK)，就可以实现多重中断，高优先级有权打断低优先级，反之则不行。</li>
<li><strong>中断屏蔽技术</strong>：每个中断可以设置其他中断源的 <code>mask</code> ，被设置为0则被停止执行</li>
</ol>
<h1 id="OS-Booting"><a href="#OS-Booting" class="headerlink" title="OS Booting"></a>OS Booting</h1><p>一些早期的计算机系统，在接收到来自操作人员或外围设备的启动信号后，可以将极少量的固定指令加载到存储器的特定位置，初始化至少一个CPU，然后将CPU指向这些指令并执行指令这些指令通常从一些外围设备（可以由操作员通过开关选择）启动输入操作。其他系统可能会直接向外围设备或 I/O 控制器发送硬件命令，从而执行极其简单的输入操作（例如“将系统设备的扇区 0 读取到从位置 1000 开始的内存中”），从而有效地加载一个小文件。然后开始==链式引导系统启动==。</p>
<p>对于现代操作系统，当计算机关闭时，其软件（包括操作系统、应用程序代码和数据）仍存储在非易失性存储器中。当计算机开机时，它的 RAM 中通常没有操作系统或其加载程序。计算机首先执行存储在 ROM（后来的EEPROM，NOR Flash）中的相对较小的程序（也就是 ==BIOS== 与 ==UEFI==）。该程序支持就地执行，初始化 CPU 和主板，初始化 DRAM（特别是在x86系统上），访问非易失性存储器设备（通常是块寻址设备，例如 NAND Flash、SSD、HDD）或其他可以将操作系统程序和数据加载到 RAM 中的设备（U盘、CD-ROM、甚至是网络设备）此外，该程序还可以初始化显示设备（例如GPU）、文本输入设备（例如键盘）和指针输入设备（例如鼠标）加载到 RAM 中的第一个程序可能不足以加载操作系统，而必须加载另一个更大的程序，它加载的程序称为第二阶段引导加载程序（狭义上的 ==Bootloader==）</p>
<h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h2><p><strong>B</strong>asic <strong>I</strong>nput/<strong>O</strong>utput <strong>S</strong>ystem，基本输入输出系统，主要负责硬件层面的初始化和基本 I/O 管理，目标是找到设备上的 Bootloader，从Bootloader启动操作系统。</p>
<p>早年，BIOS 存储于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ROM">ROM</a>芯片上；现在的 BIOS 多存储于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%96%83%E8%A8%98%E6%86%B6%E9%AB%94">闪存</a>芯片上，这方便了 BIOS 的更新。BIOS 也可从<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E5%8D%A1">网卡</a>等设备启动。</p>
<p>当电脑通电，BIOS 就会从存储器上加载，执行<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E9%9B%BB%E8%87%AA%E6%AA%A2">加电自检</a>（POST），测试和初始化 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CPU">CPU</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8">RAM</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%8E%A5%E8%A8%98%E6%86%B6%E9%AB%94%E5%AD%98%E5%8F%96">DMA</a>控制器、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%99%B6%E7%89%87%E7%B5%84">芯片组</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%8D%B5%E7%9B%A4">键盘</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E7%A2%9F">软盘</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%A2%9F">硬盘</a>等设备。</p>
<p>所有的 Option ROM（扩展 BIOS 程序）被加载后，BIOS 就试图从启动设备（如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%A2%9F">硬盘</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E7%A2%9F">软盘</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%89%E7%A2%9F">光盘</a>）加载 Bootloader，由 Bootloader 加载<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1">操作系统</a>。BIOS 以 16 位<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9C%9F%E5%AF%A6%E6%A8%A1%E5%BC%8F">实模式</a>执行。现代操作系统以<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%9D%E8%AD%B7%E6%A8%A1%E5%BC%8F">保护模式</a>或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%95%BF%E6%A8%A1%E5%BC%8F">长模式</a>执行。</p>
<h3 id="BIOS-固件（Filmware）"><a href="#BIOS-固件（Filmware）" class="headerlink" title="BIOS 固件（Filmware）"></a>BIOS 固件（Filmware）</h3><p>BIOS 本身是汇编语言代码，是在 16 位实模式下执行的，由于 x86-64 是一个高度兼容的<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=100152930&content_type=Article&match_order=1&q=%E6%8C%87%E4%BB%A4%E9%9B%86&zhida_source=entity">指令集</a>，也为了迁就 BIOS 的 16 位实模式的运行环境，所以即使现在的 CPU 都已是 64 位，如果还是在 BIOS 启动（基本见于 09 年以前的主板），在开机时仍然都是在 16 位实模式下执行的。16 位实模式直接能访问的内存只有 1 MB，就算你安了 4G、8G 或者 16 G 还是 32 G 内存，到了 BIOS 上一律只先认前 1 MB。在这 1 M内存中，前 640 K 称为基本内存，后面 384 K 内存留给开机必要硬件和各类 BIOS 本身使用。</p>
<h3 id="BIOS-Setup"><a href="#BIOS-Setup" class="headerlink" title="BIOS Setup"></a>BIOS Setup</h3><p>大约从<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/80386">80386</a> PC开始，个人电脑的 BIOS ROM 集成了设置程序（Setup）。主板的 CMOS 芯片用于存储 BIOS 设置值及硬件侦测值。</p>
<p>现代的 BIOS 可以让用户选择由哪个启动设备启动电脑，如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%89%E7%A2%9F%E6%A9%9F">光盘驱动器</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%A2%9F">硬盘</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E7%A2%9F">软盘</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9A%A8%E8%BA%AB%E7%A2%9F">U盘</a>等等。现代大多数 BIOS 支持图形化交互界面，有一些是厂商制作的，用户可以用鼠标键盘完成操作。</p>
<h4 id="CMOS"><a href="#CMOS" class="headerlink" title="CMOS"></a>CMOS</h4><p>CMOS 是计算机上另一个重要的存储器。之所以提到它，是因为 BIOS 程序的设置值、硬件参数侦测值就保存在 CMOS 中。而且，在 BIOS 程序启动计算机时，需要加载 CMOS 中的设置值。CMOS 通常被集成在南桥芯片组中。UEFI 系统则多用 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/NVRAM">NVRAM</a> 存储设置。</p>
<ul>
<li>BIOS 芯片属于 ROM ，不需要供电保存信息，其中存储的是固件（filmware，程序代码）</li>
<li>CMOS 芯片属于 RAM，内容在断电会消失，存储的是普通信息。主板上的钮扣电池用于让 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CMOS">CMOS </a>存储 BIOS 设置值，以及电脑在断电时依然可以让系统时钟运作。把<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E6%A9%9F%E6%9D%BF">主板</a>的电池拆出，便可重置其内容，拆出电池也会重置系统时钟。</li>
</ul>
<h3 id="Pre-booting"><a href="#Pre-booting" class="headerlink" title="Pre-booting"></a>Pre-booting</h3><h4 id="POST：加电自检"><a href="#POST：加电自检" class="headerlink" title="POST：加电自检"></a>POST：加电自检</h4><p>先进行 CPU 初始化：当按下电源开关时，电源就开始向主板和其他设备供电，这时电压还不稳定，在早期的南北桥主板上，由主板北桥向CPU发复位信号，对CPU初始化；稳定电压后复位信号便撤掉。而对于现在的单南桥主板，则由CPU自身调整稳定电压达到初始化的目的，当电压稳定后，CPU 便在系统BIOS保留的内存地址处执行跳转 BIOS 起始处指令，开始执行 POST 自检。</p>
<p><strong>加电自检</strong>(POST, Power-On Self Test)是计算机 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/BIOS">BIOS</a> 的一个重要功能，主要用于在 BIOS 加载操作系统之前检查计算机设备硬件是否存在问题，进而保证计算机的正常运行。在设备启动的过程中，自检程序主要检查<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CPU">CPU</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8">内存</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/I/O">I/O设备</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E6%9D%BF">主板</a>等对计算机正常运行会产生影响的设备硬件。</p>
<p>在POST自检中，BIOS 只检查系统的必要核心硬件是否有问题，主要是 CPU、640K基本内存、显卡是否正常，PS/2 键盘控制器、系统时钟是否有错误等等。由于 POST 检查在显卡初始化以前，因此在这个阶段如发生错误，是无法在屏幕上显示的，不过主板上还有个报警扬声器，而且如果主板的 8255 外围可编程接口芯片没有损坏的话，POST报警声音一定是会出来的。可以根据报警声的不同大致判断错误所在，一般情况下，一声短“嘀”声基本代表正常启动，不同的错误则是不同的短“嘀”声和长“嘀”声组合。POST 自检结束后，BIOS 开始调用中断完成各种硬件初始化工作。</p>
<h4 id="BIOS-中断调用"><a href="#BIOS-中断调用" class="headerlink" title="BIOS 中断调用"></a>BIOS 中断调用</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241220173802326.png" alt="image-20241220173802326"></p>
<p>与中断相对的是轮询（polling）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jadeshu/p/10663505.html">中断向量表 - jadeshu - 博客园</a> </p>
<p><strong>CPU 上电后（实模式阶段）：</strong> </p>
<ul>
<li>在实模式下，CPU 使用一个简单的中断向量表（Interrupt Vector Table, IVT），这是一个固定位置的内存表，系统刚引导时，内存0x00000到0x0003FF共1KB的空间用于存放中断向量表。每个中断向量占用4个字节，共可存储256个中断向量，中断向量表中存储的是异常处理程序的起始地址。这个 IVT 是 16 位架构的中断处理机制，和 IDT 不同。</li>
</ul>
<p><strong>进入保护模式（Protected Mode）或长模式（Long Mode）时：</strong> </p>
<ul>
<li>当系统进入保护模式后，操作系统需要配置自己的 IDT，因为保护模式支持更复杂的中断和异常处理。</li>
<li>操作系统初始化过程中会：<ol>
<li>分配一块内存用于存储 IDT。</li>
<li>填充 IDT 条目（包括中断号、处理程序地址、权限等）。</li>
<li>使用 <code>lidt</code> 指令加载 IDT 的基址和限制到 CPU。</li>
</ol>
</li>
</ul>
<p>BIOS 可通过 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/BIOS%E4%B8%AD%E6%96%B7%E5%91%BC%E5%8F%AB">BIOS 中断调用</a>为 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MS-DOS">MS-DOS</a> 操作系统及 MS-DOS 程序提供磁盘、键盘、显示等标准服务。通过 BIOS 中断调用访问视频硬件非常缓慢。许多现代操作系统（如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Windows">Windows</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Linux">Linux</a>）的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%95%9F%E5%8B%95%E7%A8%8B%E5%BC%8F">启动程序</a>(Bootloader)会使用 BIOS 中断调用加载内核，然后由<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8">内核</a>将处理器从16位<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9C%9F%E5%AF%A6%E6%A8%A1%E5%BC%8F">实模式</a>转换到32位<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%9D%E8%AD%B7%E6%A8%A1%E5%BC%8F">保护模式</a>（或64位<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%95%BF%E6%A8%A1%E5%BC%8F">长模式</a>）</p>
<p>在INTEL后续的32位CPU中，使用中断描述符表 IDT 来代替中断向量表 IVT。中断描述符表的起始地址由中断描述符表寄存器（IDTR）来定位，因此不再限于底部1K位置。另一方面，中断描述符表的每一个项目——称作门描述符——除了含有中断处理程序地址信息外，还包括许多属性／类型位。门描述符分为三类：任务门、中断门和自陷门。CPU对不同的门有不同的调用（处理）方式。</p>
<h4 id="硬件初始化"><a href="#硬件初始化" class="headerlink" title="硬件初始化"></a>硬件初始化</h4><p>硬件初始化工作是通过 BIOS 中断调用实现的，经过POST检测后，电脑终于出现了开机启动画面，这就是已经检测到了显卡并完成了初始化。但是请注意，由于BIOS是在16位实模式运行，因此该画面是以VGA分辨率（640*480，纵横比 4:3）显示的，因为实模式最高支持的就是 VGA。以前的小 14-17 寸CRT显示器由于都是 4:3 比例，最高分辨率也比较低，因此这个开机启动画面没有什么违和感，但现在的液晶显示器基本上都是宽屏 16:9 的，分辨率也较高，因此在这样的显示屏下，启动画面上的一切东西显示都可以说“惨不忍睹”——图形被拉长，字体很大很模糊，可以很明显看到显示字体的锯齿。</p>
<h3 id="Bootloader-位置"><a href="#Bootloader-位置" class="headerlink" title="Bootloader 位置"></a>Bootloader 位置</h3><p>引导启动的过程也是使用 BIOS 中断调用，因为 BIOS 处在实模式，Bootloader 才能切换模式</p>
<p>BIOS 根据 Setup 中用户指定的硬件启动顺序，如果将启动顺序设为“第一：DVD 驱动器；第二：硬盘驱动器”，固件会先尝试从 DVD 驱动器启动，再尝试从本地的硬盘驱动器启动。BIOS 负责硬件和软件间的相互通信。如果发现所有硬件都没有能引导操作系统的记录，则会在屏幕上显示相应错误信息（NO ROM BASIC）将电脑维持在 16 位实模式。BIOS 只识别到由主引导记录（MBR）初始化的硬盘。</p>
<h4 id="MBR：主引导扇区"><a href="#MBR：主引导扇区" class="headerlink" title="MBR：主引导扇区"></a>MBR：主引导扇区</h4><p>主引导扇区，Master Boot Record，BIOS 检查时会把硬盘最初一个扇区(MBR)加载到内存中。</p>
<p>它在硬盘上的三维地址(CHS 地址)为（柱面，磁头，扇区）＝（0，0，1）</p>
<p>MBR 位于磁盘的第一个扇区（LBA 0），其大小为 <strong>512 字节</strong>，划分如下：</p>
<ul>
<li><strong>前 446 字节</strong>: 引导代码（Bootloader Code）</li>
<li><strong>接下来的 64 字节</strong>: 分区表（DPT, Disk Partition Table），记录最多 4 个主分区的信息</li>
<li><strong>最后的 2 字节</strong>: 魔数（Signature, 0x55AA），表示这是一个有效的 MBR。</li>
</ul>
<p>BIOS 硬件检查方式：这个存储设备的前 512 字节是不是以0x55 0xAA(10101010,01010101)结尾？如果不是就按照顺序检查下一个，如果是就加载这 512 字节内部的引导代码，然后执行它。</p>
<p>MBR 最开头是第一阶段引导代码。主要作用是在检查分区表是否正确和在系统硬件完成自检以后，在活跃分区的 PBR 找到并执行 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F">Bootloader</a> 主程序（如 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GNU_GRUB">GNU GRUB</a>），不依赖任何操作系统，而且启动代码也是可以改变的，从而能够实现<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%9A%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC&action=edit&redlink=1">多系统引导</a>  </p>
<p>MBR 还记录着硬盘本身的相关信息以及硬盘各个分区的大小及位置信息（分区表），是数据信息的重要入口。如果它受到破坏，硬盘上的基本数据结构信息将会丢失，需要用繁琐的方式试探性的重建数据结构信息后才可能重新访问原先的数据。因为 512B 的限制，分区表也有限制，MBR 支持最大卷为2 TB（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Terabyte">Terabyte</a>s）并且每个磁盘最多有4个主分区（或3个主分区，1个扩展分区和无限制的逻辑驱动器）</p>
<h4 id="扇区与逻辑块地址（Sector-amp-LBA）"><a href="#扇区与逻辑块地址（Sector-amp-LBA）" class="headerlink" title="扇区与逻辑块地址（Sector &amp; LBA）"></a>扇区与逻辑块地址（Sector &amp; LBA）</h4><p>在 GPT 分区中，每一个数据读写单元成为 LBA（逻辑块地址），一个“逻辑块”相当于传统 MBR 分区中的一个“扇区”，之所以会有区别，是因为GPT除了要支持传统硬盘，还需要支持以 NAND FLASH 为材料的 SSD 硬盘。</p>
<p>不像磁盘那样有磁片，而磁片又划分磁道和扇区来保存数据，因此，闪存材料需要采用模拟扇区来保持统一性。这些硬盘的一个读写单元是 2KB 或 4KB，所以，GPT 分区中干脆用 LBA 来表示一个基础读写块，当 GPT 分区用在传统硬盘上时，通常，LBA 就等于扇区号，有些物理硬盘支持 2KB 或 4KB 对齐，此时，LBA 所表示的一个逻辑块就是 2KB的空间，为了方便，我们后面仍然将逻辑块称为扇区。</p>
<p>以 CHS 寻址的硬盘， 最高容量是 512×63×256×1024=8064 MiB，BIOS 使用的是 LBA 寻址</p>
<h2 id="UEFI"><a href="#UEFI" class="headerlink" title="UEFI"></a>UEFI</h2><p>作为 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/BIOS">BIOS </a>的替代方案，可扩展固件接口 UEFI 负责 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E9%9B%BB%E8%87%AA%E6%AA%A2">加电自检</a>（POST）、联系操作系统以及提供连接操作系统与硬件的接口。前身是 EFI</p>
<h3 id="EFI"><a href="#EFI" class="headerlink" title="EFI"></a>EFI</h3><p>虽然 BIOS 作为电脑加电启动所必不可少的部分，但是从其于 1975 年诞生之日起近 30 余年，16 位汇编语言代码，1 M 内存寻址，调用中断一条条执行的理念和方式竟然一点都没有改变，虽然经各大主板商不懈努力，BIOS 也有了 ACPI、USB 设备支持，PnP 即插即用支持等新东西，但是这在根本上没有改变 BIOS 的本质，而英特尔为了迁就这些旧技术，不得不在一代又一代处理器中保留着 16 位实模式，否则根本无法开机。英特尔推出了可扩展固件接口(EFI, Extensible Filmware Interface) 和后继的 UEFI(Unified EFI) ，是现在电脑的主要预启动环境。</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol>
<li>摒弃 16 位实模式，完全是 32 位或 64 位模式，在 EFI 中可以实现处理器的最大寻址，因此可以在任何内存地址存放任何信息</li>
<li>模块化，C 语言风格的参数堆栈传递方式，动态链接的形式构建的系统，通用性和兼容性较好，在 EFI 驱动环境(DXE)中解释执行 EFI 字节码（虚拟机器指令）写成的 EFI 驱动，识别系统硬件并完成硬件初始化。EFI 的驱动开发非常简单，基于 EFI 的驱动模型原则上可以使 EFI 接触到所有硬件功能</li>
<li>和 OS 相比，EFI 没有中断访问机制，只能轮询</li>
<li>只有简单的存储器管理机制，在段保护模式下只将存储器分段，所有程序都可以存取任何一段位置，不提供真实的保护服务。</li>
<li>支持 GPT 分区模式</li>
<li>区分不同的开机模式，向前兼容模式(Legacy) 可以启动 16 和 32 位的操作系统，采用64位UEFI固件的PC，在UEFI 开机模式下只能执行64位操作系统启动程序</li>
</ol>
<h4 id="GPT：全局唯一表示分区表"><a href="#GPT：全局唯一表示分区表" class="headerlink" title="GPT：全局唯一表示分区表"></a>GPT：全局唯一表示分区表</h4><p><strong>全局唯一标识分区表</strong> GUID Partition Table，使用通用唯一标识符(也称为全局唯一标识符(GUID))对物理计算机存储设备(例如硬盘驱动器或固态驱动器)的分区表进行布局</p>
<p>在MBR硬盘中，分区信息直接存储于主引导扇区中（其中还存储着引导 Bootloader 的引导代码）但在GPT硬盘中，分区表的位置信息储存在GPT头中。出于兼容性考虑，硬盘的第一个扇区仍然用作 MBR，之后才是 GPT 头。为了减少分区表损坏的风险，GPT在硬盘最后保存了一份分区表的副本。其中的 EFI 系统分区可以被 EFI 存取，用来存取部分驱动和应用程序。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1024px-GUID_Partition_Table_Scheme.svg.png" alt="undefined" style="zoom: 33%;" />

<p>GPT分区表的结构。此例中，每个逻辑块（LBA）为512字节，每个分区的记录为128字节。负数的LBA地址表示从最后的块开始倒数，−1表示最后一个块。</p>
<p><strong>保护性 MBR（Protective MBR）</strong></p>
<ul>
<li><strong>位置</strong>: 分区表的第一个扇区（LBA 0）。</li>
<li><strong>作用</strong>: 这是兼容性区域，用于保护 GPT 磁盘免受旧式 MBR 工具的意外覆盖。保护性 MBR 声明整个磁盘为一个分区，以阻止不支持 GPT 的软件误将磁盘视为未分区。</li>
</ul>
<p><strong>GPT 标头（GPT Header）</strong> </p>
<ul>
<li><strong>位置</strong>: 磁盘的第一个逻辑块地址（LBA 1）。</li>
<li><strong>作用</strong>: 包含 GPT 的全局信息，包括分区表的起始位置、大小和校验和。</li>
</ul>
<p><strong>分区条目表（Partition Entries）</strong></p>
<ul>
<li><strong>位置</strong>: 通常从 LBA 2 开始，连续占用一定数量的扇区。</li>
<li><strong>作用</strong>: 存储每个分区的详细信息，包括分区类型、GUID、起始和结束地址。</li>
</ul>
<p><strong>引导分区（EFI System Partition, ESP）</strong></p>
<ul>
<li><strong>位置</strong>: 通常是 GPT 分区中专门指定的一部分（由 EFI 分区条目指定）</li>
<li><strong>作用</strong>: 用于存储 Bootloader EFI 文件、操作系统引导管理器，以及其他必要的启动文件。EFI 系统分区可以位于任何地方，只要分区条目中有正确的指向即可。实际上是一个FAT32文件系统</li>
<li><strong>固定 GUID</strong>: <code>C12A-7328-F81F-11D2-BA4B-00A0-C93E-C93B</code></li>
</ul>
<p><strong>备份 GPT 数据</strong></p>
<ul>
<li><strong>位置</strong>: 通常在磁盘的最后几个逻辑块地址（倒数第一个扇区存储备份 GPT Header，倒数第二个扇区起存储备份分区条目）。</li>
<li><strong>作用</strong>: 用于恢复主 GPT 数据结构。</li>
</ul>
<h4 id="UEFI-做的优化"><a href="#UEFI-做的优化" class="headerlink" title="UEFI 做的优化"></a>UEFI 做的优化</h4><ol>
<li>拥有完整的图形驱动。EFI多数还是一种类DOS界面（仍然是640*480VGA分辨率），只支持PS/2键盘操作（极少数支持鼠标操作）。无论是PS/2还是USB键盘和鼠标，UEFI一律是支持的，而且UEFI在显卡也支持GOP VBIOS的时候，显示的设置界面是显卡高分辨率按640*480或1024*768显示</li>
<li>安全启动。固件验证：根据硬件签名对各硬件判断，只有符合认证的硬件驱动才会被加载</li>
</ol>
<h3 id="Pre-booting-1"><a href="#Pre-booting-1" class="headerlink" title="Pre-booting"></a>Pre-booting</h3><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Efi_flowchart_extended.jpg" alt="undefined" style="zoom: 67%;" />

<h4 id="POST：加电自检-1"><a href="#POST：加电自检-1" class="headerlink" title="POST：加电自检"></a>POST：加电自检</h4><p>当打开电源开关时，电脑的主要部件都开始有了供电，与 BIOS 不同的是，UEFI 预加载(Pre-EFI)环境首先开始执行，负责 CPU 和内存（是全部容量）的初始化工作，这里如出现重要问题，电脑即使有报警喇叭也不会响，因为 UEFI 没有去驱动 8255 发声，不过预加载环境只检查 CPU 和内存，如果这两个主要硬件出问题，屏幕没显示可以立即确定，另外一些主板会有提供LED提示，可根据CPU或内存亮灯大致判断故障。</p>
<h4 id="硬件初始化-1"><a href="#硬件初始化-1" class="headerlink" title="硬件初始化"></a>硬件初始化</h4><p>CPU 和内存初始化成功后，驱动执行环境（DXE）载入，当 DXE 载入后，UEFI 就具有了逐个加载UEFI 驱动的能力，在此阶段，UEFI 会迭代搜索各个硬件的 UEFI 驱动并相继加载，加载各种总线（包括PCI、SATA、USB、ISA）及硬件的 UEFI 驱动程序，完成硬件初始化工作，这相比 BIOS 的中断速度会快的多，同样如加载显卡的 UEFI 驱动成功，电脑也会出现启动画面，硬件驱动全部加载完毕后，最后同 BIOS 一样，去寻找硬盘上的操作系统的引导启动程序。</p>
<p>UEFI 应用程序（UEFI Application）和 UEFI 驱动程序（UEFI driver）是 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E5%8F%AF%E6%89%A7%E8%A1%8C">PE格式</a> 的<code>.efi</code>文件，可用C语言编写。</p>
<h3 id="Bootloader-位置-1"><a href="#Bootloader-位置-1" class="headerlink" title="Bootloader 位置"></a>Bootloader 位置</h3><p>UEFI 引导管理程序可以直接从支持的文件系统（如FAT32）中读取启动文件，而不依赖硬件中断和传统的16位服务调用，UEFI 整体就处在保护模式或者长模式下。</p>
<p>在启动操作系统的阶段，同样是根据启动记录的启动顺序，转到相应设备（GPT）引导记录，引导操作系统并进入，在 UEFI 开机模式下，Bootloader 本身也是 UEFI 应用程序，其 EFI 文件存储在 EFI 系统分区（ESP）</p>
<p>这里需要注意的是，UEFI 在检测到无任何操作系统启动设备时，会直接进入 UEFI 设置页面，而不是像 BIOS 那样黑屏显示相关信息。</p>
<p>如果启动传统 MBR 设备，则需要打开 CSM 支持。</p>
<h2 id="Legacy-MBR"><a href="#Legacy-MBR" class="headerlink" title="Legacy + MBR"></a>Legacy + MBR</h2><p><strong>MBR+Legacy</strong> 是通过引导代码指向 <strong>Bootloader</strong> 文件.</p>
<ul>
<li><p><strong>Windows</strong>: </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1460000020850912-1734487610917-44.png" alt="image"></p>
<ul>
<li><p>Windows 中根据 MBR 分区表指向活跃分区记录 PBR，这里启动系统用的分区和真正装系统的分区不一定在一起，Windows 的 PBR 可以识别 FAT32 和 NTFS 两种分区，找到分区根目录的 bootmgr 文件，并加载、执行 bootmgr。</p>
</li>
<li><p>bootmgr 没有 MBR 和 PBR 的大小限制，可以做更多的事，它会加载并分析BCD启动项存储，而且 bootmgr 可以跨越磁盘读取文件。所以无论我们有几个磁盘，在多少块磁盘上装了 Windows，一个电脑只需要一个 bootmgr 就行了。bootmgr 会去加载某磁盘某 NTFS 分区的 <code>\Windows\System32\WinLoad.exe</code>，然后，由 <code>WinLoad.exe</code> 启动 Windows (<code>ntoskrnl.exe</code>) 系统分区和启动分区可能不是位于同一分区。</p>
</li>
</ul>
</li>
<li><p>Linux:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/v2-709d9b2f76d718894bcc04c706986fcf_1440w-1734485433191-9-1734487325852-39-1734487632482-49.jpg" alt="img"></p>
<ul>
<li><p>写入 0 号扇区的 446 字节是第一阶段，其作用就是用来找到和加载真正的Grub bootloader主程序，也就是位于操作系统启动分区的Grub2第二阶段的程序。而且受限于446字节的大小，这个阶段的stage1 binary是不包含文件系统功能 对应 boot.img</p>
</li>
<li><p>被加载Stage1加载后，解析/boot/grub2/grub.cfg配置文件，跟据该配置文件的定义，显示多系统的启动选择界面，或者直接加载Linux kernel和文件系统，然后就由Kernel来启动后续的过程。Grub2 Stage2的镜像对应于core.img，位置为/boot/grub2/i386-pc目录下。</p>
</li>
</ul>
</li>
</ul>
<h2 id="UEFI-GPT"><a href="#UEFI-GPT" class="headerlink" title="UEFI + GPT"></a>UEFI + GPT</h2><p>**GPT+UEFI **没有明显的引导代码指向 Bootloader EFI 文件</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1460000020850915.png" alt="image"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1460000020850916-1734486587950-27.png" alt="image"></p>
<p>GPT 直接把 Bootloader 存到 EFI 分区</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>MBR + Legacy</th>
<th>GPT + UEFI</th>
</tr>
</thead>
<tbody><tr>
<td>代码位置</td>
<td>磁盘第一个扇区 (LBA 0)</td>
<td>EFI 分区</td>
</tr>
<tr>
<td>引导文件</td>
<td>BIOS 引导代码</td>
<td>支持 EFI 格式文件 (.efi)</td>
</tr>
<tr>
<td>机制</td>
<td>根据引导代码启动 Bootloader</td>
<td>UEFI 直接去读取并运行 Bootloader</td>
</tr>
<tr>
<td>代码大小</td>
<td>446 字节 非 Bootloader 本身</td>
<td>Bootloader，上限取决于 EFI 分区大小</td>
</tr>
<tr>
<td>Bootloader</td>
<td>MBR 同时存储分区表和引导代码，Bootloader 在其他位置</td>
<td>GPT 分区表 存储分区信息，ESP 分区直接存储 Bootloader</td>
</tr>
</tbody></table>
<p>Legacy 无法识别 GPT 分区表格式，所以也就没有 Legacy + GPT 组合方式。</p>
<p>UEFI 可同时识别 MBR 分区(开启 CSM 模式)和 GPT 分区，所以在 UEFI 下，MBR 和 GPT 磁盘都可用于启动操作系统。不过由于微软限制，UEFI 下使用 Windows 安装程序安装操作系统是只能将系统安装在 GPT 磁盘中。</p>
<h1 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h1><p>加载到 RAM 中的第一个程序可能不足以加载操作系统，而必须加载另一个更大的程序。第一个加载到 RAM 中的程序称为第一阶段引导加载程序（BIOS、UEFI），它加载的程序称为第二阶段引导加载程序（狭义上的 Bootloader）</p>
<p>Bootloader 有 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/GNU_GRUB">GNU GRUB</a>、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/REFInd">rEFInd</a>、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SYSLINUX">Syslinux</a>、Windows 的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/BOOTMGR">BOOTMGR</a>、 和 Windows NT/2000/XP 的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NTLDR">NTLDR</a> 等，它们本身不是操作系统，但能够正确加载操作系统并将 CPU 控制权转移到它;操作系统随后会自行初始化并可能加载额外的设备驱动程序。</p>
<p>Bootloader 不需要驱动程序来进行自身操作，可以使用系统固件（例如 BIOS、UEFI 或开放固件）提供的通用存储访问方法，但通常硬件功能有限且性能较低。</p>
<p>许多 Bootloader 可以配置为给用户提供多种引导选择。这些选择可以包括不同的操作系统（用于从不同分区或驱动器进行双重或多重引导）、同一操作系统的不同版本（以防新版本出现意外问题）、不同的操作系统加载选项（例如，引导至不同的操作系统）、安全模式），以及一些无需操作系统即可运行的独立程序，例如内存测试程序（例如 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memtest86%2B">memtest86+</a>）、基本 shell（如 GNU GRUB 中），甚至游戏。</p>
<p>一些 Bootloader 可以加载其他 Bootloader，例如，GRUB 可以加载 BOOTMGR 而不是直接加载 Windows。通常，默认选择是预先选择的，并有一定的时间延迟，在此期间用户可以按某个键来更改选择；在此延迟之后，默认选择将自动运行，因此无需交互即可正常启动。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/01/05/408-%E8%AE%A1%E7%BD%91-%E7%BD%91%E7%BB%9C%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/05/408-%E8%AE%A1%E7%BD%91-%E7%BD%91%E7%BB%9C%E5%B1%82/" class="post-title-link" itemprop="url">网络层</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-05 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-05T00:00:00+08:00">2025-01-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:31:17" itemprop="dateModified" datetime="2025-05-05T11:31:17+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h1><h2 id="家用无线路由器组网示意图"><a href="#家用无线路由器组网示意图" class="headerlink" title="家用无线路由器组网示意图"></a>家用无线路由器组网示意图</h2><p>通过ADSL或者FTTx与ISP相连</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241124141658211.png" alt="image-20241124141658211"></p>
<h2 id="网络层提供不可靠的传输服务"><a href="#网络层提供不可靠的传输服务" class="headerlink" title="网络层提供不可靠的传输服务"></a>网络层提供不可靠的传输服务</h2><h3 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h3><p>先建立起虚电路（Virtual Circuit）通过虚电路的存储转发搭配可靠的协议建立起可靠的服务。</p>
<h3 id="无连接的数据报服务"><a href="#无连接的数据报服务" class="headerlink" title="无连接的数据报服务"></a>无连接的数据报服务</h3><p>因为计算机本身有强大的计算功能，因此完全可以将可靠的传输交给终端主机本身去做，网络层设计得尽量简单，向上提供简单的，无连接的，尽最大努力交付的数据报服务(datagram/packet) 不保证分组一定到达，到达也不保证顺序就是发送的顺序。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/91fbdd548f6b4e86d639649f7aae4c30.jpg" alt="91fbdd548f6b4e86d639649f7aae4c30"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/87d7a972d7095f0f2bcf894527d05dd1.jpg" alt="87d7a972d7095f0f2bcf894527d05dd1"></p>
<h2 id="网络层的两个层面"><a href="#网络层的两个层面" class="headerlink" title="网络层的两个层面"></a>网络层的两个层面</h2><ul>
<li><strong>控制层面</strong>：负责维护路由表，和其他路由节点进行路由数据交互。典型协议就是各种路由选择协议（OSPF、BGP）</li>
<li><strong>数据层面</strong>：负责根据路由表将 分组/数据报 转发到其他路由器。典型协议就是IP</li>
<li><strong>SDN</strong>：软件定义网络，将控制层面用一个远程控制器实现，路由器只需要做转发数据报的工作就可以了。</li>
</ul>
<h1 id="IP（Internet-Protocol）"><a href="#IP（Internet-Protocol）" class="headerlink" title="IP（Internet Protocol）"></a>IP（Internet Protocol）</h1><p>各个局域网通过路由器相互连接称为一个虚拟的互联网，internet</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/internet_protocol_ip_address_diagram.png" alt="IP 地址使数据包到达其目的地"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/256851fcb6cde44eb5d73863a00da8b2-1732450187866-2.jpg" alt="256851fcb6cde44eb5d73863a00da8b2"></p>
<h2 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h2><p>IPv4 32位 有网络号和主机号两个部分，网络号唯一标识互联网中的一个网络，主机号表示网络中的一台设备（网络号+主机号才能唯一确定一台设备）</p>
<h3 id="ABC-分类地址"><a href="#ABC-分类地址" class="headerlink" title="ABC 分类地址"></a>ABC 分类地址</h3><p>网络号分别是前8位，前16位，前24位，随着互联网用户暴涨，固定的分类方法显然已经无法满足需求。</p>
<h3 id="无类别域间路由-Classless-Inter-Domain-Routing-CIDR"><a href="#无类别域间路由-Classless-Inter-Domain-Routing-CIDR" class="headerlink" title="无类别域间路由(Classless Inter-Domain Routing,==CIDR==)"></a>无类别域间路由(Classless Inter-Domain Routing,==<strong>CIDR</strong>==)</h3><ul>
<li>不采用固定分类的做法，把网络前缀的位数放到最后。</li>
<li>网络前缀完全相同的处于同一个CIDR地址块中。</li>
<li>128.14.35.7/20 表示网络号是前20位。</li>
<li>原先的分类地址法只能分出3级8/16/24，较为死板和浪费，B类地址也无法表示C类地址，导致路由表的膨胀。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.0/24</span><br><span class="line">192.168.1.0/24</span><br><span class="line">192.168.2.0/24</span><br></pre></td></tr></table></figure>

<ul>
<li>路由聚合：这3个地址块可以用192.168.0.0/22概括起来，多个子网的地址具有相同的前缀，便于聚合。</li>
</ul>
<h3 id="子网掩码（subnet-mask）"><a href="#子网掩码（subnet-mask）" class="headerlink" title="子网掩码（subnet mask）"></a>子网掩码（subnet mask）</h3><p>告诉计算机网络前缀的位数，128.14.35.7/20的子网掩码是255.255.240.0（二进制比点分十进制更加直观）子网掩码和主机的IP地址进行按位与运算结果即为网络地址。子网是在一个IP网络中划分子网使我们能将一个至少从逻辑上看上去单一的大型网络分成若干个较小的网络。而主机必须知道自己的IP地址，也要知道自己处于哪一个网段，因此mask就诞生了</p>
<h3 id="Facts-about-IP-address"><a href="#Facts-about-IP-address" class="headerlink" title="Facts about IP address"></a>Facts about IP address</h3><ul>
<li>IP地址实质上是对接口指派地址，路由器有多个接口，说明接入到多个网络中，准确转发到多个网络中需要根据IP。</li>
<li>同一局域网的主机IP网络前缀相同，网络地址的主机号必须全0。</li>
<li>路由器必须处在不同网络中，必须有大于等于2个IP地址，两台交换机互连仍在同一网络中。</li>
<li>交换机只有MAC地址，没有IP地址。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241124133937330.png" alt="image-20241124133937330"></p>
<h3 id="匿名网络（Anoymous-Unnumbered-Network）"><a href="#匿名网络（Anoymous-Unnumbered-Network）" class="headerlink" title="匿名网络（Anoymous/Unnumbered Network）"></a>匿名网络（Anoymous/Unnumbered Network）</h3><ul>
<li><p>从网络层的严格定义来说，<strong>网络层主要负责不同网络之间的路由和转发</strong>。路由器用了几个接口就表示接到几个网络</p>
</li>
<li><p>即使路由器间直接相连，也需要抽象为一个点对点网络（匿名网络）不过通常为了节省资源，并不分配IP地址</p>
</li>
<li><p>A为公网<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/0?fromModule=lemma_inlink">主机</a>，D为拥有公网IP的主机，通信过程为A－B－C－D，B和C用unnumbered，没有必要占用两个ip地址了，让B、C间的口借用另一边口的地址，这样B和C就只是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%93%BE%E8%B7%AF%E5%B1%82/0?fromModule=lemma_inlink">链路层</a>连接[ip unnumber_百度百科](<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ip">https://baike.baidu.com/item/ip</a> unnumber/4480818) 。如果两台路由器之间还有一个拥有主机的网络E，就必须给接口指派一个网络E的地址。</p>
</li>
</ul>
<h1 id="地址解析协议（Address-Resolution-Protocol-ARP）"><a href="#地址解析协议（Address-Resolution-Protocol-ARP）" class="headerlink" title="地址解析协议（Address Resolution Protocol, ARP）"></a>地址解析协议（Address Resolution Protocol, ARP）</h1><ul>
<li><p>网络层基于IP地址（虚拟地址），主机A有IP<del>1</del>= 192.168.38.10， 主机B有IP<del>2</del>=192.168.38.11 </p>
</li>
<li><p>下层为上层提供服务，所以上层可以不用管下层的实现细节，体现在：主机只需要一个包含源IP和目标IP的数据报即可交给网卡开始传输。实际上数据链路层的网卡要根据IP<del>2</del>解析出应该发给哪个MAC地址，以便构造以太网帧时填入目标MAC地址。<strong>ARP</strong>就提供了IP地址到MAC地址的映射。</p>
</li>
</ul>
<h2 id="ARP-高速缓存（ARP-Cache）"><a href="#ARP-高速缓存（ARP-Cache）" class="headerlink" title="ARP 高速缓存（ARP Cache）"></a>ARP 高速缓存（ARP Cache）</h2><p>这是主机中的一个映射表，缓存了IP-&gt;MAC的关系，经常动态变换，所以也叫 ARP 高速缓存</p>
<ul>
<li><p>刚刚上电，ARP Cache为空，此时就要发送一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE#ARP%E6%8A%A5%E6%96%87">ARP报文</a>（<strong>广播</strong>帧 ARP request），目标MAC地址是“FF.FF.FF.FF.FF.FF”，这表示向<strong>同一网段内</strong>的所有主机发出这样的询问：“192.168.38.11的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MAC%E5%9C%B0%E5%9D%80">MAC地址</a>是什么？” </p>
</li>
<li><p>网络内其他主机并不响应ARP询问，只有<strong>同一网段内</strong>的主机B接收到这个帧时，才向主机A做出回应（ARP response）：“192.168.38.11的MAC地址是00-BB-00-62-C2-02”，此回应以<strong>单播</strong>方式进行。</p>
</li>
<li><p>这样，主机A就知道主机B的MAC地址，它就可以向主机B发送信息。同时它还更新自己的ARP cache，下次再向主机B发送信息时，直接从ARP缓存表里查找就可。实际上，ARP Request中包含源IP和源MAC，这样B收到帧的时候就能直接写入ARP缓存，不需要多余通信</p>
</li>
<li><p>ARP Cache 会设置<strong>生存时间</strong>（Time To Live, TTL）逾期会自动删除，给新的映射关系留下空间（因为可能有的网卡坏了MAC地址也换了，IP地址因为是软件地址，不会跟着硬件走）</p>
</li>
</ul>
<h2 id="ARP-代理（ARP-Proxy）"><a href="#ARP-代理（ARP-Proxy）" class="headerlink" title="ARP 代理（ARP Proxy）"></a>ARP 代理（ARP Proxy）</h2><p>ARP 只适用于<strong>同一局域网</strong>内部的IP到MAC的映射。<strong>不同局域网之间</strong>的通信依靠路由器，主机会把IP数据报发给自己的默认网关（也就是路由器）由于默认网关是IP地址形式，所以也要发一个ARP请求广播帧来获取<strong>路由器的MAC地址</strong>，随后将自己的IP数据报封装成以太网帧发给路由器R<del>1</del>。</p>
<p>路由器R<del>1</del>获取网帧之后经过剥离拿到IP数据报，如果目标IP恰好跟R<del>1</del>在同一个网络内，那么再次通过ARP找到目标IP的MAC地址即可。如果<strong>仍然不在同一个网络</strong>内，则需要查路由表来确定下一跳应该发到哪个网络。</p>
<p><strong>广播域隔离</strong>：路由器并不会在不同子网间转发<strong>基于MAC地址的广播帧</strong>，同样也不会转发<strong>IP广播数据报</strong>，因为这样可能会造成<strong>广播风暴</strong>，瘫痪网络。</p>
<p><strong>为什么不直接使用MAC地址通信</strong>：MAC地址相比于IP地址的劣势</p>
<ul>
<li>MAC帧格式并不统一（以太网帧、802.11帧<del>Wi-Fi</del>等）地址转换过程非常复杂，并且和硬件绑定缺乏灵活性</li>
<li>使用更高层次的抽象IP地址就可以屏蔽上述差异，灵活分配，具体由ARP协议负责找到IP对应的MAC。</li>
<li>MAC地址可轻易被伪造或篡改，而IP地址则可以结合其他协议（如防火墙和ACL）进行更复杂的安全策略。</li>
</ul>
<h1 id="IP-数据报首部（IP-Header）"><a href="#IP-数据报首部（IP-Header）" class="headerlink" title="IP 数据报首部（IP Header）"></a>IP 数据报首部（IP Header）</h1><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/d448bf2729381d8aa9f09d12f454726d.png" alt="d448bf2729381d8aa9f09d12f454726d"></p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>长度（bit）</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>版本</td>
<td>4</td>
<td>区分协议的版本 (IPv4, IPv6等)</td>
</tr>
<tr>
<td>首部长度</td>
<td>4</td>
<td>整个<strong>首部</strong>的长度，单位4字节（0101（20字节）~1111（60字节））</td>
</tr>
<tr>
<td>区分服务</td>
<td>8</td>
<td>用来获得更好的服务类型，区分服务类型才使用</td>
</tr>
<tr>
<td>总长度</td>
<td>16</td>
<td>单位字节，首部+数据的总长度，最大65536，实际上超过1500（MTU）必须分片，如果分片，则为这个数据报分片的总长度</td>
</tr>
<tr>
<td>标识</td>
<td>16</td>
<td>IP 软件给每个 IP 数据报分配的标识，属于<strong>同一个数据报的分片标识相同</strong></td>
</tr>
<tr>
<td>标志</td>
<td>3</td>
<td>0 | DF | MF (MF =  1表示还有分片，MF = 0表示最后一个分片，DF = 1不允许分片)</td>
</tr>
<tr>
<td>片偏移（Offset）</td>
<td>13</td>
<td>单位8字节，$2^{13}\times8 = 65536$，表示<strong>分片的数据</strong>在<strong>原数据</strong>中的偏移量</td>
</tr>
<tr>
<td>生存时间（TTL）</td>
<td>8</td>
<td><strong>数据报的寿命</strong>，以前单位为秒，后来变成了<strong>跳数</strong>，减少路由表配置错误导致的网络风暴</td>
</tr>
<tr>
<td>协议</td>
<td>8</td>
<td>用来标识数据部分使用的是什么协议（ICMP, UDP, TCP, OSPF 等）</td>
</tr>
<tr>
<td>首部校验和（Checksum）</td>
<td>16</td>
<td><strong>首部</strong>按照16位字划分成如上图的几行，将首部各行加和的反码填入，发送者会先置0，然后再运算，接收者会直接运算结果，如果不出错结果肯定是0</td>
</tr>
<tr>
<td>源地址</td>
<td>32</td>
<td>源 IPv4 地址</td>
</tr>
<tr>
<td>目的地址</td>
<td>32</td>
<td>目标 IPv4 地址</td>
</tr>
<tr>
<td>可变部分</td>
<td>1~40</td>
<td>用于排错、测量和安全功能，由于是可变 加重路由器的负担，可有可无，IPv6 变为定长</td>
</tr>
<tr>
<td>数据部分（Payload）</td>
<td>——</td>
<td>上层传下来的数据</td>
</tr>
</tbody></table>
<h2 id="从以太网帧中找出目的IP地址"><a href="#从以太网帧中找出目的IP地址" class="headerlink" title="从以太网帧中找出目的IP地址"></a>从以太网帧中找出目的IP地址</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241124195904437.png" alt="image-20241124195904437"></p>
<p>以太网帧有14B的头，IP的目的地址之前有16B的头，因此目的地址从第31个字节开始</p>
<h1 id="IP-转发分组过程"><a href="#IP-转发分组过程" class="headerlink" title="IP 转发分组过程"></a>IP 转发分组过程</h1><h2 id="基于终点转发：前缀匹配"><a href="#基于终点转发：前缀匹配" class="headerlink" title="基于终点转发：前缀匹配"></a>基于终点转发：前缀匹配</h2><table>
<thead>
<tr>
<th>前缀匹配</th>
<th>下一跳</th>
</tr>
</thead>
<tbody><tr>
<td>128.1.2.192/26</td>
<td>直接，接口1</td>
</tr>
<tr>
<td>128.1.2.128/26</td>
<td>直接，接口2</td>
</tr>
<tr>
<td>128.1.3.64/26</td>
<td>R<del>2</del></td>
</tr>
</tbody></table>
<p>ARP代理机制中，我们接触到了逐跳转发的概念，如果转发到第一个路由器和目标IP仍然不在一个网络，就要转发到路由表的下一跳。</p>
<p><strong>路由表</strong>：分别是网络IP地址、子网掩码和下一跳，网络地址和子网掩码确定接口在哪个网络，下一跳同样是网络的地址而不是主机的IP地址，这主要是为了防止浪费，提高转发的效率。</p>
<p><strong>匹配前缀</strong>：将子网掩码和目的地址相与 得出的网络地址匹配，则进入下一跳，否则继续匹配下一个</p>
<p>R<del>1</del>查到下一跳之后，会将下一跳IP地址传给数据链路层，用ARP解析出路由器R<del>2</del>的MAC地址。</p>
<p>因此，查找路由表的过程就是寻找前缀匹配的过程。</p>
<h2 id="查询路由表"><a href="#查询路由表" class="headerlink" title="查询路由表"></a>查询路由表</h2><h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3><p>CIDR路由聚合可以将网络前缀相同的地址块合并，初衷就是减少路由表项，但同时也减少了路由的具体性，举例：</p>
<p><code>128.1.24.0/22</code>与<code>128.1.24.0/24</code> 这两个CIDR地址块并不一致，尽管后者可以聚合到前者中，但是如果特意不聚合（比如公司B和公司A同时从ISP申请了同一网段的IP地址），放到路由表就表示不同的网段，</p>
<p><strong>128.1.24.0/24</strong>：</p>
<ul>
<li>掩码：<code>255.255.255.0</code></li>
<li>包含的地址范围：<code>128.1.24.0 ~ 128.1.24.255</code> （公司A）</li>
</ul>
<p><strong>128.1.24.0/22</strong>：</p>
<ul>
<li>掩码：<code>255.255.252.0</code></li>
<li>表面上可以包含的地址范围：<code>128.1.24.0 ~ 128.1.27.255</code> </li>
<li>实际上包含的地址范围： <code>128.1.25.0/24</code>, <code>128.1.26.0/24</code>, <code>128.1.27.0/24</code> (公司B)</li>
<li>为了节省空间，使用路由聚合将公司B的3个地址块聚合成1个大地址块</li>
</ul>
<p>多个前缀匹配成功（精确和模糊网段同时出现在路由表），模糊网段实际上并没有包括这个精确网段，路由器采取的原则是 <strong>最长前缀匹配</strong> ，如果不这样做，会被错误路由到模糊的网段，找不到目标。</p>
<p>为了方便这个实践这个原则，路由表会按照前缀长度进行排序，越长防越靠前，避免发生错误多余的查找。</p>
<p>路由表中还有两个特殊的可选路由项：</p>
<h3 id="主机路由（host-route）"><a href="#主机路由（host-route）" class="headerlink" title="主机路由（host route）"></a>主机路由（host route）</h3><p>前缀长度是32位，直接定位到一台主机，目标IP和主机路由相同，则直接认定匹配，网络测试比较方便，免去地址聚合带来的不确定性</p>
<h3 id="默认路由（default-route）"><a href="#默认路由（default-route）" class="headerlink" title="默认路由（default route）"></a>默认路由（default route）</h3><p><strong>网络前缀</strong>：</p>
<ul>
<li><code>0.0.0.0</code>：表示网络地址是 0。</li>
<li><code>/0</code>：表示前缀长度是 0 位，也就是说没有固定的前缀，所有 IP 地址的前缀都可以匹配它。</li>
</ul>
<p><strong>含义</strong>：</p>
<ul>
<li>默认路由是路由表中的一个“兜底规则”。</li>
<li>当某个目标地址不匹配任何其他路由条目时，数据包会被转发到默认路由指向的下一跳（指定的网关）。</li>
<li>适用于对外连接较少的路由器（比如这个路由器不直接跟外网连接，而是通过另一个网关）</li>
</ul>
<p>当路由表中存在更精确的匹配（如 <code>/24</code> 或 <code>/16</code>），则优先使用更精确的匹配；只有当没有其他匹配时，才使用默认路由。这个可以减少路由表的条数，提高单个路由表的查询性能。</p>
<h1 id="网际控制报文协议（ICMP）"><a href="#网际控制报文协议（ICMP）" class="headerlink" title="网际控制报文协议（ICMP）"></a>网际控制报文协议（ICMP）</h1><h2 id="ICMP报文种类"><a href="#ICMP报文种类" class="headerlink" title="ICMP报文种类"></a>ICMP报文种类</h2><h3 id="差错报告报文"><a href="#差错报告报文" class="headerlink" title="差错报告报文"></a>差错报告报文</h3><ul>
<li><p>终点不可达：路由器或主机无法交付数据报时向源点发送destination unreachable，比如UDP数据包目标是一个不存在的端口</p>
<ul>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241126195147654.png" alt="image-20241126195147654"></li>
</ul>
</li>
<li><p>时间超过：TTL归零，路由器要丢弃数据报，并向源点发送time exceeded</p>
</li>
<li><p>参数问题：IP首部出错，BAD IP HEADER</p>
</li>
<li><p>改变路由：路由器发现了更好的路由，遂向主机发送redirecting，改变默认路由</p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241125220916277.png" alt="image-20241125220916277"></p>
<p>ICMP的数据部分包括IP数据报首部，和IP数据负载的前8字节（UDP，TCP的目标端口和源端口，TCP报文段的发送序列号）</p>
<h3 id="询问报文"><a href="#询问报文" class="headerlink" title="询问报文"></a>询问报文</h3><ul>
<li>回送请求、回送回答：向特定主机发送的询问，收到回答用来测试可达和主机状态</li>
<li>时间戳请求、时间戳回答：利用时间戳可以计算往返时间</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h3><p>Packet InterNet Gopher ，应用层直接调用网络层的一个例子，向节点连续发送ICMP回送请求报文，可以计算出往返时间，统计出丢失的分组数（不知道原因）</p>
<p>ECHO REQUEST(8)    ECHO REPLY(0)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241125221744772.png" alt="image-20241125221744772"></p>
<h4 id="socket编程实现"><a href="#socket编程实现" class="headerlink" title="socket编程实现"></a>socket编程实现</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/eb0963a11439dff361dbe0e7a8876abd.png" alt="图片"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241126203039467.png" alt="image-20241126203039467"></p>
<p>UNIX系统编程实现中，计算机传输层以下比较底层的部分通过socket接口封装起来，调用比较方便，socket编程接口就是应用程序访问网络，操作网卡的方式。</p>
<p>创建socket套接字时有不同的参数，可以选择基于字节流（TCP）/数据报（UDP），另外一个方面，还可以选择协议TCP UDP 或者ICMP，这样socket</p>
<p>在 TCP 传输中创建的方式是 <code>socket(AF_INET, SOCK_STREAM, 0)</code> 其中 <code>AF_INET</code> 表示将使用 IPV4 里 host:port 的方式去解析待会你输入的网络地址。<code>SOCK_STREAM</code> 是指使用面向字节流的 TCP 协议，工作在传输层。 创建好了 socket 之后，就可以愉快的把要传输的数据写到这个文件里。调用 socket 的<code>sendto</code>接口的过程中进程会从用户态进入到内核态，最后会调用到 <code>sock_sendmsg</code> 方法。 然后进入传输层，带上TCP头。网络层带上IP头，数据链路层带上 MAC头等一系列操作后。进入网卡的发送队列 ring buffer ，顺着网卡就发出去了。 回到 ping ， 整个过程也基本跟 TCP 发数据类似，差异的地方主要在于，创建 socket 的时候用的是 <code>socket(AF_INET,SOCK_RAW,IPPROTO_ICMP)</code>，<code>SOCK_RAW</code> 是原始套接字 ，工作在网络层， 所以构建ICMP（网络层协议）的数据，是再合适不过了。ping 在进入内核态后最后也是调用的 <code>sock_sendmsg</code> 方法，进入到网络层后加上ICMP和IP头后，数据链路层加上MAC头，也是顺着网卡发出。        </p>
<p>因此 本质上ping 跟 普通应用发消息 在程序流程上没太大差别。 这也解释了<strong>为什么当你发现怀疑网络有问题的时候，别人第一时间是问你能ping通吗？</strong>因为可以简单理解为ping就是自己组了个数据包，让系统按着其他软件发送数据的路径往外发一遍，能通的话说明其他软件发的数据也能通。</p>
<h4 id="PING-127-0-0-1"><a href="#PING-127-0-0-1" class="headerlink" title="PING 127.0.0.1"></a>PING 127.0.0.1</h4><p>PING localhost 127.0.0.1 本机IP都会走回环路径</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/c1019a8be584b27c4fc8b8abda9d3cf1.png" alt="图片"></p>
<p>The local network card is actually a “fake network network card”. It does not have a <strong>ring buffer</strong> like the “real network card”. The “fake network card” will push data into a linked list called <code>input_pkt_queue</code>. This linked list is actually shared by <strong>all</strong> network cards, and contains various messages sent to this machine. After the message is sent to this linked list, a soft interrupt will be triggered。</p>
<p>0.0.0.0 ping不通，不过服务器listen0.0.0.0表示监听所有目标地址</p>
<h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><ol>
<li>记录路由路径和路由时间</li>
<li>确定链路的MTU</li>
</ol>
<p>连续发送多个数据报(含有目标端口非法的UDP数据报)，TTL从1开始递增，路由器减TTL并准备转发，此时看到TTL归零就会向源点发送ICMP <strong>时间超过</strong> 差错报告报文，能够记录路由的路径，如果路由到目标主机，目标主机不会继续转发，也不会减TTL，看到UDP数据报不合法向源点发送ICMP <strong>终点不可达</strong> 差错报告报文。</p>
<p>每个TTL会发送3个相同数据报</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241125221948199.png" alt="image-20241125221948199"></p>
<p>第二个作用：<strong>故意设置不分片，从而确定路径的 MTU</strong>。</p>
<p>First, when the sending host sends an IP datagram, it sets the DF(Don’t Fragment) flag bit in the IP packet header to 1. According to this flag, routers on the way will not fragment large data packets, but will <strong>discard</strong> the packets.</p>
<p>Subsequently, the value of the <strong>MTU on the data link</strong> is sent to the sending host through an ICMP unreachable message. The type of the unreachable message is “Fragmentation is required but the DF-bit is set.”</p>
<p>Each time the sending host receives an ICMP error message, it reduces the packet size to locate an appropriate MTU value so that it can reach the target host.</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241126195846876.png" alt="image-20241126195846876"></p>
<h1 id="网际分组管理协议（IGMP）"><a href="#网际分组管理协议（IGMP）" class="headerlink" title="网际分组管理协议（IGMP）"></a>网际分组管理协议（IGMP）</h1><h2 id="一对多通信"><a href="#一对多通信" class="headerlink" title="一对多通信"></a>一对多通信</h2><h3 id="IP-单播（Unicast）"><a href="#IP-单播（Unicast）" class="headerlink" title="IP 单播（Unicast）"></a>IP 单播（Unicast）</h3><p>单播是点对点通信，一台设备直接与另一台设备通信。数据包通过网络传输到特定的目标地址。</p>
<p><strong>特点</strong></p>
<ul>
<li>每个数据包有唯一的目标 IP 地址。</li>
<li>用于一对一的通信场景。</li>
<li>网络负载低，目标明确。</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>普通的网页浏览、邮件通信等。</li>
<li>服务器与客户端的直接通信。</li>
</ul>
<p><strong>示例</strong><br>一台电脑向服务器（如 192.168.1.1）请求网页内容。</p>
<h3 id="IP-广播（Broadcast）"><a href="#IP-广播（Broadcast）" class="headerlink" title="IP 广播（Broadcast）"></a>IP 广播（Broadcast）</h3><table>
<thead>
<tr>
<th>网络号</th>
<th>主机号</th>
<th>源地址使用</th>
<th>目的地址使用</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>OK</td>
<td>NO</td>
<td>本网络的本主机，用于 DHCP，此时本主机 IP 未知</td>
</tr>
<tr>
<td>0</td>
<td>X</td>
<td>OK</td>
<td>NO</td>
<td>本网络的 X 主机</td>
</tr>
<tr>
<td>127</td>
<td>除全0和全1</td>
<td>OK</td>
<td>OK</td>
<td>本地软件测试环回地址 (loopback)</td>
</tr>
<tr>
<td><strong>Y</strong></td>
<td><strong>全1</strong></td>
<td><strong>NO</strong></td>
<td><strong>OK</strong></td>
<td><strong>Y 网络的广播（路由器参与转发）</strong></td>
</tr>
<tr>
<td><strong>全1</strong></td>
<td><strong>全1</strong></td>
<td><strong>NO</strong></td>
<td><strong>OK</strong></td>
<td><strong>本网络的广播（路由器不参与转发）</strong></td>
</tr>
</tbody></table>
<p>由此可见，IP 广播主要是聚焦局域网（LAN）所有主机都会接收广播消息，无需特定的接收者。</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li>地址解析协议（ARP）。</li>
<li>动态主机配置协议（DHCP）的请求。</li>
</ul>
<h3 id="IP-多播（Multicast）"><a href="#IP-多播（Multicast）" class="headerlink" title="IP 多播（Multicast）"></a>IP 多播（Multicast）</h3><ul>
<li><strong>定义</strong>：<br>多播是一种将数据包发送给特定一组接收者（多播组）的通信方式。这组接收者需要事先加入一个特定的多播组，只有组内的成员会接收到数据包。也叫组播</li>
<li><strong>特点</strong>：<ul>
<li>可以跨越多个网络。</li>
<li>使用 <strong>多播地址</strong>：IPv4中的多播地址范围是 <code>224.0.0.0</code> 到 <code>239.255.255.255</code>。（D类地址）</li>
<li>接收者需要加入一个多播组（通过 IGMP 协议进行管理）。</li>
<li>节省带宽，因为数据只发送给需要的设备。</li>
</ul>
</li>
<li><strong>优缺点</strong>：<ul>
<li><strong>优点</strong>：更高效，特别是在需要发送给大量接收者时。</li>
<li><strong>缺点</strong>：需要更多的配置和支持，例如多播路由器。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li>视频会议。</li>
<li>实时股票行情分发。</li>
<li>流媒体广播。</li>
</ul>
</li>
</ul>
<h3 id="IP-任播（Anycast）"><a href="#IP-任播（Anycast）" class="headerlink" title="IP 任播（Anycast）"></a>IP 任播（Anycast）</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241129180917624.png" alt="image-20241129180917624"></p>
<p><strong>定义</strong><br>任播是点对最近点通信，数据包发送给一个目标地址，但由多个具有相同地址的设备接收，最终到达距离最近的一个设备。</p>
<p><strong>特点</strong></p>
<ul>
<li>使用普通的单播地址，但配置在多个设备上。</li>
<li>路由选择最近的目标（通常基于最短路径）。</li>
<li>增强服务的可用性和效率。用于负载均衡和冗余。</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>内容分发网络（CDN）。</li>
<li>公共 DNS 服务（如 Google 的 8.8.8.8）。</li>
</ul>
<p><strong>示例</strong><br>用户请求 DNS 服务，数据包被路由到最近的 DNS 服务器（多个 DNS 服务器配置了同样的地址 8.8.8.8）。</p>
<h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>单播</td>
<td>一对一通信，目标明确</td>
<td>普通网络通信（网页、邮件等）</td>
</tr>
<tr>
<td>组播</td>
<td>一对多通信，针对订阅组传输</td>
<td>视频直播、分布式同步等</td>
</tr>
<tr>
<td>广播</td>
<td>一对全通信，子网内所有设备接收</td>
<td>ARP、DHCP 发现等</td>
</tr>
<tr>
<td>任播</td>
<td>一对最近点通信，选择最近设备</td>
<td>CDN、全球 DNS 服务等</td>
</tr>
</tbody></table>
<h3 id="局域网上的硬件多播"><a href="#局域网上的硬件多播" class="headerlink" title="局域网上的硬件多播"></a>局域网上的硬件多播</h3><p>MAC地址 FF:FF:FF:FF:FF:FF为<strong>广播地址</strong></p>
<p>MAC地址 第一个字节末位为1 表示多播，前25位固定不变，后23位来自D类IP地址的后23位 为MAC多播地址</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h3><h3 id="多播路由协议"><a href="#多播路由协议" class="headerlink" title="多播路由协议"></a>多播路由协议</h3><p>本质区别：多播路由需要考虑源地址的组和网络，也要考虑目的地址的组和网络</p>
<h1 id="缓解IPv4地址短缺"><a href="#缓解IPv4地址短缺" class="headerlink" title="缓解IPv4地址短缺"></a>缓解IPv4地址短缺</h1><h2 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h2><h2 id="虚拟专用网络（Virtual-Private-Network-VPN）"><a href="#虚拟专用网络（Virtual-Private-Network-VPN）" class="headerlink" title="虚拟专用网络（Virtual Private Network, VPN）"></a>虚拟专用网络（Virtual Private Network, VPN）</h2><h3 id="专用IP地址与隧道技术（tunnel）"><a href="#专用IP地址与隧道技术（tunnel）" class="headerlink" title="专用IP地址与隧道技术（tunnel）"></a>专用IP地址与隧道技术（tunnel）</h3><p><code>10.0.0.0 ~ 10.255.255.255</code> 1个A类网络</p>
<p><code>172.16.0.0 ~ 172.31.255.255</code> 16个B类网络</p>
<p><code>192.168.0.0 ~ 192.168.255.255</code> 256个C类网络</p>
<p>IP地址短缺，机构内部的主机都会使用专用IP网段，如果机构内部的主机AB分隔两地需要进行通信，私密性和安全性是关键，要么向运营商租用昂贵的电信线路将他们直接连成局域网，</p>
<p>要么利用互联网，用两台路由器静态配置IP，将原本的IP数据报加密后封装到一个新的IP数据报中，这个新的IP数据报负责在公网进行路由传递，最终到达目标主机所在网络的路由器，由路由器将数据报交付给目标主机。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241125223910383.png" alt="image-20241125223910383"></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>目标IP</th>
<th>源IP</th>
<th>所属网络</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>10.2.0.3</td>
<td>10.1.0.1</td>
<td>10.1.0.0</td>
</tr>
<tr>
<td>2</td>
<td>194.4.5.6</td>
<td>125.1.2.3</td>
<td>公网IP</td>
</tr>
<tr>
<td>3</td>
<td>10.2.0.3</td>
<td>10.1.0.1</td>
<td>10.2.0.0</td>
</tr>
</tbody></table>
<p>步骤2是外层数据报，13都是内层的加密数据报内容。</p>
<h2 id="网络地址转换（Network-Address-Translation-NAT）"><a href="#网络地址转换（Network-Address-Translation-NAT）" class="headerlink" title="网络地址转换（Network Address Translation, NAT）"></a>网络地址转换（Network Address Translation, NAT）</h2><p>同样是IP地址短缺的背景，路由器给主机分配了专用IP网段，内网IP的数据包根本不可能在公网上传播，因为公网上的路由器都是屏蔽掉了这些私网IP，因此主机要通过路由器的公网IP向外发送消息，但是之后外部就无法联络内部，此时就出现了网络地址转换（NAT）NAT提供了主机的专用IP地址到路由器所持公网IP的映射关系，外部发送消息到路由器的特定公网IP，NAT路由器根据映射表将消息转发到对应的主机。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241125225315413.png" alt="image-20241125225315413"></p>
<h3 id="NAPT"><a href="#NAPT" class="headerlink" title="NAPT"></a>NAPT</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241125225356469.png" alt="image-20241125225356469"></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>网络地址转换（Network Address Translation，NAT）机制的问题在于，NAT设备自动屏蔽了非内网主机主动发起的连接，也就是说，从外网发往内网的数据包将被NAT设备丢弃，这使得位于不同NAT设备之后的主机之间无法直接交换信息。这一方面保护了内网主机免于来自外部网络的攻击，另一方面也为P2P通信带来了一定困难。Internet上的NAT设备大多是地址限制圆锥形NAT或端口限制圆锥形 NAT，外部主机要与内网主机相互通信，必须由内网主机主动发起连接，使 NAT设备产生一个映射条目，这就有必要研究一下<strong>内网穿透</strong>技术。</p>
<h3 id="内网穿透（Intranet-penetration）"><a href="#内网穿透（Intranet-penetration）" class="headerlink" title="内网穿透（Intranet penetration）"></a>内网穿透（Intranet penetration）</h3><h4 id="UDP-打洞"><a href="#UDP-打洞" class="headerlink" title="UDP 打洞"></a>UDP 打洞</h4><h5 id="通信双方一台位于-NAT-之后"><a href="#通信双方一台位于-NAT-之后" class="headerlink" title="通信双方一台位于 NAT 之后"></a>通信双方一台位于 NAT 之后</h5><p>一台主机B有一个公网 IP，另一台主机A有一个内网 IP。如图2.4所示， A 位于 NAT 之后，并拥有[IP 地址：端口]对[10.0.0.1：1234]， B位于 NAT 之前，并拥有[IP 地址：端口]对[138.76.29.7：1234]，NAT 拥有公网 IP 155.99.25.11。由于  B 有一个公网 IP， A 可以直接通过 TCP 连接到[138.76.29.7：1234]，然而，如果  B 向  A 发起主动连接，则不会成功。此时，需要一个公有的服务器辅助进行内网穿透。 A 和  B 向服务器发起登陆请求，并保持一个 TCP 或 UDP 连接，服务器记录其 IP 地址和端口号，这里服务器对  A 是记录其经过 NAT 映射之后的 IP 和端口号。当  B 想连接  A 时，首先向服务器提出请求，服务器在收到请求后向  A 发出打洞命令，并将  B 的[IP 地址：端口]对发给  A， A 根据接收到的 IP地址和端口号向  B 发起 TCP 连接或发送 UDP 数据包。接下来  A 和 B 之间便可以建立数据传输通道。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241125230637435.png" alt="image-20241125230637435"></p>
<h5 id="通信双方主机均位于NAT设备之后"><a href="#通信双方主机均位于NAT设备之后" class="headerlink" title="通信双方主机均位于NAT设备之后"></a>通信双方主机均位于NAT设备之后</h5><p>两台主机都处于内网中，如图2.5所示。服务器记录的[IP 地址：端口]对是  A 和  B 经过 NAT 映射之后的IP 地址和端口号，此时， A 和  B 之间任意方向的连接请求都会被对方的 NAT 设备屏蔽。 A 首先向服务器提出连接请求，服务器将  A 的 IP地址和端口号对[155.99.25.11:51200]发给  B，并向  B 发出打洞命令； B 收到服务器的打洞命令后首先向[155.99.25.11:51200]发送一定数目的 UDP探测包或 TCP 连接请求，在 NAT B 上打一个方向为[155.99.25.11:51200]的洞， B 随后向服务器报告打洞完成；服务器在收到  B 的报告后将  B 的公网IP 地址和端口号对[110.10.33.10：5000]，此时由于 NAT B 上已经留下了对应于[155.99.25.11:51200]方向的洞， A 向[110.10.33.10：5000]发出的数据包或连接请求将不会被丢弃。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241125230725093.png" alt="image-20241125230725093"></p>
<p>这项技术需要使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">圆锥型NAT</a>设备，对称型NAT不能使用这项技术。</p>
<h4 id="STUN（NAT会话穿越应用程序）"><a href="#STUN（NAT会话穿越应用程序）" class="headerlink" title="STUN（NAT会话穿越应用程序）"></a>STUN（NAT会话穿越应用程序）</h4><p>NAT 穿越技术拥有这样的功能，它能够让网络应用程序主动发现自己位于 NAT 设备之后，并且会主动获得 NAT 设备的公有 IP，并为自己建立端口映射条目，注意这些都是 NAT设备后的应用程序自动完成的。</p>
<p>也就是说，在 NAT 穿透技术中，NAT设备后的应用程序处于主动地位，它已经明确地知道 NAT 设备要修改它外发的数据包，于是它主动配合 NAT 设备的操作，主动地建立好映射，这样就不像以前由 NAT 设备来建立映射了。</p>
<p>说人话，就是客户端主动从 NAT 设备获取公有 IP 地址，然后自己建立端口映射条目，然后用这个条目对外通信，就不需要 NAT 设备来进行转换了。</p>
<h1 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h1><h2 id="静态配置路由导致的路由环路"><a href="#静态配置路由导致的路由环路" class="headerlink" title="静态配置路由导致的路由环路"></a>静态配置路由导致的路由环路</h2><p>聚合路由和精确路由同时出现在一张路由表中，应该按照精确地址进行匹配，（模糊地址中不包括精确地址）</p>
<p><strong>路由配置错误</strong>：路由表手动配置错误导致出现路由环路。</p>
<p><strong>聚合不存在的网络</strong>：路由表中只有模糊地址，但是模糊地址里面不存在某个精确地址，而目的地址是精确地址会导致数据包会被错误地路由到模糊的网络，因此路由器应当配置黑洞路由，将不存在的地址路由到黑洞中（丢弃）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241127123732804.png" alt="image-20241127123732804"></p>
<p><strong>网络故障</strong>：路由器检测到与其直连的网络发生故障会把路由表中的条目删除，但下次来就不知道要转发到哪里，只能交给默认路由，此时可能会导致环路，正确的做法是故障时启用对应网络的黑洞路由，恢复时关闭黑洞路由，启用正常的接口路由    </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241127124109191.png" alt="image-20241127124109191"></p>
<h2 id="路由协议概述"><a href="#路由协议概述" class="headerlink" title="路由协议概述"></a>路由协议概述</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241127124155110.png" alt="image-20241127124155110"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241127124212549.png" alt="image-20241127124212549"></p>
<p>路由表：对网络拓扑计算最优化</p>
<p>转发表：使得查找过程最优化，优化路由表的查找性能</p>
<h2 id="路由信息协议（Routing-Information-Protocol-RIP）"><a href="#路由信息协议（Routing-Information-Protocol-RIP）" class="headerlink" title="路由信息协议（Routing Information Protocol, RIP）"></a>路由信息协议（Routing Information Protocol, RIP）</h2><ul>
<li>属于内部网关协议（IGP），是一个自治系统内部的路由协议</li>
<li>最早出现的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%9D%E9%9B%A2%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1%E5%8D%94%E5%AE%9A">距离向量路由协议</a>，其主要应用于规模较小的、可靠性要求较低的网络。收敛速度较慢，支持的广播网络规模有限</li>
<li>路由<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95">算法</a>是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Bellman-Ford">Bellman-Ford</a>算法</li>
</ul>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul>
<li><p>每隔30秒会与相邻的路由器交换子消息，以动态的建立<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E8%A1%A8">路由表</a>。</p>
</li>
<li><p><strong>RIP规定度量值取0~15之间的整数，大于或等于16的跳数被定义为无穷大。</strong></p>
</li>
<li><p>对方的路由表复制过来，下一跳全部改成对方，距离全部加1；</p>
</li>
<li><p>不存在网络B的条目，直接添加；</p>
</li>
<li><p>存在网络A的条目，下一跳相同，直接更新；</p>
</li>
<li><p>存在网络A的条目，下一跳不同，距离更短才更新；距离相同则添加条目（等价负载均衡）；距离更长则不更新。</p>
</li>
</ul>
<h3 id="问题：坏消息传得慢"><a href="#问题：坏消息传得慢" class="headerlink" title="问题：坏消息传得慢"></a>问题：坏消息传得慢</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241127124509184.png" alt="image-20241127124509184"></p>
<ul>
<li><strong>水平分割</strong>：水平分割指的是RIP从某个接口学到的路由，不会从该接口再发回给邻居设备。在帧中继和X.25等NBMA网络中，水平分割功能缺省为禁止状态。</li>
<li><strong>触发更新</strong>：触发更新是指路由信息发生变化时，立即向邻居设备发送触发更新报文，通知变化的路由信息。（触发更新不会触发接收路由器重置自己的更新定时器）</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241127125439393.png" alt="image-20241127125439393"></p>
<p>检测到不可达：说明之前距离是1（直连接口）</p>
<p>收敛：R3 到网络距离为1，R2和R1到网络的距离为2</p>
<p>不可达：R3 到网络距离为16，通告给R2，变更距离为16，随后R1没来得及更新，就将自己的路由表内容发给了</p>
<h2 id="开放式最短路径优先（Open-Shortest-Path-First-OSPF）"><a href="#开放式最短路径优先（Open-Shortest-Path-First-OSPF）" class="headerlink" title="开放式最短路径优先（Open Shortest Path First, OSPF）"></a>开放式最短路径优先（Open Shortest Path First, OSPF）</h2><ul>
<li><p>属于内部网关协议（IGP）</p>
</li>
<li><p>在链路状态路由协议中，每个节点都知晓整个网络的拓扑信息。各节点使用自己了解的网络拓扑情况来各自独立地对网络中每个可能的目的地址计算出其最佳的转发地址（下一跳）。所有最佳转发地址汇集到一起构成该节点的完整路由表。与距离-矢量路由协议使用的那种每个节点与其相邻节点分享自己的路由表的工作方式不同，链路状态路由协议的工作方式是节点间仅传播用于构造网络连通图所需的信息。最初创建这类协议就是为了解决距离-矢量路由协议收敛缓慢的缺点，然而，为此链路状态路由协议会消耗大量的内存与处理器能力。</p>
</li>
<li><p>大多数<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%9C%8D%E5%8A%A1%E4%BE%9B%E5%BA%94%E5%95%86">ISP</a>必须使用BGP来与其他ISP建立路由连接（尤其是当它们采取多宿主连接时）</p>
</li>
<li><p>采用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95">Dijkstra 算法</a>计算<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%A0%91">最短路径树</a>，使用“开销（Cost）”作为路由度量。</p>
</li>
<li><p>链路状态数据库（LSDB）用来保存当前<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91">网络拓扑</a>结构，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8">路由器</a>上属于同一区域的链路状态数据库是相同的（属于多个区域的路由器会为每个区域维护一份链路状态数据库）。</p>
</li>
<li><p>基于 IP 协议，路由信息直接封装在 IP 数据报中</p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241127125916904.png" alt="image-20241127125916904"></p>
<h2 id="边界网关协议（Border-Gateway-Protocol-BGP）"><a href="#边界网关协议（Border-Gateway-Protocol-BGP）" class="headerlink" title="边界网关协议（Border Gateway Protocol, BGP）"></a>边界网关协议（Border Gateway Protocol, BGP）</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241127125154032.png" alt="image-20241127125154032"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241127125208832.png" alt="image-20241127125208832"></p>
<h2 id="向路由选择协议提供服务的实体"><a href="#向路由选择协议提供服务的实体" class="headerlink" title="向路由选择协议提供服务的实体"></a>向路由选择协议提供服务的实体</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241127125231763.png" alt="image-20241127125231763"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/12/30/408-%E8%AE%A1%E7%BD%91-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/30/408-%E8%AE%A1%E7%BD%91-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" class="post-title-link" itemprop="url">物理层&数据链路层</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-30 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-30T00:00:00+08:00">2024-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:30:33" itemprop="dateModified" datetime="2025-05-05T11:30:33+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%86">同轴电缆 - 维基百科，自由的百科全书</a> </p>
<p><strong>单向通信</strong>：Simplex，只有一个方向的通信，没有反向的交互。</p>
<p><strong>半双工</strong>：Half-Duplex，可以收发信息，但无法同时收发。</p>
<p><strong>全双工</strong>：Full-Duplex，可以同时收发信息。双工通信需要两条信道。</p>
<hr>
<p><strong>基带信号</strong>：基本频带信号，来自信源的信号。</p>
<p><strong>调制</strong>：将基带信号做一定的转换，使之能够在信道内传输。</p>
<p><strong>基带调制</strong>（编码）：将数字信号做一定转换，仍然是数字信号，但是更能适应信道特性。</p>
<p><strong>带通调制</strong>：使用载波（Carrier）调制数字信号，搬到频率较高的频段，转成模拟信号，以便在模拟信道中传输。</p>
<hr>
<p><strong>奈氏准则</strong>：带宽W，则码元传输最高速率是2W/个每秒，超过则会出现严重的码间串扰。</p>
<p><strong>香农公式</strong>：信噪比越大，带宽越高，极限传输速率越高。</p>
<hr>
<p><strong>导引型传输媒体</strong>：双绞线、同轴电缆、光缆。</p>
<p><strong>非导引型传输媒体</strong>：无线电微波通信（蜂窝网）、短波通信、微波接力（卫星通信）。</p>
<hr>
<p><strong>信道复用</strong>：解决多节点接入同一信道的冲突问题，码分、时分、波分、频分、空分、正交。</p>
<hr>
<p><strong>宽带接入</strong>：ADSL、拨号上网(猫, modem)  HFC、FTTx（光纤到x，光猫, ONT）。</p>
<h1 id="数据链路层（LAN）"><a href="#数据链路层（LAN）" class="headerlink" title="数据链路层（LAN）"></a>数据链路层（LAN）</h1><h2 id="数据链路层面对的三个问题"><a href="#数据链路层面对的三个问题" class="headerlink" title="数据链路层面对的三个问题"></a>数据链路层面对的三个问题</h2><ul>
<li><strong>帧</strong>（Frame）：用帧来封装分组交换的基本单位（IP数据报），限定IP数据报的长度（MTU），用特定字符（如SOH EOT）来作为帧与帧之间的界限。</li>
<li><strong>透明传输</strong>（Transparency）：也叫二进制安全（Binary-Safe），如果数据负载（Payload）中恰好出现了和界限字符二进制码相同的部分，则应该通过转义字符（ESC）加以区分。</li>
<li><strong>差错检验</strong>（Error Detection）：以帧为单位，使用循环冗余校验（Cyclic Redundancy Check）检查二进制比特是否传输错误（比特差错）有则丢弃数据帧，主要是帧内部的差错。<ul>
<li>可靠传输：链路层的发送端发什么，接收端就收到什么。（没有比特差错，也没有帧之间的差错）</li>
<li>确认、重传机制：如果是可靠的信道（如有线链路）则不需要重传，如果是信道质量较差的无线链路传输，则有重传机制，也就是提供可靠的传输。</li>
</ul>
</li>
</ul>
<h2 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h2><p>一对一，典型协议：PPP协议（宽带上网的PPPoE，用户和ISP之间连接）</p>
<h2 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h2><p>一对多，总线型拓扑以太网，典型协议：CSMA/CD (载波侦听多点接入/碰撞检测)</p>
<p><strong>共享信道</strong>：</p>
<ul>
<li><p>静态分配：FrequencyDM,CodeDM,WaveDM,TimeDM，对于局域网来说成本太高。</p>
</li>
<li><p>动态分配：</p>
<ul>
<li><p>随机接入：随时发送，碰撞导致传输率降低，CSMA/CD检测碰撞(IEEE 802.3 / DIX Ethernet V2)</p>
</li>
<li><p>受控接入：令牌环局域网 (IEEE 802.5) </p>
</li>
</ul>
</li>
</ul>
<p><strong>LLC</strong>（Logical Link Control）：逻辑链路控制，早期有很多局域网标准，用LLC来标识使用哪一种标准，后来只剩以太网</p>
<p><strong>MAC</strong>（Media Access Control）：媒体接入控制，控制传输媒体的层级。</p>
<h3 id="适配器（Adapter）"><a href="#适配器（Adapter）" class="headerlink" title="适配器（Adapter）"></a>适配器（Adapter）</h3><p>硬件上也叫做网卡，ROM中存放MAC地址（硬件地址），承担着串行/并行信号的转换工作（作为内外信号的一个缓冲区）将IP数据报封装成帧发送出去，或是接收网帧并提供校验，通过则发给CPU开始IO，校验失败则丢弃网帧，超过也会丢弃。</p>
<h3 id="以太网（Ethernet）"><a href="#以太网（Ethernet）" class="headerlink" title="以太网（Ethernet）"></a>以太网（Ethernet）</h3><h4 id="以太网的两大特征"><a href="#以太网的两大特征" class="headerlink" title="以太网的两大特征"></a>以太网的两大特征</h4><ul>
<li>无连接：不必事先建立连接，不可靠，尽最大努力交付，是否需要重传完全依赖于高层的控制</li>
<li>曼彻斯特编码：方便接收方提取位同步信号，能够有效标示码元。</li>
</ul>
<h4 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h4><ul>
<li>MA（Multiple Access）： 多点接入 多台主机接入总线。</li>
<li>CS（Carrier Sense）： 信道监听，边发送边监听信道的电压变化。</li>
<li>CD（Collision Detection）：监听到别人发送了（检测到碰撞）就停止自己的发送，避免浪费网络资源。由于传播时延，导致真正碰撞发生一段时间，B才会检测到发生碰撞停止发送，再过一段时间等B传到A，A才会意识到发生碰撞了</li>
</ul>
<h5 id="二进制指数退避-BEB"><a href="#二进制指数退避-BEB" class="headerlink" title="二进制指数退避(BEB)"></a>二进制指数退避(BEB)</h5><p>Binary Exponential Backoff</p>
<p>二进制指数退避算法是一种网络协议中用于解决数据传输冲突的方法。在以太网的CSMA/CD协议中，当多个设备尝试同时发送数据时，可能会发生冲突。为了减少冲突的发生，二进制指数退避算法被用来计算设备在重传前应等待的时间。通过随机化退避时间，有效地减少了连续冲突的可能性。随着重传次数的增加，退避时间的上限也随之增加，这有助于在网络负载较重时平滑流量。然而，这种方法牺牲了时间效率，因为退避时间可能会指数增长，导致数据传输的延迟。此外，当退避时间达到一定阈值时，算法会停止增加退避时间，以避免无限制的延迟。</p>
<p>二进制指数退避算法的基本步骤如下：</p>
<ol>
<li>确定基本退避时间，通常设为一个争用期时间，例如以太网中为51.2微秒。</li>
<li>定义重传次数K，取重传次数和10的较小值，即K=min(重传次数, 10)。</li>
<li>从集合[0, 1, 2, …, (2^K - 1)]中随机选择一个整数R。</li>
<li>计算退避时间T，即T=R×基本退避时间。</li>
<li>如果重传次数达到16次仍未成功，则放弃传输并报告给上层协议。</li>
</ol>
<h4 id="总线型拓扑以太网"><a href="#总线型拓扑以太网" class="headerlink" title="总线型拓扑以太网"></a>总线型拓扑以太网</h4><ul>
<li><p>只能是半双工通信，适配器使用CSMA/CD协议</p>
</li>
<li><p>不能确定信道空闲后某一时间发送的帧一定不碰撞（发送的不确定性）</p>
</li>
<li><p>信道空闲一段时间（这段时间称为争用期/碰撞窗口 collision window）之后，才能保证发送的帧一定不碰撞，因此各站点需竞争</p>
</li>
</ul>
<h4 id="基于集线器的星形拓扑以太网（10BASE-T）"><a href="#基于集线器的星形拓扑以太网（10BASE-T）" class="headerlink" title="基于集线器的星形拓扑以太网（10BASE-T）"></a>基于集线器的星形拓扑以太网（10BASE-T）</h4><ul>
<li><p>使用双绞线 RJ-45 作为线缆和插头，使用集线器（hub）作为中心硬件</p>
</li>
<li><p>集线器内部仍然是用电子器件模拟实际电缆，实际上仍是总线型拓扑，适配器使用CSMA/CD协议</p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/7f194dec14ad2db7fe353c0893c1ad62-1732332398363-2.jpg" alt="7f194dec14ad2db7fe353c0893c1ad62"></p>
<h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4><p>一个帧在发送之前必须经过若干个争用期2τ（发生碰撞），然后经过发送时延T<del>0</del>，再经历一个传播时延τ才能发到对面。发送过程占用总线的时间为T<del>0</del> + τ<br>$$<br>a=\frac{\tau}{T_0}<br>$$<br>因为传播时延τ的存在，碰撞之后不能立即检测到，造成了信道浪费，所以比值a越小越好，也就是连线尽量短一些，控制以太网帧长度不能太短（大于64字节）也不能太长（小于1518字节，MTU + 其他标识位）</p>
<h3 id="以太网帧"><a href="#以太网帧" class="headerlink" title="以太网帧"></a>以太网帧</h3><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>以太网的MAC地址为48位二进制数，有两个保留的标识位G/L与I/G，一共能表示2^46^个不同的地址，和网卡绑定在一起，存在网卡的ROM中，例：E4-FD-45-3E-4A-A4</p>
<h4 id="以太网帧、MAC帧格式（DIX-Ethernet-V2）"><a href="#以太网帧、MAC帧格式（DIX-Ethernet-V2）" class="headerlink" title="以太网帧、MAC帧格式（DIX Ethernet V2）"></a>以太网帧、MAC帧格式（DIX Ethernet V2）</h4><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F#Ethernet_II">以太网帧格式 - 维基百科，自由的百科全书</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/8639303972e62f982d1666dffca21057.jpg" alt="8639303972e62f982d1666dffca21057"></p>
<ul>
<li><p>前方7B是同步字段，告诉网卡调整时钟和发送端同步，最后1B也是同步段，11表示之后才是真正的以太网帧。</p>
</li>
<li><p>接下来的12B是<strong>目标地址</strong>和<strong>源地址</strong>，目标地址在前方便检查是不是发给自己的。</p>
</li>
<li><p><strong>类型</strong>占2B，用来区分数据负载<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%B1%BB%E5%9E%8B">以太类型</a>的字段ARP、IPv4等</p>
</li>
<li><p><strong>数据负载</strong>部分，长度最小为46B（整个以太网帧不能小于64B，否则CSMA/CD不能正常工作，还有好处就是提高了帧的传输效率(有效部分占的bi’lv)），最大为MTU(1500B，太长会导致发送与转发负担太重，一点小差错就要重传，反而降低了效率)</p>
</li>
<li><p><strong>FCS</strong>（帧校验序列）长度为固定4B，FCS不检测前8B的同步字段。</p>
</li>
<li><p>以太网帧有效长度 64B-1518B</p>
</li>
<li><p>有帧开始定界符，没有帧结束符或者长度。因为以太网使用曼彻斯特编码，因此只需要在帧之间留出一定空隙即可，检测到空隙则表示帧的结束。</p>
</li>
</ul>
<h2 id="物理层扩展以太网"><a href="#物理层扩展以太网" class="headerlink" title="物理层扩展以太网"></a>物理层扩展以太网</h2><ul>
<li><p><strong>转发器</strong>（repeater）：也叫中继器，早先通过其扩大局域网的物理范围</p>
</li>
<li><p><strong>集线器</strong>：将主机用光纤加一个modem与<strong>集线器</strong>（hub）连接起来，再用一个集线器分别连接几个集线器，这样做比较简单，但是系统总吞吐量有严重的木桶效应，hub也不能缓存网帧，比较低效。</p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2d8d54ff5a6ea450f7378124fb8cf209-1732358355703-4.jpg" alt="2d8d54ff5a6ea450f7378124fb8cf209"></p>
<h2 id="数据链路层扩展以太网"><a href="#数据链路层扩展以太网" class="headerlink" title="数据链路层扩展以太网"></a>数据链路层扩展以太网</h2><h3 id="网桥（bridge）"><a href="#网桥（bridge）" class="headerlink" title="网桥（bridge）"></a>网桥（bridge）</h3><p>使用软件，根据目的地址转发和过滤帧，维护一个地址表来确定具体的转发目标。能够隔离碰撞域</p>
<h3 id="交换机（switch）"><a href="#交换机（switch）" class="headerlink" title="交换机（switch）"></a>交换机（switch）</h3><ul>
<li><p>实质是多端口网桥，能够支持并行通信，并且有专门的硬件芯片用来转发过滤，比网桥快很多。</p>
</li>
<li><p>每个端口之间都是独占传输域，能够进行全双工通信（也就不用遵守CSMA/CD）总吞吐量没有木桶效应。</p>
</li>
<li><p>端口有存储器，能在繁忙时将网帧暂存。支持存储转发和直通（cut-through）多种方式，减小交换时延。</p>
</li>
<li><p>凭借<strong>自学习</strong>功能维护一个地址表（交换表），根据发出网帧的源MAC地址，将端口映射到MAC地址。</p>
</li>
</ul>
<h4 id="自学习"><a href="#自学习" class="headerlink" title="自学习"></a>自学习</h4><p>省去了人工配置的麻烦，即插即用</p>
<ul>
<li><p>一开始地址表为空，交换机通过MAC地址的源地址部分，确定A地址对应端口1，填到地址表中</p>
</li>
<li><p>不知道目标B地址的端口，因此采用<strong>广播帧</strong>的形式，其他网卡收到帧，发现目标地址不是自己，遂直接丢弃</p>
</li>
<li><p>B收到网帧，发现是发给自己的，收下。B再发出网帧到A，因此地址表中添加了B地址对应端口2的记录</p>
</li>
<li><p>下次有人想发给A或者B，直接按照地址表转发到对应端口就可以，不用再次<strong>广播</strong></p>
</li>
<li><p>弊端：广播帧可能会导致频繁的端口之间转发，消耗了很多没有必要消耗的网络资源（广播风暴）</p>
</li>
</ul>
<h3 id="虚拟局域网（Virtual-Local-Area-Network-VLAN）"><a href="#虚拟局域网（Virtual-Local-Area-Network-VLAN）" class="headerlink" title="虚拟局域网（Virtual Local Area Network, VLAN）"></a>虚拟局域网（Virtual Local Area Network, VLAN）</h3><p><a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100088136">IEEE 802.1Q封装的VLAN数据帧格式 - 华为</a> </p>
<ul>
<li><p>将一个大局域网（广播域）分成几个小的局域网，减少网络风暴的发生，并且能提高局域网内的私密性、安全性。</p>
</li>
<li><p>IEEE 802.1Q帧在原先的MAC帧的源地址后、类型字段前添加了VLAN字段，用于不同交换机之间的传输：</p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/77e8ffb822418303da48f04e1094c8a4.jpg" alt="77e8ffb822418303da48f04e1094c8a4"></p>
<ul>
<li>在两台交换机之间能够组出很多个(4096)不同的网络（VLAN）如果发送目标横跨交换机，则交换机1会发送IEEE 802.1Q帧，再由交换机2将标签去掉把原先的MAC帧传给目标。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/359e5dc70c67ed8789ffb347a4237c7f.jpg" alt="359e5dc70c67ed8789ffb347a4237c7f"></p>
<ul>
<li>对于A与C的通信，他们不属于同一个局域网，因此不是数据链路层所能解决的，需要路由器（当然有的交换机也有附加的功能，称为L3/L2 switch，与L2 switch相对）</li>
</ul>
<h2 id="以太网的宽带接入（PPPoE）"><a href="#以太网的宽带接入（PPPoE）" class="headerlink" title="以太网的宽带接入（PPPoE）"></a>以太网的宽带接入（PPPoE）</h2><ul>
<li>ADSL、拨号上网需要猫（调制解调器，modem）负责模拟信号和数字信号的转换</li>
<li>如果是光纤到户FTTH需要光猫（光纤网络终端，Optical Network Terminal）负责光信号与数字信号的转换</li>
<li>FTTB，FTTF则连光猫也不需要了</li>
</ul>
<h1 id="无线网络"><a href="#无线网络" class="headerlink" title="无线网络"></a>无线网络</h1><h2 id="无线网络与以太网"><a href="#无线网络与以太网" class="headerlink" title="无线网络与以太网"></a>无线网络与以太网</h2><p><strong>物理介质：</strong></p>
<ul>
<li>**无线网络 (Wi-Fi 和蜂窝移动网络)**：使用无线电波或微波作为通信介质，无需物理线缆。</li>
<li>**以太网 (Ethernet)**：使用有线连接（如双绞线、光纤）作为通信介质，需要物理布线。</li>
</ul>
<p><strong>标准协议：</strong></p>
<ul>
<li><strong>无线网络</strong>：<ul>
<li>**Wi-Fi (802.11 系列)**：基于 IEEE 802.11 协议，适用于局域网 (WLAN)。</li>
<li><strong>蜂窝移动网络</strong>：包括 2G、3G、4G、5G，主要用于广域网 (WAN)。</li>
</ul>
</li>
<li><strong>以太网</strong>：基于 IEEE 802.3 协议，主要应用于局域网 (LAN)。</li>
</ul>
<p><strong>覆盖范围：</strong></p>
<ul>
<li><strong>无线网络</strong>：<ul>
<li>Wi-Fi 的典型覆盖范围是几十米，适合室内使用。</li>
<li>蜂窝网络覆盖范围更广，可以跨城市、国家甚至全球。</li>
</ul>
</li>
<li><strong>以太网</strong>：<ul>
<li>受限于线缆长度，一般在100米以内，需要交换机或路由器扩展覆盖范围。</li>
</ul>
</li>
</ul>
<p><strong>传输速度：</strong></p>
<ul>
<li><strong>无线网络</strong>：<ul>
<li>Wi-Fi 6（802.11ax）理论速度可达 9.6 Gbps。</li>
<li>蜂窝网络的 5G 技术最高速度可达 10 Gbps。</li>
</ul>
</li>
<li><strong>以太网</strong>：<ul>
<li>常见的千兆以太网 (1 Gbps) 和万兆以太网 (10 Gbps) 具有更稳定的高速连接。</li>
</ul>
</li>
</ul>
<p><strong>移动性：</strong></p>
<ul>
<li><strong>无线网络</strong>：用户可以自由移动而不影响网络连接，尤其是蜂窝网络支持无缝切换。</li>
<li><strong>以太网</strong>：由于需要有线连接，设备的移动性受到限制。</li>
</ul>
<p><strong>安全性：</strong></p>
<ul>
<li><strong>无线网络</strong>：容易受到信号干扰和窃听攻击，需要依赖加密协议（如 WPA3）增强安全性。</li>
<li><strong>以太网</strong>：由于是物理连接，安全性相对较高，受到外部攻击的风险较低。</li>
</ul>
<h2 id="碰撞协议"><a href="#碰撞协议" class="headerlink" title="碰撞协议"></a>碰撞协议</h2><h3 id="CSMA-CA-Collision-Avoidance-WLAN"><a href="#CSMA-CA-Collision-Avoidance-WLAN" class="headerlink" title="CSMA/CA: Collision Avoidance (WLAN)"></a>CSMA/CA: <strong>Collision Avoidance</strong> (WLAN)</h3><ul>
<li><p><strong>机制</strong>：</p>
<ol>
<li><strong>监听信道</strong>：设备在发送数据前先监听信道是否空闲。</li>
<li>**等待随机时间 (Backoff)**：即使信道空闲，设备也会等待一段随机时间，以减少多个设备同时发送的概率。</li>
<li>**发送 RTS/CTS (可选)**：使用请求发送 (RTS) 和清除发送 (CTS) 控制帧来保留信道，避免隐藏节点问题。其他节点在监听到 RTS 或 CTS 时暂停发送数据，从而减少冲突风险。</li>
<li>**确认 (ACK)**：接收端发送确认帧，确保数据成功接收。如果未收到确认，则重新发送数据。</li>
</ol>
</li>
<li><p><strong>优点</strong>：</p>
<ol>
<li>避免了碰撞的直接发生，适合共享信道的无线环境。</li>
<li>RTS/CTS 机制解决隐藏节点问题，减少冲突概率。</li>
</ol>
</li>
<li><p><strong>缺点</strong>：</p>
<ol>
<li><p>增加额外的通信开销（RTS、CTS 和 ACK 等控制帧）。</p>
</li>
<li><p>多用户高并发时容易导致延迟增加和吞吐量下降。</p>
</li>
</ol>
</li>
</ul>
<h3 id="CSMA-CD-Collision-Detection-Ethernet"><a href="#CSMA-CD-Collision-Detection-Ethernet" class="headerlink" title="CSMA/CD: Collision Detection (Ethernet)"></a>CSMA/CD: <strong>Collision Detection</strong> (<strong>Ethernet</strong>)</h3><ul>
<li><p><strong>机制</strong>：</p>
<ol>
<li><strong>监听信道</strong>：设备在发送数据前检测信道是否空闲。</li>
<li><strong>发送数据</strong>：如果信道空闲，立即发送数据。</li>
<li><strong>检测碰撞</strong>：发送时同时监听信道，如果检测到冲突（信号干扰或能量变化），停止发送。</li>
<li>**退避 (Backoff)**：碰撞后等待随机时间重试发送（BEB），减少再次碰撞概率。</li>
</ol>
<ul>
<li><strong>现代以太网多采用交换机连接，并支持全双工通信，每个设备有独立信道，不再使用 CSMA/CD。无碰撞问题，提高效率和可靠性。支持更高的带宽和多设备并发通信。</strong></li>
</ul>
</li>
<li><p>优点：</p>
<ol>
<li>机制简单，适合有线环境。</li>
<li>在小型局域网中具有较高效率。</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>需要碰撞发生后才能检测和处理，效率相对低于 CSMA/CA。</li>
<li>在高负载环境下碰撞频率增加，导致性能下降。</li>
</ol>
</li>
</ul>
<h3 id="CSMA-CA-vs-CSMA-CD"><a href="#CSMA-CA-vs-CSMA-CD" class="headerlink" title="CSMA/CA vs. CSMA/CD"></a>CSMA/CA vs. CSMA/CD</h3><table>
<thead>
<tr>
<th>协议</th>
<th>解决冲突方式</th>
<th>使用环境</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CSMA/CD</strong></td>
<td>冲突检测 + 重传</td>
<td>有线网络（如以太网）</td>
<td>高速、低延迟</td>
</tr>
<tr>
<td><strong>CSMA/CA</strong></td>
<td>冲突避免 + 请求确认</td>
<td>无线网络（如Wi-Fi）</td>
<td>更安全、适合无线不稳定环境</td>
</tr>
</tbody></table>
<ul>
<li><strong>CSMA/CD</strong> 适合<strong>有线网络</strong>，由于信道稳定，可以边发送边检测冲突并重试。</li>
<li><strong>CSMA/CA</strong> 适合<strong>无线网络</strong>，因为无线信号不稳定，通过握手机制降低冲突发生的概率。</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th><strong>CSMA/CD</strong></th>
<th><strong>CSMA/CA</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>应用场景</strong></td>
<td>有线网络（以太网, 802.3）</td>
<td>无线网络（如 Wi-Fi/802.11）</td>
</tr>
<tr>
<td><strong>冲突处理机制</strong></td>
<td>冲突检测（Collision Detection）</td>
<td>冲突避免（Collision Avoidance）</td>
</tr>
<tr>
<td><strong>数据发送机制</strong></td>
<td>先发送数据，边发送边检测冲突。</td>
<td>发送前通过 RTS/CTS 机制避免冲突。</td>
</tr>
<tr>
<td><strong>检测方式</strong></td>
<td>可通过检测电压变化检测冲突（有线信号明显）。</td>
<td>无法检测冲突（无线信号难以同时发送和接收）。</td>
</tr>
<tr>
<td><strong>解决冲突方法</strong></td>
<td>冲突发生后停止发送，退避后重试。</td>
<td>通过等待时间和握手机制减少冲突。</td>
</tr>
<tr>
<td><strong>适用介质</strong></td>
<td>有线介质，信号传播稳定。</td>
<td>无线介质，信号传播容易受到干扰。</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>高速、低延迟，适合稳定传输环境。</td>
<td>延迟较高，适合信号不稳定的环境。</td>
</tr>
<tr>
<td><strong>是否完全避免碰撞</strong></td>
<td>碰撞不可避免，需通过重传恢复</td>
<td>理论上可以避免，但控制开销较大</td>
</tr>
<tr>
<td><strong>现代改进</strong></td>
<td>使用交换机+全双工，完全避免碰撞</td>
<td>保留 CSMA/CA，适合无线共享环境</td>
</tr>
</tbody></table>
<h2 id="WPAN"><a href="#WPAN" class="headerlink" title="WPAN"></a>WPAN</h2><p><strong>WPAN（Wireless Personal Area Network，无线个人区域网络）</strong> 是一种覆盖范围较小的无线网络技术，通常用于个人设备之间的短距离通信</p>
<p><strong>1. 定义与特点</strong></p>
<p><strong>定义：</strong>WPAN 是一种用于设备之间<strong>短距离无线通信</strong>的网络技术，支持个人或便携式设备的互联互通，例如手机、笔记本电脑、无线耳机等。</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>覆盖范围小：</strong> 通常在 <strong>10米</strong> 左右，有些技术最多支持 <strong>100米</strong>。</li>
<li><strong>低功耗：</strong> 适合便携式设备使用，续航时间长。</li>
<li><strong>高便携性：</strong> 支持移动设备随时建立网络。</li>
<li><strong>点对点通信：</strong> 支持多种设备直接连接，无需复杂的基础设施。</li>
<li><strong>成本低廉：</strong> 适合小型设备和物联网应用。</li>
</ul>
<p><strong>2. 常见-协议与标准</strong></p>
<table>
<thead>
<tr>
<th>协议/标准</th>
<th>描述</th>
<th>应用场景</th>
<th>防碰撞协议</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Bluetooth</strong></td>
<td>短距离无线通信标准，覆盖范围约 10 米，低功耗版本为 BLE。</td>
<td>无线耳机、键盘、鼠标、传感器设备等。</td>
<td><strong>FHSS</strong> 和 <strong>AFH</strong></td>
</tr>
<tr>
<td><strong>ZigBee</strong></td>
<td>专为低功耗和低数据速率设计的无线标准，适合物联网应用。</td>
<td>智能家居、远程控制、传感器网络。</td>
<td><strong>CSMA/CA</strong></td>
</tr>
<tr>
<td><strong>Infrared (IR)</strong></td>
<td>基于红外线通信的短距离无线技术，传输速率较低。</td>
<td>遥控器、数据同步、设备控制。</td>
<td><strong>TDMA</strong></td>
</tr>
<tr>
<td><strong>UWB (Ultra-Wideband)</strong></td>
<td>提供高精度定位和高速传输，适合短距离数据交换和测距应用。</td>
<td>精准定位、物联网设备、车联网通信。</td>
<td></td>
</tr>
<tr>
<td><strong>NFC (Near Field Communication)</strong></td>
<td>超短距离无线通信，通常在几厘米范围内进行快速数据交换。</td>
<td>移动支付、门禁卡、电子票务。</td>
<td><strong>TDMA</strong></td>
</tr>
</tbody></table>
<p>小型无线设备（如 RFID）采用 <strong>Slotted ALOHA</strong>，适合简单需求。</p>
<p><strong>3. 应用场景</strong></p>
<ol>
<li><strong>智能家居：</strong> ZigBee 协议用于灯光控制、温度调节等智能设备之间的互联。</li>
<li><strong>物联网（IoT）：</strong> BLE 和 ZigBee 支持低功耗设备之间的数据采集与传输。</li>
<li><strong>移动支付：</strong> NFC 支持手机支付、身份识别等功能。</li>
<li><strong>便携设备互联：</strong> Bluetooth 用于耳机、智能手表等无线连接。</li>
<li><strong>健康监测：</strong> 无线传感器与可穿戴设备之间的数据交互。</li>
<li><strong>精准定位：</strong> UWB 支持室内定位和安全设备跟踪。</li>
</ol>
<p><strong>4. 与其他-网络的比较</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>范围</th>
<th>特点</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>WPAN</strong></td>
<td>1-10 米</td>
<td>短距离、低功耗、适合个人设备通信。</td>
<td>蓝牙、ZigBee、NFC。</td>
</tr>
<tr>
<td><strong>WLAN</strong></td>
<td>10-100 米</td>
<td>支持中等距离的高速无线通信，需要基础设施。</td>
<td>Wi-Fi。</td>
</tr>
<tr>
<td><strong>WMAN</strong></td>
<td>1-10 千米</td>
<td>城域无线网络，适合大规模覆盖。</td>
<td>WiMAX。</td>
</tr>
<tr>
<td><strong>WWAN</strong></td>
<td>覆盖整个地区或国家</td>
<td>广域无线网络，通过蜂窝网络支持移动设备通信。</td>
<td>4G、5G 移动通信网络。</td>
</tr>
</tbody></table>
<h2 id="移动网络"><a href="#移动网络" class="headerlink" title="移动网络"></a>移动网络</h2><p>CSMA/CA 和 CSMA/CD 是分布式介质访问控制协议，属于动态划分信道</p>
<ul>
<li><p>竞争式访问（监听信道）：<strong>CSMA</strong> 并不通过物理上的分离信道来避免冲突，而是让多个用户共享同一个信道。因此会有冲突的风险。当信道繁忙时，用户需要监听并等待信道空闲才能发送数据。信道的访问是竞争式的，用户依赖于监听信道的状态来判断是否发送数据。</p>
</li>
<li><p>适合短距离、设备数量较少的环境，如家庭或办公室的无线网络</p>
</li>
<li><p>通信节点之间自主决定发送时机，不需要集中式调度。</p>
</li>
<li><p>采用竞争机制，存在碰撞和重传开销，效率较低，不适合大规模、高负载的网络环境。</p>
</li>
</ul>
<p>蜂窝网络：</p>
<ul>
<li><p>CDMA TDMA FDMA 这些 MA 技术通过时间、频率、伪随机码等方式将信道划分为多个独立的信道，每个用户独占属于自己的信道，属于静态划分信道</p>
</li>
<li><p><strong>蜂窝网络的流量远高于局域网（如 Wi-Fi）</strong>，需要更高的效率和更严格的资源调度</p>
</li>
<li><p>采用集中式的<strong>基站控制</strong>，具有严格的调度和资源分配机制。</p>
</li>
<li><p>需要支持<strong>用户移动性</strong>，并保证跨基站切换过程的无缝通信。</p>
</li>
<li><p>需要满足严格的<strong>服务质量（QoS）</strong>要求，例如语音通话和视频流的低延迟、高可靠性。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>技术</th>
<th>工作方式</th>
<th>应用场景</th>
<th>主要特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ALOHA</strong></td>
<td>随机发送，碰撞后重传</td>
<td>低负载无线通信</td>
<td>简单但碰撞率高，适合控制信令。</td>
</tr>
<tr>
<td><strong>Slotted ALOHA</strong></td>
<td>分时发送，减少碰撞</td>
<td>控制信道接入（如 GSM 控制信道）RFID</td>
<td>效率较高，但需要时钟同步。</td>
</tr>
<tr>
<td><strong>TDMA</strong></td>
<td>固定时隙分配，无碰撞</td>
<td>GSM、低速蜂窝网络</td>
<td>高效，但资源利用率依赖时隙分配。</td>
</tr>
<tr>
<td><strong>FDMA</strong></td>
<td>频率划分，无碰撞</td>
<td>早期模拟蜂窝和2G网络</td>
<td>固定频率分配，利用率低。</td>
</tr>
<tr>
<td><strong>CDMA</strong></td>
<td>扩频码区分用户，无碰撞</td>
<td>3G 网络、CDMA2000</td>
<td>无需时隙和频率划分，抗干扰能力强。</td>
</tr>
<tr>
<td><strong>OFDMA</strong></td>
<td>子载波分配，无碰撞</td>
<td>4G LTE 和 5G NR</td>
<td>支持多用户，频谱利用率高，适合高负载。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/12/29/408-%E8%AE%A1%E7%BD%91-%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/29/408-%E8%AE%A1%E7%BD%91-%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">OSI参考模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-29 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-29T00:00:00+08:00">2024-12-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:47:24" itemprop="dateModified" datetime="2025-05-05T11:47:24+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>表示层：数据的编解码与加解密，以及压缩，socket也属于这一层</p>
<p>会话层：连接的建立</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h2><p>inter-前缀意为“相互的”，internet表示相互连接的网络，任意的通信协议。</p>
<p>Internet表示全球最大的开放特定计算机网络，使用TCP/IP协议族作为通信规则，前身为ARPANET</p>
<h3 id="发展概述"><a href="#发展概述" class="headerlink" title="发展概述"></a>发展概述</h3><h4 id="ARPANET-gt-Internet"><a href="#ARPANET-gt-Internet" class="headerlink" title="ARPANET -&gt; Internet"></a>ARPANET -&gt; Internet</h4><ul>
<li>1969，ARPANET</li>
<li>mid 1970s，多种网络互联的研究</li>
<li><strong>1983</strong>，TCP/IP成为ARPANET的标准协议，也是公认的Internet诞生时间</li>
</ul>
<h4 id="三级结构的Internet"><a href="#三级结构的Internet" class="headerlink" title="三级结构的Internet"></a>三级结构的Internet</h4><ul>
<li>1985，NSFNET</li>
<li>1990，ARPANET closed</li>
<li>1991，Internet开始商业化</li>
</ul>
<h4 id="多层次ISP结构的Internet"><a href="#多层次ISP结构的Internet" class="headerlink" title="多层次ISP结构的Internet"></a>多层次ISP结构的Internet</h4><ul>
<li>1993，NSFNET逐渐被商用Internet主干网取代，政府机构将其交给ISP运营</li>
<li>1994，万维网WWW技术促使因特网迅猛发展</li>
<li>1995，NSFNET停止运作，Internet正式商业化</li>
</ul>
<h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028134459569.png" alt="image-20241028134459569"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028134717845.png" alt="image-20241028134717845"></p>
<h3 id="标准化—RFC"><a href="#标准化—RFC" class="headerlink" title="标准化—RFC"></a>标准化—RFC</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028134853049.png" alt="image-20241028134853049"></p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028134950779.png" alt="image-20241028134950779"></p>
<h2 id="信息交换技术"><a href="#信息交换技术" class="headerlink" title="信息交换技术"></a>信息交换技术</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028151306409.png" alt="image-20241028151306409"></p>
<h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028151319591.png" alt="image-20241028151319591"></p>
<p>报文加首部，便于给交换机提供信息</p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028151351499.png" alt="image-20241028151351499"></p>
<p>将原来的报文分组，带首部依次发送每个组</p>
<h2 id="计算机网络概念"><a href="#计算机网络概念" class="headerlink" title="计算机网络概念"></a>计算机网络概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><p><strong>互连</strong></p>
<p>通过有线/无线方式进行通信</p>
<p><strong>集合</strong></p>
<p>至少两台以上计算机</p>
<p><strong>自治</strong></p>
<p>独立的计算机，具备自己的硬件和软件，</p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><strong>一些</strong> 通用可编程的<strong>硬件</strong>（包括智能手机、电脑等各种计算机，这些硬件并不只用于数据通信，而且能支持广泛的应用程序）<strong>互联</strong>而成。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><strong>按交换技术分类</strong></p>
<ul>
<li>电路交换</li>
<li>报文交换</li>
<li>分组交换</li>
</ul>
<p><strong>按使用者分类</strong></p>
<ul>
<li>专用</li>
<li>公用</li>
</ul>
<p><strong>按传输介质分类</strong></p>
<ul>
<li>有线 Wired</li>
<li>无线 Wireless</li>
</ul>
<p><strong>按覆盖范围分类</strong></p>
<p>覆盖范围从大到小排列：</p>
<ul>
<li><strong>广域网</strong> <strong>WAN</strong> Wide Area 国家、洲</li>
<li>城域网 MAN Metropolitan Area 城市 </li>
<li><strong>局域网</strong> <strong>LAN</strong> Local Area 机构、楼房</li>
<li>个域网 PAN Personal Area 个人电子设备 组成的多处理机系统WPAN </li>
</ul>
<p><strong>按拓扑结构分类</strong></p>
<ul>
<li><p>总线</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028160634851.png" alt="image-20241028160634851"></p>
</li>
<li><p>星型</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028160648577.png" alt="image-20241028160648577"></p>
</li>
<li><p>环形</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028160700477.png" alt="image-20241028160700477"></p>
</li>
<li><p>网状</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028160718347.png" alt="image-20241028160718347"></p>
</li>
</ul>
<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><h4 id="比特、字节、速率（数据率，比特率）"><a href="#比特、字节、速率（数据率，比特率）" class="headerlink" title="比特、字节、速率（数据率，比特率）"></a>比特、字节、速率（数据率，比特率）</h4><p>1 GiB = 2^30^ B（操作系统）  1 GB = 10^9^ B（硬盘厂商） binary 表示二进制</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028161416193.png" alt="image-20241028161416193"></p>
<ul>
<li>kilo bps, ==k==bps, Mbps, Gbps, Tbps : 1000</li>
<li>B, KB, MB, GB, GB : 1024 </li>
<li>bps 进制为1000，Byte 进制为1024，8 b = 1 B</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028161845070.png" alt="image-20241028161845070"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028162145504.png" alt="image-20241028162145504"></p>
<h4 id="带宽（Band-Width）"><a href="#带宽（Band-Width）" class="headerlink" title="带宽（Band Width）"></a>带宽（Band Width）</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028163439507.png" alt="image-20241028163439507"></p>
<p>1 Mbps = 0.125 MB/s = 128 KB/s 下载速度一般用字节表示</p>
<h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028163850891.png" alt="image-20241028163850891"></p>
<h4 id="时延（Delay）"><a href="#时延（Delay）" class="headerlink" title="时延（Delay）"></a>时延（Delay）</h4><h5 id="主机的发送速率"><a href="#主机的发送速率" class="headerlink" title="主机的发送速率"></a>主机的发送速率</h5><p>主机的发送速率，由<strong>网卡的发送速率</strong>、<strong>信道带宽</strong>、<strong>接口速率</strong>共同决定，取最小的那一个，速率应该尽量匹配。</p>
<h5 id="发送时延、传播时延、处理时延"><a href="#发送时延、传播时延、处理时延" class="headerlink" title="发送时延、传播时延、处理时延"></a>发送时延、传播时延、处理时延</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028164902463.png" alt="image-20241028164902463"></p>
<p><strong>发送时延</strong>-&gt;发送速率和分组数据包长度</p>
<p><strong>传播时延</strong>-&gt;电线长度和光速（电磁波速率）</p>
<p><strong>处理时延</strong>-&gt;忽略</p>
<p>在发送数据时，电流的大小或电压水平会发生变化，这些变化被用来表示一串二进制码。具体来说，以下是这个过程的简要说明：</p>
<ol>
<li><strong>信号变化</strong>：在数字信号传输中，电流或电压会在不同的电平之间切换。比如，当电流达到某个高电压水平时，可以表示比特1，而在低电压水平时表示比特0。</li>
<li><strong>时间同步</strong>：为了确保接收方能够正确识别这些电压变化，发送方和接收方通常会使用时钟信号进行同步。这保证了信号在正确的时间被读取，从而将电流的变化准确地转化为二进制数据。</li>
<li><strong>比特流的形成</strong>：这些电流变化在时间轴上连续发生，从而形成一个比特流（例如 10101010），每个比特对应一个电压状态的变化。</li>
</ol>
<p>通过这些方式，电流的变化被抽象为数字信息，使得数据可以在计算机和网络之间进行有效传输。</p>
<h6 id="哪一个占主导？"><a href="#哪一个占主导？" class="headerlink" title="哪一个占主导？"></a>哪一个占主导？</h6><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028164759500.png" alt="image-20241028164759500"></p>
<h5 id="时延计算要点"><a href="#时延计算要点" class="headerlink" title="时延计算要点"></a>时延计算要点</h5><p><strong>1个分组，1段链路</strong></p>
<p>从上图也可以看出，即使是100MB的数据块，一共是800M个比特，发送时延都是全部计入的，而传播时延只需将距离除以传输速度即可。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029204300220.png" alt="image-20241029204300220"></p>
<p>横坐标是时间，纵坐标是位置，比特是一个接着一个向前传播的，发送时延取决于发送方：每个比特的发送时间都要计入发送时延，传播时延取决于最后一个比特的尾部传到对面所需的时间。</p>
<p><strong>n个分组，n段链路</strong></p>
<ul>
<li>第一段链路：n个分组发送时延+1个传播时延</li>
<li>第二段链路：发送和接收同时进行，等到第一段链路传输完成，第二段还剩最后1个分组未发送，因此第二段链路的实际时延为1个分组发送时延+1个传播时延</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029205641630.png" alt="image-20241029205641630"></p>
<ul>
<li>n段路,m组：n个传播时延+[m+(n-1)*1]个分组发送时延，</li>
<li>存储转发：只有完整地接收一个比特，才能开始发送的工作</li>
</ul>
<p><strong>电路交换和分组交换时延</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029211907159.png" alt="image-20241029211907159"></p>
<ul>
<li>电路先要建立连接，然后直接发送整个报文，<strong>没有存储转发</strong>，相当于一组一链路</li>
<li><strong>分组交换不用先建立连接，每一个分组采用存储转发方式</strong>。牢记四个变量：<ul>
<li><strong>1个分组发送时间</strong>，</li>
<li><strong>分组数量</strong>，</li>
<li><strong>1个链路传播时间</strong>，</li>
<li><strong>链路数量</strong> </li>
</ul>
</li>
</ul>
<p><strong>报文交换和分组交换</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029213402856.png" alt="image-20241029213402856"></p>
<p>报文交换需要整整发送两次，分组交换需要发送组数加1次，流水线</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029214114258.png" alt="image-20241029214114258"></p>
<h5 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h5><p>传播时延x带宽 传播过去一个比特的时间内，发送了多少比特，也称为比特单位的链路长度</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028170442570.png" alt="image-20241028170442570"></p>
<h4 id="往返时间（RTT）"><a href="#往返时间（RTT）" class="headerlink" title="往返时间（RTT）"></a>往返时间（RTT）</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028180207539.png" alt="image-20241028180207539"></p>
<p>Round-Trip 传输耗时要考虑在内，<strong>双向交互</strong></p>
<h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028180135459.png" alt="image-20241028180135459"></p>
<h4 id="丢包率（Packet-Loss）"><a href="#丢包率（Packet-Loss）" class="headerlink" title="丢包率（Packet Loss）"></a>丢包率（Packet Loss）</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028181110596.png" alt="image-20241028181110596"></p>
<p>一些路由算法在未满时就会有丢包操作</p>
<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><h3 id="OSI-参考模型-amp-TCP-IP-模型"><a href="#OSI-参考模型-amp-TCP-IP-模型" class="headerlink" title="OSI 参考模型 &amp; TCP/IP 模型"></a>OSI 参考模型 &amp; TCP/IP 模型</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029195855494.png" alt="image-20241029195855494"></p>
<p>表示层：通信双方交换信息表示问题（数据格式转换），包括字符集转换，数据格式化，文本压缩，数据加密和解密的工作</p>
<p>会话层：对话管理，会话管理</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028182558729.png" alt="image-20241028182558729"  />

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028182833901.png" alt="image-20241028182833901"></p>
<p>网络Network 网际Internet</p>
<p>核心：TCP IP</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028182726625.png" alt="image-20241028182726625"></p>
<h3 id="分层的必要性"><a href="#分层的必要性" class="headerlink" title="分层的必要性"></a>分层的必要性</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028190200363.png" alt="image-20241028190200363"></p>
<h4 id="信号（bit）如何在两台机器之间传输—物理层"><a href="#信号（bit）如何在两台机器之间传输—物理层" class="headerlink" title="信号（bit）如何在两台机器之间传输—物理层"></a>信号（bit）如何在两台机器之间传输—物理层</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028185123827.png" alt="image-20241028185123827"></p>
<h4 id="分组如何在网络内传输—数据链路层（MAC地址）"><a href="#分组如何在网络内传输—数据链路层（MAC地址）" class="headerlink" title="分组如何在网络内传输—数据链路层（MAC地址）"></a>分组如何在网络内传输—数据链路层（MAC地址）</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028185259670.png" alt="image-20241028185259670"></p>
<p>PPP ARP </p>
<h4 id="分组如何在不同网络间传输（路由）—网络层（IP地址）"><a href="#分组如何在不同网络间传输（路由）—网络层（IP地址）" class="headerlink" title="分组如何在不同网络间传输（路由）—网络层（IP地址）"></a>分组如何在不同网络间传输（路由）—网络层（IP地址）</h4><p>核心协议：IP ICMP</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028185452878.png" alt="image-20241028185452878"></p>
<h4 id="进程之间基于网络的通信，端到端的通信—传输层（端口号）"><a href="#进程之间基于网络的通信，端到端的通信—传输层（端口号）" class="headerlink" title="进程之间基于网络的通信，端到端的通信—传输层（端口号）"></a>进程之间基于网络的通信，端到端的通信—传输层（端口号）</h4><p>核心协议：TCP UDP</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028185918747.png" alt="image-20241028185918747"></p>
<h4 id="应用进程之间的交互实现特定网络—应用层"><a href="#应用进程之间的交互实现特定网络—应用层" class="headerlink" title="应用进程之间的交互实现特定网络—应用层"></a>应用进程之间的交互实现特定网络—应用层</h4><p>核心协议:HTTP POP3 SMTP（TCP）  DNS  RTP(UDP)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028190013193.png" alt="image-20241028190013193"></p>
<h3 id="案例：在浏览器敲下一个URL后发生了什么？—应用进程间基于网络的通信"><a href="#案例：在浏览器敲下一个URL后发生了什么？—应用进程间基于网络的通信" class="headerlink" title="案例：在浏览器敲下一个URL后发生了什么？—应用进程间基于网络的通信"></a>案例：在浏览器敲下一个URL后发生了什么？—应用进程间基于网络的通信</h3><p>浏览器发送HTTP请求（访问URL指向的资源），HTTP属于应用层协议，需要向下传输通过物理层传到路由器的物理层，再向上传输到达网络层，经过解析之后，再通过物理层传到服务器的物理层，物理层向上传输到应用层，应用层的Web服务器应用程序会解析HTTP报文，之后返回HTTP响应（URL对应的资源），通过类似的方法传回给浏览器进程。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/9c941130d600033193a3e02800da8fd.jpg" alt="9c941130d600033193a3e02800da8fd"></p>
<h3 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h3><p>对等<strong>实体</strong>通过所属层级的通信<strong>协议</strong>，在下方层级的<strong>服务</strong>（下层两个对等实体间的逻辑通信能够向上层提供服务）下进行逻辑通信（不用考虑其他层，实际上这种通信不存在）。</p>
<h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><h5 id="对等实体"><a href="#对等实体" class="headerlink" title="对等实体"></a>对等实体</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028204310699.png" alt="image-20241028204310699"></p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028204254883.png" alt="image-20241028204254883"></p>
<h5 id="语法：定义报文格式"><a href="#语法：定义报文格式" class="headerlink" title="语法：定义报文格式"></a>语法：定义报文格式</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028204056703.png" alt="image-20241028204056703"></p>
<h5 id="语义：根据语法解析报文内容，定义出双方行为"><a href="#语义：根据语法解析报文内容，定义出双方行为" class="headerlink" title="语义：根据语法解析报文内容，定义出双方行为"></a>语义：根据语法解析报文内容，定义出双方行为</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028204146999.png" alt="image-20241028204146999"></p>
<h5 id="同步：行为发生的时序关系（先后顺序）"><a href="#同步：行为发生的时序关系（先后顺序）" class="headerlink" title="同步：行为发生的时序关系（先后顺序）"></a>同步：行为发生的时序关系（先后顺序）</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028204026941.png" alt="image-20241028204026941"></p>
<h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028203948172.png" alt="image-20241028203948172"></p>
<h5 id="服务访问点、服务原语"><a href="#服务访问点、服务原语" class="headerlink" title="服务访问点、服务原语"></a>服务访问点、服务原语</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028203743701.png" alt="image-20241028203743701"></p>
<h5 id="协议数据单元PDU、服务数据单元SDU"><a href="#协议数据单元PDU、服务数据单元SDU" class="headerlink" title="协议数据单元PDU、服务数据单元SDU"></a>协议数据单元PDU、服务数据单元SDU</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028203909481.png" alt="image-20241028203909481"></p>
<h1 id="面试要点"><a href="#面试要点" class="headerlink" title="面试要点"></a>面试要点</h1><ol>
<li>TCP/IP协议体系的认知 </li>
<li>链路层<ol>
<li>以太网帧的格式</li>
<li>MTU的概念</li>
<li>ARP协议（掌握一下ARP缓存的原理）</li>
</ol>
</li>
<li>网络层<ol>
<li>掌握IP的首部格式</li>
<li>掌握IP的分片</li>
<li>掌握IP选路</li>
<li>ICMP协议<ol>
<li>掌握报文格式</li>
<li>分类：查询 + 差错</li>
<li>两种 + 五种</li>
</ol>
</li>
</ol>
</li>
<li>传输层<ol>
<li>UDP，次要一点，掌握特点和首部各个字段</li>
<li>掌握TCP<ol>
<li>特点 + 首部字段 + 可靠机制</li>
<li>连接控制 ： 三次握手，四次挥手，同时打开，同时关闭，半关闭（可能问到为什么需要）</li>
<li>流量控制机制：滑动窗口，慢启动，拥塞避免，快速重传，快速恢复</li>
<li>超时重传机制</li>
</ol>
</li>
</ol>
</li>
<li>应用层<ol>
<li>掌握DNS协议<ol>
<li>名字空间</li>
<li>指针查询（反向查找或逆向解析）基本原理</li>
<li>DNS缓存</li>
</ol>
</li>
<li>FTP协议（活化石）：<ol>
<li>控制流和数据流</li>
<li>两种工作模式： PASV 和 PORT</li>
<li>各种指令和响应码</li>
<li>断点续传和匿名FTP的概念</li>
</ol>
</li>
<li>HTTP协议：<ol>
<li>报文格式：请求报文，响应报文，请求头各种字段，响应头各种字段。</li>
<li>HTTP状态码。</li>
<li>HTTPS协议。</li>
<li>握手的详细过程。</li>
<li>摘要算法，数字签名，数字证书的原理和过程。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">OSI模型 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p>在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/9636548?fromModule=lemma_inlink">网络通信</a>的过程中，将发出数据的主机称为源主机，接收数据的主机称为目的主机。当源主机发出数据时，数据在源主机中从上层向下层传送。源主机中的应用进程先将数据交给应用层，应用层加上必要的控制信息就成了报文流，向下传给传输层。传输层将收到的数据单元加上本层的控制信息，形成报文段、数据报，再交给网际层。网际层加上本层的控制信息据报，传给网络接口层。网络接口层将网际层交下来的IP数据报组装成帧，并以比特流的形式传给网络硬件（即物理层），数据就离开源主机。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921220715692.png" alt="image-20240921220715692"></p>
<h1 id="物理层、数据链路层"><a href="#物理层、数据链路层" class="headerlink" title="物理层、数据链路层"></a>物理层、数据链路层</h1><p><strong>双绞线、集线器（HUB）</strong>：多台计算机之间物理连接，遇到并发情况会有<strong>数据碰撞与紊乱</strong>，而且数据都是广播形式传递，无法同时向上和向下传输（半双工，相当于对讲机，只能听不能说）。CSMA/CD协议，发送以前进行载波侦听。属于物理层。</p>
<p><strong>交换机：</strong>全双工。物理连接，也支持和其他交换机连接（桥接）能更好处理并发情况，里面有一张mac地址表，用来区分不同设备，计算机1第一次联络计算机2，将计算机2的MAC地址发送给交换机，由于不知道这个mac对应哪个接口，交换机通过数据泛洪的方式，广播给所有计算机，都收到了，但只有计算机2对应的接口会回应，mac表中添加计算机2的信息，以后他们的通信就不需要广播了。<u>在数据链路层</u>。</p>
<p>重点：以太网帧 MTU概念 ARP协议(MAC和IP互查，缓存)</p>
<h2 id="协议-1"><a href="#协议-1" class="headerlink" title="协议"></a>协议</h2><h3 id="MAC-LLC"><a href="#MAC-LLC" class="headerlink" title="MAC LLC"></a>MAC LLC</h3><table>
<thead>
<tr>
<th align="right"></th>
<th><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">介质访问控制(MAC, Media Access Control)</a></th>
</tr>
</thead>
<tbody><tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2">电路交换(Channel-based)</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A2%91%E5%88%86%E5%A4%9A%E5%9D%80">FDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E4%BA%A4%E9%A0%BB%E5%88%86%E5%A4%9A%E5%9D%80">OFDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%B3%A2%E5%88%86%E5%A4%9A%E5%9D%80&action=edit&redlink=1">WDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SC-FDMA">SC-FDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%B6%E5%88%86%E5%A4%9A%E5%9D%80">TDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%9A%E9%A2%91%E6%97%B6%E5%88%86%E5%A4%9A%E5%9D%80&action=edit&redlink=1">MF-TDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%87%AA%E7%BB%84%E7%BB%87%E6%97%B6%E5%88%86%E5%A4%9A%E5%9D%80&action=edit&redlink=1">STDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%A2%BC%E5%A4%9A%E9%87%8D%E9%80%B2%E6%8E%A5">CDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/W-CDMA">W-CDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TD-CDMA">TD-CDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TD-SCDMA">TD-SCDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DS-CDMA">DS-CDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/FH-CDMA">FH-CDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E4%BA%A4%E9%A0%BB%E5%88%86%E5%A4%9A%E5%9D%80">OFHMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%9A%E8%BD%BD%E6%B3%A2%E7%A0%81%E5%88%86%E5%A4%9A%E5%9D%80&action=edit&redlink=1">MC-CDMA</a>SDMA<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%A7%E5%AE%B9%E9%87%8F%E7%A9%BA%E5%88%86%E5%A4%9A%E5%9D%80&action=edit&redlink=1">HC-SDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%9E%81%E5%88%86%E5%A4%9A%E5%9D%80&action=edit&redlink=1">PDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%84%89%E5%86%B2%E5%9C%B0%E5%9D%80%E5%A4%9A%E9%87%8D%E5%AD%98%E5%8F%96&action=edit&redlink=1">PAMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%97%B6%E6%9C%BA%E9%A9%B1%E5%8A%A8%E5%A4%9A%E5%9D%80&action=edit&redlink=1">ODMA</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">分组交换(Packet-based)</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%86%B2%E7%AA%81%E5%B9%B2%E6%89%B0%E6%81%A2%E5%A4%8D&action=edit&redlink=1">冲突干扰恢复</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%86%B2%E7%AA%81%E9%81%BF%E5%85%8D&action=edit&redlink=1">冲突避免</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%97%A0%E5%86%B2%E7%AA%81&action=edit&redlink=1">无冲突</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ALOHA">ALOHA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Slotted_ALOHA">Slotted ALOHA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=R-ALOHA&action=edit&redlink=1">R-ALOHA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%A6%E5%86%B2%E7%AA%81%E9%81%BF%E5%85%8D%E7%9A%84%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5&action=edit&redlink=1">MACA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%A6%E5%86%B2%E7%AA%81%E9%81%BF%E5%85%8D%E7%9A%84%E6%97%A0%E7%BA%BF%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5&action=edit&redlink=1">MACAW</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BD%BD%E6%B3%A2%E4%BE%A6%E5%90%AC%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE">CSMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CSMA/CD">CSMA/CD</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CSMA/CA">CSMA/CA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%88%86%E6%95%A3%E5%BC%8F%E5%8D%94%E8%AA%BF%E5%8A%9F%E8%83%BD&action=edit&redlink=1">DCF</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%82%B9%E5%8D%8F%E8%B0%83%E5%8A%9F%E8%83%BD">PCF</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%B7%B7%E5%90%88%E5%8D%8F%E8%B0%83%E5%8A%9F%E8%83%BD&action=edit&redlink=1">HCF</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%B8%A6%E5%86%B2%E7%AA%81%E9%81%BF%E5%85%8D%E4%B8%8E%E5%88%86%E8%A7%A3%E7%9A%84%E6%9C%89%E8%BD%BD%E6%B3%A2%E4%BE%A6%E5%90%AC%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE&action=edit&redlink=1">CSMA/CARP</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A4%E7%89%8C%E7%8E%AF">令牌环</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A4%E7%89%8C%E6%80%BB%E7%BA%BF">令牌总线</a><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mobile_Slotted_Aloha">MS-ALOHA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9A%A8%E5%BB%BA%E5%8D%B3%E9%80%A3%E7%B6%B2%E8%B7%AF">MANET</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BB%8A%E8%BC%89%E9%9A%A8%E6%84%8F%E8%A1%8C%E5%8B%95%E7%B6%B2%E8%B7%AF">VANET</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%BB%B6%E8%BF%9F%E5%AE%B9%E5%BF%8D%E7%BD%91%E7%BB%9C&action=edit&redlink=1">DTN</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%8A%A8%E6%80%81%E6%BA%90%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE&action=edit&redlink=1">动态源路由协议</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%99%E5%B7%A5">双工方法</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%99%E5%B7%A5#%E6%99%82%E5%88%86%E9%9B%99%E5%B7%A5">时分双工</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%99%E5%B7%A5#%E9%A0%BB%E5%88%86%E9%9B%99%E5%B7%A5">频分双工</a></td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E9%93%BE%E8%B7%AF%E6%8E%A7%E5%88%B6">逻辑链路控制 - 维基百科，自由的百科全书 (wikipedia.org)</a> LLC</p>
<h3 id="无线网络"><a href="#无线网络" class="headerlink" title="无线网络"></a>无线网络</h3><h4 id="移动网络-Celluar-Network"><a href="#移动网络-Celluar-Network" class="headerlink" title="移动网络 (Celluar Network)"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%9C%82%E7%AA%9D%E7%BD%91%E7%BB%9C">移动网络 (Celluar Network)</a></h4><table>
<thead>
<tr>
<th align="right"></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/0G">0G</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%84%A1%E7%B7%9A%E9%9B%BB%E8%A9%B1">无线电话</a> （1946）</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E5%8B%95%E9%9B%BB%E8%A9%B1%E7%B3%BB%E7%B5%B1">MTS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Improved_Mobile_Telephone_Service&action=edit&redlink=1">IMTS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Altai_%EF%BC%88mobile_telephone_system%EF%BC%89&action=edit&redlink=1">Altai</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=OLT_%EF%BC%88mobile_network%EF%BC%89&action=edit&redlink=1">OLT</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=MTD_%EF%BC%88mobile_network%EF%BC%89&action=edit&redlink=1">MTA - MTB - MTC - MTD</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Advanced_Mobile_Telephone_System&action=edit&redlink=1">AMTS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Autotel&action=edit&redlink=1">Autotel （PALM）</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Autoradiopuhelin&action=edit&redlink=1">ARP</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=B-Netz&action=edit&redlink=1">B-Netz</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=AMR_radiotelephone_network_%EF%BC%88Czechoslovakia%EF%BC%89&action=edit&redlink=1">AMR</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/1G">1G</a>（1979）</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E6%AF%94%E5%BC%8F%E8%A1%8C%E5%8B%95%E9%9B%BB%E8%A9%B1%E7%B3%BB%E7%B5%B1">AMPS</a>家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E6%AF%94%E5%BC%8F%E8%A1%8C%E5%8B%95%E9%9B%BB%E8%A9%B1%E7%B3%BB%E7%B5%B1">AMPS - N-AMPS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Total_Access_Communication_System&action=edit&redlink=1">TACS - ETACS</a>其它<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Nordic_Mobile_Telephone&action=edit&redlink=1">NMT</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=C-Netz&action=edit&redlink=1">C-450</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Hicap&action=edit&redlink=1">Hicap</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Mobitex&action=edit&redlink=1">Mobitex</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=DataTAC&action=edit&redlink=1">DataTAC</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/2G">2G</a>（1991）</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GSM">GSM</a>/<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/3GPP">3GPP</a>家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GSM">GSM</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%B7%AF%E4%BA%A4%E6%8F%9B%E6%95%B8%E6%93%9A">CSD - HSCSD</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/3GPP2">3GPP2</a>家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CdmaOne">cdmaOne （IS-95）</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E6%AF%94%E5%BC%8F%E8%A1%8C%E5%8B%95%E9%9B%BB%E8%A9%B1%E7%B3%BB%E7%B5%B1">AMPS</a>家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/D-AMPS">D-AMPS （IS-54 and IS-136）</a>其它<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%9C%82%E7%AA%9D%E6%95%B0%E5%AD%97%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE">CDPD</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E6%95%B0%E5%AD%97%E5%A2%9E%E5%BC%BA%E7%BD%91%E7%BB%9C">iDEN</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/PDC">PDC</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AA%E4%BA%BA%E6%89%8B%E6%8C%81%E5%BC%8F%E7%94%B5%E8%AF%9D%E7%B3%BB%E7%BB%9F">PHS</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/2G">2G过渡 （2.5G, 2.75G）</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GSM">GSM</a>/3GPP家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GPRS">GPRS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GSM%E5%A2%9E%E5%BC%BA%E6%95%B0%E6%8D%AE%E7%8E%87%E6%BC%94%E8%BF%9B">EDGE/EGPRS - Evolved EDGE</a>3GPP2家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CDMA2000">CDMA2000 1X</a>（TIA/EIA/IS-2000）<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CDMA2000">CDMA2000 1X Advanced</a>其它<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E6%95%B0%E5%AD%97%E5%A2%9E%E5%BC%BA%E7%BD%91%E7%BB%9C">WiDEN</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E5%A2%9E%E5%BC%B7%E7%84%A1%E7%B7%9A%E9%9B%BB%E8%A9%B1%E7%B3%BB%E7%B5%B1">DECT</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/3G">3G</a>（2001）</td>
<td>3GPP家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E7%A7%BB%E5%8A%A8%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F">UMTS</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/W-CDMA">UTRA-FDD / W-CDMA</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/FOMA">FOMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TD-SCDMA">UTRA-TDD LCR / TD-SCDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E7%A7%BB%E5%8A%A8%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F">UTRA-TDD HCR / TD-CDMA</a>3GPP2家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EV-DO">CDMA2000 1xEV-DO Release 0</a>（TIA/IS-856）</td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/3G">3G过渡 （3.5G, 3.75G, 3.9G）</a></td>
<td>3GPP家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%80%9F%E5%B0%81%E5%8C%85%E5%AD%98%E5%8F%96">HSPA</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%80%9F%E5%B0%81%E5%8C%85%E5%AD%98%E5%8F%96">HSDPA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%80%9F%E5%B0%81%E5%8C%85%E5%AD%98%E5%8F%96">HSUPA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%BC%94%E8%BF%9B%E5%BC%8FHSPA">HSPA+</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%BC%94%E8%BF%9B%E5%BC%8FHSPA">DC-HSDPA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%95%B7%E6%9C%9F%E6%BC%94%E9%80%B2%E6%8A%80%E8%A1%93">LTE</a>（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/E-UTRA">E-UTRA</a>）3GPP2家族CDMA2000 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EV-DO">1xEV-DO Revision A</a>（TIA/EIA/IS-856-A）<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EV-DO">EV-DO Revision B</a>（TIA/EIA/IS-856-B）<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EV-DO">EV-DO Revision C</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%B5%E6%B0%94%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%BC%9A">IEEE</a>家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WiMAX">Mobile WiMAX</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IEEE_802.16">IEEE 802.16e</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E4%BA%A4%E9%A0%BB%E5%88%86%E5%A4%8D%E7%94%A8">Flash-OFDM</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=IEEE_802.20&action=edit&redlink=1">iBurst （IEEE 802.20）</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WiBro">WiBro</a>   <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%B4%B2%E7%94%B5%E4%BF%A1%E6%A0%87%E5%87%86%E5%8D%8F%E4%BC%9A">ETSI</a>家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=HiperMAN&action=edit&redlink=1">HiperMAN</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/4G">4G</a>（2009） <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=IMT_Advanced&action=edit&redlink=1">IMT Advanced</a> （2013）</td>
<td>3GPP家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%B2%E9%9A%8E%E9%95%B7%E6%9C%9F%E6%BC%94%E9%80%B2%E6%8A%80%E8%A1%93">LTE Advanced</a>（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/E-UTRA">E-UTRA</a>）<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%B2%E9%9A%8E%E5%8D%87%E7%B4%9A%E7%89%88%E9%95%B7%E6%9C%9F%E6%BC%94%E9%80%B2%E6%8A%80%E8%A1%93">LTE Advanced Pro</a>（4.5G Pro/pre-5G/4.9G）IEEE家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WiMAX">WiMAX</a>（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IEEE_802.16">IEEE 802.16</a>m） WiMax 2.1 （<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LTE-TDD">LTE-TDD</a>/ <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%95%B7%E6%9C%9F%E6%BC%94%E9%80%B2%E6%8A%80%E8%A1%93">TD-LTE</a>）<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WiBro">WiBro</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/5G">5G</a>（2019） <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=IMT-2020&action=edit&redlink=1">IMT-2020</a> （开发中）</td>
<td>3GPP家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/5G_NR">NR</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=NR-IIoT&action=edit&redlink=1">NR-IIoT</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=LTE-M&action=edit&redlink=1">LTE-M</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/NB-IoT">NB-IoT</a> 其它<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=DECT-5G&action=edit&redlink=1">DECT-5G</a></td>
</tr>
<tr>
<td align="right">相关</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%9C%82%E7%AA%9D%E7%BD%91%E7%BB%9C">蜂窝网络</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A2%91%E5%88%86%E5%A4%9A%E5%9D%80">FDMA</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E4%BA%A4%E9%A0%BB%E5%88%86%E5%A4%9A%E5%9D%80">OFDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%B6%E5%88%86%E5%A4%9A%E5%9D%80">TDMA</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Self-organized_time-division_multiple_access&action=edit&redlink=1">STDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%89%A9%E9%A2%91">SSMA</a> CDMA<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A9%BA%E5%88%86%E5%A4%9A%E5%9D%80">SDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A0%BB%E8%AD%9C%E6%95%88%E7%8E%87">频谱效率</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%9C%82%E7%AA%9D%E7%BD%91%E7%BB%9C%E9%A2%91%E7%8E%87&action=edit&redlink=1">频段</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GSM%E9%A2%91%E6%AE%B5">GSM</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/UMTS%E9%A2%91%E6%AE%B5">UMTS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%80%8B%E4%BA%BA%E9%80%9A%E8%A8%8A%E6%9C%8D%E5%8B%99">PCS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=LTE_frequency_bands&action=edit&redlink=1">LTE</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/5G_NR%E9%A2%91%E6%AE%B5">5G NR</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%AF%AC%E9%A0%BB">移动宽频</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Push-to-talk">Push-to-talk</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MIMO">MIMO</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%95%BF%E6%9C%9F%E6%BC%94%E8%BF%9B%E8%AF%AD%E9%9F%B3%E6%89%BF%E8%BD%BD">VoLTE</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/VoNR">VoNR</a></td>
</tr>
</tbody></table>
<h4 id="无线局域网-WLAN"><a href="#无线局域网-WLAN" class="headerlink" title="无线局域网  (WLAN)"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91">无线局域网  (WLAN)</a></h4><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IEEE_802.11_(%E5%8E%9F%E5%A7%8B%E6%A0%87%E5%87%86)">IEEE 802.11</a> 是无线局域网（WLAN）的通用标准。</p>
<p>1999年，几家富有远见的公司联合起来组成了一个全球性非营利性协会——无线以太网兼容性联盟（Wireless Ethernet Compatibility Alliance, WECA），其目标是使用一种新的无线网络技术，无论品牌如何，都能带来最佳的用户体验。在2000年，该小组采用术语“Wi-Fi”作为其技术工作的专有名称，并宣布了正式名称：Wi-Fi Alliance。Wi-Fi产品经由Wi-Fi联盟的一家独立授权测试实验室进行严格测试，产品成功通过测试后，授予制造商或销售商使用Wi-Fi标志、Wi-Fi CERTIFIED标志和相关商标，Wi-Fi联盟使用术语“Wi-Fi CERTIFIED”来称呼这类通过认证的产品。802.11ax为Wi-Fi 6。</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Wi-Fi">Wi-Fi</a>与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IEEE_802.11">IEEE 802.11</a>常常被混淆，两者的区别可以概述为IEEE 802.11是一种无线局域网标准，而Wi-Fi是IEEE 802.11标准的一种实现。</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%84%A1%E7%B7%9A%E6%8E%A5%E5%85%A5%E9%BB%9E">无线接入点 - 维基百科，自由的百科全书 (wikipedia.org)</a> WAP</p>
<h5 id="无线个人网-WPAN"><a href="#无线个人网-WPAN" class="headerlink" title="无线个人网 (WPAN)"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%BA%BF%E4%B8%AA%E4%BA%BA%E7%BD%91">无线个人网 (WPAN)</a></h5><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%97%8D%E7%89%99">蓝牙 - 维基百科，自由的百科全书 (wikipedia.org)</a> Bluetooth (WPAN，IEEE 802.15.1)</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ZigBee">ZigBee - 维基百科，自由的百科全书 (wikipedia.org)</a> ZigBee (LR-WPAN，IEEE 802.15.4)</p>
<h3 id="有线局域网-LAN"><a href="#有线局域网-LAN" class="headerlink" title="有线局域网 (LAN)"></a>有线局域网 (LAN)</h3><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91">以太网 - 维基百科，自由的百科全书 (wikipedia.org)</a> Ethernet LAN (IEEE 802.3)</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AE">点对点协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> PPP</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/PPPoE">PPPoE - 维基百科，自由的百科全书 (wikipedia.org)</a> PPP over Ethernet PPPoE</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/PPPoA">PPPoA - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%92%A5%E8%99%9F%E9%80%A3%E7%B7%9A">拨号连接 - 维基百科，自由的百科全书 (wikipedia.org)</a> Dial-up</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%88%B6%E8%A7%A3%E8%B0%83%E5%99%A8">调制解调器 - 维基百科，自由的百科全书 (wikipedia.org)</a> 猫 modem</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E7%94%A8%E6%88%B7%E7%BA%BF%E8%B7%AF">数字用户线路 - 维基百科，自由的百科全书 (wikipedia.org)</a> DSL</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ADSL">非对称数字用户线路- 维基百科，自由的百科全书 (wikipedia.org)</a> ADSL</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%BA%E6%8E%A5%E5%B0%88%E7%B7%9A">固接专线 - 维基百科，自由的百科全书 (wikipedia.org)</a> IPLC</p>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E4%BA%A4%E6%8F%9B%E5%99%A8">网络交换机 - 维基百科，自由的百科全书 (wikipedia.org)</a> Network switch</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A9%8B%E6%8E%A5%E5%99%A8">桥接器 - 维基百科，自由的百科全书 (wikipedia.org)</a> 网桥 Network Bridge</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E5%8D%A1">网络适配器 - 维基百科，自由的百科全书 (wikipedia.org)</a> 网卡 Network Adapter</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%86%E7%B7%9A%E5%99%A8">集线器 - 维基百科，自由的百科全书 (wikipedia.org)</a> Hub</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/8P8C">8P8C - 维基百科，自由的百科全书 (wikipedia.org)</a> RJ45</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%B2%E8%A1%8C%E7%AB%AF%E5%8F%A3">串行接口 - 维基百科，自由的百科全书 (wikipedia.org)</a> COM</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E8%A1%8C%E7%AB%AF%E5%8F%A3">并行端口 - 维基百科，自由的百科全书 (wikipedia.org)</a> LPT</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/USB">USB - 维基百科，自由的百科全书 (wikipedia.org)</a> Universal Serial Bus</p>
<h2 id="校验算法"><a href="#校验算法" class="headerlink" title="校验算法"></a>校验算法</h2><p>CRC（循环冗余校验）和汉明码都是错误检测和纠正的算法，但它们的底层原理和用途有所不同：</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%A0%E9%94%99%E7%A0%81">纠错码 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<h3 id="CRC（循环冗余校验）"><a href="#CRC（循环冗余校验）" class="headerlink" title="CRC（循环冗余校验）"></a>CRC（循环冗余校验）</h3><p>CRC 是一种通过数学方法检测数据传输错误的技术。它在底层通过<strong>多项式除法</strong>来生成校验码，将数据视为一个二进制多项式，并与一个预定的生成多项式相除。CRC的底层原理包括以下几个步骤：</p>
<ol>
<li><strong>数据多项式化</strong>：将待校验的数据视为一个二进制多项式，例如“1011”对应 ($x^3 + x + 1$)。</li>
<li><strong>生成多项式</strong>：选择一个生成多项式（如 CRC-32 使用 ($x^{32} + x^{26} + x^{23} + \ldots + x + 1$)）。</li>
<li><strong>模2除法</strong>：将数据多项式和生成多项式进行模2除法（不需要进位的二进制除法），余数即为CRC校验码。</li>
<li><strong>传输和校验</strong>：接收方用相同的生成多项式再进行除法运算，若余数为零，则说明数据没有错误。</li>
</ol>
<p>CRC 常用于检测网络传输中的错误，因为其计算效率高，适合硬件实现，并能检测较高概率的错误。</p>
<p>2^n^M  % P = FCS (Frame Check Sequence, 帧检验序列)</p>
<p>2^n^M + FCS % P = 0  如果M在传输过程中出现差错，结果将几乎不可能为0</p>
<h3 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h3><p>汉明码是一种<strong>错误纠正码</strong>，可以检测并纠正单比特错误，部分版本还能检测双比特错误。它的原理基于在数据中加入特定的校验位，使得数据在传输时出现单比特错误时可以被定位并纠正。</p>
<ol>
<li><strong>奇偶校验位的设置</strong>：汉明码会在原始数据中插入多个位置的奇偶校验位。这些位置是按二的幂次方设置的（如第1、2、4、8位等），每个校验位负责检查某些特定位置的数据位。</li>
<li><strong>校验位计算</strong>：每个校验位用来检查特定数据位的奇偶性。对于一个给定的二进制数据，可以通过指定的位操作生成一组校验位。</li>
<li><strong>错误检测和纠正</strong>：传输后，通过重新计算校验位的结果并与收到的校验位对比，可以检测并定位单个比特错误的位置，然后进行纠正。</li>
</ol>
<p>汉明码适用于内存或磁盘数据校验和恢复等场景，但较不适合复杂错误模式的网络数据传输。</p>
<h2 id="多址接入"><a href="#多址接入" class="headerlink" title="多址接入"></a>多址接入</h2><p>当多个用户接入网络时，解决如何高效地共享一个无线资源（时间/频率/空间/载波）的技术。</p>
<h3 id="CSMA-载波侦听多路访问"><a href="#CSMA-载波侦听多路访问" class="headerlink" title="CSMA 载波侦听多路访问"></a>CSMA 载波侦听多路访问</h3><p>严格意义上不算MA，因为并没有真正共享</p>
<p>CSMA（Carrier Sense Multiple Access） 是一种<strong>载波监听多址接入</strong>协议，通常用于有线网络中，允许多台设备共享同一信道资源。CSMA 的核心思想是通过监听信道来避免冲突，主要有以下两种变体：</p>
<h4 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h4><p><strong>（Collision Detection，碰撞检测）</strong>半双工</p>
<ul>
<li>应用于有线以太网（如 IEEE 802.3 标准）。在此模式下，设备在发送数据前先监听信道。如果信道空闲，数据即可发送；如果信道忙，设备会等待空闲后发送。</li>
<li>若在发送过程中发生冲突（检测到信号碰撞），设备会立即停止发送，并在随机时间后重试。</li>
<li>CSMA/CD 主要用于有线网络，如早期的以太网，由于信道冲突频繁，现已逐渐被交换式以太网替代。</li>
</ul>
<h4 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA/CA"></a>CSMA/CA</h4><p><strong>（Collision Avoidance，碰撞避免）</strong></p>
<ul>
<li>常用于无线网络（如 Wi-Fi/IEEE 802.11），因无线信道难以检测碰撞。</li>
<li>CSMA/CA 通过在发送数据前监听信道，并等待一定时间以减少冲突发生，确保信道空闲时才进行发送。</li>
<li>CSMA/CA 的碰撞避免机制更加适合无线信道的开放式环境。</li>
</ul>
<h3 id="CDMA-码分多址"><a href="#CDMA-码分多址" class="headerlink" title="CDMA 码分多址"></a>CDMA 码分多址</h3><p>多路复用技术</p>
<p>CDMA 是<strong>码分多址接入</strong>（Code Division Multiple Access）技术，主要用于蜂窝网络中。CDMA 的关键思想是通过为每个用户分配独特的伪随机码（PN 码）来区分不同用户的数据流，这样多个用户可以在同一频带内同时发送数据而不产生干扰。CDMA 的工作原理和优势如下：</p>
<ul>
<li><strong>伪随机码分配</strong>：每个用户的数据流会被一个特定的伪随机码调制，接收端利用相同的伪随机码解调，从而提取对应的数据。</li>
<li><strong>同时占用信道</strong>：不同用户使用不同的伪随机码，可以在同一频带内同时传输数据，极大提高了频谱利用率。</li>
<li><strong>抗干扰能力强</strong>：CDMA 的码分多址方式在信号干扰和路径损耗上有较强的容忍度，适合蜂窝移动通信。</li>
<li><strong>应用</strong>：CDMA 主要应用于 2G、3G 的通信网络，特别是在美国、韩国的移动通信系统中被广泛使用，如 CDMA2000。</li>
</ul>
<h4 id="WCDMA"><a href="#WCDMA" class="headerlink" title="WCDMA"></a>WCDMA</h4><p>WCDMA（Wideband Code Division Multiple Access） 是<strong>宽带码分多址接入</strong>技术，基于 CDMA 的一种改进版本，是 3GPP（第三代合作伙伴计划）推出的 3G 标准之一。它在 CDMA 基础上使用更宽的带宽，从而提高数据速率和网络容量，是全球范围内 3G 网络的主流技术之一。</p>
<ul>
<li><strong>更宽的频谱带宽</strong>：WCDMA 使用 5 MHz 的带宽（相比 CDMA 的 1.25 MHz 带宽），支持更高的数据传输速率和更多用户接入。</li>
<li><strong>更高的数据速率</strong>：在理想条件下，WCDMA 可实现高达 2 Mbps 的速率，支持语音、数据、视频等多种业务。</li>
<li><strong>频谱效率</strong>：通过更宽的频谱和 CDMA 的抗干扰特性，WCDMA 能在高用户密度环境下提供稳定的连接。</li>
<li><strong>应用</strong>：WCDMA 被广泛应用于全球的 3G 网络中，尤其是欧洲和亚洲的 GSM 网络运营商采用 WCDMA 技术升级到 3G。此技术在 4G LTE 的发展中逐步退出历史舞台。</li>
</ul>
<h4 id="TD-SCDMA"><a href="#TD-SCDMA" class="headerlink" title="TD-SCDMA"></a>TD-SCDMA</h4><p><strong>TD-SCDMA</strong>（Time Division Synchronous Code Division Multiple Access，时分同步码分多址）是中国自主研发的第三代移动通信标准，也是 3G 标准之一，由中国大唐电信和西门子公司联合开发，并被国际电信联盟（ITU）接纳为 3G 标准之一。TD-SCDMA 在中国得到了广泛的应用，但在国际市场上相对较少。</p>
<p>TD-SCDMA 的优势</p>
<ul>
<li><strong>频谱利用率高</strong>：采用 TDD 模式和同步技术，使得 TD-SCDMA 的频谱利用率相比传统的 FDD 制式更高，适合频谱资源紧张的环境。</li>
<li><strong>适合不对称数据业务</strong>：可以根据实际流量需求调整上下行资源分配，特别适合数据业务占用较高的场景。</li>
<li><strong>自主知识产权</strong>：TD-SCDMA 是中国自主研发的 3G 标准，拥有大量核心专利，减少了对外部技术的依赖。</li>
</ul>
<p>TD-SCDMA 的局限性</p>
<ul>
<li><strong>国际支持度低</strong>：TD-SCDMA 主要在中国应用，国际上接受度不高，设备的生态系统较小，终端设备支持度有限。</li>
<li><strong>覆盖和稳定性问题</strong>：与 WCDMA 和 CDMA2000 相比，TD-SCDMA 的覆盖范围和信号穿透性相对较差，容易受信号衰减影响。</li>
<li><strong>技术升级受限</strong>：由于 3G 技术已经逐渐被淘汰，TD-SCDMA 的技术升级和演进受到了较大限制。</li>
</ul>
<h3 id="FDMA-频分多址"><a href="#FDMA-频分多址" class="headerlink" title="FDMA 频分多址"></a>FDMA 频分多址</h3><p>FDMA（Frequency Division Multiple Access）</p>
<ul>
<li><strong>原理</strong>：通过将可用频谱划分成多个独立的频段，每个用户使用一个独立的频段传输数据，彼此不会干扰。</li>
<li><strong>应用</strong>：早期的模拟蜂窝网络（如 1G），一些卫星通信系统也使用 FDMA。</li>
<li><strong>特点</strong>：实现简单，适合带宽分配相对固定的场景，但频谱利用效率不高。</li>
</ul>
<h4 id="OFDMA-正交频分多址"><a href="#OFDMA-正交频分多址" class="headerlink" title="OFDMA 正交频分多址"></a>OFDMA 正交频分多址</h4><p>OFDMA（Orthogonal Frequency Division Multiple Access）</p>
<ul>
<li><strong>原理</strong>：将信道划分为多个子载波，通过正交性减少子载波之间的干扰，允许多个用户同时占用不同的子载波进行传输。</li>
<li><strong>应用</strong>：4G LTE、Wi-Fi 6（802.11ax）、WiMAX（802.16）等。</li>
<li><strong>特点</strong>：频谱利用效率高，适合宽带数据传输，并在密集环境下表现优异。</li>
</ul>
<h4 id="SC-FDMA-单载波频分多址"><a href="#SC-FDMA-单载波频分多址" class="headerlink" title="SC-FDMA 单载波频分多址"></a>SC-FDMA 单载波频分多址</h4><p>SC-FDMA（Single Carrier Frequency Division Multiple Access）单载波频分多址</p>
<ul>
<li><p><strong>原理</strong>：将上行链路的数据划分成多个子载波进行传输，使用单载波调制来减少功率峰值。</p>
</li>
<li><p><strong>应用</strong>：4G LTE 上行链路。</p>
</li>
<li><p><strong>特点</strong>：降低了上行链路中的峰均功率比（PAPR），适合移动设备的功率限制。</p>
</li>
<li></li>
</ul>
<h3 id="TDMA-时分多址"><a href="#TDMA-时分多址" class="headerlink" title="TDMA 时分多址"></a>TDMA 时分多址</h3><p>TDMA（Time Division Multiple Access）</p>
<ul>
<li>原理：将信道分为不同的时间片，每个用户轮流在特定时间片上使用信道，从而达到多用户共享信道的目的。</li>
<li><strong>应用</strong>：GSM（2G）、PHS、部分卫星通信。</li>
<li><strong>特点</strong>：在一定程度上提高了频谱利用率，但时延较高，受限于用户数量增加后的带宽分配。</li>
</ul>
<h3 id="SDMA-空分多址"><a href="#SDMA-空分多址" class="headerlink" title="SDMA 空分多址"></a>SDMA 空分多址</h3><p>SDMA（Space Division Multiple Access）</p>
<ul>
<li><strong>原理</strong>：通过空间隔离的方式区分用户信号，通常结合智能天线等技术，在同一频段和时间使用不同方向的波束来服务不同用户。</li>
<li><strong>应用</strong>：主要在蜂窝基站和无线局域网中使用，配合 MIMO（多输入多输出）技术使用，增强信道容量。</li>
<li><strong>特点</strong>：适合用户密集度高的环境，频谱利用效率较高。</li>
</ul>
<h3 id="NOMA-非正交多址"><a href="#NOMA-非正交多址" class="headerlink" title="NOMA 非正交多址"></a>NOMA 非正交多址</h3><p>NOMA（Non-Orthogonal Multiple Access）</p>
<ul>
<li><strong>原理</strong>：不同用户可以同时占用同一时间和频率资源，通过功率差异进行用户分离，接收端使用 SIC（Successive Interference Cancellation）分离信号。</li>
<li><strong>应用</strong>：5G 网络中使用较多，提升频谱效率。</li>
<li><strong>特点</strong>：频谱利用效率高，适合高用户密度场景，但对接收端的处理要求较高。</li>
</ul>
<h3 id="PDMA-模式分割多址"><a href="#PDMA-模式分割多址" class="headerlink" title="PDMA 模式分割多址"></a>PDMA 模式分割多址</h3><p>PDMA（Pattern Division Multiple Access）</p>
<ul>
<li><strong>原理</strong>：通过对信号的模式（如频域、时域、空域等）进行不同配置来分割用户信道。</li>
<li><strong>应用</strong>：5G NR（New Radio）新型多址接入技术之一。</li>
<li><strong>特点</strong>：结合空间、时间等多个维度的模式，进一步提高频谱效率。</li>
</ul>
<h3 id="MIMO"><a href="#MIMO" class="headerlink" title="MIMO"></a>MIMO</h3><p>MIMO（Multiple Input Multiple Output）多输入多输出</p>
<ul>
<li><strong>原理</strong>：通过多根天线发送和接收多个数据流，提高信道容量。</li>
<li><strong>应用</strong>：4G LTE、Wi-Fi 6、5G 等。</li>
<li><strong>特点</strong>：不属于严格的多址技术，但与 SDMA、OFDMA 等结合，能够显著提升数据传输速率和覆盖范围。</li>
</ul>
<h3 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h3><ul>
<li><strong>原理</strong>：用户在任意时间段发送数据包，碰撞后重新发送；时隙 ALOHA 则将时间分割成固定时隙，用户在时隙开始时发送数据，减少了冲突概率。</li>
<li><strong>应用</strong>：早期的卫星通信、无线传感器网络。</li>
<li><strong>特点</strong>：简单易实现，但冲突率高，频谱利用率较低，通常不用于高效的现代网络。</li>
</ul>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p><strong>IP地址：</strong>MAC地址属于物理地址，不够抽象，换了网卡还得重新建立联系。IP 地址是在计算机网络中用于标识设备的，然而它本身与具体的硬件设备无关<strong>是为了支持路由而设计的</strong>，使得数据能够在复杂的网络中找到目标设备，本质上是网络层的一种抽象，根据一定的规则和协议进行分配，帮助实现数据包在全球范围内的传输。</p>
<p><strong>ARP协议</strong>:实际通信还是要通过物理地址也就是mac的，机器1传给交换机目标IP地址，机器2收到ip广播，记录来源的mac地址，这样机器2就知道了机器1的mac，并将自己的mac返回给机器1（<strong>ARP</strong>协议,根据IP解析MAC）以后就能直接通信。缺点：MAC地址表溢出，全网泛洪，效率低下。（<u>网络层和数据链路层的边界</u>） </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921204958721.png" alt="image-20240921204958721"></p>
<p><strong>子网掩码：</strong> 上述交换机的缺点导致其只能连接少数设备，所以就应该把网络分成一个个子网，由交换机负责单个子网的通信，子网掩码就是告诉计算机 子网的ID是IP前几位，消息发给交换机，如果根据子网掩码，目的IP不是子网，就将信息传给路由器。<u>网络层</u> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921204925827.png" alt="image-20240921204925827"> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921205145960.png" alt="image-20240921205145960"></p>
<p><strong>路由器：</strong> 同一台路由器连接的计算机，他们的<strong>网关</strong>(子网的关口、出口)相同，都是路由器的IP地址。路由器上有一张路由表，可以配置目标网段和 next jump ，用来决定各网段消息下一步应该交给哪个路由器。OSPF自动学习自动管理路由表，BGP是为了应对庞大的网络，确定数据包的最佳路径。在<u>网络层</u></p>
<p><strong>路由器vs交换机</strong> </p>
<ol>
<li><strong>工作层次不同</strong>：</li>
</ol>
<ul>
<li><strong>路由器</strong>：工作在 <strong>网络层（OSI 模型的第 3 层）</strong>，基于 IP 地址来转发数据包。它可以在不同的网络之间进行数据转发，比如将本地局域网与互联网连接起来。路由器可以通过 IP 地址进行路由选择，确定数据包的最佳传输路径。</li>
<li><strong>交换机</strong>：工作在 <strong>数据链路层（OSI 模型的第 2 层）</strong>，基于 MAC 地址来转发数据帧。它用于在同一个局域网（LAN）内连接多个设备，并通过 MAC 地址表来进行帧的转发和处理。高端交换机（如三层交换机）也可以在网络层上进行工作，具备一定的路由功能。</li>
</ul>
<ol start="2">
<li><strong>主要用途</strong>：</li>
</ol>
<ul>
<li><strong>路由器</strong>：用于连接<strong>不同的网络</strong>，比如将你的家庭网络或局域网与互联网连接。它不仅能处理 LAN 内部的通信，还能通过 WAN 端口将内部网络连接到外部网络（如互联网）。路由器在网络之间转发数据，并为不同的网络分配和管理 IP 地址。</li>
<li><strong>交换机</strong>：用于<strong>同一网络</strong>中的设备互联，主要在局域网（LAN）内部使用。交换机可以通过多个端口连接多个设备（如电脑、服务器、打印机等），并基于 MAC 地址表快速高效地在这些设备之间转发数据。它不会管理或处理外部网络通信。</li>
</ul>
<ol start="3">
<li><strong>数据转发方式</strong>：</li>
</ol>
<ul>
<li><strong>路由器</strong>：根据<strong>IP 地址</strong>进行路由。它维护一个路由表，用来确定数据包的最佳路径，可能需要跨越多个网络。路由器使用不同的网络协议（如 OSPF、BGP）来管理和更新这些路由表。</li>
<li><strong>交换机</strong>：根据<strong>MAC 地址</strong>转发数据帧。它通过学习每个设备的 MAC 地址并将其存储在 MAC 地址表中，来确定应该将数据帧转发到哪个端口。交换机在一个局域网内部通过这种方式高效转发流量。</li>
</ul>
<ol start="4">
<li><strong>连接范围</strong>：</li>
</ol>
<ul>
<li><strong>路由器</strong>：通常连接<strong>不同的网络</strong>，比如家庭网络和互联网之间，或者连接多个子网。它的主要作用是通过不同的 IP 网段来连接和隔离不同的网络。</li>
<li><strong>交换机</strong>：主要连接<strong>同一个局域网中的设备</strong>，如多台计算机、打印机等，形成一个共享的局域网。</li>
</ul>
<ol start="5">
<li><strong>网络地址分配与管理</strong>：</li>
</ol>
<ul>
<li><strong>路由器</strong>：一般可以通过 <strong>DHCP（动态主机配置协议）</strong> 分配 IP 地址，管理局域网内设备的 IP 地址，并充当网络的网关，将局域网中的设备连接到外部网络。</li>
<li><strong>交换机</strong>：通常不具备 DHCP 等功能，它只是转发数据，不会负责分配 IP 地址。不过，高级管理型交换机可能具备一些网络管理功能。</li>
</ul>
<ol start="6">
<li><strong>NAT（网络地址转换）功能</strong>：</li>
</ol>
<ul>
<li><strong>路由器</strong>：大多数路由器提供 <strong>NAT 功能</strong>，这允许多个内网设备通过一个公共 IP 地址访问外部网络（如互联网）。NAT 会在网络地址翻译时修改 IP 数据包的源或目标 IP 地址。</li>
<li><strong>交换机</strong>：没有 NAT 功能。它仅在局域网内部转发数据帧，不处理 IP 层的转换。</li>
</ul>
<p>重点：ip首部格式 ip分片 ip选路 路由表 ICMP格式、分类(2+5)</p>
<h2 id="协议-2"><a href="#协议-2" class="headerlink" title="协议"></a>协议</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE">地址解析协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> ARP IPv4 IP地址到MAC地址 ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%82%BB%E5%B1%85%E5%8F%91%E7%8E%B0%E5%8D%8F%E8%AE%AE">邻居发现协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> NDP 基于IPv6</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE">网际协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> IP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%8E%A7%E5%88%B6%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE">互联网控制消息协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> ICMP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%BB%84%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE">互联网组管理协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> IGMP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BE%B9%E7%95%8C%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE">边界网关协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> BGP 基于 TCP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE">内部网关协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> IGP </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E5%BC%8F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%BC%98%E5%85%88">开放式最短路径优先 - 维基百科，自由的百科全书 (wikipedia.org)</a> OSPF 基于IP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E5%8D%8F%E8%AE%AE">路由信息协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> RIP 基于UDP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IPsec">IPsec - 维基百科，自由的百科全书 (wikipedia.org)</a> IPSec</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">网络地址转换 - 维基百科，自由的百科全书 (wikipedia.org)</a> NAT  ✅</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E7%B6%B2%E8%B7%AF%E6%8F%92%E5%BA%A7">网络套接字 - 维基百科，自由的百科全书 (wikipedia.org)</a> Socket  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%9C%8D%E5%8A%A1%E4%BE%9B%E5%BA%94%E5%95%86">互联网服务提供商 - 维基百科，自由的百科全书 (wikipedia.org)</a>ISP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%89%98%E7%AE%A1%E6%9C%8D%E5%8A%A1">互联网托管服务 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%89%E5%B0%8E%E7%BA%96%E7%B6%AD">光导纤维 - 维基百科，自由的百科全书 (wikipedia.org)</a> Fiber</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE">隧道协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> Tunnel  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E8%B7%AF%E7%94%B1%E5%B0%81%E8%A3%85">通用路由封装 - 维基百科，自由的百科全书 (wikipedia.org)</a> GRE</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E7%A7%81%E4%BA%BA%E7%B6%B2%E8%B7%AF">虚拟专用网 - 维基百科，自由的百科全书 (wikipedia.org)</a> VPN  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8">代理服务器 - 维基百科，自由的百科全书 (wikipedia.org)</a> Proxy  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SOCKS">SOCKS - 维基百科，自由的百科全书 (wikipedia.org)</a> SOCKS</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E5%A2%99">防火墙 - 维基百科，自由的百科全书 (wikipedia.org)</a> Firewall</p>
<h2 id="硬件-1"><a href="#硬件-1" class="headerlink" title="硬件"></a>硬件</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8">路由器 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BD%8F%E5%AE%85%E7%BD%91%E5%85%B3">住宅网关 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p>Network Address Transition</p>
<p><strong>NAT协议，公网IP</strong>：IPv4数目限制，子网共用一个IP，发送数据的时候传给路由器，路由器内部<strong>NAT</strong>映射表记录内网IP对应的内网端口以及随机分配的可用公网端口号，信息从路由器的端口里出去，之后报文里的IP和端口全部都是公网的（篡改）冒充子网计算机跟目的地通信。某个端口收到响应，路由器根据NAT表映射到内网的IP跟端口，然后把响应传给桌子往计算机</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921211102189.png" alt="image-20240921211102189"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921211225744.png" alt="image-20240921211225744"></p>
<p>目的地的路由器收到报文后，再次根据NAT映射表，将报文精准发送给对应IP的对应端口，但是此时的目的地并不知道来源的真实端口和IP。因此不能直接与其通信，两台处于不同子网的设备是不能相互找到和通信的，因此有了端口转发，VPN等方式通信</p>
<ol>
<li><strong>内部到外部的通信</strong></li>
</ol>
<ul>
<li>内网设备（使用私有 IP 地址）发起访问外部网络的请求时，NAT 会将内网设备的私有 IP 地址和端口号转换为路由器的公共 IP 地址和一个动态分配的外部端口。</li>
<li>这种方式允许内网设备共享一个公共 IP 地址，通过不同的外部端口来区分多个连接。</li>
</ul>
<ol start="2">
<li><strong>外部响应的处理</strong></li>
</ol>
<ul>
<li>当外部网络（例如互联网上的服务器）响应内网设备的请求时，NAT 路由器根据维护的 NAT 表将外部响应流量（发往公共 IP 地址和端口）转换回相应的内网设备的私有 IP 地址和端口。</li>
<li>这使得内网设备能够从外部网络获取响应数据。</li>
</ul>
<ol start="3">
<li><strong>默认不处理外部对内部的主动连接</strong></li>
</ol>
<ul>
<li>NAT 的设计初衷是为了<strong>保护内网</strong>，并允许内网设备访问外部网络。所以，外部设备<strong>无法直接发起请求</strong>到 NAT 后的内网设备，除非进行额外的配置（例如端口转发）。</li>
<li>当外部网络试图访问路由器的公共 IP 地址时，NAT 路由器会没有匹配的 NAT 规则来将外部请求路由到内网设备，因为没有预先建立的映射关系。</li>
</ul>
<p><strong>如何让外部访问内部设备</strong>？</p>
<p>虽然默认情况下 NAT 不允许外部设备主动访问内网设备，但通过一些配置，可以实现外部访问内部网络：</p>
<ol>
<li><strong>端口转发（Port Forwarding）</strong>：<ul>
<li>通过手动配置 NAT 路由器，你可以将外部的特定端口请求映射到内网设备的 IP 地址和端口。这样，当外部网络访问路由器的公共 IP 地址和该端口时，路由器会将流量转发给指定的内网设备。</li>
<li>例如，将外部的 <code>203.0.113.5:8080</code> 端口映射到内网设备 <code>192.168.1.10:80</code>，从而实现外部访问内网中的 Web 服务器。</li>
</ul>
</li>
<li><strong>DMZ（Demilitarized Zone，非军事区）</strong>：<ul>
<li>DMZ 功能允许你将内网中的某台设备完全暴露给外部网络。所有未指定端口的外部请求都将被路由到 DMZ 主机。</li>
<li>这使得外部设备能够访问该主机，但同时也减少了该设备的安全性。</li>
</ul>
</li>
<li><strong>VPN（虚拟专用网络）</strong>：<ul>
<li>通过在外部设备和内网之间建立 VPN 连接，外部设备可以成为虚拟子网中的一部分，获得与内网设备直接通信的能力。VPN 通常是一种更安全的访问内部设备的方式。</li>
</ul>
</li>
<li><strong>反向连接</strong>：<ul>
<li>内网设备可以主动与外部设备建立连接（如通过反向 SSH 隧道），让外部设备通过该连接间接访问内网中的设备。</li>
</ul>
</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921211251306.png" alt="image-20240921211251306"></p>
<h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p><strong>分配IP</strong>  <strong>内网-使用DHCP协议</strong>首次连接路由器，设备要广播DHCP Discover 请求，表示自己需要连接网络。路由器监听DHCP请求，能够<strong>动态</strong>管理自己的IP池，通过DHCP Offer给计算机分配IP地址和默认网关（用于访问外部地址）以及子网掩码和<strong>DNS</strong> 设备收到以后Request，路由器收到以后发送ACK，确认分配并连接成功。设备使用某个IP地址的时间有限，到时间如果设备不再续用，DHCP服务器会回收。某些设备可能需要为静态的IP，这个可以通过MAC绑定也可以手动配置。</p>
<p> <strong>公网</strong> <strong>静态：</strong>根据运营商提供的静态IP，子网掩码，网关，dns手动配置。<strong>动态DHCP</strong>。 <strong>拨号</strong> 家庭公网使用PPPoE协议向运营商动态租用（PPPoE提供了身份验证功能，也就是宽带账号)</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>IP和<strong>域名 Domain Name</strong> dns可以将域名解析为ip地址，提供了用户友好的方式来访问互联网资源 属于<u>应用层</u> </p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p><strong>端口</strong>：同一台设备中，不同应用程序有不同端口，发送地址时候要加上目标端口和目标IP (UDP给应用程序标注了身份)<u>传输层</u></p>
<p><strong>TCP</strong>: UDP没有确认机制，可靠性差于是有了TCP，在不可靠信道上建立可靠连接,但是速度慢，网络游戏和视频流仍然使用UDP</p>
<p><strong>重试机制</strong>(接收方确认) <u>传输层</u></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921210407572.png" alt="image-20240921210407572"></p>
<p><strong>数据分包整理机制</strong>（分包，标注序号，大段数据的小段错误不用全部重新发送，接收方回复确认要针对序号进行回复）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921210327520.png" alt="image-20240921210327520"></p>
<p><strong>连接的建立</strong>（三次握手）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921210305337.png" alt="image-20240921210305337"></p>
<p><strong>流量控制机制，动态调整一次发送分包个数</strong>（滑动窗口、拥塞控制，慢启动，快速重传，快速恢复）</p>
<p>接收方一次可能接不住全部包</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921210631037.png" alt="image-20240921210631037"></p>
<p> <strong>连接的断开</strong>（四次挥手）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921210704880.png" alt="image-20240921210704880"></p>
<p><strong>应用层传输协议</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921210737934.png" alt="image-20240921210737934"></p>
<h2 id="协议-3"><a href="#协议-3" class="headerlink" title="协议"></a>协议</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BC%8F">网络控制程序 - 维基百科，自由的百科全书 (wikipedia.org)</a> NCP</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">传输控制协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> TCP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5">用户数据报协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> UDP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TCP/UDP%E7%AB%AF%E5%8F%A3%E5%88%97%E8%A1%A8">TCP/UDP端口列表 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<p>重点：udp tcp(特点，首部，校验和，连接控制三握四挥 同关 同开 半关，流量控制记住，超时重传)</p>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>理论上讲，有了以上三层协议的支持，数据已经可以从一个主机上的应用程序传输到另一台主机的应用程序了，但此时传过来的数据是字节流，不能很好的被程序识别，操作性差，因此，应用层定义了各种各样的协议来规范数据格式，常见的有<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/http/243074?fromModule=lemma_inlink">http</a>,ftp,<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/smtp/175887?fromModule=lemma_inlink">smtp</a>等，在请求<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Header/688992?fromModule=lemma_inlink">Header</a>中，分别定义了请求数据格式Accept和响应数据格式Content-Type，有了这个规范以后，当对方接收到请求以后就知道该用什么格式来解析，然后对请求进行处理，最后按照请求方要求的格式将数据返回，请求端接收到响应后，就按照规定的格式进行解读。</p>
<p>除了HTTP和HTTPS之外，还有很多其他的网络协议，用于不同的应用和目的。以下是一些常见的协议：</p>
<ol>
<li>**FTP (File Transfer Protocol)**：用于在计算机之间传输文件。前缀为 <code>ftp://</code>。</li>
<li>**SFTP (Secure File Transfer Protocol)**：在FTP的基础上增加了加密层，确保文件传输的安全性。前缀通常为 <code>sftp://</code>。</li>
<li>**FTPS (FTP Secure)**：FTP的安全版本，通过TLS/SSL加密传输。前缀为 <code>ftps://</code>。</li>
<li>**SMTP (Simple Mail Transfer Protocol)**：用于发送电子邮件。虽然它通常不在URL中直接使用，但它是邮件服务器之间传输邮件的主要协议。</li>
<li>**IMAP (Internet Message Access Protocol)**：用于从邮件服务器检索电子邮件。常见的前缀是 <code>imap://</code>。</li>
<li>**POP3 (Post Office Protocol version 3)**：也是用于从邮件服务器检索电子邮件的协议，前缀为 <code>pop3://</code>。</li>
<li><strong>Telnet</strong>：一种远程终端协议，用于通过网络连接到远程计算机。前缀为 <code>telnet://</code>。</li>
<li>**SSH (Secure Shell)**：用于安全地远程登录到计算机系统。前缀为 <code>ssh://</code>。</li>
<li><strong>HTTP（Hypertext Transfer Protocol）</strong>：超文本传输协议，是一种用于从web服务器传输网页的协议。<ol>
<li><code>http://</code> 表示该网页使用的是HTTP协议。HTTP是一个无状态的协议，意味着每次请求都是独立的，不会记录之前的交互状态。</li>
<li><code>https://</code>：在HTTP的基础上，HTTPS（HTTP Secure）增加了加密层（使用TLS/SSL协议），用于确保数据在传输过程中是安全的。<code>https://</code> 用于需要保护数据隐私和完整性的网页，如在线银行和购物网站。</li>
</ol>
</li>
</ol>
<h2 id="应用间通信架构"><a href="#应用间通信架构" class="headerlink" title="应用间通信架构"></a>应用间通信架构</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BB%88%E7%AB%AF/15634871">终端（通信技术术语）_百度百科 (baidu.com)</a> Terminal终端</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA">网络主机 - 维基百科，自由的百科全书 (wikipedia.org)</a> Host主机</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Host_(network)">Host (network) - Wikipedia</a> Host</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%AE%A2%E6%88%B7%E6%9C%BA/5937024">主从式架构 - 服务器-客户机(C/S)_百度百科 (baidu.com)</a> Client/Server  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器 - 维基百科，自由的百科全书 (wikipedia.org)</a> server  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model">Client–server model - Wikipedia</a>C/S  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/B%2FS%E7%BB%93%E6%9E%84/4868588">B/S结构_百度百科 (baidu.com)</a> Browser/Server  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Distributed_computing#Examples">Distributed computing - Wikipedia</a> 分布式计算 </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A">进程间通信 - 维基百科，自由的百科全书 (wikipedia.org)</a> IPC</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Inter-process_communication">Inter-process communication - Wikipedia</a> IPC</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8">远程过程调用(Remote Procedure Call) - 维基百科，自由的百科全书 (wikipedia.org)</a> RPC  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Remote_procedure_call">Remote procedure call - Wikipedia</a> RPC</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Java_remote_method_invocation">Java remote method invocation - Wikipedia</a> Java RMI </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Java%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8">Java远程方法调用 - 维基百科，自由的百科全书 (wikipedia.org)</a> Java RMI</p>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multitier_architecture">Multitier architecture - Wikipedia</a> 多层架构</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%AD%89%E7%B6%B2%E8%B7%AF">点对点网络 - 维基百科，自由的百科全书 (wikipedia.org)</a> P2P</p>
</li>
</ul>
<h2 id="软件设计模式"><a href="#软件设计模式" class="headerlink" title="软件设计模式"></a>软件设计模式</h2><table>
<thead>
<tr>
<th align="center">Designing Pattern</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80">设计模式</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%89%B5%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">创建型</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82">抽象工厂</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F">生成器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95">工厂方法</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E6%A8%A1%E5%BC%8F">惰性初始</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">原型</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B5%90%E6%A7%8B%E5%9E%8B%E6%A8%A1%E5%BC%8F">结构型</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">适配器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A9%8B%E6%8E%A5%E6%A8%A1%E5%BC%8F">桥接</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Composite_pattern&action=edit&redlink=1">Composite</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%AE%E9%A5%B0%E6%A8%A1%E5%BC%8F">修饰</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%96%E8%A7%80%E6%A8%A1%E5%BC%8F">外观</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F">享元</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">代理</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%82%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">行为型</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F">责任链</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F">命令</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Interpreter_pattern&action=edit&redlink=1">Interpreter</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F">迭代器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F">中介者</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Memento_pattern&action=edit&redlink=1">Memento</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">观察者</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Specification_pattern&action=edit&redlink=1">Specification</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=State_pattern&action=edit&redlink=1">State</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F">策略</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95">模板方法</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F">访问者</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BD%B5%E7%99%BC%E5%9E%8B%E6%A8%A1%E5%BC%8F">并行模式</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E4%B8%BB%E5%8A%A8%E5%AF%B9%E8%B1%A1&action=edit&redlink=1">主动对象</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E9%98%BB%E6%AD%A2%E6%A8%A1%E5%BC%8F&action=edit&redlink=1">阻止</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Binding_properties&action=edit&redlink=1">Binding properties</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E6%A8%A1%E5%BC%8F">双重检查锁定模式</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8">异步方法调用</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Guarded_suspension&action=edit&redlink=1">Guarded suspension</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Join%E6%A8%A1%E5%BC%8F&action=edit&redlink=1">Join</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%94%81_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">锁</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Messaging&action=edit&redlink=1">Messaging</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%A3%E8%A6%96%E5%99%A8_(%E7%A8%8B%E5%BA%8F%E5%90%8C%E6%AD%A5%E5%8C%96)">监视器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Proactor_pattern&action=edit&redlink=1">Proactor</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%BA%94%E5%99%A8%E6%A8%A1%E5%BC%8F">反应器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AF%BB%E5%86%99%E9%94%81">读写锁</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">调度</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%B1%A0">线程池</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8">线程局部存储</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F">架构模式</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Action%E2%80%93Domain%E2%80%93Responder&action=edit&redlink=1">ADR</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Broker_pattern&action=edit&redlink=1">Broker</a>主从式架构<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E7%BB%84%E4%BB%B6%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B">CBD</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1">DAO</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">主动记录</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E6%98%A0%E5%B0%84%E5%99%A8%E6%A8%A1%E5%BC%8F">数据映射器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88">DDD</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Data_transfer_object&action=edit&redlink=1">Data transfer object</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Front_controller&action=edit&redlink=1">Front controller</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Identity_map_pattern&action=edit&redlink=1">Identity map</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Interceptor_pattern&action=edit&redlink=1">Interceptor</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC">控制反转</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MVC">MVC</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9C%8D%E5%8B%99">微服务</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Model-view-presenter">MVP</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%96%AE%E9%AB%94%E5%BC%8F%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F">单体式应用程序</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%B1%82%E6%9E%B6%E6%9E%84">多层架构</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Naked_objects&action=edit&redlink=1">Naked objects</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%AD%89%E7%B6%B2%E8%B7%AF">P2P</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85">发布/订阅</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2">REST</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">SOA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Specification_pattern&action=edit&redlink=1">Specification</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%91%E8%AE%A1%E7%AE%97">云</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97">分布式</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%96%B7%E8%B7%AF%E5%99%A8%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F">断路器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%91%BD%E4%BB%A4%E9%98%9F%E5%88%97%E5%88%86%E7%A6%BB&action=edit&redlink=1">CQRS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%A1%A5%E5%81%BF%E4%BA%A4%E6%98%93&action=edit&redlink=1">补偿交易</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95">索引表</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E9%A2%86%E5%AF%BC%E8%80%85%E9%80%89%E4%B8%BE&action=edit&redlink=1">领导者选举</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MapReduce">MapReduce</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE&action=edit&redlink=1">物化视图</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(%E8%BD%AF%E4%BB%B6)">管道</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%BF%87%E6%BB%A4%E5%99%A8_(%E8%BD%AF%E4%BB%B6)&action=edit&redlink=1">过滤器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85">发布/订阅</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%88%86%E7%89%87_(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84)&action=edit&redlink=1">分片</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%8A%82%E6%B5%81%E8%BF%87%E7%A8%8B_(%E8%AE%A1%E7%AE%97)&action=edit&redlink=1">节流</a></td>
</tr>
<tr>
<td align="center">其他模式</td>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Blackboard_design_pattern&action=edit&redlink=1">Blackboard</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Business_delegate_pattern&action=edit&redlink=1">Business delegate</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Composite_entity_pattern&action=edit&redlink=1">Composite entity</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F">委托</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">依赖注入</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Intercepting_filter_pattern&action=edit&redlink=1">Intercepting filter</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%83%B0%E6%80%A7%E8%BC%89%E5%85%A5">惰性加载</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Method_chaining&action=edit&redlink=1">Method chaining</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%8B%9F%E5%AF%B9%E8%B1%A1">模拟对象</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F">空对象</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F">对象池</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Servant_(design_pattern)&action=edit&redlink=1">Servant</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Twin_pattern&action=edit&redlink=1">Twin</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Type_Tunnel_pattern&action=edit&redlink=1">Type tunnel</a></td>
</tr>
<tr>
<td align="center">书籍</td>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80">设计模式：可复用面向对象软件的基础</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A2%BC%E5%A4%A7%E5%85%A8">代码大全</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E4%BC%81%E4%B8%9A%E9%9B%86%E6%88%90%E6%A8%A1%E5%BC%8F&action=edit&redlink=1">企业集成模式</a></td>
</tr>
<tr>
<td align="center">人物</td>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%8B%E9%87%8C%E6%96%AF%E6%89%98%E4%BD%9B%C2%B7%E4%BA%9A%E5%8E%86%E5%B1%B1%E5%A4%A7">克里斯托佛·亚历山大</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9F%83%E9%87%8C%E5%B8%8C%C2%B7%E4%BC%BD%E7%91%AA">埃里希·伽玛</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Ralph_Johnson&action=edit&redlink=1">Ralph Johnson</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=John_Vlissides&action=edit&redlink=1">John Vlissides</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%91%9B%E4%BE%86%E8%BF%AA%C2%B7%E5%B8%83%E5%8D%80">葛来迪·布区</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%82%AF%E7%89%B9%C2%B7%E8%B2%9D%E5%85%8B">肯特·贝克</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B2%83%E5%BE%B7%C2%B7%E5%9D%8E%E5%AE%81%E5%AE%89">沃德·坎宁安</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A9%AC%E4%B8%81%C2%B7%E7%A6%8F%E5%8B%92">马丁·福勒</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Robert_Martin&action=edit&redlink=1">Robert Martin</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Jim_Coplien&action=edit&redlink=1">Jim Coplien</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Douglas_Schmidt&action=edit&redlink=1">Douglas Schmidt</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Linda_Rising">Linda Rising</a></td>
</tr>
</tbody></table>
<h2 id="协议-4"><a href="#协议-4" class="headerlink" title="协议"></a>协议</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">域名系统 - 维基百科，自由的百科全书 (wikipedia.org)</a> DNS 基于 TCP UDP  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E8%AE%BE%E7%BD%AE%E5%8D%8F%E8%AE%AE">动态主机设置协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> DHCP 基于UDP  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">超文本传输协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> HTTP  ✅</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE">超文本传输安全协议 - 维基百科，自由的百科全书 (wikipedia.org)</a>HTTPS  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WebDAV">WebDAV - 维基百科，自由的百科全书 (wikipedia.org)</a> WebDav</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WebSocket">WebSocket - 维基百科，自由的百科全书 (wikipedia.org)</a> WebSocket  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/BitTorrent_(%E5%8D%8F%E8%AE%AE)">BitTorrent (协议) - 维基百科，自由的百科全书 (wikipedia.org)</a> BitTorrent</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%95%A3%E5%BC%8F%E9%9B%9C%E6%B9%8A%E8%A1%A8">分布式散列表 - 维基百科，自由的百科全书 (wikipedia.org)</a> DHT</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EDonkey%E7%BD%91%E7%BB%9C">eDonkey网络 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91">万维网 - 维基百科，自由的百科全书 (wikipedia.org)</a> WWW  ✅</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8">网页浏览器 - 维基百科，自由的百科全书 (wikipedia.org)</a> WWW Browser  ✅</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WebRTC">WebRTC - 维基百科，自由的百科全书 (wikipedia.org)</a> WebRTC</p>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">文件传输协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> FTP  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E4%BF%A1%E6%81%AF%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE">因特网信息访问协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> IMAP ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">简单邮件传输协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> SMTP  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%83%B5%E5%B1%80%E5%8D%94%E5%AE%9A">邮局协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> POP  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MQTT">消息队列遥测传输- 维基百科，自由的百科全书 (wikipedia.org)</a> MQTT</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E6%99%82%E9%96%93%E5%8D%94%E5%AE%9A">网络时间协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> NTP</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AE%9E%E6%97%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">实时传输协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> RTP    </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/VoIP">VoIP - 维基百科，自由的百科全书 (wikipedia.org)</a> VoIP</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%A4%BA%E5%B1%82">表示层 - 维基百科，自由的百科全书 (wikipedia.org)</a> Presentation Layser</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Telnet">Telnet - 维基百科，自由的百科全书 (wikipedia.org)</a> Telnet  ✅</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Secure_Shell">Secure Shell - 维基百科，自由的百科全书 (wikipedia.org)</a> SSH  ✅</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D%E5%B1%82">会话层 - 维基百科，自由的百科全书 (wikipedia.org)</a> Session Layer </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A">传输层安全性协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> SSL/TLS  ✅</li>
</ul>
</li>
</ul>
<p>重点：</p>
<p>dns 指针查询 反向查找 逆向解析 dns 缓存 名字空间</p>
<p>ftp 控制流 数据流 工作模式pasv+port 指令+响应码 断点续传</p>
<p>http 报文格式（请求头字段和响应头字段）状态码</p>
<p>https 详细握手 摘要算法 数字签名 数字证书 </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/12/26/netty-best-practice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/26/netty-best-practice/" class="post-title-link" itemprop="url">Netty 最佳实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-26 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-26T00:00:00+08:00">2024-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 15:17:07" itemprop="dateModified" datetime="2025-04-27T15:17:07+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/netty/" itemprop="url" rel="index"><span itemprop="name">netty</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/12/26/netty-best-practice/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/11/30/408-OS-Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/30/408-OS-Linux/" class="post-title-link" itemprop="url">Linux 基本命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-30 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-30T00:00:00+08:00">2024-11-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:37:38" itemprop="dateModified" datetime="2025-05-05T11:37:38+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Linux-概述"><a href="#Linux-概述" class="headerlink" title="Linux 概述"></a>Linux 概述</h1><h2 id="Unix家族"><a href="#Unix家族" class="headerlink" title="Unix家族"></a>Unix家族</h2><p>在unix编写过程中发明出了新的编程语言: C</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007165031608.png" alt="image-20241007165031608"></p>
<h2 id="GNU-自由软件运动"><a href="#GNU-自由软件运动" class="headerlink" title="GNU: 自由软件运动"></a>GNU: 自由软件运动</h2><p>FreeBSD: 允许闭源</p>
<p>GPL: GNU General Public License 不允许闭源</p>
<p>MIT: 声明MIT即可</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007170423889.png" alt="image-20241007170423889"></p>
<h2 id="Linux-发行版"><a href="#Linux-发行版" class="headerlink" title="Linux 发行版"></a>Linux 发行版</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007171216031.png" alt="image-20241007171216031"></p>
<h2 id="Linux-vs-Windows"><a href="#Linux-vs-Windows" class="headerlink" title="Linux vs. Windows"></a>Linux vs. Windows</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007171911495.png" alt="image-20241007171911495"></p>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>Linux用正斜杠表示路径，一切皆文件</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007174437116.png" alt="image-20241007174437116"></p>
<p>虚拟目录，只是逻辑上的关系，分区和挂载点才会决定物理存放位置的关系</p>
<ul>
<li><strong>/bin /sbin</strong> 存放二进制命令的目录，这里是一个快捷方式，实际上是/usr/bin</li>
<li>/lib /lib64 存放动态链接库，这里是一个快捷方式，实际上是/usr/lib</li>
<li>/media /mnt 外部设备挂载目录</li>
<li>/home /root用户文件夹</li>
<li>/boot 启动相关</li>
<li>/dev 设备相关 </li>
<li>/run /proc 进程</li>
<li>/srv 服务</li>
<li>/sys 系统硬件</li>
<li><strong>/var</strong> 可变目录 log 日志文件</li>
<li>/opt </li>
<li>/tmp 临时文件</li>
<li><strong>/etc</strong> 配置文件</li>
</ul>
<h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><p>vi-&gt;vim </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007182423055.png" alt="image-20241007182423055"></p>
<h2 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h2><p><strong>光标操作</strong>：</p>
<ul>
<li>e 移动到当前词尾</li>
<li>b 上一个词的词头  shift+方向左</li>
<li>w 下一个词的词头 shift+方向右</li>
<li>gg 当前文档的开头 shift+h </li>
<li>3 gg 跳转到第3行</li>
<li>shift+g 跳转到最后一行</li>
<li>$ 定位到行尾</li>
<li>^ 定位到行开头</li>
</ul>
<p><strong>复制粘贴整行</strong>：</p>
<ul>
<li>[3] yy 复制从光标开始的3行内容</li>
<li>[3] p 粘贴剪贴板的内容3次</li>
<li>y + w  复制当前单词</li>
<li>y + $ 复制从光标到行尾($可以定位到行尾)</li>
<li>y + ^ 复制从行开头到光标（^可以定位到行尾） 记忆：正则表达式^ $</li>
</ul>
<p><strong>删除行</strong>：</p>
<ul>
<li>[3] dd 删除光标开始的3行</li>
<li>d + w 删除单词，（要把光标移到单词开头）</li>
<li>d + $ 删除从光标到行尾</li>
<li>d + ^ 删除从行开头到光标</li>
</ul>
<p><strong>撤销操作</strong>：u</p>
<p><strong>剪切字符</strong>：</p>
<ul>
<li>x 剪切 光标所指字符</li>
<li>shift + x  剪切光标之前的字符，类似退格</li>
</ul>
<p><strong>替换</strong>：</p>
<ul>
<li>r 替换 光标所指字符 </li>
<li>shift + r 进入替换模式 类似insert模式 输入的字符将直接覆盖光标处的内容</li>
</ul>
<p><strong>显示行号</strong>：</p>
<ul>
<li><code>:set nu</code></li>
</ul>
<h2 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h2><p><code>i </code>光标在当前字符上 （在当前字符前面插入内容）shift+i 当前行头</p>
<p><code>a </code>光标在下一个字符上（在当前字符后面插入内容）shift+a 当前行尾</p>
<p><code>o </code>光标移动到新建的下一行 shift+o 移动到新建的上一行</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p><strong>:w 保存 :q退出 :q! 强制退出</strong></p>
<p><strong>:wq保存退出</strong> </p>
<p>:wq!强制保存退出（只读文件）</p>
<p>:set nonu 取消行号</p>
<p><strong>/boot</strong> 查找boot并高亮 n下一个 shift+n上一个</p>
<p>:s/old/new(/g) 把当前行的第一个old替换为new（加上/g为当前行所有）</p>
<p><strong>:%s/old/new(/g)</strong> 每一行的第一个old换成new（加上/g为所有行）</p>
<h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><p>ifconfig linux中的ipconfig</p>
<p>ping</p>
<p><strong>traceroute</strong>：追踪网络路径</p>
<h2 id="网络连接模式"><a href="#网络连接模式" class="headerlink" title="网络连接模式"></a>网络连接模式</h2><h3 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007200741497.png" alt="image-20241007200741497"></p>
<p>路由器到PC，PC这边搭一个虚拟网桥到虚拟交换机，交换机连接虚拟机网络，好处：虚拟机跟PC地位相同，坏处：隐私安全无法保证，VM占用路由器的子网地址</p>
<p>VM和PC的子网掩码相同</p>
<h3 id="NAT（虚拟地址转换）"><a href="#NAT（虚拟地址转换）" class="headerlink" title="NAT（虚拟地址转换）"></a>NAT（虚拟地址转换）</h3><p>VMware建立虚拟路由，构建了一个VM专用的子网。</p>
<p>虚拟路由（虚拟NAT服务器和DHCP服务器）分配子网IP，子网设备（虚拟机）只有通过这个虚拟路由才能连到外网。VM和PC不在一个子网中。VM要请求外网，虚拟路由会根据端口号和子网IP分配端口并更新到映射表中，把信息传到PC网卡，重复上述步骤，实现VM对外网的请求。</p>
<p>虚拟路由通过PC网卡跟外界通信，PC网卡此时只是一个中介，PC本身不算在内网中，不能跟VM通信，虚拟路由不能从外部向内部发送请求，因为NAT只能将子网IP转成外部IP，这里VMware的解决方案是虚拟出一个网络适配器（VMnet8），将PC本身也接入VM子网中。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007215205758.png" alt="image-20241007215205758"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007220244669.png" alt="image-20241007220244669"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007220336304.png" alt="image-20241007220336304"></p>
<p>如图网关/路由器是168.111.2，VMnet8（给PC虚拟出的网卡）是168.111.1</p>
<h3 id="仅主机"><a href="#仅主机" class="headerlink" title="仅主机"></a>仅主机</h3><p>NAT把路由器换成交换机，主机和VM都连到这个交换机上，组成一个局域网，VM只能与主机通信。虚拟出一张主机的网卡，连到交换机上</p>
<h3 id="路由器vs交换机"><a href="#路由器vs交换机" class="headerlink" title="路由器vs交换机"></a>路由器vs交换机</h3><table>
<thead>
<tr>
<th></th>
<th>路由器</th>
<th>交换机</th>
</tr>
</thead>
<tbody><tr>
<td>动态分配IP和端口</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>NAT</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>转发数据</td>
<td>基于IP地址</td>
<td>基于MAC地址</td>
</tr>
<tr>
<td>适用场景</td>
<td>WAN、LAN</td>
<td>LAN（只能用于内部通信）</td>
</tr>
</tbody></table>
<p>systemd    守护进程</p>
<h1 id="系统服务控制"><a href="#系统服务控制" class="headerlink" title="系统服务控制"></a>系统服务控制</h1><h2 id="System-V"><a href="#System-V" class="headerlink" title="System V"></a>System V</h2><p>守护进程 init 第一个进程 调用init.d的脚本根据运行级别启动服务</p>
<p>开机 bios /boot init进程 运行级别 运行级别对应的服务</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008174512092.png" alt="image-20241008174512092"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008174709567.png" alt="image-20241008174709567"></p>
<p>target运行服务的集合</p>
<p>systemd: 很多守护进程 相比于init效率更高</p>
<h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><p>控制systemd</p>
<p><code>status</code> 服务状态</p>
<p><code>restart start stop</code> 开启停止重启</p>
<p><code>enable/disable</code> 自启动</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007004917995-1728748475007-17.png" alt="image-20241007004917995"></p>
<p><strong>systemctl</strong>是<strong>systemd</strong>的主命令，用于管理系统。除此之外，还有<strong>hostnamectl</strong>(查看当前主机信息)、<strong>timedatectl</strong>(查看当前时区设置)、<strong>loginctl</strong>(查看当前登录的用户)等命令。</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>Bash Bourne Again Shell 解释器</p>
<p>Debian dash</p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p><code>stat filename</code>: 查看inode信息</p>
<p><strong>存储文件元信息的区域就叫 inode</strong>，译为索引节点：<strong>i（index）+node</strong>。 <strong>每个文件都有一个唯一的 inode，存储文件的元信息。</strong> 同一块不能存两个文件</p>
<p><code>ln -s file.txt file_link</code> 创建软链接</p>
<p>硬链接：inode相同 软连接：inode不同，跨文件系统，只是路径相同</p>
<p><code>touch a.txt</code> 更新文件的访问修改时间戳，<strong>如果没有则创建</strong> 所以就是创建文件</p>
<h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><p>wc wordcount</p>
<p>Print newline, word, and byte counts for each FILE,</p>
<h4 id="cat-concat-concatenate"><a href="#cat-concat-concatenate" class="headerlink" title="cat (concat)(concatenate)"></a><strong>cat</strong> (concat)(concatenate)</h4><ul>
<li><strong>功能</strong>：用于连接和显示文件的内容。</li>
<li><strong>用法</strong>：可以一次性显示整个文件内容，也可以将多个文件合并。</li>
<li><strong>示例</strong>：<code>cat filename.txt</code></li>
<li><strong>特点</strong>：直接将文件内容输出到终端，不支持分页或滚动。</li>
</ul>
<h4 id="more"><a href="#more" class="headerlink" title="more"></a><strong>more</strong></h4><ul>
<li><strong>功能</strong>：用于分页显示文件内容。</li>
<li><strong>用法</strong>：按空格键查看下一页，按回车键查看下一行，按 <code>q</code> 退出。</li>
<li><strong>示例</strong>：<code>more filename.txt</code></li>
<li><strong>特点</strong>：只能向前翻页，不能向后翻。</li>
</ul>
<h4 id="less-分页查看"><a href="#less-分页查看" class="headerlink" title="less 分页查看"></a><strong>less</strong> 分页查看</h4><ul>
<li><strong>功能</strong>：也是用于分页显示文件内容，功能比 <code>more</code> 强大。</li>
<li><strong>用法</strong>：支持向前和向后翻页，使用方向键、空格键、回车键等进行导航，按 <code>q</code> 退出。</li>
<li><strong>示例</strong>：<code>less filename.txt</code></li>
<li><strong>特点</strong>：可以在文件中快速查找，支持多种命令（例如 <code>/</code> 用于搜索）。</li>
</ul>
<h4 id="tail-实时输出"><a href="#tail-实时输出" class="headerlink" title="tail 实时输出"></a><strong>tail</strong> 实时输出</h4><ul>
<li><strong>功能</strong>：用于查看文件的最后几行内容。</li>
<li><strong>用法</strong>：默认显示最后 10 行，可以使用 <code>-n</code> 选项指定行数，也可以使用 <code>-f</code> 选项实时跟踪文件变化（如日志文件）。</li>
<li><strong>示例</strong>：<code>tail filename.txt</code> 或 <code>tail -f filename.txt</code></li>
<li><strong>特点</strong>：常用于监控日志文件的实时输出。</li>
</ul>
<h4 id="grep-过滤"><a href="#grep-过滤" class="headerlink" title="grep 过滤"></a><strong>grep</strong> 过滤</h4><p>g/re/p（globally search a regular expression and print，以正则表达式进行全局查找以及打印</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -i apple fruitlist.txt</span><br><span class="line"><span class="comment"># 在fruitlist.txt中寻找apple字符串 忽略大小写 返回出现该字符串的行内容</span></span><br></pre></td></tr></table></figure>

<p>Windows平台下，<code>findstr</code>代替了<code>grep</code></p>
<h3 id="修改文件内容"><a href="#修改文件内容" class="headerlink" title="修改文件内容"></a>修改文件内容</h3><p><code>vim / nano</code>编辑器编辑</p>
<p><code>awk / sed</code> 批量处理（流）</p>
<p><code>echo / cat</code> 快速修改</p>
<ul>
<li><code>echo &quot;New content&quot; &gt; filename</code> 覆盖内容</li>
<li><code>echo &quot;New content&quot; &gt;&gt; filename</code> 追加内容</li>
<li><code>cat &gt; filename</code> 自行输入内容，输完ctrl+D </li>
</ul>
<h3 id="解压缩文件（tar）"><a href="#解压缩文件（tar）" class="headerlink" title="解压缩文件（tar）"></a>解压缩文件（tar）</h3><p>解压：tar -xvf</p>
<p>压缩：tar -zcvf</p>
<p>比如：假如 test 目录下有三个文件分别是：<code>aaa.txt</code>、 <code>bbb.txt</code>、<code>ccc.txt</code>，如果我们要打包 <code>test</code> 目录并指定压缩后的压缩包名称为 <code>test.tar.gz</code> 可以使用命令：<code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code> 或 <code>tar -zcvf test.tar.gz /test/</code></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><strong>cd</strong>: change directory</p>
<p><strong>mkdir</strong>/<strong>rmdir</strong>: make/remove directory(not null)</p>
<p><strong>ls</strong>: list</p>
<ul>
<li>-a: 显示.开头的隐藏文件 </li>
<li>-l: 显示长文件信息 </li>
<li>-F: 显示可执行信息</li>
</ul>
<p><strong>pwd</strong>: print work directory</p>
<p><strong>cp</strong>: copy</p>
<p><strong>rm</strong>: remove </p>
<p><strong>mv</strong>: move 可以用来改变文件名</p>
<p>find<code>/home</code>目录下查找以 <code>.txt</code> 结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code> ,忽略大小写: `find /home -i name “*.txt” </p>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>change owner /change mode</p>
<p><code>_rwxrw_r_</code>  普通文件</p>
<p>**所有者(u)**：一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用 <code>ls ‐ahl</code> 命令可以看到文件的所有者 也可以使用 <code>chown 用户名</code> 文件名来修改文件的所有者 。</p>
<p>**文件所在组(g)**：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组用 <code>ls ‐ahl</code>命令可以看到文件的所有组也可以使用 chgrp 组名 文件名来修改文件所在的组。</p>
<p>**其它组(o)**：除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</p>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>前提：你是文件所有者   **超级用户可以无视普通用户的权限 ** 普通用户可以用 <code>sudo chmod</code></p>
<p>文件： <code>r</code>可用cat读  <code>w</code>修改 <code>x</code>可执行</p>
<p>目录：<code>r</code> 可用ls命令 <code>w</code> 可新建，删除目录下文件 <code>x</code> 可以用cd访问</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul>
<li><p><strong>添加权限</strong></p>
<ul>
<li><code>chmod +x filename</code>：给文件添加执行权限。</li>
<li><code>chmod +r filename</code>：给文件添加读取权限。</li>
<li><code>chmod +w filename</code>：给文件添加写入权限。</li>
</ul>
</li>
<li><p><strong>删除权限</strong></p>
<ul>
<li><code>chmod -x filename</code>：去掉文件的执行权限。</li>
<li><code>chmod -r filename</code>：去掉文件的读取权限。</li>
<li><code>chmod -w filename</code>：去掉文件的写入权限。</li>
</ul>
</li>
</ul>
<h4 id="设置特定用户的权限"><a href="#设置特定用户的权限" class="headerlink" title="设置特定用户的权限"></a>设置特定用户的权限</h4><ul>
<li><strong>针对特定用户</strong><ul>
<li><code>chmod u+x filename</code>：给文件的所有者（user）添加执行权限。</li>
<li><code>chmod g+w filename</code>：给文件的所属组（group）添加写入权限。</li>
<li><code>chmod o-r filename</code>：去掉其他用户（others）的读取权限。</li>
</ul>
</li>
</ul>
<h4 id="使用八进制数设置权限"><a href="#使用八进制数设置权限" class="headerlink" title="使用八进制数设置权限"></a>使用八进制数设置权限</h4><p>权限可以用数字表示，常见的数字对应如下：</p>
<ul>
<li><code>4</code>：读取权限（r）</li>
<li><code>2</code>：写入权限（w）</li>
<li><code>1</code>：执行权限（x）</li>
</ul>
<p>通过加和可以设置权限：</p>
<ul>
<li><code>chmod 7filename</code>：所有者有读、写、执行权限，组用户和其他用户有读、执行权限。</li>
<li><code>chmod 6filename</code>：所有者有读、写权限，组用户和其他用户有读取权限。</li>
</ul>
<h4 id="递归修改权限"><a href="#递归修改权限" class="headerlink" title="递归修改权限"></a>递归修改权限</h4><ul>
<li><strong>递归应用权限</strong>：<ul>
<li><code>chmod -R 7directory</code>：递归地给目录及其所有子文件和子目录设置权限。</li>
</ul>
</li>
</ul>
<h4 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h4><ul>
<li><strong>查看当前权限</strong>：<ul>
<li>使用 <code>ls -l filename</code> 命令可以查看文件的当前权限。</li>
</ul>
</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>假设你有一个脚本文件 <code>script.sh</code>，你希望让所有用户都能执行它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a+x script.sh</span><br></pre></td></tr></table></figure>

<p>如果你想让所有者有读、写、执行权限，而其他用户只有读权限，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 7script.sh</span><br></pre></td></tr></table></figure>

<p>这些是 <code>chmod</code> 命令的一些常用选项和用法，希望对你有帮助！如果你有具体的权限需求，也可以告诉我，我可以提供更详细的命令。</p>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p><code>useradd/del/mod</code> <code>groupadd/del/mod</code> <code>passwd</code> 认证相关 </p>
<p><code>su username</code> 切换用户 Switch user</p>
<h2 id="查看系统状态"><a href="#查看系统状态" class="headerlink" title="查看系统状态"></a>查看系统状态</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ps : process status</span></span><br><span class="line">ps -ef </span><br><span class="line">ps -aux <span class="comment">#都是查看所有进程的运行情况</span></span><br><span class="line"></span><br><span class="line">ps aux | grep redis </span><br><span class="line">pgrep redis -a <span class="comment">#都是查看包含redis的进程运行情况</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> 5894 <span class="comment"># 杀死pid5394</span></span><br><span class="line"><span class="built_in">kill</span> -9 5894 <span class="comment"># 强制杀死 pid5894</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># uptime : startup time 用于查看系统总共运行了多长时间、系统的平均负载等信息</span></span><br><span class="line"><span class="comment"># top : table of processes 用于实时查看系统的 CPU 使用率、内存使用率、进程信息等</span></span><br><span class="line"><span class="comment"># htop : 用户更加友好的top</span></span><br><span class="line"><span class="comment"># vmstat : virtual memory status 进程、内存、I/O 等系统整体运行状态</span></span><br><span class="line"><span class="comment"># pmap : 分析具体进程的使用情况</span></span><br><span class="line"><span class="comment"># free : 用于查看系统的内存使用情况，包括已用内存、可用内存、缓冲区和缓存等</span></span><br><span class="line"><span class="comment"># df : disk free  df -h 查看磁盘的使用情况(可读性高)</span></span><br><span class="line"><span class="comment"># du : disk usage 用于查看指定目录或文件的磁盘空间使用情况，可以指定不同的选项来控制输出格式和单位。</span></span><br></pre></td></tr></table></figure>

<h2 id="开发调试"><a href="#开发调试" class="headerlink" title="开发调试"></a>开发调试</h2><p>静态分析：</p>
<ul>
<li><code>objdump -d &lt;program_file_name&gt;</code>：==查看二进制文件信息==</li>
<li><code>readelf</code>：查看ELF格式文件详细信息</li>
<li><code>ldd</code>：查看动态链接库依赖关系</li>
<li><code>nm</code>：列出目标文件中的符号表</li>
<li><code>strings</code>：提取文件中的可打印字符串</li>
</ul>
<p>内存使用与性能分析：</p>
<ul>
<li><code>cat /proc/meminfo</code> ：==内存使用概括==</li>
<li><code>pmap -x pid</code> ==显示进程的内存映射情况，包括虚拟内存地址和大小。==</li>
<li><code>valgrind --tool=memcheck ./program</code> 分析内存占用，泄露情况</li>
<li><code>perf</code>：性能分析工具</li>
</ul>
<p>调试器：</p>
<ul>
<li><code>gdb</code>：==GNU调试器==</li>
<li><code>strace</code>：==跟踪系统调用==</li>
<li><code>ltrace</code>：跟踪库函数调用</li>
</ul>
<p>构建工具：</p>
<p><strong><code>make</code></strong> 是 Linux 和 Unix 系统上常用的 <strong>构建自动化工具</strong>，用于<strong>自动化编译和管理项目中的依赖关系</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义编译器和编译选项</span></span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件和依赖关系</span></span><br><span class="line"><span class="section">all: main</span></span><br><span class="line"></span><br><span class="line"><span class="section">main: main.o utils.o</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o main main.o utils.o</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c main.c</span><br><span class="line"></span><br><span class="line"><span class="section">utils.o: utils.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c utils.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标 (Target)：构建的最终产物，例如main。</span></span><br><span class="line"><span class="comment"># 依赖 (Dependencies)：目标所依赖的文件，例如 main.o 和 utils.o。</span></span><br><span class="line"><span class="comment"># 命令 (Commands)：生成目标的命令，需要以 Tab 缩进（不能用空格）</span></span><br></pre></td></tr></table></figure>

<h2 id="挂载设备"><a href="#挂载设备" class="headerlink" title="挂载设备"></a>挂载设备</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43800449/article/details/130447269">Linux系统连接/挂载U盘（移动硬盘）详细步骤</a> </p>
<p>1.插入U盘，执行如下指令后能看到设备则说明连接成功</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l #查看外接设备名称，一般为/dev/sd...，这里假设为/dev/sdc1</span><br></pre></td></tr></table></figure>

<p>2.在/mnt下创建挂载点，进行挂载</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /mnt/mydev #创建挂载点</span><br><span class="line">sudo mount /dev/sdc1 /mnt/mydev #将/dev/sdc1挂载到mnt中的挂载点去</span><br><span class="line">sudo df -h #查看是否挂载成功</span><br></pre></td></tr></table></figure>

<p>3.此时挂载文件夹/mnt/mydev里面就是你U盘的内容了，可以随意访问</p>
<p>4.取消挂载，这一步相当于windows下的弹出U盘</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo umount /mnt/mydev #取消挂载，拔出硬盘</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">rmdir</span> –p /mnt/mydev  删除挂载目录（选做）</span></span><br></pre></td></tr></table></figure>

<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com	<span class="comment">#ICMP</span></span><br><span class="line">traceroute www.baidu.com <span class="comment"># 路由路径</span></span><br><span class="line">ifconfig / ip <span class="comment"># 查看网络信息 interface configuration</span></span><br><span class="line">netstat -aon | grep 3306 <span class="comment"># network status 过滤3306字符串 （监听3306端口状态）</span></span><br><span class="line">ss <span class="comment"># 比netstat高效</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wade3015/article/details/90779669">Linux用netstat查看服务及监听端口详解</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_17496365/article/details/96480424">Linux网络状态工具ss命令使用详解</a> </p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>Source</code>将xx应用于当前bash命令行</p>
<p>.bashrc .bash_profile</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44439904/article/details/109505753">linux下的source命令及~/.bashrc, ~/.bash_profile详解_source bashrc-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_57208584/article/details/135868555">【Linux】什么是.bashrc，以及其使用方法-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/shuiche/p/9436126.html">Linux下source命令详解 - 水车 - 博客园 (cnblogs.com)</a></p>
<p><strong>快捷键：</strong> </p>
<p><code>Ctrl</code>+<code>D</code> 用于结束输入或表示没有更多数据，通常用于交互式输入的结束</p>
<p><code>Ctrl</code>+<code>C</code> 强行停止正在运行的命令或进程</p>
<p>大部分命令，当用于文件夹时加 -r</p>
<p><strong>部署软件</strong>：</p>
<p>LAMP: Linux + Apache + MySQL/MariaDB + PHP</p>
<p>LEMP/LNMP: Linux + Nginx(Engine-X) + MySQL/MariaDB + PHP</p>
<p><a target="_blank" rel="noopener" href="https://cn.linux-terminal.com/?p=607">Apache 与 Nginx：哪一种 Web 服务器最适合您？ (linux-terminal.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://cn.linux-console.net/?p=27779">使用 Docker 轻松部署 LAMP 和/或 LEMP 堆栈 (linux-console.net)</a></p>
<p><a target="_blank" rel="noopener" href="https://cn.linux-console.net/?p=1038">如何在 CentOS 7 上安装 Nginx 1.15、MariaDB 10 和 PHP 7 (linux-console.net)</a> </p>
<h1 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/shell-intro.html">Shell编程</a></h1><h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><p>Debian系 <strong>apt</strong></p>
<p>RedHat系 rpm,yum</p>
<h2 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h2><h3 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h3><p>Redhat Package Manager</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rpm -qi firefox <span class="comment"># 查询firefox的安装信息 </span></span><br><span class="line">rpm -qa <span class="comment"># 查询所有</span></span><br><span class="line"></span><br><span class="line">rpm -e firefox <span class="comment"># 卸载firefox</span></span><br><span class="line">--nodeps  <span class="comment">#不检查依赖</span></span><br><span class="line"></span><br><span class="line">rpm -ivh forefox_x86_64.rpm <span class="comment"># 安装firefox，v=verbose 详细信息 h=hash 进度条</span></span><br></pre></td></tr></table></figure>

<h3 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h3><p>Yellow dog Updater Modified</p>
<p>基于RPM</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum -y install firefox <span class="comment"># 安装firefox -y表示所有yesno都填y</span></span><br><span class="line">yum list <span class="comment"># list</span></span><br><span class="line">yum update </span><br><span class="line">yum check-update</span><br><span class="line">yum deplist</span><br></pre></td></tr></table></figure>

<h4 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum 提示 Could not retrieve mirrorlist</span></span><br><span class="line"><span class="comment"># 检查是否连接到网络 Ctrl+C/D停止ping</span></span><br><span class="line">ping www.baidu.com</span><br><span class="line"><span class="comment"># ping通说明是镜像源出问题</span></span><br><span class="line"><span class="comment"># 备份当前yum源</span></span><br><span class="line"><span class="built_in">mv</span> /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line"><span class="comment"># 下载新的 CentOS-Base.repo 到/etc/yum.repos.d/</span></span><br><span class="line"><span class="comment"># 网易: http://mirrors.163.com/.help/CentOS7-Base-163.repo </span></span><br><span class="line"><span class="comment"># 阿里: http://mirrors.aliyun.com/repo/Centos-7.repo </span></span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"><span class="comment"># 清除下载过的安装包, 生成缓存</span></span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>

<p>yum 会把下载的软件包和header存储在cache中(默认路径/var/cache/yum/)，而不自动删除。如果觉得占用磁盘空间，可以使用<code>yum clean</code>指令进行清除，更精确 的用法是<code>yum clean headers</code>(清除header)，<code>yum clean packages</code>(清除下载的rpm包)，<code>yum clean all</code>(全部清除)</p>
<h3 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h3><p>apt（Advanced Packaging Tool）是一个在 Debian 和 Ubuntu 中的 Shell 前端软件包管理器。</p>
<p>apt 命令提供了查找、安装、升级、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>
<p>apt 命令执行需要超级管理员权限(root)。</p>
<ul>
<li><p>列出所有可更新的软件清单命令：<strong>sudo apt update</strong></p>
</li>
<li><p>升级软件包：<strong>sudo apt upgrade</strong></p>
<p>列出可更新的软件包及版本信息：<strong>apt list –upgradable</strong></p>
<p>升级软件包，升级前先删除需要更新软件包：<strong>sudo apt full-upgrade</strong></p>
</li>
<li><p>安装指定的软件命令：<strong>sudo apt install <package_name></strong></p>
<p>安装多个软件包：<strong>sudo apt install <package_1> <package_2> <package_3></strong></p>
</li>
<li><p>更新指定的软件命令：<strong>sudo apt update <package_name></strong></p>
</li>
<li><p>显示软件包具体信息,例如：版本号，安装大小，依赖关系等等：<strong>sudo apt show <package_name></strong></p>
</li>
<li><p>删除软件包命令：<strong>sudo apt remove <package_name></strong></p>
</li>
<li><p>清理不再使用的依赖和库文件: <strong>sudo apt autoremove</strong></p>
</li>
<li><p>移除软件包及配置文件: <strong>sudo apt purge <package_name></strong></p>
</li>
<li><p>查找软件包命令： <strong>sudo apt search <keyword></strong></p>
</li>
<li><p>列出所有已安装的包：<strong>apt list –installed</strong></p>
</li>
</ul>
<h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><p>webget下载工具</p>
<p> <code>wget https://example.com/file.zip</code> 支持断点续传</p>
<p><code>wget -O myfile.zip http://www.example.com/testfile.zip</code> 更改文件名</p>
<p><code>wget -b http://www.example.com/testfile.zip</code> 后台下载</p>
<p><strong>递归下载</strong></p>
<ul>
<li><code>wget -r http://www.example.com/path1/path2/</code><ul>
<li><code>-r</code>：递归在下整个站点（<a target="_blank" rel="noopener" href="http://www.example.com)资源/">www.example.com）资源</a></li>
<li><code>-nd</code>：递归下载时不创建一层一层的目录，把所有的文件下载到当前目录；不指定该选项默认按照资源在站点位置创建相应目录</li>
<li><code>-np</code>：递归下载时不搜索上层目录，只在当前路径path2下进行下载；不指定该选项默认搜素整个站点</li>
<li><code>-A 后缀名</code>：指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔</li>
<li><code>-R 后缀名</code>：排除要下载文件的后缀名，多个后缀名之间使用逗号进行分隔</li>
<li><code>-L</code>：递归时不进入其它主机。不指定该选项的话，如果站点包含了外部站点的链接，这样可能会导致下载内容无限大</li>
</ul>
</li>
</ul>
<blockquote>
<p>示例，只下载path2路径下的所有pdf和png文件，不创建额外目录全都保存在当前下载目录下:<br><code>wget -r -nd -np -A pdf,png http://www.example.com/path1/path2/</code></p>
</blockquote>
<h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><p><strong>curl命令</strong>是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具。作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化，curl可以祝一臂之力。</p>
<p><strong>wget</strong> 是一个独立的下载程序，无需额外的资源库，它也允许你下载网页中或是 FTP 目录中的任何内容, 能享受它超凡的下载速度，简单直接。<br><strong>curl</strong> 是一个多功能工具，是libcurl这个库支持的。它可以下载网络内容，但同时它也能做更多别的事情。</p>
<p>从用途方面，wget倾向于网络文件下载；curl倾向于网络接口调试，相当于一个无图形界面的 PostMan 工具</p>
<h3 id="处理复杂的web请求"><a href="#处理复杂的web请求" class="headerlink" title="处理复杂的web请求"></a>处理复杂的web请求</h3><p><strong>1. 自动跳转</strong></p>
<ul>
<li><code>curl -L http://www.example.com</code><ul>
<li><code>-L</code>：自动跳转到重定向链接(Location)</li>
</ul>
</li>
</ul>
<p>有些链接访问时会自动跳转(响应状态码为3xx)，<code>-L</code>参数会让 HTTP 请求跟随服务器的重定向。例如：访问 “<a target="_blank" rel="noopener" href="http://a.com&quot;/">http://a.com&quot;</a> 会重定向到 “<a target="_blank" rel="noopener" href="http://b.com&quot;,使用&quot;-l&quot;选项会返回/">http://b.com&quot;，使用&quot;-L&quot;选项会返回</a> “<a target="_blank" rel="noopener" href="http://b.com&quot;/">http://b.com&quot;</a> 的响应内容</p>
<p><strong>2. 显示响应头信息</strong></p>
<ul>
<li><code>curl -i http://www.example.com</code><ul>
<li><code>-i</code>：输出包含响应头信息</li>
<li><code>-I</code>：输出仅包含响应头信息，不包含响应内容</li>
</ul>
</li>
</ul>
<p><strong>3. 显示通信过程</strong></p>
<ul>
<li><code>curl -v http://www.example.com</code><ul>
<li><code>-v</code>：显示一次http通信的整个过程，包括端口连接和http request头信息</li>
</ul>
</li>
</ul>
<p>如果还需要查看额外的通信信息，还可以使用选项 “<code>--trace 输出文件</code>“ 或者 “<code>--trace-ascii 输出文件</code>“，例如：<code>curl --trace-ascii output.txt http://www.example.com</code>，打开文件 “output.txt”可以查看结果。</p>
<p><strong>4. 指定http请求方式</strong></p>
<ul>
<li><code>curl -X 请求方式 http://www.example.com/test</code><ul>
<li><code>-X 请求方式</code>：指定http请求方式(GET|POST|DELETE|PUT等)。默认是”GET”</li>
</ul>
</li>
</ul>
<p><strong>5. 添加http请求头</strong></p>
<ul>
<li><code>curl -H &#39;kev:value&#39; http://www.example.com/test</code><ul>
<li><code>-H &#39;kev:value&#39;</code>：添加http请求头。例：<code>-H &#39;Content-Type:application/json&#39;</code></li>
</ul>
</li>
</ul>
<p>添加多个请求头，<code>-H</code> 选项重复多次即可。例如：<br><code>curl -H &#39;Accept-Language: en-US&#39; -H &#39;Secret-Message: xyzzy&#39; http://www.example.com/test</code></p>
<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>以OpenSSL 1.1.1 的编译安装为例</p>
<blockquote>
<p>yum -y install wget</p>
</blockquote>
<p>1.安装构建 OpenSSL 所需的依赖项。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum -y groupinstall <span class="string">&quot;Development Tools&quot;</span></span><br></pre></td></tr></table></figure>

<p>2.下载 OpenSSL 1.1.x 的源代码，其中<strong>x</strong>替换为所需的实际版本。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.openssl.org/source/openssl-1.1.1t.tar.gz</span><br></pre></td></tr></table></figure>

<p>3.提取下载的文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvf openssl-1.1.1t.tar.gz</span><br></pre></td></tr></table></figure>

<p>4.导航到从文件提取创建的目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd openssl-1.1*/</span><br></pre></td></tr></table></figure>

<p>5.配置 OpenSSL。您可以指定</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./config --prefix=/usr/local/openssl --openssldir=/usr/local/openssl</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Operating system: x86_64-whatever-linux2</span><br><span class="line">Configuring OpenSSL version 1.1.1t (0x1010114fL) for linux-x86_64</span><br><span class="line">Using os-specific seed configuration</span><br><span class="line">Creating configdata.pm</span><br><span class="line">Creating Makefile</span><br><span class="line"></span><br><span class="line">**********************************************************************</span><br><span class="line">***                                                                ***</span><br><span class="line">***   OpenSSL has been successfully configured                     ***</span><br><span class="line">***                                                                ***</span><br><span class="line">***   If you encounter a problem while building, please open an    ***</span><br><span class="line">***   issue on GitHub &lt;https://github.com/openssl/openssl/issues&gt;  ***</span><br><span class="line">***   and include the output from the following command:           ***</span><br><span class="line">***                                                                ***</span><br><span class="line">***       perl configdata.pm --dump                                ***</span><br><span class="line">***                                                                ***</span><br><span class="line">***   (If you are new to OpenSSL, you might want to consult the    ***</span><br><span class="line">***   &#x27;Troubleshooting&#x27; section in the INSTALL file first)         ***</span><br><span class="line">***                                                                ***</span><br><span class="line">**********************************************************************</span><br></pre></td></tr></table></figure>

<p>5.使用make命令构建 OpenSSL 1.1.x。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j $(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure>

<p>6.在 CentOS 7 / RHEL 7 上安装 OpenSSL 1.1.1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>7.更新共享库缓存。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>

<p>8.更新系统范围的 OpenSSL 配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo tee /etc/profile.d/openssl.sh&lt;&lt;EOF</span><br><span class="line">export PATH=/usr/local/openssl/bin:\$PATH</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/openssl/lib:\$LD_LIBRARY_PATH</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>9.重新加载shell环境：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile.d/openssl.sh</span><br><span class="line">logout</span><br></pre></td></tr></table></figure>

<p>10.验证 CentOS 7 / RHEL 7 上是否安装了 OpenSSL 1.1.1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> openssl</span></span><br><span class="line">/usr/local/openssl/bin/openssl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl version</span></span><br><span class="line">OpenSSL 1.1.1t  7 Feb 2023</span><br></pre></td></tr></table></figure>



<h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><h2 id="SSH端口"><a href="#SSH端口" class="headerlink" title="SSH端口"></a>SSH端口</h2><p>SSH 的端口是服务器上用于监听和处理 SSH 连接请求的网络端口。端口可以理解为设备或计算机与外界通信的一个“入口”或“通道”，每个端口对应不同的服务或应用程序。</p>
<h3 id="默认端口：22"><a href="#默认端口：22" class="headerlink" title="默认端口：22"></a>默认端口：22</h3><p>SSH 的默认端口号是 <strong>22</strong>。当你在终端中使用 SSH 连接到远程服务器时，如果没有明确指定端口，SSH 客户端会自动连接到服务器的 22 端口。</p>
<p>例如，以下命令使用默认的 22 端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@192.168.1.100</span><br></pre></td></tr></table></figure>

<h3 id="自定义端口"><a href="#自定义端口" class="headerlink" title="自定义端口"></a>自定义端口</h3><p>为了增强安全性，很多服务器管理员会修改默认的 22 端口为其他非标准端口。这样可以减少一些自动化的攻击，比如扫描网络上 22 端口的 SSH 连接尝试。</p>
<p>如果服务器的 SSH 服务配置在非标准端口（例如 2222），你需要显式指定端口号，才能成功连接到服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@192.168.1.100 -p 2222</span><br></pre></td></tr></table></figure>

<h3 id="端口的作用"><a href="#端口的作用" class="headerlink" title="端口的作用"></a>端口的作用</h3><p>每个端口都是通过一个数字标识的，范围在 0 到 65535 之间。不同的端口对应不同的服务：</p>
<ul>
<li><strong>端口 22</strong>：通常用于 SSH 连接。</li>
<li><strong>端口 80</strong>：用于 HTTP 网络服务。</li>
<li><strong>端口 443</strong>：用于 HTTPS 网络服务。</li>
</ul>
<p>SSH 服务监听的端口可以自定义配置，通常在服务器的 <code>/etc/ssh/sshd_config</code> 文件中进行修改。更改默认端口可以提高安全性，减少针对默认端口的恶意攻击。</p>
<h3 id="端口的工作原理"><a href="#端口的工作原理" class="headerlink" title="端口的工作原理"></a>端口的工作原理</h3><p>当你尝试通过 SSH 连接到服务器时，SSH 客户端发送请求到服务器的指定端口。服务器上的 SSH 服务会在这个端口上监听并接收连接请求，一旦验证通过，就会建立安全的加密通道，允许你远程控制服务器。</p>
<p>简而言之，SSH 端口就是服务器上提供 SSH 服务的入口，你可以通过指定端口来连接远程服务器。</p>
<p>要通过 SSH 登录到远程服务器上，可以按照以下步骤进行操作：</p>
<h2 id="使用SSH登录远程服务器"><a href="#使用SSH登录远程服务器" class="headerlink" title="使用SSH登录远程服务器"></a>使用SSH登录远程服务器</h2><p>要在 CentOS 7 上使用 OpenSSH，通常分为以下几个步骤：安装、配置并启动 SSH 服务。具体步骤如下：</p>
<h3 id="安装-OpenSSH"><a href="#安装-OpenSSH" class="headerlink" title="安装 OpenSSH"></a>安装 OpenSSH</h3><p>CentOS 7 通常已经预装了 OpenSSH。如果没有安装，可以使用以下命令来安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y openssh-server</span><br></pre></td></tr></table></figure>

<h3 id="启动并启用-SSH-服务"><a href="#启动并启用-SSH-服务" class="headerlink" title="启动并启用 SSH 服务"></a>启动并启用 SSH 服务</h3><p>安装完成后，你需要启动并设置 SSH 服务开机自启：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 SSH 服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start sshd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机自动启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> sshd</span><br></pre></td></tr></table></figure>

<h3 id="配置-SSH（可选）"><a href="#配置-SSH（可选）" class="headerlink" title="配置 SSH（可选）"></a>配置 SSH（可选）</h3><p>如果需要自定义配置 SSH，可以修改配置文件 <code>/etc/ssh/sshd_config</code>。你可以使用任何文本编辑器来编辑文件，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<p>常见的配置项包括：</p>
<ul>
<li><p><strong>更改默认端口</strong>：<br>找到 <code>#Port 22</code>，取消注释并设置成你想要的端口号，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Port 2222</span><br></pre></td></tr></table></figure></li>
<li><p><strong>禁止 root 账户直接登录</strong>：<br>找到 <code>#PermitRootLogin yes</code>，取消注释并改为 <code>no</code> 以提高安全性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin no</span><br></pre></td></tr></table></figure></li>
</ul>
<p>完成后，保存并退出。</p>
<h3 id="确定远程服务器的-IP-地址和用户名"><a href="#确定远程服务器的-IP-地址和用户名" class="headerlink" title="确定远程服务器的 IP 地址和用户名"></a>确定远程服务器的 IP 地址和用户名</h3><ul>
<li><strong>IP 地址</strong>：你需要知道远程服务器的公网 IP 或内网 IP。</li>
<li><strong>用户名</strong>：你要知道登录时使用的用户名。通常是服务器的账户名，例如 <code>root</code>、<code>admin</code> 或其他已创建的普通用户。</li>
</ul>
<h3 id="使用-SSH-命令连接服务器"><a href="#使用-SSH-命令连接服务器" class="headerlink" title="使用 SSH 命令连接服务器"></a>使用 SSH 命令连接服务器</h3><p>在本地终端中使用 <code>ssh</code> 命令连接远程服务器，命令格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@server_ip</span><br></pre></td></tr></table></figure>

<ul>
<li><code>username</code>：远程服务器的登录用户名。</li>
<li><code>server_ip</code>：远程服务器的 IP 地址。</li>
</ul>
<p>例如，如果你的远程服务器 IP 是 <code>192.168.1.100</code>，用户名是 <code>user123</code>，你可以输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user123@192.168.1.100</span><br></pre></td></tr></table></figure>

<h3 id="端口号非默认时指定端口"><a href="#端口号非默认时指定端口" class="headerlink" title="端口号非默认时指定端口"></a>端口号非默认时指定端口</h3><p>如果 SSH 服务使用了非默认端口（默认是 22），你需要通过 <code>-p</code> 参数指定端口号。例如，如果远程服务器的 SSH 端口是 2222，你可以这样连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user123@192.168.1.100 -p 2222</span><br></pre></td></tr></table></figure>

<h3 id="输入密码"><a href="#输入密码" class="headerlink" title="输入密码"></a>输入密码</h3><p>第一次连接时，系统会提示你是否信任服务器的主机密钥，输入 <code>yes</code>，然后系统会要求你输入服务器用户的密码。输入密码并回车后，如果验证成功，你将进入远程服务器。</p>
<h3 id="使用-SSH-密钥登录（可选）"><a href="#使用-SSH-密钥登录（可选）" class="headerlink" title="使用 SSH 密钥登录（可选）"></a>使用 SSH 密钥登录（可选）</h3><p>如果你不想每次输入密码，可以配置 SSH 密钥对（公钥和私钥）进行无密码登录。步骤如下：</p>
<h4 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h4><p>在本地电脑上生成 SSH 密钥对：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure>

<p>按回车后会提示你设置密钥保存路径和密码。默认保存在 <code>~/.ssh/id_rsa</code>。设置密码是可选的。</p>
<h4 id="将公钥复制到远程服务器"><a href="#将公钥复制到远程服务器" class="headerlink" title="将公钥复制到远程服务器"></a>将公钥复制到远程服务器</h4><p>使用 <code>ssh-copy-id</code> 命令将你的公钥复制到远程服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id user123@192.168.1.100</span><br></pre></td></tr></table></figure>

<p>或者，如果服务器使用了不同端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -p 2222 user123@192.168.1.100</span><br></pre></td></tr></table></figure>

<h4 id="通过密钥连接"><a href="#通过密钥连接" class="headerlink" title="通过密钥连接"></a>通过密钥连接</h4><p>公钥成功上传后，下一次你再使用 SSH 登录时，就无需输入密码了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user123@192.168.1.100</span><br></pre></td></tr></table></figure>

<p>通过以上步骤，你就可以通过 SSH 成功登录远程服务器了。如果有问题，可以检查防火墙、SSH 服务是否正常运行等配置。</p>
<p><strong>47.97.75.20(公)</strong></p>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="数据挂载-双向绑定"><a href="#数据挂载-双向绑定" class="headerlink" title="数据挂载 双向绑定"></a>数据挂载 双向绑定</h2><p><strong>数据卷挂载</strong></p>
<p><strong>docker volume</strong> </p>
<p>nginx 容器内部挂载</p>
<p>docker run -v html:/usr/share/nginx/html</p>
<p>容器和外界完全隔绝无法直接访问，内部的bash也不完整不能使用vi编辑器，所以可以把容器内部html目录挂载到宿主机上，挂载之后就有了</p>
<p><strong>本地目录挂载</strong></p>
<p>本地任意目录</p>
<p>docker run -v 本地目录：容器内部目录，必须以/ ./开头</p>
<h2 id="自定义镜像-dockerfile"><a href="#自定义镜像-dockerfile" class="headerlink" title="自定义镜像-dockerfile"></a>自定义镜像-dockerfile</h2><p> Java镜像：Linux运行环境，JRE, 环境变量，拷贝jar，编写运行的shell脚本</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241010090300035-1728747968346-1.png" alt="image-20241010090300035"></p>
<p>ubuntu镜像中必要的部分，分层使得轮子的复用性大大提高BaseImage，也能提高下载的效率，减少网络资源和硬盘空间的占用</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241010090221898-1728747968346-2.png" alt="image-20241010090221898"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241010090640183-1728747968346-3.png" alt="image-20241010090640183"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241010091128239-1728747968347-7.png" alt="image-20241010091128239"></p>
<h2 id="容器间网络互连"><a href="#容器间网络互连" class="headerlink" title="容器间网络互连"></a>容器间网络互连</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241010095017952-1728747968346-6.png" alt="image-20241010095017952"></p>
<p>Bridged network</p>
<p>新创建网桥，将指定容器连接到网桥</p>
<p>创建容器时指定network，即可连到网桥</p>
<p>同一个自定义网桥的容器之间可以用容器名直接通信     </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241010095906439-1728747968346-4.png" alt="image-20241010095906439"></p>
<h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>Springboot + Nginx + Vue </p>
<p>1.springboot内部封装了servlet容器 tomcat 能够处理对动态资源的请求（后端集成）</p>
<ul>
<li>管理Servlet程序的生命周期</li>
<li>将URL映射到指定的Servlet进行处理</li>
<li>与Servlet程序合作处理HTTP请求——根据HTTP请求生成HttpServletResponse对象并传递给Servlet进行处理，将Servlet中的HttpServletResponse对象生成的内容返回给浏览器</li>
</ul>
<p>2.nginx能够进行反向代理，代理后端服务器处理静态资源的请求（例如图片、视频、CSS、JavaScript文件等,也就是前端的），负载均衡：当业务压力增大时，可能一个Tomcat的实例不足以处理，那么这时可以启动多个Tomcat实例进行水平扩展，而Nginx的负载均衡功能可以把请求通过算法分发到各个不同的实例进行处理</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241010154836707-1728747968346-5.png" alt="image-20241010154836707"></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/32212996">tomcat 与 nginx，apache的区别是什么？ - 知乎 (zhihu.com)</a></p>
<p>HTTP server：只关心http协议层面的传输和访问控制，如实将服务器上的文件通过http协议传输给客户端。</p>
<p>Application server: 应用容器（servlet=server applet）tomcat需要提供JSP/servlet运行的类库，会集成一部分httpserver功能，但是不如HTTP server强大</p>
<h2 id="dockerCompose"><a href="#dockerCompose" class="headerlink" title="dockerCompose"></a>dockerCompose</h2><p>docker-compose.yml</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241010165557595-1728747968347-8.png" alt="image-20241010165557595"></p>
<h1 id="MySQL-on-WSL"><a href="#MySQL-on-WSL" class="headerlink" title="MySQL on WSL"></a>MySQL on WSL</h1><h2 id="CentOS-7-安装到-WSL2"><a href="#CentOS-7-安装到-WSL2" class="headerlink" title="CentOS 7 安装到 WSL2"></a>CentOS 7 安装到 WSL2</h2><ol>
<li><p>下载CentOS: <a target="_blank" rel="noopener" href="https://github.com/mishamosher/CentOS-WSL/releases/tag/7.9-2211">Release CentOS 7.9-2211 · mishamosher/CentOS-WSL (github.com)</a></p>
</li>
<li><p>下载完成解压得到 CentOS7.exe rootfs.tar.gz 两个文件</p>
</li>
<li><p>安装完成后在相同目录下生成 ext4.vhdx 文件</p>
</li>
<li><p>```powershell</p>
<h1 id="在此处打开PowerShell"><a href="#在此处打开PowerShell" class="headerlink" title="在此处打开PowerShell"></a>在此处打开PowerShell</h1><p>wsl -l -v</p>
<h1 id="成功返回如下"><a href="#成功返回如下" class="headerlink" title="成功返回如下"></a>成功返回如下</h1><p>NAME    STATE   VERSION<br>CentOS7 Stopped 2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. ```powershell</span><br><span class="line">   # 迁移默认存储位置</span><br><span class="line">   # 确保为stop状态</span><br><span class="line">   wsl -l -v</span><br><span class="line">   # 导出CentOS文件到tar，文件夹需提前创建</span><br><span class="line">   wsl --export CentOS7 D:/CentOSWSL/centos7.tar</span><br><span class="line">   # 注销系统</span><br><span class="line">   wsl --unregister CentOS7</span><br><span class="line">   # 确定已注销</span><br><span class="line">   wsl -l -v</span><br><span class="line">   # 执行导入(如果失败可再次尝试执行)</span><br><span class="line">   wsl --import CentOS7  D:/CentOSWSL/ D:/CentOSWSL/centos7.tar</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="安装缺乏的依赖项"><a href="#安装缺乏的依赖项" class="headerlink" title="安装缺乏的依赖项"></a>安装缺乏的依赖项</h2><p>有些部分会提示缺乏dependencies</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql-community-devel-8.0.17-1.el7.x86_64.rpm --force --nodeps</span><br><span class="line"><span class="comment"># 直接强制安装，无视依赖</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install libaio</span><br><span class="line">yum install openssl-devel</span><br></pre></td></tr></table></figure>

<h2 id="解决执行systemctl命令报错：Failed-to-get-D-Bus-connection"><a href="#解决执行systemctl命令报错：Failed-to-get-D-Bus-connection" class="headerlink" title="解决执行systemctl命令报错：Failed to get D-Bus connection "></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fengjq/p/17616874.html">解决执行systemctl命令报错：Failed to get D-Bus connection </a></h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;[boot]\nsystemd=true&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> -a /etc/wsl.conf</span><br><span class="line"><span class="comment"># powershell</span></span><br><span class="line">wsl.exe --shutdown</span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">systemctl list-unit-files --<span class="built_in">type</span>=service</span><br></pre></td></tr></table></figure>

<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld</span><br><span class="line">systemctl restart mysqld</span><br><span class="line">systemctl stop mysqld</span><br><span class="line"></span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<h3 id="查看随机生成密码"><a href="#查看随机生成密码" class="headerlink" title="查看随机生成密码"></a>查看随机生成密码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /var/log/mysqld.log</span><br></pre></td></tr></table></figure>

<h3 id="更改密码"><a href="#更改密码" class="headerlink" title="更改密码"></a>更改密码</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;ace123456&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="更改密码策略"><a href="#更改密码策略" class="headerlink" title="更改密码策略"></a>更改密码策略</h3><p><strong>默认策略：</strong></p>
<ul>
<li><strong>至少包含 1 位大小写</strong></li>
<li><strong>至少包含 1 位数字</strong></li>
<li><strong>包含 1 个特殊符号</strong></li>
<li><strong>必须 8 位及以上</strong></li>
</ul>
<p><strong>连接到MySQL服务器：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>输入 <code>root</code> 用户的密码进行登录。</p>
<p><strong>2. 执行以下命令来查看当前的密码策略：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE <span class="string">&#x27;validate_password%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>3. 根据需求修改以下变量：</strong></p>
<ul>
<li><p><code>validate_password.policy</code>：密码策略，默认值为<code>MEDIUM</code>。可以设置为<code>LOW</code>、<code>MEDIUM</code>、<code>STRONG</code>或者自定义。例如，可以将其设置为<code>LOW</code>以降低密码复杂性要求。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> validate_password.policy <span class="operator">=</span> LOW;</span><br></pre></td></tr></table></figure>

<p>不同策略的要求：<br><code>0/LOW</code>：只验证长度；<br><code>1/MEDIUM</code>：验证长度、数字、大小写、特殊字符；默认值。<br><code>2/STRONG</code>：验证长度、数字、大小写、特殊字符、字典文件；</p>
</li>
<li><p><code>validate_password.length</code>：密码最小长度，默认值为<code>8</code>。可以根据需要修改最小密码长度。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> validate_password.length <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><code>validate_password.number_count</code>：密码中的数字要求，默认值为<code>1</code>。可以增加或减少数字的要求。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> validate_password.number_count <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><code>validate_password.special_char_count</code>：密码中特殊字符的要求，默认值为<code>1</code>。可以增加或减少特殊字符的要求。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> validate_password.special_char_count <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><code>validate_password.mixed_case_count</code>：密码中大写字母和小写字母的要求，默认值为<code>1</code>。可以增加或减少大写字母和小写字母的要求。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> validate_password.mixed_case_count <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>4. 修改配置文件以使修改的密码策略永久生效。</strong></p>
<p>打开<code>MySQL</code>的配置文件（通常是 <code>mysqld.cnf</code> 或 <code>my.cnf</code>），添加下面的内容到文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">validate_password.policy=LOW</span><br><span class="line">validate_password.length=6</span><br><span class="line">validate_password.number_count=1</span><br><span class="line">validate_password.special_char_count=1</span><br><span class="line">validate_password.mixed_case_count=1</span><br></pre></td></tr></table></figure>

<p><strong>5. 重启 MySQL 服务以应用更改：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart mysql</span><br></pre></td></tr></table></figure>

<p>完成上述步骤后，就已经修改了 <code>MySQL 8.0</code> 的密码策略。可以需求调整密码策略的参数，并确保设置合适的密码策略以提高数据库的安全性。</p>
<h3 id="配置文件路径"><a href="#配置文件路径" class="headerlink" title="配置文件路径"></a>配置文件路径</h3><p>通过 which 命令可以查看 mysql 安装路径，如下所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> mysql </span><br><span class="line">/usr/bin/mysql</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>如果服务器没有安装 mysql 命令，可以使用绝对路径下的 mysql 命令，查看配置文件在哪。如果 Linux 服务器已配置好 mysql 命令，也可以直接使用 mysql 命令查看。具体语句如下所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/bin/mysql --verbose --<span class="built_in">help</span> | grep -A 1 <span class="string">&#x27;Default options&#x27;</span></span><br><span class="line">$ mysql --verbose --<span class="built_in">help</span> | grep -A 1 <span class="string">&#x27;Default options&#x27;</span></span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>2条命令分别执行完毕后的结果均显示如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Default options are <span class="built_in">read</span> from the following files <span class="keyword">in</span> the given order:</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/etc/my.cnf ~/.my.cnf</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>结果显示：服务器首先读取的是 /etc/my.cnf 文件，如果该文件不存在则继续读 /etc/mysql/my.cnf 文件，如若文件还不存在便会去读 /usr/etc/my.cnf 文件，若文件仍不存在则继续读 ~/.my.cnf文件。</p>
<p>通过sudo tee写入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;[mysqld]\nvalidate_password.policy=LOW\nvalidate_password.length=6\nvalidate_password.number_count=1\nvalidate_password.special_char_count=1\nvalidate_password.mixed_case_count=1&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/my.cnf</span><br></pre></td></tr></table></figure>

<h3 id="添加可供远程访问的用户"><a href="#添加可供远程访问的用户" class="headerlink" title="添加可供远程访问的用户"></a>添加可供远程访问的用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> <span class="string">&#x27;ace123456&#x27;</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="查看WSL的IP地址"><a href="#查看WSL的IP地址" class="headerlink" title="查看WSL的IP地址"></a>查看WSL的IP地址</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Powershell</span></span><br><span class="line">wsl -d CentOS7 hostname -I</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wsl: 检测到 localhost 代理配置，但未镜像到 WSL。NAT 模式下的 WSL 不支持 localhost 代理。</span></span><br><span class="line">172.19.111.46</span><br></pre></td></tr></table></figure>

<h2 id="查看服务状态"><a href="#查看服务状态" class="headerlink" title="查看服务状态"></a>查看服务状态</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status mysqld</span><br><span class="line">chkconfig mysqld on</span><br><span class="line">重载systemctl配置，设置mysqld服务开机自启动。</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> mysqld</span><br><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@LAPTOP-BCC46KV0 init.d]# systemctl show mysqld -p After</span><br><span class="line">After=basic.target network.target syslog.target systemd-journald.socket system.slice</span><br><span class="line"></span><br><span class="line">systemctl status mysqld</span><br><span class="line">journalctl -xe</span><br><span class="line"></span><br><span class="line">systemctl show mysqld -p After</span><br><span class="line">systemctl show mysqld -p Before</span><br><span class="line">netstat -tulnp | grep :3306</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /etc/passwd</span><br><span class="line"></span><br><span class="line">ps -eo pid,user,<span class="built_in">comm</span> | grep mysqld</span><br><span class="line"></span><br><span class="line">top -u mysql</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写入windows环境变量+开启systemd			</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[boot]\nsystemd=true\n&quot;</span> &gt;&gt; /etc/wsl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[interop]\nappendWindowsPath=false\n&quot;</span> &gt;&gt; /etc/wsl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;### Windows ###</span></span><br><span class="line"><span class="string">export PATH=&quot;$PATH:/mnt/c/Users/Lenovo/AppData/Local/Microsoft/WindowsApps&quot;</span></span><br><span class="line"><span class="string">export PATH=&quot;$PATH:/mnt/c/Program Files/Docker/Docker/resources/bin&quot;</span></span><br><span class="line"><span class="string">export PATH=&quot;$PATH:/mnt/c/Windows&quot;&#x27;</span> &gt;&gt; /etc/profile</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动时间</span></span><br><span class="line"><span class="built_in">uptime</span> </span><br><span class="line"><span class="built_in">who</span> -b</span><br><span class="line"></span><br><span class="line">vim /etc/wsl.conf</span><br><span class="line"></span><br><span class="line">[network]</span><br><span class="line">hostname = node01 <span class="comment">#主机名称</span></span><br><span class="line">generateHosts = <span class="literal">false</span> <span class="comment">#自动生成hosts</span></span><br></pre></td></tr></table></figure>



<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">worker_processes</span>  <span class="number">1</span><span class="string">;</span>  <span class="comment"># 指定 Nginx 启动的工作进程数量</span></span><br><span class="line"></span><br><span class="line"><span class="string">events</span> &#123;</span><br><span class="line">    <span class="string">worker_connections</span>  <span class="number">1024</span><span class="string">;</span>  <span class="comment"># 每个工作进程允许的最大连接数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">http</span> &#123;</span><br><span class="line">    <span class="string">include</span>       <span class="string">mime.types;</span>  <span class="comment"># 包含 MIME 类型配置文件</span></span><br><span class="line">    <span class="string">default_type</span>  <span class="string">application/json;</span>  <span class="comment"># 默认的 Content-Type</span></span><br><span class="line"></span><br><span class="line">    <span class="string">sendfile</span>        <span class="string">off;</span>  <span class="comment"># 禁用高效文件传输</span></span><br><span class="line"></span><br><span class="line">    <span class="string">keepalive_timeout</span>  <span class="number">65</span><span class="string">;</span>  <span class="comment"># 保持活动连接的超时时间</span></span><br><span class="line"></span><br><span class="line">    <span class="string">server</span> &#123;</span><br><span class="line">        <span class="string">listen</span>       <span class="number">8080</span><span class="string">;</span>  <span class="comment"># Nginx 监听的端口</span></span><br><span class="line">        <span class="string">server_name</span>  <span class="string">localhost;</span>  <span class="comment"># 虚拟主机名称</span></span><br><span class="line"></span><br><span class="line">        <span class="string">location</span> <span class="string">/</span> &#123;</span><br><span class="line">            <span class="string">root</span>   <span class="string">html/hmdp;</span>  <span class="comment"># 静态文件根目录</span></span><br><span class="line">            <span class="string">index</span>  <span class="string">index.html</span> <span class="string">index.htm;</span>  <span class="comment"># 默认索引文件</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="string">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  <span class="string">/50x.html;</span>  <span class="comment"># 自定义错误页面</span></span><br><span class="line">        <span class="string">location</span> <span class="string">=</span> <span class="string">/50x.html</span> &#123;</span><br><span class="line">            <span class="string">root</span>   <span class="string">html;</span>  <span class="comment"># 错误页面的具体位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="string">location</span> <span class="string">/api</span> &#123;  </span><br><span class="line">            <span class="string">default_type</span>  <span class="string">application/json;</span>  <span class="comment"># 设置默认 Content-Type</span></span><br><span class="line"></span><br><span class="line">            <span class="string">keepalive_timeout</span>   <span class="string">30s;</span>  <span class="comment"># 对于 /api 的连接保持活动超时时间</span></span><br><span class="line">            <span class="string">keepalive_requests</span>  <span class="number">1000</span><span class="string">;</span>  <span class="comment"># 允许的最大请求数</span></span><br><span class="line"></span><br><span class="line">            <span class="string">proxy_http_version</span> <span class="number">1.1</span><span class="string">;</span>  <span class="comment"># 设置代理请求使用的 HTTP 版本</span></span><br><span class="line"></span><br><span class="line">            <span class="string">rewrite</span> <span class="string">/api(/.*)</span> <span class="string">$1</span> <span class="string">break;</span>  <span class="comment"># 重写请求的 URI</span></span><br><span class="line"></span><br><span class="line">            <span class="string">proxy_pass_request_headers</span> <span class="string">on;</span>  <span class="comment"># 转发请求头</span></span><br><span class="line"></span><br><span class="line">            <span class="string">proxy_next_upstream</span> <span class="string">error</span> <span class="string">timeout;</span>  <span class="comment"># 在错误或超时情况下尝试下一个后端服务器</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#proxy_pass http://127.0.0.1:8081;  # 将请求转发到后端服务</span></span><br><span class="line">            <span class="string">proxy_pass</span> <span class="string">http://backend;</span>  <span class="comment"># 可以使用 upstream 定义的 backend 服务器</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#将请求转发</span></span><br><span class="line">    <span class="string">upstream</span> <span class="string">backend</span> &#123;</span><br><span class="line">        <span class="string">server</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8081</span> <span class="string">max_fails=5</span> <span class="string">fail_timeout=10s</span> <span class="string">weight=1;</span>  <span class="comment"># 后端服务器配置</span></span><br><span class="line">        <span class="string">server</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8082</span> <span class="string">max_fails=5</span> <span class="string">fail_timeout=10s</span> <span class="string">weight=1;</span>  <span class="comment"># 另一个后端服务器的注释</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==虚拟主机（反向代理）Reverse Proxy==：<code>server</code> 中的<code>listen 8080</code> <code>server_name localhost</code> 分别表示虚拟主机的端口和域名，客户端发送请求就可以把虚拟主机当做服务器。</p>
<p>==请求转发（负载均衡）Request Forwarding &amp; Load Balancing==：<code>location /api</code> 表示nginx接管<code>/api</code>路径下的请求，<code>rewrite</code>表示会将请求的URL重写，因为在后端并不存在接管/api的Controller，<code>proxy_pass</code>表示请求转发的目标，这里转发到了backend，对应2个服务器地址，默认采用轮询(polling)机制</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241104184639596.png" alt="image-20241104184639596" style="zoom: 50%;" />

<p>如图，前端所有AJAX请求的URL都有<code>/api</code>前缀，前端向nginx发送请求，URL为<a target="_blank" rel="noopener" href="http://localhost:8080/api/shop/1%EF%BC%8C%E7%BB%8F%E8%BF%87Nginx%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%88%B0http://127.0.0.1/shop/1%E4%B8%8B%EF%BC%8C%E6%AD%A3%E5%A5%BD%E5%B0%B1%E6%98%AF%E5%90%8E%E7%AB%AF%E7%9A%84Controller%E6%89%80%E5%9C%A8%E7%9A%84URL">http://localhost:8080/api/shop/1，经过Nginx端口转发到http://127.0.0.1/shop/1下，正好就是后端的Controller所在的URL</a></p>
<p>==静态文件服务 HTTP Server==： <code>location /</code> 表示nginx将接管 <code>/</code> 路径下的请求    <code>root</code>表示静态文件的具体位置</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default/">1</a><a class="page-number" href="/default/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/default/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/default/page/9/">9</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">碎梦</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/scatteredream" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
