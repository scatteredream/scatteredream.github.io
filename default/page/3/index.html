<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Arvo:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scatteredream.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="scatteredream&#39;s blog">
<meta property="og:url" content="http://scatteredream.github.io/default/page/3/index.html">
<meta property="og:site_name" content="scatteredream&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="碎梦">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://scatteredream.github.io/default/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default/page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>scatteredream's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">scatteredream's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">碎梦</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">97</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">单例模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-20T00:00:00+08:00">2024-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 13:10:52" itemprop="dateModified" datetime="2025-04-27T13:10:52+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h1><h2 id="饿汉"><a href="#饿汉" class="headerlink" title="饿汉"></a>饿汉</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;<span class="keyword">return</span> instance;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程安全，但是可能造成资源的浪费</p>
<h2 id="懒汉-双重校验锁-DCL"><a href="#懒汉-双重校验锁-DCL" class="headerlink" title="懒汉 双重校验锁 DCL"></a><u><strong>懒汉 双重校验锁 DCL</strong></u></h2><ol>
<li>懒汉（延迟初始化） 要素：无参构造私有，进行判断<strong>「线程不安全」</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>原来的实现容易出现线程安全问题，改进：<code>getInstance()</code>变成 <code>synchronized</code> 方法。<ul>
<li><p><strong>锁范围太大</strong>：性能差，同步开销大。正常的执行路径不需要同步，只需要在创建实例的时候进行锁定即可。</p>
<ul>
<li><p>锁对象的选择：<strong>两个不相关的方法不要使用同一把锁</strong>。<strong>并且要注意不能出现死锁互相等待</strong>。</p>
</li>
<li><p>class：适用于保护静态变量或者类级别的共享资源，如果是为了保护某个对象的状态，就应该使用this。</p>
</li>
<li><p>this可能的问题：这边在内部使用this调用task.dosth()，另一边一个完全无关的业务使用 task做锁。</p>
</li>
<li><p>死锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Friend</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Friend</span><span class="params">(String name)</span> &#123;<span class="built_in">this</span>.name = name;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bow</span><span class="params">(Friend other)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; 正在向 &quot;</span> + other.name + <span class="string">&quot; 鞠躬&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟执行延迟</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            other.bowBack(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bowBack</span><span class="params">(Friend other)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; 正在回礼 &quot;</span> + other.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 死锁：a和b同时向对方bow，先都锁住了自己，bowBack的时候就会造成互相等待</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>未二次判空</strong>：线程 A 通过了条件判断，获取了锁，开始创建实例，就在同时，线程B也通过判断等待锁释放，在线程 A 出来之后线程B又进去创建了一次。</p>
</li>
<li><p><strong>指令重排序</strong>：Java 允许指令重排序，创建对象可以分为 1. 分配内存地址 2. 在这块内存地址创建对象 3. 将 对象的引用 instance 指向这块地址。如果2 3的顺序颠倒，线程 A 进去之后在完全创建对象之前就将 instance 置为 非null，线程B就会以为别人已经创建好了，直接返回 instance 引用，线程B拿到以后就开始使用，其中就会随机发生空指针或者状态异常等其他难以复现调试的bug。引入 volatile，表示这个变量不允许指令重排，且线程对它的写入会立刻对其他线程可见。避免发生拿到错误对象的情况</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance; <span class="comment">// 1. 禁止指令重排序</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton.class)&#123;<span class="comment">// 2. 锁的范围缩小</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;<span class="comment">// 3. 二次判空</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适用场景：</p>
<ul>
<li><strong>单例模式</strong>：延迟初始化全局唯一的对象。</li>
<li><strong>高并发资源初始化</strong>：如数据库连接池、线程池等。</li>
<li><strong>框架中的扩展点加载</strong>：如 Dubbo 的 <code>ExtensionLoader</code> 按需加载扩展类。</li>
</ul>
<h2 id="双重校验锁-与类解耦"><a href="#双重校验锁-与类解耦" class="headerlink" title="双重校验锁 (与类解耦)"></a><u>双重校验锁 (与类解耦)</u></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> T instance;</span><br><span class="line">    <span class="keyword">private</span> Supplier&lt;T&gt; supplier;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Holder</span><span class="params">(Supplier&lt;T&gt; supplier)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.supplier = supplier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = supplier.get();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变种</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> T instance;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span>&#123;</span><br><span class="line">        instance = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">// 在外部实现</span></span><br></pre></td></tr></table></figure>



<h2 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举 enum"></a><u><strong>枚举 enum</strong></u></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>天然线程安全，并且能够防止反射攻击</p>
<h2 id="Holder-静态内部类-（利用类加载机制）"><a href="#Holder-静态内部类-（利用类加载机制）" class="headerlink" title="Holder 静态内部类 （利用类加载机制）"></a><u><strong>Holder 静态内部类 （利用类加载机制）</strong></u></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Holder 在 Singleton 加载时并不会被加载，只有第一次调用 <code>getInstance()</code> 才会加载 Holder，然后创建单例。</p>
<h2 id="CAS-自旋"><a href="#CAS-自旋" class="headerlink" title="CAS 自旋"></a>CAS 自旋</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReference&lt;Singleton&gt; instance = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Singleton</span> <span class="variable">current</span> <span class="operator">=</span> instance.get();</span><br><span class="line">            <span class="keyword">if</span> (current != <span class="literal">null</span>) <span class="keyword">return</span> current;</span><br><span class="line">            current = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">if</span> (instance.compareAndSet(<span class="literal">null</span>, current)) &#123; <span class="comment">// 期望值为 null，设置值为 current</span></span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>无锁，非阻塞，线程安全。实现较为复杂，追求极致性能才考虑</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/13/classfile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/13/classfile/" class="post-title-link" itemprop="url">ClassFile</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-13 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-13T00:00:00+08:00">2024-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 10:57:48" itemprop="dateModified" datetime="2025-04-27T10:57:48+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ClassFile-字节码"><a href="#ClassFile-字节码" class="headerlink" title="ClassFile 字节码"></a>ClassFile 字节码</h1><p>Java 字节码是 Java 编译器将 Java 源代码编译成的 <strong>中间表示格式</strong>，它运行在 <strong>Java 虚拟机（JVM）</strong> 上。Java 字节码文件的扩展名为 <code>.class</code>，可以通过 <code>javap -c</code> 命令查看其内容。</p>
<p>任何一个Class文件都对应着唯一的一个类或接口的定义信息[1]，但是反过来说，类或 接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。本章中， 笔者只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”，实际上它完全不 需要以磁盘文件的形式存在。</p>
<p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文 件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数 据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[2]的方式分割 成若干个8个字节进行存储。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/09/13/classfile/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/12/G1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/12/G1/" class="post-title-link" itemprop="url">G1 垃圾收集器介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-12 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-12T00:00:00+08:00">2024-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-26 13:48:31" itemprop="dateModified" datetime="2025-04-26T13:48:31+08:00">2025-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h1><p>之前根据 Sun 的内存管理白皮书介绍了在 HotSpot JVM 分代算法中的几个垃圾收集器，本文将介绍 G1 垃圾收集器。</p>
<p>G1 的主要关注点在于达到<strong>可控的停顿时间</strong>，在这个基础上尽可能提高吞吐量，这一点非常重要。</p>
<p>G1 被设计用来长期取代 CMS 收集器，和 CMS 相同的地方在于，它们都属于并发收集器，在大部分的收集阶段都不需要挂起应用程序。区别在于，G1 没有 CMS 的碎片化问题（或者说不那么严重），同时提供了更加可控的停顿时间。</p>
<p>如果你的应用使用了较大的堆（如 6GB 及以上）而且还要求有较低的垃圾收集停顿时间（如 0.5 秒），那么 G1 是你绝佳的选择，是时候放弃 CMS 了。</p>
<p><strong>阅读建议</strong>：本文力求用简单的话介绍清楚 G1 收集器，但是并不会重复介绍每一个细节，所以希望读者了解其他几个收集器的工作过程，尤其是 CMS 收集器。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/09/12/G1/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/11/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/11/JVM/" class="post-title-link" itemprop="url">JVM 介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-11 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-11T00:00:00+08:00">2024-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 11:25:06" itemprop="dateModified" datetime="2025-04-27T11:25:06+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JVM-是虚拟机吗？"><a href="#JVM-是虚拟机吗？" class="headerlink" title="JVM 是虚拟机吗？"></a>JVM 是虚拟机吗？</h1><h2 id="JVM-是什么？"><a href="#JVM-是什么？" class="headerlink" title="JVM 是什么？"></a>JVM 是什么？</h2><p><strong>Java Virtual Machine (JVM)</strong> 是 Java 平台的核心组件，它是一个**<mark>程序运行环境<mark>**，专门用来执行 Java 字节码（Bytecode）</p>
<p><strong>主要功能：</strong></p>
<ol>
<li><strong>跨平台支持</strong>：JVM 实现了 Java 的 “Write Once, Run Anywhere” 特性，使 Java 程序能够在不同操作系统上运行。</li>
<li>字节码解释和编译：JVM 将 Java 编译器生成的字节码（平台无关）转换为平台相关的机器代码，并执行。</li>
<li>内存管理：提供垃圾回收机制 (Garbage Collection, GC)。</li>
<li>安全性：内置安全检查机制，确保 Java 程序在受控环境中运行，防止恶意代码执行。</li>
</ol>
<h2 id="Hypervisor-VMM-是什么"><a href="#Hypervisor-VMM-是什么" class="headerlink" title="Hypervisor/VMM 是什么?"></a>Hypervisor/VMM 是什么?</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2560px-Hyperviseur.svg.png" alt="undefined"></p>
<p>Hypervisor 是一种一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件。也可叫做虚拟机监视器，即 VMM（ virtual machine monitor ）。</p>
<ul>
<li>当服务器启动并执行 Hypervisor 时，它会加载所有虚拟机客户端的操作系统同时会分配给每一台虚拟机适量的内存，CPU，网络和磁盘。它允许多个操作系统（称为<strong>Guest OS</strong>）在同一台物理机器（称为<strong>Host</strong>）上同时运行，每个操作系统被隔离在独立的虚拟机中。</li>
<li>Hypervisor 负责资源分配，如 CPU、内存和存储，协调着这些硬件资源的访问，而且在各个虚拟机之间施加防护，处理虚拟机之间的通信和安全隔离。</li>
</ul>
<h2 id="JVM-与-Hypervisor-VMM-的对比"><a href="#JVM-与-Hypervisor-VMM-的对比" class="headerlink" title="JVM 与 Hypervisor/VMM 的对比"></a>JVM 与 Hypervisor/VMM 的对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>JVM</th>
<th>Hypervisor/VMM</th>
</tr>
</thead>
<tbody><tr>
<td><strong>用途</strong></td>
<td>运行 Java 程序的虚拟环境</td>
<td>管理和运行多个虚拟机，每个虚拟机可运行不同操作系统</td>
</tr>
<tr>
<td><strong>虚拟化层级</strong></td>
<td>应用程序级虚拟化（针对 Java 字节码）</td>
<td>操作系统级虚拟化（针对硬件资源）</td>
</tr>
<tr>
<td><strong>管理对象</strong></td>
<td><strong>Java 字节码执行环境</strong></td>
<td>虚拟机管理和<strong>硬件资源虚拟化</strong></td>
</tr>
<tr>
<td><strong>依赖性</strong></td>
<td>必须安装在操作系统上，依赖操作系统环境</td>
<td>Type 1 可以直接运行在硬件上，Type 2 依赖操作系统</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>程序之间隔离性较弱，依赖 JVM 的安全机制</td>
<td>每个虚拟机互相独立，硬件级别隔离</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td>Oracle HotSpot VM、OpenJDK JVM</td>
<td>VMware ESXi、VirtualBox、KVM、Hyper-V</td>
</tr>
</tbody></table>
<ol>
<li>在 VMware ESXi 上创建一个虚拟机；</li>
<li>在虚拟机内部运行一个 Guest OS，比如 Linux；</li>
<li>在 Linux 中安装 Java 环境并运行 JVM。</li>
</ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/09/11/JVM/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/09/web-frontend/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/09/web-frontend/" class="post-title-link" itemprop="url">Web 前端</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-09 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-09T00:00:00+08:00">2024-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 13:58:40" itemprop="dateModified" datetime="2025-04-27T13:58:40+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web-development/" itemprop="url" rel="index"><span itemprop="name">web development</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p><strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage </p>
<p>结构：HTML</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/html/html-tutorial.html">HTML 教程 | 菜鸟教程 (runoob.com)</a> </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTML">HTML - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">HTML（超文本标记语言） | MDN (mozilla.org)</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926154402465.png" alt="image-20240926154402465"></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="基础标签"><a href="#基础标签" class="headerlink" title="基础标签"></a>基础标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926165557803.png" alt="image-20240926165557803"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926170603004.png" alt="image-20240926170603004"></p>
<h3 id="图片，音视频标签"><a href="#图片，音视频标签" class="headerlink" title="图片，音视频标签"></a>图片，音视频标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926170628097.png" alt="image-20240926170628097"></p>
<p>height weight 有 px 和百分比两种写法 src路径</p>
<p>URL 统一资源定位符 ../ 代表上一级目录 </p>
<h3 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926171504599.png" alt="image-20240926171504599"></p>
<p>a href=”url” </p>
<h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926171804215.png" alt="image-20240926171804215"></p>
<h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926171833199.png" alt="image-20240926171833199"></p>
<p>边框宽度+空白区间宽度</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926172249995.png" alt="image-20240926172249995"></p>
<h3 id="布局标签"><a href="#布局标签" class="headerlink" title="布局标签"></a>布局标签</h3><div></div>


<p>div块级标签，占一整行</p>
<p>span 只占据自己的空间</p>
<h3 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926193335810.png" alt="image-20240926193335810"></p>
<p>提交表单：方式get/post </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926193711640.png" alt="image-20240926193711640"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926194217797.png" alt="image-20240926194217797"></p>
<p><strong>点击框外文本就能让框处于被选中的状态</strong>：</p>
<p>如果要随着表单一起提交，就要起一个name</p>
<p>用<strong>label</strong>标签把用户名包裹起来，给输入框起一个唯一的id, label for “id” </p>
<p><strong>radio</strong>：单选按钮，让其name相同达到互斥效果，给他赋值value让服务器接收到有效信息</p>
<p>hidden 修改商品信息，id隐藏在表单里面,提交表单会上传</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928193146331.png" alt="image-20240928193146331"></p>
<p>submit reset button 如果要指定按钮名字 value</p>
<select>
    <option>123</option>
     <option>4567</option>
</select>


<p>textarea cols支持的列数 rows支持的行数</p>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>表现：CSS</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/css/css-tutorial.html">CSS 教程 | 菜鸟教程 (runoob.com)</a> </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CSS">CSS - 维基百科，自由的百科全书 (wikipedia.org) </a> </p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS：层叠样式表 | MDN (mozilla.org)</a></p>
<h2 id="导入HTML"><a href="#导入HTML" class="headerlink" title="导入HTML"></a>导入HTML</h2><p>在head标签中导入</p>
<p>内联，内部，外部</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926201958367.png" alt="image-20240926201958367"></p>
<p><code>&lt;link href=&quot;css路径&quot; rel=&quot;stylesheet&quot;&gt;</code></p>
<h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926202419738.png" alt="image-20240926202419738"></p>
<p>name唯一 class不唯一</p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>行为：javascript</p>
<p>什么是JS？</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/js/js-tutorial.html">JavaScript 教程 | 菜鸟教程 (runoob.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript">JavaScript——动态客户端脚本语言 - 学习 Web 开发 | MDN (mozilla.org)</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926202813408.png" alt="image-20240926202813408"></p>
<p>改变HTML 交互性</p>
<p>引入方式：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929131050714.png" alt="image-20240929131050714"></p>
<p>内部脚本,一般放在body下面</p>
<p>外部脚本, 不支持自闭合</p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul>
<li>区分大小写，分号可有可无</li>
<li>单行，多行注释</li>
<li>大括号表示代码块</li>
</ul>
<h3 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h3><ul>
<li>(window.)alert()弹出警告</li>
<li>document.write() 写入HTML页面</li>
<li>console.log() 写入浏览器控制台</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>var是变量，弱类型语言，可以存放不同类型的值</p>
<p>作用域：全局变量而且可以重复声明定义</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929132314244.png" alt="image-20240929132314244"></p>
<p>let 作用域只在代码块之内 局部变量 不可重复定义</p>
<p>const 常量</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929132717037.png" alt="image-20240929132717037"></p>
<p>number boolean string 空（null）默认初始值（undefined）</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929132954368.png" alt="image-20240929132954368"></p>
<p>全等于(===) 类型不一样返回false，更加严格</p>
<p>等于（==）判断类型是否一样，如果不一样则转换类型，然后才比较值</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>转为number：</p>
<ul>
<li>string<ul>
<li><code>var str = &quot;20&quot;   parseInt(str)</code></li>
<li>字面值转为数字，如果字面值不是数字，转为NaN</li>
</ul>
</li>
<li>boolean <ul>
<li>true-&gt;1 false-&gt;0</li>
</ul>
</li>
</ul>
<p>转成boolean</p>
<ul>
<li>number： 0和NaN转为false</li>
<li>string：空字符串转为false</li>
<li>null&amp;undefined：转为false</li>
</ul>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>if  switch  while  do while  </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929135023368.png" alt="image-20240929135023368"></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>关键字：function</li>
<li>返回值类型：不需要，直接return</li>
<li>参数列表：不用写参数类型</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929135258270.png" alt="image-20240929135258270"></p>
<p>实际调用可以有很多实参，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929135611640.png" alt="image-20240929135611640"></p>
<p>add(1,2) = 3</p>
<p>add(1)  = NaN</p>
<h2 id="JavaScript-对象"><a href="#JavaScript-对象" class="headerlink" title="JavaScript 对象"></a>JavaScript 对象</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">//访问数组</span></span><br><span class="line">arr1[<span class="number">1</span>]=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>与java不同，js的数组是集合，变长，变类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变长</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr3[<span class="number">5</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//索引为5的元素被赋值为10, 中间空出来的是undefined</span></span><br><span class="line"><span class="comment">//变类型</span></span><br><span class="line">arr3[<span class="number">10</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>长度：length</p>
<p>增：push(10) 加入值为10的元素</p>
<p>删：splice(0,3)从索引0开始，删除3个元素</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>length:长度</p>
<p>trim(): 去除字符串两端的空白字符</p>
<p>charAt(i):返回指定位置的字符</p>
<p>indexOf(c) 返回字符第一次出现的索引</p>
<h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;ZS&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">23</span>,</span><br><span class="line">    <span class="attr">eat</span>:<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;eat&quot;</span>+a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">eat</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>浏览器对象模型</p>
<p>Navigator Screen</p>
<h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><ul>
<li>窗口对象，使用window获取</li>
<li><code>alert()</code> 警告</li>
<li><code>confirm(&quot;对话框内容&quot;)</code> 确认/取消对话框<ul>
<li>有返回值，返回的是一个boolean</li>
</ul>
</li>
<li><code>setInterval(function,ms)</code> 定时器，循环执行function</li>
<li><code>setTimeout(function,ms)</code> 倒计时，只有一次</li>
</ul>
<p>根据变化的数字，产生固定个数的值，取模</p>
<h5 id="history"><a href="#history" class="headerlink" title="history"></a>history</h5><ul>
<li><p>通过window调取，window可省略</p>
</li>
<li><p><code>history.back()</code>加载前一个URL</p>
</li>
<li><p><code>history.forward()</code>加载下一个URL</p>
</li>
</ul>
<h5 id="location"><a href="#location" class="headerlink" title="location"></a>location</h5><ul>
<li>通过window调取，可省略</li>
<li><code>location.href</code> 设置当前的URL，可以实现跳转</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929143103867.png" alt="image-20240929143103867"></p>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>文档对象模型 W3C指定的XML HTML的规则</p>
<p>查文档</p>
<h4 id="document"><a href="#document" class="headerlink" title="document"></a>document</h4><h5 id="获取Element"><a href="#获取Element" class="headerlink" title="获取Element"></a>获取Element</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929143507450.png" alt="image-20240929143507450"></p>
<ul>
<li>id: 每个元素唯一的id</li>
<li>tagName: 标签名</li>
<li>class: 同类的，一个元素可以有多个类，一个类可以有多个元素</li>
<li>name: 用于radio checkbox 和 form表单 提交将输入的值发送</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;submit.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">value</span>=<span class="string">&quot;apple&quot;</span>&gt;</span> Apple</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">value</span>=<span class="string">&quot;banana&quot;</span>&gt;</span> Banana</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">value</span>=<span class="string">&quot;orange&quot;</span>&gt;</span> Orange</span><br></pre></td></tr></table></figure>

<h5 id="element通用方法"><a href="#element通用方法" class="headerlink" title="element通用方法"></a>element通用方法</h5><ul>
<li><p>element.<strong>style</strong> 获取style标签</p>
<ul>
<li>element.style.color = “red” 设置元素的style中 color属性为red</li>
<li></li>
</ul>
</li>
<li><p>element.<strong>innerHTML</strong> 改变两个标签内部的文本内容</p>
</li>
</ul>
<p>checkbox.<strong>checked</strong>=true 复选框设置为勾选  </p>
<h2 id="事件监听-EventListener"><a href="#事件监听-EventListener" class="headerlink" title="事件监听 EventListener"></a>事件监听 EventListener</h2><p>事件：发生在HTML元素上的事件，比如按钮被电击，鼠标移到元素之上，按下键盘按键</p>
<p>监听：侦测到事件，执行某些代码</p>
<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><h4 id="HTML标签的属性绑定"><a href="#HTML标签的属性绑定" class="headerlink" title="HTML标签的属性绑定"></a>HTML标签的属性绑定</h4><p>耦合度太高</p>
<h4 id="DOM元素属性绑定"><a href="#DOM元素属性绑定" class="headerlink" title="DOM元素属性绑定"></a>DOM元素属性绑定</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929145651893.png" alt="image-20240929145651893"></p>
<p>属性和函数绑定</p>
<h3 id="常见的事件"><a href="#常见的事件" class="headerlink" title="常见的事件"></a>常见的事件</h3><p><code>onblur</code>: 失去焦点</p>
<p><code>onfocus</code>: 获得焦点</p>
<p><code>onchange</code>:文本改变</p>
<p><code>onkeydown</code>: 按键</p>
<p><code>onmouseover</code>: 鼠标移动到指定对象上</p>
<p><code>onmouseout</code>：鼠标离开指定对象</p>
<p><code>onsubmit</code>: 表单验证，绑定的函数要有返回值，如果返回true则表单会被提交</p>
<p>核心宗旨：把一些交互逻辑更多地放到浏览器这边，减少服务端的压力</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929152143546.png" alt="image-20240929152143546"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929153455050.png" alt="image-20240929153455050"></p>
<p>绑定函数和事件</p>
<h1 id="Regex"><a href="#Regex" class="headerlink" title="Regex"></a>Regex</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/regexp/regexp-tutorial.html">正则表达式 – 教程 | 菜鸟教程 (runoob.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://regex101.com/">regex101: build, test, and debug regex</a> </p>
<p><strong>正则表达式（Regular Expression, regex）</strong>是一种用来描述和匹配字符串模式的工具，其原理基于形式语言和自动机理论。以下是正则表达式的主要原理和工作机制：</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ol>
<li><strong>字符匹配</strong>：正则表达式中的普通字符（如 <code>a</code>, <code>b</code>, <code>1</code>, <code>2</code>）直接匹配自身。例如，正则表达式 <code>abc</code> 将匹配字符串 “abc”。</li>
<li><strong>元字符和转义</strong>：元字符（如 <code>.</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>|</code>、<code>()</code>、<code>[]</code>、<code>&#123;&#125;</code>）有特殊含义。若要匹配这些字符本身，需要使用转义字符 <code>\</code>。例如，<code>\.</code> 匹配字符 <code>.</code>。</li>
<li><strong>字符类</strong>：使用方括号 <code>[]</code> 定义字符类，可以匹配其中任意一个字符。例如，<code>[abc]</code> 匹配 <code>a</code>、<code>b</code> 或 <code>c</code>。</li>
<li><strong>预定义字符类</strong>：常见的预定义字符类包括 <code>\d</code>（数字），<code>\w</code>（字母、数字或下划线），<code>\s</code>（空白字符），等价于 <code>[0-9]</code>、<code>[a-zA-Z0-9_]</code>、<code>[ \t\n\r\f\v]</code>。</li>
<li><strong>量词</strong>：量词用来指定匹配次数。例如，<code>*</code>（0 次或多次），<code>+</code>（1 次或多次），<code>?</code>（0 次或 1 次），<code>&#123;n&#125;</code>（恰好 n 次），<code>&#123;n,&#125;</code>（至少 n 次），<code>&#123;n,m&#125;</code>（n 到 m 次）。</li>
<li><strong>边界匹配</strong>：边界匹配符包括 <code>^</code>（行首），<code>$</code>（行尾），<code>\b</code>（单词边界），<code>\B</code>（非单词边界）。</li>
<li><strong>分组和捕获</strong>：使用圆括号 <code>()</code> 将正则表达式的一部分进行分组，可以进行捕获以便后续引用。例如，<code>(\d&#123;3&#125;)-(\d&#123;3&#125;)</code> 匹配 “123-456” 并捕获 “123” 和 “456”。</li>
<li><strong>选择和替代</strong>：使用管道符 <code>|</code> 表示选择，匹配左边或右边的表达式。例如，<code>a|b</code> 匹配 <code>a</code> 或 <code>b</code>。</li>
</ol>
<h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><ol>
<li><strong>编译</strong>：正则表达式首先被编译成一种内部表示形式。这个编译过程将解析正则表达式字符串，并将其转换为一个有限状态自动机（Finite State Machine, FSM）。</li>
<li><strong>匹配过程</strong>：<ul>
<li><strong>DFA（确定性有限自动机）</strong>：DFA 每个状态都有确定的转换，即每一个输入字符都会导致状态的唯一确定转换。DFA 的匹配过程效率高，但状态数可能较多。</li>
<li><strong>NFA（非确定性有限自动机）</strong>：NFA 允许从一个状态可以有多条转换边，匹配过程可能需要回溯。NFA 的构建比较简单，但匹配过程效率可能较低。</li>
</ul>
</li>
<li><strong>引擎</strong>：<ul>
<li><strong>NFA 引擎</strong>：基于回溯算法，尝试每一种可能的路径，直到找到匹配或失败。大多数现代正则表达式引擎（如 Perl、Python、JavaScript 等）使用 NFA 引擎。</li>
<li><strong>DFA 引擎</strong>：不使用回溯，直接通过状态转换进行匹配，通常速度较快，但实现较为复杂且内存消耗较大。</li>
</ul>
</li>
</ol>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li><strong>字符串查找和替换</strong>：在文本编辑器、IDE 等工具中，通过正则表达式进行复杂的搜索和替换操作。</li>
<li><strong>数据验证</strong>：验证输入数据的格式，如邮箱地址、电话号码等。</li>
<li><strong>文本处理</strong>：如日志解析、数据抽取等。</li>
</ul>
<p>通过对正则表达式的理解和应用，可以高效地进行字符串处理和模式匹配，极大地提高文本处理的灵活性和效率。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929153836955-1727921863704-1.png" alt="image-20240929153836955"></p>
<p>JS 正则表达式对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;^\\w&#123;6,12&#125;$&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^\w&#123;6,12&#125;$/</span></span><br><span class="line"></span><br><span class="line">regex.<span class="title function_">test</span>(str) <span class="comment">//正则表达式</span></span><br></pre></td></tr></table></figure>



<ul>
<li><code>\d</code>: 数字</li>
<li><code>\D</code>: 除了数字以外的字符</li>
<li><code>\s</code>:空白字符</li>
<li><code>\w</code>:字母+下划线+数字</li>
<li><code>[ ]</code>匹配单个字符 字符集合</li>
<li><code>[^1-3A-Z]</code>匹配一个除了1-3和大写字母的字符</li>
<li>尖角^只有在方框内部才是取反的意思。在外部表示匹配开头，<code>^abc</code>表示作为开头的abc，<code>BCD$</code>就是作为结尾的BCD<ul>
<li>匹配总共需要三个参数：要处理的字符串，匹配模式和正则表达式本身，可以看出处理的文本本身就是一个字符串。</li>
<li>如果没有多行匹配，^和$只会作用于<strong>整个文本</strong>的开头和结尾</li>
<li>multiline模式会匹配每一行</li>
</ul>
</li>
<li><code>/...../g</code>表示不要搜索一次就返回，去掉只显示第一个匹配的</li>
<li><code>/...../m</code>表示多行匹配</li>
<li><code>/...../i</code>表示忽略大小写</li>
<li><code>\b</code>:表示单词边界 <code>\bin</code>表示in在单词开头 <code>in\b</code>表示in在单词末尾</li>
<li><code>\B</code>:表示单词内部 <code>\Bin\B</code>表示in在单词中间 <code>\Bin</code>表示匹配前面有东西的in</li>
<li><code>.$</code>表示属于结尾的任意字符</li>
<li><code>\.$</code>表示属于结尾的点号</li>
</ul>
<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><ul>
<li><code>at+</code> atttt atttt 加号表示a t(重复一次或者多次)</li>
<li><code>at*</code> atttt atttt 星号表示a t(重复0次或者多次)</li>
<li><code>at?</code> at a 问号表示零次或者一次</li>
<li><code>at&#123;3,5&#125;</code> attt 表示t重复了3到5次</li>
<li><code>at&#123;3,&#125;</code> attt 表示t重复了3次以上 </li>
</ul>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul>
<li><code>(at)&#123;3&#125;</code> at整体重复了3次</li>
<li><code>(P|p)iece</code> Piece和piece</li>
<li><code>(d&#123;4&#125;)[-/_.](d&#123;1,2&#125;)[-/_.](d&#123;1,2&#125;)</code> 匹配年月日并且分成三组$1$2$3分别代表123组可以使用替换</li>
<li>如果不想分其中一个组<code>?:</code>表示仅代表一个整体不参与分组</li>
</ul>
<p>在 Java 的正则表达式中，如果你想忽略大小写匹配，可以使用以下几种方法：</p>
<h2 id="Java中忽略大小写的使用"><a href="#Java中忽略大小写的使用" class="headerlink" title="Java中忽略大小写的使用"></a>Java中忽略大小写的使用</h2><h3 id="使用-Pattern-CASE-INSENSITIVE-标志"><a href="#使用-Pattern-CASE-INSENSITIVE-标志" class="headerlink" title="使用 Pattern.CASE_INSENSITIVE 标志"></a>使用 <code>Pattern.CASE_INSENSITIVE</code> 标志</h3><p>通过调用 <code>Pattern.compile</code> 方法并传递 <code>Pattern.CASE_INSENSITIVE</code> 标志，可以忽略大小写。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译正则表达式时指定忽略大小写</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex, Pattern.CASE_INSENSITIVE);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(text);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-i-内联标志"><a href="#使用-i-内联标志" class="headerlink" title="使用 (?i) 内联标志"></a>使用 <code>(?i)</code> 内联标志</h3><p>在正则表达式的开头加上 <code>(?i)</code> 也可以忽略大小写。这是内联标志，不需要使用 <code>Pattern.compile</code>。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;(?i)hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (text.matches(regex)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>Pattern.CASE_INSENSITIVE</code></strong> 标志是在编译正则表达式时通过代码设置忽略大小写。</li>
<li><strong><code>(?i)</code></strong> 是在正则表达式内部直接指定忽略大小写，简单方便。</li>
</ul>
<h1 id="AJAX-JSON-个人笔记-Java-Web-服务端-pdf"><a href="#AJAX-JSON-个人笔记-Java-Web-服务端-pdf" class="headerlink" title="[AJAX, JSON](./个人笔记/Java Web 服务端.pdf)"></a>[AJAX, JSON](./个人笔记/Java Web 服务端.pdf)</h1><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/">Vue.js - 渐进式 JavaScript 框架 | Vue.js (vuejs.org)</a></p>
<h2 id="优点、原理"><a href="#优点、原理" class="headerlink" title="优点、原理"></a>优点、原理</h2><ul>
<li>免除DOM操作，简化书写</li>
<li>基于MVVM思想，双向绑定数据，使view能够绑定model的数据，而不是model变了</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929223353641.png" alt="image-20240929223353641"></p>
<p>model: plain JavaScript Objects     view: 模板</p>
<p>model，也就是数据，通过vue实例绑定到view上，model一更新，view上也会立即更新，</p>
<p>view，模板，通过vue实例的domListener，监听发生的dom事件，比如输入，通过listener将model处的数据实时更新。</p>
<p>数据全存在vm上，view能看到vm所有的数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929231110532.png" alt="image-20240929231110532"></p>
<p>在之前的JSON案例中，填写表单时，表单数据是model，<strong>在提交的时候</strong>，还要用<strong>繁琐的dom操作</strong>获取输入框中的值再赋给model。vue能在输入的时候就赋值给对象，如果从服务器接收到数据也能实时更新。</p>
<h2 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h2><p><a href=".%5C%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%5CHTML%5Cindex.html">index.html</a></p>
<p><strong>Vue3</strong> </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hello-vue&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>//div元素 唯一id为hello-vue 归属于demo类</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span>//v-model双向绑定,这个view中的值是多少, vue实例中数据就是多少</span><br><span class="line">&#123;&#123; message &#125;&#125;//插值表达式。这是 Vue.js 的模板语法，用于将 Vue 实例中的数据绑定到页面上。</span><br><span class="line">			 //vue实例中的数据变化时,这里也跟着变化。</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">HelloVueApp</span>=&#123; <span class="comment">//此处创建了一个自定义JS对象</span></span></span><br><span class="line"><span class="language-javascript">	<span class="title function_">data</span>(<span class="params"></span>)&#123;<span class="comment">//data是一个无参的函数,返回值是一个对象，里面包含了model数据</span></span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">message</span>: <span class="string">&#x27;Hello,Vue!&#x27;</span><span class="comment">//数据初值是Hello,Vue!字符串</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">	&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">HelloVueApp</span>).<span class="title function_">mount</span>(<span class="string">&quot;#hello-vue&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="comment">//Vue.createApp() 方法用于创建一个 Vue 应用实例，参数是一个包含组件选项的对象（这里是 HelloVueApp）。</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//.mount(&#x27;#hello-vue&#x27;) 方法将 Vue 应用实例挂载到页面中具有 id=&quot;hello-vue&quot; 的 DOM 元素上。</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令是带有前缀 <strong>v-</strong> 的特殊属性，用于在模板中表达逻辑。</p>
<p><strong>v-bind</strong>: 动态绑定一个或多个特性，或一个组件 prop。将 Vue 实例的数据绑定到 HTML 元素的属性上</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>简写：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-if</strong>: 条件渲染。根据表达式的值来条件性地渲染元素或组件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;seen&quot;</span>&gt;</span>Now you see me<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-for</strong>: 列表渲染。 用于根据数组或对象的属性值来循环渲染元素或组件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.text &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">//v-for=迭代对象 相当于增强for循环 </span><br><span class="line">//key帮助 Vue 在渲染列表时识别每个元素的唯一性。</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">HelloVueApp</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">items</span>: [ <span class="comment">//items数组包含多个匿名对象，这些匿名对象id和text两个属性</span></span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;Item 1&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&#x27;Item 2&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">text</span>: <span class="string">&#x27;Item 3&#x27;</span> &#125;</span></span><br><span class="line"><span class="language-javascript">      ]</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">HelloVueApp</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-model</strong>: 实现表单数据双向绑定：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;edit me&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-on</strong>: 事件监听器。 用于在 HTML 元素上绑定事件监听器，使其能够触发 Vue 实例中的方法或函数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>简写：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-show</strong>: 用于根据表达式的值来条件性地显示或隐藏元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hello-vue&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;showMessage = !showMessage&quot;</span>&gt;</span>显示/隐藏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">&quot;showMessage&quot;</span>&gt;</span>Hello Vue!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">HelloVueApp</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">showMessage</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">HelloVueApp</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#hello-vue&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>v-on指令能够监听事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">v-<span class="attr">on</span>:click=<span class="string">&quot;methodName&quot;</span></span><br><span class="line">@click=<span class="string">&quot;methodName&quot;</span></span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;counter += 1&quot;</span>&gt;</span>增加 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> app = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">counter</span>: <span class="number">0</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(app).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="案例简化-JavaScript中的this指针与回调函数"><a href="#案例简化-JavaScript中的this指针与回调函数" class="headerlink" title="案例简化-JavaScript中的this指针与回调函数"></a>案例简化-JavaScript中的this指针与回调函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//script</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">VueApp</span> = &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="attr">brands</span>:[]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">        axios.<span class="title function_">get</span>(<span class="string">&quot;http://localhost:8080/selectAllServlet&quot;</span>)</span><br><span class="line">         .<span class="title function_">then</span>(<span class="function">(<span class="params">resp</span>)=&gt;</span>&#123;<span class="variable language_">this</span>.<span class="property">brands</span> = resp.<span class="property">data</span>;&#125;);</span><br><span class="line">        <span class="comment">//brands是集合,用v-for遍历</span></span><br><span class="line">        <span class="comment">//回调函数是作为参数传递给另一个函数的函数，目的是在特定事件或条件发生时被调用。它通常用于异步操作、事件处理和在特定时机执行代码。箭头函数不会根据调用者创建this，只会寻找域中含有的this指针，mounted的this就是Vue实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">    	<span class="attr">show</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&quot;clicked&quot;</span>);<span class="comment">//跟提交的按钮绑定</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">createVueApp</span>(<span class="title class_">VueApp</span>).<span class="title function_">mount</span>(#app)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href=".%5C%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%5CHTML%5CanoymousThis.html">JavaScript中的this指针</a> 另外一种是在mounted中先定义一个var _this = this，这样_this 一定指代的是Vue实例</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>单个复选框：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checked&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>多个复选框：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;runoob&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Runoob&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;runoob&quot;</span>&gt;</span>Runoob<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;google&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Google&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;google&quot;</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;taobao&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Taobao&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;taobao&quot;</span>&gt;</span>taobao<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>选择的值为: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> app = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      checked : <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">checkedNames</span>: []</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(app).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h1><p><a target="_blank" rel="noopener" href="https://element.eleme.cn/#/zh-CN">Element - 网站快速成型工具</a></p>
<p>Vue组件库，可以快速构建网页</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930212139910.png" alt="image-20240930212139910"></p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930224145033.png" alt="image-20240930224145033"></p>
<h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930224317166.png" alt="image-20240930224317166"></p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930224538591.png" alt="image-20240930224538591"></p>
<p>对话框+表单</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/05/web-backend/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/05/web-backend/" class="post-title-link" itemprop="url">Web 后端 Java</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-05 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-05T00:00:00+08:00">2024-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 14:13:09" itemprop="dateModified" datetime="2025-04-27T14:13:09+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web-development/" itemprop="url" rel="index"><span itemprop="name">web development</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p><strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol </p>
<p>TCPIP协议四层架构的最上层 规定了服务器和浏览器之间传输数据的规则</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP">HTTP | MDN (mozilla.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">超文本传输协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>基于TCP，面向连接，安全</li>
<li>基于请求-响应模型：1Request 1Response</li>
<li>HTTP是无状态协议，对事务处理没有记忆能力，每次RR都是独立的<ul>
<li>多次请求之间不能共享数据，java用会话技术（cookie session）解决这个问题</li>
<li>优点：速度快</li>
</ul>
</li>
</ul>
<h2 id="请求数据格式"><a href="#请求数据格式" class="headerlink" title="请求数据格式"></a><a href="#request">请求数据格式</a></h2><p><strong>请求行</strong>：第一行，<code>GET</code>(请求方式) 后面的<code>/</code>表示请求资源的路径，HTTP/1.1表示协议版本</p>
<p><strong>请求头</strong>：第二行开始 key: value形式</p>
<p><strong>请求体</strong>：POST请求的最后一部分，存放请求参数</p>
<p>GET请求参数在请求行中，没有请求体，参数大小有限制(URL长度限制) POST请求的参数在请求体中，参数大小无限制</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926220614547.png" alt="image-20240926220614547"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926221417729.png" alt="image-20240926221417729"></p>
<p><strong>Host</strong>: 请求的主机名</p>
<p><strong>User-Agent</strong>: 浏览器版本</p>
<p><strong>Accept</strong>: 浏览器能接受的资源类型，如text/* image/* */* </p>
<p><strong>Accept-Language</strong>: 浏览器的偏好语言</p>
<p><strong>Accept-Encoding</strong>: 浏览器支持的压缩类型</p>
<h2 id="响应数据格式"><a href="#响应数据格式" class="headerlink" title="响应数据格式"></a>响应数据格式</h2><p><strong>响应行</strong>：响应数据的第一行，HTTP/1.1表示协议版本，下一个是响应状态码，OK表示状态码描述</p>
<p><strong>响应头</strong>：keyvalue</p>
<p><strong>响应体</strong>：最后一部分，存放响应数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926221630980.png" alt="image-20240926221630980"></p>
<p><strong>Content-Type</strong>：响应内容类型，比如text/html image/jpeg</p>
<p><strong>Content-Length</strong>：响应内容长度（bytes）</p>
<p><strong>Content-Encoding</strong>：响应压缩算法 gzip等</p>
<p><strong>Cache-Control</strong>: 指示客户端如何缓存，例如max-age=300 表示最多缓存300s</p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926222005460.png" alt="image-20240926222005460"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926222320894.png" alt="image-20240926222320894"></p>
<p>200 OK 404资源不存在 500 服务器异常</p>
<p>Java程序中，如果直接用自带的javawebsocketAPI 代码会变得异常繁琐，要注意请求和响应的格式要求，因此要用web服务器软件进行开发—-Tomcat</p>
<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>Apache Tomcat web服务器是一个应用程序，封装http协议，不用对协议进行直接操作。类似的还有jetty，weblogic，ibm webSphere，部署web项目到服务器中</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61596145">JavaEE的13种核心技术规范： - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://tomcat.apache.org/">Apache Tomcat® - Welcome!</a> </p>
<h2 id="创建Web项目"><a href="#创建Web项目" class="headerlink" title="创建Web项目"></a>创建Web项目</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927151450747.png" alt="image-20240927151450747"></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Web-&gt;META-INF()</span><br><span class="line">     WEB-INF -&gt;classes(java文件夹和resources文件夹合并)</span><br><span class="line">     	     -&gt;lib(依赖jar包)</span><br><span class="line">             -&gt;web.xml(web项目的配置文件)</span><br><span class="line">     webapp中除了WEB-INF的其他文件</span><br></pre></td></tr></table></figure>



<p>using 骨架</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927151529348.png" alt="image-20240927151529348"></p>
<p>packaging 默认jar 改成web项目用的war </p>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>动态资源web开发技术</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927162801770.png" alt="image-20240927162801770"></p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927163054997.png" alt="image-20240927163054997"></p>
<p>servlet对象，service方法由web服务器tomcat创建</p>
<p>WebServlet继承了Servlet接口</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927174147654.png" alt="image-20240927174147654"></p>
<ol>
<li>默认情况 servlet对象第一次被访问就被创建，通过改变loadOnStartup参数可以改变优先级</li>
<li>容器（tomcat）通过init方法初始化对象，只需要调用一次</li>
<li>每次请求servlet 容器都会调用servlet的service方法</li>
</ol>
<h2 id="Servlet-接口"><a href="#Servlet-接口" class="headerlink" title="Servlet 接口"></a>Servlet 接口</h2><p>定义了五个抽象方法：</p>
<ol>
<li><p><code>init(ServletConfig conf)</code>：默认情况下，servlet第一次被访问，容器创建servlet对象时，会调用init，只调用一次。改变WebServlet注解的参数loadOnStartup，可以控制在创建服务器的时候就创建servlet对象。</p>
</li>
<li><p><code>service(ServletRequest req,ServletResponse res)</code>: 每一次访问servlet就调用一次</p>
</li>
<li><p><code>destroy()</code>: 内存释放、服务器关闭时调用，只有一次</p>
</li>
<li><p><code>ServletConfig getServletConfig()</code>: servletconfig是容器调用init方法传进来的参数,可以在demo类中声明一个config成员变量，在init中赋值，然后在getConfig方法中返回</p>
</li>
<li><p><code>String getServletInfo() </code>: copyright information</p>
</li>
</ol>
<h2 id="Servlet-体系"><a href="#Servlet-体系" class="headerlink" title="Servlet 体系"></a>Servlet 体系</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927180225035.png" alt="image-20240927180225035"></p>
<p>Http doGet doPost</p>
<p>根据请求方式的不同分别处理，因为get的参数在请求行中，post的参数在请求体中。</p>
<p>httpservlet是servlet的实现类，实际上把service方法重写，接收请求参数req，如果req中是get方式，就执行doGet，如果是post就执行doPost  子类只需要重写doGetdoPost方法即可</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927181319844.png" alt="image-20240927181319844"></p>
<p>源码分析：原来的service方法重载，参数变成httpservletrequest和httpservletresponse ，原版的请求参数传进来，强制转换成httpservletrequest，然后吊用自己写好的重载service方法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927181753064.png" alt="image-20240927181753064"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927181825881.png" alt="image-20240927181825881"></p>
<h2 id="urlPattern"><a href="#urlPattern" class="headerlink" title="urlPattern"></a>urlPattern</h2><h3 id="一个servlet可以配置多个访问路径"><a href="#一个servlet可以配置多个访问路径" class="headerlink" title="一个servlet可以配置多个访问路径"></a>一个servlet可以配置多个访问路径</h3><p>urlPatterns = {“”,””}</p>
<h3 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927183113407.png" alt="image-20240927183113407"></p>
<ol>
<li>精确匹配 （优先级比目录匹配高）</li>
<li>目录匹配，通配符</li>
<li>扩展名匹配，<code>*.do</code> <code>aaa.do bbb.do</code>都可以访问，注意不能有斜杠</li>
<li>任意匹配，<code>/</code>优先级低于<code>/*</code><ul>
<li>/是tomcat默认生成的一个servlet，启动以后自动创建，是用来访问静态资源的</li>
<li>很危险，不要用</li>
</ul>
</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927183710215.png" alt="image-20240927183710215"></p>
<h3 id="web-xml配置"><a href="#web-xml配置" class="headerlink" title="web.xml配置"></a>web.xml配置</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927183912074.png" alt="image-20240927183912074"></p>
<h1 id="Request-amp-Response"><a href="#Request-amp-Response" class="headerlink" title="Request&amp;Response"></a>Request&amp;Response</h1><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927184223066.png" alt="image-20240927184223066"></p>
<p>request 获取请求数据</p>
<p>response 设置响应时的数据</p>
<p>request中含有用户输入的参数，response可以根据这个参数设置响应的数据，这样就完成了和用户交互的基本过程</p>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><h3 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927184637027.png" alt="image-20240927184637027"></p>
<p>ServletRequest和HttpServletRequest都是接口，不能实例化，定义了一些抽象方法作为规范。</p>
<p>我们的 servlet 重写了 service()方法的方法体，浏览器访问时，tomcat就要调用servlet的service方法。tomcat作为servlet容器，<strong>要解析请求报文，将其封装成req对象</strong>，送到servlet的service方法处作为参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是tomcat的程序</span></span><br><span class="line"><span class="comment">//tomcat做的是解析报文封装请求的操作，具体如何利用请求做出什么样的响应，则是开发者的工作</span></span><br><span class="line"><span class="type">MyServlet</span> <span class="variable">myServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyServlet</span>();</span><br><span class="line">myServlet.init()<span class="comment">//开发者重写</span></span><br><span class="line">myServlet.service(req,res)<span class="comment">//开发者重写</span></span><br></pre></td></tr></table></figure>

<p>所以Tomcat对接口进行了实现，查J2EE API</p>
<h3 id="获取请求数据"><a href="#获取请求数据" class="headerlink" title="获取请求数据"></a>获取请求数据</h3><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927192106826.png" alt="image-20240927192106826"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927192310996.png" alt="image-20240927192310996"></p>
<h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927192340229.png" alt="image-20240927192340229"></p>
<p>getHeader根据name来获取对应的信息</p>
<p>getHeader(“User-Agent”) 输出Mozilla/5.0 Chrome/91.0.4472.106</p>
<h4 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927192426370.png" alt="image-20240927192426370"></p>
<p>统一获取请求参数的方式？从而统一doGet和doPost方法内的代码</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927195026912.png" alt="image-20240927195026912"></p>
<p>getParameterMap 获取参数map 结构如上</p>
<p>getParameter 根据名称获取参数值</p>
<p>getParameterValues 根据名称获取参数值</p>
<h4 id="获取参数中文乱码"><a href="#获取参数中文乱码" class="headerlink" title="获取参数中文乱码"></a>获取参数中文乱码</h4><h5 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h5><p>设置输入流的字符集</p>
<p>底层是获取字符输入流BufferReader，所以<code>setCharacterEncoding(&quot;UTF-8&quot;)</code></p>
<h5 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h5><p>底层是字符串形式</p>
<p>浏览器发出请求的时候，会把中文字符转成URL编码，tomcat需要进行URL解码</p>
<h5 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h5><p>字符串按照编码方式转为二进制，每个字节转换为两个十六进制数，在前面加上%                                            </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927214608765.png" alt="image-20240927214608765"></p>
<p>Tomcat底层将URL编码 解码为ISO-8859-1</p>
<h3 id="Forward-请求转发"><a href="#Forward-请求转发" class="headerlink" title="Forward 请求转发"></a>Forward 请求转发</h3><p>服务器内部资源跳转方式，转发的资源之间共享数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928140710653.png" alt="image-20240928140710653"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928140736371.png" alt="image-20240928140736371"></p>
<p>请求内部有参数（map形式），来源URL等信息</p>
<ul>
<li><code>setAttribute(String name, Object o)</code>把数据o 存到request域中，以key为键    </li>
<li><code>removeAttribute(String name)</code> 根据key删除键值对</li>
<li><code>Object getAttribute(String name)</code>根据key获取数据</li>
</ul>
<ul>
<li>地址栏路径不发生变化；</li>
<li>只能转发到服务器内部的资源；</li>
<li>浏览器发送一次请求，多个资源共享request数据</li>
<li>高效率</li>
</ul>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928142749615.png" alt="image-20240928142749615"></p>
<h3 id="设置响应数据"><a href="#设置响应数据" class="headerlink" title="设置响应数据"></a>设置响应数据</h3><ol>
<li>响应行：设置状态码</li>
<li>响应头：设置键值对</li>
<li>响应体：通过输出流输出数据</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928142944677.png" alt="image-20240928142944677"></p>
<h3 id="Redirect-重定向"><a href="#Redirect-重定向" class="headerlink" title="Redirect 重定向"></a>Redirect 重定向</h3><p>资源跳转方式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928143039892.png" alt="image-20240928143039892"></p>
<p>状态码 <strong>302</strong> 响应头：location: 虚拟目录/demo6</p>
<p><code>sendRedirect(String url)</code>发送重定向响应</p>
<p><code>setStatus(302)</code> </p>
<p><code>setHeader(&quot;location&quot;,&quot;https://www.google.com&quot;)</code> </p>
<p><code>setHeader(&quot;Content-type&quot;,&quot;text/html&quot;)</code> </p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>地址栏路径发生变化；</li>
<li>转发任意资源；</li>
<li>浏览器发送两次请求，不能在多个资源用request共享数据</li>
<li>效率低</li>
</ul>
<h4 id="路径问题-动态获取虚拟目录"><a href="#路径问题-动态获取虚拟目录" class="headerlink" title="路径问题 动态获取虚拟目录"></a>路径问题 动态获取虚拟目录</h4><p>如果浏览器使用，需要加虚拟目录</p>
<p>服务端使用就不需要加了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928145151848.png" alt="image-20240928145151848"></p>
<p>虚拟目录可以动态变化，所以尽量减少硬编码，减少耦合性</p>
<p>可以用<code>request</code>的<code>getContextPath()</code> 获取虚拟目录</p>
<h3 id="设置响应数据-1"><a href="#设置响应数据-1" class="headerlink" title="设置响应数据"></a>设置响应数据</h3><h4 id="字符数据"><a href="#字符数据" class="headerlink" title="字符数据"></a>字符数据</h4><p><code>getWriter().write(String s) </code>写入数据到资源中</p>
<p><code>setContentType(&quot;text/html;charset=utf-8&quot;)</code>   </p>
<p>细节：不用关闭流</p>
<p>乱码可以用响应头设置编码，tomcat8不乱码</p>
<h4 id="字节数据"><a href="#字节数据" class="headerlink" title="字节数据"></a>字节数据</h4><p>ServletOutputStream = request.getOutputStream()</p>
<h2 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h2><p>用来创建与数据库的连接会话,只需要一个即可，所以运用单例的设计模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryUtils</span>&#123;</span><br><span class="line">    SqlSessionFactory factory;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">    SqlSessionFactory <span class="title function_">getSqlSessionFactory</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h2 id="入门-1"><a href="#入门-1" class="headerlink" title="入门"></a>入门</h2><p>Java Server Pages 静态的页面嵌入动态的代码 简化开发</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928175143005.png" alt="image-20240928175143005"></p>
<p>JSP本质是servlet，把写标签等繁琐的工作交给jsp技术</p>
<h3 id="JSP脚本"><a href="#JSP脚本" class="headerlink" title="JSP脚本"></a>JSP脚本</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928175642020.png" alt="image-20240928175642020"></p>
<ol>
<li><p>service方法是访问到这个资源的时候调用</p>
</li>
<li><p>out.print() 是printWriter 调用的</p>
</li>
<li><p>被生成的jsp类直接包含</p>
</li>
</ol>
<p>截断java代码，中间插入html标签是可以的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928180319108.png" alt="image-20240928180319108"></p>
<p>出现HTML标签的地方可以理解为java程序代替你输入这些标签，最简单的字面意义上的代替功能，因此截断也没什么关系</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928180738621.png" alt="image-20240928180738621"></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928180843640.png" alt="image-20240928180843640"></p>
<h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928181558853.png" alt="image-20240928181558853"></p>
<h2 id="JSTL-标签库"><a href="#JSTL-标签库" class="headerlink" title="JSTL 标签库"></a>JSTL 标签库</h2><p><mark><strong>#{}</strong><mark></p>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928182101658.png" alt="image-20240928182101658"></p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928182210315.png" alt="image-20240928182210315"></p>
<p>brand.id 不是访问成员变量，是要调用get方法</p>
<p>自动调用getId()</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928182800258.png" alt="image-20240928182800258"></p>
<p>varStatus 计数器</p>
<p>status.count是计数从1开始，status.index是从1开始</p>
<h4 id="普通for循环"><a href="#普通for循环" class="headerlink" title="普通for循环"></a>普通for循环</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928183033816.png" alt="image-20240928183033816"></p>
<p>Java虚拟机负责存储变量信息，jsp只负责展示与变量相关的信息，因此不用重启服务器，</p>
<h2 id="Servlet-JSP开发"><a href="#Servlet-JSP开发" class="headerlink" title="Servlet+JSP开发"></a>Servlet+JSP开发</h2><p><strong>业务逻辑层</strong>本质上是对dao层的封装，包括创建session，创建mapper，mapper调用dao方法，事务等。</p>
<p>每个servlet都是资源，浏览器能够通过网址或者表单的形式发出请求，servlet根据request的参数进行一系列业务逻辑操作，将返回的结果转发给jsp页面。</p>
<p>jsp本质也是一个servlet，将请求中的参数打印出来的同时还能生成html标签，浏览器就能通过html标签解析出网页。</p>
<p>在修改页面改了一个数据，提交表单到updateServlet，updateServlet进行业务操作，完成后，把包含参数的请求转发到 浏览所有数据 的showAll.jsp页面，jsp本质是servlet，负责打印标签和数据。</p>
<h1 id="MVC-设计模式"><a href="#MVC-设计模式" class="headerlink" title="MVC 设计模式"></a>MVC 设计模式</h1><p><strong>Model</strong>：接受Controller发出的指令，与数据库交互，增删改查，返回数据给Controller</p>
<p><strong>View</strong>：接受Controller发出的数据（Model给的）渲染页面，返回HTML页面给Controller</p>
<p><strong>Controller</strong>：接受客户端的数据请求，返回给客户端HTML页面，同时与model和view交流，充当Model和View之间的桥梁。</p>
<p>Model和View之间一个是处理数据，一个是呈现数据，二者可以专注于各自的事情</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240919202449018-1727923726251-1.png" alt="image-20240919202449018"></p>
<p>Servlet controller </p>
<p>JSP View </p>
<p>JavaBean Model </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928183538077-1727923726251-2.png" alt="image-20240928183538077"></p>
<p>三层架构</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928183903472-1727923726251-3.png" alt="image-20240928183903472"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928183924963-1727923726251-4.png" alt="image-20240928183924963"></p>
<h1 id="Cookie-amp-Session-amp-JWT"><a href="#Cookie-amp-Session-amp-JWT" class="headerlink" title="Cookie&amp;Session&amp;JWT"></a>Cookie&amp;Session&amp;JWT</h1><h2 id="会话跟踪技术"><a href="#会话跟踪技术" class="headerlink" title="会话跟踪技术"></a>会话跟踪技术</h2><p>浏览器打开一个网站就是会话建立的过程，其中可以<strong>包含多次请求和响应</strong>，服务段需要区分不同的会话，判断多次请求是否来自统一浏览器，以便在同一次会话的<strong>多次请求之间，共享数据。</strong></p>
<p><strong>HTTP协议是无状态</strong>的，为了最佳的请求响应效率，牺牲了存储记忆数据的功能，每次请求都被视作新的请求，因此要跟踪回话实现会话内数据共享。</p>
<p>本质是将数据存储在一端</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928201532521.png" alt="image-20240928201532521"></p>
<p>客户端：<strong>Cookie</strong> </p>
<p>服务端：<strong>Session</strong> </p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>客户端的会话技术，保存数据到客户端，每次请求都携带cookie数据进行访问。客户端的记忆</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928202227465.png" alt="image-20240928202227465"></p>
<p>响应的时候setcookie，请求的时候带着cookie</p>
<h3 id="发送cookie"><a href="#发送cookie" class="headerlink" title="发送cookie"></a>发送cookie</h3><p>创建Cookie，设置键值对</p>
<p>response调用addCookie方法发送cookie</p>
<h3 id="获取cookie"><a href="#获取cookie" class="headerlink" title="获取cookie"></a>获取cookie</h3><p>request对象调用getCookies 接收cookies</p>
<p>for循环遍历，getName和getValue</p>
<h2 id="cookie的原理"><a href="#cookie的原理" class="headerlink" title="cookie的原理"></a>cookie的原理</h2><p><strong>基于HTTP协议</strong></p>
<p>响应的时候，做好cookie传回去，<strong>响应头</strong>setCookie:username=zs</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928204006874.png" alt="image-20240928204006874"></p>
<p>浏览器再次请求的时候，<strong>请求头</strong>中cookie:username=zs</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928204020606.png" alt="image-20240928204020606"></p>
<h3 id="cookie使用细节"><a href="#cookie使用细节" class="headerlink" title="cookie使用细节"></a>cookie使用细节</h3><h4 id="存活时间"><a href="#存活时间" class="headerlink" title="存活时间"></a>存活时间</h4><p><strong>默认</strong>存储在浏览器内存中，关闭浏览器会释放内存，销毁cookie</p>
<p>setMaxAge(int seconds) 正数：写入浏览器硬盘，到时间自动删除；负数：写入内存，自动销毁；零：删除对应cookie</p>
<p>30天内免登录</p>
<p>cookie是键值对 </p>
<h4 id="cookie存储中文"><a href="#cookie存储中文" class="headerlink" title="cookie存储中文"></a>cookie存储中文</h4><p>可以把字符串用URL编码</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928205018701.png" alt="image-20240928205018701"></p>
<p>服务端的记忆功能</p>
<p>request.getSession();</p>
<p>set Attribute 存到session域中</p>
<p>get Attribute</p>
<p>session是键值对集合，存储在服务器</p>
<p><strong>Session基于Cookie实现</strong> </p>
<p>如何保证多个浏览器不是同一个session？发送一个sessionID的cookie，作为唯一标识，浏览器请求的时候会带着cookie。响应的时候创建一个session，把浏览器唯一对应的session对象id作为cookie发过去，再次请求的时候带着sessionid作为cookie就能找到对应的session对象去存储</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928210309806.png" alt="image-20240928210309806"></p>
<p>识别sessionid如果已经创建过了就不再创建</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928210431476.png" alt="image-20240928210431476"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928210448553.png" alt="image-20240928210448553"></p>
<h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><h4 id="session-钝化、活化"><a href="#session-钝化、活化" class="headerlink" title="session 钝化、活化"></a>session 钝化、活化</h4><p>钝化：服务器正常关闭，tomcat自动把session存到硬盘</p>
<p>活化：服务器开启，从session文件读取</p>
<p>浏览器关闭后中断会话，session不是同一个</p>
<h4 id="session-销毁"><a href="#session-销毁" class="headerlink" title="session 销毁"></a>session 销毁</h4><ul>
<li>自动销毁web.xml sessionconfig 时间默认为30分钟</li>
<li>手动销毁：登出</li>
</ul>
<h2 id="Cookie-vs-Session"><a href="#Cookie-vs-Session" class="headerlink" title="Cookie vs. Session"></a>Cookie vs. Session</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928220229036.png" alt="image-20240928220229036"></p>
<p>安全性，长期存储</p>
<p>cookie保证用户在未登录情况下的身份识别</p>
<p>session存储用户登录以后的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928225946421.png" alt="image-20240928225946421"></p>
<h3 id="登录系统DEMO"><a href="#登录系统DEMO" class="headerlink" title="登录系统DEMO:"></a>登录系统DEMO:</h3><p>login.jsp页面</p>
<p>登录成功存储用户信息，并且要重定向到另一个brand.jsp页面，两次会话共享信息，考虑安全性，session</p>
<p>登录失败，转发回登录页面，把错误 信息加进request域中，jsp登录页面显示的是错误信息</p>
<p>记住用户登录信息：登录成功并且勾选了复选框（发送复选框的value参数，Object.equals或是”1”.equals（remember））创建username和password的cookie并发送到浏览器。修改login.jsp：拿到请求中的cookies，分别把响应的数据填到页面的username和password中。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928223745507.png" alt="image-20240928223745507"></p>
<h3 id="用户注册DEMO"><a href="#用户注册DEMO" class="headerlink" title="用户注册DEMO:"></a>用户注册DEMO:</h3><p>reg.jsp </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928223916558.png" alt="image-20240928223916558"></p>
<p>if(布尔表达式){</p>
<p>}</p>
<p>return 布尔表达式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928231442349.png" alt="image-20240928231442349"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928231455396.png" alt="image-20240928231455396"></p>
<p>展示验证码：servlet输出的验证码作为img src显示在HTML静态页面上，写js脚本把点击事件设置成重新请求一次，每次请求的路径不同 (?号后面加时间)，防止浏览器缓存</p>
<p>生成验证码和提交注册表单一共需要两次请求，是不同的servlet在处理，所以服务器要在生成的时候将验证码存到session中，提交注册表单的时候再次从session中访问数据看是否一致。存到cookie中会直接被抓取然后攻击，失去了验证码的功能</p>
<p>if else if直接return就不用else了</p>
<p>checkcodeServlet 生成code，输出到自己的输出流中  </p>
<h2 id="Token-Json-Web-Token"><a href="#Token-Json-Web-Token" class="headerlink" title="Token(Json Web Token)"></a>Token(<u>J</u>son <u>W</u>eb <u>T</u>oken)</h2><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/995894#comment">JWT详细讲解(保姆级教程)-阿里云开发者社区 (aliyun.com)</a></p>
<h3 id="token-cookie-session"><a href="#token-cookie-session" class="headerlink" title="token cookie session"></a>token cookie session</h3><h4 id="Cookie-1"><a href="#Cookie-1" class="headerlink" title="Cookie"></a>Cookie</h4><p>本质是键值对，客户端发起请求，服务端响应会把包含着用户信息的set-cookie 加入响应头，客户端收到set-cookie，下次发送请求，请求头中会带着包含相同内容的cookie，服务端只需要根据cookie响应对应用户的资源。</p>
<p>局限：数据直接存放在浏览器端内存，安全性差，</p>
<p>优化：把set-cookie内容除了正常的cookie内容再加一段报文鉴别码，使用服务器自己的私钥进行签名，</p>
<p>优点：存储期限长</p>
<h4 id="Session-1"><a href="#Session-1" class="headerlink" title="Session"></a>Session</h4><p>以cookie为基础，本质是一个对象，每个session可以通过唯一的sessionID进行访问，客户端发起请求，服务端会把包含着sessionID信息的set-cookie响应给客户端，客户端下次发送请求，请求头中会带着包含着sessionID信息的cookie，服务端根据sessionID找到对应的session，响应对应用户的资源</p>
<p>优点：数据完全存储在服务端内存，安全性很高，</p>
<p>缺点：</p>
<p>最重要的是，session只支持单体服务器，session拷贝效率低，</p>
<p>默认不支持跨域名，但是不同域名可能是会共享用户信息的，</p>
<p>因此在集群部署，分布式应用，前后端分离的背景下，session已经不再适用</p>
<h4 id="JsonWebToken"><a href="#JsonWebToken" class="headerlink" title="JsonWebToken"></a>JsonWebToken</h4><p>base64: 将原来的字符串二进制化，然后重新分成每6位一组，6位对应有64个索引，分别对应0-9和所有大小写英文字母</p>
<p>用户信息保存在浏览器端内存，本质就是一条加密字符串。</p>
<h5 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h5><p>RSA—单向陷门函数：加密数字5，公钥是7,33 ，<strong>5</strong>^7^ mod 33 = <mark>14<mark>，解密使用公钥，x^7^ mod 33 = <mark>14<mark> 的数字有无数个，也就无法推算出具体的x，只能穷举。如果有了私钥3,33，<mark>14<mark>^3^ mod 33 = <strong>5</strong> 很容易就能算出原数字5</p>
<p>加密和解密都用同一种算法，但不是逆向。</p>
<p><strong>签名算法：</strong> </p>
<p>HS256：$A+H(A,K)$ 签发和验证都使用同一个密钥，只适用于单体应用。H表示密钥拼接在报文后进行哈希。S表示SHA256</p>
<p>RS256, ES256：$A+D(H(A))$ 签发用私钥，验证用公钥，适合分布式架构，安全性更高。R,E分别表示RSA与ECDSA，S表示SHA256。</p>
<h5 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h5><p>header(base64-encoded).payload(base64-encoded).signature(HMACSHA256-encoded)</p>
<ul>
<li>header 用于定义token类型以及加密算法（非对称），用base64编码，相当于明文</li>
<li>payload 用于装载要传输的用户数据，用base64编码，相当于明文<ul>
<li>附加一些预定义声明</li>
<li>iss: 签发者issuer</li>
<li>sub: jwt所面向的用户subject</li>
<li>aud: 接收jwt的一方audience</li>
<li>iat: jwt的签发时间 issued at</li>
<li>exp: jwt的过期时间，必须大于签发时间  expire</li>
<li>nbf: 定义在什么时间之前，该jwt都是不可用的. not valid before</li>
<li>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击 jwtid</li>
</ul>
</li>
</ul>
<p><code>注意:对于已签名的Token，这些信息虽然受到保护，不会被篡改，但任何人都可以阅读。除非加密，否则不要将机密信息放在 JWT 的有效负载或头元素中。</code> </p>
<ul>
<li>signature = HS256…(header(base64)+payload(base64)+secret)私钥 ，用header指定的算法进行加密，鉴权核心</li>
</ul>
<p>用户请求通过鉴权成功，<strong>服务端通过私钥签发JWT字符串</strong>，通过响应返回给用户，用户后续请求会在请求头中添加一个authorization:token的键值对。</p>
<p>再次请求，鉴权成功，然后将JWT根据secret进行解密，验证此JWT是否有效。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241030152447734.png" alt="image-20241030152447734"></p>
<p>假如其他人偶然间拿到了JWT，然后篡改JWT，服务器拿私钥解密JWT，会发现信息被篡改。</p>
<h1 id="Filter-amp-Listener"><a href="#Filter-amp-Listener" class="headerlink" title="Filter&amp;Listener"></a>Filter&amp;Listener</h1><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>拦截资源请求</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928234937677.png" alt="image-20240928234937677"></p>
<h3 id="入门-2"><a href="#入门-2" class="headerlink" title="入门"></a>入门</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928235049041.png" alt="image-20240928235049041"></p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929000311150.png" alt="image-20240929000311150"></p>
<p>先访问完资源，然后执行放行后的逻辑</p>
<p>放行前对request进行处理，放行后对response进行处理</p>
<h3 id="使用细节-1"><a href="#使用细节-1" class="headerlink" title="使用细节"></a>使用细节</h3><h4 id="拦截路径"><a href="#拦截路径" class="headerlink" title="拦截路径"></a>拦截路径</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929000603427.png" alt="image-20240929000603427"></p>
<p>拦截的是具体的资源，不是说filter访问哪个路径</p>
<h4 id="Filter链"><a href="#Filter链" class="headerlink" title="Filter链"></a>Filter链</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929000822547.png" alt="image-20240929000822547"></p>
<p>执行顺序：类名字符串自然排序</p>
<h4 id="案例：登录验证才可以访问"><a href="#案例：登录验证才可以访问" class="headerlink" title="案例：登录验证才可以访问"></a>案例：登录验证才可以访问</h4><p>第一次请求，没有登录，跳转到登录页面</p>
<p>filter要看是否登录，登录成功就把username pswd存到客户端session中，下一次请求的时候就验证session是否有值，没有值就继续</p>
<p>从服务端获取用户的session，session存储登录密码，如果session</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929011626311.png" alt="image-20240929011626311"></p>
<p>针对某个资源设置filter，第一次访问被拒绝，<strong>转发</strong>到login页面，此时网址不会变化，就会把这个资源的网址缓存成login页面的样式，login成功以后如果再次访问这个资源，会展示login页面，只有刷新一下才能解决这个问题</p>
<h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929121700747.png" alt="image-20240929121700747"></p>
<h1 id="HTML-CSS-JavaScript-Java-Web-前端-md"><a href="#HTML-CSS-JavaScript-Java-Web-前端-md" class="headerlink" title="[HTML+CSS+JavaScript](.\Java Web 前端.md)"></a>[HTML+CSS+JavaScript](.\Java Web 前端.md)</h1><h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a><span id=ajax>AJAX</span></h1><p>异步JS和XML <strong>A</strong>synchronous <strong>J</strong>avaScript <strong>A</strong>nd <strong>X</strong>ML </p>
<p><strong>AJAX作用1：与服务器交换数据，前后端分离</strong></p>
<ul>
<li>Servlet+JSP开发：HTML是静态的，要想展示动态的数据必须要让servlet根据请求中的参数来手动打印页面（JSP），服务端负担较重</li>
<li>AJAX+HTML: 替换JSP页面 ，AJAX给服务器<strong>发送请求</strong>，<strong>获取服务器响应</strong>的数据，展示给浏览器</li>
</ul>
<p><strong>AJAX作用2：异步交互</strong></p>
<p>不刷新<strong>整个页</strong>面也能与服务器交换数据，更新部分网页，如搜索联想，用户名是否可用校验</p>
<p>用户名按照一定的规则：直接本地编写js脚本即可，如果用户名不能和已有的重复，还应该发送请求，接收服务器响应回来的结果（数据库中是否重名）</p>
<h2 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929161209624.png" alt="image-20240929161209624"></p>
<p>异步操作使 用户可以在等待响应的同时继续与页面互动，这使得应用程序更具响应性</p>
<p>不用刷新整个页面，只跟服务器请求需要的数据，而不是整个页面，AJAX可以减少服务器的负担和网络流量，提高响应速度。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929161455819.png" alt="image-20240929161455819"></p>
<p>URL 全路径，前后端完全分离</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929161832460.png" alt="image-20240929161832460"></p>
<h2 id="异步请求案例"><a href="#异步请求案例" class="headerlink" title="异步请求案例"></a><span id="request">异步请求案例</span></h2><p>现在有这样一个需求，在浏览器填完了一个用户名，要把用户名发送到服务器的某个servlet，servlet根据用户名查询是否重复，并把数据传回到浏览器。</p>
<p>首先应该让失焦事件绑定函数，函数中要查询用户名。</p>
<p>设置 提示重复字句的style属性为不可见（正常情况下不可见）ajax根据传回的数据为true or false，改变 提示重复字句的style属性，如果是，则设置可见，如果否，则设置不可见。</p>
<p>具体流程？可以通过以下步骤：</p>
<h2 id="前端发送请求"><a href="#前端发送请求" class="headerlink" title="前端发送请求"></a>前端发送请求</h2><p>使用 JavaScript（比如 <code>XMLHttpRequest</code> 或 Fetch API）发送请求：</p>
<ul>
<li><strong>GET 方法</strong>（URL 参数字符串）：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>).<span class="property">value</span>;</span><br><span class="line">xhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://example.com/checkUsername?username=&quot;</span> + <span class="built_in">encodeURIComponent</span>(username));</span><br><span class="line">xhttp.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>POST 方法</strong>（请求体）：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>).<span class="property">value</span>;</span><br><span class="line">xhttp.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;http://example.com/checkUsername&quot;</span>);</span><br><span class="line">xhttp.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">xhttp.<span class="title function_">send</span>(<span class="string">&quot;username=&quot;</span> + <span class="built_in">encodeURIComponent</span>(username));</span><br></pre></td></tr></table></figure>

<h3 id="服务器端处理"><a href="#服务器端处理" class="headerlink" title="服务器端处理"></a>服务器端处理</h3><p>在 Servlet 中处理请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="comment">// 查询数据库检查用户名是否重复</span></span><br><span class="line">    <span class="comment">// 返回结果到浏览器</span></span><br><span class="line">    response.setPatameter...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    doGet(request,response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h3><ul>
<li><strong>GET</strong>：参数通过 URL 传递，适合获取数据，但不适合传递敏感信息，因为 URL 可见，且请求长度有限。</li>
<li><strong>POST</strong>：参数通过请求体传递，适合发送大量数据或敏感信息。</li>
</ul>
<p>要探究本质，就要解析他们的**<mark>报文<mark>**  </p>
<p>GET：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /search?query=java&amp;page=2 HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>POST：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /search HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">?query=java&amp;page=2 </span><br></pre></td></tr></table></figure>

<p>这些都是一个个字符串而已，发送的时候设置URL和参数本质上都是拼字符串，然后把整段报文发给服务。Servlet 接收请求，解析报文，拿到参数，仅此而已。填写表单的时候也一样，form标签的action属性就是要发送请求的目标，输入参数，提交的时候，就相当于填写好了目标URL，既然目标确定了。浏览器会解析内容，写好报文，发送给目标，那么浏览器是如何确定要发送给谁呢？浏览器确定请求的目标地址（即请求的 URL）是通过 URL 来实现的。以下是这一过程的基本步骤：以GET请求为例：</p>
<h3 id="目标URL的填写"><a href="#目标URL的填写" class="headerlink" title="目标URL的填写"></a>目标URL的填写</h3><p>用户在浏览器中提交表单（例如，点击“提交”按钮），这会触发一个请求。表单的 <code>action</code> 属性指定了要发送请求的 URL。浏览器会将表单数据编码为查询字符串，并附加到 <code>action</code> URL 后面作为要访问的目标。</p>
<h3 id="解析-URL"><a href="#解析-URL" class="headerlink" title="解析 URL"></a>解析 URL</h3><p>浏览器解析这个 URL，分解成几个部分：</p>
<ul>
<li><strong>协议</strong>：<code>http</code></li>
<li><strong>主机名</strong>：<code>www.example.com</code></li>
<li><strong>路径</strong>：<code>/search</code></li>
<li><strong>查询字符串</strong>：<code>?query=java</code></li>
</ul>
<h3 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h3><p>浏览器会通过 DNS（域名系统）将主机名转换为相应的 IP 地址，以便找到目标服务器。例如，<code>www.example.com</code> 可能会被解析为 <code>192.0.2.1</code>。</p>
<h3 id="建立-TCP-连接"><a href="#建立-TCP-连接" class="headerlink" title="建立 TCP 连接"></a>建立 TCP 连接</h3><p>浏览器与目标服务器建立 TCP 连接，通常使用 HTTP 端口（默认为 80，HTTPS 为 443）。</p>
<h3 id="构造请求报文"><a href="#构造请求报文" class="headerlink" title="构造请求报文"></a>构造请求报文</h3><p>一旦连接建立，浏览器会根据表单数据构造 HTTP 请求报文，包括请求行、请求头和请求体。</p>
<h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>浏览器通过已建立的 TCP 连接，将构造好的请求报文发送到服务器的指定 IP 地址。</p>
<h3 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h3><p>服务器接收到请求后，会根据请求的路径和参数来处理请求，最终返回相应的响应数据。</p>
<p>发出请求实际上就是浏览器访问目标URL</p>
<p>表单：action就是目标URL，如果是get请求，浏览器会将目标url加上参数。随后解析url，得出目标IP，根据这些参数生成请求报文发送到目标IP。</p>
<h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>axios是对js 的封装</p>
<p><a target="_blank" rel="noopener" href="https://www.axios-http.cn/">Axios中文文档 | Axios中文网 (axios-http.cn)</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929192249373.png" alt="image-20240929192249373"></p>
<p>method url data</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929192732304.png" alt="image-20240929192732304"></p>
<p>链式编程</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(url).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">resp</span>)&#123;</span><br><span class="line">    <span class="comment">//具体用响应干什么？</span></span><br><span class="line">&#125;)</span><br><span class="line">axios.<span class="title function_">post</span>(url,data).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">resp</span>)&#123;</span><br><span class="line">    <span class="comment">//具体用响应干什么？</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>resp：</p>
<p>①data :实际响应回来的数据</p>
<p>②headers :响应头信息</p>
<p>③status :响应状态码</p>
<p>④statusText:响应状态信息</p>
<p>特色：自动将data对象序列化为json字符串，再自动将响应数据中的json转回js自定义对象</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929210844535.png" alt="image-20240929210844535"></p>
<p>解构赋值：then({data}) 只取resp的data字段</p>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p><strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation js对象表示法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929194822398.png" alt="image-20240929194822398"></p>
<p>字段名要用双引号括起来，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">    <span class="string">&quot;key1&quot;</span>:value1,</span><br><span class="line">    <span class="string">&quot;key2&quot;</span>:value2</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//json.key1 访问value1</span></span><br><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">    <span class="attr">key1</span>:value1,</span><br><span class="line">    <span class="attr">key2</span>:value2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这两个对象的主要区别在于属性名的引号使用。在第一个对象中，所有属性名都用双引号包围，而在第二个对象中，属性名没有引号。根据 JavaScript 的语法，属性名可以不加引号（如果是有效的标识符），但如果包含特殊字符或空格，就需要加引号。功能上，它们是等价的。</p>
<p>axios发送自定义对象会自动转成json的形式</p>
<h2 id="JSON数据和Java对象转换"><a href="#JSON数据和Java对象转换" class="headerlink" title="JSON数据和Java对象转换"></a>JSON数据和Java对象转换</h2><p>Fastjson 高性能JSON库。</p>
<p>导入fastjson坐标</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line"><span class="comment">//对象tostring</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> JSON.parseObject(user, User.class);</span><br><span class="line"><span class="comment">//解析出对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/json;charset=utf-8&quot;</span>);</span><br><span class="line">response.getWriter().write(jsonString)</span><br></pre></td></tr></table></figure>

<h2 id="案例：增删改查"><a href="#案例：增删改查" class="headerlink" title="案例：增删改查"></a>案例：增删改查</h2><p><strong>查询</strong>：把axios发送请求接收响应数据并打印数据的过程 封装成一个函数，跟onload（brandSelect页面加载完成）绑定。</p>
<p>axios+html 接收servlet响应，打印表格</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929200621197.png" alt="image-20240929200621197"></p>
<p>axios这边接收到json，也就是resp.data 是对象的集合，所以用for循环遍历，由于是打印，所以可以用id锚定表格的标签，每遍历一次就累加字符串一次，最后一起写入表格标签的innerHTML中。</p>
<p><strong>新增品牌</strong>：</p>
<p>表单提交的操作是一个同步请求，同步请求是直接发送参数字段，而且需要重新加载页面才能生效，利用不上js的异步高效性，所以提交按钮应该设置成普通button，进行异步操作</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929203719660.png" alt="image-20240929203719660"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929204058611.png" alt="image-20240929204058611"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929204235548.png" alt="image-20240929204235548"></p>
<p>获取表单数据，字符串直接赋值，复选框的结果用checked表示，因为这是两个复选框，名字都叫status，所以返回的是一个元素数组，对这个数组进行便利，被选中的就把自己的value赋给对象。</p>
<p>axios发送自定义对象会自动转成json的形式，直接把封装好的自定义对象添加到axios的data参数中即可</p>
<p>函数绑定提交按钮的onclick事件，设定js函数把表单填入的内容封装成json对象（即为前面的操作），发送ajax请求给addServlet。</p>
<p><strong>addServlet</strong>处，<u>getParameter不能接收json数据</u>，所以应该用<u>getReader.readLine读取字符串</u>，然后把json字符串转成pojo对象，执行添加操作，返回操作成功与否，作为响应数据发出。</p>
<p>axios接收响应数据，如果操作成功，就跳转到第一步做出来的加载html页面中</p>
<p>增删改用post 查用get </p>
<h1 id="Vue-Servlet-开发"><a href="#Vue-Servlet-开发" class="headerlink" title="Vue+Servlet 开发"></a>Vue+Servlet 开发</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul>
<li><strong>Vue</strong>：前端的JS骨架，model view双向绑定，渲染网页</li>
<li><strong>axios</strong>：AJAX请求发送</li>
<li><strong>Element</strong> <strong>UI</strong>：CSS组件库，基于Vue</li>
</ul>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ul>
<li><strong>Web层</strong>：Servlet调用Service层的方法查询，结果转为JSON，响应JSON数据发给客户端</li>
<li><strong>Service层</strong>：BrandService定义selectAll方法，获取sqlSession对象，调用BrandMapper执行SQL语句</li>
<li><strong>DAO层</strong>：BrandMapper定义selectAll方法，方法体为MyBatis执行某条具体的SQL语句</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002150928236.png" alt="image-20241002150928236"></p>
<h2 id="服务端优化"><a href="#服务端优化" class="headerlink" title="服务端优化"></a>服务端优化</h2><h3 id="Service-优化"><a href="#Service-优化" class="headerlink" title="Service 优化"></a>Service 优化</h3><h4 id="Service-接口定义"><a href="#Service-接口定义" class="headerlink" title="Service 接口定义"></a>Service 接口定义</h4><ul>
<li>定义 <strong>BrandService</strong> 接口：定义一些业务的抽象方法，实现类中实现业务方法，在servlet中创建好业务实现对象，这样就解除了service层和servlet层的耦合性</li>
</ul>
<h4 id="ServiceImpl-接口实现"><a href="#ServiceImpl-接口实现" class="headerlink" title="ServiceImpl 接口实现"></a>ServiceImpl 接口实现</h4><ul>
<li>在实现类中，先创建好唯一的的factory工厂，然后在方法中开启sqlSession，执行SQL语句</li>
</ul>
<h4 id="优化结果"><a href="#优化结果" class="headerlink" title="优化结果"></a>优化结果</h4><ul>
<li><strong>UserService:</strong></li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164617150.png" alt="image-20241002164617150"></li>
<li><strong>UserServiceImpl:</strong></li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164523529.png" alt="image-20241002164523529"></li>
</ul>
<h3 id="Servlet-优化"><a href="#Servlet-优化" class="headerlink" title="Servlet 优化"></a>Servlet 优化</h3><h4 id="业务实现类的创建"><a href="#业务实现类的创建" class="headerlink" title="业务实现类的创建"></a>业务实现类的创建</h4><p>为了增强项目的组织度，会进行业务整合，在BrandServlet中，创建一个BrandService的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BrandServlet</span>&#123;</span><br><span class="line">	<span class="type">BrandService</span> <span class="variable">brandService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrandServiceImpl1</span>();</span><br><span class="line">    <span class="comment">//调用service的方法</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="业务功能整合"><a href="#业务功能整合" class="headerlink" title="业务功能整合"></a>业务功能整合</h4><p>一个实体类的一个功能就要新创建一个Servlet，不易管理，要把一个实体类的所有功能都放在一个servlet中。（BrandServlet，UserServlet）通过/brand/*   /user/*来访问上述两个servlet。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002135939524.png" alt="image-20241002135939524"></p>
<ul>
<li>如图，原先<code>HttpServlet</code>的<code>service</code>方法根据请求的方式（<code>getMethod</code>）进行方法的分发（<code>doGe</code>t或<code>doPost</code>）</li>
<li>现在要根据请求的路径来进行方法的分发，因此<code>BrandServlet</code>不能直接继承<code>HttpServlet</code>，要创建一个<code>BaseServlet</code>继承<code>HttpServlet</code>，重写其<code>service</code>方法，根据路径分发方法。同理<code>UserServlet</code>也直接继承<code>Base</code></li>
<li>获取到请求路径的最后一部分（最后一个<code>/</code>之后的内容）就是请求的方法名</li>
<li>方法名称有了还要找<code>对应servlet</code>的字节码文件，<code>baseServlet</code>没有<code>@WebServlet</code>注解，也就不会直接访问了，到时候被访问的应该是<code>BrandServlet</code>和<code>UserServlet</code>这两个子类，子类继承父类的<code>service</code>方法，所以<code>service</code>方法中的<code>this.getClass</code>就能理所应当地拿到子类的字节码文件。</li>
<li>因为<code>BrandServlet</code>和<code>UserServlet </code>都是要先执行<code>service(req,resp)</code>方法，接收<code>request</code>参数和<code>response</code>参数，如果要执行具体的<code>selectAll</code>业务方法，就要在反射调用方法的时候把参数加上，同时在<code>子类servlet</code>中，业务方法接受的参数全部统一成<code>req</code>和<code>resp</code>。</li>
</ul>
<p>如此一来，就能实现：</p>
<ol>
<li>访问<code>/brand/selectAll</code>路径，</li>
<li>调用重写过后的<code>service(HttpServletRequest req,HttpServletResponse resp)</code> 能获取方法名和字节码文件</li>
<li>根据方法名和参数类型（<code>methodName, HttpServletRequest req.class, HttpServletResponse.class</code>）获取Method对象，</li>
<li><code>method.invoke(this, req, resp)</code>，实现业务整合</li>
</ol>
<h4 id="优化结果-1"><a href="#优化结果-1" class="headerlink" title="优化结果"></a>优化结果</h4><ul>
<li><strong>BaseServlet:</strong></li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164451103.png" alt="image-20241002164451103"></li>
<li><strong>UserServlet:</strong> </li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164355800.png" alt="image-20241002164355800"></li>
</ul>
<h3 id="优化后的后端结构"><a href="#优化后的后端结构" class="headerlink" title="优化后的后端结构"></a>优化后的后端结构</h3><p>后端的DAO, Service, Web层分开 各司其职，减少了耦合度</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164240142.png" alt="image-20241002164240142" style="zoom: 50%;" />



<h2 id="其他细节"><a href="#其他细节" class="headerlink" title=" 其他细节 "></a><span id="mybatis"> 其他细节 </span></h2><h3 id="MyBatis-模糊查询"><a href="#MyBatis-模糊查询" class="headerlink" title="MyBatis 模糊查询"></a>MyBatis 模糊查询</h3><h4 id="39-password-39-不行？-39-password-39-行？"><a href="#39-password-39-不行？-39-password-39-行？" class="headerlink" title="&#39;%#{password}%&#39;不行？&#39;%${password}%&#39;行？"></a><code>&#39;%#&#123;password&#125;%&#39;</code>不行？<code>&#39;%$&#123;password&#125;%&#39;</code>行？</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002225509824.png" alt="image-20241002225509824"></p>
<p>${password}就是最简单的文本替换，直接拼接字符串，也不会类型转换（输入参数<code>that</code>会直接拼接成<code>and password like that</code> 很显然少了引号）连SQL都无法注入<code>&#39; OR &#39;1&#39; = &#39;1</code> <code>and password like &#39; OR &#39;1&#39; = &#39;1</code> （语法错误）自然，模糊匹配就变成<code>&#39;%that%&#39;</code>了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002230031380.png" alt="image-20241002230031380"></p>
<p>预编译占位符#{password}会把整个password转换成字符串，输入参数<code>&#39; OR &#39;1&#39; = &#39;1</code>会帮你转义成<code>\&#39; OR \&#39;1\&#39; = \&#39;1</code> 还会贴心地给两边加上引号<code>and password like &#39;\&#39; OR \&#39;1\&#39; = \&#39;1&#39;</code></p>
<p>因此，#{password}本身就自带引号，模糊匹配会解析成<code>&#39;%&#39;that&#39;%&#39;</code> 完全的语法错误。</p>
<h4 id="应该怎么用"><a href="#应该怎么用" class="headerlink" title="应该怎么用"></a>应该怎么用</h4><p>既然返回的是带引号的字符串，可以用拼接字符串函数，也可以用空格把这三个字符串分开</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002231938685.png" alt="image-20241002231938685"></p>
<h3 id="MyBatis-分页查询"><a href="#MyBatis-分页查询" class="headerlink" title="MyBatis 分页查询"></a>MyBatis 分页查询</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002234502508.png" alt="image-20241002234502508"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003001119464.png" alt="image-20241003001119464"></p>
<h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><p>分页查询要两个参数，这一页从哪一行开始和每页显示的条数</p>
<p>前端传递给后台 当前页码和每页显示条数，(当前页码-1)*每行显示条数就是这一页开始的一行</p>
<p>PageBean封装 总条数 和 这一页的查询结果List&lt;User&gt; </p>
<p>list用于显示，总条数返回给前端</p>
<h4 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h4><p>前端刷新表格的操作：发出自己的两个属性，收到PageBean中的rows和totalCount</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003003901994.png" alt="image-20241003003901994"></p>
<p>前端点击页码的操作，设置自身的两个属性，同时刷新表格</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003004044018.png" alt="image-20241003004044018"></p>
<h3 id="插入重复的键——事务回滚"><a href="#插入重复的键——事务回滚" class="headerlink" title="插入重复的键——事务回滚"></a>插入重复的键——事务回滚</h3><p>username是unique 且 not null 的，所以不能重复，在提交表单的时候，如果输入重复数据，就会导致事务提交失败，这是就会出现异常，<strong>如果出现异常不处理</strong>，会一直导致故障。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003005454880.png" alt="image-20241003005454880"></p>
<p>使用try catch 如果出现异常，就调用rollback，同时return false，响应</p>
<p>前端收到响应，会根据结果弹出提示，成功或者失败</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003005659475.png" alt="image-20241003005659475"></p>
<h3 id="优化后的前端结构"><a href="#优化后的前端结构" class="headerlink" title="优化后的前端结构"></a>优化后的前端结构</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003004606856.png" alt="image-20241003004606856"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003004711700.png" alt="image-20241003004711700"></p>
<p>加入了表格loading动画，刷新按钮，以及删除和插入的结果提示</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/08/31/mp+lombok/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/31/mp+lombok/" class="post-title-link" itemprop="url">MyBatis-Plus</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-31 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-31T00:00:00+08:00">2024-08-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 15:47:45" itemprop="dateModified" datetime="2025-04-27T15:47:45+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web-development/" itemprop="url" rel="index"><span itemprop="name">web development</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>大家在日常开发中应该能发现，单表的CRUD功能代码重复度很高，也没有什么难度。而这部分代码量往往比较大，开发起来比较费时。</p>
<p>因此，目前企业中都会使用一些组件来简化或省略单表的CRUD开发工作。目前在国内使用较多的一个组件就是MybatisPlus.</p>
<p>当然，MybatisPlus不仅仅可以简化单表操作，而且还对Mybatis的功能有很多的增强。可以让我们的开发更加的简单，高效。</p>
<p>通过今天的学习，我们要达成下面的目标：</p>
<ul>
<li>能利用MybatisPlus实现基本的CRUD</li>
<li>会使用条件构建造器构建查询和更新语句</li>
<li>会使用MybatisPlus中的常用注解</li>
<li>会使用MybatisPlus处理枚举、JSON类型字段</li>
<li>会使用MybatisPlus实现分页</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://b11et3un53m.feishu.cn/wiki/PsyawI04ei2FQykqfcPcmd7Dnsc">day01-MybatisPlus - 飞书云文档</a> </p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/08/31/mp+lombok/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/08/15/Spring%20SpringMVC%20SpringBoot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/15/Spring%20SpringMVC%20SpringBoot/" class="post-title-link" itemprop="url">Spring</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-15 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-15T00:00:00+08:00">2024-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 16:12:46" itemprop="dateModified" datetime="2025-04-27T16:12:46+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h1><p>IoC: Inverse of Control 原先调用服务或者DAO的需要自行new出来对象，硬编码，耦合程度高，Spring的Container能够接管对象的创建工作（实际上就是管理Bean） 并且能够根据对象Bean之间的关系进行依赖注入，创建A对象的同时会把B对象创建起来，也就是DI(Dependency Injection)</p>
<p>管理方式：配置文件xml            IoC容器的获取：Spring提供接口</p>
<p>把业务接口的实现类交给Spring管理，遇到接口类，Spring就会自动去找Bean中是否有接口的实现类。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020194848409.png" alt="image-20241020194848409"></p>
<p>BookDao是接口，实现类为BookDaoImpl，Impl交给Spring管理</p>
<p>DI：依赖注入，依赖用方法传参的方式传入</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019114405108.png" alt="image-20241019114405108"></p>
<p>property name 是成员变量的名字</p>
<p>ref 是要引用的bean id/name</p>
<h2 id="IoC-配置"><a href="#IoC-配置" class="headerlink" title="IoC 配置"></a>IoC 配置</h2><h3 id="bean-管理"><a href="#bean-管理" class="headerlink" title="bean 管理"></a>bean 管理</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019222443537.png" alt="image-20241019222443537"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019115106810.png" alt="image-20241019115106810"></p>
<h4 id="name-别名"><a href="#name-别名" class="headerlink" title="name 别名"></a>name 别名</h4><p><u>ATTRIBUTE</u></p>
<p>bean <strong>name</strong> = “s1 s2 s3”  alias</p>
<p><strong>ref</strong>可以使用name也可以使用id</p>
<p>getBean </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019144037398.png" alt="image-20241019144037398"></p>
<h4 id="scope-作用范围"><a href="#scope-作用范围" class="headerlink" title="scope 作用范围"></a>scope 作用范围</h4><p><u>ATTRIBUTE</u></p>
<p>Spring默认创建<strong>单例</strong>bean，scope=”singleton” prototype为多例。</p>
<ul>
<li>适合复用的才作为bean交给IoC容器管理<ul>
<li>表现层，业务层，DAO层，工具层</li>
</ul>
</li>
<li>不适合复用的对象<ul>
<li>封装的实体域对象</li>
</ul>
</li>
</ul>
<h4 id="bean-创建方式"><a href="#bean-创建方式" class="headerlink" title="bean 创建方式"></a>bean 创建方式</h4><h5 id="使用构造方法"><a href="#使用构造方法" class="headerlink" title="使用构造方法"></a><mark>使用构造方法<mark></h5><p>无参构造器，如果使用构造器进行依赖注入，则走的是有参构造</p>
<h5 id="使用静态工厂实例化Bean"><a href="#使用静态工厂实例化Bean" class="headerlink" title="使用静态工厂实例化Bean"></a>使用静态工厂实例化Bean</h5><ul>
<li>工厂的静态方法factoryMethod(return new Bean)，不造工厂，调用工厂的<strong>静态</strong>方法造Bean <u>ATTRIBUTE</u>: factory-method</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019160109618.png" alt="image-20241019160109618"></p>
<h5 id="使用实例工厂实例化Bean"><a href="#使用实例工厂实例化Bean" class="headerlink" title="使用实例工厂实例化Bean"></a>使用实例工厂实例化Bean</h5><ul>
<li>先造工厂bean再调用工厂的<strong>实例</strong>方法(return newBean) 造bean</li>
</ul>
<h5 id="FactoryBean-实例工厂bean"><a href="#FactoryBean-实例工厂bean" class="headerlink" title="FactoryBean 实例工厂bean"></a><mark>FactoryBean 实例工厂bean<mark></h5><ul>
<li><p>第三方自定义工厂Bean类实现FactoryBean接口，重写方法<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019160946566.png" alt="image-20241019160946566"></p>
<ul>
<li>getObject 工厂类的returnNewBean方法</li>
<li>getObjectType return Bean.class bean的 字节码</li>
<li>isSingleton 单例</li>
</ul>
</li>
<li><p>xml 配置<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019161457148.png" alt="image-20241019161457148">    </p>
</li>
<li><p>主要用于第三方框架和Spring框架对接，他们创建的对象要配置一些参数，这时就需要一个FactoryBean，工厂bean会提供set对象参数的方法，返回的就是配好参的对象，可以省去手动配参的麻烦</p>
</li>
</ul>
<h4 id="bean-生命周期"><a href="#bean-生命周期" class="headerlink" title="bean 生命周期"></a>bean 生命周期</h4><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/reference/core/beans/factory-nature.html#beans-factory-lifecycle-initializingbean">Customizing the Nature of a Bean :: Spring Framework</a> </p>
<h5 id="init-method-初始化"><a href="#init-method-初始化" class="headerlink" title="init-method 初始化"></a>init-method 初始化</h5><p><u>ATTRIBUTE</u> 方法名</p>
<h5 id="destroy-method-销毁"><a href="#destroy-method-销毁" class="headerlink" title="destroy-method 销毁"></a>destroy-method 销毁</h5><p><u>ATTRIBUTE</u> 方法名</p>
<p>销毁方式1: 容器关闭 <code>ctx.close()</code> appctx这个类没有关闭功能，换一个annotationConfigAppctx才有</p>
<p>销毁方式2: 注册关闭钩子<code>ctx.registerShutdownHook()</code></p>
<h5 id="自定义实体类实现接口"><a href="#自定义实体类实现接口" class="headerlink" title="自定义实体类实现接口"></a>自定义实体类实现接口</h5><p><code>DisposableBean</code> <code>InitializingBean</code> </p>
<p>分别重写destory() afterPropertiesSet()</p>
<p>属性设置就是在属性注入(调用setter)之后调用的方法</p>
<h5 id="生命周期示意图"><a href="#生命周期示意图" class="headerlink" title="生命周期示意图"></a>生命周期示意图</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019163321664.png" alt="image-20241019163321664"></p>
<h3 id="DI-依赖注入"><a href="#DI-依赖注入" class="headerlink" title="DI 依赖注入"></a>DI 依赖注入</h3><p><strong>注入</strong> ⇔ <strong>给bean的属性赋值</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019222530413.png" alt="image-20241019222530413"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019163720566.png" alt="image-20241019163720566"></p>
<p>注入多个bean，填写多个property</p>
<h4 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h4><h5 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a><mark>setter注入<mark></h5><ol>
<li>setter 引用其他的bean property ref = 其他bean的名称 <u>ATTRIBUTE</u></li>
<li>setter 注入基本数据类型和简单值 property value = 值  <u>ATTRIBUTE</u></li>
<li>property name实际上是根据setter方法 setUserDao 去掉set首字母小写 userDao得到的</li>
<li>先无参构造创建bean，再用setter注入依赖</li>
</ol>
<h5 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h5><p>针对有参构造器，必须显式声明有参构造器</p>
<p> <u>ATTRIBUTE</u> <code>&lt;constructor-arg name&gt;</code></p>
<ol>
<li><p> 引用其他bean name是构造器形参名，<strong>耦合度高</strong>，参数先后顺序固定不能变<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019173838816.png" alt="image-20241019173838816"></p>
</li>
<li><p> 基本数据类型和简单值<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019174107702.png" alt="image-20241019174107702"></p>
</li>
<li><p>耦合度高解决方案：<strong>参数适配</strong></p>
<ul>
<li><p><code>&lt;constructor-arg name&gt;</code>改成type，解决参数名的高耦合，但是type相同的参数会混淆</p>
</li>
<li><p>改成index，index表示参数的位置</p>
</li>
</ul>
</li>
<li><p> 直接有参构造创建bean，可以没有无参构造</p>
</li>
</ol>
<h4 id="方式选择"><a href="#方式选择" class="headerlink" title="方式选择"></a>方式选择</h4><ul>
<li><strong>强制依赖</strong>使用构造器进行，使用setter注入有概率不进行注入导致NullPointerException</li>
<li><strong>可选依赖</strong>使用setter注入进行，灵活性强</li>
<li>Spring框架倡导使用构造器,第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨</li>
<li>如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入</li>
<li>实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</li>
<li><u>自己开发的模块推荐使用setter注入</u></li>
</ul>
<h4 id="依赖自动装配-autowire"><a href="#依赖自动装配-autowire" class="headerlink" title="依赖自动装配 autowire"></a>依赖自动装配 <span id="autowire">autowire</span></h4><p>只适用于引用类型</p>
<p><u>ATTRIBUTE</u> </p>
<p>不去手动指定，在容器的bean中自动匹配适合的bean。依赖于有参构造或者setter</p>
<h5 id="byType-依赖setter"><a href="#byType-依赖setter" class="headerlink" title="byType (依赖setter)"></a><mark>byType<mark> (依赖setter)</h5><p><code>bean属性的type</code> 要去匹配 <code>容器中bean的class</code></p>
<p>保证相同class的bean唯一 推荐</p>
<h5 id="byName-依赖setter"><a href="#byName-依赖setter" class="headerlink" title="byName (依赖setter)"></a>byName (依赖setter)</h5><p><code>bean属性的name</code> 要去匹配 <code>容器中bean的id</code></p>
<p>保证必须要有指定名称的bean  耦合度高，不推荐</p>
<h5 id="constructor-依赖有参构造器"><a href="#constructor-依赖有参构造器" class="headerlink" title="constructor(依赖有参构造器)"></a>constructor(依赖有参构造器)</h5><h5 id="default"><a href="#default" class="headerlink" title="default"></a>default</h5><p>如果&lt;beans&gt;指定了autowire 此bean跟随beans</p>
<h5 id="no"><a href="#no" class="headerlink" title="no"></a>no</h5><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li><p>只能自动装配引用类型（IoC容器不会去管理简单类型）包装类bean根本没法写</p>
</li>
<li><p>优先级 &lt; 手动装配</p>
</li>
</ul>
<h4 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h4><p>集合要注入内容，而不是注一个空壳</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myArray&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>5<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">value</span>&gt;</span>this<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>that<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>where<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mySet&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">value</span>&gt;</span>this<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>that<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>where<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;A&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;B&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;C&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myProperties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;A&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;B&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;C&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="管理第三方Bean"><a href="#管理第三方Bean" class="headerlink" title="管理第三方Bean"></a>管理第三方Bean</h3><p>别人写的对象，创建bean，类型是什么？你要配哪些参数？</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019191451764.png" alt="image-20241019191451764"></p>
<h4 id="加载-properties-XML-Namespace-JDBC-MyBatis-XML-Maven-md"><a href="#加载-properties-XML-Namespace-JDBC-MyBatis-XML-Maven-md" class="headerlink" title="加载.properties ([XML Namespace](.\JDBC MyBatis XML Maven.md))"></a>加载.properties ([XML Namespace](.\JDBC MyBatis XML Maven.md))</h4><p>创建context命名空间</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019192317628.png" alt="image-20241019192317628"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019220634669.png" alt="image-20241019220634669"></p>
<p>classpath:*.properties 当前模块下所有的配置文件</p>
<h3 id="容器-ctx"><a href="#容器-ctx" class="headerlink" title="容器 ctx"></a>容器 ctx</h3><h4 id="创建容器方式"><a href="#创建容器方式" class="headerlink" title="创建容器方式"></a>创建容器方式</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019221415451.png" alt="image-20241019221415451"></p>
<h4 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019221407031.png" alt="image-20241019221407031"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019221914707.png" alt="image-20241019221914707"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019222158026.png" alt="image-20241019222158026"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019221938964.png" alt="image-20241019221938964"></p>
<p>立即加载（饿汉），lazy-init 延迟加载 (懒汉)</p>
<h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><h3 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h3><h4 id="定义bean-Component"><a href="#定义bean-Component" class="headerlink" title="定义bean@Component"></a><mark>定义bean@Component<mark></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019223116345.png" alt="image-20241019223116345"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019223156078.png" alt="image-20241019223156078"></p>
<p>加上对应的bean的id ，不加就要加载字节码class</p>
<h4 id="纯注解开发-Configuration-ComponetScan"><a href="#纯注解开发-Configuration-ComponetScan" class="headerlink" title="纯注解开发@Configuration  @ComponetScan"></a><mark>纯注解开发@Configuration  @ComponetScan<mark></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019224153002.png" alt="image-20241019224153002"></p>
<p>获取ctx: <code>ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class)</code> </p>
<p>默认xml配置文件只给了beans的命名空间，context还得另外自己加，纯注解开发需要定义一个SpringConfig类，常用的配置都有，不用手动去加命名空间</p>
<p>XML out!</p>
<h3 id="2-bean管理"><a href="#2-bean管理" class="headerlink" title="2. bean管理"></a>2. bean管理</h3><h4 id="作用范围-Scope"><a href="#作用范围-Scope" class="headerlink" title="作用范围 @Scope"></a>作用范围 @Scope</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019225307356.png" alt="image-20241019225307356"></p>
<h4 id="生命周期-PostConstruct-PreDestroy"><a href="#生命周期-PostConstruct-PreDestroy" class="headerlink" title="生命周期 @PostConstruct @PreDestroy"></a>生命周期 @PostConstruct @PreDestroy</h4><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2426419">探究Spring Boot中@PostConstruct注解的使用场景-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1588212">Spring 框架中 @PostConstruct 注解详解-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019225254913.png" alt="image-20241019225254913"></p>
<p>Instantiate(Constructor)&gt; @Autowired &gt; @PostConstruct</p>
<p>依赖注入完成，被显式调用之前</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/reference/core/beans/annotation-config/postconstruct-and-predestroy-annotations.html">Using @PostConstruct and @PreDestroy :: Spring Framework</a></p>
<h3 id="DI-自动装配"><a href="#DI-自动装配" class="headerlink" title="DI 自动装配"></a>DI 自动装配</h3><h4 id="自动装配-Autowired（引用类型）"><a href="#自动装配-Autowired（引用类型）" class="headerlink" title="自动装配@Autowired（引用类型）"></a><mark>自动装配@Autowired（引用类型）<mark></h4><p>在需要注入依赖的<strong>一个</strong>属性</p>
<p>与配置文件<a href="#autowire">autowire Attribute of Bean</a>不同，注解Autowired不依赖于setter和有参构造器，直接暴力反射访问private属性，创建对象并注入依赖。 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020011345128.png" alt="image-20241020011345128"></p>
<h5 id="按名称匹配-Qualifier"><a href="#按名称匹配-Qualifier" class="headerlink" title="按名称匹配@Qualifier"></a>按名称匹配@Qualifier</h5><p>autowired默认按类型装 配，同一类型多个实现，用Qualifier指定具体bean名称，<em>不加Qualifier就按一定规则选择</em> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020011356460.png" alt="image-20241020011356460"></p>
<h5 id="先名称匹配，再按照类型匹配-Resource"><a href="#先名称匹配，再按照类型匹配-Resource" class="headerlink" title="先名称匹配，再按照类型匹配@Resource"></a>先名称匹配，再按照类型匹配@Resource</h5><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1003903">面试突击78：@Autowired 和 @Resource 有什么区别？-阿里云开发者社区 (aliyun.com)</a> </p>
<ul>
<li><strong>@Autowired 先根据类型（byType）查找，如果存在多个（Bean）再根据名称（byName）进行查找；</strong></li>
<li><strong>@Resource 先根据名称（byName）查找，如果（根据名称）查找不到，再根据类型（byType）进行查找。</strong> </li>
</ul>
<p>注意下方的<a href="#bean">Bean注解</a></p>
<p><strong>@Autowired 支持属性注入、构造方法注入和 Setter 注入，而 @Resource 只支持属性注入和 Setter 注入</strong> </p>
<p>@Autowired 来自 Spring 框架，而 @Resource 来自于（Java）JSR-250；</p>
<p>@Autowired 只支持设置 1 个参数，而 @Resource 支持设置 7 个参数；</p>
<p>@Autowired 既支持构造方法注入，又支持属性注入和 Setter 注入，而 @Resource 只支持属性注入和 Setter 注入；</p>
<h4 id="简单类型注入依赖-Value"><a href="#简单类型注入依赖-Value" class="headerlink" title="简单类型注入依赖@Value"></a>简单类型注入依赖@Value</h4><p>需要注入的属性上 写value</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020011954765.png" alt="image-20241020011954765"></p>
<h4 id="导入配置文件-PropertySource"><a href="#导入配置文件-PropertySource" class="headerlink" title="导入配置文件@PropertySource"></a>导入配置文件@PropertySource</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020011844984.png" alt="image-20241020011844984"></p>
<h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a><mark>循环依赖<mark></h4><p>Spring循环依赖指的是两个或多个Bean之间相互依赖，形成一个环状依赖的情况。简单来说，就是A依赖B，B依赖C，C依赖A，这样就形成了一个循环依赖的环。</p>
<p>Spring循环依赖通常会导致Bean无法正确地被实例化，从而导致应用程序无法正常启动或者出现异常。因此，Spring循环依赖是一种需要尽量避免的情况。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/633066ae3fcb2fcc117ab142dd90d3da-1730639875106-2.png"></p>
<h5 id="使用构造函数注入"><a href="#使用构造函数注入" class="headerlink" title="使用构造函数注入"></a>使用构造函数注入</h5><p>构造函数注入是一种相对保险的方式，因为在实例化Bean时，Spring会检查是否存在循环依赖，并在发现循环依赖时抛出异常，避免死循环。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用-Lazy注解"><a href="#使用-Lazy注解" class="headerlink" title="使用@Lazy注解"></a>使用@Lazy注解</h5><p>@Lazy注解可以延迟Bean的实例化，从而避免循环依赖的问题。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用setter方法注入"><a href="#使用setter方法注入" class="headerlink" title="使用setter方法注入"></a>使用setter方法注入</h5><p>使用setter方法注入也可以解决循环依赖的问题，但要注意可能出现的空指针异常。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">(B b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(A a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="管理第三方Bean-1"><a href="#管理第三方Bean-1" class="headerlink" title="管理第三方Bean"></a>管理第三方Bean</h3><h4 id="Config配置类中bean的创建-Bean"><a href="#Config配置类中bean的创建-Bean" class="headerlink" title="Config配置类中bean的创建@Bean"></a><span id="bean"><mark>Config配置类中bean的创建@Bean<mark></span></h4><p>与@Component不同 这个是方法级别的注解，方法返回的对象将由Spring容器管理</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020012511399.png" alt="image-20241020012511399"></p>
<h5 id="Bean声明的Bean名称？"><a href="#Bean声明的Bean名称？" class="headerlink" title="@Bean声明的Bean名称？"></a>@Bean声明的Bean名称？</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/w1014074794/article/details/106768607">spring boot中通过注解@Bean声明的bean的名称是什么？_springboot 声明bean的名称-CSDN博客</a></p>
<h6 id="不指定name属性，bean名称为方法名"><a href="#不指定name属性，bean名称为方法名" class="headerlink" title="不指定name属性，bean名称为方法名"></a>不指定name属性，bean名称为方法名</h6><h6 id="指定name属性，bean名称为name"><a href="#指定name属性，bean名称为name" class="headerlink" title="指定name属性，bean名称为name"></a>指定name属性，bean名称为name</h6><h5 id="导入其他Config类到核心配置-Import"><a href="#导入其他Config类到核心配置-Import" class="headerlink" title="导入其他Config类到核心配置@Import"></a>导入其他Config类到核心配置@Import</h5><p>不建议直接把其他的配置写到SpringConfig里面，分出去然后import</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020012755726.png" alt="image-20241020012755726"></p>
<h4 id="DI-依赖注入-1"><a href="#DI-依赖注入-1" class="headerlink" title="DI 依赖注入"></a>DI 依赖注入</h4><p><span id="thirdpartydi">最简单的方法：自己new个对象出来，手动配参数，丢给spring</span> (其实xml就是把手动配参的过程从业务代码中解耦出来)</p>
<h5 id="简单类型依赖注入：成员变量-Value"><a href="#简单类型依赖注入：成员变量-Value" class="headerlink" title="简单类型依赖注入：成员变量@Value"></a>简单类型依赖注入：成员变量@Value</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020013246624.png" alt="image-20241020013246624"></p>
<h5 id="引用类型依赖注入：方法形参"><a href="#引用类型依赖注入：方法形参" class="headerlink" title="引用类型依赖注入：方法形参"></a><mark>引用类型依赖注入：方法形参<mark></h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020013406409.png" alt="image-20241020013406409"></p>
<h3 id="XML-vs-Annotation"><a href="#XML-vs-Annotation" class="headerlink" title="XML vs. Annotation"></a>XML vs. Annotation</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020013703651.png" alt="image-20241020013703651"></p>
<h2 id="整合第三方框架实战"><a href="#整合第三方框架实战" class="headerlink" title="整合第三方框架实战"></a>整合第三方框架实战</h2><h3 id="Spring-amp-MyBatis"><a href="#Spring-amp-MyBatis" class="headerlink" title="Spring &amp; MyBatis"></a>Spring &amp; MyBatis</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_64737877/article/details/122608987">使用纯注解方式Spring整合MyBatis_spring整合mybatis基于注解-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/SerikaOnoe/article/details/90639135">Spring整合Mybatis(注解方式完整过程，摒弃MyBatis配置文件)_springboot启动去除mybatis-CSDN博客</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020123544343.png" alt="image-20241020123544343"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020123756444.png" alt="image-20241020123756444"></p>
<p>dao是session用动态代理造出来的，不同业务的内部实现有区别。session也不会一直复用，根源在sqlSessionFactory。</p>
<p>还有一个就是mapper映射，这个跟ssf没什么关系。</p>
<h4 id="MyBatisConfig-SqlSessionFactoryBean"><a href="#MyBatisConfig-SqlSessionFactoryBean" class="headerlink" title="MyBatisConfig - SqlSessionFactoryBean"></a>MyBatisConfig - SqlSessionFactoryBean</h4><p>导入mybatis-spring spring-jdbc，mybatis实现了Spring规定的FactoryBean接口，专门用来造sqlSessionFactory对象。</p>
<p>回顾spring创建对象的方法，一种是<a href="#thirdpartydi">使用构造</a>器直接得到对象，另一种就是使用factoryBean&lt;E&gt;得到对象E，定义一个造E的工厂Bean，这样spring就知道类型E创对象需要用工厂Bean的方式。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020130218463.png" alt="image-20241020130218463"></p>
<p>factorybean中提供了很多设置E参数的方法，最终返回的是一个设置好参数的E，思想还是一样的，只不过套了一层工厂的皮，封装进去很多固定的参数set方法，一般这个E需要xml进行配置(跟真正的业务代码解耦)，工厂Bean就取代了xml，直接给你返回一个配置好的对象。</p>
<p>需要传参就直接在写上方法参数即可，spring自动匹配</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020145504890.png" alt="image-20241020145504890"></p>
<h4 id="MyBatisConfig-MapperScannerConfigurer"><a href="#MyBatisConfig-MapperScannerConfigurer" class="headerlink" title="MyBatisConfig - MapperScannerConfigurer"></a>MyBatisConfig - MapperScannerConfigurer</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020145526730.png" alt="image-20241020145526730"></p>
<p>DAO没有实现类了，在原始接口上加Component、Repository给ioc容器标识一下，不标也行。</p>
<p>这个mapperScannerConfigurer是mybatis和spring集成的部分，扫描指定mapper所在的包，mapper生成代理对象，通过factoryBean方式交给Spring容器，所以重点不是让spring知道dao的实现类在哪，重点是要让mybatis知道mapper位置</p>
<h4 id="JdbcConfig-创建DataSource的Bean交给Spring管理"><a href="#JdbcConfig-创建DataSource的Bean交给Spring管理" class="headerlink" title="JdbcConfig - 创建DataSource的Bean交给Spring管理"></a>JdbcConfig - 创建DataSource的Bean交给Spring管理</h4><h3 id="Spring-amp-JUnit"><a href="#Spring-amp-JUnit" class="headerlink" title="Spring &amp; JUnit"></a>Spring &amp; JUnit</h3><p>导入spring-test 在Test<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020191443245.png" alt="image-20241020191443245"></p>
<p>在test.java中测试。</p>
<h4 id="RunWith-ContextConfiguration"><a href="#RunWith-ContextConfiguration" class="headerlink" title="@RunWith @ContextConfiguration"></a>@RunWith @ContextConfiguration</h4><h4 id="Autowired-Test"><a href="#Autowired-Test" class="headerlink" title="@Autowired @Test"></a>@Autowired @Test</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020145826024.png" alt="image-20241020145826024"></p>
<p>需要引用类型参数直接autowired注入即可，一般是业务类做测试</p>
<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><h2 id="AOP的含义"><a href="#AOP的含义" class="headerlink" title="AOP的含义"></a>AOP的含义</h2><p>AOP 面向切面编程 <strong>不惊动原始设计</strong>的情况下增强功能</p>
<p>Spring理念：无侵入式增强功能</p>
<ul>
<li>所有原始方法-&gt;连接点(joint point) 在SpringAOP中如此<ul>
<li>save update delete select</li>
</ul>
</li>
<li>需要追加功能的方法-&gt;切入点(pointcut)<ul>
<li>save update delete </li>
</ul>
</li>
<li>具备的共性功能-&gt;通知 (advice)<ul>
<li>method1   method2</li>
</ul>
</li>
<li>通知和切入点产生关系-&gt;切面 (aspect) <ul>
<li>save update delete追加method</li>
</ul>
</li>
<li>功能的集合-&gt;通知类</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020152910091.png" alt="image-20241020152910091"></p>
<p>连接点包含切入点</p>
<h2 id="Spring中进行AOP编程"><a href="#Spring中进行AOP编程" class="headerlink" title="Spring中进行AOP编程"></a>Spring中进行AOP编程</h2><h3 id="导入坐标"><a href="#导入坐标" class="headerlink" title="导入坐标"></a>导入坐标</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020154236445.png" alt="image-20241020154236445"></p>
<h3 id="MyAdvice"><a href="#MyAdvice" class="headerlink" title="MyAdvice"></a><mark>MyAdvice<mark></h3><h4 id="定义通知"><a href="#定义通知" class="headerlink" title="定义通知"></a>定义通知</h4><h4 id="定义切入点-Pointcut"><a href="#定义切入点-Pointcut" class="headerlink" title="定义切入点 @Pointcut"></a>定义切入点 @Pointcut</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020154309848.png" alt="image-20241020154309848"></p>
<p><code>private</code> <code>void</code> <code>空参</code> </p>
<h4 id="绑定通知与切入点"><a href="#绑定通知与切入点" class="headerlink" title="绑定通知与切入点"></a>绑定通知与切入点</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020154407660.png" alt="image-20241020154407660"></p>
<h4 id="Spring接管此类-Component"><a href="#Spring接管此类-Component" class="headerlink" title="Spring接管此类 @Component"></a>Spring接管此类 @Component</h4><h4 id="定义AOP-Aspect"><a href="#定义AOP-Aspect" class="headerlink" title="定义AOP @Aspect"></a>定义AOP @Aspect</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020154529656.png" alt="image-20241020154529656"></p>
<h3 id="SpringConfig-EnableAspectAutoProxy"><a href="#SpringConfig-EnableAspectAutoProxy" class="headerlink" title="SpringConfig @EnableAspectAutoProxy"></a><mark>SpringConfig @EnableAspectAutoProxy<mark></h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020154505110-1729410361899-4.png" alt="image-20241020154505110"></p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020155857766.png" alt="image-20241020155857766"></p>
<p>**基于<mark>动态代理<mark>**：</p>
<ul>
<li><p>匹配失败，new原始对象；</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020160228368.png" alt="image-20241020160228368"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020160243146.png" alt="image-20241020160243146"></p>
</li>
<li><p>匹配成功，new出来的是原始对象的代理对象；</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020160302140.png" alt="image-20241020160302140"></p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020160341452.png" alt="image-20241020160341452"></p>
</li>
</ul>
<p><strong>用获取到的bean执行方法</strong>：如果是代理的bean，根据通知和切入点进行方法执行。</p>
<h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3><p>切入点：要对其进行增强的方法</p>
<p>切入点表达式：对切入点的描述方式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020161523488.png" alt="image-20241020161523488"></p>
<p>execution(<code>public</code> <code>User</code> <code>com.itheima.service.UserService.findById</code>(<code>int</code>))</p>
<p>public exception 可省略</p>
<p>参数必须有</p>
<h4 id="通配符使用"><a href="#通配符使用" class="headerlink" title="通配符使用"></a>通配符使用</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020161833474.png" alt="image-20241020161833474"></p>
<ul>
<li>..和*的区别 *用于精准匹配到某个位置</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020163432072.png" alt="image-20241020163432072"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.impl.BookDaoImpl.update())&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.impl.BookDaoImpl.update(*))&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.*.*.*.update())&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* *..*(..))&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* *..*e(..))&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(void com..*())&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.itheima.*.*Service.find*(..))&quot;)</span></span><br><span class="line"><span class="comment">//执行com.itheima包下的任意包下的名称以Service结尾的类或接口中的save方法，参数任意，返回值任意</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h3><h4 id="前置-Before"><a href="#前置-Before" class="headerlink" title="前置@Before"></a>前置@Before</h4><h4 id="后置-After"><a href="#后置-After" class="headerlink" title="后置@After"></a>后置@After</h4><h4 id="环绕-Around"><a href="#环绕-Around" class="headerlink" title="环绕@Around"></a><strong><u><mark>环绕@Around<mark></u></strong></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020170038080.png" alt="image-20241020170038080"></p>
<ul>
<li><p>ProceedingJoinPoint</p>
</li>
<li><p>原始方法在环绕方法中执行，用<code>pjp.proceed()</code>执行原始方法，<mark>不出现就能隔离原始方法，（权限校验）<mark></p>
</li>
<li><p>pjp能接原始方法的返回值，类型为Object，强转后可以在给他返回去，思想和动态代理里的案例比较像：利用反射invoke调用可以拿到返回值，<strong>注意修改通知方法的返回值为Object。</strong>没返回值也可以</p>
</li>
<li><p>强制抛Throwable </p>
</li>
</ul>
<h4 id="得到返回值之后-AfterReturning"><a href="#得到返回值之后-AfterReturning" class="headerlink" title="得到返回值之后@AfterReturning"></a>得到返回值之后@AfterReturning</h4><p>和after区别：after只要方法结束即可，不管是得到返回值正常结束还是抛异常。AfterReturning需要得到返回值正常结束才能</p>
<h4 id="抛出异常之后-AfterThrowing"><a href="#抛出异常之后-AfterThrowing" class="headerlink" title="抛出异常之后@AfterThrowing"></a>抛出异常之后@AfterThrowing</h4><h3 id="案例：JUnit-测量业务层接口执行效率"><a href="#案例：JUnit-测量业务层接口执行效率" class="headerlink" title="案例：JUnit 测量业务层接口执行效率"></a>案例：JUnit 测量业务层接口执行效率</h3><p>JUnit 测试服务类就private服务出来，<code>@Autowired</code> </p>
<p>下面写test具体方法。详见JUnit单元测试篇(Java SE)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020171154617.png" alt="image-20241020171154617"></p>
<p>获取方法签名 (执行信息) <code>getSignature()</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020171252962.png" alt="image-20241020171252962"></p>
<h3 id="通知获取数据"><a href="#通知获取数据" class="headerlink" title="通知获取数据"></a>通知获取数据</h3><h4 id="JoinPoint-amp-ProceedingJoinPoint"><a href="#JoinPoint-amp-ProceedingJoinPoint" class="headerlink" title="JoinPoint &amp; ProceedingJoinPoint"></a>JoinPoint &amp; ProceedingJoinPoint</h4><p><strong>作为通知的参数</strong>，如果出现，必须在第一个参数的位置上,PJP是JP的子类</p>
<p><code>Object[] getArgs()</code>: 获取原始方法的参数</p>
<p><code> Object proceed()</code> :环绕 PJP专用，调用原始方法同时返回这个方法的返回值</p>
<h4 id="AOP获取原始方法调用参数"><a href="#AOP获取原始方法调用参数" class="headerlink" title="AOP获取原始方法调用参数"></a><mark>AOP获取原始方法调用参数<mark></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020173959692.png" alt="image-20241020173959692"></p>
<p>这样可以对原始参数进行处理，可以增加程序健壮性。</p>
<p><code>Object proceed(Object[] args)</code> 可以把处理以后的参数传给原始方法。</p>
<h5 id="案例：网盘提取码去空格"><a href="#案例：网盘提取码去空格" class="headerlink" title="案例：网盘提取码去空格"></a>案例：网盘提取码去空格</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020180157823.png" alt="image-20241020180157823"></p>
<p>args本身是Object数组，拿进来需要转成字符串toString getArgs 然后遍历参数数组，对每个字符串参数trim，再把处理以后的传给proceed</p>
<h4 id="AOP获取返回值"><a href="#AOP获取返回值" class="headerlink" title="AOP获取返回值"></a>AOP获取返回值</h4><ol>
<li>环绕 pjp proceed </li>
<li>AfterReturning 注解的returning要和形参名字相同</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020175037570.png" alt="image-20241020175037570"></p>
<h4 id="AOP接收异常"><a href="#AOP接收异常" class="headerlink" title="AOP接收异常"></a>AOP接收异常</h4><ol>
<li><p>环绕 不要往出抛Throwable 内部try-catch</p>
</li>
<li><p>AfterThrowing 注解的throwing和形参名字相同</p>
</li>
</ol>
<p>![image-20241020174307577](<a target="_blank" rel="noopener" href="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/屏幕截图</a> 2024-10-20 174257.jpg)</p>
<h3 id="环绕通知模拟其他四种通知"><a href="#环绕通知模拟其他四种通知" class="headerlink" title="环绕通知模拟其他四种通知"></a>环绕通知模拟其他四种通知</h3><table>
<thead>
<tr>
<th>前置</th>
<th>最后调用proceed</th>
</tr>
</thead>
<tbody><tr>
<td>后置</td>
<td>try catch finally 在finally里写</td>
</tr>
<tr>
<td>AfterReturning</td>
<td>Object接住proceed的返回值</td>
</tr>
<tr>
<td>AfterThrowing</td>
<td>不要往出抛Throwable，try catch Throwable</td>
</tr>
</tbody></table>
<h2 id="AOP编程思想—this调用实例方法失效"><a href="#AOP编程思想—this调用实例方法失效" class="headerlink" title="AOP编程思想—this调用实例方法失效"></a>AOP编程思想—this调用实例方法失效</h2><p>AOP的核心，是从调用对象的方法时生成代理对象—PROXY，this指向真正的目标对象—TARGET</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IService</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">zoo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IService</span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">		System.println(<span class="string">&quot;fooStart...&quot;</span>);</span><br><span class="line">		zoo();<span class="comment">//this指针调用实例方法</span></span><br><span class="line">		System.println(<span class="string">&quot;fooFinish...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Transactional</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">zoo</span><span class="params">()</span>&#123;</span><br><span class="line">		save(a);<span class="comment">//假设是将a保存到数据库</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">		save(b);<span class="comment">//假设是将b保存到数据库</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IService service;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        service.foo();<span class="comment">//从外部调用内部的事务方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事务的实现基于spring aop，如果直接用this，则会使用target对象进行方法调用，</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/reference/core/aop/proxying.html#aop-understanding-aop-proxies">Proxying Mechanisms :: Spring Framework</a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/tx-decl-explained.html#page-title">Understanding the Spring Framework’s Declarative Transaction Implementation :: Spring Framework</a> </p>
<p>如果是在类内部开启的事务，就需要CGLIB动态代理，实现的基础是方法拦截器，环绕通知，</p>
<h3 id="直接调用方法"><a href="#直接调用方法" class="headerlink" title="直接调用方法"></a>直接调用方法</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241104161707487.png" alt="image-20241104161707487"></p>
<h3 id="通过代理调用方法"><a href="#通过代理调用方法" class="headerlink" title="通过代理调用方法"></a>通过代理调用方法</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241104161648309.png" alt="image-20241104161648309"></p>
<p>也就是说，如果要让代理生效，首先就是要获取代理对象，而通过@Transactional注解的方法<code>zoo()</code>，如果从外部调用，只要获得了代理对象的引用，事务功能就是生效的，因此直接在main中只要获取了代理对象的引用调用service.zoo()方法是没有问题的。</p>
<p>而在目标对象内部，this就是目标对象本身，肯定不会走代理，因此如果实在</p>
<h3 id="解决方案—在类的内部获取代理对象"><a href="#解决方案—在类的内部获取代理对象" class="headerlink" title="解决方案—在类的内部获取代理对象"></a>解决方案—在类的内部获取代理对象</h3><h4 id="AopContext-currentProxy"><a href="#AopContext-currentProxy" class="headerlink" title="AopContext.currentProxy()"></a>AopContext.currentProxy()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (UserHolder.getUser()) &#123;</span><br><span class="line">    <span class="comment">//开启事务需要获取当前的代理对象</span></span><br><span class="line">    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Autowired-注入服务对象本身"><a href="#Autowired-注入服务对象本身" class="headerlink" title="@Autowired 注入服务对象本身"></a>@Autowired 注入服务对象本身</h4><p>获取service对象即可，这样就能在类内部的上下文中获取proxy代理都象的引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ServiceImpl service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (UserHolder.getUser()) &#123;</span><br><span class="line">    <span class="comment">//开启事务需要获取当前的代理对象</span></span><br><span class="line">    <span class="keyword">return</span> service.createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以新开一个Impl2类，把方法移植进去，注入Impl2对象，思路一样</span></span><br></pre></td></tr></table></figure>



<h2 id="AOP：动态代理对象的生成时机"><a href="#AOP：动态代理对象的生成时机" class="headerlink" title="AOP：动态代理对象的生成时机"></a>AOP：动态代理对象的生成时机</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xzb5566/article/details/141639614">【spring系列】spring的AOP是在哪个阶段创建的动态代理对象，spring bean的生命周期中在什么阶段创建的aop动态代理对象，很多人会说第一种，其实还有一种情况也会进行aop_spring的aop代理对象什么时候创建-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2154184">关于Spring的两三事：代理对象的生成时机-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><strong>1） Bean的实例化</strong>：首先，Spring容器会实例化Bean。</p>
<p><strong>2）Bean的属性填充</strong>：然后，为Bean填充依赖注入的属性。</p>
<p><strong>3）Bean的初始化：</strong></p>
<ul>
<li><strong>初始化前（postProcessBeforeInitialization）</strong>：在这一阶段，Spring会调用所有BeanPostProcessor的postProcessBeforeInitialization方法。但此时，代理对象可能还未被创建，因为还需要进一步判断该Bean是否需要被代理。</li>
<li><strong>初始化</strong>：接着，执行Bean的初始化方法（如@PostConstruct注解的方法或实现了InitializingBean接口的afterPropertiesSet方法）。</li>
<li><strong>初始化后（postProcessAfterInitialization）</strong>：在Bean初始化完成后，Spring会调用所有BeanPostProcessor的postProcessAfterInitialization方法。这通常是**创建动态代理对象的时机(AOP)**，因为此时Bean已经完全初始化并准备使用，而且代理对象可以在这一阶段被创建并替换掉原始的Bean实例。</li>
</ul>
<p><strong>4）代理对象的创建：</strong> </p>
<ul>
<li>在postProcessAfterInitialization方法中，Spring会检查该Bean是否需要被代理（通常基于是否存在对应的Advisor或Aspect）。</li>
<li>如果需要，Spring会根据Bean的类型（是否实现了接口）选择合适的代理方式（JDK动态代理或CGLIB代理）来创建代理对象。</li>
<li>代理对象会封装原始Bean，并在方法调用时插入增强的逻辑（如前置通知、后置通知等）。</li>
</ul>
<p><strong>5）Bean的交付</strong>：最后，将创建好的代理对象（如果需要的话）或原始Bean实例交付给客户端使用。</p>
<p>因此，<strong>Spring AOP的动态代理对象主要是在Bean的初始化后的postProcessAfterInitialization阶段创建的</strong>。这一过程确保了代理对象能够封装并增强原始Bean的方法调用，同时保持了Bean的生命周期和依赖注入的完整性。</p>
<h1 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h1><p>事务用于业务层或者Dao层</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wang489687009/article/details/129259394">【Spring事务三千问】Spring的事务管理与MyBatis事务管理结合的原理_spring transaction和mybatis的整合 原理-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/358657396">【spring源码深度解析】：spring是如何利用@Transactional注解实现数据库事务的？把握住事务的基本用法你就懂了 - 知乎 (zhihu.com)</a></p>
<h2 id="事务管理整合"><a href="#事务管理整合" class="headerlink" title="事务管理整合"></a>事务管理整合</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jddreams/p/14024754.html">图解Java JDBC和JPA的区别 - 快乐随行 - 博客园 (cnblogs.com)</a></p>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ul>
<li>InnoDB存储引擎支持事务（SQL语句）</li>
</ul>
<h3 id="原生JDBC"><a href="#原生JDBC" class="headerlink" title="原生JDBC"></a>原生JDBC</h3><ul>
<li> 注册驱动，</li>
<li> 获取Connection，</li>
<li> 建立Statement执行SQL语句，Connection可以管理事务（本质是执行SQL语句）</li>
</ul>
<h3 id="DataSource数据源"><a href="#DataSource数据源" class="headerlink" title="DataSource数据源"></a>DataSource数据源</h3><ul>
<li>主要用来获取并管理，调度Connection</li>
</ul>
<h3 id="原生-MyBatis-ORM"><a href="#原生-MyBatis-ORM" class="headerlink" title="原生 MyBatis (ORM)"></a>原生 MyBatis (ORM)</h3><ul>
<li><p>可以调用外部数据源获取Connection，也可以使用原生JDBC来获取，最终这些Connection可以呗SqlSession获取到。</p>
</li>
<li><p>SqlSession同样能管理事务，底层是基于Transaction(也是mybatis的一个类)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">affected_rows</span> <span class="operator">=</span> session.insert(<span class="string">&quot;com.kvn.mapper.UserMapper.insert&quot;</span>, user);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 捕获到异常，将操作回滚</span></span><br><span class="line">    session.rollback();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正常执行，提交事务</span></span><br><span class="line">session.commit();</span><br><span class="line">session.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Spring联合MyBatis事务管理"><a href="#Spring联合MyBatis事务管理" class="headerlink" title="Spring联合MyBatis事务管理"></a>Spring联合MyBatis事务管理</h3><p><code>SpringManagedTransaction</code> 打通了 MyBatis 的事务管理、连接管理 和 spring-tx 的 事务管理、连接管理，使得 MyBatis 与 Spring 可以使用统一的方式来管理连接的生命周期 和 事务处理。</p>
<ol start="0">
<li><p>原生的MyBatis 使用的是JdbcTransaction实现类</p>
</li>
<li><p>在一个非 <code>@Transactional</code> 标记的方法中执行 sql 命令，则事务的管理会通过 <code>SpringManagedTransaction</code> 来执行。</p>
</li>
<li><p>在一个 <code>@Transactional</code> 标记的事务方法中执行 sql 命令，则 <code>SpringManagedTransaction</code> 的 <code>commit()/rollback()</code> 方法不会执行任何动作，而事务的管理会走 Spring AOP 事务管理，即通过 <code>org.springframework.transaction.interceptor.TransactionInterceptor</code> 来进行拦截处理。</p>
</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020215834772.png" alt="image-20241020215834772"></p>
<ol start="3">
<li>SqlSessionInterceptor 保证了 MyBatis 的 SqlSession 在执行 sql 时使用的连接与 Spring 事务管理操作使用的连接是<u>同一个</u>连接。具体就是通过 Spring 的事务同步器 <code>TransactionSynchronizationManager</code> 来保证的。</li>
<li>SpringManagedTransaction 中连接的获取是从 Spring 管理的 DataSource 中获取的，这样，数据库连接池也就和 spring 整合在一起了。</li>
</ol>
<h2 id="多线程事务"><a href="#多线程事务" class="headerlink" title="多线程事务"></a>多线程事务</h2><h3 id="javax-sql-Connection"><a href="#javax-sql-Connection" class="headerlink" title="javax.sql.Connection"></a>javax.sql.Connection</h3><p>简单地来说，建立<code>Connection</code>连接，会消耗数据库系统的如下资源：</p>
<table>
<thead>
<tr>
<th align="center">资源</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">线程数</td>
<td align="center">线程越多，线程的上下文切换会越频繁，会影响其处理能力</td>
</tr>
<tr>
<td align="center">创建Connection的开销</td>
<td align="center">由于Connection负责和数据库之间的通信，在创建环节会做大量的初始化 ，创建过程所需时间和内存资源上都有一定的开销</td>
</tr>
<tr>
<td align="center">内存资源</td>
<td align="center">为了维护Connection对象会消耗一定的内存</td>
</tr>
<tr>
<td align="center">锁占用</td>
<td align="center">在高并发模式下，不同的Connection可能会操作相同的表数据，就会存在锁的情况，数据库为了维护这种锁会有不少的内存开销</td>
</tr>
</tbody></table>
<p>事务的执行依赖于JDBC-connection，connection的建立基于tcp连接，需要耗费很多资源，所以在多线程并发的情况下，connection数目远少于thread数，需要尽可能考虑connection的共用和复用。</p>
<p>connection可以显式开启和关闭事务，遵循事务的ACID原则，因此虽然共用connection，但是同一时间同一connection只能有同一个事务正在执行，也就是串行执行，否则会造成事务紊乱。</p>
<p>一个最佳实践：<strong>当线程需要做数据库操作时，才会真正请求获取JDBC数据库连接,线程使用完了之后，立即释放，被释放的JDBC数据库连接等待下次分配使用</strong></p>
<p>最简单的方式就是把事务执行的代码块用connection锁对象锁住：事务执行完以后释放（但不销毁）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(connection)&#123;</span><br><span class="line">    <span class="comment">//tx......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程如何获取锁对象？为了保证一个线程所有dao操作都是用的同一个connection，使用threadLocal存放属于线程自己的connection，如果是直接从连接池获得的话，多个 DAO 就用到了多个Connection，不能完成一个事务。而连接池负责提供缓存和提供connection</p>
<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/luanlouis/article/details/37671851">《深入理解mybatis原理》 Mybatis数据源与连接池_mybatis 连接池-CSDN博客</a></p>
<p>原生的JDBC会让connection的close()方法执行数据库连接的释放与销毁，为了保证不更改原生的功能，我们可以使用代理对象，让其close方法不会真正执行，而是回收到数据库连接池中。</p>
<p>使用数据库连接池，通常都是得到一个javax.sql.DataSource[接口]的实例对象，它里面包含了Connection，并且数据库连接池工具类（比如C3P0、JNDI、DBCP等）重新定义了getConnection、closeConnection等方法，所以每次得到的Connection，几乎都不是新建立的连接（而是已经建立好并放到缓存里面的连接），调用closeConnection方法，也不是真正的关闭连接（一般都是起到一个标识作用，标识当前连接已经使用完毕，归还给连接池，让这个连接处于待分配状态）【PS：所以说：使用数据库连接池时，还是要显式的调用数据库连接池API提供的关闭连接的方法】。</p>
<p>至于为什么要用ThreadLocal呢?这个和连接池无关,我认为更多的是和程序本身相关,为了更清楚的说明,我举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">servlet中获取一个连接.首先,servlet是线程安全的吗?</span><br><span class="line"></span><br><span class="line">     class MyServlet extends HttpServlet&#123;</span><br><span class="line">         private Connection conn;</span><br><span class="line">     &#125;</span><br><span class="line">     ok,遗憾的告诉你,这个conn并不是安全的,所有请求这个servlet的连接,使用的都是一个Connection,这个就是致命的了.多个人使用同一个连接,算上延迟啥的,天知道数据会成什么样.</span><br><span class="line">     因此我们要保证Connection对每个请求都是唯一的.这个时候就可以用到ThreadLocal了,保证每个线程都有自己的连接.</span><br><span class="line">     改为 private ThreadLocal&lt;Connection&gt; ct = new ThreadLocal&lt;Connnection&gt;();</span><br><span class="line">     然后从连接池获取Connection,set到ct中,再get就行了,至于得到的是哪个Connection就是连接池的问题了,你也管不到.</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal?"></a>ThreadLocal?</h3><p>就是为每一个使用该变量的线程都提供一个变量值的副本，是每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲</p>
<h2 id="开启步骤"><a href="#开启步骤" class="headerlink" title="开启步骤"></a>开启步骤</h2><h3 id="业务层-接口-为业务方法打开事务-Transactional"><a href="#业务层-接口-为业务方法打开事务-Transactional" class="headerlink" title="业务层**接口**为业务方法打开事务@Transactional"></a>业务层**<mark>接口<mark>**为业务方法打开事务@Transactional</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020204651727.png" alt="image-20241020204651727"></p>
<ul>
<li><p>@Transactional是方法级别或者类级别的注解，可以<strong>开在整个接口上</strong>，也可以开在单个方法上</p>
</li>
<li><p>接口能够提高复用性，降低耦合</p>
</li>
</ul>
<h3 id="JdbcConfig创建事务管理器Bean-Bean"><a href="#JdbcConfig创建事务管理器Bean-Bean" class="headerlink" title="JdbcConfig创建事务管理器Bean@Bean"></a>JdbcConfig创建事务管理器Bean@Bean</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020204933459.png" alt="image-20241020204933459"></p>
<p>PlatformTransactionManager是Spring规定的，DataSourceTransactionManager可以动，根据具体的技术选择</p>
<p>要注意，事务管理器的datasource和mybatis用的datasource必须是同一个，不然</p>
<h3 id="SpringConfig打开事务-EnableTransactionManagement"><a href="#SpringConfig打开事务-EnableTransactionManagement" class="headerlink" title="SpringConfig打开事务@EnableTransactionManagement"></a>SpringConfig打开事务@EnableTransactionManagement</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020205233232.png" alt="image-20241020205233232"></p>
<h2 id="事务角色"><a href="#事务角色" class="headerlink" title="事务角色"></a>事务角色</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020205625500.png" alt="image-20241020205625500"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020205648701.png" alt="image-20241020205648701"></p>
<h2 id="事务配置"><a href="#事务配置" class="headerlink" title="事务配置"></a>事务配置</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020222103484.png" alt="image-20241020222103484"></p>
<p>有些异常不会触发回滚，需要手动设置一下rollbackFor</p>
<h3 id="追加日志"><a href="#追加日志" class="headerlink" title="追加日志"></a>追加日志</h3><p>try finally结构，finally 记日志功能必定触发</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020222628555.png" alt="image-20241020222628555"></p>
<h3 id="事务传播行为控制"><a href="#事务传播行为控制" class="headerlink" title="事务传播行为控制"></a>事务传播行为控制</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013341344#item-2-2">(1) java - Spring事务传播行为详解 - 个人文章 - SegmentFault 思否</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020222917510.png" alt="image-20241020222917510"></p>
<p>transfer、AccountDao中所有的数据层方法、日志记录的业务方法都加了Transacitonal注解。</p>
<ul>
<li>transfer作为方法的调用者，是事务的管理员。</li>
<li>其他作为被调用者，是事务的协调员。</li>
<li>如果默认设置Required，管理员开事务，协调员都会加入</li>
</ul>
<p><code>@Transactional(propagation = Propagation.REQUIRES_NEW)</code></p>
<p>开启事务：<code>@Transactional</code></p>
<p>管理员肯定要开启事务，管理员默认是<code>REQUIRED</code>一般不用改，某一个协调员要单开另外一个事务，那么就可以把这个协调员的事务传播机制改成<code>REQUIRES_NEW</code> </p>
<h4 id="Propagation-REQUIRED"><a href="#Propagation-REQUIRED" class="headerlink" title="Propagation.REQUIRED"></a>Propagation.REQUIRED</h4><p><strong>外围方法未开启事务的情况下<code>Propagation.REQUIRED</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</strong> </p>
<p><strong>在外围方法开启事务的情况下<code>Propagation.REQUIRED</code>修饰的内部方法会加入到外围方法的事务中，所有<code>Propagation.REQUIRED</code>修饰的内部方法和外围方法均属于同一事务，只要一个方法回滚，整个事务均回滚。</strong></p>
<h4 id="Propagation-REQUIRES-NEW"><a href="#Propagation-REQUIRES-NEW" class="headerlink" title="Propagation.REQUIRES_NEW"></a>Propagation.REQUIRES_NEW</h4><p><strong>外围方法未开启事务的情况下<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</strong> </p>
<p><strong>在外围方法开启事务的情况下<code>Propagation.REQUIRES_NEW</code>修饰的内部方法依然会单独开启独立事务，且与外部方法事务也独立，内部方法之间、内部方法和外部方法事务均相互独立，互不干扰。</strong></p>
<h2 id="事务失效"><a href="#事务失效" class="headerlink" title="事务失效"></a>事务失效</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hanjiaqian/article/details/120501741">spring 事务失效的 12 种场景_spring 截获duplicatekeyexception 不抛异常-CSDN博客</a></p>
<ul>
<li>访问权限，private,default无法生效</li>
<li>方法用final或static修饰，代理对象无法重写</li>
<li>多线程调用事务方法，两个线程获取的不是同一个连接</li>
<li>数据库或表不支持事务（MySQL的MyISAM不支持事务）</li>
<li>未开启事务或未将类纳入Spring管理<code>@Transactional</code> <code>@Service</code> </li>
</ul>
<h3 id="方法自调用"><a href="#方法自调用" class="headerlink" title="方法自调用"></a><span id="selfinvoke">方法自调用</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        updateStatus(userModel);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateStatus</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">        doSameThing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到在事务方法 add 中，直接调用事务方法 updateStatus。从前面介绍的内容可以知道，updateStatus 方法拥有事务的能力是因为 spring aop 生成代理对象proxy，但是这种方法直接调用了 this 对象的方法，所以 updateStatus 方法不会生成事务。</p>
<p>由此可见，在同一个类中的方法直接内部调用，会导致事务失效。</p>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><p>Java实现MVC模型的web框架，灵活性强，主要进行<strong>表现层开发</strong> Controller。</p>
<h3 id="导坐标"><a href="#导坐标" class="headerlink" title="导坐标"></a>导坐标</h3><h3 id="bean创建-Controller"><a href="#bean创建-Controller" class="headerlink" title="bean创建@Controller"></a>bean创建@Controller</h3><h4 id="方法级别注解-请求映射-RequestMapping"><a href="#方法级别注解-请求映射-RequestMapping" class="headerlink" title="方法级别注解 请求映射 @RequestMapping"></a>方法级别注解 请求映射 @RequestMapping</h4><h4 id="方法级别注解-设置响应-ResponseBody"><a href="#方法级别注解-设置响应-ResponseBody" class="headerlink" title="方法级别注解 设置响应 @ResponseBody"></a>方法级别注解 设置响应 @ResponseBody</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021161644841.png" alt="image-20241021161644841"></p>
<p>都是方法级别注解    </p>
<h3 id="创建SpringMvcConfig-Configuration-ComponentScan"><a href="#创建SpringMvcConfig-Configuration-ComponentScan" class="headerlink" title="创建SpringMvcConfig@Configuration@ComponentScan"></a>创建SpringMvcConfig@Configuration@ComponentScan</h3><p>扫描到controller</p>
<h3 id="创建servlet容器Config"><a href="#创建servlet容器Config" class="headerlink" title="创建servlet容器Config"></a>创建servlet容器Config</h3><p>ServletContainerInitConfig继承AbstractDispatcherServeltInitializer类重写对应方法。都是一次性</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021161341011.png" alt="image-20241021161341011"></p>
<ul>
<li><code>getServletMappings</code> 表示接管URL的那个部分的映射</li>
<li><code>createRootApplicationContext</code> 创建Spring Framework容器并指定配置    </li>
<li><code>createServletApplicationContext</code> 创建web容器并指定配置</li>
<li>web容器 <strong>servlet容器</strong></li>
</ul>
<h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021162133487.png" alt="image-20241021162133487"></p>
<h3 id="bean加载-ComponentScan-Filter"><a href="#bean加载-ComponentScan-Filter" class="headerlink" title="bean加载@ComponentScan.Filter"></a>bean加载@ComponentScan.Filter</h3><p><u>Spring避免加载springmvc的controller</u></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021162700082.png" alt="image-20241021162700082"></p>
<p>导包：mybatis自动代理会返回dao接口的实现对象，可以不写，但是其他技术不一定是这样，所以为了通用性还是应该导dao</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021164147565.png" alt="image-20241021164147565"></p>
<p>SpringConfig扫描排除含有Controller注解的类：<strong>Filter</strong> 可以更细粒度地加载bean</p>
<p>exclude排除</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021164311077.png" alt="image-20241021164311077"></p>
<p>加了configuration的类，spring都会将其作为配置类，里面如果有componentScan，就会扫上。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021164930504.png" alt="image-20241021164930504"></p>
<p>创建容器设定配置再去返回容器，简化过程只需要指定类的字节码即可</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021165128160.png" alt="image-20241021165128160"></p>
<h2 id="配置Controller"><a href="#配置Controller" class="headerlink" title="配置Controller"></a>配置Controller</h2><h3 id="请求Request相关"><a href="#请求Request相关" class="headerlink" title="请求Request相关"></a>请求Request相关</h3><h4 id="请求映射路径-RequestMapping"><a href="#请求映射路径-RequestMapping" class="headerlink" title="请求映射路径@RequestMapping"></a>请求映射路径@RequestMapping</h4><p>对于不同的controller可能会优相同方法，这时会有冲突问题，解决办法是在controller**<mark>类<mark><strong>上加一个@RequestMapping，要和</strong><mark>方法<mark>**的@RequestMapping注解结合一下。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021172423291.png" alt="image-20241021172423291"></p>
<h4 id="名称匹配-指定请求参数名-RequestParam"><a href="#名称匹配-指定请求参数名-RequestParam" class="headerlink" title="名称匹配 指定请求参数名@RequestParam"></a>名称匹配 指定<mark>请求参数<mark>名@RequestParam</h4><p>用于接收GET请求中URL的查询参数，也可以接收POST请求的参数（表单）</p>
<blockquote>
<p>You can use the <code>@RequestParam</code> annotation to bind Servlet request parameters (that is, query parameters or form data) to a method argument in a controller.</p>
</blockquote>
<p>与mybatis类似，对于外部传进来的请求参数用map封装，因此**@RequestParam接收的是key-value形式的参数<strong>，</strong>发送get请求**只会处理URL中的参数，忽略请求体中的数据</p>
<p><strong>发送post请求</strong>时，<mark>表单数据在请求体中<mark>，不过仍然是username=root这样键值对的形式存在，如果URL里有请求参数，服务端收到以后会一并加到map中，打印出来，即使方法里的参数只是一个String也能打印出来</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021220731172.png" alt="image-20241021220731172"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021220755961.png" alt="image-20241021220755961" style="zoom:150%;" /></p>
<p>@RequestParam XXX xxx 表示查询参数用XXX类型接</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43606226/article/details/106545024">SpringMvc--@RequestBody和@RequestParam注解以及不加注解接收参数的区别_不写接收参数的注解,默认使用什么的-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_12393361/5021343">解决mybatis不加@Param报错 org.apache.ibatis.binding.BindingException_51CTO博客_mybatis @Param</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zeng1994/p/9110632.html">记一次SpringMVC碰到的坑 - zeng1994 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as513385/article/details/93512699">关于SpringMvc使用时,不加@RequestParam注解,根据方法形参名也可以获取请求值的分析_spring 请求体不写注解-CSDN博客</a></p>
<p>和 <strong>MyBatis</strong> 一样，使用反射机制获取参数名称，JDK8以后 java.lang.reflect.Parameter 中能够获取参数相关信息，框架就是利用这个机制，不加RequestParam获取参数信息。不然就只有arg0 arg1这种形式。</p>
<ul>
<li>required参数 是否为必传参数，默认必传</li>
<li>defaultValue 参数默认值</li>
</ul>
<h4 id="传递多种类型的请求参数"><a href="#传递多种类型的请求参数" class="headerlink" title="传递多种类型的请求参数"></a>传递多种类型的<mark>请求参数<mark></h4><p>与mybatis类似</p>
<ul>
<li><p>pojo：直接使用pojo内部的字段名称</p>
</li>
<li><p>嵌套pojo：address.字段名称</p>
</li>
<li><p>数组：直接接收字符串数组即可，请求的参数名就是数组的形参名，会把数组当成一个独立的参数</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021192646729.png" alt="image-20241021192646729"></p>
</li>
<li><p>集合类型：加RequestParam注解。 因为集合属于<strong>引用类型</strong>，spring会把它当成pojo处理（造pojo然后根据字段名注入依赖），不加param注解，spring就不会像数组一样把他当成一个独立的参数。</p>
</li>
</ul>
<h5 id="传JSON-EnableWebMvc"><a href="#传JSON-EnableWebMvc" class="headerlink" title="传JSON @EnableWebMvc"></a>传JSON @<mark>EnableWebMvc<mark></h5><p>导坐标 webMvc</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021193842326.png" alt="image-20241021193842326"></p>
<h6 id="参数在请求体里-RequestBody"><a href="#参数在请求体里-RequestBody" class="headerlink" title="参数在请求体里@RequestBody"></a>参数在请求体里@RequestBody</h6><p>@RequestBody XXX xxx 表示请求体中的数据用XXX类型接</p>
<p>RequestBody请求体中的数据通常是以JSON、XML等格式发送的，可以将请求体中的数据自动绑定到指定的Java对象上。</p>
<ol>
<li>参数写在请求体里，用List接收json数组</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021194047781.png" alt="image-20241021194047781"></p>
<ol start="2">
<li>用Pojo类接单个pojo对象json</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021194303198.png" alt="image-20241021194303198"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021194445000.png" alt="image-20241021194445000"></p>
<ol start="3">
<li>用List<pojo>接收多个pojo对象的json，</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021194340592.png" alt="image-20241021194340592"></p>
<p>一个请求，只有一个RequestBody；一个请求，可以有多个RequestParam。</p>
<p><strong>Body vs Param:</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021222507281.png" alt="image-20241021222507281"></p>
<h5 id="日期参数格式化-DateTimeFormat-pattern-”yyyy-MM-dd”"><a href="#日期参数格式化-DateTimeFormat-pattern-”yyyy-MM-dd”" class="headerlink" title="日期参数格式化@DateTimeFormat(pattern=”yyyy-MM-dd”)"></a>日期参数格式化@DateTimeFormat(pattern=”yyyy-MM-dd”)</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021223057976.png" alt="image-20241021223057976"></p>
<p>默认yyyy/MM/dd 其他形式不认识，需要自己手动指明formatPattern</p>
<h5 id="Converter接口-将字符串参数转换成Java类型"><a href="#Converter接口-将字符串参数转换成Java类型" class="headerlink" title="Converter接口-将字符串参数转换成Java类型"></a>Converter接口-将字符串参数转换成Java类型</h5><p>请求里面的参数都是以字符串形式发来的，converter要根据形参类型，把字符串转成对应类型提供给方法，这就是为什么前面能把字符串12按照需求转换成int 12</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021223621200.png" alt="image-20241021223621200"></p>
<p>@EnableWebMvc</p>
<h3 id="响应Response相关"><a href="#响应Response相关" class="headerlink" title="响应Response相关"></a>响应Response相关</h3><h4 id="响应页面（跳转页面）"><a href="#响应页面（跳转页面）" class="headerlink" title="响应页面（跳转页面）"></a>响应页面（跳转页面）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toPage&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toJumpPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接在方法里 return “page.jsp” </p>
<p>Spring默认认为Controller的方法返回的就是一个页面</p>
<h4 id="响应文本数据-ResponseBody"><a href="#响应文本数据-ResponseBody" class="headerlink" title="响应文本数据@ResponseBody"></a>响应文本数据@ResponseBody</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021225227708.png" alt="image-20241021225227708"></p>
<p>如果直接return一个字符串Spring会认为这个字符串是一个网页，响应分为响应行响应头和响应体，响应头里是放状态码之类的，只能在响应体里返回数据，加@ResponseBody注解表示返回值就是响应体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toText&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toText</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//表示返回 page.jsp 这个字符串</span></span><br></pre></td></tr></table></figure>

<h4 id="响应POJO对象-JSON形式"><a href="#响应POJO对象-JSON形式" class="headerlink" title="响应POJO对象(JSON形式)"></a>响应POJO对象(JSON形式)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toJsonPOJO&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">toJsonPOJO</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;返回json对象数据&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">15</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接返回user即可，jackson帮我们做的</p>
<h5 id="响应POJO对象集合（JSON数组）"><a href="#响应POJO对象集合（JSON数组）" class="headerlink" title="响应POJO对象集合（JSON数组）"></a>响应POJO对象集合（JSON数组）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toJsonList&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">toJsonList</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;返回json集合数据&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user1.setName(<span class="string">&quot;传智播客&quot;</span>);</span><br><span class="line">    user1.setAge(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user2.setName(<span class="string">&quot;黑马程序员&quot;</span>);</span><br><span class="line">    user2.setAge(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">    userList.add(user1);</span><br><span class="line">    userList.add(user2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="HttpMessageConverter接口"><a href="#HttpMessageConverter接口" class="headerlink" title="HttpMessageConverter接口"></a>HttpMessageConverter接口</h5><p>POJO转JSON字符串</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021225843796.png" alt="image-20241021225843796"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021225823024.png" alt="image-20241021225823024"></p>
<h3 id="REST-风格"><a href="#REST-风格" class="headerlink" title="REST 风格"></a>REST 风格</h3><p><strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021230252993.png" alt="image-20241021230252993"></p>
<p>根据请求的方式区分 GET POST PUT DELETE</p>
<p>同一URL，请求方式不同，调用的方法也不同</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021230150675.png" alt="image-20241021230150675"></p>
<p>RESTful：用REST风格访问资源</p>
<h4 id="RequestMapping-加-method-参数"><a href="#RequestMapping-加-method-参数" class="headerlink" title="@RequestMapping 加 method 参数"></a>@RequestMapping 加 method 参数</h4><p><code>@RequestMapping(value = &quot;/users/&#123;id&#125;&quot; ,method = RequestMethod.DELETE)</code> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021231918974.png" alt="image-20241021231918974"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021231836548.png" alt="image-20241021231836548"></p>
<h5 id="URL占位符传参-PathVariable"><a href="#URL占位符传参-PathVariable" class="headerlink" title="URL占位符传参 @PathVariable"></a>URL占位符传参 <mark>@PathVariable<mark></h5><p>value=”/users/{id}”  URL中的{id}和用@PathVariable修饰的方法参数id是一致的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021231846312.png" alt="image-20241021231846312"></p>
<h5 id="RequestBody-RequestParam-PathVariable"><a href="#RequestBody-RequestParam-PathVariable" class="headerlink" title="@RequestBody@RequestParam@PathVariable"></a>@RequestBody@RequestParam@PathVariable</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021232010983.png" alt="image-20241021232010983"></p>
<h4 id="RESTful-快速开发"><a href="#RESTful-快速开发" class="headerlink" title="RESTful 快速开发"></a><mark>RESTful 快速开发<mark></h4><h5 id="类级别注解-RequestMapping"><a href="#类级别注解-RequestMapping" class="headerlink" title="类级别注解 @RequestMapping"></a>类级别注解 @RequestMapping</h5><p>省去所有user前缀，写一次就好。</p>
<h5 id="类级别注解-RestController"><a href="#类级别注解-RestController" class="headerlink" title="类级别注解 @RestController"></a>类级别注解 @RestController</h5><p>类级别的@RequestBody，表示所有类的返回值都是请求体的数据，既然@Controller和RequestBody都要写，合而为一即可</p>
<h5 id="方法级别注解-PostMapping"><a href="#方法级别注解-PostMapping" class="headerlink" title="方法级别注解 @PostMapping"></a>方法级别注解 @PostMapping</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot; ,method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/&#123;id&#125;&quot;)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021232955549.png" alt="image-20241021232955549"></p>
<h4 id="RESTful-页面交互案例"><a href="#RESTful-页面交互案例" class="headerlink" title="RESTful 页面交互案例"></a>RESTful 页面交互案例</h4><p>RestController PostMapping GetMapping DeleteMapping PutMapping </p>
<p>方法参数RequestBody</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021235556399.png" alt="image-20241021235556399"></p>
<h5 id="Config-类-SpringMvcSupport-放行静态页面访问"><a href="#Config-类-SpringMvcSupport-放行静态页面访问" class="headerlink" title="Config 类 SpringMvcSupport 放行静态页面访问"></a>Config 类 SpringMvcSupport 放行静态页面访问</h5><p>@Configuration</p>
<p>默认SpringMvcConfig接管/后所有东西，通过ResourceHandlerRegistry 设置SpringMVC如何处理对静态资源的访问 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021235616215.png" alt="image-20241021235616215"></p>
<h5 id="前端ajax"><a href="#前端ajax" class="headerlink" title="前端ajax"></a>前端ajax</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021235623670.png" alt="image-20241021235623670"></p>
<h2 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h2><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><h3 id="整合Config包"><a href="#整合Config包" class="headerlink" title="整合Config包"></a>整合Config包</h3><h4 id="SpringConfig"><a href="#SpringConfig" class="headerlink" title="SpringConfig"></a>SpringConfig</h4><p><code>Configuration</code> <code>ComponentScan</code> <code>Import</code></p>
<h5 id="MyBatisConfig-amp-JdbcConfig"><a href="#MyBatisConfig-amp-JdbcConfig" class="headerlink" title="MyBatisConfig &amp; JdbcConfig"></a>MyBatisConfig &amp; JdbcConfig</h5><p>JdbcConfig：数据源 DataSource Bean</p>
<p>MyBatisConfig：sqlSessionFactoryBean</p>
<p><code>Bean</code> <code>jdbc.properties</code> </p>
<h4 id="SpringMvcConfig"><a href="#SpringMvcConfig" class="headerlink" title="SpringMvcConfig"></a>SpringMvcConfig</h4><p><code>Configuration</code> <code>ComponentScan</code> <code>EnableWebMvc</code></p>
<h5 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h5><p>rootApplicationContext和webApplicationContext</p>
<h3 id="编写后端模块"><a href="#编写后端模块" class="headerlink" title="编写后端模块"></a>编写后端模块</h3><h4 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h4><p>实体类，User</p>
<h4 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h4><p>MyBatis Mapper自动代理，写接口，写方法结合注解</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022135643205.png" alt="image-20241022135643205"></p>
<p>占位符对应参数的名称，这里映射实体类中的字段信息     </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022135845990.png" alt="image-20241022135845990"></p>
<h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>BookDao@Autowired</p>
<p>dao接口加repository注解（可加可不加）</p>
<h4 id="RestController"><a href="#RestController" class="headerlink" title="RestController"></a>RestController</h4><p>参数在url中：PathVariable</p>
<p>参数在请求体：RequestBody</p>
<h4 id="JUnit-测试-Service"><a href="#JUnit-测试-Service" class="headerlink" title="JUnit 测试 Service"></a>JUnit 测试 Service</h4><h4 id="Postman-测试-Controller"><a href="#Postman-测试-Controller" class="headerlink" title="Postman 测试 Controller"></a>Postman 测试 Controller</h4><h4 id="Spring-事务激活"><a href="#Spring-事务激活" class="headerlink" title="Spring 事务激活"></a>Spring 事务激活</h4><p><code>JdbcConfig</code> 里 加PlatformTransactionManager Bean, 接dataSource参数</p>
<p><code>Service</code>接口添加@Transactional</p>
<h3 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h3><h4 id="表现层数据封装模型-设置统一的返回结果集Result"><a href="#表现层数据封装模型-设置统一的返回结果集Result" class="headerlink" title="表现层数据封装模型 - 设置统一的返回结果集Result"></a>表现层数据封装模型 - 设置统一的返回结果集Result</h4><p>实际开发过程中前后端<mark>约定<mark></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">//下方提供若干构造方法,有参无参</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code,Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code, Object data, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....getter setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022152253512-1729581786093-1.png" alt="image-20241022152253512"></p>
<h5 id="Result-data"><a href="#Result-data" class="headerlink" title="Result.data"></a>Result.data</h5><p>业务方法不同返回数据格式也不同，可能是true false这样的text，也可能是json数据，还可能是json数组，约定将数据封装到<mark>data<mark>字段中</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022144637267.png" alt="image-20241022144637267"></p>
<h5 id="Result-code"><a href="#Result-code" class="headerlink" title="Result.code"></a>Result.code</h5><p>不同业务方法可能会返回相同的内容，返回一个true可能对应新增，修改，删除的业务方法，加一个识别码<mark>code<mark>字段区分 ，可以约定尾数是0表示失败，尾数是1表示成功：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022145108783.png" alt="image-20241022145108783"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SAVE_OK</span> <span class="operator">=</span> <span class="number">20011</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DELETE_OK</span> <span class="operator">=</span> <span class="number">20021</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">UPDATE_OK</span> <span class="operator">=</span> <span class="number">20031</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">GET_OK</span> <span class="operator">=</span> <span class="number">20041</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SAVE_ERR</span> <span class="operator">=</span> <span class="number">20010</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DELETE_ERR</span> <span class="operator">=</span> <span class="number">20020</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">UPDATE_ERR</span> <span class="operator">=</span> <span class="number">20030</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">GET_ERR</span> <span class="operator">=</span> <span class="number">20040</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里Result的构造器识别的是Integer code</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Enum枚举：CodeEnum是一个类，类内部有一字段code(Integer)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022152238169.png" alt="image-20241022152238169"></p>
<h5 id="Result-message"><a href="#Result-message" class="headerlink" title="Result.message"></a>Result.message</h5><p>一些业务方法，本来应该返回json，没查到只能返回null，不能直接把null展示给用户看，展示的是message信息</p>
<h5 id="Controller-返回值统一设定为-Result"><a href="#Controller-返回值统一设定为-Result" class="headerlink" title="Controller 返回值统一设定为 Result"></a>Controller 返回值统一设定为 Result</h5><p>将返回值封装到Result中，data</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Book&gt; bookList = bookService.getAll();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> bookList != <span class="literal">null</span> ? Code.GET_OK : Code.GET_ERR;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> bookList != <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;数据查询失败，请重试！&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(code,bookList,msg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//data字段是否为null？</span></span><br></pre></td></tr></table></figure>

<h4 id="返回数据格式统一-异常处理器-RestControllerAdvice"><a href="#返回数据格式统一-异常处理器-RestControllerAdvice" class="headerlink" title="返回数据格式统一 - 异常处理器@RestControllerAdvice"></a>返回数据格式统一 - 异常处理器<mark>@RestControllerAdvice<mark></h4><ul>
<li><p><mark>类级别注解<mark></p>
</li>
<li><p>后端抛出的异常如果不处理，就会抛到前端页面，不美观，并且不会返回任何数据，导致<mark>数据不统一<mark> </p>
</li>
<li><p>要让WebMvcConfig扫到这个Advice类</p>
</li>
</ul>
<h5 id="常见异常诱因"><a href="#常见异常诱因" class="headerlink" title="常见异常诱因"></a>常见异常诱因</h5><ul>
<li><strong>框架内部抛出的异常</strong>:因使用不合规导致</li>
<li><strong>数据层抛出的异常</strong>:因外部服务器故障导致(例如:服务器访问超时)</li>
<li><strong>业务层抛出的异常</strong>:因业务逻辑书写错误导致(例如:遍历业务书写操作，导致索引异常等)</li>
<li><strong>表现层抛出的异常</strong>:因数据收集、校验等规则导致(例如:不匹配的数据类型间导致异常)</li>
<li><strong>工具类抛出的异常</strong>:因工具类书写不严谨不够健壮导致(例如:必要释放的连接长期未释放等)</li>
</ul>
<p><u>处理方法</u>：全部抛到表现层Controller —— AOP 编程，<strong>用最少量的代码实现最强大的功能</strong>，快速统一地处理异常 </p>
<h5 id="方法级别注解-处理具体类别的异常-ExceptionHandler"><a href="#方法级别注解-处理具体类别的异常-ExceptionHandler" class="headerlink" title="方法级别注解 处理具体类别的异常@ExceptionHandler"></a>方法级别注解 处理具体类别的异常<mark>@ExceptionHandler<mark></h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022153703868.png" alt="image-20241022153703868"></p>
<p>处理异常返回的结果也要封装成Result</p>
<h3 id="项目异常处理方案-捕获异常并返回Result"><a href="#项目异常处理方案-捕获异常并返回Result" class="headerlink" title="项目异常处理方案 (捕获异常并返回Result)"></a>项目异常处理方案 (捕获异常并返回Result)</h3><h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><ul>
<li><strong>业务异常 BusinessException</strong> 可预期<ul>
<li>发送对应消息，提醒用户规范操作</li>
</ul>
</li>
<li><strong>系统异常 SystemException</strong> <ul>
<li>发送固定消息，安抚用户</li>
<li>发送特定消息给运维，提醒维护</li>
<li>记录日志</li>
</ul>
</li>
<li><strong>其他异常 Exception</strong><ul>
<li>发送固定消息，安抚用户</li>
<li>发送特定消息给开发，提醒维护（纳入预期范围）</li>
<li>记录日志</li>
</ul>
</li>
</ul>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022154704744.png" alt="image-20241022154704744"></p>
<h5 id="继承RuntimeException"><a href="#继承RuntimeException" class="headerlink" title="继承RuntimeException"></a>继承RuntimeException</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022155606802.png" alt="image-20241022155606802"></p>
<p>加一个code属性（getter setter），重写RuntimeException的方法。异常构造的时候需要用到这些构造器，包装返回数据要用到code和message</p>
<p>建议放在源根的exception包下面</p>
<h5 id="异常代码扩充"><a href="#异常代码扩充" class="headerlink" title="异常代码扩充"></a>异常代码扩充</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022160311854.png" alt="image-20241022160311854"></p>
<h5 id="触发异常"><a href="#触发异常" class="headerlink" title="触发异常"></a>触发异常</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022160332391.png" alt="image-20241022160332391"></p>
<h5 id="拦截并处理异常-返回Result"><a href="#拦截并处理异常-返回Result" class="headerlink" title="拦截并处理异常 返回Result"></a>拦截并处理异常 返回Result</h5><p>在RestControllerAdvice下方的类中处理对应类型的异常，将异常继续封装成Result返回</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022160546843.png" alt="image-20241022160546843"></p>
<h3 id="放行静态资源配置"><a href="#放行静态资源配置" class="headerlink" title="放行静态资源配置"></a>放行静态资源配置</h3><h4 id="SpringMvcSupport（Config类）"><a href="#SpringMvcSupport（Config类）" class="headerlink" title="SpringMvcSupport（Config类）"></a>SpringMvcSupport（Config类）</h4><p>加Configuration注解，继承WebMvcConfigurationSupport类，重写resourceHandler方法</p>
<h4 id="Config包详解"><a href="#Config包详解" class="headerlink" title="Config包详解"></a><mark>Config包详解<mark></h4><h5 id="ServletContainersInitializerConfig-Servlet容器配置类"><a href="#ServletContainersInitializerConfig-Servlet容器配置类" class="headerlink" title="ServletContainersInitializerConfig (Servlet容器配置类)"></a>ServletContainersInitializerConfig (Servlet容器配置类)</h5><p>用来构建ServletContext，继承自 AbstractDispatcherServletInitializer，Spring MVC是建立在 DispatcherServlet 基础之上的，每一个请求最先访问的都是它，负责转发每一个Request请求，所以是必不可少的。</p>
<p>先以 <mark>Abstract<u>DispatcherServlet</u>Initializer<mark> 为例介绍这个加载Config类的职责 具体介绍在<a href="#webappinit">下方</a></p>
<h6 id="a-createRootApplicationContext"><a href="#a-createRootApplicationContext" class="headerlink" title="a. createRootApplicationContext"></a>a. createRootApplicationContext</h6><p>需要加载Spring IoC容器的配置类(SpringConfig)，返回配置好的 <a href="#wac">Root WAC</a> </p>
<h6 id="b-createServletApplicationContext"><a href="#b-createServletApplicationContext" class="headerlink" title="b.createServletApplicationContext"></a>b.createServletApplicationContext</h6><p>需要加载WebMvc容器的配置类(SpringMvcConfig) 返回配置好的 <a href="#swac">Servlet WAC</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022205635235.png" alt="image-20241022205635235"></p>
<h6 id="c-getServletMappings"><a href="#c-getServletMappings" class="headerlink" title="c.getServletMappings"></a>c.getServletMappings</h6><p>配置由此DispatcherServlet接管的URL映射路径</p>
<h5 id="SpringConfig-Configuration"><a href="#SpringConfig-Configuration" class="headerlink" title="SpringConfig(@Configuration)"></a>SpringConfig(@Configuration)</h5><p><u>对应applicationContext.xml</u>，配置 <a href="#wac">Root WAC</a>  </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zzjlxy-225223/p/12611093.html">applicationContext.xml及spring-servlet.xml详解 - 长木木弓 - 博客园 (cnblogs.com)</a>  </p>
<p>注解开发用来替代传统的XML配置文件，因此可以透过xml与注解的映射关系来了解，<code>@Configuration</code>用来替代<code>&lt;beans&gt;</code> <code>&lt;/beans&gt;</code> 在应用启动时，Spring 会自动扫描并加载所有带有 <code>@Configuration</code> 注解的类，根据<code>@ComponentScan</code>扫描要加入的<code>@Component</code>(代替<code>&lt;bean&gt;</code> <code>&lt;/bean&gt;</code>)，最终创建出对应的容器(Context) </p>
<h6 id="Import-MyBatisConfig-class-JdbcConfig-class"><a href="#Import-MyBatisConfig-class-JdbcConfig-class" class="headerlink" title="@Import({MyBatisConfig.class,JdbcConfig.class})"></a>@Import({MyBatisConfig.class,JdbcConfig.class})</h6><p><code>MyBatisConfig</code> 和 <code>JdbcConfig</code>中方法级别注解<code>@Bean</code>用来替代 <code>&lt;bean&gt;</code> <code>&lt;/bean&gt;</code> 标签（表示方法返回的对象当成Bean/Component交给Spring容器管理）虽然没有加<code>Configuration</code>注解，但是会由<code>SpringConfig</code> <code>@Import</code>，导入的还是SpringConfig配置的容器，属于 <a href="#wac">Root WAC</a> </p>
<h5 id="SpringMvcConfig-Configuration-EnableWebMvc"><a href="#SpringMvcConfig-Configuration-EnableWebMvc" class="headerlink" title="SpringMvcConfig(@Configuration @EnableWebMvc)"></a>SpringMvcConfig(@Configuration @EnableWebMvc)</h5><p><u>对应spring-servlet.xml</u>，配置 <a href="#swac">Servlet WAC</a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/EnableWebMvc.html">@EnableWebMvc (Spring Framework 6.1.14 API)</a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurationSupport.html">WebMvcConfigurationSupport (Spring Framework 6.1.14 API)</a>  (WMCS)</p>
<ul>
<li><p><code>@EnableWebMvc</code> 会通过导入 <code>WMCS</code> 完成 Spring MVC 默认配置的添加，<strong>只有一个类能拥有此注解</strong> </p>
</li>
<li><p>不写 <code>@EnableWebMvc</code> 直接继承 WMCS 也可以实现相同效果</p>
</li>
<li><p>自定义具体某项WebMvc配置：<code>extends WebMvcConfigurer</code> 允许多个WebMvcConfigurer存在，但是具有一定侵入性</p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023210351697.png" alt="image-20241023210351697"></p>
<ul>
<li>主要Config：<code>@EnableWebMvc</code> + 继承 <code>WebMvcConfigurer</code> 重写方法 + <code>@ComponentScan</code> 其他Config类</li>
<li>次要Config：继承 <code>WebMvcConfigurer</code>重写方法+@Configuration确保被主要Config扫描到</li>
<li>没有暴露高级设置，如果需要高级设置 需要第二种方式直接继承 WMCS 来做更高级别的配置，此时要移除@Enable注解</li>
</ul>
<h6 id="SpringMvcSupport-Configuration"><a href="#SpringMvcSupport-Configuration" class="headerlink" title="SpringMvcSupport(@Configuration)"></a>SpringMvcSupport(@Configuration)</h6><p><u>对应springMvcContext.xml</u>，配置 <a href="#swac">Servlet WAC</a> </p>
<ul>
<li>继承WMCS，完成对SpringMVC的默认配置，重写resourceHandler方法，实现在默认配置基础上的自定义。</li>
<li>案例中的SMS是配置类，用于配置容器，被SMC扫config包扫到了，此时SMS这里的自定义配置会覆盖SMC的Enable注解</li>
</ul>
<h3 id="前端逻辑"><a href="#前端逻辑" class="headerlink" title="前端逻辑"></a>前端逻辑</h3><p>查询： get请求</p>
<p>保存/添加：post请求</p>
<p>新增要弹出表单，添加成功要关闭表单并<strong>清空表单数据</strong>，不论成功与否finallyGetAll回显 ，按照识别码判别成功与否</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023190220059.png" alt="image-20241023190220059"></p>
<p>修改：put请求</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023191646261.png" alt="image-20241023191646261"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023191751771.png" alt="image-20241023191751771"></p>
<p>删除：delete请求</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023191526268.png" alt="image-20241023191526268"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023191952545.png" alt="image-20241023191952545"></p>
<h3 id="容器之间的嵌套关系-概念解释-源码解析"><a href="#容器之间的嵌套关系-概念解释-源码解析" class="headerlink" title="容器之间的嵌套关系 + 概念解释 (源码解析)"></a>容器之间的嵌套关系 + 概念解释 (源码解析)</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022175254007-1729595662475-3.png" alt="image-20241022175254007"></p>
<h4 id="WebApplicationContext-WAC"><a href="#WebApplicationContext-WAC" class="headerlink" title="WebApplicationContext(WAC)"></a><span id="wac">WebApplicationContext(WAC)</span></h4><ul>
<li>ApplicationContext(AC) 表示整个 Spring 应用的上下文。WAC是普通AC的扩展，它具有Web应用程序所需的一些额外功能，比如可以<u>get</u>ServletContext或者<u>set</u>ServletContext</li>
<li><code>Root WAC</code>在应用启动时首先被加载，并且作为父上下文，供表示层使用，主要负责管理服务层（Service）、数据访问层（DAO）、中间件配置等非 Web 层（表示层）的 Bean</li>
</ul>
<h4 id="Servlet-WebApplicationContext-Servlet-WAC"><a href="#Servlet-WebApplicationContext-Servlet-WAC" class="headerlink" title="Servlet WebApplicationContext(Servlet WAC)"></a><span id="swac">Servlet WebApplicationContext(Servlet WAC)</span></h4><ul>
<li><code>Servlet WAC</code> 是 <code>Root WAC</code> 的<strong>子上下文</strong>，专门用于处理表示层的 Bean 和配置。比如控制器（<code>Controller</code>）、视图解析器、拦截器(<code>Interceptor</code>)等</li>
<li>每个 <code>DispatcherServlet</code> 实例会有一个独立的 <code>Servlet WAC</code> </li>
</ul>
<h5 id="Parent-amp-Child-ApplicatitonContext"><a href="#Parent-amp-Child-ApplicatitonContext" class="headerlink" title="Parent &amp; Child ApplicatitonContext"></a>Parent &amp; Child ApplicatitonContext</h5><p>Root WAC 作为 所有 Servlet WAC 的 Parent，DispatherServlet在创建属于自己的ServletContext的getAttribute方法来判断是否存在Root WebApplicationContext。如果存在，则将其设置为自己的parent。这就是父子上下文(父子容器)的概念，getParentBeanFactory。</p>
<p>对于作用范围而言，在DispatcherServlet中可以引用由ContextLoaderListener所创建的RootWAC中的内容，而反过来不行。当Spring在执行ApplicationContext的getBean时，如果在自己context中找不到对应的bean，则会在父ApplicationContext中去找。这也解释了为什么我们可以在DispatcherServlet中获取到RootWAC中的bean。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023154504980.png" alt="image-20241023154504980"></p>
<h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><ul>
<li>Servlet容器（Tomcat）在启动一个web应用时，根据web.xml 会为整个应用创建一个<mark>唯一<mark>的ServletContext(SC)对象，应用内部所有的Servlet共享同一个SC。</li>
<li>ServletContext是Servlet与Servlet容器（Tomcat）之间直接通信的接口。</li>
<li>容器中的Servlet可以通过它来访问容器中的各种资源</li>
<li>ServletContext跟XML一样，由Attributes组成，要访问资源就要通过字符串name访问，可以通过<code>void setAttribute(name, object) </code>来将ServletContext与你的object绑定，<code>Object getAttribute(name)</code>可以得到object</li>
<li><code>Enumeration&lt;String&gt; getInitParameterNames()</code> 获取所有 <code>&lt;context-param/&gt;</code> 参数的名称 字符串枚举</li>
<li><code> String getInitParameter(name)</code> 根据name获取指定的 <code>&lt;context-param/&gt;</code> 参数值</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023013135254.png" alt="image-20241023013135254"></p>
<h5 id="Root-WAC-Servlet-WAC-ServletContext之间的关系"><a href="#Root-WAC-Servlet-WAC-ServletContext之间的关系" class="headerlink" title="Root WAC, Servlet WAC, ServletContext之间的关系"></a>Root WAC, Servlet WAC, ServletContext之间的关系</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022230909096.png" alt="image-20241022230909096"></p>
<ul>
<li><p>Root WebApplicationContext存储key为<code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>，可以通过此Key访问Root WAC。</p>
</li>
<li><p>WebApplicationContextUtis工具类提供了从ServletContext获取RootWAC的方法：</p>
<ul>
<li><code>WebApplicationContextUtils.getWebApplicationContext(ServletContext sc)</code></li>
</ul>
</li>
<li><p>WAC提供了获取ServletContext的抽象方法 <code>getServletContext()</code> </p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E6%97%A0%E6%A0%87%E9%A2%98-1729654361571-5.png" alt="context"></p>
<h5 id="web-xml-配置-ServletContext"><a href="#web-xml-配置-ServletContext" class="headerlink" title="web.xml 配置 ServletContext"></a>web.xml 配置 ServletContext</h5><p>Tomcat创建web应用时，会构建ServletContext对象，根据web.xml中的配置把如下参数都存到ServletContext对象中，注册Listener，Servlet等</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line">    &lt;!—ServletContext自有的init 参数--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span>  </span><br><span class="line">        &lt;!—创建Root WAC所需要的配置文件路径--&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span>  </span><br><span class="line">  	</span><br><span class="line">    &lt;!—注册ContextLoaderListener--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line">    &lt;!—注册DispatcherServlet ServletConfig--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span> </span><br><span class="line">        &lt;!—init Servlet所需参数--&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">            &lt;!—创建Servlet WAC所需参数--&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/spring-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line">        &lt;!—指定某个servlet的URL映射路径--&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="ContextLoaderListener-创建-Root-WAC"><a href="#ContextLoaderListener-创建-Root-WAC" class="headerlink" title="ContextLoaderListener - 创建 Root WAC"></a>ContextLoader<mark>Listener<mark> - 创建 Root WAC</h4><ul>
<li><p>本质就是一个Listener，因此需要在web.xml中注册</p>
</li>
<li><p>实现了ServletContextListener接口，EventListener-&gt;ServletContextListener</p>
</li>
<li><p>继承了ContextLoader类，见名知意，是用来加载WAC的，有一个WAC参数context，所有方法都是围绕加工这个context字段进行的</p>
</li>
</ul>
<h5 id="WebApplicationContext-initWAC-ServletContext-sc"><a href="#WebApplicationContext-initWAC-ServletContext-sc" class="headerlink" title="WebApplicationContext initWAC(ServletContext sc)"></a>WebApplicationContext initWAC(ServletContext sc)</h5><p>ContextLoaer 接收一个ServletContext参数sc，调用initWAC方法返回加载好的WAC对象this.context</p>
<p>打印在服务器日志上 <code>servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);</code></p>
<p>中间调用<code>createWAC(ServletContext sc)</code>返回一个ConfigurableWAC对象，将其<strong>parentContext设置为sc</strong>，</p>
<p>再把这个CWAC和sc传给<code>configureAndRefreshWAC(CWAC cwac,ServletContext sc)</code>方法进行配置（ServletContext是根据web.xml构建的，根据key: contextConfigLocation找到RootWAC的配置文件<code>applicationContext.xml</code>）</p>
<p>之后在sc中创建一个Attribute，使得能通过ServletContext对这个Root WAC进行访问（键值对形式）</p>
<p><code>setAttribute(</code> <code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>, <code>this.context)</code></p>
<p>最终返回 <code>this.context</code> 作为 Root WAC</p>
<h5 id="WebApplicationContext-contextInitialized-ServletContextEvent-sce"><a href="#WebApplicationContext-contextInitialized-ServletContextEvent-sce" class="headerlink" title="WebApplicationContext contextInitialized(ServletContextEvent sce)"></a>WebApplicationContext contextInitialized(ServletContextEvent sce)</h5><p>ContextLoaderListener 能监听Web应用启动或关闭的事件（会修改ServletContext中的参数），触发contextInitializaed/contextDestroyed，创建或销毁Root WAC。</p>
<h4 id="DispatcherServlet-创建-Servlet-WAC"><a href="#DispatcherServlet-创建-Servlet-WAC" class="headerlink" title="DispatcherServlet - 创建 Servlet WAC"></a>Dispatcher<mark>Servlet<mark> - 创建 Servlet WAC</h4><ul>
<li><p>本质就是一个Servlet，所以需要在web.xml中注册，继承自HttpServlet-&gt;HttpServletBean-&gt;FrameworkServlet</p>
</li>
<li><p>Spring MVC 的核心前端控制器，用于处理所有进入的 HTTP 请求。将请求分发给适当的处理器（控制器 Controller），并在处理后将响应返回给客户端。</p>
</li>
<li><p>每一个 <code>DispatcherServlet</code> 都拥有自己的 <a href="#swac">Servlet WebApplicationContext</a>，管理与 Web 层(表现层)相关的 Bean，如控制器、视图解析器、拦截器等。</p>
</li>
<li><p>HttpServletBean有一个final的init()<strong>[Servlet的入口方法]</strong>  其中会调用抽象方法initServletBean()</p>
</li>
<li><p>FrameServlet实现了initServletBean(): <strong>[生成Servlet WAC，设置parent和ServletContext]</strong> 最后会调用initStrategies</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">var10000</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line"><span class="type">String</span> <span class="variable">var10001</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getSimpleName();</span><br><span class="line">var10000.log(<span class="string">&quot;Initializing Spring &quot;</span> + var10001 + <span class="string">&quot; &#x27;&quot;</span> + <span class="built_in">this</span>.getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"><span class="comment">//记录日志</span></span><br></pre></td></tr></table></figure>

<ul>
<li>同样的，途中也会调用自己的initWAC方法：<ul>
<li>调用WACUtils工具类，获得自己所在的ServletContext的<strong>Root WAC</strong> </li>
<li>将自己的WAC转换成CWAC，如果存在RootWAC，则将其设置为自己的parent</li>
<li>然后configureAndRefreshWAC(cwac)：设置ServletContext为sc，从其中ServletConfig中获取 <code>&lt;init-param&gt;</code> 参数的值</li>
</ul>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023013013442.png" alt="image-20241023013013442"></p>
<ul>
<li>最后根据自己的ServletConfig获取到ServletContext，根据自己的名称设置自己的Servlet WAC在ServletContext中的Key</li>
</ul>
</li>
<li><p>DispatcherServlet实现了initStrategies [生成各个功能组件，异常处理器，视图处理，请求映射]</p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/mvc-context-hierarchy.png" alt="mvc-context-hierarchy"></p>
<p>这两个context都是在ServletContext中，属于dispatcherServlet的上下文是servletWAC，找不到的话就去rootWAC中找</p>
<h4 id="替代web-xml，以Java形式配置ServletContext——WebApplicationInitializer"><a href="#替代web-xml，以Java形式配置ServletContext——WebApplicationInitializer" class="headerlink" title="替代web.xml，以Java形式配置ServletContext——WebApplicationInitializer"></a><span id="webappinit">替代web.xml，以Java形式配置ServletContext——WebApplicationInitializer</span></h4><p>![屏幕截图 2024-10-23 133904](<a target="_blank" rel="noopener" href="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/屏幕截图</a> 2024-10-23 133904.png)</p>
<h5 id="ServletContainerInitializer"><a href="#ServletContainerInitializer" class="headerlink" title="ServletContainerInitializer"></a>ServletContainerInitializer</h5><p>之前，web容器（Tomcat）会根据WEB-INF下的web.xml初始化ServletContext</p>
<p>Java EE Servlet 规范定义了这个接口，web容器（Tomcat）启动时根据这个初始化器做一些组件内的初始化工作。 </p>
<p><strong>SpringServletContainerInitializer</strong> 是Spring 对其的实现，其onStartup方法会调用 <strong><a href="#webappinit">WebApplicationInitializer</a></strong> 的onStartup(<strong>ServletContext sc</strong>)初始化Web应用</p>
<h4 id="SpringMVC-Web应用启动流程"><a href="#SpringMVC-Web应用启动流程" class="headerlink" title="SpringMVC Web应用启动流程"></a>SpringMVC Web应用启动流程</h4><ul>
<li>Tomcat 读取web.xml中 <code>&lt;context-param&gt;</code> <code>&lt;listener&gt;</code>  然后创建一个全局共享的ServletContext</li>
<li>Tomcat 将<code>&lt;context-param&gt;</code> <code>&lt;listener&gt;</code>转化为键值对，存到ServletContext </li>
<li>Tomcat 加载Listener实例，实施监听，Listener必须实现<u>ServletContext</u>Listener接口（比如ContextLoaderListener）</li>
<li><strong>Web项目继续启动中</strong>，触发Listener中的contextInitialized(ServletContexEvent event)，根据ServletContext中 <code>&lt;context-param&gt;</code> 部分创建父容器，configClass是类的形式，configLocation是xml配置文件的形式</li>
<li>创建完父容器，如果有<code>&lt;filter&gt;</code>会创建filter，然后读取 <code>&lt;servlet&gt;</code> 用于注册DispatcherServlet（这块流程建议从init方法一步步往下看，流程还是很清晰的），因为DispatcherServlet实质是一个Servlet，所以会先执行它的init方法。这个init()方法在<strong>HttpServletBean</strong>这个类中实现，其主要工作是做一些初始化工作，将我们在web.xml中配置的参数设置到ServletContext的ServletConfig中，然后再触发<strong>FrameworkServlet</strong>的initServletBean()方法；<ul>
<li><strong>FrameworkServlet</strong>主要作用是初始化Spring子容器，设置其父容器，并将其放入ServletContext中；</li>
<li><strong>FrameworkServlet</strong>在调用initServletBean()的过程中同时会触发<strong>DispatcherServlet</strong>的onRefresh()方法，这个方法会初始化Spring MVC的各个功能组件。比如异常处理器、视图处理器、请求映射处理等</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/54chensongxia/p/12522804.html">Spring MVC启动流程</a> </p>
<h5 id="100-code-based"><a href="#100-code-based" class="headerlink" title="100% code-based"></a>100% code-based</h5><p>用Java类的形式配置ServletContext，有一些细微差异，Spring这边实现了ServletContainerInitializer接口，注册组件的工作就交给了WebApplicationInitializer：</p>
<p>先根据指定的rootWacConfig配置类（SpringConfig）创建出父容器，父容器作为参数进行Listener的有参构造，最后以<mark>add<mark>Listener的方式注册到ServletContext中。</p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023193138396.png" alt="image-20241023193138396"></p>
<h4 id="Interceptor-vs-Filter"><a href="#Interceptor-vs-Filter" class="headerlink" title="Interceptor vs Filter"></a>Interceptor vs Filter</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023193414214.png" alt="image-20241023193414214"></p>
<p>filter在一定是在访问servlet之前，interceptor只能在servlet中， <mark>before Controller<mark></p>
<h3 id="功能类"><a href="#功能类" class="headerlink" title="功能类"></a>功能类</h3><p>控制表现层：controller下新建interceptor包，新建一个Interceptor类 <strong>extends HandlerInterceptor</strong> </p>
<p>注意preHandle返回值和@Component</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023210048371.png" alt="image-20241023210048371"></p>
<h4 id="SpringMvcSupport"><a href="#SpringMvcSupport" class="headerlink" title="SpringMvcSupport"></a>SpringMvcSupport</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023205518460.png" alt="image-20241023205518460"></p>
<p>addInterceptors 自动注入自定义拦截器</p>
<p>addPathPatterns 加的不是前缀，<mark>是严格的URL匹配<mark>，配/books就拦截对/books发的请求，/books/100就拦截不了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023205715345.png" alt="image-20241023205715345"></p>
<p><mark>preHandle<mark>，yourService，postHandle，afterCompletion 顺序</p>
<h4 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023210636045.png" alt="image-20241023210636045"></p>
<h4 id="简化开发"><a href="#简化开发" class="headerlink" title="简化开发"></a>简化开发</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023210528299.png" alt="image-20241023210528299"></p>
<p>已经和Spring接口绑定，侵入性强。</p>
<h3 id="拦截方法参数配置"><a href="#拦截方法参数配置" class="headerlink" title="拦截方法参数配置"></a>拦截方法参数配置</h3><h4 id="boolean-preHandle-req-resp-handler"><a href="#boolean-preHandle-req-resp-handler" class="headerlink" title="boolean preHandle(req,resp,handler)"></a>boolean preHandle(req,resp,<mark>handler<mark>)</h4><p>req和resp是servlet的响应和请求，handler实际上是HandlerMethod，通过getMethod能拿到执行的业务方法的对象（反射）</p>
<h4 id="void-postHandle-req-resp-handler-modelAndView"><a href="#void-postHandle-req-resp-handler-modelAndView" class="headerlink" title="void postHandle(req,resp,handler,modelAndView)"></a>void postHandle(req,resp,<mark>handler<mark>,modelAndView)</h4><p>页面跳转相关。</p>
<h4 id="void-afterCompletion-req-resp-handler-exception"><a href="#void-afterCompletion-req-resp-handler-exception" class="headerlink" title="void afterCompletion(req,resp,handler,exception)"></a>void afterCompletion(req,resp,<mark>handler<mark>,exception)</h4><p>能拿到原始业务方法执行过程中的异常</p>
<h3 id="拦截链顺序"><a href="#拦截链顺序" class="headerlink" title="拦截链顺序"></a>拦截链顺序</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023211911820.png" alt="image-20241023211911820"></p>
<p>拦截顺序，和注册顺序有关系</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023212439810.png" alt="image-20241023212439810"></p>
<p>如果某个pre返回false，post全部跳过，倒序执行，从最近一个pre返回true的拦截器开始执行afterCompletion</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023212527269.png" alt="image-20241023212527269"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/penriver/article/details/118571991">万字详解 GoF 23 种设计模式（多图、思维导图、模式对比），让你一文全面理解-CSDN博客</a></p>
<h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><h2 id="入门案例——Web项目"><a href="#入门案例——Web项目" class="headerlink" title="入门案例——Web项目"></a>入门案例——Web项目</h2><h3 id="创建boot模块"><a href="#创建boot模块" class="headerlink" title="创建boot模块"></a>创建boot模块</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dream_ready/article/details/134639886">idea创建不了spring2.X版本，无法使用JDK8，最低支持JDK17 ， 如何用idea创建spring2.X版本，使用JDK8解决方案_spring3不支持jdk8-CSDN博客</a></p>
<p>SpringBoot2停止维护，SpringBoot3最低Java17</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025190302057.png" alt="image-20241025190302057"></p>
<h3 id="写控制器类"><a href="#写控制器类" class="headerlink" title="写控制器类"></a>写控制器类</h3><p>把controller类写好</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025194037167.png" alt="image-20241025194037167"></p>
<h3 id="启动app"><a href="#启动app" class="headerlink" title="启动app"></a>启动app</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025194052846.png" alt="image-20241025194052846"></p>
<h2 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h2><h3 id="打包—jar"><a href="#打包—jar" class="headerlink" title="打包—jar"></a>打包—jar</h3><p><code>package</code> 之前 <code>clean</code> 全部设置为UTF-8参数</p>
<h3 id="命令行启动-java-jar"><a href="#命令行启动-java-jar" class="headerlink" title="命令行启动 java -jar"></a>命令行启动 java -jar</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025194844475.png" alt="image-20241025194844475"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025194925821.png" alt="image-20241025194925821"></p>
<p>jar执行要有入口类，boot打包需要插件才能生成可执行的入口类</p>
<h2 id="简述boot"><a href="#简述boot" class="headerlink" title="简述boot"></a>简述boot</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025195226537.png" alt="image-20241025195226537"></p>
<h3 id="starter-起步依赖"><a href="#starter-起步依赖" class="headerlink" title="starter 起步依赖"></a>starter 起步依赖</h3><h3 id="starter-parent-依赖管理"><a href="#starter-parent-依赖管理" class="headerlink" title="starter-parent 依赖管理"></a>starter-parent 依赖管理</h3><p>starter-parent：定义了无数jar包的版本管理和依赖管理，减少依赖冲突。只写GA 不写V</p>
<h3 id="dependencies-辅助功能"><a href="#dependencies-辅助功能" class="headerlink" title="dependencies-辅助功能"></a>dependencies-辅助功能</h3><p>每一个dependency（以web包为例）把真正需要用到的jar包声明，去找parent要即可</p>
<p>spring-boot-starter-web: </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025201404198.png" alt="image-20241025201404198"></p>
<p>spring-boot-dependencies: </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025201443556.png" alt="image-20241025201443556"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025201805886.png" alt="image-20241025201805886"></p>
<h3 id="替换starter的某个依赖"><a href="#替换starter的某个依赖" class="headerlink" title="替换starter的某个依赖"></a>替换starter的某个依赖</h3><p>依赖排除exclusion，换技术</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025202142653.png" alt="image-20241025202142653"></p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="resources目录下配置文件加载优先级"><a href="#resources目录下配置文件加载优先级" class="headerlink" title="resources目录下配置文件加载优先级"></a>resources目录下配置文件加载优先级</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025204356892.png" alt="image-20241025204356892"></p>
<p>properties&gt;<mark>yml<mark>&gt;yaml</p>
<h3 id="自动提示功能消失—引入配置文件到boot模块中"><a href="#自动提示功能消失—引入配置文件到boot模块中" class="headerlink" title="自动提示功能消失—引入配置文件到boot模块中"></a>自动提示功能消失—引入配置文件到boot模块中</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025204437530.png" alt="image-20241025204437530"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025204503008.png" alt="image-20241025204503008"></p>
<p>debug&gt;info&gt;warn</p>
<h3 id="YAML—-YAML-Ain’t-Markup-Language"><a href="#YAML—-YAML-Ain’t-Markup-Language" class="headerlink" title="YAML—(YAML Ain’t Markup Language)"></a>YAML—(YAML Ain’t Markup Language)</h3><h4 id="YAML-简介"><a href="#YAML-简介" class="headerlink" title="YAML 简介"></a>YAML 简介</h4><p>Jamel  Camel</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025204800590.png" alt="image-20241025204800590"></p>
<h4 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025204945594.png" alt="image-20241025204945594"></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空格数量不限，只要前面格数一样就是同一级，不允许使用tab缩进</span></span><br><span class="line"><span class="attr">enterprise:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">John</span></span><br><span class="line"> <span class="attr">likes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Java</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Python</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">C++</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025205033642.png" alt="image-20241025205033642"></p>
<h3 id="以Java方式读取yaml配置文件"><a href="#以Java方式读取yaml配置文件" class="headerlink" title="以Java方式读取yaml配置文件"></a>以Java方式读取yaml配置文件</h3><h4 id="读取单个数据—定义成员变量-Value-enterprise-subject"><a href="#读取单个数据—定义成员变量-Value-enterprise-subject" class="headerlink" title="读取单个数据—定义成员变量@Value(${enterprise.subject)"></a>读取单个数据—定义成员变量@Value(${enterprise.subject)</h4><p>自动赋值</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025205805383.png" alt="image-20241025205805383"></p>
<h4 id="读取全部数据—Environment对象"><a href="#读取全部数据—Environment对象" class="headerlink" title="读取全部数据—Environment对象"></a>读取全部数据—Environment对象</h4><p>定义一个Environment，自动装配，将配置中的属性全部遍历:</p>
<p><code>environment.getProperty(&quot;name&quot;)</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025210024893.png" alt="image-20241025210024893"></p>
<h4 id="自定义对象封装指定数据-Component-ConfigurationProperties-prefix-enterprise"><a href="#自定义对象封装指定数据-Component-ConfigurationProperties-prefix-enterprise" class="headerlink" title="自定义对象封装指定数据@Component@ConfigurationProperties(prefix = enterprise)"></a><strong>自定义对象封装指定数据</strong>@Component@ConfigurationProperties(prefix = enterprise)</h4><p>可以拿到需要的某个属性的信息(prefix)</p>
<p>在控制器中定义成员变量自动装配，常用</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025210946272.png" alt="image-20241025210710013"></p>
<h5 id="自定义对象封装数据警告"><a href="#自定义对象封装数据警告" class="headerlink" title="自定义对象封装数据警告"></a>自定义对象封装数据警告</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025211036999.png" alt="image-20241025211036999"></p>
<h3 id="多环境开发"><a href="#多环境开发" class="headerlink" title="多环境开发"></a>多环境开发</h3><h4 id="生产环境设定"><a href="#生产环境设定" class="headerlink" title="生产环境设定"></a>生产环境设定</h4><p><strong>独立生产环境设定</strong>：</p>
<p><code>spring.profiles</code> <strong>boot2</strong></p>
<p><code>spring.config.activate.on-profile</code> <strong>boot3</strong></p>
<p><code>---</code> 三条横线分割配置</p>
<p><code>spring.profiles.active</code> 设置激活的环境</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025214421983.png" alt="image-20241025214421983"></p>
<h4 id="带参数启动boot"><a href="#带参数启动boot" class="headerlink" title="带参数启动boot"></a>带参数启动boot</h4><h5 id="命令行参数临时修改配置内容"><a href="#命令行参数临时修改配置内容" class="headerlink" title="命令行参数临时修改配置内容"></a>命令行参数临时修改配置内容</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改启动环境为test</span></span><br><span class="line">java -jar boot_1.0_SNAPSHOT.jar --spring.profiles.active=<span class="built_in">test</span></span><br><span class="line"><span class="comment"># 修改服务器端口号为88</span></span><br><span class="line">java -jar boot_1.0_SNAPSHOT.jar --server.port=88</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="参数加载优先级"><a href="#参数加载优先级" class="headerlink" title="参数加载优先级"></a>参数加载优先级</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025215406246.png" alt="image-20241025215406246"></p>
<h4 id="maven-amp-boot开发环境兼容—加载配置文件"><a href="#maven-amp-boot开发环境兼容—加载配置文件" class="headerlink" title="maven&amp;boot开发环境兼容—加载配置文件"></a>maven&amp;boot开发环境兼容—加载配置文件</h4><p>maven和boot都设置了多环境，但是打包工作是maven负责，所以maven应该占主导</p>
<p>手动配置resources插件，覆盖parent设定</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hcgk/p/17600908.html">maven-resources-plugin详解 - 红尘过客2022 - 博客园 (cnblogs.com)</a></p>
<h5 id="lt-resources-gt-lt-filtering-gt"><a href="#lt-resources-gt-lt-filtering-gt" class="headerlink" title="&lt;resources&gt; (&lt;filtering&gt;)"></a><code>&lt;resources&gt;</code> (<code>&lt;filtering&gt;</code>)</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026013908079.png" alt="image-20241026013908079"></p>
<p><code>&lt;resources&gt;</code>标签其实就是<code>maven-resources-plugin</code>的<code>&lt;resources&gt;</code>配置，主要用来配置资源目录的。普通项目没有<code>parent</code>，默认继承<code>父pom.xml</code>: </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026024547372.png" alt="image-20241026024547372"></p>
<p>可以看到<code>resources</code>默认就是项目下的<code>src/main/resources</code>，但是没开过滤<code>filtering</code>，所以之前maven课程中，<u>在配置文件中引入占位符还得重写一遍resources标签。</u></p>
<p>而boot模块默认继承的starter-parent默认的<code>resources</code>标签是开了过滤的，而且资源明确<code>包括application.yml</code>这种配置文件，所以即使子项目里不用手动复写<code>resources</code>也能匹配到占位符：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026025346547.png" alt="image-20241026025346547"></p>
<h5 id="maven-resources-plugin-lt-useDefaultDelimeters-gt"><a href="#maven-resources-plugin-lt-useDefaultDelimeters-gt" class="headerlink" title="maven-resources-plugin (&lt;useDefaultDelimeters&gt; )"></a><code>maven-resources-plugin</code> (<code>&lt;useDefaultDelimeters&gt;</code> )</h5><p><code>&lt;useDefaultDelimeters&gt;</code> 支持使用<code>$&#123;&#125;或@</code>过滤资源 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026021624316.png" alt="image-20241026021624316"></p>
<p>boot的starter-parent默认对<code>resources-plugin</code>的配置也做了自定义更改（主要就是<code>&lt;useDefaultDelimeters&gt;</code> = false）而上文提到的父pom没有，<code>&lt;useDefaultDelimeters&gt;</code>默认就是true</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026025510839.png" alt="image-20241026025510839"></p>
<h4 id="定义多环境-lt-profiles-gt"><a href="#定义多环境-lt-profiles-gt" class="headerlink" title="定义多环境 &lt;profiles&gt;"></a>定义多环境 <code>&lt;profiles&gt;</code></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026005328800.png" alt="image-20241026005328800"></p>
<h4 id="配置属性替换占位符"><a href="#配置属性替换占位符" class="headerlink" title="配置属性替换占位符"></a>配置属性替换占位符</h4><h5 id=""><a href="#" class="headerlink" title="@"></a><code>@</code></h5><p>boot项目的parent为了防止spring占位符被扩展，所以只允许<code>@</code>为占位符，不解析<code>$&#123;&#125;</code>。如果已经继承starter-parent，直接在配置文件中@xxx@即可。 <a target="_blank" rel="noopener" href="https://docs.springjava.cn/spring-boot/how-to/properties-and-configuration.html#howto.properties-and-configuration.expand-properties.maven">parent不是starter-parent的解决办法</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026021230152.png" alt="image-20241026021230152"></p>
<h5 id="-1"><a href="#-1" class="headerlink" title="${}"></a><code>$&#123;&#125;</code></h5><p>非要用${}，可以使用如下方法覆盖配置：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026081744618.png" alt="image-20241026081744618"></p>
<p>或者启用插件的<code>&lt;useDefaultDelimeters&gt;</code> = true</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026005308461-1729903011039-5.png" alt="image-20241026005308461"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026005348094-1729902750823-1-1729902803907-3.png" alt="image-20241026005348094"></p>
<h4 id="多配置文件加载优先级"><a href="#多配置文件加载优先级" class="headerlink" title="多配置文件加载优先级"></a>多配置文件加载优先级</h4><h5 id="包外配置"><a href="#包外配置" class="headerlink" title="包外配置"></a>包外配置</h5><p>假设JAR包位于file目录下，<code>file/config/application.yml</code> &gt; <code>file/application.yml</code></p>
<h5 id="包内配置"><a href="#包内配置" class="headerlink" title="包内配置"></a>包内配置</h5><p><code>resources/config/application.yml</code> &gt; <code>resources/application.yml</code></p>
<h4 id="Java项目目录结构"><a href="#Java项目目录结构" class="headerlink" title="Java项目目录结构"></a>Java项目目录结构</h4><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026140333629.png" alt="image-20241026140333629" style="zoom: 67%;" />

<ul>
<li><p>src/main 就是编译以后的classpath(classes)，java是java源代码，resources资源文件，编译完打包都在同一个classes目录下。</p>
</li>
<li><p>src/test 是test-classes，属于测试文件，默认不会参与打包。</p>
</li>
<li><p>依赖放在<strong>包内</strong>和classes并列的lib目录</p>
</li>
<li><p>对于maven webapp骨架，main还有webapp目录，其中WEB-INF文件夹存放web.xml，打包之后web.xml classes lib并列放在WEB-INF中</p>
<ul>
<li>webapp也可存放静态资源，打包之后在JAR包中的第一级</li>
</ul>
</li>
</ul>
<h4 id="JAR包内部结构"><a href="#JAR包内部结构" class="headerlink" title="JAR包内部结构"></a>JAR包内部结构</h4><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/JAR_(%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F)">JAR (文件格式) - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p>META-INF 整个项目的元数据，MANIFEST.MF 包含执行时的入口类等信息</p>
<p>BOOT-INF boot项目的jar包中 classes+lib</p>
<p>WEB-INF web项目war包中 classes+lib+web.xml</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026143753352.png" alt="image-20241026143753352"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026143816570.png" alt="image-20241026143816570"></p>
<h5 id="APK内部结构"><a href="#APK内部结构" class="headerlink" title="APK内部结构"></a>APK内部结构</h5><p>APK作为JAR包的变种，也具有相似的结构：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026144246642.png" alt="image-20241026144246642"></p>
<h2 id="与其他框架整合"><a href="#与其他框架整合" class="headerlink" title="与其他框架整合"></a>与其他框架整合</h2><h3 id="Spring-Boot-X-JUnit"><a href="#Spring-Boot-X-JUnit" class="headerlink" title="Spring Boot X JUnit"></a>Spring Boot X JUnit</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026151902777.png" alt="image-20241026151902777"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026152538674.png" alt="image-20241026152538674"></p>
<h4 id="测试类注解-SpringBootTest"><a href="#测试类注解-SpringBootTest" class="headerlink" title="测试类注解@SpringBootTest"></a>测试类注解@SpringBootTest</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026152650043.png" alt="image-20241026152650043"></p>
<p>SpringBoot启动类：@SpringBootApplication有加载bean的功能，会扫描当前包同层以及子包中所有的bean，加载bean（包含配置类）</p>
<p>SpringBootTest会自动扫描SpringBootApplication，测试类不在启动类所在包/子包中，需要指定启动类的class文件</p>
<h3 id="基于SpringBoot实现SSM整合"><a href="#基于SpringBoot实现SSM整合" class="headerlink" title="基于SpringBoot实现SSM整合"></a>基于SpringBoot实现SSM整合</h3><h4 id="整合MyBatis案例"><a href="#整合MyBatis案例" class="headerlink" title="整合MyBatis案例"></a>整合MyBatis案例</h4><h5 id="启动依赖-MyBatis-MySQL"><a href="#启动依赖-MyBatis-MySQL" class="headerlink" title="启动依赖-MyBatis,MySQL"></a>启动依赖-MyBatis,MySQL</h5><h5 id="pojo-dao-Mapper-MapperScan"><a href="#pojo-dao-Mapper-MapperScan" class="headerlink" title="pojo dao @Mapper @MapperScan"></a>pojo dao @Mapper @MapperScan</h5><p>mybatis自动代理注解开发返回的对象就是实体类，所以实体类不用配置，</p>
<p>mybatis注解开发中@Mapper注解取代了bookMapper.xml，对mybatis声明这是一个mapper。</p>
<p>spring-mybatis整合中，mybatis生成mapper的代理对象会以FactoryBean的形式交给Spring容器管理，要让mybatis知道mapper在哪里，就要加@Mapper注解</p>
<p>spring-mybatis整合中，不加@Mapper注解，要么配置mapperScannerConfigurer，要么加@MapperScan扫mapper包。</p>
<h5 id="application-yml-配置数据源"><a href="#application-yml-配置数据源" class="headerlink" title="application.yml 配置数据源"></a>application.yml 配置数据源</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026163010546.png" alt="image-20241026163010546"></p>
<h4 id="SSM项目迁移到Spring-Boot"><a href="#SSM项目迁移到Spring-Boot" class="headerlink" title="SSM项目迁移到Spring Boot"></a>SSM项目迁移到Spring Boot</h4><p>TODO 注释前面加TODO 可以有事项清单</p>
<h5 id="配置类全部删除"><a href="#配置类全部删除" class="headerlink" title="配置类全部删除"></a>配置类全部删除</h5><h5 id="Dao加-Mapper"><a href="#Dao加-Mapper" class="headerlink" title="Dao加@Mapper"></a>Dao加@Mapper</h5><h5 id="Controller-Service不变"><a href="#Controller-Service不变" class="headerlink" title="Controller Service不变"></a>Controller Service不变</h5><h5 id="application-yml-配置端口和数据源"><a href="#application-yml-配置端口和数据源" class="headerlink" title="application.yml 配置端口和数据源"></a>application.yml 配置端口和数据源</h5><h5 id="静态资源放到resources-static"><a href="#静态资源放到resources-static" class="headerlink" title="静态资源放到resources/static"></a>静态资源放到resources/static</h5><h6 id="静态资源的重定向-JS脚本"><a href="#静态资源的重定向-JS脚本" class="headerlink" title="静态资源的重定向(JS脚本)"></a>静态资源的重定向(JS脚本)</h6><p>访问一个web资源，如果直接访问 <code>localhost:port</code> 一般会请求一个主页index.html，为了能直接从地址访问资源，创建一个index.html，添加一个跳转的js脚本</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span>=<span class="string">&quot;pages/books.html&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/08/15/hash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/15/hash/" class="post-title-link" itemprop="url">哈希函数的工程应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-15 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-15T00:00:00+08:00">2024-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 11:25:31" itemprop="dateModified" datetime="2025-04-27T11:25:31+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/math/" itemprop="url" rel="index"><span itemprop="name">math</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">散列函数 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<h2 id="Hash-是什么"><a href="#Hash-是什么" class="headerlink" title="Hash 是什么"></a>Hash 是什么</h2><p>哈希（Hash）的原理是通过一种<strong>特定的函数</strong>，将任意长度的输入（也称为键）<strong>映射</strong>为固定长度的输出（称为哈希值、哈希码或散列值）。这种函数称为<strong>哈希函数</strong>或<strong>散列函数</strong>。哈希主要用于快速查找、数据完整性验证等方面，下面具体解释其原理和应用：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/08/15/hash/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/08/11/redis-quickstart/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/11/redis-quickstart/" class="post-title-link" itemprop="url">Redis 使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-11 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-11T00:00:00+08:00">2024-08-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 13:26:25" itemprop="dateModified" datetime="2025-04-27T13:26:25+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="初识Redis"><a href="#初识Redis" class="headerlink" title="初识Redis"></a>初识Redis</h1><p>Redis是一种键值型的NoSql数据库，这里有两个关键字：</p>
<ul>
<li><p>键值型</p>
</li>
<li><p>NoSql</p>
</li>
</ul>
<p>其中<strong>键值型</strong>，是指Redis中存储的数据都是以key、value对的形式存储，而value的形式多种多样，可以是字符串、数值、甚至json：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/6U1Rhxo.png" alt="image-20220502190959608"></p>
<p>而NoSql则是相对于传统关系型数据库而言，有很大差异的一种数据库。</p>
<h2 id="认识NoSQL"><a href="#认识NoSQL" class="headerlink" title="认识NoSQL"></a>认识NoSQL</h2><p><strong>NoSql</strong>可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为<strong>非关系型数据库</strong>。</p>
<h3 id="结构化与非结构化"><a href="#结构化与非结构化" class="headerlink" title="结构化与非结构化"></a>结构化与非结构化</h3><p>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名、字段数据类型、字段约束等等信息，插入的数据必须遵守这些约束：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/4tUgFo6.png"></p>
<p>而NoSql则对数据库格式没有严格约束，往往形式松散，自由。</p>
<p>可以是键值型：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/GdqOSsj.png"></p>
<p>也可以是文档型：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/zBBQfcc.png"></p>
<p>甚至可以是图格式：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/zBnKxWf.png"></p>
<h3 id="关联和非关联"><a href="#关联和非关联" class="headerlink" title="关联和非关联"></a>关联和非关联</h3><p>传统数据库的表与表之间往往存在关联，例如外键：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/tXYSl5x.png"></p>
<p>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  name<span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  orders<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	 id<span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;荣耀6&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">4999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       id<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">       item<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	 id<span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> title<span class="punctuation">:</span> <span class="string">&quot;小米11&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">3999</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。</p>
<h3 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h3><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；</p>
<p>而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/AzaHOTF.png"></p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>传统关系型数据库能满足事务ACID的原则。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/J1MqOJM.png"></p>
<p>而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>除了上述四点以外，在存储方式、扩展性、查询性能上关系型与非关系型也都有着显著差异，总结如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/kZP40dQ.png"></p>
<ul>
<li>存储方式<ul>
<li>关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响</li>
<li>非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些</li>
</ul>
</li>
</ul>
<ul>
<li>扩展性<ul>
<li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li>
<li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li>
<li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li>
</ul>
</li>
</ul>
<h2 id="认识Redis"><a href="#认识Redis" class="headerlink" title="认识Redis"></a>认识Redis</h2><p>Redis诞生于2009年全称是<strong>Re</strong>mote  <strong>D</strong>ictionary <strong>S</strong>erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p>
<p><strong>特征</strong>：</p>
<ul>
<li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li>
<li>单线程，每个命令具备原子性</li>
<li>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</li>
<li>支持数据持久化</li>
<li>支持主从集群、分片集群</li>
<li>支持多语言客户端</li>
</ul>
<p><strong>作者</strong>：Antirez</p>
<p>Redis的官方网站地址：<a target="_blank" rel="noopener" href="https://redis.io/">https://redis.io/</a></p>
<h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><p>大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis.</p>
<p>此处选择的Linux版本为CentOS 7.</p>
<h3 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a>依赖库</h3><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure>



<h3 id="上传安装包并解压"><a href="#上传安装包并解压" class="headerlink" title="上传安装包并解压"></a>上传安装包并解压</h3><p>然后将课前资料提供的Redis安装包上传到虚拟机的任意目录：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/SyjanS5.png"></p>
<p>例如，我放到了/usr/local/src 目录：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/01DTNCf.png"></p>
<p>解压缩：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure>

<p>解压后：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/8V6zvCD.png" alt="image-20211211080339076"></p>
<p>进入redis目录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-6.2.6</span><br></pre></td></tr></table></figure>



<p>运行编译命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>如果没有出错，应该就安装成功了。</p>
<p>默认的安装路径是在 <code>/usr/local/bin</code>目录下：</p>
<p><img src="https://i.imgur.com/YSxkGm7.png"></p>
<p>该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p>
<ul>
<li>redis-cli：是redis提供的命令行客户端</li>
<li>redis-server：是redis的服务端启动脚本</li>
<li>redis-sentinel：是redis的哨兵启动脚本</li>
</ul>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>redis的启动方式有很多种，例如：</p>
<ul>
<li>默认启动</li>
<li>指定配置启动</li>
<li>开机自启</li>
</ul>
<h3 id="默认启动"><a href="#默认启动" class="headerlink" title="默认启动"></a>默认启动</h3><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/v7xWsqC.png"></p>
<p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p>
<h3 id="指定配置启动"><a href="#指定配置启动" class="headerlink" title="指定配置启动"></a>指定配置启动</h3><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20211211082225509.png" alt="image-20211211082225509"></p>
<p>我们先将这个配置文件备份一份：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure>



<p>然后修改redis.conf文件中的一些配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes </span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123321</span></span><br></pre></td></tr></table></figure>



<p>Redis的其它常见配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">.</span></span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line"><span class="attr">maxmemory</span> <span class="string">512mb</span></span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure>



<p>启动Redis：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure>



<p>停止服务：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span></span><br><span class="line">redis-cli -u 123321 shutdown</span><br></pre></td></tr></table></figure>



<h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><p>我们也可以通过配置来实现开机自启。</p>
<p>首先，新建一个系统服务文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>



<p>然后重载系统服务：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>



<p>现在，我们可以用下面这组命令来操作redis了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure>



<p>执行下面的命令，可以让redis开机自启：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure>



<h2 id="Redis桌面客户端"><a href="#Redis桌面客户端" class="headerlink" title="Redis桌面客户端"></a>Redis桌面客户端</h2><p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p>
<ul>
<li>命令行客户端</li>
<li>图形化桌面客户端</li>
<li>编程客户端</li>
</ul>
<h3 id="Redis命令行客户端"><a href="#Redis命令行客户端" class="headerlink" title="Redis命令行客户端"></a>Redis命令行客户端</h3><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure>

<p>其中常见的options有：</p>
<ul>
<li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li>
<li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li>
<li><code>-a 123321</code>：指定redis的访问密码 </li>
</ul>
<p>其中的commonds就是Redis的操作命令，例如：</p>
<ul>
<li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li>
</ul>
<p>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/OYYWPNo.png"></p>
<h3 id="图形化桌面客户端"><a href="#图形化桌面客户端" class="headerlink" title="图形化桌面客户端"></a>图形化桌面客户端</h3><p>GitHub上的大神编写了Redis的图形化桌面客户端，地址：<a target="_blank" rel="noopener" href="https://github.com/uglide/RedisDesktopManager">https://github.com/uglide/RedisDesktopManager</a></p>
<p>不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。</p>
<p>在下面这个仓库可以找到安装包：<a target="_blank" rel="noopener" href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在课前资料中可以找到Redis的图形化桌面客户端：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/BZ4Agbi.png"></p>
<p>解压缩后，运行安装程序即可安装：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/hguGHbX.png"></p>
<p>安装完成后，在安装目录下找到rdm.exe文件：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/hwK5LQ8.png"></p>
<p>双击即可运行：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/6hUqslY.png"></p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>点击左上角的<code>连接到Redis服务器</code>按钮：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/9qTGyoN.png"></p>
<p>在弹出的窗口中填写Redis服务信息：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/DshNnKC.png"></p>
<p>点击确定后，在左侧菜单会出现这个链接：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/A2cOm7Q.png"></p>
<p>点击即可建立连接了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ja8Fd9s.png"></p>
<p>Redis默认有16个仓库，编号从0至15.  通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p>
<p>如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择 0号库</span></span><br><span class="line"><span class="keyword">select</span> 0</span><br></pre></td></tr></table></figure>



<h1 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a>Redis常见命令</h1><p>Redis是典型的key-value数据库，key一般是字符串，而value包含很多不同的数据类型：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/8tli2o9.png"></p>
<p>Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ <a target="_blank" rel="noopener" href="https://redis.io/commands">https://redis.io/commands </a>）可以查看到不同的命令：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/5Lcr3BE.png"></p>
<p>不同类型的命令称为一个group，我们也可以通过help命令来查看各种不同group的命令：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/suevOIR.png"></p>
<p>接下来，我们就学习常见的五种基本数据类型的相关命令。</p>
<h2 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h2><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p>
<ul>
<li>KEYS：查看符合模板的所有key</li>
<li>DEL：删除一个指定的key</li>
<li>EXISTS：判断key是否存在</li>
<li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li>
<li>TTL：查看一个KEY的剩余有效期</li>
</ul>
<p>通过help [command] 可以查看一个命令的具体用法，例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看keys命令的帮助信息：</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> keys</span><br><span class="line"></span><br><span class="line">KEYS pattern</span><br><span class="line">summary: Find all keys matching the given pattern</span><br><span class="line">since: 1.0.0</span><br><span class="line">group: generic</span><br></pre></td></tr></table></figure>



<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p>
<p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p>
<ul>
<li>string：普通字符串</li>
<li>int：整数类型，可以做自增、自减操作</li>
<li>float：浮点类型，可以做自增、自减操作</li>
</ul>
<p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/VZqpv73.png"></p>
<h3 id="String的常见命令"><a href="#String的常见命令" class="headerlink" title="String的常见命令"></a>String的常见命令</h3><p>String的常见命令有：</p>
<ul>
<li>SET：添加或者修改已经存在的一个String类型的键值对</li>
<li>GET：根据key获取String类型的value</li>
<li>MSET：批量添加多个String类型的键值对</li>
<li>MGET：根据多个key获取多个String类型的value</li>
<li>INCR：让一个整型的key自增1</li>
<li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li>
<li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li>
<li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li>
<li>SETEX：添加一个String类型的键值对，并且指定有效期</li>
</ul>
<h3 id="Key结构"><a href="#Key结构" class="headerlink" title="Key结构"></a>Key结构</h3><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p>
<p>例如，需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p>
<p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p>
<p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目名:业务名:类型:id</span><br></pre></td></tr></table></figure>

<p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。这样以来，我们就可以把不同类型的数据区分开了。从而避免了key的冲突问题。</p>
<p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p>
<ul>
<li><p>user相关的key：<strong>heima:user:1</strong></p>
</li>
<li><p>product相关的key：<strong>heima:product:1</strong></p>
</li>
</ul>
<p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p>
<table>
<thead>
<tr>
<th><strong>KEY</strong></th>
<th><strong>VALUE</strong></th>
</tr>
</thead>
<tbody><tr>
<td>heima:user:1</td>
<td>{“id”:1,  “name”: “Jack”, “age”: 21}</td>
</tr>
<tr>
<td>heima:product:1</td>
<td>{“id”:1,  “name”: “小米11”, “price”: 4999}</td>
</tr>
</tbody></table>
<p>并且，在Redis的桌面客户端中，还会以相同前缀作为层级结构，让数据看起来层次分明，关系清晰：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/InWMfeD.png"></p>
<h2 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h2><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p>
<p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/x2zDBjf.png"></p>
<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/VF2EPt0.png"></p>
<p>Hash的常见命令有：</p>
<ul>
<li><p>HSET key field value：添加或者修改hash类型key的field的值</p>
</li>
<li><p>HGET key field：获取一个hash类型key的field的值</p>
</li>
<li><p>HMSET：批量添加多个hash类型key的field的值</p>
</li>
<li><p>HMGET：批量获取多个hash类型key的field的值</p>
</li>
<li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p>
</li>
<li><p>HKEYS：获取一个hash类型的key中的所有的field</p>
</li>
<li><p>HINCRBY:让一个hash类型key的字段值自增并指定步长</p>
</li>
<li><p>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</p>
</li>
</ul>
<h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p>
<p>特征也与LinkedList类似：</p>
<ul>
<li>有序</li>
<li>元素可以重复</li>
<li>插入和删除快</li>
<li>查询速度一般</li>
</ul>
<p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p>
<p>List的常见命令有：</p>
<ul>
<li>LPUSH key element … ：向列表左侧插入一个或多个元素</li>
<li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li>
<li>RPUSH key element … ：向列表右侧插入一个或多个元素</li>
<li>RPOP key：移除并返回列表右侧的第一个元素</li>
<li>LRANGE key star end：返回一段角标范围内的所有元素</li>
<li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li>
</ul>
<h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p>
<ul>
<li><p>无序</p>
</li>
<li><p>元素不可重复</p>
</li>
<li><p>查找快</p>
</li>
<li><p>支持交集、并集、差集等功能</p>
</li>
</ul>
<p>Set的常见命令有：</p>
<ul>
<li>SADD key member … ：向set中添加一个或多个元素</li>
<li>SREM key member … : 移除set中的指定元素</li>
<li>SCARD key： 返回set中元素的个数</li>
<li>SISMEMBER key member：判断一个元素是否存在于set中</li>
<li>SMEMBERS：获取set中的所有元素</li>
<li>SINTER key1 key2 … ：求key1与key2的交集</li>
</ul>
<p>例如两个集合：s1和s2:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ha8x86R.png"></p>
<p>求交集：SINTER s1 s2</p>
<p>求s1与s2的不同：SDIFF s1 s2</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/L9vTv2X.png"></p>
<p>练习：</p>
<ol>
<li>将下列数据用Redis的Set集合来存储：</li>
</ol>
<ul>
<li>张三的好友有：李四、王五、赵六</li>
<li>李四的好友有：王五、麻子、二狗</li>
</ul>
<ol start="2">
<li>利用Set的命令实现下列功能：</li>
</ol>
<ul>
<li>计算张三的好友有几人</li>
<li>计算张三和李四有哪些共同好友</li>
<li>查询哪些人是张三的好友却不是李四的好友</li>
<li>查询张三和李四的好友总共有哪些人</li>
<li>判断李四是否是张三的好友</li>
<li>判断张三是否是李四的好友</li>
<li>将李四从张三的好友列表中移除</li>
</ul>
<h2 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个<strong>score</strong>属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p>
<p>SortedSet具备下列特性：</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p>
<p>SortedSet的常见命令有：</p>
<ul>
<li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li>
<li>ZREM key member：删除sorted set中的一个指定元素</li>
<li>ZSCORE key member : 获取sorted set中的指定元素的score值</li>
<li>ZRANK key member：获取sorted set 中的指定元素的排名</li>
<li>ZCARD key：获取sorted set中的元素个数</li>
<li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li>
<li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li>
<li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li>
<li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li>
<li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li>
</ul>
<p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p>
<ul>
<li><p><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</p>
</li>
<li><p><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</p>
</li>
</ul>
<p>REVERSE</p>
<p>练习题：</p>
<p>将班级的下列学生得分存入Redis的SortedSet中：</p>
<p>Jack 85, Lucy 89, Rose 82, Tom 95, Jerry 78, Amy 92, Miles 76</p>
<p>并实现下列功能：</p>
<ul>
<li>删除Tom同学</li>
<li>获取Amy同学的分数</li>
<li>获取Rose同学的排名</li>
<li>查询80分以下有几个学生</li>
<li>给Amy同学加2分</li>
<li>查出成绩前3名的同学</li>
<li>查出成绩80分以下的所有同学</li>
</ul>
<p>range 分数条件 </p>
<p>count 分数条件</p>
<h1 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h1><p>在Redis官网中提供了各种语言的客户端，地址：<a target="_blank" rel="noopener" href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/9f68ivq.png"></p>
<p>其中Java客户端也包含很多：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220609102817435-165735883948534.png" alt="image-20220609102817435"></p>
<p>标记为*的就是推荐使用的java客户端，包括：</p>
<ul>
<li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。</li>
<li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。</li>
</ul>
<h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>Jedis的官网地址： <a target="_blank" rel="noopener" href="https://github.com/redis/jedis">https://github.com/redis/jedis</a></p>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>我们先来个快速入门：</p>
<p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jedis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>建立连接</p>
<p>新建一个单元测试类，内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.建立连接</span></span><br><span class="line">    <span class="comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span></span><br><span class="line">    jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">    <span class="comment">// 2.设置密码</span></span><br><span class="line">    jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.选择库</span></span><br><span class="line">    jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 存入数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 插入hash数据</span></span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取</span></span><br><span class="line">    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>释放资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.jedis.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig, <span class="string">&quot;192.168.150.101&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>, <span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心线程数 线程最大数 多余线程自动销毁时间 多余线程自动销毁时间单位 阻塞队列BlockingQueue  拒绝策略abortPolicy 线程工厂</p>
<h2 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p>
<ul>
<li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li>
<li>提供了RedisTemplate统一API来操作Redis</li>
<li>支持Redis的发布订阅模型</li>
<li>支持Redis哨兵和Redis集群</li>
<li>支持基于Lettuce的响应式编程</li>
<li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li>
<li>支持基于Redis的JDKCollection实现</li>
</ul>
<p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/UFlNIV0.png"></p>
<h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><p>SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单。</p>
<p>首先，新建一个maven项目，然后按照下面步骤执行：</p>
<h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redis-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>redis-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Jackson依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="配置Redis"><a href="#配置Redis" class="headerlink" title="配置Redis"></a>配置Redis</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br></pre></td></tr></table></figure>



<h4 id="注入RedisTemplate"><a href="#注入RedisTemplate" class="headerlink" title="注入RedisTemplate"></a>注入RedisTemplate</h4><p>因为有了SpringBoot的自动装配，我们可以拿来就用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="编写测试"><a href="#编写测试" class="headerlink" title="编写测试"></a>编写测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate edisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入一条String数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取string数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h3><p>RedisTemplate可以接收任意Object作为值写入Redis：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/OEMcbuu.png"></p>
<p>一种方法，redistemplate指定泛型，</p>
<p>另外一种，Redis</p>
<p>只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/5FjtWk5.png"></p>
<p>缺点：</p>
<ul>
<li>可读性差</li>
<li>内存占用较大</li>
</ul>
<p>我们可以自定义RedisTemplate的序列化方式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> </span><br><span class="line">            							<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/XOAq3cN.png"></p>
<p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</p>
<h3 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h3><p>为了节省内存空间，我们可以不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Ip9TKSY.png"></p>
<p>因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis了。</p>
<p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/zXH6Qn6.png"></p>
<p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="comment">// JSON序列化工具</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;虎哥&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 手动序列化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">    <span class="comment">// 手动反序列化</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="OperationsForHash"><a href="#OperationsForHash" class="headerlink" title="OperationsForHash"></a>OperationsForHash</h3><p>entries(key) 所有键值对</p>
<p>keys(key) key的所有field</p>
<p>values(key)key的所有value</p>
<p>put(key,field,value)</p>
<p>get(key,field)</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default/">1</a><a class="page-number" href="/default/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/default/page/4/">4</a><a class="page-number" href="/default/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">碎梦</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/scatteredream" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
