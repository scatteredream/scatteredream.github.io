<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Arvo:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scatteredream.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="scatteredream&#39;s blog">
<meta property="og:url" content="http://scatteredream.github.io/default/page/3/index.html">
<meta property="og:site_name" content="scatteredream&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="碎梦">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://scatteredream.github.io/default/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default/page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>scatteredream's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">scatteredream's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="碎梦"
      src="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
  <p class="site-author-name" itemprop="name">碎梦</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">77</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">125</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/12/29/408-%E8%AE%A1%E7%BD%91-%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/29/408-%E8%AE%A1%E7%BD%91-%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">OSI参考模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-29 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-29T00:00:00+08:00">2024-12-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:47:24" itemprop="dateModified" datetime="2025-05-05T11:47:24+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>表示层：数据的编解码与加解密，以及压缩，socket也属于这一层</p>
<p>会话层：连接的建立</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h2><p>inter-前缀意为“相互的”，internet表示相互连接的网络，任意的通信协议。</p>
<p>Internet表示全球最大的开放特定计算机网络，使用TCP/IP协议族作为通信规则，前身为ARPANET</p>
<h3 id="发展概述"><a href="#发展概述" class="headerlink" title="发展概述"></a>发展概述</h3><h4 id="ARPANET-gt-Internet"><a href="#ARPANET-gt-Internet" class="headerlink" title="ARPANET -&gt; Internet"></a>ARPANET -&gt; Internet</h4><ul>
<li>1969，ARPANET</li>
<li>mid 1970s，多种网络互联的研究</li>
<li><strong>1983</strong>，TCP/IP成为ARPANET的标准协议，也是公认的Internet诞生时间</li>
</ul>
<h4 id="三级结构的Internet"><a href="#三级结构的Internet" class="headerlink" title="三级结构的Internet"></a>三级结构的Internet</h4><ul>
<li>1985，NSFNET</li>
<li>1990，ARPANET closed</li>
<li>1991，Internet开始商业化</li>
</ul>
<h4 id="多层次ISP结构的Internet"><a href="#多层次ISP结构的Internet" class="headerlink" title="多层次ISP结构的Internet"></a>多层次ISP结构的Internet</h4><ul>
<li>1993，NSFNET逐渐被商用Internet主干网取代，政府机构将其交给ISP运营</li>
<li>1994，万维网WWW技术促使因特网迅猛发展</li>
<li>1995，NSFNET停止运作，Internet正式商业化</li>
</ul>
<h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028134459569.png" alt="image-20241028134459569"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028134717845.png" alt="image-20241028134717845"></p>
<h3 id="标准化—RFC"><a href="#标准化—RFC" class="headerlink" title="标准化—RFC"></a>标准化—RFC</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028134853049.png" alt="image-20241028134853049"></p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028134950779.png" alt="image-20241028134950779"></p>
<h2 id="信息交换技术"><a href="#信息交换技术" class="headerlink" title="信息交换技术"></a>信息交换技术</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028151306409.png" alt="image-20241028151306409"></p>
<h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028151319591.png" alt="image-20241028151319591"></p>
<p>报文加首部，便于给交换机提供信息</p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028151351499.png" alt="image-20241028151351499"></p>
<p>将原来的报文分组，带首部依次发送每个组</p>
<h2 id="计算机网络概念"><a href="#计算机网络概念" class="headerlink" title="计算机网络概念"></a>计算机网络概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><p><strong>互连</strong></p>
<p>通过有线/无线方式进行通信</p>
<p><strong>集合</strong></p>
<p>至少两台以上计算机</p>
<p><strong>自治</strong></p>
<p>独立的计算机，具备自己的硬件和软件，</p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><strong>一些</strong> 通用可编程的<strong>硬件</strong>（包括智能手机、电脑等各种计算机，这些硬件并不只用于数据通信，而且能支持广泛的应用程序）<strong>互联</strong>而成。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><strong>按交换技术分类</strong></p>
<ul>
<li>电路交换</li>
<li>报文交换</li>
<li>分组交换</li>
</ul>
<p><strong>按使用者分类</strong></p>
<ul>
<li>专用</li>
<li>公用</li>
</ul>
<p><strong>按传输介质分类</strong></p>
<ul>
<li>有线 Wired</li>
<li>无线 Wireless</li>
</ul>
<p><strong>按覆盖范围分类</strong></p>
<p>覆盖范围从大到小排列：</p>
<ul>
<li><strong>广域网</strong> <strong>WAN</strong> Wide Area 国家、洲</li>
<li>城域网 MAN Metropolitan Area 城市 </li>
<li><strong>局域网</strong> <strong>LAN</strong> Local Area 机构、楼房</li>
<li>个域网 PAN Personal Area 个人电子设备 组成的多处理机系统WPAN </li>
</ul>
<p><strong>按拓扑结构分类</strong></p>
<ul>
<li><p>总线</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028160634851.png" alt="image-20241028160634851"></p>
</li>
<li><p>星型</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028160648577.png" alt="image-20241028160648577"></p>
</li>
<li><p>环形</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028160700477.png" alt="image-20241028160700477"></p>
</li>
<li><p>网状</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028160718347.png" alt="image-20241028160718347"></p>
</li>
</ul>
<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><h4 id="比特、字节、速率（数据率，比特率）"><a href="#比特、字节、速率（数据率，比特率）" class="headerlink" title="比特、字节、速率（数据率，比特率）"></a>比特、字节、速率（数据率，比特率）</h4><p>1 GiB = 2^30^ B（操作系统）  1 GB = 10^9^ B（硬盘厂商） binary 表示二进制</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028161416193.png" alt="image-20241028161416193"></p>
<ul>
<li>kilo bps, ==k==bps, Mbps, Gbps, Tbps : 1000</li>
<li>B, KB, MB, GB, GB : 1024 </li>
<li>bps 进制为1000，Byte 进制为1024，8 b = 1 B</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028161845070.png" alt="image-20241028161845070"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028162145504.png" alt="image-20241028162145504"></p>
<h4 id="带宽（Band-Width）"><a href="#带宽（Band-Width）" class="headerlink" title="带宽（Band Width）"></a>带宽（Band Width）</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028163439507.png" alt="image-20241028163439507"></p>
<p>1 Mbps = 0.125 MB/s = 128 KB/s 下载速度一般用字节表示</p>
<h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028163850891.png" alt="image-20241028163850891"></p>
<h4 id="时延（Delay）"><a href="#时延（Delay）" class="headerlink" title="时延（Delay）"></a>时延（Delay）</h4><h5 id="主机的发送速率"><a href="#主机的发送速率" class="headerlink" title="主机的发送速率"></a>主机的发送速率</h5><p>主机的发送速率，由<strong>网卡的发送速率</strong>、<strong>信道带宽</strong>、<strong>接口速率</strong>共同决定，取最小的那一个，速率应该尽量匹配。</p>
<h5 id="发送时延、传播时延、处理时延"><a href="#发送时延、传播时延、处理时延" class="headerlink" title="发送时延、传播时延、处理时延"></a>发送时延、传播时延、处理时延</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028164902463.png" alt="image-20241028164902463"></p>
<p><strong>发送时延</strong>-&gt;发送速率和分组数据包长度</p>
<p><strong>传播时延</strong>-&gt;电线长度和光速（电磁波速率）</p>
<p><strong>处理时延</strong>-&gt;忽略</p>
<p>在发送数据时，电流的大小或电压水平会发生变化，这些变化被用来表示一串二进制码。具体来说，以下是这个过程的简要说明：</p>
<ol>
<li><strong>信号变化</strong>：在数字信号传输中，电流或电压会在不同的电平之间切换。比如，当电流达到某个高电压水平时，可以表示比特1，而在低电压水平时表示比特0。</li>
<li><strong>时间同步</strong>：为了确保接收方能够正确识别这些电压变化，发送方和接收方通常会使用时钟信号进行同步。这保证了信号在正确的时间被读取，从而将电流的变化准确地转化为二进制数据。</li>
<li><strong>比特流的形成</strong>：这些电流变化在时间轴上连续发生，从而形成一个比特流（例如 10101010），每个比特对应一个电压状态的变化。</li>
</ol>
<p>通过这些方式，电流的变化被抽象为数字信息，使得数据可以在计算机和网络之间进行有效传输。</p>
<h6 id="哪一个占主导？"><a href="#哪一个占主导？" class="headerlink" title="哪一个占主导？"></a>哪一个占主导？</h6><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028164759500.png" alt="image-20241028164759500"></p>
<h5 id="时延计算要点"><a href="#时延计算要点" class="headerlink" title="时延计算要点"></a>时延计算要点</h5><p><strong>1个分组，1段链路</strong></p>
<p>从上图也可以看出，即使是100MB的数据块，一共是800M个比特，发送时延都是全部计入的，而传播时延只需将距离除以传输速度即可。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029204300220.png" alt="image-20241029204300220"></p>
<p>横坐标是时间，纵坐标是位置，比特是一个接着一个向前传播的，发送时延取决于发送方：每个比特的发送时间都要计入发送时延，传播时延取决于最后一个比特的尾部传到对面所需的时间。</p>
<p><strong>n个分组，n段链路</strong></p>
<ul>
<li>第一段链路：n个分组发送时延+1个传播时延</li>
<li>第二段链路：发送和接收同时进行，等到第一段链路传输完成，第二段还剩最后1个分组未发送，因此第二段链路的实际时延为1个分组发送时延+1个传播时延</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029205641630.png" alt="image-20241029205641630"></p>
<ul>
<li>n段路,m组：n个传播时延+[m+(n-1)*1]个分组发送时延，</li>
<li>存储转发：只有完整地接收一个比特，才能开始发送的工作</li>
</ul>
<p><strong>电路交换和分组交换时延</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029211907159.png" alt="image-20241029211907159"></p>
<ul>
<li>电路先要建立连接，然后直接发送整个报文，<strong>没有存储转发</strong>，相当于一组一链路</li>
<li><strong>分组交换不用先建立连接，每一个分组采用存储转发方式</strong>。牢记四个变量：<ul>
<li><strong>1个分组发送时间</strong>，</li>
<li><strong>分组数量</strong>，</li>
<li><strong>1个链路传播时间</strong>，</li>
<li><strong>链路数量</strong> </li>
</ul>
</li>
</ul>
<p><strong>报文交换和分组交换</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029213402856.png" alt="image-20241029213402856"></p>
<p>报文交换需要整整发送两次，分组交换需要发送组数加1次，流水线</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029214114258.png" alt="image-20241029214114258"></p>
<h5 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h5><p>传播时延x带宽 传播过去一个比特的时间内，发送了多少比特，也称为比特单位的链路长度</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028170442570.png" alt="image-20241028170442570"></p>
<h4 id="往返时间（RTT）"><a href="#往返时间（RTT）" class="headerlink" title="往返时间（RTT）"></a>往返时间（RTT）</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028180207539.png" alt="image-20241028180207539"></p>
<p>Round-Trip 传输耗时要考虑在内，<strong>双向交互</strong></p>
<h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028180135459.png" alt="image-20241028180135459"></p>
<h4 id="丢包率（Packet-Loss）"><a href="#丢包率（Packet-Loss）" class="headerlink" title="丢包率（Packet Loss）"></a>丢包率（Packet Loss）</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028181110596.png" alt="image-20241028181110596"></p>
<p>一些路由算法在未满时就会有丢包操作</p>
<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><h3 id="OSI-参考模型-amp-TCP-IP-模型"><a href="#OSI-参考模型-amp-TCP-IP-模型" class="headerlink" title="OSI 参考模型 &amp; TCP/IP 模型"></a>OSI 参考模型 &amp; TCP/IP 模型</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029195855494.png" alt="image-20241029195855494"></p>
<p>表示层：通信双方交换信息表示问题（数据格式转换），包括字符集转换，数据格式化，文本压缩，数据加密和解密的工作</p>
<p>会话层：对话管理，会话管理</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028182558729.png" alt="image-20241028182558729"  />

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028182833901.png" alt="image-20241028182833901"></p>
<p>网络Network 网际Internet</p>
<p>核心：TCP IP</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028182726625.png" alt="image-20241028182726625"></p>
<h3 id="分层的必要性"><a href="#分层的必要性" class="headerlink" title="分层的必要性"></a>分层的必要性</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028190200363.png" alt="image-20241028190200363"></p>
<h4 id="信号（bit）如何在两台机器之间传输—物理层"><a href="#信号（bit）如何在两台机器之间传输—物理层" class="headerlink" title="信号（bit）如何在两台机器之间传输—物理层"></a>信号（bit）如何在两台机器之间传输—物理层</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028185123827.png" alt="image-20241028185123827"></p>
<h4 id="分组如何在网络内传输—数据链路层（MAC地址）"><a href="#分组如何在网络内传输—数据链路层（MAC地址）" class="headerlink" title="分组如何在网络内传输—数据链路层（MAC地址）"></a>分组如何在网络内传输—数据链路层（MAC地址）</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028185259670.png" alt="image-20241028185259670"></p>
<p>PPP ARP </p>
<h4 id="分组如何在不同网络间传输（路由）—网络层（IP地址）"><a href="#分组如何在不同网络间传输（路由）—网络层（IP地址）" class="headerlink" title="分组如何在不同网络间传输（路由）—网络层（IP地址）"></a>分组如何在不同网络间传输（路由）—网络层（IP地址）</h4><p>核心协议：IP ICMP</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028185452878.png" alt="image-20241028185452878"></p>
<h4 id="进程之间基于网络的通信，端到端的通信—传输层（端口号）"><a href="#进程之间基于网络的通信，端到端的通信—传输层（端口号）" class="headerlink" title="进程之间基于网络的通信，端到端的通信—传输层（端口号）"></a>进程之间基于网络的通信，端到端的通信—传输层（端口号）</h4><p>核心协议：TCP UDP</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028185918747.png" alt="image-20241028185918747"></p>
<h4 id="应用进程之间的交互实现特定网络—应用层"><a href="#应用进程之间的交互实现特定网络—应用层" class="headerlink" title="应用进程之间的交互实现特定网络—应用层"></a>应用进程之间的交互实现特定网络—应用层</h4><p>核心协议:HTTP POP3 SMTP（TCP）  DNS  RTP(UDP)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028190013193.png" alt="image-20241028190013193"></p>
<h3 id="案例：在浏览器敲下一个URL后发生了什么？—应用进程间基于网络的通信"><a href="#案例：在浏览器敲下一个URL后发生了什么？—应用进程间基于网络的通信" class="headerlink" title="案例：在浏览器敲下一个URL后发生了什么？—应用进程间基于网络的通信"></a>案例：在浏览器敲下一个URL后发生了什么？—应用进程间基于网络的通信</h3><p>浏览器发送HTTP请求（访问URL指向的资源），HTTP属于应用层协议，需要向下传输通过物理层传到路由器的物理层，再向上传输到达网络层，经过解析之后，再通过物理层传到服务器的物理层，物理层向上传输到应用层，应用层的Web服务器应用程序会解析HTTP报文，之后返回HTTP响应（URL对应的资源），通过类似的方法传回给浏览器进程。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/9c941130d600033193a3e02800da8fd.jpg" alt="9c941130d600033193a3e02800da8fd"></p>
<h3 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h3><p>对等<strong>实体</strong>通过所属层级的通信<strong>协议</strong>，在下方层级的<strong>服务</strong>（下层两个对等实体间的逻辑通信能够向上层提供服务）下进行逻辑通信（不用考虑其他层，实际上这种通信不存在）。</p>
<h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><h5 id="对等实体"><a href="#对等实体" class="headerlink" title="对等实体"></a>对等实体</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028204310699.png" alt="image-20241028204310699"></p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028204254883.png" alt="image-20241028204254883"></p>
<h5 id="语法：定义报文格式"><a href="#语法：定义报文格式" class="headerlink" title="语法：定义报文格式"></a>语法：定义报文格式</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028204056703.png" alt="image-20241028204056703"></p>
<h5 id="语义：根据语法解析报文内容，定义出双方行为"><a href="#语义：根据语法解析报文内容，定义出双方行为" class="headerlink" title="语义：根据语法解析报文内容，定义出双方行为"></a>语义：根据语法解析报文内容，定义出双方行为</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028204146999.png" alt="image-20241028204146999"></p>
<h5 id="同步：行为发生的时序关系（先后顺序）"><a href="#同步：行为发生的时序关系（先后顺序）" class="headerlink" title="同步：行为发生的时序关系（先后顺序）"></a>同步：行为发生的时序关系（先后顺序）</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028204026941.png" alt="image-20241028204026941"></p>
<h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028203948172.png" alt="image-20241028203948172"></p>
<h5 id="服务访问点、服务原语"><a href="#服务访问点、服务原语" class="headerlink" title="服务访问点、服务原语"></a>服务访问点、服务原语</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028203743701.png" alt="image-20241028203743701"></p>
<h5 id="协议数据单元PDU、服务数据单元SDU"><a href="#协议数据单元PDU、服务数据单元SDU" class="headerlink" title="协议数据单元PDU、服务数据单元SDU"></a>协议数据单元PDU、服务数据单元SDU</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241028203909481.png" alt="image-20241028203909481"></p>
<h1 id="面试要点"><a href="#面试要点" class="headerlink" title="面试要点"></a>面试要点</h1><ol>
<li>TCP/IP协议体系的认知 </li>
<li>链路层<ol>
<li>以太网帧的格式</li>
<li>MTU的概念</li>
<li>ARP协议（掌握一下ARP缓存的原理）</li>
</ol>
</li>
<li>网络层<ol>
<li>掌握IP的首部格式</li>
<li>掌握IP的分片</li>
<li>掌握IP选路</li>
<li>ICMP协议<ol>
<li>掌握报文格式</li>
<li>分类：查询 + 差错</li>
<li>两种 + 五种</li>
</ol>
</li>
</ol>
</li>
<li>传输层<ol>
<li>UDP，次要一点，掌握特点和首部各个字段</li>
<li>掌握TCP<ol>
<li>特点 + 首部字段 + 可靠机制</li>
<li>连接控制 ： 三次握手，四次挥手，同时打开，同时关闭，半关闭（可能问到为什么需要）</li>
<li>流量控制机制：滑动窗口，慢启动，拥塞避免，快速重传，快速恢复</li>
<li>超时重传机制</li>
</ol>
</li>
</ol>
</li>
<li>应用层<ol>
<li>掌握DNS协议<ol>
<li>名字空间</li>
<li>指针查询（反向查找或逆向解析）基本原理</li>
<li>DNS缓存</li>
</ol>
</li>
<li>FTP协议（活化石）：<ol>
<li>控制流和数据流</li>
<li>两种工作模式： PASV 和 PORT</li>
<li>各种指令和响应码</li>
<li>断点续传和匿名FTP的概念</li>
</ol>
</li>
<li>HTTP协议：<ol>
<li>报文格式：请求报文，响应报文，请求头各种字段，响应头各种字段。</li>
<li>HTTP状态码。</li>
<li>HTTPS协议。</li>
<li>握手的详细过程。</li>
<li>摘要算法，数字签名，数字证书的原理和过程。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">OSI模型 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p>在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/9636548?fromModule=lemma_inlink">网络通信</a>的过程中，将发出数据的主机称为源主机，接收数据的主机称为目的主机。当源主机发出数据时，数据在源主机中从上层向下层传送。源主机中的应用进程先将数据交给应用层，应用层加上必要的控制信息就成了报文流，向下传给传输层。传输层将收到的数据单元加上本层的控制信息，形成报文段、数据报，再交给网际层。网际层加上本层的控制信息据报，传给网络接口层。网络接口层将网际层交下来的IP数据报组装成帧，并以比特流的形式传给网络硬件（即物理层），数据就离开源主机。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921220715692.png" alt="image-20240921220715692"></p>
<h1 id="物理层、数据链路层"><a href="#物理层、数据链路层" class="headerlink" title="物理层、数据链路层"></a>物理层、数据链路层</h1><p><strong>双绞线、集线器（HUB）</strong>：多台计算机之间物理连接，遇到并发情况会有<strong>数据碰撞与紊乱</strong>，而且数据都是广播形式传递，无法同时向上和向下传输（半双工，相当于对讲机，只能听不能说）。CSMA/CD协议，发送以前进行载波侦听。属于物理层。</p>
<p><strong>交换机：</strong>全双工。物理连接，也支持和其他交换机连接（桥接）能更好处理并发情况，里面有一张mac地址表，用来区分不同设备，计算机1第一次联络计算机2，将计算机2的MAC地址发送给交换机，由于不知道这个mac对应哪个接口，交换机通过数据泛洪的方式，广播给所有计算机，都收到了，但只有计算机2对应的接口会回应，mac表中添加计算机2的信息，以后他们的通信就不需要广播了。<u>在数据链路层</u>。</p>
<p>重点：以太网帧 MTU概念 ARP协议(MAC和IP互查，缓存)</p>
<h2 id="协议-1"><a href="#协议-1" class="headerlink" title="协议"></a>协议</h2><h3 id="MAC-LLC"><a href="#MAC-LLC" class="headerlink" title="MAC LLC"></a>MAC LLC</h3><table>
<thead>
<tr>
<th align="right"></th>
<th><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">介质访问控制(MAC, Media Access Control)</a></th>
</tr>
</thead>
<tbody><tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2">电路交换(Channel-based)</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A2%91%E5%88%86%E5%A4%9A%E5%9D%80">FDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E4%BA%A4%E9%A0%BB%E5%88%86%E5%A4%9A%E5%9D%80">OFDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%B3%A2%E5%88%86%E5%A4%9A%E5%9D%80&action=edit&redlink=1">WDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SC-FDMA">SC-FDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%B6%E5%88%86%E5%A4%9A%E5%9D%80">TDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%9A%E9%A2%91%E6%97%B6%E5%88%86%E5%A4%9A%E5%9D%80&action=edit&redlink=1">MF-TDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%87%AA%E7%BB%84%E7%BB%87%E6%97%B6%E5%88%86%E5%A4%9A%E5%9D%80&action=edit&redlink=1">STDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%A2%BC%E5%A4%9A%E9%87%8D%E9%80%B2%E6%8E%A5">CDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/W-CDMA">W-CDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TD-CDMA">TD-CDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TD-SCDMA">TD-SCDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DS-CDMA">DS-CDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/FH-CDMA">FH-CDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E4%BA%A4%E9%A0%BB%E5%88%86%E5%A4%9A%E5%9D%80">OFHMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%9A%E8%BD%BD%E6%B3%A2%E7%A0%81%E5%88%86%E5%A4%9A%E5%9D%80&action=edit&redlink=1">MC-CDMA</a>SDMA<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%A7%E5%AE%B9%E9%87%8F%E7%A9%BA%E5%88%86%E5%A4%9A%E5%9D%80&action=edit&redlink=1">HC-SDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%9E%81%E5%88%86%E5%A4%9A%E5%9D%80&action=edit&redlink=1">PDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%84%89%E5%86%B2%E5%9C%B0%E5%9D%80%E5%A4%9A%E9%87%8D%E5%AD%98%E5%8F%96&action=edit&redlink=1">PAMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%97%B6%E6%9C%BA%E9%A9%B1%E5%8A%A8%E5%A4%9A%E5%9D%80&action=edit&redlink=1">ODMA</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">分组交换(Packet-based)</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%86%B2%E7%AA%81%E5%B9%B2%E6%89%B0%E6%81%A2%E5%A4%8D&action=edit&redlink=1">冲突干扰恢复</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%86%B2%E7%AA%81%E9%81%BF%E5%85%8D&action=edit&redlink=1">冲突避免</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%97%A0%E5%86%B2%E7%AA%81&action=edit&redlink=1">无冲突</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ALOHA">ALOHA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Slotted_ALOHA">Slotted ALOHA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=R-ALOHA&action=edit&redlink=1">R-ALOHA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%A6%E5%86%B2%E7%AA%81%E9%81%BF%E5%85%8D%E7%9A%84%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5&action=edit&redlink=1">MACA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%A6%E5%86%B2%E7%AA%81%E9%81%BF%E5%85%8D%E7%9A%84%E6%97%A0%E7%BA%BF%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5&action=edit&redlink=1">MACAW</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BD%BD%E6%B3%A2%E4%BE%A6%E5%90%AC%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE">CSMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CSMA/CD">CSMA/CD</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CSMA/CA">CSMA/CA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%88%86%E6%95%A3%E5%BC%8F%E5%8D%94%E8%AA%BF%E5%8A%9F%E8%83%BD&action=edit&redlink=1">DCF</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%82%B9%E5%8D%8F%E8%B0%83%E5%8A%9F%E8%83%BD">PCF</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%B7%B7%E5%90%88%E5%8D%8F%E8%B0%83%E5%8A%9F%E8%83%BD&action=edit&redlink=1">HCF</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%B8%A6%E5%86%B2%E7%AA%81%E9%81%BF%E5%85%8D%E4%B8%8E%E5%88%86%E8%A7%A3%E7%9A%84%E6%9C%89%E8%BD%BD%E6%B3%A2%E4%BE%A6%E5%90%AC%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE&action=edit&redlink=1">CSMA/CARP</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A4%E7%89%8C%E7%8E%AF">令牌环</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A4%E7%89%8C%E6%80%BB%E7%BA%BF">令牌总线</a><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mobile_Slotted_Aloha">MS-ALOHA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9A%A8%E5%BB%BA%E5%8D%B3%E9%80%A3%E7%B6%B2%E8%B7%AF">MANET</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BB%8A%E8%BC%89%E9%9A%A8%E6%84%8F%E8%A1%8C%E5%8B%95%E7%B6%B2%E8%B7%AF">VANET</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%BB%B6%E8%BF%9F%E5%AE%B9%E5%BF%8D%E7%BD%91%E7%BB%9C&action=edit&redlink=1">DTN</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%8A%A8%E6%80%81%E6%BA%90%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE&action=edit&redlink=1">动态源路由协议</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%99%E5%B7%A5">双工方法</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%99%E5%B7%A5#%E6%99%82%E5%88%86%E9%9B%99%E5%B7%A5">时分双工</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%99%E5%B7%A5#%E9%A0%BB%E5%88%86%E9%9B%99%E5%B7%A5">频分双工</a></td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E9%93%BE%E8%B7%AF%E6%8E%A7%E5%88%B6">逻辑链路控制 - 维基百科，自由的百科全书 (wikipedia.org)</a> LLC</p>
<h3 id="无线网络"><a href="#无线网络" class="headerlink" title="无线网络"></a>无线网络</h3><h4 id="移动网络-Celluar-Network"><a href="#移动网络-Celluar-Network" class="headerlink" title="移动网络 (Celluar Network)"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%9C%82%E7%AA%9D%E7%BD%91%E7%BB%9C">移动网络 (Celluar Network)</a></h4><table>
<thead>
<tr>
<th align="right"></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/0G">0G</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%84%A1%E7%B7%9A%E9%9B%BB%E8%A9%B1">无线电话</a> （1946）</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E5%8B%95%E9%9B%BB%E8%A9%B1%E7%B3%BB%E7%B5%B1">MTS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Improved_Mobile_Telephone_Service&action=edit&redlink=1">IMTS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Altai_%EF%BC%88mobile_telephone_system%EF%BC%89&action=edit&redlink=1">Altai</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=OLT_%EF%BC%88mobile_network%EF%BC%89&action=edit&redlink=1">OLT</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=MTD_%EF%BC%88mobile_network%EF%BC%89&action=edit&redlink=1">MTA - MTB - MTC - MTD</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Advanced_Mobile_Telephone_System&action=edit&redlink=1">AMTS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Autotel&action=edit&redlink=1">Autotel （PALM）</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Autoradiopuhelin&action=edit&redlink=1">ARP</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=B-Netz&action=edit&redlink=1">B-Netz</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=AMR_radiotelephone_network_%EF%BC%88Czechoslovakia%EF%BC%89&action=edit&redlink=1">AMR</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/1G">1G</a>（1979）</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E6%AF%94%E5%BC%8F%E8%A1%8C%E5%8B%95%E9%9B%BB%E8%A9%B1%E7%B3%BB%E7%B5%B1">AMPS</a>家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E6%AF%94%E5%BC%8F%E8%A1%8C%E5%8B%95%E9%9B%BB%E8%A9%B1%E7%B3%BB%E7%B5%B1">AMPS - N-AMPS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Total_Access_Communication_System&action=edit&redlink=1">TACS - ETACS</a>其它<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Nordic_Mobile_Telephone&action=edit&redlink=1">NMT</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=C-Netz&action=edit&redlink=1">C-450</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Hicap&action=edit&redlink=1">Hicap</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Mobitex&action=edit&redlink=1">Mobitex</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=DataTAC&action=edit&redlink=1">DataTAC</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/2G">2G</a>（1991）</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GSM">GSM</a>/<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/3GPP">3GPP</a>家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GSM">GSM</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%B7%AF%E4%BA%A4%E6%8F%9B%E6%95%B8%E6%93%9A">CSD - HSCSD</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/3GPP2">3GPP2</a>家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CdmaOne">cdmaOne （IS-95）</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E6%AF%94%E5%BC%8F%E8%A1%8C%E5%8B%95%E9%9B%BB%E8%A9%B1%E7%B3%BB%E7%B5%B1">AMPS</a>家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/D-AMPS">D-AMPS （IS-54 and IS-136）</a>其它<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%9C%82%E7%AA%9D%E6%95%B0%E5%AD%97%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE">CDPD</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E6%95%B0%E5%AD%97%E5%A2%9E%E5%BC%BA%E7%BD%91%E7%BB%9C">iDEN</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/PDC">PDC</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AA%E4%BA%BA%E6%89%8B%E6%8C%81%E5%BC%8F%E7%94%B5%E8%AF%9D%E7%B3%BB%E7%BB%9F">PHS</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/2G">2G过渡 （2.5G, 2.75G）</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GSM">GSM</a>/3GPP家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GPRS">GPRS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GSM%E5%A2%9E%E5%BC%BA%E6%95%B0%E6%8D%AE%E7%8E%87%E6%BC%94%E8%BF%9B">EDGE/EGPRS - Evolved EDGE</a>3GPP2家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CDMA2000">CDMA2000 1X</a>（TIA/EIA/IS-2000）<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CDMA2000">CDMA2000 1X Advanced</a>其它<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E6%95%B0%E5%AD%97%E5%A2%9E%E5%BC%BA%E7%BD%91%E7%BB%9C">WiDEN</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E5%A2%9E%E5%BC%B7%E7%84%A1%E7%B7%9A%E9%9B%BB%E8%A9%B1%E7%B3%BB%E7%B5%B1">DECT</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/3G">3G</a>（2001）</td>
<td>3GPP家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E7%A7%BB%E5%8A%A8%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F">UMTS</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/W-CDMA">UTRA-FDD / W-CDMA</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/FOMA">FOMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TD-SCDMA">UTRA-TDD LCR / TD-SCDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E7%A7%BB%E5%8A%A8%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F">UTRA-TDD HCR / TD-CDMA</a>3GPP2家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EV-DO">CDMA2000 1xEV-DO Release 0</a>（TIA/IS-856）</td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/3G">3G过渡 （3.5G, 3.75G, 3.9G）</a></td>
<td>3GPP家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%80%9F%E5%B0%81%E5%8C%85%E5%AD%98%E5%8F%96">HSPA</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%80%9F%E5%B0%81%E5%8C%85%E5%AD%98%E5%8F%96">HSDPA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%80%9F%E5%B0%81%E5%8C%85%E5%AD%98%E5%8F%96">HSUPA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%BC%94%E8%BF%9B%E5%BC%8FHSPA">HSPA+</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%BC%94%E8%BF%9B%E5%BC%8FHSPA">DC-HSDPA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%95%B7%E6%9C%9F%E6%BC%94%E9%80%B2%E6%8A%80%E8%A1%93">LTE</a>（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/E-UTRA">E-UTRA</a>）3GPP2家族CDMA2000 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EV-DO">1xEV-DO Revision A</a>（TIA/EIA/IS-856-A）<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EV-DO">EV-DO Revision B</a>（TIA/EIA/IS-856-B）<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EV-DO">EV-DO Revision C</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%B5%E6%B0%94%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%BC%9A">IEEE</a>家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WiMAX">Mobile WiMAX</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IEEE_802.16">IEEE 802.16e</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E4%BA%A4%E9%A0%BB%E5%88%86%E5%A4%8D%E7%94%A8">Flash-OFDM</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=IEEE_802.20&action=edit&redlink=1">iBurst （IEEE 802.20）</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WiBro">WiBro</a>   <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%B4%B2%E7%94%B5%E4%BF%A1%E6%A0%87%E5%87%86%E5%8D%8F%E4%BC%9A">ETSI</a>家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=HiperMAN&action=edit&redlink=1">HiperMAN</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/4G">4G</a>（2009） <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=IMT_Advanced&action=edit&redlink=1">IMT Advanced</a> （2013）</td>
<td>3GPP家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%B2%E9%9A%8E%E9%95%B7%E6%9C%9F%E6%BC%94%E9%80%B2%E6%8A%80%E8%A1%93">LTE Advanced</a>（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/E-UTRA">E-UTRA</a>）<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%B2%E9%9A%8E%E5%8D%87%E7%B4%9A%E7%89%88%E9%95%B7%E6%9C%9F%E6%BC%94%E9%80%B2%E6%8A%80%E8%A1%93">LTE Advanced Pro</a>（4.5G Pro/pre-5G/4.9G）IEEE家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WiMAX">WiMAX</a>（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IEEE_802.16">IEEE 802.16</a>m） WiMax 2.1 （<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LTE-TDD">LTE-TDD</a>/ <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%95%B7%E6%9C%9F%E6%BC%94%E9%80%B2%E6%8A%80%E8%A1%93">TD-LTE</a>）<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WiBro">WiBro</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/5G">5G</a>（2019） <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=IMT-2020&action=edit&redlink=1">IMT-2020</a> （开发中）</td>
<td>3GPP家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/5G_NR">NR</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=NR-IIoT&action=edit&redlink=1">NR-IIoT</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=LTE-M&action=edit&redlink=1">LTE-M</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/NB-IoT">NB-IoT</a> 其它<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=DECT-5G&action=edit&redlink=1">DECT-5G</a></td>
</tr>
<tr>
<td align="right">相关</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%9C%82%E7%AA%9D%E7%BD%91%E7%BB%9C">蜂窝网络</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A2%91%E5%88%86%E5%A4%9A%E5%9D%80">FDMA</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E4%BA%A4%E9%A0%BB%E5%88%86%E5%A4%9A%E5%9D%80">OFDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%B6%E5%88%86%E5%A4%9A%E5%9D%80">TDMA</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Self-organized_time-division_multiple_access&action=edit&redlink=1">STDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%89%A9%E9%A2%91">SSMA</a> CDMA<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A9%BA%E5%88%86%E5%A4%9A%E5%9D%80">SDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A0%BB%E8%AD%9C%E6%95%88%E7%8E%87">频谱效率</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%9C%82%E7%AA%9D%E7%BD%91%E7%BB%9C%E9%A2%91%E7%8E%87&action=edit&redlink=1">频段</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GSM%E9%A2%91%E6%AE%B5">GSM</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/UMTS%E9%A2%91%E6%AE%B5">UMTS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%80%8B%E4%BA%BA%E9%80%9A%E8%A8%8A%E6%9C%8D%E5%8B%99">PCS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=LTE_frequency_bands&action=edit&redlink=1">LTE</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/5G_NR%E9%A2%91%E6%AE%B5">5G NR</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%AF%AC%E9%A0%BB">移动宽频</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Push-to-talk">Push-to-talk</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MIMO">MIMO</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%95%BF%E6%9C%9F%E6%BC%94%E8%BF%9B%E8%AF%AD%E9%9F%B3%E6%89%BF%E8%BD%BD">VoLTE</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/VoNR">VoNR</a></td>
</tr>
</tbody></table>
<h4 id="无线局域网-WLAN"><a href="#无线局域网-WLAN" class="headerlink" title="无线局域网  (WLAN)"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91">无线局域网  (WLAN)</a></h4><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IEEE_802.11_(%E5%8E%9F%E5%A7%8B%E6%A0%87%E5%87%86)">IEEE 802.11</a> 是无线局域网（WLAN）的通用标准。</p>
<p>1999年，几家富有远见的公司联合起来组成了一个全球性非营利性协会——无线以太网兼容性联盟（Wireless Ethernet Compatibility Alliance, WECA），其目标是使用一种新的无线网络技术，无论品牌如何，都能带来最佳的用户体验。在2000年，该小组采用术语“Wi-Fi”作为其技术工作的专有名称，并宣布了正式名称：Wi-Fi Alliance。Wi-Fi产品经由Wi-Fi联盟的一家独立授权测试实验室进行严格测试，产品成功通过测试后，授予制造商或销售商使用Wi-Fi标志、Wi-Fi CERTIFIED标志和相关商标，Wi-Fi联盟使用术语“Wi-Fi CERTIFIED”来称呼这类通过认证的产品。802.11ax为Wi-Fi 6。</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Wi-Fi">Wi-Fi</a>与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IEEE_802.11">IEEE 802.11</a>常常被混淆，两者的区别可以概述为IEEE 802.11是一种无线局域网标准，而Wi-Fi是IEEE 802.11标准的一种实现。</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%84%A1%E7%B7%9A%E6%8E%A5%E5%85%A5%E9%BB%9E">无线接入点 - 维基百科，自由的百科全书 (wikipedia.org)</a> WAP</p>
<h5 id="无线个人网-WPAN"><a href="#无线个人网-WPAN" class="headerlink" title="无线个人网 (WPAN)"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%BA%BF%E4%B8%AA%E4%BA%BA%E7%BD%91">无线个人网 (WPAN)</a></h5><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%97%8D%E7%89%99">蓝牙 - 维基百科，自由的百科全书 (wikipedia.org)</a> Bluetooth (WPAN，IEEE 802.15.1)</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ZigBee">ZigBee - 维基百科，自由的百科全书 (wikipedia.org)</a> ZigBee (LR-WPAN，IEEE 802.15.4)</p>
<h3 id="有线局域网-LAN"><a href="#有线局域网-LAN" class="headerlink" title="有线局域网 (LAN)"></a>有线局域网 (LAN)</h3><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91">以太网 - 维基百科，自由的百科全书 (wikipedia.org)</a> Ethernet LAN (IEEE 802.3)</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AE">点对点协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> PPP</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/PPPoE">PPPoE - 维基百科，自由的百科全书 (wikipedia.org)</a> PPP over Ethernet PPPoE</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/PPPoA">PPPoA - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%92%A5%E8%99%9F%E9%80%A3%E7%B7%9A">拨号连接 - 维基百科，自由的百科全书 (wikipedia.org)</a> Dial-up</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%88%B6%E8%A7%A3%E8%B0%83%E5%99%A8">调制解调器 - 维基百科，自由的百科全书 (wikipedia.org)</a> 猫 modem</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E7%94%A8%E6%88%B7%E7%BA%BF%E8%B7%AF">数字用户线路 - 维基百科，自由的百科全书 (wikipedia.org)</a> DSL</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ADSL">非对称数字用户线路- 维基百科，自由的百科全书 (wikipedia.org)</a> ADSL</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%BA%E6%8E%A5%E5%B0%88%E7%B7%9A">固接专线 - 维基百科，自由的百科全书 (wikipedia.org)</a> IPLC</p>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E4%BA%A4%E6%8F%9B%E5%99%A8">网络交换机 - 维基百科，自由的百科全书 (wikipedia.org)</a> Network switch</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A9%8B%E6%8E%A5%E5%99%A8">桥接器 - 维基百科，自由的百科全书 (wikipedia.org)</a> 网桥 Network Bridge</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E5%8D%A1">网络适配器 - 维基百科，自由的百科全书 (wikipedia.org)</a> 网卡 Network Adapter</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%86%E7%B7%9A%E5%99%A8">集线器 - 维基百科，自由的百科全书 (wikipedia.org)</a> Hub</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/8P8C">8P8C - 维基百科，自由的百科全书 (wikipedia.org)</a> RJ45</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%B2%E8%A1%8C%E7%AB%AF%E5%8F%A3">串行接口 - 维基百科，自由的百科全书 (wikipedia.org)</a> COM</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E8%A1%8C%E7%AB%AF%E5%8F%A3">并行端口 - 维基百科，自由的百科全书 (wikipedia.org)</a> LPT</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/USB">USB - 维基百科，自由的百科全书 (wikipedia.org)</a> Universal Serial Bus</p>
<h2 id="校验算法"><a href="#校验算法" class="headerlink" title="校验算法"></a>校验算法</h2><p>CRC（循环冗余校验）和汉明码都是错误检测和纠正的算法，但它们的底层原理和用途有所不同：</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%A0%E9%94%99%E7%A0%81">纠错码 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<h3 id="CRC（循环冗余校验）"><a href="#CRC（循环冗余校验）" class="headerlink" title="CRC（循环冗余校验）"></a>CRC（循环冗余校验）</h3><p>CRC 是一种通过数学方法检测数据传输错误的技术。它在底层通过<strong>多项式除法</strong>来生成校验码，将数据视为一个二进制多项式，并与一个预定的生成多项式相除。CRC的底层原理包括以下几个步骤：</p>
<ol>
<li><strong>数据多项式化</strong>：将待校验的数据视为一个二进制多项式，例如“1011”对应 ($x^3 + x + 1$)。</li>
<li><strong>生成多项式</strong>：选择一个生成多项式（如 CRC-32 使用 ($x^{32} + x^{26} + x^{23} + \ldots + x + 1$)）。</li>
<li><strong>模2除法</strong>：将数据多项式和生成多项式进行模2除法（不需要进位的二进制除法），余数即为CRC校验码。</li>
<li><strong>传输和校验</strong>：接收方用相同的生成多项式再进行除法运算，若余数为零，则说明数据没有错误。</li>
</ol>
<p>CRC 常用于检测网络传输中的错误，因为其计算效率高，适合硬件实现，并能检测较高概率的错误。</p>
<p>2^n^M  % P = FCS (Frame Check Sequence, 帧检验序列)</p>
<p>2^n^M + FCS % P = 0  如果M在传输过程中出现差错，结果将几乎不可能为0</p>
<h3 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h3><p>汉明码是一种<strong>错误纠正码</strong>，可以检测并纠正单比特错误，部分版本还能检测双比特错误。它的原理基于在数据中加入特定的校验位，使得数据在传输时出现单比特错误时可以被定位并纠正。</p>
<ol>
<li><strong>奇偶校验位的设置</strong>：汉明码会在原始数据中插入多个位置的奇偶校验位。这些位置是按二的幂次方设置的（如第1、2、4、8位等），每个校验位负责检查某些特定位置的数据位。</li>
<li><strong>校验位计算</strong>：每个校验位用来检查特定数据位的奇偶性。对于一个给定的二进制数据，可以通过指定的位操作生成一组校验位。</li>
<li><strong>错误检测和纠正</strong>：传输后，通过重新计算校验位的结果并与收到的校验位对比，可以检测并定位单个比特错误的位置，然后进行纠正。</li>
</ol>
<p>汉明码适用于内存或磁盘数据校验和恢复等场景，但较不适合复杂错误模式的网络数据传输。</p>
<h2 id="多址接入"><a href="#多址接入" class="headerlink" title="多址接入"></a>多址接入</h2><p>当多个用户接入网络时，解决如何高效地共享一个无线资源（时间/频率/空间/载波）的技术。</p>
<h3 id="CSMA-载波侦听多路访问"><a href="#CSMA-载波侦听多路访问" class="headerlink" title="CSMA 载波侦听多路访问"></a>CSMA 载波侦听多路访问</h3><p>严格意义上不算MA，因为并没有真正共享</p>
<p>CSMA（Carrier Sense Multiple Access） 是一种<strong>载波监听多址接入</strong>协议，通常用于有线网络中，允许多台设备共享同一信道资源。CSMA 的核心思想是通过监听信道来避免冲突，主要有以下两种变体：</p>
<h4 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h4><p><strong>（Collision Detection，碰撞检测）</strong>半双工</p>
<ul>
<li>应用于有线以太网（如 IEEE 802.3 标准）。在此模式下，设备在发送数据前先监听信道。如果信道空闲，数据即可发送；如果信道忙，设备会等待空闲后发送。</li>
<li>若在发送过程中发生冲突（检测到信号碰撞），设备会立即停止发送，并在随机时间后重试。</li>
<li>CSMA/CD 主要用于有线网络，如早期的以太网，由于信道冲突频繁，现已逐渐被交换式以太网替代。</li>
</ul>
<h4 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA/CA"></a>CSMA/CA</h4><p><strong>（Collision Avoidance，碰撞避免）</strong></p>
<ul>
<li>常用于无线网络（如 Wi-Fi/IEEE 802.11），因无线信道难以检测碰撞。</li>
<li>CSMA/CA 通过在发送数据前监听信道，并等待一定时间以减少冲突发生，确保信道空闲时才进行发送。</li>
<li>CSMA/CA 的碰撞避免机制更加适合无线信道的开放式环境。</li>
</ul>
<h3 id="CDMA-码分多址"><a href="#CDMA-码分多址" class="headerlink" title="CDMA 码分多址"></a>CDMA 码分多址</h3><p>多路复用技术</p>
<p>CDMA 是<strong>码分多址接入</strong>（Code Division Multiple Access）技术，主要用于蜂窝网络中。CDMA 的关键思想是通过为每个用户分配独特的伪随机码（PN 码）来区分不同用户的数据流，这样多个用户可以在同一频带内同时发送数据而不产生干扰。CDMA 的工作原理和优势如下：</p>
<ul>
<li><strong>伪随机码分配</strong>：每个用户的数据流会被一个特定的伪随机码调制，接收端利用相同的伪随机码解调，从而提取对应的数据。</li>
<li><strong>同时占用信道</strong>：不同用户使用不同的伪随机码，可以在同一频带内同时传输数据，极大提高了频谱利用率。</li>
<li><strong>抗干扰能力强</strong>：CDMA 的码分多址方式在信号干扰和路径损耗上有较强的容忍度，适合蜂窝移动通信。</li>
<li><strong>应用</strong>：CDMA 主要应用于 2G、3G 的通信网络，特别是在美国、韩国的移动通信系统中被广泛使用，如 CDMA2000。</li>
</ul>
<h4 id="WCDMA"><a href="#WCDMA" class="headerlink" title="WCDMA"></a>WCDMA</h4><p>WCDMA（Wideband Code Division Multiple Access） 是<strong>宽带码分多址接入</strong>技术，基于 CDMA 的一种改进版本，是 3GPP（第三代合作伙伴计划）推出的 3G 标准之一。它在 CDMA 基础上使用更宽的带宽，从而提高数据速率和网络容量，是全球范围内 3G 网络的主流技术之一。</p>
<ul>
<li><strong>更宽的频谱带宽</strong>：WCDMA 使用 5 MHz 的带宽（相比 CDMA 的 1.25 MHz 带宽），支持更高的数据传输速率和更多用户接入。</li>
<li><strong>更高的数据速率</strong>：在理想条件下，WCDMA 可实现高达 2 Mbps 的速率，支持语音、数据、视频等多种业务。</li>
<li><strong>频谱效率</strong>：通过更宽的频谱和 CDMA 的抗干扰特性，WCDMA 能在高用户密度环境下提供稳定的连接。</li>
<li><strong>应用</strong>：WCDMA 被广泛应用于全球的 3G 网络中，尤其是欧洲和亚洲的 GSM 网络运营商采用 WCDMA 技术升级到 3G。此技术在 4G LTE 的发展中逐步退出历史舞台。</li>
</ul>
<h4 id="TD-SCDMA"><a href="#TD-SCDMA" class="headerlink" title="TD-SCDMA"></a>TD-SCDMA</h4><p><strong>TD-SCDMA</strong>（Time Division Synchronous Code Division Multiple Access，时分同步码分多址）是中国自主研发的第三代移动通信标准，也是 3G 标准之一，由中国大唐电信和西门子公司联合开发，并被国际电信联盟（ITU）接纳为 3G 标准之一。TD-SCDMA 在中国得到了广泛的应用，但在国际市场上相对较少。</p>
<p>TD-SCDMA 的优势</p>
<ul>
<li><strong>频谱利用率高</strong>：采用 TDD 模式和同步技术，使得 TD-SCDMA 的频谱利用率相比传统的 FDD 制式更高，适合频谱资源紧张的环境。</li>
<li><strong>适合不对称数据业务</strong>：可以根据实际流量需求调整上下行资源分配，特别适合数据业务占用较高的场景。</li>
<li><strong>自主知识产权</strong>：TD-SCDMA 是中国自主研发的 3G 标准，拥有大量核心专利，减少了对外部技术的依赖。</li>
</ul>
<p>TD-SCDMA 的局限性</p>
<ul>
<li><strong>国际支持度低</strong>：TD-SCDMA 主要在中国应用，国际上接受度不高，设备的生态系统较小，终端设备支持度有限。</li>
<li><strong>覆盖和稳定性问题</strong>：与 WCDMA 和 CDMA2000 相比，TD-SCDMA 的覆盖范围和信号穿透性相对较差，容易受信号衰减影响。</li>
<li><strong>技术升级受限</strong>：由于 3G 技术已经逐渐被淘汰，TD-SCDMA 的技术升级和演进受到了较大限制。</li>
</ul>
<h3 id="FDMA-频分多址"><a href="#FDMA-频分多址" class="headerlink" title="FDMA 频分多址"></a>FDMA 频分多址</h3><p>FDMA（Frequency Division Multiple Access）</p>
<ul>
<li><strong>原理</strong>：通过将可用频谱划分成多个独立的频段，每个用户使用一个独立的频段传输数据，彼此不会干扰。</li>
<li><strong>应用</strong>：早期的模拟蜂窝网络（如 1G），一些卫星通信系统也使用 FDMA。</li>
<li><strong>特点</strong>：实现简单，适合带宽分配相对固定的场景，但频谱利用效率不高。</li>
</ul>
<h4 id="OFDMA-正交频分多址"><a href="#OFDMA-正交频分多址" class="headerlink" title="OFDMA 正交频分多址"></a>OFDMA 正交频分多址</h4><p>OFDMA（Orthogonal Frequency Division Multiple Access）</p>
<ul>
<li><strong>原理</strong>：将信道划分为多个子载波，通过正交性减少子载波之间的干扰，允许多个用户同时占用不同的子载波进行传输。</li>
<li><strong>应用</strong>：4G LTE、Wi-Fi 6（802.11ax）、WiMAX（802.16）等。</li>
<li><strong>特点</strong>：频谱利用效率高，适合宽带数据传输，并在密集环境下表现优异。</li>
</ul>
<h4 id="SC-FDMA-单载波频分多址"><a href="#SC-FDMA-单载波频分多址" class="headerlink" title="SC-FDMA 单载波频分多址"></a>SC-FDMA 单载波频分多址</h4><p>SC-FDMA（Single Carrier Frequency Division Multiple Access）单载波频分多址</p>
<ul>
<li><p><strong>原理</strong>：将上行链路的数据划分成多个子载波进行传输，使用单载波调制来减少功率峰值。</p>
</li>
<li><p><strong>应用</strong>：4G LTE 上行链路。</p>
</li>
<li><p><strong>特点</strong>：降低了上行链路中的峰均功率比（PAPR），适合移动设备的功率限制。</p>
</li>
<li></li>
</ul>
<h3 id="TDMA-时分多址"><a href="#TDMA-时分多址" class="headerlink" title="TDMA 时分多址"></a>TDMA 时分多址</h3><p>TDMA（Time Division Multiple Access）</p>
<ul>
<li>原理：将信道分为不同的时间片，每个用户轮流在特定时间片上使用信道，从而达到多用户共享信道的目的。</li>
<li><strong>应用</strong>：GSM（2G）、PHS、部分卫星通信。</li>
<li><strong>特点</strong>：在一定程度上提高了频谱利用率，但时延较高，受限于用户数量增加后的带宽分配。</li>
</ul>
<h3 id="SDMA-空分多址"><a href="#SDMA-空分多址" class="headerlink" title="SDMA 空分多址"></a>SDMA 空分多址</h3><p>SDMA（Space Division Multiple Access）</p>
<ul>
<li><strong>原理</strong>：通过空间隔离的方式区分用户信号，通常结合智能天线等技术，在同一频段和时间使用不同方向的波束来服务不同用户。</li>
<li><strong>应用</strong>：主要在蜂窝基站和无线局域网中使用，配合 MIMO（多输入多输出）技术使用，增强信道容量。</li>
<li><strong>特点</strong>：适合用户密集度高的环境，频谱利用效率较高。</li>
</ul>
<h3 id="NOMA-非正交多址"><a href="#NOMA-非正交多址" class="headerlink" title="NOMA 非正交多址"></a>NOMA 非正交多址</h3><p>NOMA（Non-Orthogonal Multiple Access）</p>
<ul>
<li><strong>原理</strong>：不同用户可以同时占用同一时间和频率资源，通过功率差异进行用户分离，接收端使用 SIC（Successive Interference Cancellation）分离信号。</li>
<li><strong>应用</strong>：5G 网络中使用较多，提升频谱效率。</li>
<li><strong>特点</strong>：频谱利用效率高，适合高用户密度场景，但对接收端的处理要求较高。</li>
</ul>
<h3 id="PDMA-模式分割多址"><a href="#PDMA-模式分割多址" class="headerlink" title="PDMA 模式分割多址"></a>PDMA 模式分割多址</h3><p>PDMA（Pattern Division Multiple Access）</p>
<ul>
<li><strong>原理</strong>：通过对信号的模式（如频域、时域、空域等）进行不同配置来分割用户信道。</li>
<li><strong>应用</strong>：5G NR（New Radio）新型多址接入技术之一。</li>
<li><strong>特点</strong>：结合空间、时间等多个维度的模式，进一步提高频谱效率。</li>
</ul>
<h3 id="MIMO"><a href="#MIMO" class="headerlink" title="MIMO"></a>MIMO</h3><p>MIMO（Multiple Input Multiple Output）多输入多输出</p>
<ul>
<li><strong>原理</strong>：通过多根天线发送和接收多个数据流，提高信道容量。</li>
<li><strong>应用</strong>：4G LTE、Wi-Fi 6、5G 等。</li>
<li><strong>特点</strong>：不属于严格的多址技术，但与 SDMA、OFDMA 等结合，能够显著提升数据传输速率和覆盖范围。</li>
</ul>
<h3 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h3><ul>
<li><strong>原理</strong>：用户在任意时间段发送数据包，碰撞后重新发送；时隙 ALOHA 则将时间分割成固定时隙，用户在时隙开始时发送数据，减少了冲突概率。</li>
<li><strong>应用</strong>：早期的卫星通信、无线传感器网络。</li>
<li><strong>特点</strong>：简单易实现，但冲突率高，频谱利用率较低，通常不用于高效的现代网络。</li>
</ul>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p><strong>IP地址：</strong>MAC地址属于物理地址，不够抽象，换了网卡还得重新建立联系。IP 地址是在计算机网络中用于标识设备的，然而它本身与具体的硬件设备无关<strong>是为了支持路由而设计的</strong>，使得数据能够在复杂的网络中找到目标设备，本质上是网络层的一种抽象，根据一定的规则和协议进行分配，帮助实现数据包在全球范围内的传输。</p>
<p><strong>ARP协议</strong>:实际通信还是要通过物理地址也就是mac的，机器1传给交换机目标IP地址，机器2收到ip广播，记录来源的mac地址，这样机器2就知道了机器1的mac，并将自己的mac返回给机器1（<strong>ARP</strong>协议,根据IP解析MAC）以后就能直接通信。缺点：MAC地址表溢出，全网泛洪，效率低下。（<u>网络层和数据链路层的边界</u>） </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921204958721.png" alt="image-20240921204958721"></p>
<p><strong>子网掩码：</strong> 上述交换机的缺点导致其只能连接少数设备，所以就应该把网络分成一个个子网，由交换机负责单个子网的通信，子网掩码就是告诉计算机 子网的ID是IP前几位，消息发给交换机，如果根据子网掩码，目的IP不是子网，就将信息传给路由器。<u>网络层</u> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921204925827.png" alt="image-20240921204925827"> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921205145960.png" alt="image-20240921205145960"></p>
<p><strong>路由器：</strong> 同一台路由器连接的计算机，他们的<strong>网关</strong>(子网的关口、出口)相同，都是路由器的IP地址。路由器上有一张路由表，可以配置目标网段和 next jump ，用来决定各网段消息下一步应该交给哪个路由器。OSPF自动学习自动管理路由表，BGP是为了应对庞大的网络，确定数据包的最佳路径。在<u>网络层</u></p>
<p><strong>路由器vs交换机</strong> </p>
<ol>
<li><strong>工作层次不同</strong>：</li>
</ol>
<ul>
<li><strong>路由器</strong>：工作在 <strong>网络层（OSI 模型的第 3 层）</strong>，基于 IP 地址来转发数据包。它可以在不同的网络之间进行数据转发，比如将本地局域网与互联网连接起来。路由器可以通过 IP 地址进行路由选择，确定数据包的最佳传输路径。</li>
<li><strong>交换机</strong>：工作在 <strong>数据链路层（OSI 模型的第 2 层）</strong>，基于 MAC 地址来转发数据帧。它用于在同一个局域网（LAN）内连接多个设备，并通过 MAC 地址表来进行帧的转发和处理。高端交换机（如三层交换机）也可以在网络层上进行工作，具备一定的路由功能。</li>
</ul>
<ol start="2">
<li><strong>主要用途</strong>：</li>
</ol>
<ul>
<li><strong>路由器</strong>：用于连接<strong>不同的网络</strong>，比如将你的家庭网络或局域网与互联网连接。它不仅能处理 LAN 内部的通信，还能通过 WAN 端口将内部网络连接到外部网络（如互联网）。路由器在网络之间转发数据，并为不同的网络分配和管理 IP 地址。</li>
<li><strong>交换机</strong>：用于<strong>同一网络</strong>中的设备互联，主要在局域网（LAN）内部使用。交换机可以通过多个端口连接多个设备（如电脑、服务器、打印机等），并基于 MAC 地址表快速高效地在这些设备之间转发数据。它不会管理或处理外部网络通信。</li>
</ul>
<ol start="3">
<li><strong>数据转发方式</strong>：</li>
</ol>
<ul>
<li><strong>路由器</strong>：根据<strong>IP 地址</strong>进行路由。它维护一个路由表，用来确定数据包的最佳路径，可能需要跨越多个网络。路由器使用不同的网络协议（如 OSPF、BGP）来管理和更新这些路由表。</li>
<li><strong>交换机</strong>：根据<strong>MAC 地址</strong>转发数据帧。它通过学习每个设备的 MAC 地址并将其存储在 MAC 地址表中，来确定应该将数据帧转发到哪个端口。交换机在一个局域网内部通过这种方式高效转发流量。</li>
</ul>
<ol start="4">
<li><strong>连接范围</strong>：</li>
</ol>
<ul>
<li><strong>路由器</strong>：通常连接<strong>不同的网络</strong>，比如家庭网络和互联网之间，或者连接多个子网。它的主要作用是通过不同的 IP 网段来连接和隔离不同的网络。</li>
<li><strong>交换机</strong>：主要连接<strong>同一个局域网中的设备</strong>，如多台计算机、打印机等，形成一个共享的局域网。</li>
</ul>
<ol start="5">
<li><strong>网络地址分配与管理</strong>：</li>
</ol>
<ul>
<li><strong>路由器</strong>：一般可以通过 <strong>DHCP（动态主机配置协议）</strong> 分配 IP 地址，管理局域网内设备的 IP 地址，并充当网络的网关，将局域网中的设备连接到外部网络。</li>
<li><strong>交换机</strong>：通常不具备 DHCP 等功能，它只是转发数据，不会负责分配 IP 地址。不过，高级管理型交换机可能具备一些网络管理功能。</li>
</ul>
<ol start="6">
<li><strong>NAT（网络地址转换）功能</strong>：</li>
</ol>
<ul>
<li><strong>路由器</strong>：大多数路由器提供 <strong>NAT 功能</strong>，这允许多个内网设备通过一个公共 IP 地址访问外部网络（如互联网）。NAT 会在网络地址翻译时修改 IP 数据包的源或目标 IP 地址。</li>
<li><strong>交换机</strong>：没有 NAT 功能。它仅在局域网内部转发数据帧，不处理 IP 层的转换。</li>
</ul>
<p>重点：ip首部格式 ip分片 ip选路 路由表 ICMP格式、分类(2+5)</p>
<h2 id="协议-2"><a href="#协议-2" class="headerlink" title="协议"></a>协议</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE">地址解析协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> ARP IPv4 IP地址到MAC地址 ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%82%BB%E5%B1%85%E5%8F%91%E7%8E%B0%E5%8D%8F%E8%AE%AE">邻居发现协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> NDP 基于IPv6</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE">网际协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> IP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%8E%A7%E5%88%B6%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE">互联网控制消息协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> ICMP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%BB%84%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE">互联网组管理协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> IGMP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BE%B9%E7%95%8C%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE">边界网关协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> BGP 基于 TCP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE">内部网关协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> IGP </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E5%BC%8F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%BC%98%E5%85%88">开放式最短路径优先 - 维基百科，自由的百科全书 (wikipedia.org)</a> OSPF 基于IP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E5%8D%8F%E8%AE%AE">路由信息协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> RIP 基于UDP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IPsec">IPsec - 维基百科，自由的百科全书 (wikipedia.org)</a> IPSec</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">网络地址转换 - 维基百科，自由的百科全书 (wikipedia.org)</a> NAT  ✅</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E7%B6%B2%E8%B7%AF%E6%8F%92%E5%BA%A7">网络套接字 - 维基百科，自由的百科全书 (wikipedia.org)</a> Socket  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%9C%8D%E5%8A%A1%E4%BE%9B%E5%BA%94%E5%95%86">互联网服务提供商 - 维基百科，自由的百科全书 (wikipedia.org)</a>ISP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%89%98%E7%AE%A1%E6%9C%8D%E5%8A%A1">互联网托管服务 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%89%E5%B0%8E%E7%BA%96%E7%B6%AD">光导纤维 - 维基百科，自由的百科全书 (wikipedia.org)</a> Fiber</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE">隧道协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> Tunnel  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E8%B7%AF%E7%94%B1%E5%B0%81%E8%A3%85">通用路由封装 - 维基百科，自由的百科全书 (wikipedia.org)</a> GRE</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E7%A7%81%E4%BA%BA%E7%B6%B2%E8%B7%AF">虚拟专用网 - 维基百科，自由的百科全书 (wikipedia.org)</a> VPN  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8">代理服务器 - 维基百科，自由的百科全书 (wikipedia.org)</a> Proxy  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SOCKS">SOCKS - 维基百科，自由的百科全书 (wikipedia.org)</a> SOCKS</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E5%A2%99">防火墙 - 维基百科，自由的百科全书 (wikipedia.org)</a> Firewall</p>
<h2 id="硬件-1"><a href="#硬件-1" class="headerlink" title="硬件"></a>硬件</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8">路由器 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BD%8F%E5%AE%85%E7%BD%91%E5%85%B3">住宅网关 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p>Network Address Transition</p>
<p><strong>NAT协议，公网IP</strong>：IPv4数目限制，子网共用一个IP，发送数据的时候传给路由器，路由器内部<strong>NAT</strong>映射表记录内网IP对应的内网端口以及随机分配的可用公网端口号，信息从路由器的端口里出去，之后报文里的IP和端口全部都是公网的（篡改）冒充子网计算机跟目的地通信。某个端口收到响应，路由器根据NAT表映射到内网的IP跟端口，然后把响应传给桌子往计算机</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921211102189.png" alt="image-20240921211102189"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921211225744.png" alt="image-20240921211225744"></p>
<p>目的地的路由器收到报文后，再次根据NAT映射表，将报文精准发送给对应IP的对应端口，但是此时的目的地并不知道来源的真实端口和IP。因此不能直接与其通信，两台处于不同子网的设备是不能相互找到和通信的，因此有了端口转发，VPN等方式通信</p>
<ol>
<li><strong>内部到外部的通信</strong></li>
</ol>
<ul>
<li>内网设备（使用私有 IP 地址）发起访问外部网络的请求时，NAT 会将内网设备的私有 IP 地址和端口号转换为路由器的公共 IP 地址和一个动态分配的外部端口。</li>
<li>这种方式允许内网设备共享一个公共 IP 地址，通过不同的外部端口来区分多个连接。</li>
</ul>
<ol start="2">
<li><strong>外部响应的处理</strong></li>
</ol>
<ul>
<li>当外部网络（例如互联网上的服务器）响应内网设备的请求时，NAT 路由器根据维护的 NAT 表将外部响应流量（发往公共 IP 地址和端口）转换回相应的内网设备的私有 IP 地址和端口。</li>
<li>这使得内网设备能够从外部网络获取响应数据。</li>
</ul>
<ol start="3">
<li><strong>默认不处理外部对内部的主动连接</strong></li>
</ol>
<ul>
<li>NAT 的设计初衷是为了<strong>保护内网</strong>，并允许内网设备访问外部网络。所以，外部设备<strong>无法直接发起请求</strong>到 NAT 后的内网设备，除非进行额外的配置（例如端口转发）。</li>
<li>当外部网络试图访问路由器的公共 IP 地址时，NAT 路由器会没有匹配的 NAT 规则来将外部请求路由到内网设备，因为没有预先建立的映射关系。</li>
</ul>
<p><strong>如何让外部访问内部设备</strong>？</p>
<p>虽然默认情况下 NAT 不允许外部设备主动访问内网设备，但通过一些配置，可以实现外部访问内部网络：</p>
<ol>
<li><strong>端口转发（Port Forwarding）</strong>：<ul>
<li>通过手动配置 NAT 路由器，你可以将外部的特定端口请求映射到内网设备的 IP 地址和端口。这样，当外部网络访问路由器的公共 IP 地址和该端口时，路由器会将流量转发给指定的内网设备。</li>
<li>例如，将外部的 <code>203.0.113.5:8080</code> 端口映射到内网设备 <code>192.168.1.10:80</code>，从而实现外部访问内网中的 Web 服务器。</li>
</ul>
</li>
<li><strong>DMZ（Demilitarized Zone，非军事区）</strong>：<ul>
<li>DMZ 功能允许你将内网中的某台设备完全暴露给外部网络。所有未指定端口的外部请求都将被路由到 DMZ 主机。</li>
<li>这使得外部设备能够访问该主机，但同时也减少了该设备的安全性。</li>
</ul>
</li>
<li><strong>VPN（虚拟专用网络）</strong>：<ul>
<li>通过在外部设备和内网之间建立 VPN 连接，外部设备可以成为虚拟子网中的一部分，获得与内网设备直接通信的能力。VPN 通常是一种更安全的访问内部设备的方式。</li>
</ul>
</li>
<li><strong>反向连接</strong>：<ul>
<li>内网设备可以主动与外部设备建立连接（如通过反向 SSH 隧道），让外部设备通过该连接间接访问内网中的设备。</li>
</ul>
</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921211251306.png" alt="image-20240921211251306"></p>
<h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p><strong>分配IP</strong>  <strong>内网-使用DHCP协议</strong>首次连接路由器，设备要广播DHCP Discover 请求，表示自己需要连接网络。路由器监听DHCP请求，能够<strong>动态</strong>管理自己的IP池，通过DHCP Offer给计算机分配IP地址和默认网关（用于访问外部地址）以及子网掩码和<strong>DNS</strong> 设备收到以后Request，路由器收到以后发送ACK，确认分配并连接成功。设备使用某个IP地址的时间有限，到时间如果设备不再续用，DHCP服务器会回收。某些设备可能需要为静态的IP，这个可以通过MAC绑定也可以手动配置。</p>
<p> <strong>公网</strong> <strong>静态：</strong>根据运营商提供的静态IP，子网掩码，网关，dns手动配置。<strong>动态DHCP</strong>。 <strong>拨号</strong> 家庭公网使用PPPoE协议向运营商动态租用（PPPoE提供了身份验证功能，也就是宽带账号)</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>IP和<strong>域名 Domain Name</strong> dns可以将域名解析为ip地址，提供了用户友好的方式来访问互联网资源 属于<u>应用层</u> </p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p><strong>端口</strong>：同一台设备中，不同应用程序有不同端口，发送地址时候要加上目标端口和目标IP (UDP给应用程序标注了身份)<u>传输层</u></p>
<p><strong>TCP</strong>: UDP没有确认机制，可靠性差于是有了TCP，在不可靠信道上建立可靠连接,但是速度慢，网络游戏和视频流仍然使用UDP</p>
<p><strong>重试机制</strong>(接收方确认) <u>传输层</u></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921210407572.png" alt="image-20240921210407572"></p>
<p><strong>数据分包整理机制</strong>（分包，标注序号，大段数据的小段错误不用全部重新发送，接收方回复确认要针对序号进行回复）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921210327520.png" alt="image-20240921210327520"></p>
<p><strong>连接的建立</strong>（三次握手）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921210305337.png" alt="image-20240921210305337"></p>
<p><strong>流量控制机制，动态调整一次发送分包个数</strong>（滑动窗口、拥塞控制，慢启动，快速重传，快速恢复）</p>
<p>接收方一次可能接不住全部包</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921210631037.png" alt="image-20240921210631037"></p>
<p> <strong>连接的断开</strong>（四次挥手）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921210704880.png" alt="image-20240921210704880"></p>
<p><strong>应用层传输协议</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240921210737934.png" alt="image-20240921210737934"></p>
<h2 id="协议-3"><a href="#协议-3" class="headerlink" title="协议"></a>协议</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BC%8F">网络控制程序 - 维基百科，自由的百科全书 (wikipedia.org)</a> NCP</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">传输控制协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> TCP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5">用户数据报协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> UDP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TCP/UDP%E7%AB%AF%E5%8F%A3%E5%88%97%E8%A1%A8">TCP/UDP端口列表 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<p>重点：udp tcp(特点，首部，校验和，连接控制三握四挥 同关 同开 半关，流量控制记住，超时重传)</p>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>理论上讲，有了以上三层协议的支持，数据已经可以从一个主机上的应用程序传输到另一台主机的应用程序了，但此时传过来的数据是字节流，不能很好的被程序识别，操作性差，因此，应用层定义了各种各样的协议来规范数据格式，常见的有<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/http/243074?fromModule=lemma_inlink">http</a>,ftp,<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/smtp/175887?fromModule=lemma_inlink">smtp</a>等，在请求<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Header/688992?fromModule=lemma_inlink">Header</a>中，分别定义了请求数据格式Accept和响应数据格式Content-Type，有了这个规范以后，当对方接收到请求以后就知道该用什么格式来解析，然后对请求进行处理，最后按照请求方要求的格式将数据返回，请求端接收到响应后，就按照规定的格式进行解读。</p>
<p>除了HTTP和HTTPS之外，还有很多其他的网络协议，用于不同的应用和目的。以下是一些常见的协议：</p>
<ol>
<li>**FTP (File Transfer Protocol)**：用于在计算机之间传输文件。前缀为 <code>ftp://</code>。</li>
<li>**SFTP (Secure File Transfer Protocol)**：在FTP的基础上增加了加密层，确保文件传输的安全性。前缀通常为 <code>sftp://</code>。</li>
<li>**FTPS (FTP Secure)**：FTP的安全版本，通过TLS/SSL加密传输。前缀为 <code>ftps://</code>。</li>
<li>**SMTP (Simple Mail Transfer Protocol)**：用于发送电子邮件。虽然它通常不在URL中直接使用，但它是邮件服务器之间传输邮件的主要协议。</li>
<li>**IMAP (Internet Message Access Protocol)**：用于从邮件服务器检索电子邮件。常见的前缀是 <code>imap://</code>。</li>
<li>**POP3 (Post Office Protocol version 3)**：也是用于从邮件服务器检索电子邮件的协议，前缀为 <code>pop3://</code>。</li>
<li><strong>Telnet</strong>：一种远程终端协议，用于通过网络连接到远程计算机。前缀为 <code>telnet://</code>。</li>
<li>**SSH (Secure Shell)**：用于安全地远程登录到计算机系统。前缀为 <code>ssh://</code>。</li>
<li><strong>HTTP（Hypertext Transfer Protocol）</strong>：超文本传输协议，是一种用于从web服务器传输网页的协议。<ol>
<li><code>http://</code> 表示该网页使用的是HTTP协议。HTTP是一个无状态的协议，意味着每次请求都是独立的，不会记录之前的交互状态。</li>
<li><code>https://</code>：在HTTP的基础上，HTTPS（HTTP Secure）增加了加密层（使用TLS/SSL协议），用于确保数据在传输过程中是安全的。<code>https://</code> 用于需要保护数据隐私和完整性的网页，如在线银行和购物网站。</li>
</ol>
</li>
</ol>
<h2 id="应用间通信架构"><a href="#应用间通信架构" class="headerlink" title="应用间通信架构"></a>应用间通信架构</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BB%88%E7%AB%AF/15634871">终端（通信技术术语）_百度百科 (baidu.com)</a> Terminal终端</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA">网络主机 - 维基百科，自由的百科全书 (wikipedia.org)</a> Host主机</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Host_(network)">Host (network) - Wikipedia</a> Host</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%AE%A2%E6%88%B7%E6%9C%BA/5937024">主从式架构 - 服务器-客户机(C/S)_百度百科 (baidu.com)</a> Client/Server  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器 - 维基百科，自由的百科全书 (wikipedia.org)</a> server  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model">Client–server model - Wikipedia</a>C/S  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/B%2FS%E7%BB%93%E6%9E%84/4868588">B/S结构_百度百科 (baidu.com)</a> Browser/Server  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Distributed_computing#Examples">Distributed computing - Wikipedia</a> 分布式计算 </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A">进程间通信 - 维基百科，自由的百科全书 (wikipedia.org)</a> IPC</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Inter-process_communication">Inter-process communication - Wikipedia</a> IPC</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8">远程过程调用(Remote Procedure Call) - 维基百科，自由的百科全书 (wikipedia.org)</a> RPC  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Remote_procedure_call">Remote procedure call - Wikipedia</a> RPC</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Java_remote_method_invocation">Java remote method invocation - Wikipedia</a> Java RMI </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Java%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8">Java远程方法调用 - 维基百科，自由的百科全书 (wikipedia.org)</a> Java RMI</p>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multitier_architecture">Multitier architecture - Wikipedia</a> 多层架构</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%AD%89%E7%B6%B2%E8%B7%AF">点对点网络 - 维基百科，自由的百科全书 (wikipedia.org)</a> P2P</p>
</li>
</ul>
<h2 id="软件设计模式"><a href="#软件设计模式" class="headerlink" title="软件设计模式"></a>软件设计模式</h2><table>
<thead>
<tr>
<th align="center">Designing Pattern</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80">设计模式</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%89%B5%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">创建型</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82">抽象工厂</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F">生成器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95">工厂方法</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E6%A8%A1%E5%BC%8F">惰性初始</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">原型</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B5%90%E6%A7%8B%E5%9E%8B%E6%A8%A1%E5%BC%8F">结构型</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">适配器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A9%8B%E6%8E%A5%E6%A8%A1%E5%BC%8F">桥接</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Composite_pattern&action=edit&redlink=1">Composite</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%AE%E9%A5%B0%E6%A8%A1%E5%BC%8F">修饰</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%96%E8%A7%80%E6%A8%A1%E5%BC%8F">外观</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F">享元</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">代理</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%82%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">行为型</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F">责任链</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F">命令</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Interpreter_pattern&action=edit&redlink=1">Interpreter</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F">迭代器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F">中介者</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Memento_pattern&action=edit&redlink=1">Memento</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">观察者</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Specification_pattern&action=edit&redlink=1">Specification</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=State_pattern&action=edit&redlink=1">State</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F">策略</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95">模板方法</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F">访问者</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BD%B5%E7%99%BC%E5%9E%8B%E6%A8%A1%E5%BC%8F">并行模式</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E4%B8%BB%E5%8A%A8%E5%AF%B9%E8%B1%A1&action=edit&redlink=1">主动对象</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E9%98%BB%E6%AD%A2%E6%A8%A1%E5%BC%8F&action=edit&redlink=1">阻止</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Binding_properties&action=edit&redlink=1">Binding properties</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E6%A8%A1%E5%BC%8F">双重检查锁定模式</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8">异步方法调用</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Guarded_suspension&action=edit&redlink=1">Guarded suspension</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Join%E6%A8%A1%E5%BC%8F&action=edit&redlink=1">Join</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%94%81_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">锁</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Messaging&action=edit&redlink=1">Messaging</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%A3%E8%A6%96%E5%99%A8_(%E7%A8%8B%E5%BA%8F%E5%90%8C%E6%AD%A5%E5%8C%96)">监视器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Proactor_pattern&action=edit&redlink=1">Proactor</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%BA%94%E5%99%A8%E6%A8%A1%E5%BC%8F">反应器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AF%BB%E5%86%99%E9%94%81">读写锁</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">调度</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%B1%A0">线程池</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8">线程局部存储</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F">架构模式</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Action%E2%80%93Domain%E2%80%93Responder&action=edit&redlink=1">ADR</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Broker_pattern&action=edit&redlink=1">Broker</a>主从式架构<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E7%BB%84%E4%BB%B6%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B">CBD</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1">DAO</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">主动记录</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E6%98%A0%E5%B0%84%E5%99%A8%E6%A8%A1%E5%BC%8F">数据映射器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88">DDD</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Data_transfer_object&action=edit&redlink=1">Data transfer object</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Front_controller&action=edit&redlink=1">Front controller</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Identity_map_pattern&action=edit&redlink=1">Identity map</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Interceptor_pattern&action=edit&redlink=1">Interceptor</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC">控制反转</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MVC">MVC</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9C%8D%E5%8B%99">微服务</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Model-view-presenter">MVP</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%96%AE%E9%AB%94%E5%BC%8F%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F">单体式应用程序</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%B1%82%E6%9E%B6%E6%9E%84">多层架构</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Naked_objects&action=edit&redlink=1">Naked objects</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%AD%89%E7%B6%B2%E8%B7%AF">P2P</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85">发布/订阅</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2">REST</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">SOA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Specification_pattern&action=edit&redlink=1">Specification</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%91%E8%AE%A1%E7%AE%97">云</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97">分布式</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%96%B7%E8%B7%AF%E5%99%A8%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F">断路器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%91%BD%E4%BB%A4%E9%98%9F%E5%88%97%E5%88%86%E7%A6%BB&action=edit&redlink=1">CQRS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%A1%A5%E5%81%BF%E4%BA%A4%E6%98%93&action=edit&redlink=1">补偿交易</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95">索引表</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E9%A2%86%E5%AF%BC%E8%80%85%E9%80%89%E4%B8%BE&action=edit&redlink=1">领导者选举</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MapReduce">MapReduce</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE&action=edit&redlink=1">物化视图</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(%E8%BD%AF%E4%BB%B6)">管道</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%BF%87%E6%BB%A4%E5%99%A8_(%E8%BD%AF%E4%BB%B6)&action=edit&redlink=1">过滤器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85">发布/订阅</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%88%86%E7%89%87_(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84)&action=edit&redlink=1">分片</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%8A%82%E6%B5%81%E8%BF%87%E7%A8%8B_(%E8%AE%A1%E7%AE%97)&action=edit&redlink=1">节流</a></td>
</tr>
<tr>
<td align="center">其他模式</td>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Blackboard_design_pattern&action=edit&redlink=1">Blackboard</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Business_delegate_pattern&action=edit&redlink=1">Business delegate</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Composite_entity_pattern&action=edit&redlink=1">Composite entity</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F">委托</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">依赖注入</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Intercepting_filter_pattern&action=edit&redlink=1">Intercepting filter</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%83%B0%E6%80%A7%E8%BC%89%E5%85%A5">惰性加载</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Method_chaining&action=edit&redlink=1">Method chaining</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%8B%9F%E5%AF%B9%E8%B1%A1">模拟对象</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F">空对象</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F">对象池</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Servant_(design_pattern)&action=edit&redlink=1">Servant</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Twin_pattern&action=edit&redlink=1">Twin</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Type_Tunnel_pattern&action=edit&redlink=1">Type tunnel</a></td>
</tr>
<tr>
<td align="center">书籍</td>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80">设计模式：可复用面向对象软件的基础</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A2%BC%E5%A4%A7%E5%85%A8">代码大全</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E4%BC%81%E4%B8%9A%E9%9B%86%E6%88%90%E6%A8%A1%E5%BC%8F&action=edit&redlink=1">企业集成模式</a></td>
</tr>
<tr>
<td align="center">人物</td>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%8B%E9%87%8C%E6%96%AF%E6%89%98%E4%BD%9B%C2%B7%E4%BA%9A%E5%8E%86%E5%B1%B1%E5%A4%A7">克里斯托佛·亚历山大</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9F%83%E9%87%8C%E5%B8%8C%C2%B7%E4%BC%BD%E7%91%AA">埃里希·伽玛</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Ralph_Johnson&action=edit&redlink=1">Ralph Johnson</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=John_Vlissides&action=edit&redlink=1">John Vlissides</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%91%9B%E4%BE%86%E8%BF%AA%C2%B7%E5%B8%83%E5%8D%80">葛来迪·布区</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%82%AF%E7%89%B9%C2%B7%E8%B2%9D%E5%85%8B">肯特·贝克</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B2%83%E5%BE%B7%C2%B7%E5%9D%8E%E5%AE%81%E5%AE%89">沃德·坎宁安</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A9%AC%E4%B8%81%C2%B7%E7%A6%8F%E5%8B%92">马丁·福勒</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Robert_Martin&action=edit&redlink=1">Robert Martin</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Jim_Coplien&action=edit&redlink=1">Jim Coplien</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Douglas_Schmidt&action=edit&redlink=1">Douglas Schmidt</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Linda_Rising">Linda Rising</a></td>
</tr>
</tbody></table>
<h2 id="协议-4"><a href="#协议-4" class="headerlink" title="协议"></a>协议</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">域名系统 - 维基百科，自由的百科全书 (wikipedia.org)</a> DNS 基于 TCP UDP  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E8%AE%BE%E7%BD%AE%E5%8D%8F%E8%AE%AE">动态主机设置协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> DHCP 基于UDP  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">超文本传输协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> HTTP  ✅</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE">超文本传输安全协议 - 维基百科，自由的百科全书 (wikipedia.org)</a>HTTPS  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WebDAV">WebDAV - 维基百科，自由的百科全书 (wikipedia.org)</a> WebDav</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WebSocket">WebSocket - 维基百科，自由的百科全书 (wikipedia.org)</a> WebSocket  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/BitTorrent_(%E5%8D%8F%E8%AE%AE)">BitTorrent (协议) - 维基百科，自由的百科全书 (wikipedia.org)</a> BitTorrent</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%95%A3%E5%BC%8F%E9%9B%9C%E6%B9%8A%E8%A1%A8">分布式散列表 - 维基百科，自由的百科全书 (wikipedia.org)</a> DHT</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EDonkey%E7%BD%91%E7%BB%9C">eDonkey网络 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91">万维网 - 维基百科，自由的百科全书 (wikipedia.org)</a> WWW  ✅</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8">网页浏览器 - 维基百科，自由的百科全书 (wikipedia.org)</a> WWW Browser  ✅</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WebRTC">WebRTC - 维基百科，自由的百科全书 (wikipedia.org)</a> WebRTC</p>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">文件传输协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> FTP  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E4%BF%A1%E6%81%AF%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE">因特网信息访问协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> IMAP ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">简单邮件传输协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> SMTP  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%83%B5%E5%B1%80%E5%8D%94%E5%AE%9A">邮局协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> POP  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MQTT">消息队列遥测传输- 维基百科，自由的百科全书 (wikipedia.org)</a> MQTT</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E6%99%82%E9%96%93%E5%8D%94%E5%AE%9A">网络时间协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> NTP</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AE%9E%E6%97%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">实时传输协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> RTP    </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/VoIP">VoIP - 维基百科，自由的百科全书 (wikipedia.org)</a> VoIP</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%A4%BA%E5%B1%82">表示层 - 维基百科，自由的百科全书 (wikipedia.org)</a> Presentation Layser</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Telnet">Telnet - 维基百科，自由的百科全书 (wikipedia.org)</a> Telnet  ✅</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Secure_Shell">Secure Shell - 维基百科，自由的百科全书 (wikipedia.org)</a> SSH  ✅</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D%E5%B1%82">会话层 - 维基百科，自由的百科全书 (wikipedia.org)</a> Session Layer </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A">传输层安全性协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> SSL/TLS  ✅</li>
</ul>
</li>
</ul>
<p>重点：</p>
<p>dns 指针查询 反向查找 逆向解析 dns 缓存 名字空间</p>
<p>ftp 控制流 数据流 工作模式pasv+port 指令+响应码 断点续传</p>
<p>http 报文格式（请求头字段和响应头字段）状态码</p>
<p>https 详细握手 摘要算法 数字签名 数字证书 </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/12/26/netty-best-practice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/26/netty-best-practice/" class="post-title-link" itemprop="url">Netty 最佳实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-26 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-26T00:00:00+08:00">2024-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 15:17:07" itemprop="dateModified" datetime="2025-04-27T15:17:07+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/netty/" itemprop="url" rel="index"><span itemprop="name">netty</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/12/26/netty-best-practice/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/11/30/408-OS-Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/30/408-OS-Linux/" class="post-title-link" itemprop="url">Linux 基本命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-30 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-30T00:00:00+08:00">2024-11-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:37:38" itemprop="dateModified" datetime="2025-05-05T11:37:38+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Linux-概述"><a href="#Linux-概述" class="headerlink" title="Linux 概述"></a>Linux 概述</h1><h2 id="Unix家族"><a href="#Unix家族" class="headerlink" title="Unix家族"></a>Unix家族</h2><p>在unix编写过程中发明出了新的编程语言: C</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007165031608.png" alt="image-20241007165031608"></p>
<h2 id="GNU-自由软件运动"><a href="#GNU-自由软件运动" class="headerlink" title="GNU: 自由软件运动"></a>GNU: 自由软件运动</h2><p>FreeBSD: 允许闭源</p>
<p>GPL: GNU General Public License 不允许闭源</p>
<p>MIT: 声明MIT即可</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007170423889.png" alt="image-20241007170423889"></p>
<h2 id="Linux-发行版"><a href="#Linux-发行版" class="headerlink" title="Linux 发行版"></a>Linux 发行版</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007171216031.png" alt="image-20241007171216031"></p>
<h2 id="Linux-vs-Windows"><a href="#Linux-vs-Windows" class="headerlink" title="Linux vs. Windows"></a>Linux vs. Windows</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007171911495.png" alt="image-20241007171911495"></p>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>Linux用正斜杠表示路径，一切皆文件</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007174437116.png" alt="image-20241007174437116"></p>
<p>虚拟目录，只是逻辑上的关系，分区和挂载点才会决定物理存放位置的关系</p>
<ul>
<li><strong>/bin /sbin</strong> 存放二进制命令的目录，这里是一个快捷方式，实际上是/usr/bin</li>
<li>/lib /lib64 存放动态链接库，这里是一个快捷方式，实际上是/usr/lib</li>
<li>/media /mnt 外部设备挂载目录</li>
<li>/home /root用户文件夹</li>
<li>/boot 启动相关</li>
<li>/dev 设备相关 </li>
<li>/run /proc 进程</li>
<li>/srv 服务</li>
<li>/sys 系统硬件</li>
<li><strong>/var</strong> 可变目录 log 日志文件</li>
<li>/opt </li>
<li>/tmp 临时文件</li>
<li><strong>/etc</strong> 配置文件</li>
</ul>
<h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><p>vi-&gt;vim </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007182423055.png" alt="image-20241007182423055"></p>
<h2 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h2><p><strong>光标操作</strong>：</p>
<ul>
<li>e 移动到当前词尾</li>
<li>b 上一个词的词头  shift+方向左</li>
<li>w 下一个词的词头 shift+方向右</li>
<li>gg 当前文档的开头 shift+h </li>
<li>3 gg 跳转到第3行</li>
<li>shift+g 跳转到最后一行</li>
<li>$ 定位到行尾</li>
<li>^ 定位到行开头</li>
</ul>
<p><strong>复制粘贴整行</strong>：</p>
<ul>
<li>[3] yy 复制从光标开始的3行内容</li>
<li>[3] p 粘贴剪贴板的内容3次</li>
<li>y + w  复制当前单词</li>
<li>y + $ 复制从光标到行尾($可以定位到行尾)</li>
<li>y + ^ 复制从行开头到光标（^可以定位到行尾） 记忆：正则表达式^ $</li>
</ul>
<p><strong>删除行</strong>：</p>
<ul>
<li>[3] dd 删除光标开始的3行</li>
<li>d + w 删除单词，（要把光标移到单词开头）</li>
<li>d + $ 删除从光标到行尾</li>
<li>d + ^ 删除从行开头到光标</li>
</ul>
<p><strong>撤销操作</strong>：u</p>
<p><strong>剪切字符</strong>：</p>
<ul>
<li>x 剪切 光标所指字符</li>
<li>shift + x  剪切光标之前的字符，类似退格</li>
</ul>
<p><strong>替换</strong>：</p>
<ul>
<li>r 替换 光标所指字符 </li>
<li>shift + r 进入替换模式 类似insert模式 输入的字符将直接覆盖光标处的内容</li>
</ul>
<p><strong>显示行号</strong>：</p>
<ul>
<li><code>:set nu</code></li>
</ul>
<h2 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h2><p><code>i </code>光标在当前字符上 （在当前字符前面插入内容）shift+i 当前行头</p>
<p><code>a </code>光标在下一个字符上（在当前字符后面插入内容）shift+a 当前行尾</p>
<p><code>o </code>光标移动到新建的下一行 shift+o 移动到新建的上一行</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p><strong>:w 保存 :q退出 :q! 强制退出</strong></p>
<p><strong>:wq保存退出</strong> </p>
<p>:wq!强制保存退出（只读文件）</p>
<p>:set nonu 取消行号</p>
<p><strong>/boot</strong> 查找boot并高亮 n下一个 shift+n上一个</p>
<p>:s/old/new(/g) 把当前行的第一个old替换为new（加上/g为当前行所有）</p>
<p><strong>:%s/old/new(/g)</strong> 每一行的第一个old换成new（加上/g为所有行）</p>
<h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><p>ifconfig linux中的ipconfig</p>
<p>ping</p>
<p><strong>traceroute</strong>：追踪网络路径</p>
<h2 id="网络连接模式"><a href="#网络连接模式" class="headerlink" title="网络连接模式"></a>网络连接模式</h2><h3 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007200741497.png" alt="image-20241007200741497"></p>
<p>路由器到PC，PC这边搭一个虚拟网桥到虚拟交换机，交换机连接虚拟机网络，好处：虚拟机跟PC地位相同，坏处：隐私安全无法保证，VM占用路由器的子网地址</p>
<p>VM和PC的子网掩码相同</p>
<h3 id="NAT（虚拟地址转换）"><a href="#NAT（虚拟地址转换）" class="headerlink" title="NAT（虚拟地址转换）"></a>NAT（虚拟地址转换）</h3><p>VMware建立虚拟路由，构建了一个VM专用的子网。</p>
<p>虚拟路由（虚拟NAT服务器和DHCP服务器）分配子网IP，子网设备（虚拟机）只有通过这个虚拟路由才能连到外网。VM和PC不在一个子网中。VM要请求外网，虚拟路由会根据端口号和子网IP分配端口并更新到映射表中，把信息传到PC网卡，重复上述步骤，实现VM对外网的请求。</p>
<p>虚拟路由通过PC网卡跟外界通信，PC网卡此时只是一个中介，PC本身不算在内网中，不能跟VM通信，虚拟路由不能从外部向内部发送请求，因为NAT只能将子网IP转成外部IP，这里VMware的解决方案是虚拟出一个网络适配器（VMnet8），将PC本身也接入VM子网中。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007215205758.png" alt="image-20241007215205758"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007220244669.png" alt="image-20241007220244669"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007220336304.png" alt="image-20241007220336304"></p>
<p>如图网关/路由器是168.111.2，VMnet8（给PC虚拟出的网卡）是168.111.1</p>
<h3 id="仅主机"><a href="#仅主机" class="headerlink" title="仅主机"></a>仅主机</h3><p>NAT把路由器换成交换机，主机和VM都连到这个交换机上，组成一个局域网，VM只能与主机通信。虚拟出一张主机的网卡，连到交换机上</p>
<h3 id="路由器vs交换机"><a href="#路由器vs交换机" class="headerlink" title="路由器vs交换机"></a>路由器vs交换机</h3><table>
<thead>
<tr>
<th></th>
<th>路由器</th>
<th>交换机</th>
</tr>
</thead>
<tbody><tr>
<td>动态分配IP和端口</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>NAT</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>转发数据</td>
<td>基于IP地址</td>
<td>基于MAC地址</td>
</tr>
<tr>
<td>适用场景</td>
<td>WAN、LAN</td>
<td>LAN（只能用于内部通信）</td>
</tr>
</tbody></table>
<p>systemd    守护进程</p>
<h1 id="系统服务控制"><a href="#系统服务控制" class="headerlink" title="系统服务控制"></a>系统服务控制</h1><h2 id="System-V"><a href="#System-V" class="headerlink" title="System V"></a>System V</h2><p>守护进程 init 第一个进程 调用init.d的脚本根据运行级别启动服务</p>
<p>开机 bios /boot init进程 运行级别 运行级别对应的服务</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008174512092.png" alt="image-20241008174512092"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008174709567.png" alt="image-20241008174709567"></p>
<p>target运行服务的集合</p>
<p>systemd: 很多守护进程 相比于init效率更高</p>
<h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><p>控制systemd</p>
<p><code>status</code> 服务状态</p>
<p><code>restart start stop</code> 开启停止重启</p>
<p><code>enable/disable</code> 自启动</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241007004917995-1728748475007-17.png" alt="image-20241007004917995"></p>
<p><strong>systemctl</strong>是<strong>systemd</strong>的主命令，用于管理系统。除此之外，还有<strong>hostnamectl</strong>(查看当前主机信息)、<strong>timedatectl</strong>(查看当前时区设置)、<strong>loginctl</strong>(查看当前登录的用户)等命令。</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>Bash Bourne Again Shell 解释器</p>
<p>Debian dash</p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p><code>stat filename</code>: 查看inode信息</p>
<p><strong>存储文件元信息的区域就叫 inode</strong>，译为索引节点：<strong>i（index）+node</strong>。 <strong>每个文件都有一个唯一的 inode，存储文件的元信息。</strong> 同一块不能存两个文件</p>
<p><code>ln -s file.txt file_link</code> 创建软链接</p>
<p>硬链接：inode相同 软连接：inode不同，跨文件系统，只是路径相同</p>
<p><code>touch a.txt</code> 更新文件的访问修改时间戳，<strong>如果没有则创建</strong> 所以就是创建文件</p>
<h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><p>wc wordcount</p>
<p>Print newline, word, and byte counts for each FILE,</p>
<h4 id="cat-concat-concatenate"><a href="#cat-concat-concatenate" class="headerlink" title="cat (concat)(concatenate)"></a><strong>cat</strong> (concat)(concatenate)</h4><ul>
<li><strong>功能</strong>：用于连接和显示文件的内容。</li>
<li><strong>用法</strong>：可以一次性显示整个文件内容，也可以将多个文件合并。</li>
<li><strong>示例</strong>：<code>cat filename.txt</code></li>
<li><strong>特点</strong>：直接将文件内容输出到终端，不支持分页或滚动。</li>
</ul>
<h4 id="more"><a href="#more" class="headerlink" title="more"></a><strong>more</strong></h4><ul>
<li><strong>功能</strong>：用于分页显示文件内容。</li>
<li><strong>用法</strong>：按空格键查看下一页，按回车键查看下一行，按 <code>q</code> 退出。</li>
<li><strong>示例</strong>：<code>more filename.txt</code></li>
<li><strong>特点</strong>：只能向前翻页，不能向后翻。</li>
</ul>
<h4 id="less-分页查看"><a href="#less-分页查看" class="headerlink" title="less 分页查看"></a><strong>less</strong> 分页查看</h4><ul>
<li><strong>功能</strong>：也是用于分页显示文件内容，功能比 <code>more</code> 强大。</li>
<li><strong>用法</strong>：支持向前和向后翻页，使用方向键、空格键、回车键等进行导航，按 <code>q</code> 退出。</li>
<li><strong>示例</strong>：<code>less filename.txt</code></li>
<li><strong>特点</strong>：可以在文件中快速查找，支持多种命令（例如 <code>/</code> 用于搜索）。</li>
</ul>
<h4 id="tail-实时输出"><a href="#tail-实时输出" class="headerlink" title="tail 实时输出"></a><strong>tail</strong> 实时输出</h4><ul>
<li><strong>功能</strong>：用于查看文件的最后几行内容。</li>
<li><strong>用法</strong>：默认显示最后 10 行，可以使用 <code>-n</code> 选项指定行数，也可以使用 <code>-f</code> 选项实时跟踪文件变化（如日志文件）。</li>
<li><strong>示例</strong>：<code>tail filename.txt</code> 或 <code>tail -f filename.txt</code></li>
<li><strong>特点</strong>：常用于监控日志文件的实时输出。</li>
</ul>
<h4 id="grep-过滤"><a href="#grep-过滤" class="headerlink" title="grep 过滤"></a><strong>grep</strong> 过滤</h4><p>g/re/p（globally search a regular expression and print，以正则表达式进行全局查找以及打印</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -i apple fruitlist.txt</span><br><span class="line"><span class="comment"># 在fruitlist.txt中寻找apple字符串 忽略大小写 返回出现该字符串的行内容</span></span><br></pre></td></tr></table></figure>

<p>Windows平台下，<code>findstr</code>代替了<code>grep</code></p>
<h3 id="修改文件内容"><a href="#修改文件内容" class="headerlink" title="修改文件内容"></a>修改文件内容</h3><p><code>vim / nano</code>编辑器编辑</p>
<p><code>awk / sed</code> 批量处理（流）</p>
<p><code>echo / cat</code> 快速修改</p>
<ul>
<li><code>echo &quot;New content&quot; &gt; filename</code> 覆盖内容</li>
<li><code>echo &quot;New content&quot; &gt;&gt; filename</code> 追加内容</li>
<li><code>cat &gt; filename</code> 自行输入内容，输完ctrl+D </li>
</ul>
<h3 id="解压缩文件（tar）"><a href="#解压缩文件（tar）" class="headerlink" title="解压缩文件（tar）"></a>解压缩文件（tar）</h3><p>解压：tar -xvf</p>
<p>压缩：tar -zcvf</p>
<p>比如：假如 test 目录下有三个文件分别是：<code>aaa.txt</code>、 <code>bbb.txt</code>、<code>ccc.txt</code>，如果我们要打包 <code>test</code> 目录并指定压缩后的压缩包名称为 <code>test.tar.gz</code> 可以使用命令：<code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code> 或 <code>tar -zcvf test.tar.gz /test/</code></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><strong>cd</strong>: change directory</p>
<p><strong>mkdir</strong>/<strong>rmdir</strong>: make/remove directory(not null)</p>
<p><strong>ls</strong>: list</p>
<ul>
<li>-a: 显示.开头的隐藏文件 </li>
<li>-l: 显示长文件信息 </li>
<li>-F: 显示可执行信息</li>
</ul>
<p><strong>pwd</strong>: print work directory</p>
<p><strong>cp</strong>: copy</p>
<p><strong>rm</strong>: remove </p>
<p><strong>mv</strong>: move 可以用来改变文件名</p>
<p>find<code>/home</code>目录下查找以 <code>.txt</code> 结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code> ,忽略大小写: `find /home -i name “*.txt” </p>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>change owner /change mode</p>
<p><code>_rwxrw_r_</code>  普通文件</p>
<p>**所有者(u)**：一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用 <code>ls ‐ahl</code> 命令可以看到文件的所有者 也可以使用 <code>chown 用户名</code> 文件名来修改文件的所有者 。</p>
<p>**文件所在组(g)**：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组用 <code>ls ‐ahl</code>命令可以看到文件的所有组也可以使用 chgrp 组名 文件名来修改文件所在的组。</p>
<p>**其它组(o)**：除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</p>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>前提：你是文件所有者   **超级用户可以无视普通用户的权限 ** 普通用户可以用 <code>sudo chmod</code></p>
<p>文件： <code>r</code>可用cat读  <code>w</code>修改 <code>x</code>可执行</p>
<p>目录：<code>r</code> 可用ls命令 <code>w</code> 可新建，删除目录下文件 <code>x</code> 可以用cd访问</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul>
<li><p><strong>添加权限</strong></p>
<ul>
<li><code>chmod +x filename</code>：给文件添加执行权限。</li>
<li><code>chmod +r filename</code>：给文件添加读取权限。</li>
<li><code>chmod +w filename</code>：给文件添加写入权限。</li>
</ul>
</li>
<li><p><strong>删除权限</strong></p>
<ul>
<li><code>chmod -x filename</code>：去掉文件的执行权限。</li>
<li><code>chmod -r filename</code>：去掉文件的读取权限。</li>
<li><code>chmod -w filename</code>：去掉文件的写入权限。</li>
</ul>
</li>
</ul>
<h4 id="设置特定用户的权限"><a href="#设置特定用户的权限" class="headerlink" title="设置特定用户的权限"></a>设置特定用户的权限</h4><ul>
<li><strong>针对特定用户</strong><ul>
<li><code>chmod u+x filename</code>：给文件的所有者（user）添加执行权限。</li>
<li><code>chmod g+w filename</code>：给文件的所属组（group）添加写入权限。</li>
<li><code>chmod o-r filename</code>：去掉其他用户（others）的读取权限。</li>
</ul>
</li>
</ul>
<h4 id="使用八进制数设置权限"><a href="#使用八进制数设置权限" class="headerlink" title="使用八进制数设置权限"></a>使用八进制数设置权限</h4><p>权限可以用数字表示，常见的数字对应如下：</p>
<ul>
<li><code>4</code>：读取权限（r）</li>
<li><code>2</code>：写入权限（w）</li>
<li><code>1</code>：执行权限（x）</li>
</ul>
<p>通过加和可以设置权限：</p>
<ul>
<li><code>chmod 7filename</code>：所有者有读、写、执行权限，组用户和其他用户有读、执行权限。</li>
<li><code>chmod 6filename</code>：所有者有读、写权限，组用户和其他用户有读取权限。</li>
</ul>
<h4 id="递归修改权限"><a href="#递归修改权限" class="headerlink" title="递归修改权限"></a>递归修改权限</h4><ul>
<li><strong>递归应用权限</strong>：<ul>
<li><code>chmod -R 7directory</code>：递归地给目录及其所有子文件和子目录设置权限。</li>
</ul>
</li>
</ul>
<h4 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h4><ul>
<li><strong>查看当前权限</strong>：<ul>
<li>使用 <code>ls -l filename</code> 命令可以查看文件的当前权限。</li>
</ul>
</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>假设你有一个脚本文件 <code>script.sh</code>，你希望让所有用户都能执行它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a+x script.sh</span><br></pre></td></tr></table></figure>

<p>如果你想让所有者有读、写、执行权限，而其他用户只有读权限，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 7script.sh</span><br></pre></td></tr></table></figure>

<p>这些是 <code>chmod</code> 命令的一些常用选项和用法，希望对你有帮助！如果你有具体的权限需求，也可以告诉我，我可以提供更详细的命令。</p>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p><code>useradd/del/mod</code> <code>groupadd/del/mod</code> <code>passwd</code> 认证相关 </p>
<p><code>su username</code> 切换用户 Switch user</p>
<h2 id="查看系统状态"><a href="#查看系统状态" class="headerlink" title="查看系统状态"></a>查看系统状态</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ps : process status</span></span><br><span class="line">ps -ef </span><br><span class="line">ps -aux <span class="comment">#都是查看所有进程的运行情况</span></span><br><span class="line"></span><br><span class="line">ps aux | grep redis </span><br><span class="line">pgrep redis -a <span class="comment">#都是查看包含redis的进程运行情况</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> 5894 <span class="comment"># 杀死pid5394</span></span><br><span class="line"><span class="built_in">kill</span> -9 5894 <span class="comment"># 强制杀死 pid5894</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># uptime : startup time 用于查看系统总共运行了多长时间、系统的平均负载等信息</span></span><br><span class="line"><span class="comment"># top : table of processes 用于实时查看系统的 CPU 使用率、内存使用率、进程信息等</span></span><br><span class="line"><span class="comment"># htop : 用户更加友好的top</span></span><br><span class="line"><span class="comment"># vmstat : virtual memory status 进程、内存、I/O 等系统整体运行状态</span></span><br><span class="line"><span class="comment"># pmap : 分析具体进程的使用情况</span></span><br><span class="line"><span class="comment"># free : 用于查看系统的内存使用情况，包括已用内存、可用内存、缓冲区和缓存等</span></span><br><span class="line"><span class="comment"># df : disk free  df -h 查看磁盘的使用情况(可读性高)</span></span><br><span class="line"><span class="comment"># du : disk usage 用于查看指定目录或文件的磁盘空间使用情况，可以指定不同的选项来控制输出格式和单位。</span></span><br></pre></td></tr></table></figure>

<h2 id="开发调试"><a href="#开发调试" class="headerlink" title="开发调试"></a>开发调试</h2><p>静态分析：</p>
<ul>
<li><code>objdump -d &lt;program_file_name&gt;</code>：==查看二进制文件信息==</li>
<li><code>readelf</code>：查看ELF格式文件详细信息</li>
<li><code>ldd</code>：查看动态链接库依赖关系</li>
<li><code>nm</code>：列出目标文件中的符号表</li>
<li><code>strings</code>：提取文件中的可打印字符串</li>
</ul>
<p>内存使用与性能分析：</p>
<ul>
<li><code>cat /proc/meminfo</code> ：==内存使用概括==</li>
<li><code>pmap -x pid</code> ==显示进程的内存映射情况，包括虚拟内存地址和大小。==</li>
<li><code>valgrind --tool=memcheck ./program</code> 分析内存占用，泄露情况</li>
<li><code>perf</code>：性能分析工具</li>
</ul>
<p>调试器：</p>
<ul>
<li><code>gdb</code>：==GNU调试器==</li>
<li><code>strace</code>：==跟踪系统调用==</li>
<li><code>ltrace</code>：跟踪库函数调用</li>
</ul>
<p>构建工具：</p>
<p><strong><code>make</code></strong> 是 Linux 和 Unix 系统上常用的 <strong>构建自动化工具</strong>，用于<strong>自动化编译和管理项目中的依赖关系</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义编译器和编译选项</span></span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件和依赖关系</span></span><br><span class="line"><span class="section">all: main</span></span><br><span class="line"></span><br><span class="line"><span class="section">main: main.o utils.o</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o main main.o utils.o</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c main.c</span><br><span class="line"></span><br><span class="line"><span class="section">utils.o: utils.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c utils.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标 (Target)：构建的最终产物，例如main。</span></span><br><span class="line"><span class="comment"># 依赖 (Dependencies)：目标所依赖的文件，例如 main.o 和 utils.o。</span></span><br><span class="line"><span class="comment"># 命令 (Commands)：生成目标的命令，需要以 Tab 缩进（不能用空格）</span></span><br></pre></td></tr></table></figure>

<h2 id="挂载设备"><a href="#挂载设备" class="headerlink" title="挂载设备"></a>挂载设备</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43800449/article/details/130447269">Linux系统连接/挂载U盘（移动硬盘）详细步骤</a> </p>
<p>1.插入U盘，执行如下指令后能看到设备则说明连接成功</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l #查看外接设备名称，一般为/dev/sd...，这里假设为/dev/sdc1</span><br></pre></td></tr></table></figure>

<p>2.在/mnt下创建挂载点，进行挂载</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /mnt/mydev #创建挂载点</span><br><span class="line">sudo mount /dev/sdc1 /mnt/mydev #将/dev/sdc1挂载到mnt中的挂载点去</span><br><span class="line">sudo df -h #查看是否挂载成功</span><br></pre></td></tr></table></figure>

<p>3.此时挂载文件夹/mnt/mydev里面就是你U盘的内容了，可以随意访问</p>
<p>4.取消挂载，这一步相当于windows下的弹出U盘</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo umount /mnt/mydev #取消挂载，拔出硬盘</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">rmdir</span> –p /mnt/mydev  删除挂载目录（选做）</span></span><br></pre></td></tr></table></figure>

<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com	<span class="comment">#ICMP</span></span><br><span class="line">traceroute www.baidu.com <span class="comment"># 路由路径</span></span><br><span class="line">ifconfig / ip <span class="comment"># 查看网络信息 interface configuration</span></span><br><span class="line">netstat -aon | grep 3306 <span class="comment"># network status 过滤3306字符串 （监听3306端口状态）</span></span><br><span class="line">ss <span class="comment"># 比netstat高效</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wade3015/article/details/90779669">Linux用netstat查看服务及监听端口详解</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_17496365/article/details/96480424">Linux网络状态工具ss命令使用详解</a> </p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>Source</code>将xx应用于当前bash命令行</p>
<p>.bashrc .bash_profile</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44439904/article/details/109505753">linux下的source命令及~/.bashrc, ~/.bash_profile详解_source bashrc-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_57208584/article/details/135868555">【Linux】什么是.bashrc，以及其使用方法-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/shuiche/p/9436126.html">Linux下source命令详解 - 水车 - 博客园 (cnblogs.com)</a></p>
<p><strong>快捷键：</strong> </p>
<p><code>Ctrl</code>+<code>D</code> 用于结束输入或表示没有更多数据，通常用于交互式输入的结束</p>
<p><code>Ctrl</code>+<code>C</code> 强行停止正在运行的命令或进程</p>
<p>大部分命令，当用于文件夹时加 -r</p>
<p><strong>部署软件</strong>：</p>
<p>LAMP: Linux + Apache + MySQL/MariaDB + PHP</p>
<p>LEMP/LNMP: Linux + Nginx(Engine-X) + MySQL/MariaDB + PHP</p>
<p><a target="_blank" rel="noopener" href="https://cn.linux-terminal.com/?p=607">Apache 与 Nginx：哪一种 Web 服务器最适合您？ (linux-terminal.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://cn.linux-console.net/?p=27779">使用 Docker 轻松部署 LAMP 和/或 LEMP 堆栈 (linux-console.net)</a></p>
<p><a target="_blank" rel="noopener" href="https://cn.linux-console.net/?p=1038">如何在 CentOS 7 上安装 Nginx 1.15、MariaDB 10 和 PHP 7 (linux-console.net)</a> </p>
<h1 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/shell-intro.html">Shell编程</a></h1><h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><p>Debian系 <strong>apt</strong></p>
<p>RedHat系 rpm,yum</p>
<h2 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h2><h3 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h3><p>Redhat Package Manager</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rpm -qi firefox <span class="comment"># 查询firefox的安装信息 </span></span><br><span class="line">rpm -qa <span class="comment"># 查询所有</span></span><br><span class="line"></span><br><span class="line">rpm -e firefox <span class="comment"># 卸载firefox</span></span><br><span class="line">--nodeps  <span class="comment">#不检查依赖</span></span><br><span class="line"></span><br><span class="line">rpm -ivh forefox_x86_64.rpm <span class="comment"># 安装firefox，v=verbose 详细信息 h=hash 进度条</span></span><br></pre></td></tr></table></figure>

<h3 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h3><p>Yellow dog Updater Modified</p>
<p>基于RPM</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum -y install firefox <span class="comment"># 安装firefox -y表示所有yesno都填y</span></span><br><span class="line">yum list <span class="comment"># list</span></span><br><span class="line">yum update </span><br><span class="line">yum check-update</span><br><span class="line">yum deplist</span><br></pre></td></tr></table></figure>

<h4 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum 提示 Could not retrieve mirrorlist</span></span><br><span class="line"><span class="comment"># 检查是否连接到网络 Ctrl+C/D停止ping</span></span><br><span class="line">ping www.baidu.com</span><br><span class="line"><span class="comment"># ping通说明是镜像源出问题</span></span><br><span class="line"><span class="comment"># 备份当前yum源</span></span><br><span class="line"><span class="built_in">mv</span> /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line"><span class="comment"># 下载新的 CentOS-Base.repo 到/etc/yum.repos.d/</span></span><br><span class="line"><span class="comment"># 网易: http://mirrors.163.com/.help/CentOS7-Base-163.repo </span></span><br><span class="line"><span class="comment"># 阿里: http://mirrors.aliyun.com/repo/Centos-7.repo </span></span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"><span class="comment"># 清除下载过的安装包, 生成缓存</span></span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>

<p>yum 会把下载的软件包和header存储在cache中(默认路径/var/cache/yum/)，而不自动删除。如果觉得占用磁盘空间，可以使用<code>yum clean</code>指令进行清除，更精确 的用法是<code>yum clean headers</code>(清除header)，<code>yum clean packages</code>(清除下载的rpm包)，<code>yum clean all</code>(全部清除)</p>
<h3 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h3><p>apt（Advanced Packaging Tool）是一个在 Debian 和 Ubuntu 中的 Shell 前端软件包管理器。</p>
<p>apt 命令提供了查找、安装、升级、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>
<p>apt 命令执行需要超级管理员权限(root)。</p>
<ul>
<li><p>列出所有可更新的软件清单命令：<strong>sudo apt update</strong></p>
</li>
<li><p>升级软件包：<strong>sudo apt upgrade</strong></p>
<p>列出可更新的软件包及版本信息：<strong>apt list –upgradable</strong></p>
<p>升级软件包，升级前先删除需要更新软件包：<strong>sudo apt full-upgrade</strong></p>
</li>
<li><p>安装指定的软件命令：<strong>sudo apt install <package_name></strong></p>
<p>安装多个软件包：<strong>sudo apt install <package_1> <package_2> <package_3></strong></p>
</li>
<li><p>更新指定的软件命令：<strong>sudo apt update <package_name></strong></p>
</li>
<li><p>显示软件包具体信息,例如：版本号，安装大小，依赖关系等等：<strong>sudo apt show <package_name></strong></p>
</li>
<li><p>删除软件包命令：<strong>sudo apt remove <package_name></strong></p>
</li>
<li><p>清理不再使用的依赖和库文件: <strong>sudo apt autoremove</strong></p>
</li>
<li><p>移除软件包及配置文件: <strong>sudo apt purge <package_name></strong></p>
</li>
<li><p>查找软件包命令： <strong>sudo apt search <keyword></strong></p>
</li>
<li><p>列出所有已安装的包：<strong>apt list –installed</strong></p>
</li>
</ul>
<h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><p>webget下载工具</p>
<p> <code>wget https://example.com/file.zip</code> 支持断点续传</p>
<p><code>wget -O myfile.zip http://www.example.com/testfile.zip</code> 更改文件名</p>
<p><code>wget -b http://www.example.com/testfile.zip</code> 后台下载</p>
<p><strong>递归下载</strong></p>
<ul>
<li><code>wget -r http://www.example.com/path1/path2/</code><ul>
<li><code>-r</code>：递归在下整个站点（<a target="_blank" rel="noopener" href="http://www.example.com)资源/">www.example.com）资源</a></li>
<li><code>-nd</code>：递归下载时不创建一层一层的目录，把所有的文件下载到当前目录；不指定该选项默认按照资源在站点位置创建相应目录</li>
<li><code>-np</code>：递归下载时不搜索上层目录，只在当前路径path2下进行下载；不指定该选项默认搜素整个站点</li>
<li><code>-A 后缀名</code>：指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔</li>
<li><code>-R 后缀名</code>：排除要下载文件的后缀名，多个后缀名之间使用逗号进行分隔</li>
<li><code>-L</code>：递归时不进入其它主机。不指定该选项的话，如果站点包含了外部站点的链接，这样可能会导致下载内容无限大</li>
</ul>
</li>
</ul>
<blockquote>
<p>示例，只下载path2路径下的所有pdf和png文件，不创建额外目录全都保存在当前下载目录下:<br><code>wget -r -nd -np -A pdf,png http://www.example.com/path1/path2/</code></p>
</blockquote>
<h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><p><strong>curl命令</strong>是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具。作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化，curl可以祝一臂之力。</p>
<p><strong>wget</strong> 是一个独立的下载程序，无需额外的资源库，它也允许你下载网页中或是 FTP 目录中的任何内容, 能享受它超凡的下载速度，简单直接。<br><strong>curl</strong> 是一个多功能工具，是libcurl这个库支持的。它可以下载网络内容，但同时它也能做更多别的事情。</p>
<p>从用途方面，wget倾向于网络文件下载；curl倾向于网络接口调试，相当于一个无图形界面的 PostMan 工具</p>
<h3 id="处理复杂的web请求"><a href="#处理复杂的web请求" class="headerlink" title="处理复杂的web请求"></a>处理复杂的web请求</h3><p><strong>1. 自动跳转</strong></p>
<ul>
<li><code>curl -L http://www.example.com</code><ul>
<li><code>-L</code>：自动跳转到重定向链接(Location)</li>
</ul>
</li>
</ul>
<p>有些链接访问时会自动跳转(响应状态码为3xx)，<code>-L</code>参数会让 HTTP 请求跟随服务器的重定向。例如：访问 “<a target="_blank" rel="noopener" href="http://a.com&quot;/">http://a.com&quot;</a> 会重定向到 “<a target="_blank" rel="noopener" href="http://b.com&quot;,使用&quot;-l&quot;选项会返回/">http://b.com&quot;，使用&quot;-L&quot;选项会返回</a> “<a target="_blank" rel="noopener" href="http://b.com&quot;/">http://b.com&quot;</a> 的响应内容</p>
<p><strong>2. 显示响应头信息</strong></p>
<ul>
<li><code>curl -i http://www.example.com</code><ul>
<li><code>-i</code>：输出包含响应头信息</li>
<li><code>-I</code>：输出仅包含响应头信息，不包含响应内容</li>
</ul>
</li>
</ul>
<p><strong>3. 显示通信过程</strong></p>
<ul>
<li><code>curl -v http://www.example.com</code><ul>
<li><code>-v</code>：显示一次http通信的整个过程，包括端口连接和http request头信息</li>
</ul>
</li>
</ul>
<p>如果还需要查看额外的通信信息，还可以使用选项 “<code>--trace 输出文件</code>“ 或者 “<code>--trace-ascii 输出文件</code>“，例如：<code>curl --trace-ascii output.txt http://www.example.com</code>，打开文件 “output.txt”可以查看结果。</p>
<p><strong>4. 指定http请求方式</strong></p>
<ul>
<li><code>curl -X 请求方式 http://www.example.com/test</code><ul>
<li><code>-X 请求方式</code>：指定http请求方式(GET|POST|DELETE|PUT等)。默认是”GET”</li>
</ul>
</li>
</ul>
<p><strong>5. 添加http请求头</strong></p>
<ul>
<li><code>curl -H &#39;kev:value&#39; http://www.example.com/test</code><ul>
<li><code>-H &#39;kev:value&#39;</code>：添加http请求头。例：<code>-H &#39;Content-Type:application/json&#39;</code></li>
</ul>
</li>
</ul>
<p>添加多个请求头，<code>-H</code> 选项重复多次即可。例如：<br><code>curl -H &#39;Accept-Language: en-US&#39; -H &#39;Secret-Message: xyzzy&#39; http://www.example.com/test</code></p>
<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>以OpenSSL 1.1.1 的编译安装为例</p>
<blockquote>
<p>yum -y install wget</p>
</blockquote>
<p>1.安装构建 OpenSSL 所需的依赖项。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum -y groupinstall <span class="string">&quot;Development Tools&quot;</span></span><br></pre></td></tr></table></figure>

<p>2.下载 OpenSSL 1.1.x 的源代码，其中<strong>x</strong>替换为所需的实际版本。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.openssl.org/source/openssl-1.1.1t.tar.gz</span><br></pre></td></tr></table></figure>

<p>3.提取下载的文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvf openssl-1.1.1t.tar.gz</span><br></pre></td></tr></table></figure>

<p>4.导航到从文件提取创建的目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd openssl-1.1*/</span><br></pre></td></tr></table></figure>

<p>5.配置 OpenSSL。您可以指定</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./config --prefix=/usr/local/openssl --openssldir=/usr/local/openssl</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Operating system: x86_64-whatever-linux2</span><br><span class="line">Configuring OpenSSL version 1.1.1t (0x1010114fL) for linux-x86_64</span><br><span class="line">Using os-specific seed configuration</span><br><span class="line">Creating configdata.pm</span><br><span class="line">Creating Makefile</span><br><span class="line"></span><br><span class="line">**********************************************************************</span><br><span class="line">***                                                                ***</span><br><span class="line">***   OpenSSL has been successfully configured                     ***</span><br><span class="line">***                                                                ***</span><br><span class="line">***   If you encounter a problem while building, please open an    ***</span><br><span class="line">***   issue on GitHub &lt;https://github.com/openssl/openssl/issues&gt;  ***</span><br><span class="line">***   and include the output from the following command:           ***</span><br><span class="line">***                                                                ***</span><br><span class="line">***       perl configdata.pm --dump                                ***</span><br><span class="line">***                                                                ***</span><br><span class="line">***   (If you are new to OpenSSL, you might want to consult the    ***</span><br><span class="line">***   &#x27;Troubleshooting&#x27; section in the INSTALL file first)         ***</span><br><span class="line">***                                                                ***</span><br><span class="line">**********************************************************************</span><br></pre></td></tr></table></figure>

<p>5.使用make命令构建 OpenSSL 1.1.x。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j $(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure>

<p>6.在 CentOS 7 / RHEL 7 上安装 OpenSSL 1.1.1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>7.更新共享库缓存。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>

<p>8.更新系统范围的 OpenSSL 配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo tee /etc/profile.d/openssl.sh&lt;&lt;EOF</span><br><span class="line">export PATH=/usr/local/openssl/bin:\$PATH</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/openssl/lib:\$LD_LIBRARY_PATH</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>9.重新加载shell环境：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile.d/openssl.sh</span><br><span class="line">logout</span><br></pre></td></tr></table></figure>

<p>10.验证 CentOS 7 / RHEL 7 上是否安装了 OpenSSL 1.1.1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> openssl</span></span><br><span class="line">/usr/local/openssl/bin/openssl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">openssl version</span></span><br><span class="line">OpenSSL 1.1.1t  7 Feb 2023</span><br></pre></td></tr></table></figure>



<h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><h2 id="SSH端口"><a href="#SSH端口" class="headerlink" title="SSH端口"></a>SSH端口</h2><p>SSH 的端口是服务器上用于监听和处理 SSH 连接请求的网络端口。端口可以理解为设备或计算机与外界通信的一个“入口”或“通道”，每个端口对应不同的服务或应用程序。</p>
<h3 id="默认端口：22"><a href="#默认端口：22" class="headerlink" title="默认端口：22"></a>默认端口：22</h3><p>SSH 的默认端口号是 <strong>22</strong>。当你在终端中使用 SSH 连接到远程服务器时，如果没有明确指定端口，SSH 客户端会自动连接到服务器的 22 端口。</p>
<p>例如，以下命令使用默认的 22 端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@192.168.1.100</span><br></pre></td></tr></table></figure>

<h3 id="自定义端口"><a href="#自定义端口" class="headerlink" title="自定义端口"></a>自定义端口</h3><p>为了增强安全性，很多服务器管理员会修改默认的 22 端口为其他非标准端口。这样可以减少一些自动化的攻击，比如扫描网络上 22 端口的 SSH 连接尝试。</p>
<p>如果服务器的 SSH 服务配置在非标准端口（例如 2222），你需要显式指定端口号，才能成功连接到服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@192.168.1.100 -p 2222</span><br></pre></td></tr></table></figure>

<h3 id="端口的作用"><a href="#端口的作用" class="headerlink" title="端口的作用"></a>端口的作用</h3><p>每个端口都是通过一个数字标识的，范围在 0 到 65535 之间。不同的端口对应不同的服务：</p>
<ul>
<li><strong>端口 22</strong>：通常用于 SSH 连接。</li>
<li><strong>端口 80</strong>：用于 HTTP 网络服务。</li>
<li><strong>端口 443</strong>：用于 HTTPS 网络服务。</li>
</ul>
<p>SSH 服务监听的端口可以自定义配置，通常在服务器的 <code>/etc/ssh/sshd_config</code> 文件中进行修改。更改默认端口可以提高安全性，减少针对默认端口的恶意攻击。</p>
<h3 id="端口的工作原理"><a href="#端口的工作原理" class="headerlink" title="端口的工作原理"></a>端口的工作原理</h3><p>当你尝试通过 SSH 连接到服务器时，SSH 客户端发送请求到服务器的指定端口。服务器上的 SSH 服务会在这个端口上监听并接收连接请求，一旦验证通过，就会建立安全的加密通道，允许你远程控制服务器。</p>
<p>简而言之，SSH 端口就是服务器上提供 SSH 服务的入口，你可以通过指定端口来连接远程服务器。</p>
<p>要通过 SSH 登录到远程服务器上，可以按照以下步骤进行操作：</p>
<h2 id="使用SSH登录远程服务器"><a href="#使用SSH登录远程服务器" class="headerlink" title="使用SSH登录远程服务器"></a>使用SSH登录远程服务器</h2><p>要在 CentOS 7 上使用 OpenSSH，通常分为以下几个步骤：安装、配置并启动 SSH 服务。具体步骤如下：</p>
<h3 id="安装-OpenSSH"><a href="#安装-OpenSSH" class="headerlink" title="安装 OpenSSH"></a>安装 OpenSSH</h3><p>CentOS 7 通常已经预装了 OpenSSH。如果没有安装，可以使用以下命令来安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y openssh-server</span><br></pre></td></tr></table></figure>

<h3 id="启动并启用-SSH-服务"><a href="#启动并启用-SSH-服务" class="headerlink" title="启动并启用 SSH 服务"></a>启动并启用 SSH 服务</h3><p>安装完成后，你需要启动并设置 SSH 服务开机自启：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 SSH 服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start sshd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机自动启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> sshd</span><br></pre></td></tr></table></figure>

<h3 id="配置-SSH（可选）"><a href="#配置-SSH（可选）" class="headerlink" title="配置 SSH（可选）"></a>配置 SSH（可选）</h3><p>如果需要自定义配置 SSH，可以修改配置文件 <code>/etc/ssh/sshd_config</code>。你可以使用任何文本编辑器来编辑文件，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<p>常见的配置项包括：</p>
<ul>
<li><p><strong>更改默认端口</strong>：<br>找到 <code>#Port 22</code>，取消注释并设置成你想要的端口号，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Port 2222</span><br></pre></td></tr></table></figure></li>
<li><p><strong>禁止 root 账户直接登录</strong>：<br>找到 <code>#PermitRootLogin yes</code>，取消注释并改为 <code>no</code> 以提高安全性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin no</span><br></pre></td></tr></table></figure></li>
</ul>
<p>完成后，保存并退出。</p>
<h3 id="确定远程服务器的-IP-地址和用户名"><a href="#确定远程服务器的-IP-地址和用户名" class="headerlink" title="确定远程服务器的 IP 地址和用户名"></a>确定远程服务器的 IP 地址和用户名</h3><ul>
<li><strong>IP 地址</strong>：你需要知道远程服务器的公网 IP 或内网 IP。</li>
<li><strong>用户名</strong>：你要知道登录时使用的用户名。通常是服务器的账户名，例如 <code>root</code>、<code>admin</code> 或其他已创建的普通用户。</li>
</ul>
<h3 id="使用-SSH-命令连接服务器"><a href="#使用-SSH-命令连接服务器" class="headerlink" title="使用 SSH 命令连接服务器"></a>使用 SSH 命令连接服务器</h3><p>在本地终端中使用 <code>ssh</code> 命令连接远程服务器，命令格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@server_ip</span><br></pre></td></tr></table></figure>

<ul>
<li><code>username</code>：远程服务器的登录用户名。</li>
<li><code>server_ip</code>：远程服务器的 IP 地址。</li>
</ul>
<p>例如，如果你的远程服务器 IP 是 <code>192.168.1.100</code>，用户名是 <code>user123</code>，你可以输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user123@192.168.1.100</span><br></pre></td></tr></table></figure>

<h3 id="端口号非默认时指定端口"><a href="#端口号非默认时指定端口" class="headerlink" title="端口号非默认时指定端口"></a>端口号非默认时指定端口</h3><p>如果 SSH 服务使用了非默认端口（默认是 22），你需要通过 <code>-p</code> 参数指定端口号。例如，如果远程服务器的 SSH 端口是 2222，你可以这样连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user123@192.168.1.100 -p 2222</span><br></pre></td></tr></table></figure>

<h3 id="输入密码"><a href="#输入密码" class="headerlink" title="输入密码"></a>输入密码</h3><p>第一次连接时，系统会提示你是否信任服务器的主机密钥，输入 <code>yes</code>，然后系统会要求你输入服务器用户的密码。输入密码并回车后，如果验证成功，你将进入远程服务器。</p>
<h3 id="使用-SSH-密钥登录（可选）"><a href="#使用-SSH-密钥登录（可选）" class="headerlink" title="使用 SSH 密钥登录（可选）"></a>使用 SSH 密钥登录（可选）</h3><p>如果你不想每次输入密码，可以配置 SSH 密钥对（公钥和私钥）进行无密码登录。步骤如下：</p>
<h4 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h4><p>在本地电脑上生成 SSH 密钥对：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure>

<p>按回车后会提示你设置密钥保存路径和密码。默认保存在 <code>~/.ssh/id_rsa</code>。设置密码是可选的。</p>
<h4 id="将公钥复制到远程服务器"><a href="#将公钥复制到远程服务器" class="headerlink" title="将公钥复制到远程服务器"></a>将公钥复制到远程服务器</h4><p>使用 <code>ssh-copy-id</code> 命令将你的公钥复制到远程服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id user123@192.168.1.100</span><br></pre></td></tr></table></figure>

<p>或者，如果服务器使用了不同端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -p 2222 user123@192.168.1.100</span><br></pre></td></tr></table></figure>

<h4 id="通过密钥连接"><a href="#通过密钥连接" class="headerlink" title="通过密钥连接"></a>通过密钥连接</h4><p>公钥成功上传后，下一次你再使用 SSH 登录时，就无需输入密码了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user123@192.168.1.100</span><br></pre></td></tr></table></figure>

<p>通过以上步骤，你就可以通过 SSH 成功登录远程服务器了。如果有问题，可以检查防火墙、SSH 服务是否正常运行等配置。</p>
<p><strong>47.97.75.20(公)</strong></p>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="数据挂载-双向绑定"><a href="#数据挂载-双向绑定" class="headerlink" title="数据挂载 双向绑定"></a>数据挂载 双向绑定</h2><p><strong>数据卷挂载</strong></p>
<p><strong>docker volume</strong> </p>
<p>nginx 容器内部挂载</p>
<p>docker run -v html:/usr/share/nginx/html</p>
<p>容器和外界完全隔绝无法直接访问，内部的bash也不完整不能使用vi编辑器，所以可以把容器内部html目录挂载到宿主机上，挂载之后就有了</p>
<p><strong>本地目录挂载</strong></p>
<p>本地任意目录</p>
<p>docker run -v 本地目录：容器内部目录，必须以/ ./开头</p>
<h2 id="自定义镜像-dockerfile"><a href="#自定义镜像-dockerfile" class="headerlink" title="自定义镜像-dockerfile"></a>自定义镜像-dockerfile</h2><p> Java镜像：Linux运行环境，JRE, 环境变量，拷贝jar，编写运行的shell脚本</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241010090300035-1728747968346-1.png" alt="image-20241010090300035"></p>
<p>ubuntu镜像中必要的部分，分层使得轮子的复用性大大提高BaseImage，也能提高下载的效率，减少网络资源和硬盘空间的占用</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241010090221898-1728747968346-2.png" alt="image-20241010090221898"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241010090640183-1728747968346-3.png" alt="image-20241010090640183"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241010091128239-1728747968347-7.png" alt="image-20241010091128239"></p>
<h2 id="容器间网络互连"><a href="#容器间网络互连" class="headerlink" title="容器间网络互连"></a>容器间网络互连</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241010095017952-1728747968346-6.png" alt="image-20241010095017952"></p>
<p>Bridged network</p>
<p>新创建网桥，将指定容器连接到网桥</p>
<p>创建容器时指定network，即可连到网桥</p>
<p>同一个自定义网桥的容器之间可以用容器名直接通信     </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241010095906439-1728747968346-4.png" alt="image-20241010095906439"></p>
<h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>Springboot + Nginx + Vue </p>
<p>1.springboot内部封装了servlet容器 tomcat 能够处理对动态资源的请求（后端集成）</p>
<ul>
<li>管理Servlet程序的生命周期</li>
<li>将URL映射到指定的Servlet进行处理</li>
<li>与Servlet程序合作处理HTTP请求——根据HTTP请求生成HttpServletResponse对象并传递给Servlet进行处理，将Servlet中的HttpServletResponse对象生成的内容返回给浏览器</li>
</ul>
<p>2.nginx能够进行反向代理，代理后端服务器处理静态资源的请求（例如图片、视频、CSS、JavaScript文件等,也就是前端的），负载均衡：当业务压力增大时，可能一个Tomcat的实例不足以处理，那么这时可以启动多个Tomcat实例进行水平扩展，而Nginx的负载均衡功能可以把请求通过算法分发到各个不同的实例进行处理</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241010154836707-1728747968346-5.png" alt="image-20241010154836707"></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/32212996">tomcat 与 nginx，apache的区别是什么？ - 知乎 (zhihu.com)</a></p>
<p>HTTP server：只关心http协议层面的传输和访问控制，如实将服务器上的文件通过http协议传输给客户端。</p>
<p>Application server: 应用容器（servlet=server applet）tomcat需要提供JSP/servlet运行的类库，会集成一部分httpserver功能，但是不如HTTP server强大</p>
<h2 id="dockerCompose"><a href="#dockerCompose" class="headerlink" title="dockerCompose"></a>dockerCompose</h2><p>docker-compose.yml</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241010165557595-1728747968347-8.png" alt="image-20241010165557595"></p>
<h1 id="MySQL-on-WSL"><a href="#MySQL-on-WSL" class="headerlink" title="MySQL on WSL"></a>MySQL on WSL</h1><h2 id="CentOS-7-安装到-WSL2"><a href="#CentOS-7-安装到-WSL2" class="headerlink" title="CentOS 7 安装到 WSL2"></a>CentOS 7 安装到 WSL2</h2><ol>
<li><p>下载CentOS: <a target="_blank" rel="noopener" href="https://github.com/mishamosher/CentOS-WSL/releases/tag/7.9-2211">Release CentOS 7.9-2211 · mishamosher/CentOS-WSL (github.com)</a></p>
</li>
<li><p>下载完成解压得到 CentOS7.exe rootfs.tar.gz 两个文件</p>
</li>
<li><p>安装完成后在相同目录下生成 ext4.vhdx 文件</p>
</li>
<li><p>```powershell</p>
<h1 id="在此处打开PowerShell"><a href="#在此处打开PowerShell" class="headerlink" title="在此处打开PowerShell"></a>在此处打开PowerShell</h1><p>wsl -l -v</p>
<h1 id="成功返回如下"><a href="#成功返回如下" class="headerlink" title="成功返回如下"></a>成功返回如下</h1><p>NAME    STATE   VERSION<br>CentOS7 Stopped 2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. ```powershell</span><br><span class="line">   # 迁移默认存储位置</span><br><span class="line">   # 确保为stop状态</span><br><span class="line">   wsl -l -v</span><br><span class="line">   # 导出CentOS文件到tar，文件夹需提前创建</span><br><span class="line">   wsl --export CentOS7 D:/CentOSWSL/centos7.tar</span><br><span class="line">   # 注销系统</span><br><span class="line">   wsl --unregister CentOS7</span><br><span class="line">   # 确定已注销</span><br><span class="line">   wsl -l -v</span><br><span class="line">   # 执行导入(如果失败可再次尝试执行)</span><br><span class="line">   wsl --import CentOS7  D:/CentOSWSL/ D:/CentOSWSL/centos7.tar</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="安装缺乏的依赖项"><a href="#安装缺乏的依赖项" class="headerlink" title="安装缺乏的依赖项"></a>安装缺乏的依赖项</h2><p>有些部分会提示缺乏dependencies</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql-community-devel-8.0.17-1.el7.x86_64.rpm --force --nodeps</span><br><span class="line"><span class="comment"># 直接强制安装，无视依赖</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install libaio</span><br><span class="line">yum install openssl-devel</span><br></pre></td></tr></table></figure>

<h2 id="解决执行systemctl命令报错：Failed-to-get-D-Bus-connection"><a href="#解决执行systemctl命令报错：Failed-to-get-D-Bus-connection" class="headerlink" title="解决执行systemctl命令报错：Failed to get D-Bus connection "></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fengjq/p/17616874.html">解决执行systemctl命令报错：Failed to get D-Bus connection </a></h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;[boot]\nsystemd=true&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> -a /etc/wsl.conf</span><br><span class="line"><span class="comment"># powershell</span></span><br><span class="line">wsl.exe --shutdown</span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">systemctl list-unit-files --<span class="built_in">type</span>=service</span><br></pre></td></tr></table></figure>

<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld</span><br><span class="line">systemctl restart mysqld</span><br><span class="line">systemctl stop mysqld</span><br><span class="line"></span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<h3 id="查看随机生成密码"><a href="#查看随机生成密码" class="headerlink" title="查看随机生成密码"></a>查看随机生成密码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /var/log/mysqld.log</span><br></pre></td></tr></table></figure>

<h3 id="更改密码"><a href="#更改密码" class="headerlink" title="更改密码"></a>更改密码</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;ace123456&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="更改密码策略"><a href="#更改密码策略" class="headerlink" title="更改密码策略"></a>更改密码策略</h3><p><strong>默认策略：</strong></p>
<ul>
<li><strong>至少包含 1 位大小写</strong></li>
<li><strong>至少包含 1 位数字</strong></li>
<li><strong>包含 1 个特殊符号</strong></li>
<li><strong>必须 8 位及以上</strong></li>
</ul>
<p><strong>连接到MySQL服务器：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>输入 <code>root</code> 用户的密码进行登录。</p>
<p><strong>2. 执行以下命令来查看当前的密码策略：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE <span class="string">&#x27;validate_password%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>3. 根据需求修改以下变量：</strong></p>
<ul>
<li><p><code>validate_password.policy</code>：密码策略，默认值为<code>MEDIUM</code>。可以设置为<code>LOW</code>、<code>MEDIUM</code>、<code>STRONG</code>或者自定义。例如，可以将其设置为<code>LOW</code>以降低密码复杂性要求。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> validate_password.policy <span class="operator">=</span> LOW;</span><br></pre></td></tr></table></figure>

<p>不同策略的要求：<br><code>0/LOW</code>：只验证长度；<br><code>1/MEDIUM</code>：验证长度、数字、大小写、特殊字符；默认值。<br><code>2/STRONG</code>：验证长度、数字、大小写、特殊字符、字典文件；</p>
</li>
<li><p><code>validate_password.length</code>：密码最小长度，默认值为<code>8</code>。可以根据需要修改最小密码长度。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> validate_password.length <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><code>validate_password.number_count</code>：密码中的数字要求，默认值为<code>1</code>。可以增加或减少数字的要求。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> validate_password.number_count <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><code>validate_password.special_char_count</code>：密码中特殊字符的要求，默认值为<code>1</code>。可以增加或减少特殊字符的要求。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> validate_password.special_char_count <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><code>validate_password.mixed_case_count</code>：密码中大写字母和小写字母的要求，默认值为<code>1</code>。可以增加或减少大写字母和小写字母的要求。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> validate_password.mixed_case_count <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>4. 修改配置文件以使修改的密码策略永久生效。</strong></p>
<p>打开<code>MySQL</code>的配置文件（通常是 <code>mysqld.cnf</code> 或 <code>my.cnf</code>），添加下面的内容到文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">validate_password.policy=LOW</span><br><span class="line">validate_password.length=6</span><br><span class="line">validate_password.number_count=1</span><br><span class="line">validate_password.special_char_count=1</span><br><span class="line">validate_password.mixed_case_count=1</span><br></pre></td></tr></table></figure>

<p><strong>5. 重启 MySQL 服务以应用更改：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart mysql</span><br></pre></td></tr></table></figure>

<p>完成上述步骤后，就已经修改了 <code>MySQL 8.0</code> 的密码策略。可以需求调整密码策略的参数，并确保设置合适的密码策略以提高数据库的安全性。</p>
<h3 id="配置文件路径"><a href="#配置文件路径" class="headerlink" title="配置文件路径"></a>配置文件路径</h3><p>通过 which 命令可以查看 mysql 安装路径，如下所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> mysql </span><br><span class="line">/usr/bin/mysql</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>如果服务器没有安装 mysql 命令，可以使用绝对路径下的 mysql 命令，查看配置文件在哪。如果 Linux 服务器已配置好 mysql 命令，也可以直接使用 mysql 命令查看。具体语句如下所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/bin/mysql --verbose --<span class="built_in">help</span> | grep -A 1 <span class="string">&#x27;Default options&#x27;</span></span><br><span class="line">$ mysql --verbose --<span class="built_in">help</span> | grep -A 1 <span class="string">&#x27;Default options&#x27;</span></span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>2条命令分别执行完毕后的结果均显示如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Default options are <span class="built_in">read</span> from the following files <span class="keyword">in</span> the given order:</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/etc/my.cnf ~/.my.cnf</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>结果显示：服务器首先读取的是 /etc/my.cnf 文件，如果该文件不存在则继续读 /etc/mysql/my.cnf 文件，如若文件还不存在便会去读 /usr/etc/my.cnf 文件，若文件仍不存在则继续读 ~/.my.cnf文件。</p>
<p>通过sudo tee写入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;[mysqld]\nvalidate_password.policy=LOW\nvalidate_password.length=6\nvalidate_password.number_count=1\nvalidate_password.special_char_count=1\nvalidate_password.mixed_case_count=1&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/my.cnf</span><br></pre></td></tr></table></figure>

<h3 id="添加可供远程访问的用户"><a href="#添加可供远程访问的用户" class="headerlink" title="添加可供远程访问的用户"></a>添加可供远程访问的用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> <span class="string">&#x27;ace123456&#x27;</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="查看WSL的IP地址"><a href="#查看WSL的IP地址" class="headerlink" title="查看WSL的IP地址"></a>查看WSL的IP地址</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Powershell</span></span><br><span class="line">wsl -d CentOS7 hostname -I</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wsl: 检测到 localhost 代理配置，但未镜像到 WSL。NAT 模式下的 WSL 不支持 localhost 代理。</span></span><br><span class="line">172.19.111.46</span><br></pre></td></tr></table></figure>

<h2 id="查看服务状态"><a href="#查看服务状态" class="headerlink" title="查看服务状态"></a>查看服务状态</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status mysqld</span><br><span class="line">chkconfig mysqld on</span><br><span class="line">重载systemctl配置，设置mysqld服务开机自启动。</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> mysqld</span><br><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@LAPTOP-BCC46KV0 init.d]# systemctl show mysqld -p After</span><br><span class="line">After=basic.target network.target syslog.target systemd-journald.socket system.slice</span><br><span class="line"></span><br><span class="line">systemctl status mysqld</span><br><span class="line">journalctl -xe</span><br><span class="line"></span><br><span class="line">systemctl show mysqld -p After</span><br><span class="line">systemctl show mysqld -p Before</span><br><span class="line">netstat -tulnp | grep :3306</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /etc/passwd</span><br><span class="line"></span><br><span class="line">ps -eo pid,user,<span class="built_in">comm</span> | grep mysqld</span><br><span class="line"></span><br><span class="line">top -u mysql</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写入windows环境变量+开启systemd			</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[boot]\nsystemd=true\n&quot;</span> &gt;&gt; /etc/wsl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[interop]\nappendWindowsPath=false\n&quot;</span> &gt;&gt; /etc/wsl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;### Windows ###</span></span><br><span class="line"><span class="string">export PATH=&quot;$PATH:/mnt/c/Users/Lenovo/AppData/Local/Microsoft/WindowsApps&quot;</span></span><br><span class="line"><span class="string">export PATH=&quot;$PATH:/mnt/c/Program Files/Docker/Docker/resources/bin&quot;</span></span><br><span class="line"><span class="string">export PATH=&quot;$PATH:/mnt/c/Windows&quot;&#x27;</span> &gt;&gt; /etc/profile</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动时间</span></span><br><span class="line"><span class="built_in">uptime</span> </span><br><span class="line"><span class="built_in">who</span> -b</span><br><span class="line"></span><br><span class="line">vim /etc/wsl.conf</span><br><span class="line"></span><br><span class="line">[network]</span><br><span class="line">hostname = node01 <span class="comment">#主机名称</span></span><br><span class="line">generateHosts = <span class="literal">false</span> <span class="comment">#自动生成hosts</span></span><br></pre></td></tr></table></figure>



<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">worker_processes</span>  <span class="number">1</span><span class="string">;</span>  <span class="comment"># 指定 Nginx 启动的工作进程数量</span></span><br><span class="line"></span><br><span class="line"><span class="string">events</span> &#123;</span><br><span class="line">    <span class="string">worker_connections</span>  <span class="number">1024</span><span class="string">;</span>  <span class="comment"># 每个工作进程允许的最大连接数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">http</span> &#123;</span><br><span class="line">    <span class="string">include</span>       <span class="string">mime.types;</span>  <span class="comment"># 包含 MIME 类型配置文件</span></span><br><span class="line">    <span class="string">default_type</span>  <span class="string">application/json;</span>  <span class="comment"># 默认的 Content-Type</span></span><br><span class="line"></span><br><span class="line">    <span class="string">sendfile</span>        <span class="string">off;</span>  <span class="comment"># 禁用高效文件传输</span></span><br><span class="line"></span><br><span class="line">    <span class="string">keepalive_timeout</span>  <span class="number">65</span><span class="string">;</span>  <span class="comment"># 保持活动连接的超时时间</span></span><br><span class="line"></span><br><span class="line">    <span class="string">server</span> &#123;</span><br><span class="line">        <span class="string">listen</span>       <span class="number">8080</span><span class="string">;</span>  <span class="comment"># Nginx 监听的端口</span></span><br><span class="line">        <span class="string">server_name</span>  <span class="string">localhost;</span>  <span class="comment"># 虚拟主机名称</span></span><br><span class="line"></span><br><span class="line">        <span class="string">location</span> <span class="string">/</span> &#123;</span><br><span class="line">            <span class="string">root</span>   <span class="string">html/hmdp;</span>  <span class="comment"># 静态文件根目录</span></span><br><span class="line">            <span class="string">index</span>  <span class="string">index.html</span> <span class="string">index.htm;</span>  <span class="comment"># 默认索引文件</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="string">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  <span class="string">/50x.html;</span>  <span class="comment"># 自定义错误页面</span></span><br><span class="line">        <span class="string">location</span> <span class="string">=</span> <span class="string">/50x.html</span> &#123;</span><br><span class="line">            <span class="string">root</span>   <span class="string">html;</span>  <span class="comment"># 错误页面的具体位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="string">location</span> <span class="string">/api</span> &#123;  </span><br><span class="line">            <span class="string">default_type</span>  <span class="string">application/json;</span>  <span class="comment"># 设置默认 Content-Type</span></span><br><span class="line"></span><br><span class="line">            <span class="string">keepalive_timeout</span>   <span class="string">30s;</span>  <span class="comment"># 对于 /api 的连接保持活动超时时间</span></span><br><span class="line">            <span class="string">keepalive_requests</span>  <span class="number">1000</span><span class="string">;</span>  <span class="comment"># 允许的最大请求数</span></span><br><span class="line"></span><br><span class="line">            <span class="string">proxy_http_version</span> <span class="number">1.1</span><span class="string">;</span>  <span class="comment"># 设置代理请求使用的 HTTP 版本</span></span><br><span class="line"></span><br><span class="line">            <span class="string">rewrite</span> <span class="string">/api(/.*)</span> <span class="string">$1</span> <span class="string">break;</span>  <span class="comment"># 重写请求的 URI</span></span><br><span class="line"></span><br><span class="line">            <span class="string">proxy_pass_request_headers</span> <span class="string">on;</span>  <span class="comment"># 转发请求头</span></span><br><span class="line"></span><br><span class="line">            <span class="string">proxy_next_upstream</span> <span class="string">error</span> <span class="string">timeout;</span>  <span class="comment"># 在错误或超时情况下尝试下一个后端服务器</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#proxy_pass http://127.0.0.1:8081;  # 将请求转发到后端服务</span></span><br><span class="line">            <span class="string">proxy_pass</span> <span class="string">http://backend;</span>  <span class="comment"># 可以使用 upstream 定义的 backend 服务器</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#将请求转发</span></span><br><span class="line">    <span class="string">upstream</span> <span class="string">backend</span> &#123;</span><br><span class="line">        <span class="string">server</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8081</span> <span class="string">max_fails=5</span> <span class="string">fail_timeout=10s</span> <span class="string">weight=1;</span>  <span class="comment"># 后端服务器配置</span></span><br><span class="line">        <span class="string">server</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8082</span> <span class="string">max_fails=5</span> <span class="string">fail_timeout=10s</span> <span class="string">weight=1;</span>  <span class="comment"># 另一个后端服务器的注释</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==虚拟主机（反向代理）Reverse Proxy==：<code>server</code> 中的<code>listen 8080</code> <code>server_name localhost</code> 分别表示虚拟主机的端口和域名，客户端发送请求就可以把虚拟主机当做服务器。</p>
<p>==请求转发（负载均衡）Request Forwarding &amp; Load Balancing==：<code>location /api</code> 表示nginx接管<code>/api</code>路径下的请求，<code>rewrite</code>表示会将请求的URL重写，因为在后端并不存在接管/api的Controller，<code>proxy_pass</code>表示请求转发的目标，这里转发到了backend，对应2个服务器地址，默认采用轮询(polling)机制</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241104184639596.png" alt="image-20241104184639596" style="zoom: 50%;" />

<p>如图，前端所有AJAX请求的URL都有<code>/api</code>前缀，前端向nginx发送请求，URL为<a target="_blank" rel="noopener" href="http://localhost:8080/api/shop/1%EF%BC%8C%E7%BB%8F%E8%BF%87Nginx%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%88%B0http://127.0.0.1/shop/1%E4%B8%8B%EF%BC%8C%E6%AD%A3%E5%A5%BD%E5%B0%B1%E6%98%AF%E5%90%8E%E7%AB%AF%E7%9A%84Controller%E6%89%80%E5%9C%A8%E7%9A%84URL">http://localhost:8080/api/shop/1，经过Nginx端口转发到http://127.0.0.1/shop/1下，正好就是后端的Controller所在的URL</a></p>
<p>==静态文件服务 HTTP Server==： <code>location /</code> 表示nginx将接管 <code>/</code> 路径下的请求    <code>root</code>表示静态文件的具体位置</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/11/30/juc-in-one/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/30/juc-in-one/" class="post-title-link" itemprop="url">java.util.concurrent</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-30 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-30T00:00:00+08:00">2024-11-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 14:37:58" itemprop="dateModified" datetime="2025-04-27T14:37:58+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/juc/" itemprop="url" rel="index"><span itemprop="name">juc</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-Concurrency-Overview"><a href="#Java-Concurrency-Overview" class="headerlink" title="Java Concurrency Overview"></a>Java Concurrency Overview</h1><h2 id="java-lang-Thread"><a href="#java-lang-Thread" class="headerlink" title="java.lang.Thread"></a><code>java.lang.Thread</code></h2><ol>
<li><p><strong>线程创建与运行</strong>:</p>
<ul>
<li><strong>继承 <code>Thread</code> 类</strong>: 继承 <code>Thread</code> 并重写 <code>run()</code> 方法<ul>
<li><code>new MyThread().start()</code> </li>
</ul>
</li>
<li><strong>实现 <code>Runnable</code> 接口</strong>: 实现 <code>Runnable</code> 实现 <code>run()</code> 方法<ul>
<li><code>new Thread(runnable).start()</code> </li>
</ul>
</li>
</ul>
</li>
<li><p><strong>线程生命周期</strong>:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/640.png" alt="Java 线程状态变迁图"></p>
<ul>
<li><strong>New</strong>: <code>new Thread()</code>, 还没有调用 <code>start()</code> </li>
<li><strong>Runnable</strong>: 线程已经调用了 <code>start()</code> / 获取锁等待 CPU 调度执行，操作系统层面属于 <strong>Ready</strong> 和 <strong>Running</strong> 状态</li>
<li><strong>Blocked</strong>:  等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</li>
<li><strong>Waiting</strong>: 操作系统的 <strong>Sleep</strong> 状态，等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。需要等待其他线程做出一些特定动作（通知或中断）</li>
<li><strong>Timed Waiting</strong>: 无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。获取锁之后调用 <code>wait(long ms)</code> <code>sleep(long ms)</code> 可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li>
<li><strong>Terminated</strong>: <code>run()</code> 执行完毕正常退出或者抛出了未处理的异常</li>
</ul>
</li>
<li><p><strong>Thread Methods</strong>:</p>
<ul>
<li><strong><code>start()</code></strong>: 线程转为 Runnable 可运行状态，相当于 <code>pthread_create()</code></li>
<li><strong><code>run()</code></strong>: 线程应该执行的方法，相当于 <code>pthread_create()</code> 传的函数指针</li>
<li><strong><code>sleep(long millis)</code></strong>: 调用者睡眠一段时间</li>
<li><strong><code>join()</code></strong>: 父线程等待子线程执行完毕再继续执行</li>
<li><strong><code>interrupt()</code></strong>: 使线程中断</li>
<li><code>currentThread()</code>: 获取当前执行的线程对象</li>
<li><code>get/setName()</code>: 获取线程名称</li>
<li><code>yield()</code>: 声明当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。只是对线程调度器的一个建议，只是建议具有相同优先级的其它线程可以运行。只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。</li>
<li><code>setDaemon()</code>: 将一个线程设置为守护线程。当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。main() 属于非守护线程。</li>
</ul>
</li>
<li><p>线程安全：</p>
<ol>
<li><p>线程互斥同步：<code>synchronized</code> <code>ReentrantLock</code> </p>
</li>
<li><p>线程非阻塞同步：<code>AtomicInteger</code> (CAS)</p>
</li>
<li><p>无同步：<code>ThreadLocal</code> 利用线程各自的栈(FutureTask，线程池)</p>
</li>
</ol>
</li>
<li><p>线程通信与协作：</p>
<ul>
<li><code>thread.join()</code> 父线程与子线程的通信</li>
<li><code>object.wait()/notify()/notifyAll()</code> 可用于 synchronized 对象锁</li>
<li><code>condition.await()/signal()/signalAll()</code> 可用于 Lock 的条件变量</li>
<li>或者使用共享内存，volatile/while轮询 的形式隐式通信</li>
</ul>
</li>
</ol>
<h2 id="java-util-concurrent"><a href="#java-util-concurrent" class="headerlink" title="java.util.concurrent"></a><code>java.util.concurrent</code></h2><p>**<mark><a href="#jvm">理论基础</a><mark>**：</p>
<ol>
<li><p><strong>JVM</strong> 对并发的支持：</p>
<ul>
<li><strong>JMM 内存模型</strong> 解决由于 Cache、指令重排序导致的可见性、有序性问题</li>
<li><code>synchronized</code> 用于解决 CPU 时分复用(操作系统调度)导致的原子性问题<ul>
<li>偏向锁、轻量级锁与重量级锁，理解锁升级和锁优化机制，如自旋锁与锁消除。</li>
</ul>
</li>
<li><code>volatile</code> 用于解决指令重排序与可见性问题</li>
<li><code>final</code> 创建不可变对象或常量(线程安全)，内存可见性</li>
<li>happens-before 原则</li>
</ul>
</li>
<li><p>常见<strong>并发设计模式</strong>：</p>
<ul>
<li><p><strong>生产者-消费者模式：</strong> 使用阻塞队列（BlockingQueue）优化实现。</p>
</li>
<li><p><strong>读写分离模式：</strong> 提高读写性能，适合数据库访问优化，读写锁、CoW 集合。</p>
</li>
<li><p><strong>线程池模式：</strong> 使用线程池 ThreadPool 统一管理线程资源。</p>
</li>
<li><p><strong>Future 模式：</strong> 提供任务执行结果的异步返回。</p>
</li>
</ul>
</li>
<li><p><strong>死锁检测与避免策略</strong></p>
</li>
</ol>
<p><strong>可选：</strong>虚拟线程、Reactor、Disruptor</p>
<p><code>java.util.concurrent</code> 给并发控制提供更多可用的操作:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/format,webp.webp" alt="img"></p>
<ol>
<li><p><strong><mark><a href="#lock">Locks</a><mark></strong>:（悲观锁）</p>
<ul>
<li><strong>ReentrantLock</strong>: 相同线程可以重复持有同一把锁</li>
<li><strong>ReentrantReadWriteLock</strong>: 有读锁和写锁两部分组成，支持多线程读取和单个线程写入</li>
<li><strong>StampedLock</strong>: 不可重入的读写锁</li>
<li><strong>LockSupport</strong>: 提供线程阻塞同步原语<ul>
<li><code>park()</code> <code>unpark(thread)</code> </li>
</ul>
</li>
<li><strong>Condition</strong>: 更细粒度的线程同步</li>
<li><strong>AbstractQueuedSynchronizer</strong>: AQS 自定义同步器</li>
</ul>
</li>
<li><p><strong><mark><a href="#tools">Tools</a><mark></strong>(Synchronizers): 和锁配合使用，线程安全工具类</p>
<ul>
<li><strong>CountDownLatch</strong>: Allows one or more threads to wait until a set of operations being performed in other threads completes. 闭锁是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待</li>
<li><strong>CyclicBarrier</strong>: A barrier that all threads must reach before any thread can proceed.（栅栏） 是因为是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 ，并且在释放等待线程后可以重用。</li>
<li><strong>Semaphore</strong>: Controls access to a resource by multiple threads. 它的本质是一个“共享锁“。信号量维护了一个信号量许可集。线程可以通过调用 acquire()来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过release()来释放它所持有的信号量许可。</li>
</ul>
</li>
<li><p><strong><mark><a href="#atomic">Atomic Variables</a><mark></strong>: CAS Lock-free(乐观锁)</p>
<ul>
<li><strong>AtomicBoolean</strong>, <strong>AtomicInteger</strong>, <strong>AtomicLong</strong></li>
<li><strong>AtomicIntegerArray</strong> These classes support lock-free thread-safe programming on single variables using low-level atomic operations.</li>
<li>CAS 构建自旋锁</li>
<li>ABA 问题与解决方案（如 AtomicStampedReference）。</li>
</ul>
</li>
<li><p><strong><mark><a href="#executor">Executor</a><mark></strong>: 线程池及异步任务相关</p>
<ul>
<li><p><strong>Callable</strong>: 和 Runnable 类似，但是有返回值</p>
</li>
<li><p><strong>Future</strong> <strong>FutureTask</strong> </p>
<ul>
<li>CompletableFuture 异步编程</li>
</ul>
</li>
<li><p><strong>ExecutorService</strong>: A flexible interface for managing and controlling thread execution.</p>
<ul>
<li><strong>ThreadPoolExecutor</strong>: 通常所说的线程池</li>
</ul>
</li>
<li><p><strong>Fork/Join</strong> 框架</p>
</li>
</ul>
</li>
<li><p><strong>Concurrent Collections/Maps</strong>: 线程安全的集合</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-concurrent-collections.png" alt="Concurrent Collections"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-thread-x-juc-overview-2.png" alt="image"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Collection-Hierarchy-concurrent-1735225309564-38.png" alt="Collection Hierarchy concurrent"></p>
<ul>
<li><strong>ConcurrentHashMap</strong> 线程安全的哈希表</li>
<li><strong>CopyOnWriteArrayList</strong> CoW List</li>
<li><strong>CopyOnWriteArraySet</strong> CoW Set</li>
<li><strong>BlockingQueue</strong> 阻塞队列</li>
</ul>
</li>
</ol>
<h1 id="JVM-支持"><a href="#JVM-支持" class="headerlink" title="JVM 支持"></a><span id="jvm">JVM 支持</span></h1><h2 id="并发问题的根源"><a href="#并发问题的根源" class="headerlink" title="并发问题的根源"></a>并发问题的根源</h2><h3 id="CPU-时分复用"><a href="#CPU-时分复用" class="headerlink" title="CPU 时分复用"></a>CPU 时分复用</h3><p>**<mark>原子性<mark>**：一个过程要么完全执行并且执行的过程不会被任何因素打断，要么就完全不执行。</p>
<p>操作系统基于受限直接执行(Limited Direct Execution)来运行任务，基于 CPU 的时钟中断对任务进行调度，通过这种 CPU 虚拟化技术让应用程序认为是自己在独占 CPU。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">i += <span class="number">1</span>;<span class="comment">// 线程1执行</span></span><br><span class="line">i += <span class="number">1</span>;<span class="comment">// 线程2执行</span></span><br><span class="line"><span class="comment">/*注意：i += 1 需要三条 CPU 指令</span></span><br><span class="line"><span class="comment">1. 将变量 i 从内存读取到 CPU寄存器；</span></span><br><span class="line"><span class="comment">2. 在CPU寄存器中执行 i + 1 操作；</span></span><br><span class="line"><span class="comment">3. 将最后的结果 i 写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。*/</span></span><br></pre></td></tr></table></figure>

<p>由于CPU分时复用（线程切换）的存在，线程 1 执行了第一条指令后，就切换到线程 2 执行，假如线程 2 执行了这三条指令后，再切换会线程 1 执行后续两条指令，将造成最后写到内存中的 <code>i</code> 是 2 而不是 3</p>
<blockquote>
<p>在 Java 中，可以借助<code>synchronized</code>、各种 <code>Lock</code> 以及各种原子类实现原子性。</p>
<p><code>synchronized</code> 和各种 <code>Lock</code> 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 <code>volatile</code>或者<code>final</code>关键字）来保证原子操作。</p>
</blockquote>
<h3 id="CPU-Cache"><a href="#CPU-Cache" class="headerlink" title="CPU Cache"></a>CPU Cache</h3><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/cpu-cache-protocol.png" alt="缓存一致性协议" style="zoom:67%;" />

<p><mark><strong>可见性</strong><mark>：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。</p>
<ol>
<li>CPU Cache 缓存的是物理内存数据，用于解决 CPU 处理速度和物理内存不匹配的问题<ul>
<li>多核缓存与主内存交互时需要遵守的原则和规范叫做 <strong>缓存一致协议</strong>，如 MESI</li>
</ul>
</li>
<li>应用程序眼中是一片完整的虚拟内存，由操作系统提供内存的虚拟化，将虚拟内存地址映射到真正的物理内存空间中。<ul>
<li>操作系统也要解决缓存(比如 TLB)与内存(比如页表)的一致性问题</li>
</ul>
</li>
</ol>
<blockquote>
<p>在 Java 中，可以借助<code>synchronized</code>、<code>volatile</code> 以及各种 <code>Lock</code> 实现可见性。</p>
<p>如果我们将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
</blockquote>
<h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>**<mark>有序性<mark>**：即程序执行的顺序按照代码的先后顺序执行。</p>
<p>为了提升执行速度/性能，计算机在执行程序代码的时候，会对指令进行重排序。 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。<strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p>
<blockquote>
<p>在 Java 中，<code>volatile</code> 关键字可以禁止指令进行重排序优化。</p>
</blockquote>
<h4 id="编译器优化重排"><a href="#编译器优化重排" class="headerlink" title="编译器优化重排"></a>编译器优化重排</h4><p>编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</p>
<p>对于编译器，禁止重排两句代码的指令，需要在它们之间插入 compiler fence。</p>
<h4 id="CPU-优化重排"><a href="#CPU-优化重排" class="headerlink" title="CPU 优化重排"></a>CPU 优化重排</h4><p>对于处理器，通过插入内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence，一种 CPU 指令）的方式来禁止特定类型的处理器重排序。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障变量的可见性。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/413889872">并发编程：乱序执行的那些事儿 - 知乎</a>  <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maycap/p/15690751.html">图解CPU为何要乱序执行 - last_coding - 博客园</a>  </p>
<h5 id="指令级并行重排-乱序执行-ILP"><a href="#指令级并行重排-乱序执行-ILP" class="headerlink" title="指令级并行重排/乱序执行(ILP)"></a>指令级并行重排/乱序执行(ILP)</h5><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2586739-20211214234820966-1713761498.png" alt="img" style="zoom: 80%;" />

<p>RISC 架构的特点就是指令长度相等，执行时间恒定(通常为一个时钟周期)，因此处理器设计起来就很简单，可以通过深长的流水线达到很高的频率，IBM 的 Power6 就可以轻松地达到 4.7GHz 的起步频率。和 RISC 相反，CISC 指令的长度不固定，执行时间也不固定，因此 Intel 的 RISC/CISC 混合处理器架构就要通过 Instruction Fetch &amp; Decode 将 x86 指令翻译为 μops，从而获得 RISC 架构的长处，提升内部执行效率。x86 指令大部分简单指令可以一对一翻译为 μops，复杂的可能 1 ~ 4 条 μops。解码器是按位数取指的，在经过译码，因此每次可能产生多条 μops。</p>
<p>计算机执行符合局部性原理，这里不仅指同个指令可能重复执行，也指内存访问。而内存访问显然是比较慢的，<strong>对多条指令重新排序，把访存相关的指令放到一起，显然是可以提升效率的。</strong></p>
<h5 id="内存系统重排"><a href="#内存系统重排" class="headerlink" title="内存系统重排"></a>内存系统重排</h5><p>另外，内存系统也会有“重排序”，但又不是真正意义上的重排序。在 JMM 里表现为主内存和线程的本地内存可能不一致，进而导致程序在多线程下执行可能出现问题。</p>
<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a><mark>Java 内存模型<mark></h2><p>并发编程环境下，像 CPU 多级缓存和指令重排这类设计可能会导致程序运行出现一些问题。就比如说我们上面提到的指令重排序就可能会让多线程程序的执行出现问题。</p>
<p>JMM 说白了就是定义了一些规范来解决这些问题，例如 JMM 抽象了 happens-before 原则（后文会详细介绍到）来解决指令重排序问题。开发者可以利用 JMM 规范更方便地开发多线程程序。Java 开发者不需要了解底层原理，直接使用并发相关的一些关键字和类（比如 <code>volatile</code>、<code>synchronized</code>、各种 <code>Lock</code>）即可开发出并发安全的程序。</p>
<p>与 Java 内存区域要区分开：</p>
<ul>
<li>JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说<strong>堆主要用于存放对象实例</strong>，栈用来存放局部变量。</li>
<li>Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</li>
</ul>
<h3 id="线程与主内存"><a href="#线程与主内存" class="headerlink" title="线程与主内存"></a>线程与主内存</h3><p>在当前的 Java 内存模型下，线程可以把变量保存 <strong>本地内存</strong> （比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/jmm.png" alt="JMM(Java 内存模型)" style="zoom:60%;" />

<ul>
<li><strong>主内存</strong>：所有线程创建的实例对象都存放在主内存中，不管该实例对象是<strong>成员变量</strong>，还是<strong>局部变量</strong>，类信息、<strong>常量</strong>、<strong>静态变量</strong>都是放在主内存中。为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。</li>
<li><strong>本地内存</strong>：每个线程都有一个私有的本地内存，本地内存存储了该线程以读 / 写共享变量的副本。每个线程只能操作自己本地内存中的变量，<strong>无法直接访问其他线程的本地内存</strong>。线程间通信必须通过主内存来进行。本地内存是 JMM 抽象出来的一个概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。图中的线程1想和线程2通信，线程1必须把自己的共享变量副本同步到住内存里，然后线程2需要从主内存读取，读取的共享变量是否是线程1修改过的，是不知道的，由此引发了线程安全问题。</li>
<li>Java 内存模型定义了八种同步操作，规定了关于主内存与工作内存直接的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现细节。规定了一些同步规则来保证这些同步操作的正确执行 <a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/jmm.html#jmm-%E6%98%AF%E5%A6%82%E4%BD%95%E6%8A%BD%E8%B1%A1%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%B8%BB%E5%86%85%E5%AD%98%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">详见 JavaGuide</a> </li>
</ul>
<h3 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a>happens-before 原则</h3><p>JSR 133 引入了 happens-before 这个概念来描述<strong>两个操作之间的内存可见性</strong>。</p>
<p>happens-before 原则的诞生是为了程序员和编译器、处理器之间的平衡。程序员追求的是易于理解和编程的强内存模型，遵守既定规则编码即可。编译器和处理器追求的是较少约束的弱内存模型，让它们尽己所能地去优化性能，让性能最大化。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220731155332375-1735372822645-10-1735372984006-14.png" alt="img" style="zoom:70%;" />

<ul>
<li>为了对编译器和处理器的约束尽可能少，只要<strong>不改变程序的执行结果</strong>（单线程程序和正确执行的多线程程序），编译器和处理器怎么进行重排序优化都行。两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。</li>
<li>对于会改变程序执行结果的重排序，JMM 要求<u>编译器</u>和<u>处理器</u>必须<mark>禁止<mark>这种重排序。</li>
</ul>
<p>happens-before 原则表达的意义其实并不是一个操作发生在另外一个操作的前面，虽然这从程序员的角度上来说也并无大碍。更准确地来说，它更想表达的意义是**前一个操作的结果对于后一个操作<mark>是可见的<mark>**，无论这两个操作是否在同一个线程里。</p>
<p>具体规则：1. 按照代码先后顺序 2. 线程的 <code>start()</code> 先于其他所有动作 3. 传递性</p>
<ol start="4">
<li><p>Monitor 的解锁 happens- before 于随后对此 Monitor 的加锁 <code>synchronized</code></p>
</li>
<li><p>对 <code>volatile</code> 域的<mark>写<mark>，happens- before 于任意的后续对此 <code>volatile</code> 域的<mark>读<mark> </p>
<ul>
<li><code>volatile</code> 仅保证变量读写操作的可见性和有序性，不保证复合操作（ <code>i++</code>）的原子性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 线程1</span></span><br><span class="line">a = <span class="number">1</span>;        <span class="comment">// 普通写</span></span><br><span class="line">flag = <span class="literal">true</span>;  <span class="comment">// volatile 写</span></span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;   <span class="comment">// volatile 读</span></span><br><span class="line">    System.out.println(a); <span class="comment">// 一定会输出 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>保证 <code>flag = true</code> 的写入之前，<code>a = 1</code> 已经执行完毕，并且对线程 2 可见。</li>
<li>在 JDK 5 之前，由于没有禁止 volatile 指令重排序，<code>a = 1</code> 可能会被移动到 <code>flag = true</code> 之后执行，导致线程 2 看到 <code>flag</code> 为 true，但 <code>a</code> 的值仍然是 0。这种情况显然是违背直觉的，也无法确保程序正确性。</li>
<li>在 JDK 5 及之后，<code>a = 1</code> 一定会在 <code>flag = true</code> 之前执行， <code>flag = true</code> 一定在 <code>if(flag)</code> 之前执行，从而保证了有序性和内存可见性。</li>
</ul>
</li>
</ol>
<p><strong>JMM 与 happens-before</strong></p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220731084604667.png" alt="happens-before 与 JMM 的关系" style="zoom:67%;" />

<p>程序员在 happens-before 提供的内存可见性基础上编程，JMM 的实现：根据编译器和处理器的重排序规则，如果出现了重排序，除非没有影响执行结果，否则就禁止重排序：为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。实现细节对于程序员是透明的，只要保证程序执行时语义不改变即可。</p>
<h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a><mark><code>volatile</code> 关键字<mark></h2><ol>
<li><p><code>volatile</code> 关键字并非 Java 语言特有，在 C 语言里也有，其最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 <code>volatile</code> 修饰，这就告诉编译器这个变量是共享且不稳定的，每次使用它都到主存中进行读取。（可见性）</p>
</li>
<li><p>在 Java 中，<code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是<strong>防止 JVM 的指令重排序</strong>。 如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。（有序性）（Unsafe 类的内存屏障方法也可以实现 volatile 相同的效果）</p>
</li>
<li><p><code>volatile</code> 无法保证原子性。</p>
</li>
</ol>
<h3 id="双重校验实现单例：volatile-synchronized"><a href="#双重校验实现单例：volatile-synchronized" class="headerlink" title="双重校验实现单例：volatile + synchronized"></a>双重校验实现单例：<code>volatile</code> + <code>synchronized</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton unique;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getunique</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (unique &lt;mark&gt; <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁(对象锁)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (unique &lt;mark&gt; <span class="literal">null</span>) &#123;</span><br><span class="line">                    unique = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unique;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 <code>unique</code> 的写操作: <code>unique = new Singleton();</code> 可以分成如下三步</p>
<ol>
<li>为 <code>unique</code> 分配内存空间 malloc</li>
<li>初始化 <code>unique</code> initialize</li>
<li>将 <code>unique</code> 指向分配的引用地址(赋值)</li>
</ol>
<p>对 <code>unique</code> 的读操作: <code>if (unique == null)</code> </p>
<p><code>volatile</code> 使 <strong>写操作的第 3 步</strong> 一定对读操作可见；</p>
<p>但是指令重排仍然会导致一些问题，在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getunique</code>() 后发现 <code>unique</code> 不为空，因此返回 <code>unique</code>，但此时 <code>unique</code> 还未被初始化。<code>volatile</code> 能够禁止这种重排。</p>
<h2 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a><mark><code>synchronized</code> 关键字<mark></h2><p><code>synchronized</code> 是 Java 中的一个关键字，也叫做对象锁，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。它是 Java 内置的同步机制，在 JVM 中实现，隐式获取、自动释放。</p>
<p>在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。这是因为监视器锁（Monitor）是依赖于底层的操作系统的互斥锁 <code>mutex</code> 和条件变量 <code>cond</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>
<p>在 Java 6 之后， <code>synchronized</code> 引入了大量的优化如<strong>自旋锁</strong>、适应性自旋锁、<strong>锁消除</strong>、<strong>锁粗化</strong>、<del>-偏向锁-</del>、<strong>轻量级锁</strong>等技术来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多。因此， <code>synchronized</code> 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 <code>synchronized</code> 。</p>
<blockquote>
<p>由于偏向锁增加了 JVM 的复杂性，同时也并没有为所有应用都带来性能提升。因此，在 JDK 15 中，偏向锁被默认关闭（仍然可以使用 <code>-XX:+UseBiasedLocking</code> 启用偏向锁），在 JDK 18 中，偏向锁已经被彻底废弃（无法通过命令行打开）。</p>
</blockquote>
<ul>
<li>加在实例方法上，相当于<code>synchronized(this)</code>；</li>
<li>加在静态方法上，相当于<code>synchronized(Example.class)</code>；</li>
<li>尽量使用<code>this</code>作为对象锁，不要图方便使用字符串常量等</li>
</ul>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><h4 id="同步代码块与同步方法"><a href="#同步代码块与同步方法" class="headerlink" title="同步代码块与同步方法"></a>同步代码块与同步方法</h4><p><strong><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong></p>
<p>含有同步代码块的字节码中包含一个 <code>monitorenter</code> 指令以及两个 <code>monitorexit</code> 指令，这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放。</p>
<p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<blockquote>
<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的。每个对象中都内置了一个 <code>ObjectMonitor</code> 对象。</p>
<p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p>
</blockquote>
<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p>
<p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p>
<p><strong>同步方法</strong>：<code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取而代之的是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p>
<h4 id="可重入性-Reentrancy"><a href="#可重入性-Reentrancy" class="headerlink" title="可重入性 (Reentrancy)"></a>可重入性 (Reentrancy)</h4><p><code>synchronized</code> 的可重入性依赖于 <strong>Monitor 对象</strong> 的 <strong>锁计数器</strong> 和 <strong>锁持有线程ID</strong>。</p>
<p>同一个线程每进入一次同步方法或者对象锁相同的同步代码块，就会将锁计数器+1，退出时-1，减到0则释放锁</p>
<h4 id="ObjectMonitor"><a href="#ObjectMonitor" class="headerlink" title="ObjectMonitor"></a>ObjectMonitor</h4><p>synchronized 是基于管程实现的，核心的数据结构是 ObjectMonitor，AQS也基于MESA管程</p>
<p><strong>ObjectMonitor 的核心作用</strong></p>
<ul>
<li>保证同一时刻只有一个线程能执行同步代码块（<strong>互斥</strong>）。</li>
<li>提供线程之间的等待和唤醒机制（<strong>条件变量</strong>）。</li>
</ul>
<p>每个 Java 对象都与一个 对象监视器锁 关联，用于控制对该对象的访问权限。采用 Mesa 语义</p>
<p><strong>底层机制</strong> </p>
<ul>
<li><strong>互斥锁（Mutex）</strong>：<ul>
<li>Monitor 使用操作系统的互斥锁来实现互斥访问。</li>
<li>重量级锁通过内核态的同步原语（如 <code>futex</code> 或 <code>pthread_mutex</code>）挂起和唤醒线程。</li>
</ul>
</li>
<li><strong>条件变量（Condition Variable）</strong>：<ul>
<li>等待队列和条件变量用于管理线程状态。<code>pthread_cond</code></li>
<li>条件变量依赖于操作系统的 <code>wait()</code> 和 <code>signal()</code> 机制，控制线程等待和唤醒。</li>
</ul>
</li>
<li><strong>线程阻塞与唤醒</strong>：<ul>
<li>当线程无法获取锁时，Monitor 会将其挂起，并调用操作系统的线程调度机制。</li>
<li>被唤醒的线程通过抢占式调度重新竞争锁资源。</li>
</ul>
</li>
</ul>
<h3 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h3><p>锁主要有四种状态：无锁、偏向锁、轻量级锁、重量级锁，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3230688-20231101142724469-1226844103.png" alt="img" style="zoom: 80%;" />

<p><strong>对象头中的 Mark Word</strong></p>
<p>Java 对象在内存中由以下部分组成：</p>
<table>
<thead>
<tr>
<th>内存布局</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>对象头（Header）</td>
<td>4 字节 Mark Word、4 字节 <code>.class</code> Pointer</td>
</tr>
<tr>
<td>实例数据</td>
<td>实例变量存储的数据</td>
</tr>
<tr>
<td>对齐填充</td>
<td>用于内存对齐，按照8字节填充</td>
</tr>
</tbody></table>
<p>Mark Word 是对象头中的一部分，存储对象的状态和锁信息。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/443934-20201207134826598-1740849743.png" alt="img"></p>
<p><strong>注：锁状态会根据竞争情况自动升级，从偏向锁到轻量级锁，再到重量级锁。</strong> </p>
<h3 id="synchronized-与-volatile-的区别"><a href="#synchronized-与-volatile-的区别" class="headerlink" title="synchronized 与 volatile 的区别"></a><code>synchronized</code> 与 <code>volatile</code> 的区别</h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li>
<li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li>
<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a><code>final</code> 关键字</h2><p><a target="_blank" rel="noopener" href="https://www.nenggz.com/md/java/thread/java-thread-x-key-final.html">关键字: final详解 | Java 全栈知识体系</a> </p>
<p>用 final 修饰的类不可以被继承，用 final 修饰的方法不可以被覆写，用 final 修饰的属性一旦初始化以后不可以被修改。当然，我们不关心这些段子，这节，我们来看看 final 带来的内存可见性影响。</p>
<p>之前在说双重检查的单例模式的时候，提过了一句，如果所有的属性都使用了 final 修饰，那么 volatile 也是可以不要的，这就是 final 带来的可见性影响。</p>
<p>在对象的构造方法中设置 final 属性，<strong>同时在对象初始化完成前，不要将此对象的引用写入到其他线程可以访问到的地方</strong>（不要让引用在构造函数中逸出）。如果这个条件满足，当其他线程看到这个对象的时候，那个线程始终可以看到正确初始化后的对象的 final 属性。</p>
<p>上面说得很明白了，final 属性的写操作不会和此引用的赋值操作发生重排序，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.finalField = v; ...; sharedRef = x;</span><br></pre></td></tr></table></figure>

<h2 id="ThreadLocal-lt-T-gt"><a href="#ThreadLocal-lt-T-gt" class="headerlink" title="ThreadLocal&lt;T&gt;"></a><mark><code>ThreadLocal&lt;T&gt;</code><mark></h2><p><code>ThreadLocal</code> 主要用于以下场景：</p>
<ol>
<li><strong>线程安全的变量管理：</strong> 比如事务管理、用户会话等。</li>
<li><strong>避免同步锁：</strong> 替代传统的锁机制，提高并发性能。</li>
<li><strong>数据库连接或会话缓存：</strong> 每个线程维护自己的数据库连接实例。</li>
</ol>
<p>T 用于表示 ThreadLocal 存的值类型</p>
<p>ThreadLocal在Spring中发挥着巨大的作用，在管理request作用域中的bean、事务管理、任务调度、aop等模块都出现了它的身影。<br>Spring中绝大部分Bean都可以声明成Singleton作用域，采用ThreadLocal进行封装，因此有状态的bean就能够以 Singleton的方式在多线程中正常工作了。</p>
<h3 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h3><p><strong>JVM 提供线程隔离：</strong></p>
<ul>
<li>每个线程都有自己的栈空间和线程私有变量。</li>
<li>JVM 将 <code>Thread</code> 对象与其局部变量绑定，保证变量不被其他线程访问。</li>
</ul>
<p><strong>JDK 提供 <code>ThreadLocal</code>：</strong> </p>
<ul>
<li><code>ThreadLocal</code> 依赖于每个线程 (<code>Thread</code> 对象) 内部的 <code>ThreadLocalMap</code> 实现数据存储，每个线程都持有一个独立的 <code>ThreadLocalMap</code> 实例</li>
<li><code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</li>
<li><code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</li>
<li>每次访问 <code>ThreadLocal</code> 时，都会从当前线程的 <code>ThreadLocalMap</code> 查找对应的value。</li>
<li>不同线程之间的 <code>ThreadLocalMap</code> 互不影响，因此保证了变量的线程隔离性。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2-CFHd4NU8.png" alt="img"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ThreadLocal-01.png" alt="ThreadLocal各引用间的关系"></p>
<p>哈希冲突解决：开放地址法（线性探测）</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>注意泛型、remove避免内存泄露 public static final</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义 ThreadLocal 变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// tl = ThreadLocal.withInitial(() -&gt; 0) 可以设置初始值</span></span><br><span class="line">tl.set(<span class="number">100</span>); <span class="comment">// 当前线程设置值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get(); <span class="comment">// 获取当前线程的值</span></span><br><span class="line">tl.remove(); <span class="comment">// 避免内存泄漏</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241230193230746.png" alt="image-20241230193230746"></p>
<p>如图 在 web 请求到达时，进入controller之前的interceptor可以</p>
<h3 id="内存泄漏：弱引用与强引用"><a href="#内存泄漏：弱引用与强引用" class="headerlink" title="内存泄漏：弱引用与强引用"></a>内存泄漏：弱引用与强引用</h3><p>key 是 ThreadLocal 对象，弱引用；value 是 Object 对象，强引用。</p>
<p>那么在<code>ThreadLocal.get()</code>的时候，发生<code>GC</code>之后，<code>key</code>是否是<code>null</code>？</p>
<p>为了搞清楚这个问题，我们需要搞清楚<code>Java</code>的<strong>四种引用类型</strong>：</p>
<ul>
<li><strong>强引用</strong>：我们常常 new 出来的对象就是强引用类型，只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足的时候</li>
<li><strong>软引用</strong>：使用 SoftReference 修饰的对象被称为软引用，软引用指向的对象在内存要溢出的时候被回收</li>
<li><strong>弱引用</strong>：使用 WeakReference 修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收</li>
<li><strong>虚引用</strong>：虚引用是最弱的引用，在 Java 中使用 PhantomReference 进行定义。虚引用中唯一的作用就是用队列接收对象即将死亡的通知</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/5-GYIVKEun.png" alt="img"></p>
<p>当作为 key 的 <code>ThreadLocal</code> 实例失去强引用后，只要发生 GC 就会被回收，但是其对应的 value <code>Object</code> 仍然存在于 <code>ThreadLocalMap</code> 中，因为 <code>Entry</code> 对象强引用了它。如果线程持续存活（例如线程池中的线程），<code>ThreadLocalMap</code> 也会一直存在，导致 key 为 <code>null</code> 的 entry 无法被垃圾回收，机会造成内存泄漏。</p>
<ol>
<li>在使用完 <code>ThreadLocal</code> 后，<mark>务必调用 <code>remove()</code> 方法<mark>。 这是最安全和最推荐的做法。 <code>remove()</code> 方法会从 <code>ThreadLocalMap</code> 中显式地移除对应的 entry，彻底解决内存泄漏的风险。 即使将 <code>ThreadLocal</code> 定义为 <code>static final</code>，也强烈建议在每次使用后调用 <code>remove()</code>。</li>
<li>在线程池等线程复用的场景下，<mark>使用 <code>try-finally</code> 块<mark>可以确保即使发生异常，<code>remove()</code> 方法也一定会被执行。</li>
</ol>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a><span id="lock">锁</span></h1><p><code>java.util.concurrent.locks</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241230173434255-1735551283426-42.png" alt="image-20241230173434255"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241230173500715.png" alt="image-20241230173500715"></p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><mark><code>ReentrantLock</code><mark></h2><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个<mark>可重入<mark>且<mark>独占式<mark>的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了<strong>非阻塞</strong>、<strong>超时</strong>、<strong>中断</strong>、<strong>公平锁和非公平锁</strong>等高级功能。</p>
<p>继承关系：实现了 Lock 接口，有一个 Sync 内部类，Sync 继承了 AQS，加锁和释放锁基本在 Sync 中实现，Sync 有公平锁 FairSync 和非公平锁 NonfairSync 两个子类。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aqs.png" alt="Classes"></p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本如上，finally 逻辑一定要释放锁，防止死锁</p>
<h3 id="与-synchronized-比较"><a href="#与-synchronized-比较" class="headerlink" title="与 synchronized 比较"></a>与 <code>synchronized</code> 比较</h3><table>
<thead>
<tr>
<th></th>
<th><code>synchronized</code></th>
<th><code>ReentrantLock</code></th>
</tr>
</thead>
<tbody><tr>
<td>实现</td>
<td><strong>JVM</strong> 底层关键字</td>
<td><strong>JDK</strong> API</td>
</tr>
<tr>
<td>公平锁</td>
<td>不支持</td>
<td>可显式指定 <code>new Reentrantlock(true)</code></td>
</tr>
<tr>
<td>多条件/选择通信</td>
<td>只支持一个条件变量</td>
<td>Condition 支持多个条件变量</td>
</tr>
<tr>
<td>线程通信API</td>
<td><code>wait()</code> <code>notify()</code> <code>notifyAll()</code></td>
<td><code>await()</code> <code>signal()</code> <code>signalAll()</code> <code>lock.newCondition()</code></td>
</tr>
<tr>
<td>可重入</td>
<td>支持</td>
<td>支持 <code>getHoldCount()</code> 查看重入次数</td>
</tr>
<tr>
<td>超时等待</td>
<td>不支持</td>
<td>支持 <code>tryLock(timeout)</code> 超时返回机制</td>
</tr>
<tr>
<td>释放</td>
<td>进出代码块自动完成</td>
<td>手动 (<code>lock()</code> <code>unlock()</code>)</td>
</tr>
<tr>
<td>中断</td>
<td>不可响应中断</td>
<td><code>lock.lockInterruptibly()</code></td>
</tr>
<tr>
<td>阻塞获取</td>
<td>只能阻塞获取</td>
<td>支持非阻塞获取<code>tryLock()</code> 失败直接返回</td>
</tr>
</tbody></table>
<p>超时等待：防止死锁， 防止线程无限期阻塞</p>
<p>等待可中断：获取锁的线程在阻塞等待的过程中，如果其他线程中断当前线程 <code>interrupt()</code> ，就会抛出 <code>InterruptedException</code> 异常，可以捕获该异常，做一些处理操作</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>包含独占写锁和共享读锁，在读多写少的情况下性能很好，分为可重入<code>ReentrantReadWriteLock</code> 和不可重入 <code>StampedLock</code> <a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#reentrantreadwritelock-%E6%98%AF%E4%BB%80%E4%B9%88">详见 JavaGuide</a> </p>
<p>ReentrantReadWriteLock </p>
<p>1、读写锁接口ReadWriteLock接口的一个具体实现，实现了读写锁的分离， </p>
<p>2、支持公平和非公平，底层也是基于AQS实现 </p>
<p>3、允许从写锁降级为读锁 流程：先获取写锁，然后获取读锁，最后释放写锁；但不能从读锁升级到写锁 </p>
<p>4、重入：读锁后还可以获取读锁；获取了写锁之后既可以再次获取写锁又可以获取读锁 核心：读锁是共享的，写锁是独占的。 读和读之间不会互斥，读和写、写和读、写和写之间才会互斥， 主要是提升了读写的性能</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a><span id="tools"><mark>AQS<mark></span></h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解 - waterystone - 博客园</a> </p>
<p><strong>AQS（AbstractQueuedSynchronizer）</strong> 是 <strong>Java 并发包</strong>（<code>java.util.concurrent</code>）提供的一个<strong>底层同步框架</strong>，是一个抽象类，用来实现锁和同步器。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，</p>
<ul>
<li>独占：<code>tryAcquire-tryRelease</code>(ReentrantLock)</li>
<li>共享：<code>tryAcquireShared-tryReleaseShared</code>(Semaphore, CountDownLatch)</li>
<li>AQS也支持同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code> </li>
</ul>
<h3 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ol>
<li><p><strong>共享变量 (state)：</strong> </p>
<ul>
<li>AQS 内部有一个整数 <code>volatile</code> 变量 <code>state</code>，用来表示当前锁的状态，比如 0 表示空闲，1 表示已占用。</li>
<li>多个线程可以通过 <strong>CAS 操作</strong>来修改这个共享变量，从而实现并发控制。</li>
</ul>
</li>
<li><p><strong>等待队列 (CLH FIFO队列)：</strong> </p>
<p><code>Node</code>: 含有<code>thread</code>对象</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/40cb932a64694262993907ebda6a0bfetplv-k3u1fbpfcp-zoom-1.png" alt="img"></p>
<ul>
<li>如果线程无法获取共享资源，就进入一个等待队列，这个队列是一个<strong>双向链表</strong>结构。</li>
</ul>
<p><code>waitStatus</code>: </p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/785ca26c055b5be2761374af6a0c7bc5.webp?x-image-process=image/format,png#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><strong>CANCELLED</strong>(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li>
<li><strong>SIGNAL</strong>(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</li>
<li><strong>CONDITION</strong>(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将<strong>从等待队列转移到同步队列中</strong>，等待获取同步锁。</li>
<li><strong>PROPAGATE</strong>(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li>
<li><strong>0</strong>：新结点入队时的默认状态。</li>
</ul>
<p>注意，<strong>负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用&gt;0、&lt;0来判断结点的状态是否正常</strong>。</p>
</li>
<li><p><strong>模板方法：</strong>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可<strong>，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</strong> </p>
<ul>
<li><p><code>isHeldExclusively()</code>：是否正在独占资源。只有用到condition才需要去实现它。</p>
</li>
<li><p><code>tryAcquire(int i)</code>：独占方式。尝试获取资源，成功则返回true，失败则返回false。</p>
</li>
<li><p><code>tryRelease(int i</code>)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</p>
</li>
<li><p><code>tryAcquireShared(int i)</code>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</p>
</li>
<li><p><code>tryReleaseShared(int i)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>
</li>
<li><p>参数 <code>i</code> 表示共享资源的个数，<code>tryAcquire</code> 就是在更改 <code>state</code></p>
<ul>
<li>以<code>ReentrantLock</code>为例，<code>tryLock()</code>就是在非阻塞获取，<code>lock()</code>就是真正的获取过程，先<code>initialTryLock()</code> 一下，逻辑和<code>tryLock()</code>类似这里默认state就是1，因为是Lock自己内部的。如果失败了才真正<code>acquire(1)</code>，这里的1就代表资源的个数（锁的个数）只有1，这里才开始重写AQS的内容，<code>tryAcquire(1)</code> 开始…</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!initialTryLock())</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解 - waterystone - 博客园</a> </p>
<ol>
<li>尝试获取<ul>
<li>如果共享资源空闲，线程可以直接占用资源。</li>
<li>如果锁已被占用，线程会创建一个节点加入队列尾部。</li>
</ul>
</li>
<li>排队等待<ul>
<li>前一个线程释放锁时，会通知队列中的下一个线程。</li>
<li>通知机制依赖 <code>LockSupport.park()</code> 和 <code>LockSupport.unpark()</code> 实现线程通信。</li>
</ul>
</li>
<li>被唤醒的线程继续尝试获取锁，如果成功，则从队列中移除原队头，老二称为新的队头。</li>
</ol>
<p><strong>CLR 队列节点大致结构</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 等待状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 通知下一个线程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 已取消 已放弃</span></span><br><span class="line">    <span class="type">int</span> waitStatus; </span><br><span class="line"></span><br><span class="line">    Node prev; <span class="comment">// 前驱节点</span></span><br><span class="line">    Node next; <span class="comment">// 后继节点</span></span><br><span class="line">    Thread thread; <span class="comment">// 当前线程引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/721070-20170504110246211-10684485-1735391533653-31-1735395150328-37.png" alt="img"></p>
<h5 id="acquire-int"><a href="#acquire-int" class="headerlink" title="acquire(int)"></a><code>acquire(int)</code></h5><p>获取操作：<code>acquire(int arg)</code>：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/721070-20151102145743461-623794326-1735395145015-35-1735395190296-39.png" alt="img"></p>
<p>如图所示，队头是当前共享资源占用者，AQS保证严格按照入队顺序唤醒，老二被<code>unpark</code>之后尝试获取，如果成功自己就是队头，之前的队头将来会自动回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 acquire() 方法中，当 if 语句的条件返回 true 后，就会调用 selfInterrupt() ，该方法会中断当前线程，为什么需要中断当前线程呢？当 if 判断为 true 时，需要 tryAcquire() 返回 false ，并且 acquireQueued() 返回 true 。其中 acquireQueued() 方法返回的是线程被唤醒之后的 中断状态 ，通过执行 Thread.interrupted() 来返回。该方法在返回中断状态的同时，会清除线程的中断状态。因此如果 if 判断为 true ，表明线程的中断状态为 true ，但是调用 Thread.interrupted() 之后，线程的中断状态被清除为 false ，因此需要重新执行 selfInterrupt() 来重新设置线程的中断状态。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aqs-acquire-exclusive-1735447666698-3-1735447685230-5-1735447698634-7.png" alt="Exclusive Acquire"></p>
<p><strong>尝试获取</strong>：<code>tryAcquire(int arg)</code> : 应该由具体的实现类去实现(对status的CAS操作)</p>
<ul>
<li><p>以ReentrantLock为例：</p>
<ul>
<li><p>非公平锁(NotFairSync)：<code>tryAcquire()</code> 无需考虑队列中是否有前驱节点，前面有人也可以试着抢一下。失败后再排队。</p>
</li>
<li><p>公平锁(FairSync)：<code>tryAcquire()</code> 只有 !hasQueuedPredecessors() 才能尝试acquire</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static final class NonfairSync extends Sync:</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getState() == <span class="number">0</span> &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// static final class FairSync extends Sync:</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (getState() == <span class="number">0</span> &amp;&amp; !hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">       compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">       setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>**线程入队: **<code>addWaiter(Node)</code> <code>enq(Node)</code></p>
<p>应该用CAS更新，有快速和自旋两个阶段，快速插入是队列已经初始化了，尝试一次CAS更改</p>
<p>如果快速插入的CAS不成功，就进行自旋CAS插入<code>enq()</code> 同时，如果未初始化会先初始化队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、将当前线程封装为 Node 节点。</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">// 2、如果 pred ！= null，则证明 tail 节点已经被初始化，直接将 Node 节点加入队列即可。 CAS</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 2.1、通过 CAS 控制并发安全。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、初始化队列，并将新创建的 Node 节点加入队列。</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 1、通过 CAS 操作保证队列初始化的并发安全</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2、与 addWaiter() 方法中节点入队的操作相同</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程睡眠</strong>：<code>acquireQueued(Node, int arg)</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS：令队列中的节点尝试获取锁，并且对线程进行阻塞。</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//标记是否成功拿到资源</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 1、如果已经是老二，就可以再去尝试获取一下。</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2、判断线程是否可以阻塞，如果可以，则阻塞当前线程。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 3、如果获取锁失败，就会取消获取锁，将节点状态更新为 CANCELLED。</span></span><br><span class="line">        <span class="keyword">if</span> (failed)<span class="comment">// 等待过程中没有成功获取资源（超时/中断）</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS：判断当前线程节点是否可以阻塞。</span></span><br><span class="line"><span class="comment">// 前面可能有已经放弃的节点，应该挪到最后一个正常等待的节点后边；</span></span><br><span class="line"><span class="comment">// 并且只有前面节点状态为 `SIGNAL` 才能睡，不是的话就应该改成`SIGNAL`再睡</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="comment">// 1、前继节点状态正常，直接返回 true 即可。</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 2、ws &gt; 0 表示前继节点的状态异常，即为 CANCELLED 状态，需要跳过异常状态的节点。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3、如果前继节点的状态不是 SIGNAL，也不是 CANCELLED，就将状态设置为 SIGNAL。</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS 如果确实可以睡，就睡在`parkAndCheckInterrupt()`里等待唤醒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1、线程阻塞到这里 等待unpark()或interrupt()唤醒自己；</span></span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 2、线程被唤醒之后，返回线程中断状态</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="release-int"><a href="#release-int" class="headerlink" title="release(int)"></a><code>release(int)</code></h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aqs-release.png" alt="Release"></p>
<p>线程唤醒：<code>unparkSuccessor()</code> 唤醒队头之后第一个未放弃正常等待的节点，从后往前找。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;<span class="comment">//找到头结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);<span class="comment">//唤醒等待队列里的下一个线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//底层基于 LockSupport.unpark(thread);</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//这里，node一般为当前线程所在的结点。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)<span class="comment">//置零当前线程所在的结点状态，允许失败。</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;<span class="comment">//找到下一个需要唤醒的结点s</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">//如果为空或已取消</span></span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev) </span><br><span class="line">     <span class="comment">// 从后向前遍历,找到头节点后面第一个正常等待的节点</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)<span class="comment">//从这里可以看出，&lt;=0的结点，都是还有效的结点。</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);<span class="comment">//唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aqs-addWaiter.png" alt="img"></p>
<p>为什么prev链是强一致的？因为addWaiter()里每次compareAndSetTail(pred, node)之前都有node.prev = pred，enq()会反复尝试CAStail，直到成功。一旦CAStail成功，该node.prev就成功挂在之前的tail结点上而且是唯一的，这时其他新结点的prev只能尝试往新tail结点上挂。这里的组合用法非常巧妙，能保证CAS之前的prev链强一致，但不能保证CAS后的next链强一致。</p>
<p><code>acquireShared(int arg)</code>  </p>
<p>前面逻辑基本一致，先try 如果失败了，就准备入队，</p>
<p><code>setHeadAndPropagate(Node node, int propagate)</code> </p>
<p>如果自己成了老二并且尝试获取成功，如果资源还有剩余，就会唤醒下一个正常等待的节点：</p>
<p>这些都是失败了就会寻找安全点，进入睡眠</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    setHead(node);<span class="comment">//head指向自己</span></span><br><span class="line">     <span class="comment">//如果还有剩余量，继续唤醒下一个邻居线程</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>releaseShared(int arg)</code> </p>
<p>独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                unparkSuccessor(h);<span class="comment">//唤醒后继</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)<span class="comment">// head发生变化</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="AQS-的常见应用"><a href="#AQS-的常见应用" class="headerlink" title="AQS 的常见应用"></a>AQS 的常见应用</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-thread-x-juc-overview-lock.png" alt="image"></p>
<p>AQS 本身不是直接用来加锁的，而是作为<strong>其他锁工具的基础</strong>。</p>
<ul>
<li><strong>ReentrantLock（可重入锁）：</strong> 用于线程互斥。<ul>
<li> <code>state</code> 表示重入次数，每lock一次就+1，unlock一次就-1，因此获取和释放要一一对应，否则就会死锁，tryAcquire(1)</li>
</ul>
</li>
<li><strong>Semaphore（信号量）：</strong> 控制并发访问的线程数。tryAcquire(n)</li>
<li><strong>CountDownLatch（计数器）：</strong> 等待多个线程完成任务。tryAcquire(n)<ul>
<li> <code>state = N</code>，N 个子线程执行任务，每个子线程执行完后<code>countDown()</code> 一次，也就是 CAS 减 1，<code>state</code> 归零之后，会<code>unpark(callerThread)</code> 主调用线程，主线程从<code>await</code> 返回，继续后面的动作。</li>
</ul>
</li>
<li><strong>ReadWriteLock（读写锁）：</strong> 支持多个读线程和一个写线程。</li>
</ul>
<h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><code>Semaphore</code></h4><p>Semaphore 是 synchronized 的加强版，作用是控制线程的并发数量（允许 自定义多少线程同时访问）。就这一点而言，单纯的synchronized 关键字是实现不了的。</p>
<p>Semaphore有一个构造函数， 可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待， 等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中 传入的int型整数n=1，相当于变成了一个synchronized了。</p>
<p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，而<code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。</p>
<p>Semaphore 的使用简单，我们这里假设有 N(N&gt;5) 个线程来获取 <code>Semaphore</code> 中的共享资源，下面的代码表示同一时刻 N 个线程中只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。</p>
<p>当初始的资源个数为 1 的时候，<code>Semaphore</code> 退化为独占锁。</p>
<p><code>Semaphore</code> 有两种模式：公平和非公平 </p>
<p><code>Semaphore</code> 是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为 <code>permits</code>，你可以将 <code>permits</code> 的值理解为许可证的数量，只有拿到许可证的线程才能执行。</p>
<p>调用<code>semaphore.acquire()</code> ，线程尝试获取许可证，如果 <code>state &gt;= 0</code> 的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state-1</code>。如果 <code>state&lt;0</code> 的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。</p>
<p>调用<code>semaphore.release();</code> ，线程尝试释放许可证，并使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state+1</code>。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 <code>state</code> 的值 <code>state=state-1</code> ，如果 <code>state&gt;=0</code> 则获取令牌成功，否则重新进入阻塞队列，挂起线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始共享资源数量</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取1个许可</span></span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">// 释放1个许可</span></span><br><span class="line">semaphore.release();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreExample</span> &#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">300</span>);</span><br><span class="line">    <span class="comment">// 初始许可证数量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">      threadPool.execute(() -&gt; &#123;<span class="comment">// Lambda 表达式的运用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          semaphore.acquire();<span class="comment">// 获取一个许可，所以可运行线程数量为20/1=20</span></span><br><span class="line">          test(threadnum);</span><br><span class="line">          semaphore.release();<span class="comment">// 释放一个许可</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><code>CountDownLatch</code></h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>releaseShared()</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。</p>
<p>当主线程调用 <code>await()</code> 方法的时候，实际是<code>tryAcquireShared(1)和acquire(1)</code>: 如果 <strong>state 不为 0</strong>，表示计数器未归零，线程会被<strong>封装成 Node 并加入 AQS 的等待队列</strong>中，并进入 <strong>阻塞状态</strong>。<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。直到 <code>count</code> 个线程调用了<code>countDown()</code>使 state 值被减为 0，或者调用<code>await()</code>的线程被中断，该线程才会从阻塞中被唤醒，<code>await()</code> 方法之后的语句得到执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted() ||</span><br><span class="line">        (tryAcquireShared(arg) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         acquire(<span class="literal">null</span>, arg, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">0L</span>) &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 减-1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        signalNext(head);<span class="comment">// SIGNAL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">signalNext</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; (s = h.next) != <span class="literal">null</span> &amp;&amp; s.status != <span class="number">0</span>) &#123;</span><br><span class="line">        s.getAndUnsetStatus(WAITING);</span><br><span class="line">        LockSupport.unpark(s.waiter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample1</span> &#123;</span><br><span class="line">    <span class="comment">// 处理文件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//处理文件的业务操作</span></span><br><span class="line">                    <span class="comment">//......</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//表示一个文件已经被完成</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="用法及注意事项"><a href="#用法及注意事项" class="headerlink" title="用法及注意事项"></a>用法及注意事项</h5><ol>
<li>某一线程在开始运行前等待 n 个线程执行完毕 : 将 <code>CountDownLatch</code> 的计数器初始化为 n （<code>new CountDownLatch(n)</code>），每当一个任务线程执行完毕，就将计数器减 1 （<code>countdownlatch.countDown()</code>），当计数器的值变为 0 时，在 <code>CountDownLatch 上 await()</code> 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</li>
<li>实现多个线程开始执行任务的最大并行性：注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 <code>CountDownLatch</code> 对象，将其计数器初始化为 1 （<code>new CountDownLatch(1)</code>），多个线程在开始执行任务前首先 <code>coundownlatch.await()</code>，当主线程调用 <code>countDown()</code> 时，计数器变为 0，<strong>多个线程同时被唤醒</strong>。</li>
</ol>
<p>与 <code>CountDownLatch</code> 的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用 <code>CountDownLatch.await()</code> 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p>
<p>其他 N 个线程必须引用闭锁对象，因为他们需要通知 <code>CountDownLatch</code> 对象，他们已经完成了各自的任务。这种通知机制是通过 <code>CountDownLatch.countDown()</code>方法来完成的；每调用一次这个方法，在构造函数中初始化的 count 值就减 1。所以当 N 个线程都调 用了这个方法，count 的值等于 0，然后主线程就能通过 <code>await()</code>方法，恢复执行自己的任务。</p>
<p>再插一嘴：<code>CountDownLatch</code> 的 <code>await()</code> 方法使用不当很容易产生死锁，比如我们上面代码中的 for 循环改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount-<span class="number">1</span>; i++) &#123;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就导致 <code>count</code> 的值没办法等于 0，然后就会导致一直等待。</p>
<h5 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a><code>CyclicBarrier</code></h5><p>一个加强版的CountDownLatch。</p>
<p>作用就是会让所有线程都等待完成后才会继续下一步行 动。 CyclicBarrier初始化时规定一个数目，然后计算调用了CyclicBarrier.await()进入等待的线程数。 当线程数达到了这个数目时，所有进入等待状态的线程被唤醒并继续</p>
<p>CyclicBarrier初始时还可带一个Runnable的参数， 此Runnable任务在CyclicBarrier的数目达到 后，所有其它线程被唤醒前被执行。</p>
<h3 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a><code>ConditionObject</code></h3><p>Usage</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!conditionMet()) &#123;</span><br><span class="line">        condition.await(); <span class="comment">// 等待条件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行条件满足后的逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其他线程中：</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    updateCondition();</span><br><span class="line">    condition.signal(); <span class="comment">// 通知等待的线程</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Condition-的等待队列"><a href="#Condition-的等待队列" class="headerlink" title="Condition 的等待队列"></a>Condition 的等待队列</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Monitor.png" alt="Monitor"></p>
<p><code>ConditionObject</code> 维护一个<strong>等待队列</strong>（<mark>单向链表<mark>），其中每个节点是一个AQS CLH 队列的 <code>Node</code> ，节点的 <code>waitStatus</code> 被设置为 <code>COND</code>，表示属于Condition的等待队列节点。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/979960-20180430090729190-1934051559.png" alt="img"></p>
<p><code>ConditionNode</code> 关键字段：</p>
<ul>
<li><code>waitStatus</code>：<code>COND</code> </li>
<li><code>nextWaiter</code>：指向下一个等待节点。</li>
</ul>
<p><code>ConditionObject</code> 拥有等待队列的 <strong>头尾指针</strong>：</p>
<ul>
<li><code>firstWaiter</code>：指向队列头部（第一个等待线程）。</li>
<li><code>lastWaiter</code>：指向队列尾部（最后一个等待线程）。</li>
</ul>
<p>挂起自己的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isReleasable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> status &lt;= <span class="number">1</span> || Thread.currentThread().isInterrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">block</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!isReleasable()) LockSupport.park();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>线程调用 <code>await()</code> 进入等待队列，同时释放锁(AQS的独占锁实现，比如ReentrantLock)。<ol>
<li>调用 <code>addConditionWaiter()</code> 将线程加入条件队列。</li>
<li>调用 <code>fullyRelease()</code> 释放当前线程持有的锁。</li>
<li>判断线程是否进入同步队列，如果没有，则阻塞线程。</li>
<li>被唤醒后，通过 <code>reacquireQueued()</code> 重新获取锁。</li>
</ol>
</li>
<li>线程被阻塞，直到被其他线程唤醒（<code>signal()</code> 或 <code>signalAll()</code>）。<ol>
<li>检查调用线程是否持有锁。</li>
<li>调用 <code>doSignal()</code> 将条件队列中的节点移动到同步队列。</li>
<li>调用 <code>LockSupport.unpark()</code> 唤醒节点线程。</li>
</ol>
</li>
<li>被唤醒后，该线程进入 <strong>AQS 的 CLH 队列</strong> 排队尝试重新获取锁。</li>
</ol>
<h4 id="await"><a href="#await" class="headerlink" title="await()"></a><code>await()</code></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/979960-20180430095049880-331436771.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把当前线程的节点加入到等待队列中　</span></span><br><span class="line"><span class="comment">//调用await()的线程已经获取锁，所以在加入等待队列后，需要释放锁，并且唤醒后继节点线程</span></span><br><span class="line"><span class="comment">//挂起当前线程，当别的线程调用了signal（），并且是当前线程被唤醒的时候才从返回</span></span><br><span class="line"><span class="comment">//当被唤醒后，该线程会尝试去获取锁，只有获取到了才会从await()返回，否则挂起自己</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 创建节点并加入等待队列</span></span><br><span class="line">    <span class="type">ConditionNode</span> <span class="variable">node</span> <span class="operator">=</span> newConditionNode();</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> enableWait(node);<span class="comment">// 加入等待队列，唤醒同步队列的后继节点</span></span><br><span class="line">    LockSupport.setCurrentBlocker(<span class="built_in">this</span>); <span class="comment">// for back-compatibility</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>, cancelled = <span class="literal">false</span>, rejected = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/********************* 无法进入同步队列，循环 ******************************/</span></span><br><span class="line">    <span class="keyword">while</span> (!canReacquire(node)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interrupted |= Thread.interrupted()) &#123; <span class="comment">// 被中断 取消</span></span><br><span class="line">            <span class="keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((node.status &amp; COND) != <span class="number">0</span>) &#123;<span class="comment">// 未被中断 状态是COND 挂起自己</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rejected)</span><br><span class="line">                    node.block();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ForkJoinPool.managedBlock(node);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">                rejected = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">//其他情况，自选等待</span></span><br><span class="line">            Thread.onSpinWait();    <span class="comment">// awoke while enqueuing</span></span><br><span class="line">    &#125;</span><br><span class="line">    LockSupport.setCurrentBlocker(<span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/******** 从上方的循环中跳出，清除 status，准备ReAcquire，进入同步队列  ********/</span></span><br><span class="line">    node.clearStatus();</span><br><span class="line">    acquire(node, savedState, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cancelled) &#123;</span><br><span class="line">            unlinkCancelledWaiters(node);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="enableWait-node"><a href="#enableWait-node" class="headerlink" title="enableWait(node)"></a><code>enableWait(node)</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">enableWait</span><span class="params">(ConditionNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// 先检查是否拥有独占锁 </span></span><br><span class="line">    <span class="keyword">if</span> (isHeldExclusively()) &#123;</span><br><span class="line">        </span><br><span class="line">        node.waiter = Thread.currentThread();</span><br><span class="line">        node.setStatusRelaxed(COND | WAITING);</span><br><span class="line">        <span class="comment">// 尾插法插入条件变量的等待队列中</span></span><br><span class="line">        <span class="type">ConditionNode</span> <span class="variable">last</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">            firstWaiter = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last.nextWaiter = node;</span><br><span class="line">        lastWaiter = node;</span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 释放锁并唤醒同步队列中的下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState))</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有独占锁就需要将节点状态改变为 CANCELLED</span></span><br><span class="line">    node.status = CANCELLED; <span class="comment">// lock not held or inconsistent</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="canReacquire-node"><a href="#canReacquire-node" class="headerlink" title="canReacquire(node)"></a><code>canReacquire(node)</code></h5><p>如果一个在等待队列中的节点现在能够参与同步队列的 ReAcquire，返回 true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Returns true if a node that was initially placed on a condition</span></span><br><span class="line"><span class="comment">         * queue is now ready to reacquire on sync queue.*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canReacquire</span><span class="params">(ConditionNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// check links, not status to avoid enqueue race</span></span><br><span class="line">    Node p; <span class="comment">// traverse unless known to be bidirectionally linked</span></span><br><span class="line">    <span class="comment">// 必须要有前驱节点才能</span></span><br><span class="line">    <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; (p = node.prev) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (p.next == node || isEnqueued(node));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Returns true if node is found in traversal from tail */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isEnqueued</span><span class="params">(Node node)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="unlinkCancelledWaiters-node"><a href="#unlinkCancelledWaiters-node" class="headerlink" title="unlinkCancelledWaiters(node)"></a><code>unlinkCancelledWaiters(node)</code></h5><p><strong>机制</strong>：通过遍历队列节点检查状态标记，将已取消的节点从队列中断开引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">(ConditionNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span> || node.nextWaiter != <span class="literal">null</span> || node == lastWaiter) &#123;</span><br><span class="line">        <span class="type">ConditionNode</span> <span class="variable">w</span> <span class="operator">=</span> firstWaiter, trail = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (w != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ConditionNode</span> <span class="variable">next</span> <span class="operator">=</span> w.nextWaiter;</span><br><span class="line">            <span class="keyword">if</span> ((w.status &amp; COND) == <span class="number">0</span>) &#123;</span><br><span class="line">                w.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (trail == <span class="literal">null</span>)</span><br><span class="line">                    firstWaiter = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    trail.nextWaiter = next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                    lastWaiter = trail;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                trail = w;</span><br><span class="line">            w = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="doSignal-firstNode-all"><a href="#doSignal-firstNode-all" class="headerlink" title="doSignal(firstNode, all)"></a><code>doSignal(firstNode, all)</code></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/979960-20180430101906927-1765442903.png" alt="img"></p>
<p>signal(）方法首先会判断当前线程是不是独占的持有锁，从等待队列中取出第一个节点，并将其移动到 AQS 的同步队列中，然后唤醒等待线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(ConditionNode first, <span class="type">boolean</span> all)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ConditionNode</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">        <span class="keyword">if</span> ((firstWaiter = next) == <span class="literal">null</span>)</span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((first.getAndUnsetStatus(COND) &amp; COND) != <span class="number">0</span>) &#123;</span><br><span class="line">            enqueue(first);</span><br><span class="line">            <span class="keyword">if</span> (!all)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ConditionNode</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="signalAll"><a href="#signalAll" class="headerlink" title="signalAll()"></a><code>signalAll()</code></h5><p>与 <code>signal()</code> 类似，只是将所有等待节点依次移动到同步队列并唤醒。<code>signalAll()</code> 会唤醒所有线程，但可能导致“惊群效应”（即多个线程争夺锁），需要根据场景合理选择 <code>signal()</code> 或 <code>signalAll()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ConditionNode</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="死锁排查——JPS"><a href="#死锁排查——JPS" class="headerlink" title="死锁排查——JPS"></a>死锁排查——JPS</h3><p>jps进程状态工具 <strong>jps.exe 工具是 jdk 自带的，在 %JAVA_HOME%/bin 目录下。</strong></p>
<p>第一步：打开idea提供terminal终端命令行，使用<code>jps -l</code>查看进程<br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20230105200845649-1781815144.png" alt="DeadLock1"><br>第二步：使用<code>jstack 进程号</code>查看堆栈信息<br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20230105201438568-23123605.png" alt="DeadLock2"><br>一般情况信息在最后面<br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20230105201125421-886160053.png" alt="DeadLock3"></p>
<h1 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a><span id="atomic">原子变量</span></h1><p>一个操作具有原子性，即该操作不可分割、不可中断。即使在多个线程同时执行时，该操作要么全部执行完成，要么不执行，不会被其他线程看到部分完成的状态。</p>
<p><code>java.util.concurrent.atomic</code> 包中的 <code>Atomic</code> 原子类提供了一种线程安全的方式来操作单个变量。<code>Atomic</code> 类依赖于 CAS（Compare-And-Swap，比较并交换）乐观锁来保证其方法的原子性，而不需要使用传统的锁机制（如 <code>synchronized</code> 块或 <code>ReentrantLock</code>）。</p>
<h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a><mark>乐观锁与悲观锁<mark></h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁总是假设最坏的情况，即一定会发生线程安全问题，因此必须串行访问临界区，<code>synchronized</code> 和 <code>ReentrantLock</code> 就是悲观锁，高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题（线程获得锁的顺序不当时），影响代码的正常运行。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。</p>
<p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败并重试，会出现类似活锁的问题，这样同样会非常影响性能，导致 CPU 飙升。</p>
<p>不过，大量失败重试的问题也是可以解决的，像我们前面提到的 <code>LongAdder</code>以空间换时间的方式就解决了这个问题。</p>
<p><strong>理论上</strong>：</p>
<ul>
<li>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li>
<li>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li>
</ul>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>一般是在数据库表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。线程 A 更新数据时读入版本号为 1，此时插入一个线程 B 抢先操作完并提交使版本号更新为 2，线程 A 要提交的时候发现版本号不对，因此重新进行更新操作。</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>CAS 是一条原子操作，依赖于 CPU 的一条指令，在 Java 中由 Unsafe 类(native本地方法类)实现，一共有三个参数：要更新的变量，变量的预期值（旧值），要赋给变量的新值；返回值为CAS是否成功。具体原理参见OSTEP Concurrency 部分，<code>do-while</code> 循环也是自旋锁的原理。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><h5 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h5><p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong> </p>
<p>解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<h5 id="自旋开销大"><a href="#自旋开销大" class="headerlink" title="自旋开销大"></a>自旋开销大</h5><p>CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p>
<h5 id="只对单个变量有效"><a href="#只对单个变量有效" class="headerlink" title="只对单个变量有效"></a>只对单个变量有效</h5><p>CAS 操作仅能对单个共享变量有效。当需要操作多个共享变量时，CAS 就显得无能为力。不过，从 JDK 1.5 开始，Java 提供了<code>AtomicReference</code>类，这使得我们能够保证引用对象之间的原子性。通过将多个变量封装在一个对象中，我们可以使用<code>AtomicReference</code>来执行 CAS 操作。</p>
<p>除了 <code>AtomicReference</code> 这种方式之外，还可以利用加锁来保证。</p>
<h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><p>基本类型：<code>AtomicInteger/Long/Boolean</code></p>
<p>数组类型：<code>AtomicXXXArray</code>  XXX = <code>Integer/Long/Reference</code></p>
<p>引用类型：<code>AtomicReference</code> <code>AtomicStampedReference</code> 引用类型解决ABA</p>
<p>基本方法就是 get getAndAdd getAndIncrement compareAndSet getAndSet</p>
<ul>
<li><code>LongAdder</code>:  消耗内存更多，适合写多读少的情况</li>
<li><code>LongAccumulator</code>: generalized version of LongAdder, use <code>LongBinaryOperator</code> as operations</li>
</ul>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a><span id="executor">线程池</span></h1><h2 id="Future-lt-V-gt"><a href="#Future-lt-V-gt" class="headerlink" title="Future&lt;V&gt;"></a><code>Future&lt;V&gt;</code></h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241230173414548.png" alt="image-20241230173414548"></p>
<p><code>Future</code> 提供了一种轮询/阻塞的方式来获取异步任务的结果，但它不直接支持通知机制，而是需要主动检查任务是否完成。提供方法检查任务是否完成、等待任务完成和获取结果。</p>
<p>是 <code>submit()</code>  的返回值，   isDone() 检查是否完成，get() 阻塞等待返回结果</p>
<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a><code>Callable</code></h3><p>Callable 接口类似于 Runnable，从名字就可以看出来了，会返回结果，并且可以抛出返回结果的异常，使用 <strong>call()</strong> 方法代替 <strong>run()</strong> 方法，适合需要结果的任务。可以直接提交到线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureCallableExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        Callable&lt;Integer&gt; task = () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时任务</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务是否完成: &quot;</span> + future.isDone());</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 阻塞等待结果</span></span><br><span class="line">            System.out.println(<span class="string">&quot;任务结果: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="FutureTask-lt-V-gt"><a href="#FutureTask-lt-V-gt" class="headerlink" title="FutureTask&lt;V&gt;"></a><code>FutureTask&lt;V&gt;</code></h3><p>FutureTask 表示一个异步运算的任务，实现了 Runnable 和 Future 接口（RunnableFuture）</p>
<p>FutureTask 通过传入 Callable 的实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然也可以传入 Runnable 的实现类，但是 Runnable 没有返回值，因此需要额外传入一个指定的返回值。V 表示返回值的类型</p>
<p>只有当任务完成的时候结果才能取回，如果<mark>任务尚未完成 <code>get()</code> 方法将会阻塞<mark>。</p>
<p>FutureTask 可以 submit 到线程池，还可以可以直接作为 Thread 构造器的参数(Runnable)创建新线程（实践中不建议直接创建新线程）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Callable&lt;String&gt; callable = () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;任务完成!&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行其他任务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程正在执行其他任务...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get(); <span class="comment">// 阻塞等待</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行结果: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a><code>ExecutorService</code></h2><p>继承了 ExecutorService 并进行一定程度扩展</p>
<p><code>shutdown()</code> 关闭            <code>submit()</code> 提交任务</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-concurrent-executors.png" alt="Executors"></p>
<h3 id="execute-Runnable-command-Runnable-ONLY"><a href="#execute-Runnable-command-Runnable-ONLY" class="headerlink" title="execute(Runnable command) (Runnable ONLY)"></a><code>execute(Runnable command)</code> (<strong>Runnable ONLY</strong>)</h3><p>ThreadPoolExecutor 实现的方法，定义在 <strong><code>Executor</code></strong> 接口中。</p>
<p>只支持提交 <strong><code>Runnable</code></strong> 类型的任务。无返回值，无法获取任务执行结果。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/thread-pool-principle.png" alt="图解线程池实现原理"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********源码************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment"> * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment"> * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment"> * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment"> * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment"> * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment"> * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment"> * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment"> * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment"> * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment"> * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment"> * and so reject the task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 1. 当前线程数 &lt; corePoolSize，创建核心线程</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 如果corePoolSize已满，将任务放入阻塞队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command); <span class="comment">// 检查是否需要拒绝</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 任务队列已满，尝试扩展到 maximumPoolSize</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command); <span class="comment">// 执行拒绝策略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用例</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务1执行: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;);</span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>

<h4 id="submit-supports-Callable-Runnable"><a href="#submit-supports-Callable-Runnable" class="headerlink" title="submit() (supports Callable, Runnable)"></a><code>submit()</code> (supports Callable, Runnable)</h4><p>可以提交 Callable 和 Runnable 任务，返回的是 Future 对象</p>
<ol>
<li>**<code>Runnable</code>**：不返回结果的任务。</li>
<li>**<code>Callable&lt;T&gt;</code>**：<mark>可以返回结果或抛出异常的任务<mark>。</li>
<li>**<code>T result</code>**：指定任务完成后返回的结果。可以给Runnable人工指定返回值，不指定也行</li>
</ol>
<ul>
<li>返回 <strong><code>Future</code></strong> 对象，用于获取任务执行的结果或状态，并且可以方便异常处理。</li>
</ul>
<p>定义在 <strong><code>ExecutorService</code></strong> 接口中，由<code>AbstractExecutorService</code>实现。支持 <strong><code>Runnable</code></strong> 和 <strong><code>Callable</code></strong> 两种任务类型。返回一个 <strong><code>Future&lt;T&gt;</code></strong> 对象，可以获取任务结果或判断任务状态。</p>
<p>主要的任务就是将 Runnable 或者 Callable 封装成 <strong>FutureTask</strong>，FutureTask 实现了 RunnableFuture（实现了 Runnable）可以直接作为 execute(Runnable command) 的参数，查看返回值本身跟线程池没关系，是 Future 的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br><span class="line">Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务2执行: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务结果: &quot;</span> + future.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>

<h3 id="Executors-工具类提供的默认线程池"><a href="#Executors-工具类提供的默认线程池" class="headerlink" title="Executors 工具类提供的默认线程池"></a>Executors 工具类提供的默认线程池</h3><table>
<thead>
<tr>
<th>线程池类型</th>
<th>核心线程数</th>
<th>最大线程数</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>FixedThreadPool</strong></td>
<td>固定数量</td>
<td>固定数量</td>
<td>固定线程数，适合长期稳定的任务执行。积压任务排队等待</td>
</tr>
<tr>
<td><strong>CachedThreadPool</strong></td>
<td>0</td>
<td>无限制</td>
<td>动态扩展线程，适合短期大量任务。60s 回收空闲位置</td>
</tr>
<tr>
<td><strong>SingleThreadExecutor</strong></td>
<td>1</td>
<td>1</td>
<td>单线程执行任务，保证顺序。</td>
</tr>
<tr>
<td><strong>ScheduledThreadPool</strong></td>
<td>固定数量</td>
<td>无限制</td>
<td>支持延迟和周期性任务调度。</td>
</tr>
<tr>
<td><strong>WorkStealingPool</strong></td>
<td>CPU 核心数</td>
<td>CPU 核心数</td>
<td>支持并行任务执行和任务窃取算法。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 固定大小线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 可缓存线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">// 单线程线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">// 定时任务线程池</span></span><br><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 定时任务</span></span><br><span class="line">pool.schedule(() -&gt; System.out.println(<span class="string">&quot;delay&quot;</span>), <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 周期任务</span></span><br><span class="line">pool.scheduleAtFixedRate(() -&gt; System.out.println(<span class="string">&quot;周期&quot;</span>), </span><br><span class="line">                         <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><h4 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h4><ul>
<li>**<code>execute()</code>**：只关注任务执行，不关注结果或异常处理。适合无需返回值的任务，只支持Runnable。</li>
<li>**<code>submit()</code>**：既关注任务执行，也关注结果和异常处理，适合需要返回结果的任务，除了Runnable 也支持 Callable，返回 Future，对其调用get()会阻塞当前任务。</li>
</ul>
<p><strong>最佳实践：</strong> 优先使用 **<code>submit()</code>**，即使不需结果，也可以捕获潜在异常，避免线程池异常崩溃。</p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ul>
<li><strong>使用<code>execute()</code>提交任务</strong>：当任务通过<code>execute()</code>提交到线程池并在执行过程中抛出异常时，如果这个异常没有在任务内被捕获，那么该异常会导致当前线程终止，并且异常会被打印到控制台或日志文件中。线程池会检测到这种线程终止，并创建一个新线程来替换它，从而保持配置的线程数不变。</li>
<li><strong>使用<code>submit()</code>提交任务</strong>：对于通过<code>submit()</code>提交的任务，如果在任务执行中发生异常，这个异常不会直接打印出来。相反，异常会被封装在由<code>submit()</code>返回的<code>Future</code>对象中。当调用<code>Future.get()</code>方法时，可以捕获到一个<code>ExecutionException</code>。在这种情况下，线程不会因为异常而终止，它会继续存在于线程池中，准备执行后续的任务。</li>
</ul>
<p>简单来说：使用<code>execute()</code>时，未捕获异常导致线程终止，线程池创建新线程替代；使用<code>submit()</code>时，异常被封装在<code>Future</code>中，线程继续复用。</p>
<p>这种设计允许<code>submit()</code>提供更灵活的错误处理机制，因为它允许调用者决定如何处理异常，而<code>execute()</code>则适用于那些不需要关注执行结果的场景。</p>
<h4 id="使用自定义线程池-ThreadPoolExecutor"><a href="#使用自定义线程池-ThreadPoolExecutor" class="headerlink" title="使用自定义线程池 ThreadPoolExecutor"></a><mark>使用自定义线程池 <code>ThreadPoolExecutor</code><mark></h4><p>**避免使用 <code>Executors</code> 创建线程池：推荐直接使用<code>ThreadPoolExecutor</code> 自定义线程池：因为 **<code>Executors</code> 默认队列为 <strong>无限队列</strong>，可能导致内存溢出。除了避免 OOM 的原因之外，不推荐使用 <code>Executors</code>提供快捷的线程池的原因：</p>
<ul>
<li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。<ul>
<li>CPU 密集型任务的 <code>WT/ST</code> 接近或者等于 0，因此， 线程数可以设置为 N（CPU 核心数）∗（1+0）= N，和我们上面说的 N（CPU 核心数）+1 差不多。</li>
<li>IO 密集型任务下，几乎全是线程等待时间，从理论上来说，你就可以将线程数设置为 2N（按道理来说，WT/ST 的结果应该比较大，这里选择 2N 的原因应该是为了避免创建过多线程吧）。</li>
</ul>
</li>
</ul>
<h5 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h5><p>建议实践中手动指定线程池配置，ThreadPoolExecutor的构造器共有七个参数：</p>
<ol>
<li><p><code>int corePoolSize</code>: 核心线程数     </p>
</li>
<li><p><code>int maxPoolSize</code>: 最大线程数</p>
</li>
<li><p><code>long keepAliveTime</code>: 非核心线程闲置的最长时间，超时销毁</p>
</li>
<li><p><code>TimeUnit unit</code>: 时间单位，枚举</p>
</li>
<li><p><code>BlockingQueue&lt;Runnable&gt; workQueue</code>: 保存任务的阻塞队列</p>
<ul>
<li><p>如果运行的线程数少于 corePoolSize，则执行器始终倾向于添加新线程而不是排队。</p>
</li>
<li><p>如果 corePoolSize 或更多线程正在运行，对请求进行排队而不是添加新线程。</p>
</li>
<li><p>如果请求无法排队，则会创建一个新线程，如果超出了 MaximumPoolSize，拒绝策略</p>
</li>
</ul>
</li>
</ol>
<ul>
<li><code>SynchronousQueue</code>不会保存任务，直接递交给线程，没有就创建，需要maxPoolSize很大，<code>CachedThreadPool</code> 就属于这种，创建无限个线程也会OOM。</li>
<li><code>LinkedBlockingQueue</code>为无界队列，默认最大容量为 <strong>Integer.MAX_VALUE</strong>，可能会导致任务积压 OOM，比如 Fixed 和 Single<ul>
<li>当所有 <code>corePoolSize</code> 线程都忙时，使用无界队列（例如没有预定义容量的 LinkedBlockingQueue）将导致新任务在队列中等待。</li>
<li>线程最多只有corePoolSize，maxSize没有影响。</li>
<li>当每个任务完全独立于其他任务时，这可能是合适的，因此任务不会影响彼此的执行；例如，在网页服务器中。虽然这种排队方式对于平滑请求的瞬态突发很有用，但它当命令平均到达速度继续快于处理速度时，可能发生OOM</li>
</ul>
</li>
<li><code>ArrayBlockingQueue</code>为有界队列，防止OOM：<ul>
<li>使用大队列和小池可以最大限度地减少 CPU 使用率、操作系统资源和上下文切换开销，但可能会导致人为降低吞吐量。</li>
<li>使用小队列通常需要更大的池，提高了 CPU 的利用率，但遇到不可接受的调度开销时也会降低吞吐量。</li>
</ul>
</li>
</ul>
<p><strong><u>Optional</u> Parameters</strong>：</p>
<ol start="5">
<li><code>ThreadFactory threadFactory</code>: 线程工厂，创建新线程，支持自定义线程名称等属性。</li>
</ol>
<ul>
<li>默认为 <code>Executors.defaultThreadFactory()</code> </li>
</ul>
<ol start="6">
<li><code>RejectedExecutionHandler handler</code>: 线程池满负荷(队列满且maxPoolSize)的拒绝策略</li>
</ol>
<ul>
<li><code>AbortPolicy</code>(default): 抛出<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/RejectedExecutionException.html"><code>RejectedExecutionException</code></a> 异常</li>
<li><code>CallerRunsPolicy</code>: 由提交任务的线程直接执行任务，防止任务丢失。这提供了一个简单的反馈控制机制，将减慢新任务提交的速度。</li>
<li><code>DiscardOldestPolicy</code>: 丢弃最旧未执行的任务，工作队列头部的任务将被删除，然后重试执行（可能会再次失败，导致重复执行）。这种策略很少被接受</li>
<li><code>DiscardPolicy</code>: 直接丢弃，不抛出任何异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">// 队列长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>线程池可以使用getter setter等方法进行参数的访问与更改</p>
</li>
<li><p>使用 Spring 内部线程池 ThreadPoolTaskExecutor 时，一定要手动自定义，合理配置参数，不然会出现生产问题（一个请求创建一个线程）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(name=&quot;threadPoolExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">threadPoolExecutor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">// 返回可用处理器的Java虚拟机的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">processNum</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors(); </span><br><span class="line">        <span class="type">int</span> <span class="variable">corePoolSize</span> <span class="operator">=</span> (<span class="type">int</span>) (processNum / (<span class="number">1</span> - <span class="number">0.2</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxPoolSize</span> <span class="operator">=</span> (<span class="type">int</span>) (processNum / (<span class="number">1</span> - <span class="number">0.5</span>));</span><br><span class="line">        threadPoolExecutor.setCorePoolSize(corePoolSize); <span class="comment">// 核心池大小</span></span><br><span class="line">        threadPoolExecutor.setMaxPoolSize(maxPoolSize); <span class="comment">// 最大线程数</span></span><br><span class="line">        threadPoolExecutor.setQueueCapacity(maxPoolSize * <span class="number">1000</span>); <span class="comment">// 队长</span></span><br><span class="line">        threadPoolExecutor.setThreadPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        threadPoolExecutor.setDaemon(<span class="literal">false</span>);</span><br><span class="line">        threadPoolExecutor.setKeepAliveSeconds(<span class="number">300</span>);<span class="comment">// 线程空闲时间</span></span><br><span class="line">        <span class="comment">// 线程名字前缀</span></span><br><span class="line">        threadPoolExecutor.setThreadNamePrefix(<span class="string">&quot;test-Executor-&quot;</span>); </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> threadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h5><ul>
<li><p>给线程池(实际上是ThreadFactory)命名，有助于定位问题。一般可以使用 Guava：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                        .setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>)</span><br><span class="line">                        .setDaemon(<span class="literal">true</span>).build();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize,</span><br><span class="line">  maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue,</span><br><span class="line"> threadFactory);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="适度复用"><a href="#适度复用" class="headerlink" title="适度复用"></a><strong>适度</strong>复用</h4><ul>
<li><p>要<mark>适当复用<mark>线程池，不要一个请求创建一个线程池，浪费资源且效率极低。</p>
</li>
<li><p>根据当前业务的情况对线程池进行配置，<mark>不同业务不要复用线程池<mark>：父任务占满线程池，导致子任务阻塞，但是父任务也同时被子任务阻塞，造成互相等待的死锁局面。</p>
</li>
</ul>
<h4 id="正确关闭"><a href="#正确关闭" class="headerlink" title="正确关闭"></a>正确关闭</h4><p>释放资源，shutdown(Now)不过只是异步通知，不会同步阻塞等待。</p>
<ul>
<li><strong><code>void shutdown()</code></strong> 有序关闭，执行完先前提交的任务。</li>
<li><strong><code>List&lt;Runnable&gt; shutdownNow()</code></strong> 停止所有正在执行的任务，停止正在等待的任务的处理，并返回正在等待执行的任务的列表。</li>
<li><code>awaitTermination</code> 同步阻塞等待</li>
<li>实现了autoclosable，close方法可以阻塞等待，因此trywithresource</li>
</ul>
<h4 id="不要和-JDK-自带-ThreadLocal-共用"><a href="#不要和-JDK-自带-ThreadLocal-共用" class="headerlink" title="不要和 JDK 自带 ThreadLocal 共用"></a>不要和 JDK 自带 ThreadLocal 共用</h4><p>这是因为线程池会复用线程对象，与线程对象绑定的类的静态属性 <code>ThreadLocal</code> 变量也会被重用，这就导致一个线程可能获取到其他线程的<code>ThreadLocal</code> 值。</p>
<h4 id="不要放入耗时任务"><a href="#不要放入耗时任务" class="headerlink" title="不要放入耗时任务"></a>不要放入耗时任务</h4><p>线程池本身的目的是为了提高任务执行效率，避免因频繁创建和销毁线程而带来的性能开销。如果将耗时任务提交到线程池中执行，可能会导致线程池中的线程被长时间占用，无法及时响应其他任务，甚至会导致线程池崩溃或者程序假死。这些任务可以采用异步 <code>CompletableFuture</code> 完成</p>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a><code>CompletableFuture</code></h2><p><code>Future</code> 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 <code>get()</code> 方法为阻塞调用。Java 8 才被引入<code>CompletableFuture</code> 类可以解决<code>Future</code> 的这些缺陷。<code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。对某些部分可以并行执行的异步任务支持比较好。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>runAsync</code></strong></td>
<td>执行无返回值异步任务。</td>
</tr>
<tr>
<td><strong><code>supplyAsync</code></strong></td>
<td>执行有返回值异步任务。</td>
</tr>
<tr>
<td><strong><code>thenApply</code></strong></td>
<td>转换结果并返回新的结果。</td>
</tr>
<tr>
<td><strong><code>thenAccept</code></strong></td>
<td>消费结果但不返回新结果。</td>
</tr>
<tr>
<td><strong><code>thenCombine</code></strong></td>
<td>合并两个任务的结果。</td>
</tr>
<tr>
<td><strong><code>allOf</code></strong> / <strong><code>anyOf</code></strong></td>
<td>等待所有任务完成 / 任意任务完成。</td>
</tr>
<tr>
<td><strong><code>exceptionally</code></strong> / <strong><code>handle</code></strong></td>
<td>处理异常并提供默认值或继续处理结果。</td>
</tr>
</tbody></table>
<p>以下是 <strong><code>CompletableFuture</code></strong> 的使用示例及详解：</p>
<h3 id="任务创建"><a href="#任务创建" class="headerlink" title="任务创建"></a>任务创建</h3><p><strong>创建异步任务：</strong><code>runAsync()</code><strong>：执行无返回值任务。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行异步任务：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;);</span><br><span class="line">future.join(); <span class="comment">// 等待任务执行完成</span></span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>join()</code>**：等待任务执行完成（类似 **<code>get()</code>**，但不会抛出 checked 异常）。</li>
</ul>
<p><strong>执行有返回值任务：</strong><code>supplyAsync()</code><strong>：执行有返回值任务。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;计算中...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;计算结果：&quot;</span> + future.join());</span><br></pre></td></tr></table></figure>

<h3 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h3><p><code>thenApply</code> - 对任务结果进行变换（同步执行）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span>)</span><br><span class="line">        .thenApply(result -&gt; result * <span class="number">2</span>); <span class="comment">// 结果翻倍</span></span><br><span class="line">System.out.println(future.join()); <span class="comment">// 输出 20</span></span><br></pre></td></tr></table></figure>

<p><code>thenAccept</code> - 消费结果，不返回新的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">        .thenAccept(result -&gt; System.out.println(<span class="string">&quot;结果: &quot;</span> + result));</span><br></pre></td></tr></table></figure>

<p><code>thenRun</code> - 不关心前一任务结果，直接执行下一步操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;任务完成&quot;</span>)</span><br><span class="line">        .thenRun(() -&gt; System.out.println(<span class="string">&quot;继续执行任务&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="组合多个任务"><a href="#组合多个任务" class="headerlink" title="组合多个任务"></a>组合多个任务</h3><p><code>thenCombine</code> - 合并两个任务结果，组合两个任务结果，并执行新任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span>);</span><br><span class="line">CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; result = future1.thenCombine(future2, (a, b) -&gt; a + b);</span><br><span class="line">System.out.println(<span class="string">&quot;结果: &quot;</span> + result.join()); <span class="comment">// 输出 30</span></span><br></pre></td></tr></table></figure>

<p><code>allOf</code> - 等待所有任务完成，但不返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;任务1&quot;</span>)),</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;任务2&quot;</span>)),</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;任务3&quot;</span>))</span><br><span class="line">);</span><br><span class="line">all.join(); <span class="comment">// 等待所有任务完成</span></span><br></pre></td></tr></table></figure>

<p><code>anyOf</code> - 任意任务完成即结束，返回第一个任务的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Object&gt; any = CompletableFuture.anyOf(</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;任务1&quot;</span>),</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;任务2&quot;</span>),</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;任务3&quot;</span>)</span><br><span class="line">);</span><br><span class="line">System.out.println(<span class="string">&quot;最快完成的任务: &quot;</span> + any.join());</span><br></pre></td></tr></table></figure>

<h3 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h3><p><code>exceptionally</code> - 捕获异常并返回默认值，继续执行任务链。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;任务异常&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;捕获异常: &quot;</span> + ex.getMessage());</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 返回默认值</span></span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;结果: &quot;</span> + future.join()); <span class="comment">// 输出 -1</span></span><br></pre></td></tr></table></figure>

<p><code>handle</code>- 捕获异常并处理结果,同时处理正常结果和异常情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;计算出错&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;).handle((result, ex) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理异常: &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 返回默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;最终结果: &quot;</span> + future.join());</span><br></pre></td></tr></table></figure>

<h3 id="线程池自定义"><a href="#线程池自定义" class="headerlink" title="线程池自定义"></a>线程池自定义</h3><p>指定线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;自定义线程池: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;, executor).join();</span><br><span class="line"></span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>

<p>**异步任务默认使用 **<code>ForkJoinPool.commonPool()</code>，但可以自定义线程池以控制资源。</p>
<h3 id="例：批量任务处理"><a href="#例：批量任务处理" class="headerlink" title="例：批量任务处理"></a>例：批量任务处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;CompletableFuture&lt;Integer&gt;&gt; futures = IntStream.range(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">        .mapToObj(i -&gt; CompletableFuture.supplyAsync(() -&gt; i * <span class="number">2</span>))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; allDone = CompletableFuture.allOf(</span><br><span class="line">        futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>])</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">allDone.join();</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; results = futures.stream()</span><br><span class="line">        .map(CompletableFuture::join)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;所有结果: &quot;</span> + results);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <strong><code>allOf()</code></strong> 确保所有任务完成。</li>
<li>收集各任务结果并返回。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有结果: [2, 4, 6, 8, 10]</span><br></pre></td></tr></table></figure>

<h3 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/virtual-thread.html">虚拟线程</a></h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/11/20/juc-thread-in-one/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/20/juc-thread-in-one/" class="post-title-link" itemprop="url">java.lang.Thread</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-20T00:00:00+08:00">2024-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:16:31" itemprop="dateModified" datetime="2025-05-05T11:16:31+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/juc/" itemprop="url" rel="index"><span itemprop="name">juc</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="线程概念相关"><a href="#线程概念相关" class="headerlink" title="线程概念相关"></a>线程概念相关</h2><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119185155274-1735313112574-111.png" alt="image-20241119185155274"></p>
<p><strong>Parallel Unit 并行最小单位</strong></p>
<ul>
<li>拥有自己的上下文</li>
<li>拥有调用堆栈</li>
<li>有自己的 PC</li>
<li>但是内存和同一个进程的其他线程共享（SHARED），发生竞态条件（RACE CONDITION）</li>
</ul>
<h4 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h4><p>操作系统对执行中程序的一种抽象</p>
<p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p>
<p>每个程序都有自己的进程，互不干扰。即使它们都是同一份代码，但各自播放的内容和进度都可以不同。进程（可以看成只有一个线程的进程）同时只能做一件事，如果将一个进程分成多个线程，这样就不会浪费时间空等了进程间是完全独立的，互不干扰。而线程则共享同一个进程的资源，所以线程间交换数据更方便，几乎没有通讯损耗。但进程间交换数据就麻烦多了，得通过一些通讯机制，比如管道、消息队列之类的（Inter-Process Communication）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119184759519.png" alt="image-20241119184759519"></p>
<h4 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a>Coroutine</h4><p>线程在执行加载视频片段时，必须等待结果返回才能再次执行解码操作，如果引入多线程：加载本身是IO行为，CPU在等待结果返回期间几乎是在空等，浪费了CPU资源。当然，你可以让它休眠以释放 CPU 时间，但创建线程本身就有开销，线程切换同样有开销。</p>
<p>相比之下，协程（Coroutine）非常轻量，创建和切换的开销极小——它并非操作系统层面的东西，就不涉及内核调度。一般是由编程语言来实现（比如 Python 的 asyncio 标准库），它属于用户态的东西。</p>
<p>资源共享问题：线程的执行时机由操作系统调度，程序员无法控制，这正是多线程容易出现资源覆盖的主要原因。而协程的执行时机由程序自身控制，不受操作系统调度影响，因此可以完全避免这类问题。同一个线程内的多个协程共享同一个线程的 CPU 时间片资源，它们在 CPU 上的执行是有先后顺序的，不能并行执行。而线程是可以并行执行的</p>
<p>协程（coroutine），其实是一种特殊的子程序（subroutine，比如普通函数）。普通函数一旦执行就会从头到尾运行，然后返回结果，中间不会暂停。而协程则可以在执行到一半时暂停。利用这一特性，我们可以在遇到 I/O 这类不消耗 CPU 资源的操作时，将其挂起，继续执行其他计算任务，充分利用 CPU 资源。等 I/O 操作结果返回时，再恢复执行。在一个线程内并发执行多个任务</p>
<h3 id="为什么要有多线程？"><a href="#为什么要有多线程？" class="headerlink" title="为什么要有多线程？"></a>为什么要有多线程？</h3><p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代</strong>：在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li>
<li><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 核心上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）</li>
</ul>
<h3 id="多线程效率一定高吗？"><a href="#多线程效率一定高吗？" class="headerlink" title="多线程效率一定高吗？"></a>多线程效率一定高吗？</h3><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><p>众所周知，CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:</p>
<ul>
<li>CPU 增加了 Cache，以均衡与内存的速度差异，导致 <code>可见性</code>问题</li>
<li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异，导致 <code>原子性</code>问题</li>
<li>编译程序优化指令执行次序，使得 Cache 能够得到更加合理地利用，导致 <code>有序性</code>问题</li>
</ul>
<h4 id="单核-CPU-多线程"><a href="#单核-CPU-多线程" class="headerlink" title="单核 CPU 多线程"></a>单核 CPU 多线程</h4><p>对于 IO 密集型，效率明显提高，因为线程切换带来的收益可以抵消代价</p>
<p>对于计算密集型，频繁的上下文切换开销很大</p>
<h3 id="易混淆"><a href="#易混淆" class="headerlink" title="易混淆"></a>易混淆</h3><h4 id="并发-并行"><a href="#并发-并行" class="headerlink" title="并发/并行"></a>并发/并行</h4><ul>
<li>运行的程序就是一个独立的进程</li>
<li><strong>并发</strong>：CPU轮询执行每个线程，切换速度快，感觉线程在同时和执行，这就是<strong>并发</strong></li>
<li><strong>并行</strong>：同一时刻有多个线程在被CPU调度执行</li>
</ul>
<h4 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h4><ul>
<li><strong>同步</strong>：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li>
<li><strong>异步</strong>：调用在发出之后，不用等待返回结果，该调用直接返回。</li>
</ul>
<h2 id="Java-线程和-OS-线程"><a href="#Java-线程和-OS-线程" class="headerlink" title="Java 线程和 OS 线程"></a>Java 线程和 OS 线程</h2><p>JDK 1.2 之前，Java 线程是基于绿色线程（Green Threads）实现的，这是一种用户级线程（用户线程），也就是说 JVM 自己模拟了多线程的运行，而不依赖于操作系统。由于绿色线程和原生线程比起来在使用时有一些限制（比如绿色线程不能直接使用操作系统提供的功能如异步 I/O、只能在一个内核线程上运行无法利用多核），在 JDK 1.2 及以后，Java 线程改为基于原生线程（Native Threads）实现，也就是说 JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。</p>
<p>我们上面提到了用户线程和内核线程，考虑到很多读者不太了解二者的区别，这里简单介绍一下：</p>
<ul>
<li>用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。</li>
<li>内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。</li>
</ul>
<p>顺便简单总结一下用户线程和内核线程的区别和特点：用户线程创建和切换成本低，但不可以利用多核。内核态线程，创建和切换成本高，可以利用多核。</p>
<p>一句话概括 Java 线程和操作系统线程的关系：<strong>现在的 Java 线程的本质其实就是操作系统的线程</strong>。</p>
<p>线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有这三种：</p>
<ol>
<li>一对一（一个用户线程对应一个内核线程）</li>
<li>多对一（多个用户线程映射到一个内核线程）</li>
<li>多对多（多个用户线程映射到多个内核线程）</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/three-types-of-thread-models.png" alt="常见的三种线程模型"></p>
<p>在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个 Java 线程对应一个系统内核线程。Solaris 系统是一个特例（Solaris 系统本身就支持多对多的线程模型），HotSpot VM 在 Solaris 上支持多对多和一对一。</p>
<h2 id="线程创建、运行、中断"><a href="#线程创建、运行、中断" class="headerlink" title="线程创建、运行、中断"></a>线程创建、运行、中断</h2><h3 id="三种-Thread-构造器"><a href="#三种-Thread-构造器" class="headerlink" title="三种 Thread 构造器"></a>三种 Thread 构造器</h3><p><strong><mark>继承 Thread 抽象类<mark></strong></p>
<ol>
<li>创建<strong>子类</strong>继承Thread类，重写 run 方法</li>
<li>创建子类对象<code>Thread t = new MyThread()</code></li>
<li><code>t.start()</code> </li>
</ol>
<ul>
<li>编码简单，不能继承其他类</li>
<li>不要把主线程任务放在启动子线程之前</li>
<li>必须调用start方法，调用run方法还是会顺序执行，先启动，启动后会自动调用</li>
<li>不能返回执行结果</li>
</ul>
<p><strong><mark>实现 Runnable 接口 任务对象<mark></strong></p>
<ol>
<li>自己创建一个类实现Runnable接口，重写run方法</li>
<li>创建任务对象<code>Runnable target = new MyRunnable()</code></li>
<li>创建线程对象<code>new Thread(target)</code></li>
<li>调用线程对象的start方法</li>
</ol>
<ul>
<li>只是实现接口，可以继承其他的类，实现其他接口，扩展性强</li>
<li>不能返回执行结果</li>
</ul>
<p>匿名内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create an annoymous inner class object</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		...;</span><br><span class="line">        ...;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(target).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lambda expression</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>( ()-&gt;&#123;</span><br><span class="line">    ...;</span><br><span class="line">    ...;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p><strong><mark>实现 Callable 接口<mark></strong></p>
<ol>
<li>定义类实现<code>Callable&lt;&gt;</code>，重写call方法，封装要做的事情和返回的数据。<code>Callable</code>后边的泛型就是返回的数据类型</li>
<li>创建<code>Callable</code>对象，把他封装成<code>FutureTask&lt;String&gt;(Callable&lt;String&gt; callable)</code> 对象，泛型要相同</li>
<li><code>FutureTask</code>实现了<code>Runnable</code>接口，是任务对象</li>
<li>在线程执行完毕之后，对<code>FutureTask</code>对象调用<code>get</code>方法获取线程执行结果。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;String&gt; callable = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">10</span>); <span class="comment">//创建 Callable对象</span></span><br><span class="line"></span><br><span class="line">FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable); <span class="comment">//用Callable对象 创建 任务对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start(); <span class="comment">//用任务对象 创建 线程对象 并启动</span></span><br><span class="line"></span><br><span class="line">System.out.println(futureTask.get());<span class="comment">//获取返回值</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	如果执行到get()线程还未执行完毕</span></span><br><span class="line"><span class="comment">*	代码会暂停，等待执行完毕才获取结果</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以获取返回值，扩展性强</li>
<li>编码复杂一些</li>
</ul>
<h3 id="thread-start"><a href="#thread-start" class="headerlink" title="thread.start()"></a><code>thread.start()</code></h3><p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了 Runnable 状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
<p>在别的平台，比如 C/C++ ，线程创建即运行</p>
<h3 id="thread-interrupt"><a href="#thread-interrupt" class="headerlink" title="thread.interrupt()"></a><code>thread.interrupt()</code></h3><p>如果异常没有被捕获该线程将会停止执行。</p>
<ol>
<li>Java 通过 <strong><code>interrupt()</code></strong> 发出线程中断信号，<strong>不会强制停止线程</strong>，而是依靠线程自行检查并响应。</li>
<li>使用 <strong><code>isInterrupted()</code></strong> 查询中断状态，或 <strong><code>interrupted()</code></strong> 查询并重置状态。</li>
<li>在阻塞操作中，抛出 <strong><code>InterruptedException</code></strong> 时需恢复中断标志位并及时退出。</li>
<li>遵循协作式终止原则，确保线程安全和资源正确释放。</li>
</ol>
<p><strong>推荐方式：</strong></p>
<ul>
<li>在关键任务中轮询中断状态。</li>
<li>在阻塞状态下捕获异常并优雅退出线程。</li>
</ul>
<p><strong>如何处理中断</strong>？</p>
<ol>
<li><strong>响应中断标志位</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务执行中...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;检测到中断，退出线程！&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>2. 捕获异常并退出</strong></p>
<p>在阻塞状态下（如 <code>sleep()</code>、<code>wait()</code>、<code>join()</code> 等方法），线程会抛出 <strong><code>InterruptedException</code><strong>，此时中断标志位会被</strong>自动清除</strong>。示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程被中断！&quot;</span>);</span><br><span class="line">    Thread.currentThread().interrupt(); <span class="comment">// 恢复中断标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么中断不能强制终止线程</strong>？</p>
<p>Java 提倡线程的<strong>协作式终止</strong>，而不是<strong>强制终止</strong>（如 <code>Thread.stop()</code> 已被废弃）。原因包括：</p>
<ol>
<li><strong>强制终止会导致资源泄漏：</strong> 线程可能在持有锁或打开文件等资源时被突然终止，导致资源无法正常释放。</li>
<li><strong>不安全的状态：</strong> 数据可能处于不一致状态，从而引发数据损坏。</li>
<li><strong>可控性低：</strong> 开发者无法自行控制线程的退出逻辑。</li>
</ol>
<h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918105642868-1726751033487-52-1735555863361-53.png" alt="image-20240918105642868"></p>
<h2 id="Thread-常用方法"><a href="#Thread-常用方法" class="headerlink" title="Thread 常用方法"></a>Thread 常用方法</h2><p>  <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917203637026-1726751033487-46.png" alt="image-20240917203637026"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917203429253-1726751033487-47.png" alt="image-20240917203429253"></p>
<ul>
<li><strong><code>start()</code></strong>: 线程转为 Runnable 可运行状态，相当于 <code>pthread_create()</code></li>
<li><strong><code>run()</code></strong>: 线程应该执行的方法，相当于 <code>pthread_create()</code> 传的函数指针</li>
<li><strong><code>sleep(long millis)</code></strong>: 调用者睡眠一段时间</li>
<li><strong><code>join()</code></strong>: 父线程等待子线程执行完毕再继续执行</li>
<li><strong><code>interrupt()</code></strong>: 使线程中断</li>
<li><code>currentThread()</code>: 获取当前执行的线程对象</li>
<li><code>get/setName()</code>: 获取线程名称</li>
<li><code>yield()</code>: 声明当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。只是对线程调度器的一个建议，只是建议具有相同优先级的其它线程可以运行。只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。</li>
<li><code>setDaemon()</code>: 将一个线程设置为守护线程。当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。main() 属于非守护线程。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/640-1735555856683-51.png" alt="Java 线程状态变迁图"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918105918176-1726751033487-54.png" alt="image-20240918105918176"></p>
<h2 id="线程安全问题-1"><a href="#线程安全问题-1" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p>
<p>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadUnsafeExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">ThreadUnsafeExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadUnsafeExample</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadSize);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --- 997 // 结果总是小于1000</span></span><br></pre></td></tr></table></figure>

<p>多个线程，同时修改同一个共享资源，可能出现业务安全问题 <a href="jetbrains://idea/navigate/reference?project=MyFirstProject&fqn=com.it.threadtest.BankSimulator">Banksim</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917205938036-1726751033487-48.png" alt="image-20240917205938036"></p>
<p>又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：如果你的代码 在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。 这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p>
<h3 id="不可变-Immutable"><a href="#不可变-Immutable" class="headerlink" title="不可变 Immutable"></a>不可变 Immutable</h3><p>final 关键字修饰的基本数据类型，枚举类型，Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。任何一个线程都改变不了它们的值，要改变除 非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p>
<h3 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h3><p>不管运行时环境如何，调用者都不需要任何额外的同步措施。</p>
<h3 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h3><p>相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。也就是我们通常意义上所说的线程安全</p>
<p>ConcurrentHashMap, Vector, HashTable, StringBuffer</p>
<p>像 <strong>Vector</strong> 这种，add、remove方法都是原子 操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个 Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。HashTable也同理。StringBuffer 自带缓冲区，线程安全，性能较低。</p>
<p><mark>ConcurrentHashMap<mark> 的复合操作：<code>if(map.containsKey(x)) map.put(x,1);</code> 不能保证原子性，需要使用内置的原子操作方法，如 <code>putIfAbsent()</code>。另外批量操作也不一定线程安全</p>
<h3 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h3><p>ArrayList、LinkedList、HashMap等都是线程非安全的类 StringBuilder也不安全。完全不安全</p>
<h2 id="线程互斥同步-Mutex-Synchronization"><a href="#线程互斥同步-Mutex-Synchronization" class="headerlink" title="线程互斥同步(Mutex Synchronization)"></a>线程互斥同步(Mutex Synchronization)</h2><h3 id="悲观、乐观锁"><a href="#悲观、乐观锁" class="headerlink" title="悲观、乐观锁"></a>悲观、乐观锁</h3><p><strong>乐观锁</strong>：CAS算法，共享资源修改之后跟修改之前做对比，如果一样就确认修改，不一样就作废，重新进行修改</p>
<p>主线程里调用子线程的join方法，表示主线程等待次线程执行完毕，再继续执行<a href="jetbrains://idea/navigate/reference?project=MyFirstProject&fqn=com.it.threadtest.GiftSender">赠送礼物案例</a> </p>
<p><strong>悲观锁</strong>：直接把核心代码锁住，只要线程开始执行就加锁，线程安全,但并发性能差</p>
<p>t1和t2两个子线程同时启动，调用start方法，t1，t2进入就绪状态，何时启动，启动顺序由调度器决定，启动以后，main,t1,t2各自执行互不影响，此时如果在子线程的start语句后调用子线程的join方法，t1.join表示主线程要在这一步暂停，直到t1执行完毕，但是t2不会受到任何影响，当t1执行完毕之后，再调用t2.join等待t2执行完毕，可能在t1执行完之前t2就完了，所以有时候t2不join也不会影响结果，但是最好还是加上</p>
<p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。解决线程安全问题的方案，让多个线程先后依次访问共享资源</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><code>synchronized</code></h3><h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><ul>
<li>作用：把访问共享资源的核心代码上锁，保证线程安全</li>
<li>原理：每次只允许一个线程加锁以后进入，执行完毕自动解锁，其他线程才能进来执行。</li>
<li>同步锁必须是同一个锁对象。</li>
</ul>
<p>关键字 <code>synchronized</code> 后边括号里是锁对象，<mark>必须保证是同一个<mark>，最简单的方法就是唯一的 字符串常量池。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917214332757-1726751033487-49.png" alt="image-20240917214332757"></p>
<p>不同类或模块中不相关的代码会因为使用相同的字符串常量作为锁而相互干扰，你取钱关我什么事？我的账号我为什么不能取！搜易</p>
<p><code>synchronized(this)</code> 实例方法，锁对象代表正在操作的共享资源</p>
<p>静态方法：<code>synchronized(Account.class)</code> </p>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p><code>public synchronized int steal()</code></p>
<p>实例方法就是用this作为锁，静态方法的锁：类名.class</p>
<p>web应用的业务层对象service通常是同一个（spring容器的单例）</p>
<p>如果多个线程都要调用service对象的synchronized方法，此时线程A拿到了this对象开始执行方法，其他线程只能阻塞等待A执行完毕释放this对象锁才可继续执行。</p>
<p>锁必须是不同的线程都能访问到的对象，比如字符串常量，比如this</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><code>ReentrantLock</code></h3><p><code>final Lock lk = new ReentrantLock();</code> 声明在共享资源的成员变量，</p>
<p><code>lk.lock()</code> <code>lk.unlock()</code></p>
<ul>
<li>final 关键字 不能修改锁</li>
<li>加锁之后，执行核心代码的时候如果遇到异常，后面程序无法执行，就变成了死锁，所以用 <code>try-catch-finally</code></li>
</ul>
<h3 id="which-one"><a href="#which-one" class="headerlink" title="which one?"></a>which one?</h3><p><strong>比较</strong></p>
<p><strong>1. 锁的实现</strong></p>
<p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p>
<p><strong>2. 性能</strong></p>
<p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p>
<p><strong>3. 等待可中断</strong></p>
<p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p>
<p>ReentrantLock 可中断，而 synchronized 不行。</p>
<p><strong>4. 公平锁</strong></p>
<p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p>
<p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p>
<p><strong>5. 锁绑定多个条件</strong></p>
<p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p>
<p><strong>使用选择</strong></p>
<p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><ul>
<li><p>Hold and wait:  一个进程因请求资源而阻塞时，对以获得的资源保持不放。</p>
<ul>
<li>原子性抢锁, 把要抢的锁集中到一起,一块抢了</li>
</ul>
</li>
<li><p>No preemption: 进程已获得的资源，在使用完毕之前，不能被强行抢走。</p>
<ul>
<li><code>a.lock()</code>-&gt;<code>if(!b.tryLock()) then a.unlock()</code> </li>
<li>如果 b tryLock 失败就会被抢走。</li>
<li>Issue: Livelock</li>
</ul>
</li>
<li><p>Circular wait: </p>
<ul>
<li>fixed order</li>
</ul>
</li>
<li><p>Mutual exclusion: </p>
<ul>
<li>Lock-free CAS</li>
</ul>
</li>
</ul>
<h2 id="线程通信-Inter-Thread-Communication"><a href="#线程通信-Inter-Thread-Communication" class="headerlink" title="线程通信(Inter-Thread Communication)"></a>线程通信(Inter-Thread Communication)</h2><p>可以通过共享变量的方式实现线程间的通讯和协作：volatile、while 轮询</p>
<p>同时可以使用下面线程消息传递机制：</p>
<h3 id="thread-join"><a href="#thread-join" class="headerlink" title="thread.join()"></a><code>thread.join()</code></h3><p><strong><mark>join()<mark></strong></p>
<p>join 在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p>
<p>线程之间互相告知对方自己的状态，相互协调。<strong>避免无效资源争夺</strong> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917222622519-1726751033487-50.png" alt="image-20240917222622519"></p>
<h3 id="object-wait"><a href="#object-wait" class="headerlink" title="object.wait()"></a><code>object.wait()</code></h3><p><strong><mark>wait() notify() notifyAll()<mark></strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917224325687-1726751033487-51.png" alt="image-20240917224325687"></p>
<p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。它们都属于 Object 的一部分，而不属于 Thread。</p>
<p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception。</p>
<p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。上述方法应该使用当前同步锁对象进行调用，只有锁知道当前占用自己的是哪个线程</p>
<p>先notifyAll 后wait   </p>
<p>先wait 后notifyAll 当前线程等待，notifyAll又再次唤醒了自己</p>
<p>底层逻辑：如果没有通信机制，就会出现无效的资源争夺，我做好了包子，我就应该通知你们所有人，我的工作做完了，你们可以开始你们的工作了，不然我会一直占用桌子但是又做不了包子，你们想吃包子的也因为桌子被占用而吃不上，导致厨师和吃货之间没有必要的资源挤兑与争抢。</p>
<h4 id="wait-与-sleep"><a href="#wait-与-sleep" class="headerlink" title="wait() 与 sleep()"></a><code>wait()</code> 与 <code>sleep()</code></h4><p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p>
<p>类似的问题：<strong>为什么 <code>sleep()</code> 方法定义在 <code>Thread</code> 中？</strong> </p>
<p>因为 <code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p>
<p><strong>区别</strong>：</p>
<ul>
<li><strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</li>
<li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code>通常被用于暂停执行。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
<li><code>sleep()</code> 是 <code>Thread</code> 类的静态native方法，<code>wait()</code> 则是 <code>Object</code> 类的native方法。</li>
</ul>
<h3 id="condition-await"><a href="#condition-await" class="headerlink" title="condition.await()"></a><code>condition.await()</code></h3><p><mark><strong>await() signal() signalAll()</strong><mark></p>
<p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p>
<p>使用 Lock 来获取一个 Condition 对象。</p>
<h3 id="Producer-Consumer"><a href="#Producer-Consumer" class="headerlink" title="Producer/Consumer"></a>Producer/Consumer</h3><p><strong>生产者-消费者模式</strong>（Producer-Consumer Pattern）是一种常见的多线程设计模式，通常用于解决<strong>不同速率的线程之间如何协调工作</strong>的问题。它的主要目标是将“<strong>生产数据</strong>”和“<strong>消费数据</strong>”的任务解耦，使用一个共享的缓冲区（通常是队列）来协调生产者和消费者的工作。 </p>
<p><mark>模式概述<mark></p>
<ol>
<li><strong>生产者（Producer）</strong>：负责生成数据，并将数据放入缓冲区或队列中。生产者线程的工作是“生产”，即产生新数据。</li>
<li><strong>消费者（Consumer）</strong>：负责从缓冲区中获取数据并进行处理。消费者线程的工作是“消费”，即处理已经由生产者产生的数据。</li>
<li><strong>共享缓冲区</strong>：生产者和消费者通过共享一个缓冲区（通常是一个线程安全的队列）进行数据传递。生产者将数据放入缓冲区，消费者从缓冲区中取出数据。</li>
</ol>
<p>在该模式下，生产者和消费者可以独立运行，而不需要直接相互依赖。两者通过共享缓冲区进行<strong>松耦合的通信</strong>。</p>
<p><mark>关键问题<mark></p>
<p>生产者和消费者的工作速率可能不同：</p>
<ul>
<li>如果生产者比消费者快，消费者可能一时无法处理所有的数据，导致缓冲区满。</li>
<li>如果消费者比生产者快，消费者可能没有数据可消费，导致缓冲区空。</li>
</ul>
<p>因此，需要有一种机制来处理这两种情况：</p>
<ul>
<li><strong>缓冲区满时</strong>：生产者应该等待，直到有空间可以继续生产数据。</li>
<li><strong>缓冲区空时</strong>：消费者应该等待，直到有数据可以消费。</li>
</ul>
<p>如果在生产者-消费者模式中没有合适的<strong>等待机制</strong>，而生产者和消费者直接对缓冲区进行操作，那么可能会出现以下问题：</p>
<ol>
<li><strong>缓冲区满时的情况</strong></li>
</ol>
<p>当缓冲区已经满了，<strong>生产者</strong>线程如果继续向缓冲区添加数据，而没有等待机制，可能会出现以下两种情况：</p>
<ul>
<li><strong>覆盖数据</strong>：如果没有检查缓冲区是否已满，生产者可能会继续向缓冲区写入数据，从而覆盖掉之前的数据，导致丢失尚未被消费者读取的数据。</li>
<li><strong>抛出异常</strong>：在某些实现中，尝试向满的缓冲区写入数据可能会抛出异常，程序会因为未处理该异常而崩溃或出现不可预测的行为。</li>
</ul>
<p>示例：没有等待机制的生产者向满缓冲区添加数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoWaitBufferFull</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] buffer = <span class="keyword">new</span> <span class="title class_">int</span>[CAPACITY];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 简单模拟生产者行为</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count == CAPACITY) &#123;</span><br><span class="line">                    <span class="comment">// 缓冲区已满，没有等待机制，可能出现问题</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Buffer is full! Data may be lost or overwritten.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                buffer[count % CAPACITY] = count; <span class="comment">// 可能覆盖数据</span></span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(<span class="string">&quot;Produced: &quot;</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题：</strong></p>
<ul>
<li>在没有等待机制的情况下，生产者线程一旦缓冲区满了，就会继续写入新数据，覆盖掉尚未被消费者读取的数据，从而丢失数据。</li>
</ul>
<ol start="2">
<li><strong>缓冲区空时的情况</strong></li>
</ol>
<p>当缓冲区为空，<strong>消费者</strong>线程如果继续尝试从缓冲区读取数据，而没有等待机制，可能会出现以下问题：</p>
<ul>
<li><strong>读取无效数据</strong>：消费者从空的缓冲区读取到无效的或未初始化的数据，导致消费错误。</li>
<li><strong>抛出异常</strong>：如果没有等待机制，当消费者试图从空的缓冲区获取数据时，可能会抛出空指针异常或数组越界异常，导致程序崩溃。</li>
</ul>
<p>示例：没有等待机制的消费者从空缓冲区读取数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoWaitBufferEmpty</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] buffer = <span class="keyword">new</span> <span class="title class_">int</span>[CAPACITY];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 简单模拟消费者行为</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 缓冲区为空，没有等待机制，可能出现问题</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Buffer is empty! Consumer may read invalid data.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> buffer[(count - <span class="number">1</span>) % CAPACITY]; <span class="comment">// 可能读取到无效数据</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Consumed: &quot;</span> + data);</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题：</strong></p>
<ul>
<li>如果消费者在缓冲区为空时继续尝试读取，可能会读到无效的数据，或者抛出异常。</li>
</ul>
<ol start="3">
<li><strong>竞态条件（Race Condition）</strong></li>
</ol>
<p>没有等待机制的生产者和消费者可能会产生竞争条件，导致<strong>数据一致性问题</strong>。</p>
<ul>
<li><strong>生产者和消费者竞争访问缓冲区</strong>：生产者在写入数据时，消费者同时读取缓冲区，可能导致消费者读取到部分更新的数据，或者读取到不完整的数据。</li>
<li><strong>缓冲区状态不一致</strong>：由于生产者和消费者缺乏同步，缓冲区的状态可能变得不可预测，例如在消费者从空缓冲区读取数据时，生产者已经开始写入数据，导致状态错乱。</li>
</ul>
<p>正确的等待机制</p>
<p>为了避免上述问题，生产者和消费者应该使用合适的<strong>等待和唤醒机制</strong>，例如：</p>
<ul>
<li><strong>使用阻塞队列（BlockingQueue）</strong>：自动处理缓冲区满和空的情况。</li>
<li>**使用 <code>wait()</code> 和 <code>notify()</code>**：手动实现线程间的等待和通知。</li>
</ul>
<p>这些机制可以保证：</p>
<ul>
<li>当缓冲区满时，生产者会自动等待，直到消费者消费了一些数据并腾出空间。</li>
<li>当缓冲区为空时，消费者会自动等待，直到生产者产生新的数据。</li>
</ul>
<p>总结</p>
<p>如果没有等待机制：</p>
<ul>
<li><strong>缓冲区满时</strong>，生产者可能会覆盖数据或抛出异常。</li>
<li><strong>缓冲区空时</strong>，消费者可能会读取到无效数据或抛出异常。</li>
<li><strong>竞态条件</strong>会导致数据不一致和程序异常行为。</li>
</ul>
<p>等待机制可以确保生产者和消费者之间的正确同步，保证数据的完整性和线程安全性。</p>
<p>示例代码：使用 `BlockingQueue</p>
<p><code>BlockingQueue</code> 是 Java 并发包中的线程安全队列，当队列为空时，消费者会阻塞等待；当队列满时，生产者会阻塞等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 缓冲区容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(CAPACITY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Producing: &quot;</span> + value);</span><br><span class="line">                    queue.put(value); <span class="comment">// 队列满时生产者阻塞</span></span><br><span class="line">                    value++;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟生产耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> queue.take(); <span class="comment">// 队列空时消费者阻塞</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Consuming: &quot;</span> + value);</span><br><span class="line">                    Thread.sleep(<span class="number">1500</span>); <span class="comment">// 模拟消费耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码解释</p>
<ul>
<li>**<code>ArrayBlockingQueue</code>**：这是一个固定容量的阻塞队列，容量为 5。</li>
<li><strong>生产者线程</strong>：生产一个整数，将其放入队列中。如果队列满了，<code>put()</code> 方法会阻塞，直到队列有空余位置。</li>
<li><strong>消费者线程</strong>：从队列中取出一个整数进行消费。如果队列为空，<code>take()</code> 方法会阻塞，直到有数据可以消费。</li>
<li>生产者每秒生产一个数据，消费者每 1.5 秒消费一个数据，因此队列会周期性地满和空。</li>
</ul>
<p>运行结果（部分）：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Producing: 0</span></span><br><span class="line"><span class="section">Consuming: 0</span></span><br><span class="line"><span class="section">Producing: 1</span></span><br><span class="line"><span class="section">Producing: 2</span></span><br><span class="line"><span class="section">Consuming: 1</span></span><br><span class="line"><span class="section">Producing: 3</span></span><br><span class="line"><span class="section">Producing: 4</span></span><br><span class="line"><span class="section">Producing: 5</span></span><br><span class="line"><span class="section">Consuming: 2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>实现的核心优势：</p>
<ul>
<li><strong>线程安全</strong>：<code>BlockingQueue</code> 是线程安全的，它自动管理生产者和消费者之间的同步操作。</li>
<li><strong>自动阻塞与唤醒</strong>：<code>BlockingQueue</code> 的 <code>put()</code> 和 <code>take()</code> 方法在队列满或空时自动阻塞生产者或消费者线程，不需要手动使用 <code>wait()</code> 和 <code>notify()</code> 。</li>
<li><strong>简单的并发控制</strong>：相比于自己手动编写锁和条件变量，<code>BlockingQueue</code> 使得生产者-消费者模式的实现更加简洁和可靠。</li>
</ul>
<p>使用场景</p>
<p>生产者-消费者模式广泛用于以下场景：</p>
<ul>
<li><strong>多线程任务处理</strong>：例如在消息队列中，生产者产生消息并存放到队列中，消费者从队列中读取并处理消息。</li>
<li><strong>流式数据处理</strong>：例如网络服务器中，生产者线程从网络中读取数据，消费者线程对数据进行处理。</li>
<li><strong>异步任务队列</strong>：后台线程不断产生任务，工作线程从任务队列中取出任务并执行。</li>
</ul>
<p>总结</p>
<p>生产者-消费者模式通过解耦生产和消费的过程，提高了系统的<strong>并发性</strong>和<strong>响应速度</strong>，并通过使用共享的缓冲区，确保了线程之间的协调和通信。在 Java 中，通过 <code>BlockingQueue</code> 等并发工具，可以非常简便地实现这一模式。</p>
<p>为了更好地理解生产者-消费者模式中缓冲区满、空以及等待机制的问题，可以通过几个生活中的例子来形象化解释。</p>
<p><mark>案例1：餐厅的厨房和服务员<mark></p>
<p><strong>背景</strong>：我们把餐厅的厨房比作生产者，把服务员比作消费者，而“出菜窗口”就是缓冲区。厨师不断做菜（生产者），然后把做好的菜放到窗口。服务员从窗口取菜并送到顾客桌上（消费者）。窗口有固定的空间（比如只能放5盘菜）。</p>
<p>情况一：<strong>没有等待机制，缓冲区满</strong> </p>
<p>假设窗口只能放5盘菜，但没有任何规则限制厨房什么时候该停止做菜。</p>
<ul>
<li><strong>缓冲区满的情况</strong>：当窗口已经放满了5盘菜时，厨师继续做菜并将新菜强行放到窗口，结果是已经在窗口的菜被挤掉了（覆盖数据），导致有些菜从来没有被服务员送出去（数据丢失）。</li>
<li><strong>没有等待的后果</strong>：这样会让顾客拿不到部分菜，而厨师和服务员也浪费了时间。顾客会抱怨因为菜不够，服务员也因为混乱的出菜流程而忙得不可开交。</li>
</ul>
<p><strong>现实中的问题</strong>：如果生产者不等待缓冲区腾出空间继续生产，数据就可能会被覆盖，导致丢失。</p>
<p>情况二：<strong>没有等待机制，缓冲区空</strong></p>
<p>假设服务员到窗口取菜时，没有任何规则限制什么时候该停止等菜。</p>
<ul>
<li><strong>缓冲区为空的情况</strong>：当窗口里一盘菜也没有时，服务员会继续来回在窗口取菜，却发现没有菜可以送（读取无效数据）。服务员一次次白跑，最终浪费时间，不能及时给顾客送餐。</li>
<li><strong>没有等待的后果</strong>：服务员会忙碌但却无法送餐，而顾客等待时间过长，抱怨连连。</li>
</ul>
<p><strong>现实中的问题</strong>：如果消费者在没有数据可取时不等待，那么它可能会白忙一场，甚至读取无效数据或造成错误。</p>
<p>在这些生活案例中，缓冲区（窗口、传送带、货架）的满和空如果不通过合适的等待机制进行处理，会导致资源浪费、系统效率下降，甚至使整个系统无法正常工作。等待机制的引入可以确保：</p>
<ul>
<li>当缓冲区满时，生产者等待，避免覆盖数据。</li>
<li>当缓冲区空时，消费者等待，避免无效操作或消费错误。</li>
</ul>
<p>通过这些例子可以更直观地理解，<strong>等待机制</strong>在多线程程序中的重要性就在于确保生产者和消费者合理协同，防止资源浪费或错误行为。</p>
<h2 id="线程调度-scheduling"><a href="#线程调度-scheduling" class="headerlink" title="线程调度 scheduling"></a>线程调度 scheduling</h2><p>Java 的线程调度完全依赖于操作系统。操作系统根据线程优先级、时间片和调度算法来控制线程执行顺序和时间。JVM 负责将 Java 线程映射到操作系统线程，确保线程的创建、调度和同步机制正常工作。Java 提供的优先级和调度方法只是“建议”，最终执行权由操作系统决定。在大多数现代操作系统（如 Linux）中，线程优先级被忽略，使用时间片轮转调度所有线程。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/three-types-of-thread-models-1735555167554-48.png" alt="常见的三种线程模型"></p>
<h3 id="基于内核线程"><a href="#基于内核线程" class="headerlink" title="基于内核线程"></a>基于内核线程</h3><p>Java 中的线程调度依赖于操作系统提供的<strong>原生线程（Native Thread）</strong>支持。具体来说：</p>
<ol>
<li><strong>Java 线程映射到操作系统线程：</strong><ul>
<li>Java 使用 <strong>1:1 模型</strong>，即每个 Java 线程对应一个操作系统线程。</li>
<li>线程的创建、管理和调度全部委托给底层操作系统的线程调度器（如 Windows 的 <strong>线程调度器</strong> 或 Linux 的 <strong>CFS调度器</strong>）。</li>
</ul>
</li>
<li><strong>线程调度策略：</strong><br>操作系统调度器通常采用 <strong>时间片轮转（Round-Robin）</strong> 或 <strong>优先级调度（Priority Scheduling）</strong>策略，为线程分配 CPU 时间。<ul>
<li>Java 线程也有优先级，但其实际执行顺序依赖于操作系统的实现。</li>
</ul>
</li>
<li><strong>时间片和抢占式调度：</strong><ul>
<li>Java 虚拟机（JVM）并不直接管理线程的时间片分配，而是由操作系统决定何时挂起或恢复线程。</li>
<li>Java 线程默认是<strong>抢占式调度</strong>，即高优先级线程可能会抢占 CPU 资源，但操作系统仍有最终决定权。</li>
</ul>
</li>
</ol>
<p>Java 线程通过 JVM 的 <strong>线程库（Thread API）</strong> 调用底层 <strong>操作系统线程库（如 POSIX pthreads 或 Windows API）</strong>来实现线程调度。</p>
<p>Java 线程是基于<strong>内核级线程（Kernel Thread）</strong>，因为：</p>
<ul>
<li>Java 线程依赖操作系统的内核调度器进行管理。</li>
<li>内核线程直接由操作系统管理和调度，可以利用多核 CPU 并行执行多个线程。</li>
<li>用户级线程（如早期的绿色线程）已经被淘汰，Java 不再支持用户级线程。</li>
</ul>
<p><strong>关键组件：</strong></p>
<ol>
<li><strong><code>java.lang.Thread</code>：</strong> Java 提供的线程抽象类，依赖 JVM 的原生接口。</li>
<li><strong><code>Thread.start()</code>：</strong> 调用 JVM 本地方法 <code>start0()</code>，最终委托给操作系统创建线程。</li>
<li><strong><code>Thread.yield()</code>：</strong> 提示线程调度器让出 CPU，但具体是否让出由操作系统决定。</li>
<li><strong><code>Thread.sleep()</code>：</strong> 当前线程进入休眠状态，底层通过操作系统的 <strong>计时器</strong> 和 <strong>休眠 API</strong> 实现。</li>
<li><strong><code>Thread.join()</code>：</strong> 等待其他线程执行完成，依赖于操作系统提供的线程同步机制。</li>
</ol>
<h3 id="OS-线程调度"><a href="#OS-线程调度" class="headerlink" title="OS 线程调度"></a>OS 线程调度</h3><p><strong>1) Windows：</strong></p>
<ul>
<li>使用 <strong>Windows API</strong> 管理线程调度。</li>
<li>支持优先级和基于时间片的抢占式调度策略。</li>
</ul>
<p><strong>2) Linux/Unix：</strong></p>
<ul>
<li>使用 <strong>POSIX Threads (pthreads)</strong> 作为底层实现。</li>
<li>基于 <strong>CFS（Completely Fair Scheduler）</strong> 调度器执行线程调度，按“公平性”分配 CPU 时间片。</li>
</ul>
<h2 id="线程池-Executor"><a href="#线程池-Executor" class="headerlink" title="线程池 Executor"></a>线程池 <code>Executor</code></h2><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p>
<ul>
<li><p>可以复用线程的技术</p>
</li>
<li><p>如果不使用线程池，后台要用新的线程，创建新线程开销很大，请求过多就会严重影响系统性能</p>
</li>
<li><p>创建线程池</p>
<ul>
<li><p>ExecutorService的实现类ThreadPoolExecutor 自创建对象</p>
</li>
<li><p>Executors 工具类</p>
</li>
</ul>
</li>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918001837124-1726751033487-53.png" alt="image-20240918001837124"></p>
</li>
</ul>
<h3 id="构造-ThreadPoolExecutor"><a href="#构造-ThreadPoolExecutor" class="headerlink" title="构造 ThreadPoolExecutor"></a>构造 <code>ThreadPoolExecutor</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">int</span> corePoolSize,//核心线程数量</span></span><br><span class="line"><span class="params">	<span class="type">int</span> maximumPoolSize,//核心线程数量+临时线程数量</span></span><br><span class="line"><span class="params">	<span class="type">long</span> keepAliveTime,//临时线程存活时间</span></span><br><span class="line"><span class="params">	TimeUnit unit,  //临时线程存活时间的单位,是一个枚举<span class="keyword">enum</span></span></span><br><span class="line"><span class="params">	BlockingQueue&lt;Runnable&gt; workQueue,//线程池的任务队列</span></span><br><span class="line"><span class="params">	ThreadFactory threadFactory,//线程池的线程工厂,创建线程</span></span><br><span class="line"><span class="params">	RejectedExecutionHandler handler//任务拒绝策略, 线程全在忙,任务队列也满了,新任务来了怎么处理</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p><code>workQueue</code>: <code>new ArrayBlockingQueue&lt;&gt;(4)</code> 声明一个新的任务队列,容量为4</p>
<p><code>threadFactory</code>: <code>Executors.defaultThreadFactory()</code></p>
<p><code>handler</code>: <code>new ThreadPoolExecutor.AbortPolicy()</code> 丢弃任务抛出异常 默认策略</p>
<p>​        <code>DiscardPolicy</code> 丢弃任务不抛异常     <code>DiscardOldestPolicy</code> 抛弃队列中等待最久任务</p>
<p>​        <code>CallerRunsPolicy</code> 主线程调用<code>Runnable</code>任务的<code>run()</code>方法从而绕过线程池直接执行</p>
<h3 id="处理-Runnable-任务"><a href="#处理-Runnable-任务" class="headerlink" title="处理 Runnable 任务"></a>处理 <code>Runnable</code> 任务</h3><p><code>void execute(Runnable command)</code>: 处理一个任务</p>
<p><code>void shutdown()</code>: 停机, 但是等待所有任务完成</p>
<p><code>List&lt;Runnable&gt; shutdownNow()</code>: 立即停机, 返回未完成任务的列表</p>
<p>核心线程占满, 再排任务队列, 任务队列占满, 就加临时线程。</p>
<h3 id="处理-Callable-任务"><a href="#处理-Callable-任务" class="headerlink" title="处理 Callable 任务"></a>处理 <code>Callable</code> 任务</h3><p><code>Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code> 返回一个任务对象获取线程结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; f1 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>));</span><br><span class="line">Future&lt;String&gt; f2 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>));</span><br><span class="line">Future&lt;String&gt; f3 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">300</span>));</span><br><span class="line">Future&lt;String&gt; f4 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">400</span>));</span><br></pre></td></tr></table></figure>

<h3 id="构造线程池：Executors-工具类"><a href="#构造线程池：Executors-工具类" class="headerlink" title="构造线程池：Executors 工具类"></a>构造线程池：Executors 工具类</h3><ul>
<li><p><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>: 创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。任务队列可达 <code>Integer.MAX_VALUE</code> <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42447950/article/details/81435080">OOM</a>风险</p>
</li>
<li><p><code>public static ExecutorService newSingleThreadExecutor()</code>: 创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程。任务队列可达 <code>Integer.MAX_VALUE</code> <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42447950/article/details/81435080">OOM</a>风险</p>
</li>
<li><p><code>public static ExecutorService newCachedThreadPool()</code>: 线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了60s则会被回收掉。线程数可达 <code>Integer.MAX_VALUE</code> <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42447950/article/details/81435080">OOM</a>风险</p>
</li>
<li><p><code>public static ScheduledExecutorService newScheduledThreadPool(int corePoolsize)</code>: 创建一个线程池，可以实现在给定的延迟后运行任务或者定期执行任务。</p>
</li>
<li><p>底层都是ThreadPoolExecutor创建的线程池对象</p>
</li>
</ul>
<p>计算密集型：核心线程数量 = CPU核数 + 1</p>
<p>IO密集型：核心线程数量 = CPU核数*2</p>
<p>Executors工具类可能在大型并发系统有危险，内存溢出</p>
<h2 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a>虚拟线程</h2><p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/virtual-thread.html">虚拟线程常见问题总结 | JavaGuide</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/11/15/digital-S.M.A.R.T/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/15/digital-S.M.A.R.T/" class="post-title-link" itemprop="url">S.M.A.R.T 概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-15 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-15T00:00:00+08:00">2024-11-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:19:24" itemprop="dateModified" datetime="2025-05-05T11:19:24+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">数码</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一、SMART概述"><a href="#一、SMART概述" class="headerlink" title="一、SMART概述"></a>一、SMART概述</h2><p><a target="_blank" rel="noopener" href="https://www.smzdm.com/fenlei/yingpan/">硬盘</a>的故障一般分为两种：可预测的（predictable）和不可预测的（unpredictable）。后者偶而会发生，也没有办法去预防它，例如芯片突然失效，机械撞击等。但像电机轴承磨损、盘片磁介质性能下降等都属于可预测的情况，可以在在几天甚至几星期前就发现这种不正常的现象。如果发生这种问题，SMART功能会在开机时响起警报，至少让使用者有足够的时间把重要资料转移到其它储存设备上。</p>
<p>最早期的硬盘监控技术起源于1992年，IBM在AS/400计算机的IBM 0662 SCSI 2代硬盘驱动器中使用了后来被命名为Predictive Failure Analysis（故障预警分析技术）的监控技术，它是通过在固件中测量几个重要的硬盘安全参数和评估他们的情况，然后由监控软件得出两种结果：“硬盘安全”或“不久后会发生故障”。</p>
<p>不久，当时的微机制造商康柏和硬盘制造商希捷、昆腾以及康纳共同提出了名为IntelliSafe的类似技术。通过该技术，硬盘可以测量自身的的健康指标并将参量值传送给操作系统和用户的监控软件中，每个硬盘生产商有权决定哪些指标需要被监控以及设定它们的安全阈值。</p>
<p>1995年，康柏公司将该技术方案提交到Small Form Factor(SFF)委员会进行标准化，该方案得到IBM、希捷、昆腾、康纳和西部数据的支持，1996年6月进行了1.3版的修正，正式更名为S.M.A.R.T.（Self-Monitoring Analysis And Reporting Technology），全称就是“自我检测分析与报告技术”，成为一种自动监控硬盘驱动器完好状况和报告潜在问题的技术标准。</p>
<p>作为行业规范，SMART规定了硬盘制造厂商应遵循的标准，满足SMART标准的条件主要包括：</p>
<p>1）在设备制造期间完成SMART需要的各项参数、属性的设定；</p>
<p>2）在特定系统平台下，能够正常使用SMART；通过BIOS检测，能够识别设备是否支持SMART并可显示相关信息，而且能辨别有效和失效的SMART信息；</p>
<p>3）允许用户自由开启和关闭SMART功能；</p>
<p>4）在用户使用过程中，能提供SMART的各项有效信息，确定设备的工作状态，并能发出相应的修正指令或警告。在硬盘及操作系统都支持SMART技术并且开启的情况下，若硬盘状态不良，SMART技术能够在屏幕上显示英文警告信息：“WARNING：IMMEDIATLY BACKUP YOUR DATA AND REPLACE YOUR HARD DISK DRIVE，A FAILURE MAY BE IMMINENT．”(警告：立刻备份你的数据并更换硬盘，硬盘可能失效。)</p>
<p>SMART功能不断从硬盘上的各个传感器收集信息，并把信息保存在硬盘的系统保留区(service area)内，这个区域一般位于硬盘0物理面的最前面几十个物理磁道，由厂商写入相关的内部管理程序。这里除了SMART信息表外还包括低级格式化程序、加密解密程序、自监控程序、自动修复程序等。用户使用的监测软件通过名为“SMART Return Status”的命令（命令代码为：B0h）对SMART信息进行读取，且不允许最终用户对信息进行修改。</p>
<h2 id="二、SMART的ID代码"><a href="#二、SMART的ID代码" class="headerlink" title="二、SMART的ID代码"></a>二、SMART的ID代码</h2><p>硬盘SMART检测的ID代码以两位十六进制数表示（括号里对应的是十进制数）硬盘的各项检测参数。目前，各硬盘制造商的绝大部分SMART ID代码所代表的参数含义是一致的，但厂商也可以根据需要使用不同的ID代码，或者根据检测项目的多少增减ID代码。一般来说，以下这些检测项是必需的：</p>
<p>01（001） 底层数据读取错误率 Raw Read Error Rate</p>
<p>04（004） 启动/停止计数 Start/Stop Count</p>
<p>05（005） 重映射扇区数 Relocated Sector Count</p>
<p>09（009） 通电时间累计 Power-On Time Count (POH)</p>
<p>0A（010） 主轴起旋重试次数（即硬盘主轴电机启动重试次数） Spin up Retry Count</p>
<p>0B（011） 磁盘校准重试次数 Calibration Retry Count</p>
<p>0C（012） 磁盘通电次数 Power Cycle Count</p>
<p>C2（194） 温度 Temperature</p>
<p>C7（199） ULTRA DMA奇偶校验错误率 ULTRA ATA CRC Error Rate</p>
<p>C8（200） 写错误率 Write Error Rate</p>
<h2 id="三、SMART的描述（Description）"><a href="#三、SMART的描述（Description）" class="headerlink" title="三、SMART的描述（Description）"></a>三、SMART的描述（Description）</h2><p>描述，即某一检测项目的名称，是ID代码的文字解释。对用户而言，不仅要了解描述的含义，重要的是要了解各参数的值如“临界值”、“最差值”的定义，“当前值”与“数据值”的区别等，才能对自己的硬盘状态有一个基本了解。</p>
<h2 id="四、SMART的值"><a href="#四、SMART的值" class="headerlink" title="四、SMART的值"></a>四、SMART的值</h2><h3 id="1、临界值（Threshold）"><a href="#1、临界值（Threshold）" class="headerlink" title="1、临界值（Threshold）"></a>1、临界值（Threshold）</h3><p>临界值是硬盘厂商指定的表示某一项目可靠性的门限值，也称阈值，它通过特定公式计算而得。如果某个参数的当前值接近了临界值，就意味着硬盘将变得不可靠，可能导致数据丢失或者硬盘故障。由于临界值是硬盘厂商根据自己产品特性而确定的，因此用厂商提供的专用检测软件往往会跟Windows下检测软件的检测结果有较大出入。</p>
<p>以参数Raw Read Error Rate（底层数据读取错误率）为例：某型硬盘对该参数的计算公式为“10×log10（主机和硬盘之间所传输数据的扇区数）×512×8／重读的扇区数”。其中“512×8”是把扇区数转化为所传输的数据位(bits)，这个值只在所传输的数据位处于1010～1012范围时才作计算，而当Windows系统启动后，主机和硬盘之间所传输的数据扇区大于或等于1012时，此值将重新复位，所以有些值在不同的操作环境、不同检测程序下时会有较大的波动。</p>
<h3 id="2、当前值（Normalized-value）"><a href="#2、当前值（Normalized-value）" class="headerlink" title="2、当前值（Normalized value）"></a>2、当前值（Normalized value）</h3><p>当前值是各ID项在硬盘运行时根据实测数据通过公式计算的结果，计算公式由硬盘厂家自定。</p>
<p>硬盘出厂时各ID项目都有一个预设的最大正常值，也即出厂值，这个预设的依据及计算方法为硬盘厂家保密，不同型号的硬盘都不同，最大正常值通常为100或200或253，新硬盘刚开始使用时显示的当前值可以认为是预设的最大正常值（有些ID项如温度等除外）。随着使用损耗或出现错误，当前值会根据实测数据而不断刷新并逐渐减小。因此，当前值接近临界值就意味着硬盘寿命的减少，发生故障的可能性增大，所以当前值也是判定硬盘健康状态或推测寿命的依据之一。</p>
<h3 id="3、最差值（Worst）"><a href="#3、最差值（Worst）" class="headerlink" title="3、最差值（Worst）"></a>3、最差值（Worst）</h3><p>最差值是硬盘运行时各ID项曾出现过的最大的非正常值。</p>
<p>最差值是对硬盘运行中某项数据变劣的峰值统计，该数值也会不断刷新。通常，最差值与当前值是相等的，如果最差值出现较大的波动（小于当前值），表明硬盘曾出现错误或曾经历过恶劣的工作环境（如温度）。</p>
<h3 id="4、数据值（Data或Raw-value）"><a href="#4、数据值（Data或Raw-value）" class="headerlink" title="4、数据值（Data或Raw value）"></a>4、数据值（Data或Raw value）</h3><p>数据值是硬盘运行时各项参数的实测值，大部分SMART工具以十进制显示数据。</p>
<p>数据值代表的意义随参数而定，大致可以分为三类：</p>
<p>1）数据值并不直接反映硬盘状态，必须经过硬盘内置的计算公式换算成当前值才能得出结果；</p>
<p>2）数据值是直接累计的，如Start/Stop Count（启动/停止计数）的数据是50，即表示该硬盘从出厂到现在累计启停了50次；</p>
<p>3）有些参数的数据是即时数，如Temperature（温度）的数据值是44，表示硬盘的当前温度是44℃。</p>
<p>因此，有些参数直接查看数据也能大致了解硬盘目前的工作状态。</p>
<h2 id="五、状态-Status"><a href="#五、状态-Status" class="headerlink" title="五、状态(Status)"></a>五、状态(Status)</h2><p>硬盘的每项SMART信息中都有一个临界值（阈值），不同硬盘的临界值是不同的，SMART针对各项的当前值、最差值和临界值的比较结果以及数据值进行分析后，提供硬盘当前的评估状态，也是我们直观判断硬盘健康状态的重要信息。根据SMART的规定，状态一般有正常、警告、故障或错误三种状态。</p>
<p>SMART判定这三个状态与SMART的 Pre-failure/advisory BIT（预测错误/发现位）参数的赋值密切相关，当Pre-failure/advisory BIT=0，并且当前值、最差值远大于临界值的情况下，为正常标志。当Pre-failure/advisory BIT=0，并且当前值、最差值大于但接近临界值时，为警告标志；当Pre-failure/advisory BIT=1，并且当前值、最差值小于临界值时，为故障或错误标志。</p>
<h2 id="六、SMART参数详解"><a href="#六、SMART参数详解" class="headerlink" title="六、SMART参数详解"></a>六、SMART参数详解</h2><p>一般情况下，用户只要观察当前值、最差值和临界值的关系，并注意状态提示信息即可大致了解硬盘的健康状况。下面简单介绍各参数的含义，以红色标出的项目是寿命关键项，蓝色为<a target="_blank" rel="noopener" href="https://www.smzdm.com/fenlei/gutaiyingpan/">固态硬盘</a>（SSD）特有的项目。</p>
<p>在基于闪存的固态硬盘中，存储单元分为两类：SLC（Single Layer Cell，单层单元）和MLC（Multi-Level Cell，多层单元）。SLC成本高、容量小、但读写速度快，可靠性高，擦写次数可高达100000次，比MLC高10倍。而MLC虽容量大、成本低，但其性能大幅落后于SLC。为了保证MLC的寿命，控制芯片还要有智能磨损平衡技术算法，使每个存储单元的写入次数可以平均分摊，以达到100万小时的平均无故障时间。因此固态硬盘有许多SMART参数是<a target="_blank" rel="noopener" href="https://www.smzdm.com/fenlei/jixieyingpan/">机械硬盘</a>所没有的，如存储单元的擦写次数、备用块统计等等，这些新增项大都由厂家自定义，有些尚无详细的解释，有些解释也未必准确，此处也只是仅供参考。下面凡未注明厂商的固态硬盘特有的项均为SandForce主控芯片特有的，其它厂商各自单独注明。</p>
<h3 id="01（001）底层数据读取错误率-Raw-Read-Error-Rate"><a href="#01（001）底层数据读取错误率-Raw-Read-Error-Rate" class="headerlink" title="01（001）底层数据读取错误率 Raw Read Error Rate"></a>01（001）底层数据读取错误率 Raw Read Error Rate</h3><p>数据为0或任意值，当前值应远大于与临界值。</p>
<p>底层数据读取错误率是磁头从磁盘表面读取数据时出现的错误，对某些硬盘来说，大于0的数据表明磁盘表面或者读写磁头发生问题，如介质损伤、磁头污染、磁头共振等等。不过对希捷硬盘来说，许多硬盘的这一项会有很大的数据量，这不代表有任何问题，主要是看当前值下降的程度。</p>
<p>在固态硬盘中，此项的数据值包含了可校正的错误与不可校正的RAISE错误（UECC＋URAISE）。</p>
<p>注：RAISE（Redundant Array of Independent Silicon Elements）意为独立硅元素冗余阵列，是固态硬盘特有的一种冗余恢复技术，保证内部有类似RAID阵列的数据安全性。</p>
<h3 id="02（002）磁盘读写通量性能-Throughput-Performance"><a href="#02（002）磁盘读写通量性能-Throughput-Performance" class="headerlink" title="02（002）磁盘读写通量性能 Throughput Performance"></a>02（002）磁盘读写通量性能 Throughput Performance</h3><p>此参数表示硬盘的读写通量性能，数据值越大越好。当前值如果偏低或趋近临界值，表示硬盘存在严重的问题，但现在的硬盘通常显示数据值为0或根本不显示此项，一般在进行了人工脱机SMART测试后才会有数据量。</p>
<h3 id="03（003）主轴起旋时间-Spin-Up-Time"><a href="#03（003）主轴起旋时间-Spin-Up-Time" class="headerlink" title="03（003）主轴起旋时间 Spin Up Time"></a>03（003）主轴起旋时间 Spin Up Time</h3><p>主轴起旋时间就是主轴电机从启动至达到额定转速所用的时间，数据值直接显示时间，单位为毫秒或者秒，因此数据值越小越好。不过对于正常硬盘来说，这一项仅仅是一个参考值，硬盘每次的启动时间都不相同，某次启动的稍慢些也不表示就有问题。</p>
<p>硬盘的主轴电机从启动至达到额定转速大致需要4秒～15秒左右，过长的启动时间说明电机驱动电路或者轴承机构有问题。旦这一参数的数据值在某些型号的硬盘上总是为0，这就要看当前值和最差值来判断了。</p>
<p>对于固态硬盘来说，所有的数据都是保存在半导体集成电路中，没有主轴电机，所以这项没有意义，数据固定为0，当前值固定为100。</p>
<h3 id="04（004）启停计数-Start-Stop-Count"><a href="#04（004）启停计数-Start-Stop-Count" class="headerlink" title="04（004）启停计数 Start/Stop Count"></a>04（004）启停计数 Start/Stop Count</h3><p>这一参数的数据是累计值，表示硬盘主轴电机启动/停止的次数，新硬盘通常只有几次，以后会逐渐增加。系统的某些功能如空闲时关闭硬盘等会使硬盘启动/停止的次数大为增加，在排除定时功能的影响下，过高的启动/停止次数（远大于通电次数0C）暗示硬盘电机及其驱动电路可能有问题。</p>
<p>这个参数的当前值是依据某种公式计算的结果，例如对希捷某硬盘来说临界值为20，当前值是通过公式“100－（启停计数/1024）”计算得出的。若新硬盘的启停计数为0，当前值为100－(0/1024)＝100，随着启停次数的增加，该值不断下降，当启停次数达到81920次时，当前值为100－(81920/1024)＝20，已达到临界值，表示从启停次数来看，该硬盘已达设计寿命，当然这只是个寿命参考值，并不具有确定的指标性。</p>
<p>这一项对于固态硬盘同样没有意义，数据固定为0，当前值固定为100。</p>
<h3 id="05（005）重映射扇区计数-Reallocated-Sectors-Count-退役块计数-Retired-Block-Count"><a href="#05（005）重映射扇区计数-Reallocated-Sectors-Count-退役块计数-Retired-Block-Count" class="headerlink" title="05（005）重映射扇区计数 Reallocated Sectors Count/ 退役块计数 Retired Block Count"></a>05（005）重映射扇区计数 Reallocated Sectors Count/ 退役块计数 Retired Block Count</h3><p>数据应为0，当前值应远大于临界值。</p>
<p>当硬盘的某扇区持续出现读/写/校验错误时，硬盘固件程序会将这个扇区的物理地址加入缺陷表(G-list)，将该地址重新定向到预先保留的备用扇区并将其中的数据一并转移，这就称为重映射。执行重映射操作后的硬盘在Windows常规检测中是无法发现不良扇区的，因其地址已被指向备用扇区，这等于屏蔽了不良扇区。</p>
<p>这项参数的数据值直接表示已经被重映射扇区的数量，当前值则随着数据值的增加而持续下降。当发现此项的数据值不为零时，要密切注意其发展趋势，若能长期保持稳定，则硬盘还可以正常运行；若数据值不断上升，说明不良扇区不断增加，硬盘已处于不稳定状态，应当考虑更换了。如果当前值接近或已到达临界值（此时的数据值并不一定很大，因为不同硬盘保留的备用扇区数并不相同），表示缺陷表已满或备用扇区已用尽，已经失去了重映射功能，再出现不良扇区就会显现出来并直接导致数据丢失。</p>
<p>这一项不仅是硬盘的寿命关键参数，而且重映射扇区的数量也直接影响硬盘的性能，例如某些硬盘会出现数据量很大，但当前值下降不明显的情况，这种硬盘尽管还可正常运行，但也不宜继续使用。因为备用扇区都是位于磁盘尾部（靠近盘片轴心处），大量的使用备用扇区会使寻道时间增加，硬盘性能明显下降。</p>
<p>这个参数在机械硬盘上是非常敏感的，而对于固态硬盘来说同样具有重要意义。闪存的寿命是正态分布的，例如说MLC能写入一万次以上，实际上说的是写入一万次之前不会发生“批量损坏”，但某些单元可能写入几十次就损坏了。换言之，机械硬盘的盘片不会因读写而损坏，出现不良扇区大多与工艺质量相关，而闪存的读写次数则是有限的，因而损坏是正常的。所以固态硬盘在制造时也保留了一定的空间，当某个存储单元出现问题后即把损坏的部分隔离，用好的部分来顶替。这一替换方法和机械硬盘的扇区重映射是一个道理，只不过机械硬盘正常时极少有重映射操作，而对于固态硬盘是经常性的。</p>
<p>在固态硬盘中这一项的数据会随着使用而不断增长，只要增长的速度保持稳定就可以。通常情况下，数据值＝100－（100×被替换块/必需块总数），因此也可以估算出硬盘的剩余寿命。</p>
<p>Intel固态硬盘型号的第十二个字母表示了两种规格，该字母为1表示第一代的50纳米技术的SSD，为2表示第二代的34纳米技术的SSD，如SSDSA2M160G2GN就表示是34nm的SSD。所以参数的查看也有两种情况：</p>
<p>50nm的SSD（一代）要看当前值。这个值初始是100，当出现替换块的时候这个值并不会立即变化，一直到已替换四个块时这个值变为1，之后每增加四个块当前值就＋1。也就是100对应0～3个块，1对应4～7个块，2对应8～11个块……</p>
<p>34nm的SSD（二代）直接查看数据值，数据值直接表示有多少个被替换的块。</p>
<h3 id="06（006）读取通道余量-Read-Channel-Margin"><a href="#06（006）读取通道余量-Read-Channel-Margin" class="headerlink" title="06（006）读取通道余量 Read Channel Margin"></a>06（006）读取通道余量 Read Channel Margin</h3><p>这一项功能不明，现在的硬盘也不显示这一项。</p>
<h3 id="07（007）寻道错误率-Seek-Error-Rate"><a href="#07（007）寻道错误率-Seek-Error-Rate" class="headerlink" title="07（007）寻道错误率 Seek Error Rate"></a>07（007）寻道错误率 Seek Error Rate</h3><p>数据应为0，当前值应远大于与临界值。</p>
<p>这一项表示磁头寻道时的错误率，有众多因素可导致寻道错误率上升，如磁头组件的机械系统、伺服电路有局部问题，盘片表面介质不良，硬盘温度过高等等。</p>
<p>通常此项的数据应为0，但对希捷硬盘来说，即使是新硬盘，这一项也可能有很大的数据量，这不代表有任何问题，还是要看当前值是否下降。</p>
<h3 id="08（008）寻道性能-Seek-Time-Performance"><a href="#08（008）寻道性能-Seek-Time-Performance" class="headerlink" title="08（008）寻道性能 Seek Time Performance"></a>08（008）寻道性能 Seek Time Performance</h3><p>此项表示硬盘寻道操作的平均性能（寻道速度），通常与前一项（寻道错误率）相关联。当前值持续下降标志着磁头组件、寻道电机或伺服电路出现问题，但现在许多硬盘并不显示这一项。</p>
<h3 id="09（009）通电时间累计-Power-On-Time-Count-POH"><a href="#09（009）通电时间累计-Power-On-Time-Count-POH" class="headerlink" title="09（009）通电时间累计 Power-On Time Count (POH)"></a>09（009）通电时间累计 Power-On Time Count (POH)</h3><p>这个参数的含义一目了然，表示硬盘通电的时间，数据值直接累计了设备通电的时长，新硬盘当然应该接近0，但不同硬盘的计数单位有所不同，有以小时计数的，也有以分、秒甚至30秒为单位的，这由磁盘制造商来定义。</p>
<p>这一参数的临界值通常为0，当前值随着硬盘通电时间增加会逐渐下降，接近临界值表明硬盘已接近预计的设计寿命，当然这并不表明硬盘将出现故障或立即报废。参考磁盘制造商给出的该型号硬盘的MTBF（平均无故障时间）值，可以大致估计剩余寿命或故障概率。</p>
<p>对于固态硬盘，要注意“设备优先电源管理功能（device initiated power management，DIPM）”会影响这个统计：如果启用了DIPM，持续通电计数里就不包括睡眠时间；如果关闭了DIPM功能，那么活动、空闲和睡眠三种状态的时间都会被统计在内。</p>
<h3 id="0A（010）主轴起旋重试次数-Spin-up-Retry-Count"><a href="#0A（010）主轴起旋重试次数-Spin-up-Retry-Count" class="headerlink" title="0A（010）主轴起旋重试次数 Spin up Retry Count"></a>0A（010）主轴起旋重试次数 Spin up Retry Count</h3><p>数据应为0，当前值应大于临界值。</p>
<p>主轴起旋重试次数的数据值就是主轴电机尝试重新启动的计数，即主轴电机启动后在规定的时间里未能成功达到额定转速而尝试再次启动的次数。数据量的增加表示电机驱动电路或是机械子系统出现问题，整机供电不足也会导致这一问题。</p>
<h3 id="0B（011）磁头校准重试计数-Calibration-Retry-Count"><a href="#0B（011）磁头校准重试计数-Calibration-Retry-Count" class="headerlink" title="0B（011）磁头校准重试计数 Calibration Retry Count"></a>0B（011）磁头校准重试计数 Calibration Retry Count</h3><p>数据应为0，当前值应远大于与临界值。</p>
<p>硬盘在温度发生变化时，机械部件（特别是盘片）会因热胀冷缩出现形变，因此需要执行磁头校准操作消除误差，有的硬盘还内置了磁头定时校准功能。这一项记录了需要再次校准（通常因上次校准失败）的次数。</p>
<p>这一项的数据量增加，表示电机驱动电路或是机械子系统出现问题，但有些型号的新硬盘也有一定的数据量，并不表示有问题，还要看当前值和最差值。</p>
<h3 id="0C（012）通电周期计数-Power-Cycle-Count"><a href="#0C（012）通电周期计数-Power-Cycle-Count" class="headerlink" title="0C（012）通电周期计数 Power Cycle Count"></a>0C（012）通电周期计数 Power Cycle Count</h3><p>通电周期计数的数据值表示了硬盘通电/断电的次数，即电源开关次数的累计，新硬盘通常只有几次。</p>
<p>这一项与启停计数（04）是有区别的，一般来说，硬盘通电/断电意味着计算机的开机与关机，所以经历一次开关机数据才会加1；而启停计数（04）表示硬盘主轴电机的启动/停止（硬盘在运行时可能多次启停，如系统进入休眠或被设置为空闲多少时间而关闭）。所以大多情况下这个通电/断电的次数会小于启停计数（04）的次数。</p>
<p>通常，硬盘设计的通电次数都很高，如至少5000次，因此这一计数只是寿命参考值，本身不具指标性。</p>
<h3 id="0D（013）软件读取错误率-Soft-Read-Error-Rate"><a href="#0D（013）软件读取错误率-Soft-Read-Error-Rate" class="headerlink" title="0D（013）软件读取错误率 Soft Read Error Rate"></a>0D（013）软件读取错误率 Soft Read Error Rate</h3><p>软件读取错误率也称为可校正的读取误码率，就是报告给操作系统的未经校正的读取错误。数据值越低越好，过高则可能暗示盘片磁介质有问题。</p>
<h3 id="AA（170）坏块增长计数-Grown-Failing-Block-Count（Micron-镁光）"><a href="#AA（170）坏块增长计数-Grown-Failing-Block-Count（Micron-镁光）" class="headerlink" title="AA（170）坏块增长计数 Grown Failing Block Count（Micron 镁光）"></a>AA（170）坏块增长计数 Grown Failing Block Count（Micron 镁光）</h3><p>读写失败的块增长的总数。</p>
<h3 id="AB（171）编程失败块计数-Program-Fail-Block-Count"><a href="#AB（171）编程失败块计数-Program-Fail-Block-Count" class="headerlink" title="AB（171）编程失败块计数 Program Fail Block Count"></a>AB（171）编程失败块计数 Program Fail Block Count</h3><p>Flash编程失败块的数量。</p>
<h3 id="AC（172）擦写失败块计数-Erase-Fail-Block-Count"><a href="#AC（172）擦写失败块计数-Erase-Fail-Block-Count" class="headerlink" title="AC（172）擦写失败块计数 Erase Fail Block Count"></a>AC（172）擦写失败块计数 Erase Fail Block Count</h3><p>擦写失败块的数量。</p>
<h3 id="AD（173）磨损平衡操作次数（平均擦写次数）-Wear-Leveling-Count（Micron-镁光）"><a href="#AD（173）磨损平衡操作次数（平均擦写次数）-Wear-Leveling-Count（Micron-镁光）" class="headerlink" title="AD（173）磨损平衡操作次数（平均擦写次数） / Wear Leveling Count（Micron 镁光）"></a>AD（173）磨损平衡操作次数（平均擦写次数） / Wear Leveling Count（Micron 镁光）</h3><p>所有好块的平均擦写次数。</p>
<p>Flash芯片有写入次数限制，当使用FAT文件系统时，需要频繁地更新文件分配表。如果闪存的某些区域读写过于频繁，就会比其它区域磨损的更快，这将明显缩短整个硬盘的寿命（即便其它区域的擦写次数还远小于最大限制）。所以，如果让整个区域具有均匀的写入量，就可明显延长芯片寿命，这称为磨损均衡措施。</p>
<h3 id="AE（174）意外失电计数-Unexpected-Power-Loss-Count"><a href="#AE（174）意外失电计数-Unexpected-Power-Loss-Count" class="headerlink" title="AE（174）意外失电计数 Unexpected Power Loss Count"></a>AE（174）意外失电计数 Unexpected Power Loss Count</h3><p>硬盘自启用后发生意外断电事件的次数。</p>
<h3 id="B1（177）磨损范围对比值-Wear-Range-Delta"><a href="#B1（177）磨损范围对比值-Wear-Range-Delta" class="headerlink" title="B1（177）磨损范围对比值 Wear Range Delta"></a>B1（177）磨损范围对比值 Wear Range Delta</h3><p>磨损最重的块与磨损最轻的块的磨损百分比之差。</p>
<h3 id="B4（180）未用的备用块计数-Unused-Reserved-Block-Count-Total（惠普）"><a href="#B4（180）未用的备用块计数-Unused-Reserved-Block-Count-Total（惠普）" class="headerlink" title="B4（180）未用的备用块计数 Unused Reserved Block Count Total（惠普）"></a>B4（180）未用的备用块计数 Unused Reserved Block Count Total（惠普）</h3><p>固态硬盘会保留一些容量来准备替换损坏的存储单元，所以可用的预留空间数非常重要。这个参数的当前值表示的是尚未使用的预留的存储单元数量。</p>
<h3 id="B5（181）编程失败计数-Program-Fail-Count"><a href="#B5（181）编程失败计数-Program-Fail-Count" class="headerlink" title="B5（181）编程失败计数 Program Fail Count"></a>B5（181）编程失败计数 Program Fail Count</h3><p>用4个字节显示已编程失败的次数，与（AB）参数相似。</p>
<h3 id="B5（181）非4KB对齐访问数-Non-4k-Aligned-Access（Micron-镁光）"><a href="#B5（181）非4KB对齐访问数-Non-4k-Aligned-Access（Micron-镁光）" class="headerlink" title="B5（181）非4KB对齐访问数 Non-4k Aligned Access（Micron 镁光）"></a>B5（181）非4KB对齐访问数 Non-4k Aligned Access（Micron 镁光）</h3><h3 id="B6（182）擦写失败计数-Erase-Fail-Count"><a href="#B6（182）擦写失败计数-Erase-Fail-Count" class="headerlink" title="B6（182）擦写失败计数 Erase Fail Count"></a>B6（182）擦写失败计数 Erase Fail Count</h3><p>用4个字节显示硬盘自启用后块擦写失败的次数，与（AC）参数相似。</p>
<h3 id="B7（183）串口降速错误计数-SATA-Downshift-Error-Count"><a href="#B7（183）串口降速错误计数-SATA-Downshift-Error-Count" class="headerlink" title="B7（183）串口降速错误计数 SATA Downshift Error Count"></a>B7（183）串口降速错误计数 SATA Downshift Error Count</h3><p>这一项表示了SATA接口速率错误下降的次数。通常硬盘与主板之间的兼容问题会导致SATA传输级别降级运行。</p>
<h3 id="B8（184）I-O错误检测与校正-I-O-Error-Detection-and-Correction（IOEDC）"><a href="#B8（184）I-O错误检测与校正-I-O-Error-Detection-and-Correction（IOEDC）" class="headerlink" title="B8（184）I/O错误检测与校正 I/O Error Detection and Correction（IOEDC）"></a>B8（184）I/O错误检测与校正 I/O Error Detection and Correction（IOEDC）</h3><p>“I/O错误检测与校正”是惠普公司专有的SMART IV技术的一部分，与其他制造商的I/O错误检测和校正架构一样，它记录了数据通过驱动器内部高速缓存RAM传输到主机时的奇偶校验错误数量。</p>
<h3 id="B8（184）点到点错误检测计数-End-to-End-Error-Detection-Count"><a href="#B8（184）点到点错误检测计数-End-to-End-Error-Detection-Count" class="headerlink" title="B8（184）点到点错误检测计数 End to End Error Detection Count"></a>B8（184）点到点错误检测计数 End to End Error Detection Count</h3><p>Intel第二代的34nm固态硬盘有点到点错误检测计数这一项。固态硬盘里有一个LBA（logical block addressing，逻辑块地址）记录，这一项显示了SSD内部逻辑块地址与真实物理地址间映射的出错次数。</p>
<p>B8（184）原始坏块数 Init Bad Block Count（Indilinx芯片）</p>
<p>硬盘出厂时已有的坏块数量。</p>
<h3 id="B9（185）磁头稳定性-Head-Stability（西部数据）"><a href="#B9（185）磁头稳定性-Head-Stability（西部数据）" class="headerlink" title="B9（185）磁头稳定性 Head Stability（西部数据）"></a>B9（185）磁头稳定性 Head Stability（西部数据）</h3><p>意义不明。</p>
<h3 id="BA（186）感应运算振动检测-nduced-Op-Vibration-Detection（西部数据）"><a href="#BA（186）感应运算振动检测-nduced-Op-Vibration-Detection（西部数据）" class="headerlink" title="BA（186）感应运算振动检测 nduced Op-Vibration Detection（西部数据）"></a>BA（186）感应运算振动检测 nduced Op-Vibration Detection（西部数据）</h3><p>意义不明。</p>
<h3 id="BB（187）无法校正的错误-Reported-Uncorrectable-Errors（希捷）"><a href="#BB（187）无法校正的错误-Reported-Uncorrectable-Errors（希捷）" class="headerlink" title="BB（187）无法校正的错误 Reported Uncorrectable Errors（希捷）"></a>BB（187）无法校正的错误 Reported Uncorrectable Errors（希捷）</h3><p>报告给操作系统的无法通过硬件ECC校正的错误。如果数据值不为零，就应该备份硬盘上的数据了。</p>
<p>报告给操作系统的在所有存取命令中出现的无法校正的RAISE（URAISE）错误。</p>
<h3 id="BC（188）命令超时-Command-Timeout"><a href="#BC（188）命令超时-Command-Timeout" class="headerlink" title="BC（188）命令超时 Command Timeout"></a>BC（188）命令超时 Command Timeout</h3><p>由于硬盘超时导致操作终止的次数。通常数据值应为0，如果远大于零，最有可能出现的是电源供电问题或者<a target="_blank" rel="noopener" href="https://www.smzdm.com/fenlei/shujuxian/">数据线</a>氧化致使接触不良，也可能是硬盘出现严重问题。</p>
<h3 id="BD（189）高飞写入-High-Fly-Writes"><a href="#BD（189）高飞写入-High-Fly-Writes" class="headerlink" title="BD（189）高飞写入 High Fly Writes"></a>BD（189）高飞写入 High Fly Writes</h3><p>磁头飞行高度监视装置可以提高读写的可靠性，这一装置时刻监测磁头的飞行高度是否在正常范围来保证可靠的写入数据。如果磁头的飞行高度出现偏差，写入操作就会停止，然后尝试重新写入或者换一个位置写入。这种持续的监测过程提高了写入数据的可靠性，同时也降低了读取错误率。这一项的数据值就统计了写入时磁头飞行高度出现偏差的次数。</p>
<h3 id="BD（189）出厂坏块计数-Factory-Bad-Block-Count（Micron-镁光芯片）"><a href="#BD（189）出厂坏块计数-Factory-Bad-Block-Count（Micron-镁光芯片）" class="headerlink" title="BD（189）出厂坏块计数 Factory Bad Block Count（Micron 镁光芯片）"></a>BD（189）出厂坏块计数 Factory Bad Block Count（Micron 镁光芯片）</h3><h3 id="BE（190）气流温度-Airflow-Temperature"><a href="#BE（190）气流温度-Airflow-Temperature" class="headerlink" title="BE（190）气流温度 Airflow Temperature"></a>BE（190）气流温度 Airflow Temperature</h3><p>这一项表示的是硬盘内部盘片表面的气流温度。在希捷公司的某些硬盘中，当前值=（100－当前温度），因此气流温度越高，当前值就越低，最差值则是当前值曾经到达过的最低点，临界值由制造商定义的最高允许温度来确定，而数据值不具实际意义。许多硬盘也没有这一项参数。</p>
<h3 id="BF（191）冲击错误率-G-sense-error-rate"><a href="#BF（191）冲击错误率-G-sense-error-rate" class="headerlink" title="BF（191）冲击错误率 G-sense error rate"></a>BF（191）冲击错误率 G-sense error rate</h3><p>这一项的数据值记录了硬盘受到机械冲击导致出错的频度。</p>
<h3 id="C0（192）断电返回计数-Power-Off-Retract-Count"><a href="#C0（192）断电返回计数-Power-Off-Retract-Count" class="headerlink" title="C0（192）断电返回计数 Power-Off Retract Count"></a>C0（192）断电返回计数 Power-Off Retract Count</h3><p>当计算机关机或意外断电时，硬盘的磁头都要返回停靠区，不能停留在盘片的数据区里。正常关机时电源会给硬盘一个通知，即Standby Immediate，就是说主机要求将缓存数据写入硬盘，然后就准备关机断电了（休眠、待机也是如此）；意外断电则表示硬盘在未收到关机通知时就失电，此时磁头会自动复位，迅速离开盘片。</p>
<p>这个参数的数据值累计了磁头返回的次数。但要注意这个参数对某些硬盘来说仅记录意外断电时磁头的返回动作；而某些硬盘记录了所有（包括休眠、待机，但不包括关机时）的磁头返回动作；还有些硬盘这一项没有记录。因此这一参数的数据值在某些硬盘上持续为0或稍大于0，但在另外的硬盘上则会大于通电周期计数（0C）或启停计数（04）的数据。在一些新型节能硬盘中，这一参数的数据量还与硬盘的节能设计相关，可能会远大于通电周期计数（0C）或启停计数（04）的数据，但又远小于磁头加载/卸载计数（C1）的数据量。</p>
<p>对于固态硬盘来说，虽然没有磁头的加载/卸载操作，但这一项的数据量仍然代表了不安全关机，即发生意外断电的次数。</p>
<h3 id="C1（193）磁头加载-卸载计数-Load-Unload-Cycle-Count"><a href="#C1（193）磁头加载-卸载计数-Load-Unload-Cycle-Count" class="headerlink" title="C1（193）磁头加载/卸载计数 Load/Unload Cycle Count"></a>C1（193）磁头加载/卸载计数 Load/Unload Cycle Count</h3><p>对于过去的硬盘来说，盘片停止旋转时磁头臂停靠于盘片中心轴处的停泊区，磁头与盘片接触，只有当盘片旋转到一定转速时，磁头才开始漂浮于盘片之上并开始向外侧移动至数据区。这使得磁头在硬盘启停时都与盘片发生摩擦，虽然盘片的停泊区不存储数据，但无疑启停一个循环，就使磁头经历两次磨损。所以对以前的硬盘来说，磁头起降（加载/卸载）次数是一项重要的寿命关键参数。</p>
<p>而在现代硬盘中，平时磁头臂是停靠于盘片之外的一个专门设计的停靠架上，远离盘片。只有当盘片旋转达到额定转速后，磁头臂才开始向内（盘片轴心）转动使磁头移至盘片区域（加载），磁头臂向外转动返回至停靠架即卸载。这样就彻底杜绝了硬盘启停时磁头与盘片接触的现象，西部数据公司将其称为“斜坡加载技术”。由于磁头在加载/卸载过程中始终不与盘片接触，不存在磁头的磨损，使得这一参数的重要性已经大大下降。</p>
<p>这个参数的数据值就是磁头执行加载/卸载操作的累计次数。从原理上讲，这个加载/卸载次数应当与硬盘的启停次数相当，但对于笔记本内置硬盘以及<a target="_blank" rel="noopener" href="https://www.smzdm.com/fenlei/taishiji/">台式机</a>新型节能硬盘来说，这一项的数据量会很大。这是因为磁头臂组件设计有一个固定的返回力矩，保证在意外断电时磁头能靠弹簧力自动离开盘片半径范围，迅速返回停靠架。所以要让硬盘运行时磁头保持在盘片的半径之内，就要使磁头臂驱动电机（寻道电机）持续通以电流。而让磁头臂在硬盘空闲几分钟后就立即执行卸载动作，返回到停靠架上，既有利于节能，又降低了硬盘受外力冲击导致磁头与盘片接触的概率。虽然再次加载会增加一点寻道时间，但毕竟弊大于利，所以在这类硬盘中磁头的加载/卸载次数会远远大于通电周期计数（0C）或启停计数（04）的数据量。不过这种加载/卸载方式已经没有了磁头与盘片的接触，所以设计值也已大大增加，通常笔记本内置硬盘的磁头加载/卸载额定值在30～60万次，而台式机新型节能硬盘的磁头加载/卸载设计值可达一百万次。</p>
<h3 id="C2（194）温度-Temperature"><a href="#C2（194）温度-Temperature" class="headerlink" title="C2（194）温度 Temperature"></a>C2（194）温度 Temperature</h3><p>温度的数据值直接表示了硬盘内部的当前温度。硬盘运行时最好不要超过45℃，温度过高虽不会导致数据丢失，但引起的机械变形会导致寻道与读写错误率上升，降低硬盘性能。硬盘的最高允许运行温度可查看硬盘厂商给出的数据，一般不会超过60℃。</p>
<p>不同厂家对温度参数的当前值、最差值和临界值有不同的表示方法：希捷公司某些硬盘的当前值就是实际温度（摄氏）值，最差值则是曾经达到过的最高温度，临界值不具意义；而西部数据公司一些硬盘的最差值是温度上升到某值后的时间函数，每次升温后的持续时间都将导致最差值逐渐下降，当前值则与当前温度成反比，即当前温度越高，当前值越低，随实际温度波动。</p>
<h3 id="C3（195）硬件ECC校正-Hardware-ECC-Recovered"><a href="#C3（195）硬件ECC校正-Hardware-ECC-Recovered" class="headerlink" title="C3（195）硬件ECC校正 Hardware ECC Recovered"></a>C3（195）硬件ECC校正 Hardware ECC Recovered</h3><p>ECC（Error Correcting Code）的意思是“错误检查和纠正”，这个技术能够容许错误，并可以将错误更正，使读写操作得以持续进行，不致因错误而中断。这一项的数据值记录了磁头在盘片上读写时通过ECC技术校正错误的次数，不过许多硬盘有其制造商特定的数据结构，因此数据量的大小并不能直接说明问题。</p>
<h3 id="C3（195）实时无法校正错误计数-On-the-fly-ECC-Uncorrectable-Error-Count"><a href="#C3（195）实时无法校正错误计数-On-the-fly-ECC-Uncorrectable-Error-Count" class="headerlink" title="C3（195）实时无法校正错误计数 On the fly ECC Uncorrectable Error Count"></a>C3（195）实时无法校正错误计数 On the fly ECC Uncorrectable Error Count</h3><p>这一参数记录了无法校正（UECC）的错误数量。</p>
<h3 id="C3（195）编程错误块计数-Program-Failure-block-Count（Indilinx芯片）"><a href="#C3（195）编程错误块计数-Program-Failure-block-Count（Indilinx芯片）" class="headerlink" title="C3（195）编程错误块计数 Program Failure block Count（Indilinx芯片）"></a>C3（195）编程错误块计数 Program Failure block Count（Indilinx芯片）</h3><h3 id="C4（196）重映射事件计数-Reallocetion-Events-Count"><a href="#C4（196）重映射事件计数-Reallocetion-Events-Count" class="headerlink" title="C4（196）重映射事件计数 Reallocetion Events Count"></a>C4（196）重映射事件计数 Reallocetion Events Count</h3><p>数据应为0，当前值应远大于临界值。</p>
<p>这个参数的数据值记录了将重映射扇区的数据转移到备用扇区的尝试次数，是重映射操作的累计值，成功的转移和不成功的转移都会被计数。因此这一参数与重映射扇区计数（05）相似，都是反映硬盘已经存在不良扇区。</p>
<h3 id="C4（196）擦除错误块计数-Erase-Failure-block-Count（Indilinx芯片）"><a href="#C4（196）擦除错误块计数-Erase-Failure-block-Count（Indilinx芯片）" class="headerlink" title="C4（196）擦除错误块计数 Erase Failure block Count（Indilinx芯片）"></a>C4（196）擦除错误块计数 Erase Failure block Count（Indilinx芯片）</h3><p>在固态硬盘中，这一参数记录了被重映射的块编程失败的数量。</p>
<h3 id="C5（197）当前待映射扇区计数-Current-Pending-Sector-Count"><a href="#C5（197）当前待映射扇区计数-Current-Pending-Sector-Count" class="headerlink" title="C5（197）当前待映射扇区计数 Current Pending Sector Count"></a>C5（197）当前待映射扇区计数 Current Pending Sector Count</h3><p>数据应为0，当前值应远大于临界值。</p>
<p>这个参数的数据表示了“不稳定的”扇区数，即等待被映射的扇区（也称“被挂起的扇区”）数量。如果不稳定的扇区随后被读写成功，该扇区就不再列入等待范围，数据值就会下降。</p>
<p>仅仅读取时出错的扇区并不会导致重映射，只是被列入“等待”，也许以后读取就没有问题，所以只有在写入失败时才会发生重映射。下次对该扇区写入时如果继续出错，就会产生一次重映射操作，此时重映射扇区计数（05）与重映射事件计数（C4）的数据值增加，此参数的数据值下降。</p>
<h3 id="C5（197）读取错误块计数（不可修复错误）Read-Failure-block-Count（Indilinx芯片）"><a href="#C5（197）读取错误块计数（不可修复错误）Read-Failure-block-Count（Indilinx芯片）" class="headerlink" title="C5（197）读取错误块计数（不可修复错误）Read Failure block Count（Indilinx芯片）"></a>C5（197）读取错误块计数（不可修复错误）Read Failure block Count（Indilinx芯片）</h3><h3 id="C6（198）脱机无法校正的扇区计数-Offline-Uncorrectable-Sector-Count"><a href="#C6（198）脱机无法校正的扇区计数-Offline-Uncorrectable-Sector-Count" class="headerlink" title="C6（198）脱机无法校正的扇区计数 Offline Uncorrectable Sector Count"></a>C6（198）脱机无法校正的扇区计数 Offline Uncorrectable Sector Count</h3><p>数据应为0，当前值应远大于临界值。</p>
<p>这个参数的数据累计了读写扇区时发生的无法校正的错误总数。数据值上升表明盘片表面介质或机械子系统出现问题，有些扇区肯定已经不能读取，如果有文件正在使用这些扇区，操作系统会返回读盘错误的信息。下一次写操作时会对该扇区执行重映射。</p>
<h3 id="C6（198）总读取页数-Total-Count-of-Read-Sectors（Indilinx芯片）"><a href="#C6（198）总读取页数-Total-Count-of-Read-Sectors（Indilinx芯片）" class="headerlink" title="C6（198）总读取页数 Total Count of Read Sectors（Indilinx芯片）"></a>C6（198）总读取页数 Total Count of Read Sectors（Indilinx芯片）</h3><h3 id="C7（199）Ultra-ATA访问校验错误率-Ultra-ATA-CRC-Error-Rate"><a href="#C7（199）Ultra-ATA访问校验错误率-Ultra-ATA-CRC-Error-Rate" class="headerlink" title="C7（199）Ultra ATA访问校验错误率 Ultra ATA CRC Error Rate"></a>C7（199）Ultra ATA访问校验错误率 Ultra ATA CRC Error Rate</h3><p>这个参数的数据值累计了通过接口循环冗余校验（Interface Cyclic Redundancy Check，ICRC）发现的数据线传输错误的次数。如果数据值不为0且持续增长，表示硬盘控制器→数据线→硬盘接口出现错误，劣质的数据线、接口接触不良都可能导致此现象。由于这一项的数据值不会复零，所以某些新硬盘也会出现一定的数据量，只要更换数据线后数据值不再继续增长，即表示问题已得到解决。</p>
<h3 id="C7（199）总写入页数-Total-Count-of-Write-Sectors（Indilinx芯片）"><a href="#C7（199）总写入页数-Total-Count-of-Write-Sectors（Indilinx芯片）" class="headerlink" title="C7（199）总写入页数 Total Count of Write Sectors（Indilinx芯片）"></a>C7（199）总写入页数 Total Count of Write Sectors（Indilinx芯片）</h3><h3 id="C8（200）写入错误率-Write-Error-Rate-多区域错误率-Multi-Zone-Error-Rate（西部数据）"><a href="#C8（200）写入错误率-Write-Error-Rate-多区域错误率-Multi-Zone-Error-Rate（西部数据）" class="headerlink" title="C8（200）写入错误率 Write Error Rate / 多区域错误率 Multi-Zone Error Rate（西部数据）"></a>C8（200）写入错误率 Write Error Rate / 多区域错误率 Multi-Zone Error Rate（西部数据）</h3><p>数据应为0，当前值应远大于临界值。</p>
<p>这个参数的数据累计了向扇区写入数据时出现错误的总数。有的新硬盘也会有一定的数据量，若数据值持续快速升高（当前值偏低），表示盘片、磁头组件可能有问题。</p>
<h3 id="C8（200）总读取指令数-Total-Count-of-Read-Command（Indilinx芯片）"><a href="#C8（200）总读取指令数-Total-Count-of-Read-Command（Indilinx芯片）" class="headerlink" title="C8（200）总读取指令数 Total Count of Read Command（Indilinx芯片）"></a>C8（200）总读取指令数 Total Count of Read Command（Indilinx芯片）</h3><h3 id="C9（201）脱道错误率-Off-Track-Error-Rate-逻辑读取错误率-Soft-Read-Error-Rate"><a href="#C9（201）脱道错误率-Off-Track-Error-Rate-逻辑读取错误率-Soft-Read-Error-Rate" class="headerlink" title="C9（201）脱道错误率 Off Track Error Rate / 逻辑读取错误率 Soft Read Error Rate"></a>C9（201）脱道错误率 Off Track Error Rate / 逻辑读取错误率 Soft Read Error Rate</h3><p>数据值累积了读取时脱轨的错误数量，如果数据值不为0，最好备份硬盘上的资料。</p>
<h3 id="C9（201）TA-Counter-Detected（意义不明）"><a href="#C9（201）TA-Counter-Detected（意义不明）" class="headerlink" title="C9（201）TA Counter Detected（意义不明）"></a>C9（201）TA Counter Detected（意义不明）</h3><h3 id="C9（201）写入指令总数-Total-Count-of-Write-Command（Indilinx芯片）"><a href="#C9（201）写入指令总数-Total-Count-of-Write-Command（Indilinx芯片）" class="headerlink" title="C9（201）写入指令总数 Total Count of Write Command（Indilinx芯片）"></a>C9（201）写入指令总数 Total Count of Write Command（Indilinx芯片）</h3><h3 id="CA（202）数据地址标记错误-Data-Address-Mark-errors"><a href="#CA（202）数据地址标记错误-Data-Address-Mark-errors" class="headerlink" title="CA（202）数据地址标记错误 Data Address Mark errors"></a>CA（202）数据地址标记错误 Data Address Mark errors</h3><p>此项的数据值越低越好（或者由制造商定义）。</p>
<h3 id="CA（202）TA-Counter-Increased（意义不明）"><a href="#CA（202）TA-Counter-Increased（意义不明）" class="headerlink" title="CA（202）TA Counter Increased（意义不明）"></a>CA（202）TA Counter Increased（意义不明）</h3><h3 id="CA（202）剩余寿命-Percentage-Of-The-Rated-Lifetime-Used（Micron-镁光芯片）"><a href="#CA（202）剩余寿命-Percentage-Of-The-Rated-Lifetime-Used（Micron-镁光芯片）" class="headerlink" title="CA（202）剩余寿命 Percentage Of The Rated Lifetime Used（Micron 镁光芯片）"></a>CA（202）剩余寿命 Percentage Of The Rated Lifetime Used（Micron 镁光芯片）</h3><p>当前值从100开始下降至0，表示所有块的擦写余量统计。计算方法是以MLC擦写次数除以50，SLC擦写次数除以1000，结果取整数，将其与100的差值作为当前值（MLC预计擦写次数为5000，SLC预计擦写次数为100000）。</p>
<h3 id="CA（202）闪存总错误bit数-Total-Count-of-error-bits-from-flash（Indilinx芯片）"><a href="#CA（202）闪存总错误bit数-Total-Count-of-error-bits-from-flash（Indilinx芯片）" class="headerlink" title="CA（202）闪存总错误bit数 Total Count of error bits from flash（Indilinx芯片）"></a>CA（202）闪存总错误bit数 Total Count of error bits from flash（Indilinx芯片）</h3><h3 id="CB（203）软件ECC错误数-Run-Out-Cancel"><a href="#CB（203）软件ECC错误数-Run-Out-Cancel" class="headerlink" title="CB（203）软件ECC错误数 Run Out Cancel"></a>CB（203）软件ECC错误数 Run Out Cancel</h3><p>错误检查和纠正（ECC）出错的频度。</p>
<h3 id="CB（203）校正bit错误的总读取页数-Total-Count-of-Read-Sectors-with-correct-bits-error（Indilinx芯片）"><a href="#CB（203）校正bit错误的总读取页数-Total-Count-of-Read-Sectors-with-correct-bits-error（Indilinx芯片）" class="headerlink" title="CB（203）校正bit错误的总读取页数 Total Count of Read Sectors with correct bits error（Indilinx芯片）"></a>CB（203）校正bit错误的总读取页数 Total Count of Read Sectors with correct bits error（Indilinx芯片）</h3><h3 id="CC（204）软件ECC校正-Soft-ECC-Correction"><a href="#CC（204）软件ECC校正-Soft-ECC-Correction" class="headerlink" title="CC（204）软件ECC校正 Soft ECC Correction"></a>CC（204）软件ECC校正 Soft ECC Correction</h3><p>通过软件ECC纠正错误的计数。</p>
<h3 id="CC（204）坏块满标志-Bad-Block-Full-Flag（Indilinx芯片）"><a href="#CC（204）坏块满标志-Bad-Block-Full-Flag（Indilinx芯片）" class="headerlink" title="CC（204）坏块满标志 Bad Block Full Flag（Indilinx芯片）"></a>CC（204）坏块满标志 Bad Block Full Flag（Indilinx芯片）</h3><h3 id="CD（205）热骚动错误率-Thermal-Asperity-Rate-TAR"><a href="#CD（205）热骚动错误率-Thermal-Asperity-Rate-TAR" class="headerlink" title="CD（205）热骚动错误率 Thermal Asperity Rate (TAR)"></a>CD（205）热骚动错误率 Thermal Asperity Rate (TAR)</h3><p>由超温导致的错误。数据值应为0。</p>
<h3 id="CD（205）最大可编程-擦除次数-Max-P-E-Count（Indilinx芯片）"><a href="#CD（205）最大可编程-擦除次数-Max-P-E-Count（Indilinx芯片）" class="headerlink" title="CD（205）最大可编程/擦除次数 Max P/E Count（Indilinx芯片）"></a>CD（205）最大可编程/擦除次数 Max P/E Count（Indilinx芯片）</h3><h3 id="CE（206）磁头飞行高度-Flying-Height"><a href="#CE（206）磁头飞行高度-Flying-Height" class="headerlink" title="CE（206）磁头飞行高度 Flying Height"></a>CE（206）磁头飞行高度 Flying Height</h3><p>磁头距离盘片表面的垂直距离。高度过低则增加了磁头与盘片接触导致损坏的可能性；高度偏高则增大了读写错误率。不过准确地说，硬盘中并没有任何装置可以直接测出磁头的飞行高度，制造商也只是根据磁头读取的信号强度来推算磁头飞行高度。</p>
<h3 id="CE（206）底层数据写入出错率-Write-Error-Rate"><a href="#CE（206）底层数据写入出错率-Write-Error-Rate" class="headerlink" title="CE（206）底层数据写入出错率 Write Error Rate"></a>CE（206）底层数据写入出错率 Write Error Rate</h3><h3 id="CE（206）最小擦写次数-Erase-Count-Min（Indilinx芯片）"><a href="#CE（206）最小擦写次数-Erase-Count-Min（Indilinx芯片）" class="headerlink" title="CE（206）最小擦写次数 Erase Count Min（Indilinx芯片）"></a>CE（206）最小擦写次数 Erase Count Min（Indilinx芯片）</h3><h3 id="CF（207）主轴过电流-Spin-High-Current"><a href="#CF（207）主轴过电流-Spin-High-Current" class="headerlink" title="CF（207）主轴过电流 Spin High Current"></a>CF（207）主轴过电流 Spin High Current</h3><p>数据值记录了主轴电机运行时出现浪涌电流的次数，数据量的增加意味着轴承或电机可能有问题。</p>
<h3 id="CF（207）最大擦写次数-Erase-Count-Max（Indilinx芯片）"><a href="#CF（207）最大擦写次数-Erase-Count-Max（Indilinx芯片）" class="headerlink" title="CF（207）最大擦写次数 Erase Count Max（Indilinx芯片）"></a>CF（207）最大擦写次数 Erase Count Max（Indilinx芯片）</h3><h3 id="D0（208）主轴电机重启次数-Spin-Buzz"><a href="#D0（208）主轴电机重启次数-Spin-Buzz" class="headerlink" title="D0（208）主轴电机重启次数 Spin Buzz"></a>D0（208）主轴电机重启次数 Spin Buzz</h3><p>数据值记录了主轴电机反复尝试启动的次数，这通常是由于电源供电不足引起的。</p>
<h3 id="D0（208）平均擦写次数Erase-Count-Average（Indilinx芯片）"><a href="#D0（208）平均擦写次数Erase-Count-Average（Indilinx芯片）" class="headerlink" title="D0（208）平均擦写次数Erase Count Average（Indilinx芯片）"></a>D0（208）平均擦写次数Erase Count Average（Indilinx芯片）</h3><h3 id="D1（209）脱机寻道性能-Offline-Seek-Performance"><a href="#D1（209）脱机寻道性能-Offline-Seek-Performance" class="headerlink" title="D1（209）脱机寻道性能 Offline Seek Performance"></a>D1（209）脱机寻道性能 Offline Seek Performance</h3><p>这一项表示驱动器在脱机状态下的寻道性能，通常用于工厂内部测试。</p>
<h3 id="D1（209）剩余寿命百分比-Remaining-Life-（Indilinx芯片）"><a href="#D1（209）剩余寿命百分比-Remaining-Life-（Indilinx芯片）" class="headerlink" title="D1（209）剩余寿命百分比 Remaining Life %（Indilinx芯片）"></a>D1（209）剩余寿命百分比 Remaining Life %（Indilinx芯片）</h3><h3 id="D2（210）斜坡加载值-Ramp-Load-Value"><a href="#D2（210）斜坡加载值-Ramp-Load-Value" class="headerlink" title="D2（210）斜坡加载值 Ramp Load Value"></a>D2（210）斜坡加载值 Ramp Load Value</h3><p>这一项仅见于几年前迈拓制造的部分硬盘。通常数据值为0，意义不明。</p>
<h3 id="D2（210）坏块管理错误日志-BBM-Error-Log（Indilinx芯片）"><a href="#D2（210）坏块管理错误日志-BBM-Error-Log（Indilinx芯片）" class="headerlink" title="D2（210）坏块管理错误日志 BBM Error Log（Indilinx芯片）"></a>D2（210）坏块管理错误日志 BBM Error Log（Indilinx芯片）</h3><h3 id="D3（211）写入时振动-Vibration-During-Write"><a href="#D3（211）写入时振动-Vibration-During-Write" class="headerlink" title="D3（211）写入时振动 Vibration During Write"></a>D3（211）写入时振动 Vibration During Write</h3><p>写入数据时受到受到外部振动的记录。</p>
<h3 id="D3（211）SATA主机接口CRC写入错误计数-SATA-Error-Count-CRC-Write-（Indilinx芯片）"><a href="#D3（211）SATA主机接口CRC写入错误计数-SATA-Error-Count-CRC-Write-（Indilinx芯片）" class="headerlink" title="D3（211）SATA主机接口CRC写入错误计数 SATA Error Count CRC (Write)（Indilinx芯片）"></a>D3（211）SATA主机接口CRC写入错误计数 SATA Error Count CRC (Write)（Indilinx芯片）</h3><h3 id="D4（212）写入时冲击-Shock-During-Write"><a href="#D4（212）写入时冲击-Shock-During-Write" class="headerlink" title="D4（212）写入时冲击 Shock During Write"></a>D4（212）写入时冲击 Shock During Write</h3><p>写入数据时受到受到外部机械冲击的记录。</p>
<h3 id="D4（212）SATA主机接口读取错误计数-SATA-Error-Count-Count-CRC-Read-（Indilinx芯片）"><a href="#D4（212）SATA主机接口读取错误计数-SATA-Error-Count-Count-CRC-Read-（Indilinx芯片）" class="headerlink" title="D4（212）SATA主机接口读取错误计数 SATA Error Count Count CRC (Read)（Indilinx芯片）"></a>D4（212）SATA主机接口读取错误计数 SATA Error Count Count CRC (Read)（Indilinx芯片）</h3><h3 id="DC（220）盘片偏移量-Disk-Shift"><a href="#DC（220）盘片偏移量-Disk-Shift" class="headerlink" title="DC（220）盘片偏移量 Disk Shift"></a>DC（220）盘片偏移量 Disk Shift</h3><p>硬盘中的盘片相对主轴的偏移量（通常是受外力冲击或温度变化所致），单位未知，数据值越小越好。</p>
<h3 id="DD（221）冲击错误率-G-sense-error-rate"><a href="#DD（221）冲击错误率-G-sense-error-rate" class="headerlink" title="DD（221）冲击错误率 G-sense error rate"></a>DD（221）冲击错误率 G-sense error rate</h3><p>与（BF）相同，数据值记录了硬盘受到外部机械冲击或振动导致出错的频度。</p>
<h3 id="DE（222）磁头寻道时间累计-Loaded-Hours"><a href="#DE（222）磁头寻道时间累计-Loaded-Hours" class="headerlink" title="DE（222）磁头寻道时间累计 Loaded Hours"></a>DE（222）磁头寻道时间累计 Loaded Hours</h3><p>磁头臂组件运行的小时数，即寻道电机运行时间累计。</p>
<h3 id="DF（223）磁头加载-卸载重试计数-Load-Unload-Retry-Count"><a href="#DF（223）磁头加载-卸载重试计数-Load-Unload-Retry-Count" class="headerlink" title="DF（223）磁头加载/卸载重试计数 Load/Unload Retry Count"></a>DF（223）磁头加载/卸载重试计数 Load/Unload Retry Count</h3><p>这一项与（C1）项类似，数据值累积了磁头尝试重新加载/卸载的次数。</p>
<h3 id="E0（224）磁头阻力-Load-Friction"><a href="#E0（224）磁头阻力-Load-Friction" class="headerlink" title="E0（224）磁头阻力 Load Friction"></a>E0（224）磁头阻力 Load Friction</h3><p>磁头工作时受到的机械部件的阻力。</p>
<h3 id="E1（225）主机写入数据量-Host-Writes"><a href="#E1（225）主机写入数据量-Host-Writes" class="headerlink" title="E1（225）主机写入数据量 Host Writes"></a>E1（225）主机写入数据量 Host Writes</h3><p>由于闪存的擦写次数是有限的，所以这项是固态硬盘特有的统计。Intel的SSD是每当向硬盘写入了65536个扇区，这一项的数据就＋1。如果用HDTune等软件查看SMART时可以自己计算，Intel SSD Toolbox已经为你算好了，直接就显示了曾向SSD中写入过的数据量。</p>
<h3 id="E2（226）磁头加载时间累计-Load-‘In’-time"><a href="#E2（226）磁头加载时间累计-Load-‘In’-time" class="headerlink" title="E2（226）磁头加载时间累计 Load ‘In’-time"></a>E2（226）磁头加载时间累计 Load ‘In’-time</h3><p>磁头组件运行时间的累积数，即磁头臂不在停靠区的时间，与（DE）项相似。</p>
<h3 id="E3（227）扭矩放大计数-Torque-Amplification-Count"><a href="#E3（227）扭矩放大计数-Torque-Amplification-Count" class="headerlink" title="E3（227）扭矩放大计数 Torque Amplification Count"></a>E3（227）扭矩放大计数 Torque Amplification Count</h3><p>主轴电机试图提高扭矩来补偿盘片转速变化的次数。当主轴轴承存在问题时，主轴电机会尝试增加驱动力使盘片稳定旋转。这个参数的当前值下降，说明硬盘的机械子系统出现了严重的问题。</p>
<h3 id="E4（228）断电返回计数-Power-Off-Retract-Cycle"><a href="#E4（228）断电返回计数-Power-Off-Retract-Cycle" class="headerlink" title="E4（228）断电返回计数 Power-Off Retract Cycle"></a>E4（228）断电返回计数 Power-Off Retract Cycle</h3><p>数据值累计了磁头因设备意外断电而自动返回的次数，与（C0）项相似。</p>
<h3 id="E6（230）GMR磁头振幅-GMR-Head-Amplitude"><a href="#E6（230）GMR磁头振幅-GMR-Head-Amplitude" class="headerlink" title="E6（230）GMR磁头振幅 GMR Head Amplitude"></a>E6（230）GMR磁头振幅 GMR Head Amplitude</h3><p>磁头“抖动”，即正向/反向往复运动的距离。</p>
<h3 id="E7（231）温度-Temperature"><a href="#E7（231）温度-Temperature" class="headerlink" title="E7（231）温度 Temperature"></a>E7（231）温度 Temperature</h3><p>温度的数据值直接表示了硬盘内部的当前温度，与（C2）项相同。</p>
<h3 id="E7（231）剩余寿命-SSD-Life-Left"><a href="#E7（231）剩余寿命-SSD-Life-Left" class="headerlink" title="E7（231）剩余寿命 SSD Life Left"></a>E7（231）剩余寿命 SSD Life Left</h3><p>剩余寿命是基于P/E周期与可用的备用块作出的预测。新硬盘为100；10表示PE周期已到设计值，但尚有足够的保留块；0表示保留块不足，硬盘将处于只读方式以便备份数据。</p>
<h3 id="E8（232）寿命余量-Endurance-Remaining"><a href="#E8（232）寿命余量-Endurance-Remaining" class="headerlink" title="E8（232）寿命余量 Endurance Remaining"></a>E8（232）寿命余量 Endurance Remaining</h3><p>寿命余量是指硬盘已擦写次数与设计最大可擦写次数的百分比，与（CA）项相似。</p>
<h3 id="E8（232）预留空间剩余量-Available-Reserved-Space（Intel芯片）"><a href="#E8（232）预留空间剩余量-Available-Reserved-Space（Intel芯片）" class="headerlink" title="E8（232）预留空间剩余量 Available Reserved Space（Intel芯片）"></a>E8（232）预留空间剩余量 Available Reserved Space（Intel芯片）</h3><p>对于Intel的SSD来说，前边05项提到会保留一些容量来准备替换损坏的存储单元，所以可用的预留空间数非常重要。当保留的空间用尽，再出现损坏的单元就将出现数据丢失，这个SSD的寿命就结束了。所以仅看05项意义并不大，这一项才最重要。这项参数可以看当前值，新的SSD里所有的预留空间都在，所以是100。随着预留空间的消耗，当前值将不断下降，减小到接近临界值（一般是10）时，就说明只剩下10%的预留空间了，SSD的寿命将要结束。这个与（B4）项相似。</p>
<h3 id="E9（233）通电时间累计-Power-On-Hours"><a href="#E9（233）通电时间累计-Power-On-Hours" class="headerlink" title="E9（233）通电时间累计 Power-On Hours"></a>E9（233）通电时间累计 Power-On Hours</h3><p>对于普通硬盘来说，这一项与（09）相同。</p>
<h3 id="E9（233）介质磨耗指数-Media-Wareout-Indicator（Intel芯片）"><a href="#E9（233）介质磨耗指数-Media-Wareout-Indicator（Intel芯片）" class="headerlink" title="E9（233）介质磨耗指数 Media Wareout Indicator（Intel芯片）"></a>E9（233）介质磨耗指数 Media Wareout Indicator（Intel芯片）</h3><p>由于固态硬盘的擦写次数是有限的，当到达一定次数的时候，就会出现大量的单元同时损坏，这时候预留空间也顶不住了，所以这项参数实际上表示的是硬盘设计寿命。Intel的SSD要看当前值，随着NAND的平均擦写次数从0增长到最大的设计值，这一参数的当前值从开始的100逐渐下降至1为止。这表示SSD的设计寿命已经终结。当然到达设计寿命也不一定意味着SSD就立即报废，这与闪存芯片的品质有着很大的关系。</p>
<p>注：Total Erase Count全擦写计数是指固态硬盘中所有块的擦写次数的总和，不同规格的NAND芯片以及不同容量的SSD，其最大全擦写次数均有所不同。</p>
<h3 id="F0（240）磁头飞行时间-Head-Flying-Hours-传输错误率-Transfer-Error-Rate（富士通）"><a href="#F0（240）磁头飞行时间-Head-Flying-Hours-传输错误率-Transfer-Error-Rate（富士通）" class="headerlink" title="F0（240）磁头飞行时间 Head Flying Hours / 传输错误率 Transfer Error Rate（富士通）"></a>F0（240）磁头飞行时间 Head Flying Hours / 传输错误率 Transfer Error Rate（富士通）</h3><p>磁头位于工作位置的时间。</p>
<p>富士通硬盘表示在数据传输时连接被重置的次数。</p>
<h3 id="F1（241）LBA写入总数-Total-LBAs-Written"><a href="#F1（241）LBA写入总数-Total-LBAs-Written" class="headerlink" title="F1（241）LBA写入总数 Total LBAs Written"></a>F1（241）LBA写入总数 Total LBAs Written</h3><p>LBA写入数的累计。</p>
<h3 id="F1（241）写入剩余寿命-Lifetime-Writes-from-Host"><a href="#F1（241）写入剩余寿命-Lifetime-Writes-from-Host" class="headerlink" title="F1（241）写入剩余寿命 Lifetime Writes from Host"></a>F1（241）写入剩余寿命 Lifetime Writes from Host</h3><p>自硬盘启用后主机向硬盘写入的数据总量，以4个字节表示，每写入64GB字节作为一个单位。</p>
<h3 id="F2（242）LBA读取总数-Total-LBAs-Read"><a href="#F2（242）LBA读取总数-Total-LBAs-Read" class="headerlink" title="F2（242）LBA读取总数 Total LBAs Read"></a>F2（242）LBA读取总数 Total LBAs Read</h3><p>LBA读取数的累计。某些SMART读取工具会显示负的数据值，是因为采用了48位LBA，而不是32位LBA。</p>
<h3 id="F2（242）读取剩余寿命-Lifetime-Reads-from-Host"><a href="#F2（242）读取剩余寿命-Lifetime-Reads-from-Host" class="headerlink" title="F2（242）读取剩余寿命 Lifetime Reads from Host"></a>F2（242）读取剩余寿命 Lifetime Reads from Host</h3><p>自硬盘启用后主机从硬盘读取的数据总量，以4个字节表示，每读取64GB字节作为一个单位。</p>
<h3 id="FA（250）读取错误重试率-Read-Error-Retry-Rate"><a href="#FA（250）读取错误重试率-Read-Error-Retry-Rate" class="headerlink" title="FA（250）读取错误重试率 Read Error Retry Rate"></a>FA（250）读取错误重试率 Read Error Retry Rate</h3><p>从磁盘上读取时出错的次数。</p>
<h3 id="FE（254）自由坠落保护-Free-Fall-Protection"><a href="#FE（254）自由坠落保护-Free-Fall-Protection" class="headerlink" title="FE（254）自由坠落保护 Free Fall Protection"></a>FE（254）自由坠落保护 Free Fall Protection</h3><p>现在有些笔记本硬盘具有自由坠落保护功能，当硬盘内置的加速度探测装置检测到硬盘位移时，会立即停止读写操作，将磁头臂复位。这个措施防止了磁头与盘片之间发生摩擦撞击，提高了硬盘的抗震性能。这个参数的数据里记录了这一保护装置动作的次数。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/28/jdk-juc-%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/28/jdk-juc-%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">并发集合框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-28 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-28T00:00:00+08:00">2024-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 14:38:18" itemprop="dateModified" datetime="2025-04-27T14:38:18+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/juc/" itemprop="url" rel="index"><span itemprop="name">juc</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><h2 id="并发安全-Map"><a href="#并发安全-Map" class="headerlink" title="并发安全 Map"></a>并发安全 Map</h2><p><code>ConcurrentSkipListMap</code>: 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="JDK-1-7-Segment-ReentrantLock"><a href="#JDK-1-7-Segment-ReentrantLock" class="headerlink" title="JDK 1.7: Segment(ReentrantLock)"></a>JDK 1.7: Segment(ReentrantLock)</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java7_concurrenthashmap.png" alt="Java7 ConcurrentHashMap 存储结构"></p>
<p>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，</p>
<p>JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 继承自 <code>ReentrantLock</code>。每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</p>
<ul>
<li><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。</li>
<li><code>Segment</code> 数组中的每个元素包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 数组属于链表结构。</li>
</ul>
<p>首先将数据分为一段一段（这个“段”就是 <code>Segment</code>）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。</p>
<p><code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组，<code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>。 <code>Segment</code> 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。</p>
<p><code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p>
<p>JDK 1.7 最大并发度是 Segment 的个数，默认是 16</p>
<h4 id="JDK-1-8-Node-CAS-synchronized"><a href="#JDK-1-8-Node-CAS-synchronized" class="headerlink" title="JDK 1.8: Node+CAS+synchronized"></a>JDK 1.8: Node+CAS+synchronized</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构"></p>
<p>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是<mark>直接用 <code>Node</code></mark> 数组+链表+红黑树的数据结构来实现，并发控制使用 <mark><code>synchronized</code> 和 CAS</mark> 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p>
<p>JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</p>
<ul>
<li><p>每个 <strong>桶（bucket）</strong> 对应一个链表或红黑树，用于解决<strong>哈希冲突</strong>。</p>
</li>
<li><p>如果链表长度超过一定阈值（默认为 8），链表会自动转换为<strong>红黑树</strong>，提高查询效率。</p>
</li>
<li><p>红黑树的情况需要使用 <code>TreeNode</code>。当冲突链表达到一定长度时，链表会转换成红黑树。<code>TreeNode</code>是存储红黑树节点，被<code>TreeBin</code>包装。<code>TreeBin</code>通过<code>root</code>属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所以在 <code>ConcurrentHashMap</code> 中<code>TreeBin</code>通过<code>waiter</code>属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。</p>
</li>
</ul>
<p>JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</p>
<p><strong>链表的线程安全性</strong> </p>
<p>在 <strong>ConcurrentHashMap</strong> 中，链表本身不是直接加锁的，而是通过更细粒度的<strong>CAS（Compare-And-Swap）机制</strong>和<strong>自旋锁</strong>来保证线程安全：</p>
<ol>
<li><strong>插入节点</strong>时通过 CAS 更新表头或表尾。</li>
<li><strong>查询节点</strong>时允许并发读操作，而不会阻塞其他线程。</li>
<li><strong>扩容操作</strong>采用链表迁移的方式，通过分段迁移减少阻塞时间。</li>
</ol>
<h4 id="不保证复合操作原子性"><a href="#不保证复合操作原子性" class="headerlink" title="不保证复合操作原子性"></a>不保证复合操作原子性</h4><p><code>ConcurrentHashMap</code> 是线程安全的，意味着它可以保证多个线程同时对它进行读写操作时，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 <code>HashMap</code> 多线程操作导致死循环问题。但是，这并不意味着它可以保证所有的复合操作都是原子性的，一定不要搞混了！</p>
<p>复合操作是指由多个基本操作(如<code>put</code>、<code>get</code>、<code>remove</code>、<code>containsKey</code>等)组成的操作，例如先判断某个键是否存在<code>containsKey(key)</code>，然后根据结果进行插入或更新<code>put(key, value)</code>。这种操作在执行过程中可能会被其他线程打断，导致结果不符合预期。</p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p><code>Hashtable</code>(同一把锁) :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低</p>
<h2 id="并发安全-List"><a href="#并发安全-List" class="headerlink" title="并发安全 List"></a>并发安全 List</h2><h3 id="线程不安全-ArrayList"><a href="#线程不安全-ArrayList" class="headerlink" title="线程不安全 ArrayList"></a>线程不安全 ArrayList</h3><p>我们通常使用的ArrayList就是线程不安全的，举个简单的例子</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestList</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] <span class="keyword">args</span></span>)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.<span class="keyword">add</span>(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.<span class="keyword">out</span>.println(list);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并发修改异常</span></span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;4&quot;</span> java.util.ConcurrentModificationException</span><br><span class="line">   at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">909</span>)</span><br><span class="line">   at java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">859</span>)</span><br><span class="line">   at java.util.AbstractCollection.toString(AbstractCollection.java:<span class="number">461</span>)</span><br><span class="line">   at java.lang.String.valueOf(String.java:<span class="number">2994</span>)</span><br><span class="line">   at java.io.PrintStream.println(PrintStream.java:<span class="number">821</span>)</span><br><span class="line">   at com.hnguigu.<span class="keyword">unsafe</span>.TestList.lambda$main$<span class="number">0</span>(TestList.java:<span class="number">20</span>)</span><br><span class="line">   at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案，有以下几种！</strong></p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">concurrent</span>.<span class="property">CopyOnWriteArrayList</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestList</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解决方案</span></span><br><span class="line"><span class="comment">         * 1. List&lt;String&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line"><span class="comment">         * 2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span></span><br><span class="line"><span class="comment">         * 3. List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="title class_">List</span>&lt;<span class="title class_">String</span>&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                list.<span class="title function_">add</span>(<span class="variable constant_">UUID</span>.<span class="title function_">randomUUID</span>().<span class="title function_">toString</span>().<span class="title function_">substring</span>(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(list);</span><br><span class="line">            &#125;,<span class="title class_">String</span>.<span class="title function_">valueOf</span>(i)).<span class="title function_">start</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写入时复制（CopyOnWrite，简称COW）思想是计算机程序设计领域中的一种通用优化策略。</p>
<p>CopyOnWrite容器即写入时复制的容器。<strong>通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。</strong>这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<p>读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据。CopyOnWrite并发容器用于读多写少的并发场景。</p>
<blockquote>
<p>CopyOnWriteArrayList 比 Vector 厉害在哪里？</p>
</blockquote>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20221224114551267-580082797.png" alt="CopyOnWrite"></p>
<p>CopyOnWriteArrayList底层采用了Lock锁，是JDK层面的，效率高！</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20221223214340940-165732240.png" alt="VectorSource"></p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p>
<ul>
<li>CopyOnWriteArrayList 并发安全且性能比 Vector 好。Vector 是增删改查方法都加了synchronized 来保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降，而 CopyOnWriteArrayList 只是在增删改上加锁，但是读不加锁，在读方面的性能就好于 Vector。</li>
<li>线程安全的 <code>List</code>，在读多写少的场合性能非常好，远远好于 <code>Vector</code>。</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据一致性问题。这种实现只是保证数据的<strong>最终一致性</strong>，不能保证数据的<strong>实时一致性</strong>。在添加到拷贝数据而还没进行替换的时候，读到的仍然是旧数据。</li>
<li>内存占用问题。如果对象比较大，内存写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。 这个时候，我们应该考虑其他的容器，例如 ConcurrentHashMap。</li>
<li>由于实际使用中可能没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点 多，每次 add/set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种 操作分分钟引起故障。</li>
</ul>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>Vector底层采用了Synchronized加锁的方式，保证了数据的安全性，但是效率低下！</p>
<p>解释一下：Synchronized是Java内置的机制，是JVM层面的，效率低是因为底层操作依赖于操作系统，操作系统切换线程要从用户态切换到内核态，花费很多时间。</p>
<h2 id="并发安全-Set"><a href="#并发安全-Set" class="headerlink" title="并发安全 Set"></a>并发安全 Set</h2><h3 id="线程不安全-HashSet"><a href="#线程不安全-HashSet" class="headerlink" title="线程不安全 HashSet"></a>线程不安全 HashSet</h3><p>Set和List同样是多线程下不安全的集合类，同样会报并发修改异常！</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestSet</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] <span class="keyword">args</span></span>)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; <span class="keyword">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">set</span>.<span class="keyword">add</span>(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="keyword">set</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestSet</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] <span class="keyword">args</span></span>)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解决方案</span></span><br><span class="line"><span class="comment">         * set集合没有可替换的集合</span></span><br><span class="line"><span class="comment">         * 1. Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span></span><br><span class="line"><span class="comment">         * 2. Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Set&lt;String&gt; <span class="keyword">set</span> = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">set</span>.<span class="keyword">add</span>(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="keyword">set</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和面试官谈到这里，一般都会问hashSet的底层实现原理。<br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20221224125000674-1551081400.png" alt="hashSetSource"></p>
<p>底层其实就是用hashMap实现的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20221224125144809-649163275.png" alt="hashSetAdd"></p>
<p>HashSet底层使用了哈希表来支持的，特点：存储快 往HashSet添加元素的时候，HashSet会先调用元素的HashCode方法得到元素的哈希值，然后通过元素的哈希值经过异或移位等运算，就可以算出该元素在哈希表中的存储位置。如果算出的元素存储的位置目前没有任何元素存储，那么该元素可以直接存储在该位置上；如果算出的元素的存储位置上目前已经有了其他的元素，那么还会调用该元素的equals方法 ，与该位置的元素进行比较一次，如果过equals方法返回的是true，那么该位置上的元素就会被视为重复元素，不允许被添加，如果false，则允许添加。</p>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p><code>BlockingQueue</code> 是 Java 并发包（<code>java.util.concurrent</code>）中的一个接口，专门用于<strong>线程安全的生产者-消费者模型</strong>。它支持线程在队列为空或已满时自动阻塞，从而简化了多线程编程中的同步问题。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/arrayblockingqueue-class-diagram.png" alt="ArrayBlockingQueue 类图"></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>线程安全：<ul>
<li>内部使用锁和条件变量（Condition）实现线程安全操作。</li>
</ul>
</li>
<li>阻塞机制：<ul>
<li>当队列为空时，获取元素的线程会被阻塞，直到队列中有可用元素。</li>
<li>当队列已满时，添加元素的线程会被阻塞，直到队列有空间。</li>
</ul>
</li>
<li>常用场景：<ul>
<li><strong>生产者-消费者模型</strong>，生产者向队列中添加数据，消费者从队列中取数据。</li>
<li>控制线程执行顺序或流量，避免资源争抢。</li>
</ul>
</li>
</ol>
<p><code>BlockingQueue</code>: 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><code>ArrayBlockingQueue</code> </p>
<ul>
<li><strong>best performance</strong> </li>
<li>单lock 双condition 算法，必须显式设置容量</li>
<li>底层是数组，有界队列，如果我们要使用生产者-消费者模式，这是非常好的选择。</li>
</ul>
<p><code>LinkedBlockingQueue</code> / <code>LinkedBlockingDeque</code></p>
<ul>
<li>2 locks 2 conditions，默认Integer.MAX_VALUE</li>
<li>底层是链表，可以当做无界和有界队列来使用，所以大家不要以为它就是无界队列。</li>
</ul>
<p><code>SynchronousQueue</code></p>
<ul>
<li>每次插入操作必须等待一个取出操作，否则就会阻塞，适合高并发传递数据。</li>
<li>不允许null</li>
<li>本身不带有空间来存储任何元素，使用上可以选择公平模式和非公平模式。</li>
</ul>
<p><code>DelayQueue</code></p>
<ul>
<li>延时队列，只有到期的元素才能被取出，适合定时任务或延迟执行场景。</li>
<li>elements must implement <code>java.util.concurrent.Delayed</code> </li>
</ul>
<p><code>LinkedTransferQueue</code></p>
<ul>
<li>waits for consumer to consume the element (message passing need to be guaranteed)</li>
</ul>
<p><code>ConcurrentLinkedQueue</code>:</p>
<ul>
<li>高效的并发队列，使用链表实现。一个线程安全的 <code>LinkedList</code>，这是一个非阻塞队列。</li>
</ul>
<p><code>PriorityBlockingQueue</code></p>
<ul>
<li>concurrent version of <code>PriorityQueue</code></li>
<li>无界队列，基于数组，数据结构为二叉堆，数组第一个也是树的根节点总是最小值。</li>
<li>基于优先级堆实现的无界阻塞队列，元素按优先级排序，不保证 FIFO。</li>
</ul>
<h3 id="主要方法-put-take-offer-poll"><a href="#主要方法-put-take-offer-poll" class="headerlink" title="主要方法: put-take offer-poll"></a>主要方法: put-take offer-poll</h3><p>add、remove实际上是对offer的封装</p>
<ul>
<li><strong>插入元素：</strong><ul>
<li><code>put(E e)</code>：如果队列已满，阻塞等待空间。</li>
<li><code>offer(E e)</code>: 非阻塞插入<ul>
<li><code>offer(E e, long timeout, TimeUnit unit)</code>：带自旋的非阻塞插入</li>
</ul>
</li>
</ul>
</li>
<li><strong>取出元素：</strong> <ul>
<li><code>take()</code>：如果队列为空，阻塞等待数据。</li>
<li><code>poll()</code>: 非阻塞获取<ul>
<li><code>poll(long timeout, TimeUnit unit)</code>：带自旋的非阻塞获取</li>
</ul>
</li>
</ul>
</li>
<li><strong>检查队列状态：</strong><ul>
<li><code>size()</code>：返回当前元素数量。</li>
<li><code>remainingCapacity()</code>：返回剩余可用空间。</li>
</ul>
</li>
<li>队列数据迁移<ul>
<li><code>int elemCount = queue.drainTo(list);</code></li>
<li> <code>drainTo</code> 会一次性将队列中所有元素存放到列表，如果队列中有元素，且成功存到 list 中则 <code>drainTo</code> 会返回本次转移到 list 中的元素数，若队列为空，<code>drainTo</code> 则直接返回 0</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    queue.put(i); <span class="comment">// 阻塞插入</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Produced: &quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> queue.take(); <span class="comment">// 阻塞获取</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumed: &quot;</span> + value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>实际上就是生产者——消费者模式的具体实现</p>
<p>加锁访问共享区域，阻塞使用的是和锁相关的condition条件变量，细化了等待条件</p>
<p>condition.await    condition.signal/signalAll   就是使用了这个细节</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#define MAXSIZE <span class="number">8</span></span><br><span class="line"><span class="type">int</span> buffer[MAXSIZE];</span><br><span class="line"><span class="type">int</span> <span class="variable">fill_ptr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">use_ptr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    buffer[fill_ptr] = value;</span><br><span class="line">	fill_ptr = (fill_ptr + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> buffer[use_ptr];</span><br><span class="line">    fill_ptr = (fill_ptr + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">cond_t notEmpty,notFull;</span><br><span class="line">mutex_t mutex;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; loops;i++)&#123;</span><br><span class="line">        mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(count == MAXSIZE)</span><br><span class="line">            cond_wait(&amp;notEmpty, &amp;mutex);</span><br><span class="line">    	put(i);</span><br><span class="line">        printf(<span class="string">&quot;producer:%d puts value:%d&quot;</span>, gettid(), i);</span><br><span class="line">        cond_signal((&amp;notFull);</span><br><span class="line">    	mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; loops;i++)&#123;</span><br><span class="line">        mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(count == <span class="number">0</span>)</span><br><span class="line">            cond_wait(&amp;isEmpty, &amp;mutex);</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> get();</span><br><span class="line">        printf(<span class="string">&quot;pid:%d gets value:%d&quot;</span>, gettid(), value);</span><br><span class="line">        cond_signal(&amp;isFull);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                    </span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/24/digital-80%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/24/digital-80%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">如何定位端口占用问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-24 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-24T00:00:00+08:00">2024-10-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-08 13:47:08" itemprop="dateModified" datetime="2025-05-08T13:47:08+08:00">2025-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">数码</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>80端口占用问题</p>
<p>找到占用者，其pid为4</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025203515838.png" alt="image-20241025203515838"></p>
<p>根据pid找到其名为System，不能直接taskKill</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025203538420.png" alt="image-20241025203538420"></p>
<p>netsh http show servicestate</p>
<p>发现是defaultAppPool在占用，控制器进程的pid为4671</p>
<p>任务管理器中找到4671，发现是iis Publishing 服务，禁用</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/20/redis-review-optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/20/redis-review-optimization/" class="post-title-link" itemprop="url">redis-review 项目优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-20T00:00:00+08:00">2024-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-13 16:24:28" itemprop="dateModified" datetime="2025-05-13T16:24:28+08:00">2025-05-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="redis-review"><a href="#redis-review" class="headerlink" title="redis-review"></a>redis-review</h1><p>配置环境： Nginx + SpringBoot + RabbitMQ + Redis</p>
<h2 id="redis-key-设计"><a href="#redis-key-设计" class="headerlink" title="redis key 设计"></a>redis key 设计</h2><p>STRING </p>
<ul>
<li><code>sign:&#123;userId&#125;:202411</code> 2024年11月的userId的签到信息 （bitmap）</li>
<li><code>incr:order:2024:11:10</code> 2024年11月10号的订单序列号serialNumber，唯一id（timestamp&lt;&lt;32 | serialNumber）</li>
<li><code>seckill:stock:&#123;voucherId&#125;</code> voucherId的优惠券对应的库存</li>
<li><code>cache:shop:&#123;shopId&#125;</code> shopId的商铺信息</li>
<li><code>login:code:&#123;phoneNumber&#125;</code> 验证码信息</li>
</ul>
<p>LIST </p>
<ul>
<li><code>cache:shoptype</code>（商铺类型信息JSON数组）</li>
</ul>
<p>ZSET </p>
<ul>
<li><p><code>shop:geo:&#123;shopId&#125;</code> 商铺地理位置信息</p>
</li>
<li><p><code>blog:liked:&#123;blogId&#125;</code> blogId的博客点赞信息，包括userId 以及对应的score（unix时间）</p>
</li>
<li><p><code>feed:&#123;userId&#125;</code> userId 的收件箱，保存笔记时推送到所有粉丝（看看谁follow了我）包括了 blogId 以及对应的score </p>
</li>
</ul>
<p>SET</p>
<ul>
<li><code>follows:&#123;userId&#125;</code> userId 关注的人</li>
<li><code>seckill:order:&#123;voucherId&#125;</code> 抢过voucherId的优惠券的人的集合</li>
</ul>
<p>HASH </p>
<ul>
<li><code>login:token:&#123;token&#125;</code> 存储token对应的userDTO </li>
</ul>
<h2 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h2><p>blog blog评论 关注的人(x在t时间关注了y) 用户表 </p>
<p>商铺 商铺类别</p>
<p>券 秒杀券 秒杀券订单</p>
<h2 id="热key-大key"><a href="#热key-大key" class="headerlink" title="热key 大key"></a>热key 大key</h2><p>在处理热key、大key以及分表问题时，可以采用以下策略进行优化：</p>
<p>• <strong>热Key</strong>：多级缓存 + 分片 + 异步更新。<br>• <strong>大Key</strong>：拆分 + 异步删除 + 设计规避。<br>• <strong>分表</strong>：合理分片规则 + 中间件 + 缓存加速。<br>• <strong>监控</strong>：实时监控Key大小和QPS，提前预防问题。</p>
<h3 id="热Key处理方案"><a href="#热Key处理方案" class="headerlink" title="热Key处理方案"></a>热Key处理方案</h3><ol>
<li><p><strong>监控与识别</strong><br>• 使用Redis监控工具（如<code>redis-cli --hotkeys</code>、<code>MONITOR</code>命令）或APM系统（如Prometheus）识别高频访问的key。<br>• 业务侧预判热点（如秒杀商品ID、热门话题），提前介入优化。</p>
</li>
<li><p><strong>多级缓存</strong><br>• <strong>本地缓存</strong>：结合Guava Cache或Caffeine，将热key缓存在应用服务器本地，减少Redis压力。<br>• <strong>分布式缓存冗余</strong>：复制热key到多个Redis实例（如<code>key:1</code>, <code>key:2</code>），通过随机访问分散压力。</p>
</li>
<li><p><strong>缓存续期与互斥锁</strong><br>• <strong>逻辑过期</strong>：Value中存储过期时间，异步更新缓存，避免物理过期后大量请求穿透到DB。<br>• <strong>互斥锁（Mutex Lock）</strong>：缓存失效时，仅允许一个线程重建数据，其他线程等待或返回降级结果。</p>
</li>
<li><p><strong>读写分离与分片</strong><br>• 使用Redis Cluster或Codis分片，分散热key压力。<br>• 读写分离：通过从节点处理读请求，主节点处理写请求。</p>
</li>
</ol>
<h3 id="大Key处理方案"><a href="#大Key处理方案" class="headerlink" title="大Key处理方案"></a>大Key处理方案</h3><ol>
<li><p><strong>拆分与分片</strong><br>• <strong>横向拆分</strong>：将大Hash/List按字段或元素拆分（如<code>user:1000:info</code>拆为<code>user:1000:base</code>、<code>user:1000:contact</code>）。<br>• <strong>分片存储</strong>：对Key添加分片后缀（如<code>user:&#123;id%10&#125;:profile</code>），分散存储。</p>
</li>
<li><p><strong>异步删除</strong><br>• 使用<code>UNLINK</code>替代<code>DEL</code>，非阻塞删除大Key。<br>• 渐进式删除：通过脚本分批删除Hash/Set元素（如<code>HSCAN</code>遍历删除）。</p>
</li>
<li><p><strong>压缩与存储优化</strong><br>• 序列化优化：使用Protobuf或MessagePack替代JSON。<br>• 冷热分离：将大Key中低频数据存入MySQL/HBase，高频数据保留在Redis。</p>
</li>
<li><p><strong>设计规避</strong><br>• 避免单个Key存储超过1MB的数据。<br>• 使用HyperLogLog替代大Set统计UV，或使用TimeSeries存储时序数据。</p>
</li>
</ol>
<h3 id="分表方案（以MySQL为例）"><a href="#分表方案（以MySQL为例）" class="headerlink" title="分表方案（以MySQL为例）"></a>分表方案（以MySQL为例）</h3><ol>
<li><p><strong>水平分表</strong><br>• <strong>规则分片</strong>：按哈希（如<code>user_id % 100</code>）、范围（如时间戳）或一致性哈希拆分数据。<br>• <strong>中间件</strong>：使用ShardingSphere、Vitess等工具自动路由查询。</p>
</li>
<li><p><strong>垂直分表</strong><br>• 将大表按列拆分（如用户基础信息表<code>user_base</code>与扩展信息表<code>user_extend</code>），减少单行数据量。</p>
</li>
<li><p><strong>全局ID与查询优化</strong><br>• 分布式ID生成（雪花算法、Redis自增ID）避免主键冲突。<br>• 冗余字段或索引表：通过异步维护冗余字段（如商户ID+订单ID）支持多维度查询。</p>
</li>
<li><p><strong>结合Redis</strong><br>• 缓存分表路由信息（如<code>user_shard:1000 -&gt; shard_2</code>），加速查询。<br>• 热数据缓存：将分表后的热数据单独缓存，降低DB压力。</p>
</li>
</ol>
<h3 id="Redis分片与集群"><a href="#Redis分片与集群" class="headerlink" title="Redis分片与集群"></a>Redis分片与集群</h3><ol>
<li><p><strong>Redis Cluster</strong><br>• 自动分片（16384 slots），支持水平扩展和高可用。<br>• 通过<code>CRC16(key) % 16384</code>计算slot，分散数据。</p>
</li>
<li><p><strong>客户端分片</strong><br>• 使用一致性哈希算法（如Jedis的<code>ShardedJedis</code>）在客户端路由请求。</p>
</li>
<li><p><strong>Proxy方案</strong><br>• 通过Twemproxy或Codis代理层管理分片，对业务透明。</p>
</li>
</ol>
<h1 id="项目剖析"><a href="#项目剖析" class="headerlink" title="项目剖析"></a>项目剖析</h1><h2 id="Login-Redis-Token"><a href="#Login-Redis-Token" class="headerlink" title="Login (Redis Token)"></a>Login (Redis Token)</h2><ol>
<li><p>短信登录的短信怎么发送的?</p>
<p>（使用hutool生成的随机六位数验证码）</p>
</li>
<li><p>如何标识用户</p>
<p>（主要是唯一的id主键，而登录靠的是也是唯一的手机号）</p>
</li>
<li><p>项目的权限刷新什么意思</p>
<p>（token具有ttl期，用户如果浏览网页就会刷新其ttl）</p>
</li>
</ol>
<p><strong>原来</strong>：tomcat 的 HttpSession 是集中的，如果要扩展的话同步是一个大问题，并且可能过多占用服务器的内存。</p>
<p><strong>改进</strong>：<mark>Redis Token</mark>是分布式的，天生不存在同步问题。</p>
<ul>
<li><strong>Redis</strong>：使用 Hash 数据结构—— KEY: token:xxxxxxxx, VALUE: UserDTO的字段信息</li>
<li><strong>拦截器</strong>：配置到需要拦截器的地方（个人中心等位置）根据请求头里的 token 查到对应的UserDTO，将其放入<mark>ThreadLocal</mark>，放行，同时也会刷新 token 有效期。<mark>核心方法：preHandle + afterCompletion</mark><ul>
<li>ThreadLocal 使用：<code>get()</code>,<code>set()</code> 在finally块调用<code>remove()</code> 用途 Spring 数据库连接、事务管理</li>
<li>内存泄露：每个线程有个 Map，键是 tl（弱引用），值是对应的值（强引用），如果线程没有销毁，但是 tl 销毁了，就容易泄露内存。</li>
</ul>
</li>
<li><strong>问题</strong>：访问别的页面也需要刷新，不然不浏览那些需要拦截器的页面就不会刷新token，莫名其妙就会过期</li>
<li><strong>解决</strong>：新加一个拦截器，负责查token、保存到tl、刷新，放行所有。原先的拦截器只负责从tl查询用户，tl 里没有就拒绝</li>
<li><strong>其他缺点</strong>：仍然依赖内存（redis是内存数据库） + redis接口调用会增加复杂性。需要注意的是，虽然这种方式支持分布式系统，但是根本上还是和 HttpSession 一样的<strong>中心化</strong>。</li>
</ul>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653320764547.png" alt="优化拦截器" style="zoom:33%;" />

<p>JWT：去中心化，服务端压力减小，便于分布式系统使用。基本信息可直接放在token中。功能权限较少可以直接放在token中，用bit位表示用户所具有的功能权限。但是缺点也很明显，签发以后就不能主动让其失效，拿到了就可以进行重放攻击。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>使用 Redis 作为商户信息缓存，避免大量请求直接打到数据库引发宕机，采取<mark>主动更新、旁路缓存</mark>的方法保证数<br>据库与 Redis 之间的缓存一致性问题。使用<mark>布隆过滤器</mark>解决商户信息的缓存穿透问题，使用 <strong>Redis 集群</strong>等方式减<br>小缓存雪崩的概率，使用<mark>逻辑过期</mark>解决缓存击穿。</p>
<p><strong>内存更新</strong>：</p>
<ul>
<li>内存淘汰机制和TTL（对于低一致性场景）</li>
<li><mark>主动更新</mark>：编写业务逻辑，修改数据库的同时操作缓存，解决一致性问题。（对于高一致性场景）✅</li>
</ul>
<p><strong>一致性解决方案</strong>：</p>
<ul>
<li><strong>cache aside 旁路缓存</strong> 编码使用客户端自行将数据写入cache ✅ 适合读多写少</li>
<li>读写穿透：封装了旁路缓存功能，其工作由cache层的服务自动完成，但是redis并不支持写入db</li>
<li>异步缓存写入：只操作cache，其他线程异步写到db。一般是写密集允许短暂的数据不一致</li>
</ul>
<p><strong>Cache Aside</strong>：</p>
<ul>
<li>选择删除cache，<em>更新导致的无效写比较多（更新多次但只有最后一次被查询），并且线程安全问题难以解决：<strong>要求数据库和缓存写入都要成功</strong>，此时有可能A更新到v1，线程B突然插进来把缓存更新到v2，最后A把脏数据v1更新到缓存，如果缓存更新涉及多表的查询就更加难以维护。</em> <strong>cache删除和db更新放入一个事务</strong></li>
<li><strong>删缓存、更新db的先后顺序</strong>：读未命中、更新操作的互相穿插<ul>
<li>选择先更新db后删除cache。导致不一致的情况：读未命中的过程中插进来一个更新操作，最后缓存里是旧数据</li>
<li><em>如果反过来，先删cache，更新db过程中进来一个查询的又把旧数据填充到缓存里，最后导致db和cache不一致。</em></li>
</ul>
</li>
<li><strong>如果缓存删除失败怎么办</strong>？（异步重试）<ul>
<li>单机可用线程池重试，分布式用MQ</li>
<li><strong>延迟双删：删完之后，隔段时间再尝试删一次。</strong></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>解决方案</strong></th>
<th><strong>适用性</strong></th>
</tr>
</thead>
<tbody><tr>
<td>瞬时故障</td>
<td>同步重试（3次以内）</td>
<td>低并发，容忍短暂阻塞</td>
</tr>
<tr>
<td>缓存服务不稳定</td>
<td>异步队列 + 重试（最终一致性）</td>
<td>高并发，要求最终一致</td>
</tr>
<tr>
<td>长期不可用</td>
<td>降级读数据库 + 告警</td>
<td>高一致性要求场景</td>
</tr>
<tr>
<td>无法接受任何不一致</td>
<td>版本号校验 + 同步双写</td>
<td>金融、交易等强一致性场景</td>
</tr>
</tbody></table>
<ul>
<li><strong>如果删除失败以后读脏数据怎么办</strong>？<ul>
<li>写入标记+短ttl：删除失败之后写入一个特殊的key，短ttl，标记这个缓存可能不准确，然后在正常读缓存逻辑之前加上if判断即可，遇到特殊key就直读数据库，统计缓存失败率，可以据此熔断。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>解决方案</strong></th>
<th><strong>适用性</strong></th>
</tr>
</thead>
<tbody><tr>
<td>短暂删除失败（网络抖动）</td>
<td><strong>标记待修复</strong> + 读取时主动修复</td>
<td>高并发，允许短暂不一致</td>
</tr>
<tr>
<td>长期缓存服务不可用</td>
<td>熔断降级 + 直读数据库</td>
<td>强一致性要求场景</td>
</tr>
<tr>
<td>数据版本频繁变更</td>
<td><strong>版本号校验</strong> + 异步补偿任务</td>
<td>金融、订单等关键业务</td>
</tr>
<tr>
<td>灰度验证修复效果</td>
<td>流量染色 + 强制对比</td>
<td>需要验证缓存一致性的场景</td>
</tr>
</tbody></table>
<p><mark>缓存穿透和缓存击穿都实现在 <strong>CacheClient</strong> 中</mark></p>
<p><strong>缓存穿透</strong>：恶意查询db里不存在的数据，导致db崩溃</p>
<ul>
<li>缓存空对象设置ttl：实现简单，维护方便。<em>造成短期的不一致，额外内存消耗。</em> <ul>
<li>适合空key数目可控的场景，支持动态更新</li>
</ul>
</li>
<li><strong>布隆过滤器</strong>：内存占用较少，没有多余key。<em>实现复杂，可能误判。</em>   本项目使用 Guava 实现。<ul>
<li>适合海量数据，且需要高效拦截绝对不存在的请求时（如用户注册校验）需要预先初始化 @PostConstruct </li>
<li>容量由bitmap大小与哈希函数数量决定，可能会满，满了以后可以扩容，可以业务层兜底（比如缓存空对象）。</li>
<li>删除、扩容：不支持。</li>
<li><strong>计数布隆过滤器</strong>(Counting Bloom Filter): 用空间复杂度换来删除功能，bit改为计数器，查询时所有位置的计数器都大于0才算存在。插入时在所有位置加1，删除时在所有位置减1，只要有一个归0就认定其不存在。</li>
<li><strong>布谷鸟过滤器</strong>(Cuckoo Filter): <strong>指纹</strong>使用抗碰撞性强的哈希函数计算哈希值后截取低位获得。使用<strong>桶数组</strong>存储指纹，一个桶存四个指纹(连续,cpucache)。使用与当前指纹的哈希值异或的方式计算出另一个指纹副本的桶索引。<ul>
<li>插入时，第一个桶索引 i1= hash(x) 计算，第二个桶索引 i2 = i1 ⊕ hash(fingerprint(x))。桶只要有一个空位就可以插入，如果直接和指纹本身异或，在指纹跟桶数组大小差距悬殊时两个桶离得较近不利于均匀分布。如果没有空位就从其中挑一个指纹 f’ 迁出然后迁入，对于f’我们直接使用当前的桶索引和 f’ 进行异或就能计算出就能 f’ 备用桶的位置。</li>
<li>查询时，看两个桶里面是否存在 x 的指纹，有指纹就算存在。删除时，从两个桶里删除匹配的指纹。</li>
<li>降低误判率：增大指纹长度，减小桶的尺寸</li>
<li>大多数情况下，选择2个哈希函数，桶的尺寸选择4，能够达到最佳或接近最佳的空间效率的假阳性率。</li>
</ul>
</li>
<li>动态数据集应该预防写满，或者使用多级过滤，例如使用 HashSet 过滤高频数据，然后用BF处理长尾数据</li>
<li>可以使用功能更加强大的 RedisBloom</li>
</ul>
</li>
</ul>
<p><strong>缓存击穿</strong>：一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。常见的解决方案有两种：</p>
<ul>
<li>互斥锁 MUTEX。线程 1 未命中，拿到锁去<strong>同步地重建缓存</strong>，线程 2 此时也紧随其后，拿不到锁就重复查询缓存。直到重建完成，线程 2 就能拿到重建的缓存值。优点是<strong>一致性可以确保</strong>，缺点是重建期间其他的线程会一直<strong>同步递归调用</strong>。</li>
<li>逻辑过期 LOGICAL EXPIRE。不存在未命中情况，发现过期就拿到锁然后提交一个重建缓存的任务（异步重建完之后finally释放锁），然后直接返回旧值。优点是<strong>响应比较快</strong>，是非阻塞的，缺点是一致性受影响。</li>
</ul>
<p><strong>缓存雪崩</strong>：同一时段大量的缓存key同时失效或redis宕机</p>
<ul>
<li>给不同的Key的TTL添加随机值</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
<h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><h3 id="RestControllerAdvice-和-ExceptionHandler"><a href="#RestControllerAdvice-和-ExceptionHandler" class="headerlink" title="@RestControllerAdvice 和 @ExceptionHandler"></a>@RestControllerAdvice 和 @ExceptionHandler</h3><p>对于更简单的异常处理，推荐使用 <code>@RestControllerAdvice</code>：所有方法默认返回 JSON，等价于自动添加 <code>@ResponseBody</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalApiExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动返回 JSON，无需 @ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(UserNotFoundException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.NOT_FOUND)</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleUserNotFound</span><span class="params">(UserNotFoundException ex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(ex.getMessage(), <span class="number">404</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更灵活的控制：自定义状态码和响应体</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ValidationException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorResponse&gt; <span class="title function_">handleValidationError</span><span class="params">(ValidationException ex)</span> &#123;</span><br><span class="line">        <span class="type">ErrorResponse</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(ex.getMessage(), <span class="number">400</span>);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.badRequest().body(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项</p>
<ul>
<li><strong>执行顺序</strong>：解析器按注册顺序执行。返回非空 <code>ModelAndView</code> 时终止处理。</li>
<li><strong>默认解析器</strong>：使用 <code>extendHandlerExceptionResolvers</code> 避免覆盖Spring默认解析器（如处理<code>@ExceptionHandler</code>的解析器）。</li>
<li><strong>与Spring Boot整合</strong>：在Spring Boot中，可结合 <code>@ControllerAdvice</code> 和 <code>ErrorController</code> 进行全局处理。</li>
</ul>
<h3 id="Result-封装"><a href="#Result-封装" class="headerlink" title="Result 封装"></a>Result 封装</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean success;</span><br><span class="line">    <span class="keyword">private</span> String errorMsg;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="literal">true</span>, <span class="literal">null</span>, data, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">(List&lt;?&gt; data, Long total)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="literal">true</span>, <span class="literal">null</span>, data, total);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">fail</span><span class="params">(String errorMsg)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="literal">false</span>, errorMsg, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="秒杀抢购"><a href="#秒杀抢购" class="headerlink" title="秒杀抢购"></a>秒杀抢购</h2><p>• 使用乐观锁避免秒杀券超卖，同时提高并发。通过控制事务的粒度以及动态代理保证事务的有效性。使用 Lua 脚本解决秒杀券更新的原子性问题。 Redisson 分布式 锁解决集群环境下一人一单可能导致的并发安全问题。在 3000 并发测试中成功拦截 100%的重复请求</p>
<h3 id="乐观锁-防止超卖"><a href="#乐观锁-防止超卖" class="headerlink" title="乐观锁 防止超卖"></a>乐观锁 防止超卖</h3><p><strong>做完&gt;0库存判断之后：</strong></p>
<ul>
<li>原来：不检查直接扣【超卖】</li>
<li>改进1：扣减时的库存必须跟原来一样才成功。（类似于版本号）【成功率太低】</li>
<li>改进2：只要大于0就可以进行扣减。</li>
</ul>
<h3 id="一人一单（订单接口的幂等性）"><a href="#一人一单（订单接口的幂等性）" class="headerlink" title="一人一单（订单接口的幂等性）"></a>一人一单（订单接口的幂等性）</h3><ol>
<li><p>订单接口的幂等性是怎么做的？</p>
<p>（意思就是post请求带着：一个用户id，一个优惠卷id。发送多次请求，如何保证只有一个成功，也就是一人一单，订单做成唯一id）还有一种方法是新加一个状态字段。</p>
</li>
<li><p>库存扣减之后，还要去insert一个新的订单，你是如何保存这个的一致性的？<code>createOrder(order)</code></p>
<p>（使用spring自带的事务，将其放到一个事务里 @Transactional，注意事务有效性）</p>
</li>
<li><p>抢优惠券没有及时处理怎么办?</p>
<p>（通知用户已经抢了，延迟推送结果）</p>
</li>
<li><p>抢优惠券处理完了如何通知用户？</p>
<p>（没有通知，实际的业务还是基于DB的，使用券的时候db里没有就是没有，db处理完了自然就能用了）</p>
</li>
<li><p>秒杀场景下扣减库存太慢了怎么办？</p>
<p>（数据库集群，分库分表，索引优化，Redis热key，大key，Redis缓存过小）</p>
</li>
</ol>
<h4 id="单机解决方案"><a href="#单机解决方案" class="headerlink" title="单机解决方案"></a>单机解决方案</h4><ul>
<li>原来：一人n单过来之后，一开始都还没有订单，问题还是一样。</li>
<li>改进1：变成同步方法以后锁太大 createVoucherOrder()</li>
<li>改进2：使用this作为锁缩小范围，this获取的是服务对象，只要获得了服务对象就要参与竞争，导致所有人都参与竞争</li>
<li>改进3：使用userId.toString().intern()作为锁对象锁住一人一单的判断逻辑，但是锁在事务内部会导致事务尚未提交锁就已经释放，所以应该在 createVoucherOrder() 外部进行加锁。</li>
<li>改进4：上方依然有问题，因为直接调用实例方法默认是使用this.createVoucherOrder的，而Spring的事务基于aop动态代理，因此需要显式获取代理对象。</li>
<li>改进5：外部的方法不要加事务，因为事务传播机制默认是加入已经存在的事务。这边锁释放了大事务还没提交所以没用</li>
</ul>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>集群环境下同步代码块会失效，因此需要使用redis作为公共的分布式锁进行改进</p>
<p><strong>原来</strong>：setnx 到期删除锁</p>
<ul>
<li>问题是如果在锁内部阻塞导致过期删除，别人抢来了锁开始执行，自己出来以后就会把别人的锁删掉。</li>
</ul>
<p><strong>改进</strong>：分布式锁的value为自己的线程id，释放逻辑里判断id是否和自己相同。</p>
<ul>
<li>问题是如果发生比较极端的情况，判断逻辑里id相同，准备delete时可能发生fullgc导致超时释放，仍然会误删别人的锁，拿锁、比锁、删锁不是原子性的。因此引入LUA脚本。</li>
<li>自定义锁的局限性：实现比较简单，没有高级功能。</li>
</ul>
<p><strong>REDISSON</strong> 解决了setnx的以下痛点：</p>
<ol>
<li>不可重入，死锁，获取锁的线程不能进入相同的所的代码块。<ul>
<li><strong>重入机制</strong>：重入次数从0开始增加，使用hash结构存储线程id以及其重入次数。</li>
</ul>
</li>
<li>不可重试，尝试获取一次就返回没有重试机制。要么就是无效自旋耗费资源<ul>
<li>获取失败会订阅（pub/sub）释放消息，再等一段时间，收到释放信号就重试，如果一直没获取到，超出最大等待时间之后返回false。</li>
</ul>
</li>
<li>超时释放：业务执行时间长导致锁过期，虽然不会误删，但是有隐患。<ul>
<li><strong>续约</strong>：<strong>watchdog</strong> 线程，只要持有锁就会有定时更新ttl的任务，业务完成释放锁也会将定时任务取消。</li>
</ul>
</li>
<li>主从一致：主从同步出现问题可能出现死锁<ul>
<li><strong>multilock</strong>：解决主从一致问题。必须所有的redis全获取成功才算获取到。</li>
</ul>
</li>
</ol>
<h3 id="RabbitMQ-异步秒杀"><a href="#RabbitMQ-异步秒杀" class="headerlink" title="RabbitMQ 异步秒杀"></a>RabbitMQ 异步秒杀</h3><p>项目为什么要加个消息队列?</p>
<ul>
<li>Redis 效率比较高，而数据库效率不如redis快，tomcat中的程序，会进行串行操作，分成如下几步：查询优惠卷、<strong>判断秒杀库存是否足够</strong>、查询订单、<strong>校验是否是一人一单</strong>、扣减库存、创建订单。在这六步操作中，又有很多操作是要去操作数据库的，而且还是一个线程串行执行， 这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行。</li>
<li>将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息。</li>
<li>为什么不使用线程池或者异步编排。如果访问的人很多，那么线程池中的线程可能一下子就被消耗完了，而且你使用上述方案，最大的特点在于，你觉得时效性会非常重要，但是你想想是吗？并不是，比如我只要确定他能做这件事，然后我后边慢慢做就可以了，我并不需要他一口气做完这件事，所以我们应当采用的是课程中，类似消息队列的方式来完成我们的需求，而不是使用线程池或者是异步编排的方式来完成这个需求。</li>
</ul>
<h4 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h4><p><strong>Lua 脚本</strong>：把库存和一人一单做好判断，符合就直接返回成功。构建好订单发给rabbitMQ。</p>
<p>为了支持集群和维持原子性，lua脚本内操作的键必须在同一个哈希插槽内，因此需要使用前缀 + {voucherid}进行拼接，这样的两个键一定能在同一个哈西插槽内 HASHTAG</p>
<h4 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h4><p>MQ 这边本身支持 concurrency，不过用默认的 1 就好，我们手动配置好线程池的参数，然后提交给线程池。</p>
<p>异步：时效性不是那么重要，因此使用 MQ 慢慢消化即可。</p>
<p>单机——轻量级异步任务编排：如并行调用多个本地接口、合并结果、链式处理。</p>
<ul>
<li>高并发请求处理：通过线程池快速响应，避免阻塞主线程。</li>
<li>无需跨进程通信：所有操作在同一个 JVM 内完成。</li>
</ul>
<p><strong>分布式——RabbitMQ</strong>：</p>
<ul>
<li><p>直连交换机 <code>hmdianping.direct</code> 负责接收和分发消息</p>
</li>
<li><p>队列 <code>direct.seckill.queue</code>  存储消息，是消息的“最终目的地”。</p>
</li>
<li><p>绑定关系：队列通过路由键 <code>direct.seckill</code> 绑定到交换机。分发消息的依据（地址）</p>
</li>
<li><p><strong>参数注入</strong>：</p>
<ul>
<li><code>Message</code>：原始消息对象（含元数据）。</li>
<li><code>Channel</code>：RabbitMQ 通道，用于手动确认消息（ACK/NACK）。</li>
<li><code>VoucherOrder</code>：消息体自动反序列化后的业务对象（需配置消息转换器，如 <code>Jackson2JsonMessageConverter</code>）。</li>
</ul>
</li>
<li><p><strong>手动ACK</strong>：manual。业务处理成功调用 <code>basicAck</code>，告知 RabbitMQ 消息已被消费。</p>
</li>
<li><p><strong>消息持久化</strong>：发送者发消息时设置DeliveryMode为Persistent，同时队列创建时也要指定durable = true</p>
</li>
<li><p><strong>生产者 confirm</strong>：correlated。需要@PostConstruct配置回调函数，到达交换机和路由成功之后会触发回调。</p>
</li>
<li><p>重试机制：生产者发送消息的时候设置好消息头的 <code>retryCount = 0</code>，消费者检测 <code>retryCount &lt;= 3</code>才消费。如果订单保存失败则抛异常，此时拒绝消息并重新入队，达到三次重试就将这条消息转发到延时队列中去。这样，配置延时队列的死信队列为我们的正常队列，等到消息的 ttl 到了就 Reject消息，消息就重新回到了“死信队列”，也就是消费者对应的对列中，确保了消息不丢失。</p>
</li>
</ul>
<h4 id="数据库操作失败（Redis已经预扣）"><a href="#数据库操作失败（Redis已经预扣）" class="headerlink" title="数据库操作失败（Redis已经预扣）"></a>数据库操作失败（Redis已经预扣）</h4><p>lua脚本对库存（string）执行了减1操作，对集合（set）进行了add操作</p>
<ol>
<li>指数退避重试机制（订单id唯一保证幂等性）</li>
<li><strong>补偿机制：最终一致性兜底</strong>。如果重试到达一定次数就变成死信，死信监听器接受消息之后出发redis回滚对库存加1，对集合进行remove的操作。</li>
</ol>
<h4 id="请求堆积"><a href="#请求堆积" class="headerlink" title="请求堆积"></a>请求堆积</h4><p>MQ消息堆积：使用 CallerRunsPolicy()</p>
<table>
<thead>
<tr>
<th><strong>方案</strong></th>
<th><strong>实施难度</strong></th>
<th><strong>见效速度</strong></th>
<th><strong>适用阶段</strong></th>
<th><strong>成本</strong></th>
</tr>
</thead>
<tbody><tr>
<td>限流降级</td>
<td>低</td>
<td>立即</td>
<td>紧急处理</td>
<td>低</td>
</tr>
<tr>
<td>代码优化</td>
<td>中</td>
<td>1-3天</td>
<td>短期优化</td>
<td>低</td>
</tr>
<tr>
<td>数据库读写分离</td>
<td>高</td>
<td>1周</td>
<td>中期架构调整</td>
<td>中</td>
</tr>
<tr>
<td>微服务拆分</td>
<td>高</td>
<td>1-3个月</td>
<td>长期重构</td>
<td>高</td>
</tr>
<tr>
<td>消息队列削峰</td>
<td>中</td>
<td>3-7天</td>
<td>中期解耦</td>
<td>中</td>
</tr>
</tbody></table>
<h3 id="用户体感反馈"><a href="#用户体感反馈" class="headerlink" title="用户体感反馈"></a>用户体感反馈</h3><ol>
<li>活动开始/结束，token，参数非法</li>
<li>判断资格，成功则返回“抢购成功，请耐心等待结果”避免用户重复点击。</li>
<li>入队阶段：网络异常/MQ不可用，回滚 Redis，告知用户系统繁忙</li>
<li>异步落库：成功可以推送一个站内信，失败就发送失败通知，同时后台记录好日志，做好异常落库工作。</li>
</ol>
<h2 id="点赞、排行榜"><a href="#点赞、排行榜" class="headerlink" title="点赞、排行榜"></a>点赞、排行榜</h2><p><strong>使用 ZSet 与 MySQL 的自定义排序实现点赞及排行榜，使用 Set 作为共同关注的解决方案。</strong> </p>
<p>使用Zset存储每个blog的点赞者。 保证按照点赞时间排序，并且点赞人不会重复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  idStr 是前5个点赞的用户的 id，由于MySQL查询的结果顺序不定，因此需要 手动使用 ORDER BY FIELD 指定 ID 字段 按照 idStr 的顺序</span></span><br><span class="line">List&lt;UserDTO&gt; userDTOS = userService.query()</span><br><span class="line">        .in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list()</span><br><span class="line">        .stream()</span><br><span class="line">        .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h2 id="分页查询-时间线"><a href="#分页查询-时间线" class="headerlink" title="分页查询 时间线"></a>分页查询 时间线</h2><p><strong>实现了基于推模式的关注内容推送，用基于时间戳的分页查询实现时间线功能。</strong>  </p>
<p>优点：时效快，不用临时拉取</p>
<p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p>
<p>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</p>
<p>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()</span><br><span class="line">            .reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 3.非空判断</span></span><br><span class="line">    <span class="keyword">if</span> (typedTuples == <span class="literal">null</span> || typedTuples.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.解析数据：blogId、minTime（时间戳）、offset</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">    <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">os</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; <span class="comment">// 5 4 4 2 2</span></span><br><span class="line">        <span class="comment">// 4.1.获取id</span></span><br><span class="line">        ids.add(Long.valueOf(tuple.getValue()));</span><br><span class="line">        <span class="comment">// 4.2.获取分数(时间戳）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> tuple.getScore().longValue();</span><br><span class="line">        <span class="keyword">if</span>(time == minTime)&#123;</span><br><span class="line">            os++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            os = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    os = minTime == max ? os : os + offset;</span><br><span class="line">    <span class="comment">// 5.根据id查询blog</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    List&lt;Blog&gt; blogs = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">        setBlogUserInfo(blog);</span><br><span class="line">        setBlogIsLike(blog);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.封装并返回</span></span><br><span class="line">    <span class="type">ScrollResult</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">    r.setList(blogs);</span><br><span class="line">    r.setOffset(os);</span><br><span class="line">    r.setMinTime(minTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScrollResult</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;?&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Long minTime;</span><br><span class="line">    <span class="keyword">private</span> Integer offset;</span><br><span class="line">    <span class="comment">//minTime 上次查询的最小值 offset从上次查询最小值偏移的个数(上次最小值有多少个)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-Bitmap-签到"><a href="#使用-Bitmap-签到" class="headerlink" title="使用 Bitmap 签到"></a>使用 Bitmap 签到</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 签到实际上就是将天数所在的位置 SETBIT，重点是记录连续签到天数</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(key,</span><br><span class="line">            BitFieldSubCommands.create()</span><br><span class="line">            .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) &#123;<span class="keyword">return</span> Result.ok(<span class="number">0</span>);&#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.getFirst();</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="literal">null</span> || num == <span class="number">0</span>) &#123;<span class="keyword">return</span> Result.ok(<span class="number">0</span>);&#125;</span><br><span class="line">    <span class="comment">// 6.循环遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 如果为0，说明未签到，结束</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不为0，说明已签到，计数器+1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分布式锁≠流量削峰"><a href="#分布式锁≠流量削峰" class="headerlink" title="分布式锁≠流量削峰"></a>分布式锁≠流量削峰</h1><p>不，光开了分布式锁并不会减少外部打过来的请求数——它只是保证「同一时刻只有一个请求能拿到锁去真正执行业务」，但所有其他请求还是会去 Redis 调用一次 <code>tryLock()</code>，只不过拿不到锁而已。所以，分布式锁并不能从源头上降请求量或 Redis 的流量。</p>
<p>如果你想真正减轻 Redis 压力、提前拦截大批量的并发请求，可以考虑在业务层或网关层做以下几种优化：</p>
<ol>
<li><strong>本地预热+内存拦截</strong><ul>
<li>把库存、限流配额等关键信息缓存在应用内存（比如 <code>ConcurrentHashMap</code>、Guava Cache、Caffeine）里，先在本地判断 “库存是否用完” 或 “是否超过限流阈值”，</li>
<li>只有本地判断通过的请求才继续走远程 Redis 锁或库存扣减，未通过的直接快速返回。</li>
<li>这样在高并发时，大部分请求都被本地拦截掉，Redis 压力会大幅下降。</li>
</ul>
</li>
<li><strong>网关限流/熔断</strong><ul>
<li>在 Nginx 或 API 网关（如 Kong、Zuul、Spring Cloud Gateway）层面，给热点接口打限流，使用漏桶、令牌桶算法，把峰值流量削峰；</li>
<li>超出限流阈值的请求直接在网关被拒绝，不会转到业务后端。</li>
</ul>
</li>
<li><strong>消息队列异步排队</strong><ul>
<li>接口层接到请求后，迅速把请求放到 MQ（RabbitMQ、Kafka、RocketMQ），立即返回“排队中”给用户；</li>
<li>后端消费者单线程或限并发地从队列里拉取消息、串行执行业务、更新库存、入库；</li>
<li>这样除了一条队列写入，后续几乎零并发冲突，也不会给 Redis 带来峰值压力。</li>
</ul>
</li>
<li><strong>Lua 脚本原子化合并操作</strong><ul>
<li>把库存检查、扣减、锁定、消息入队等逻辑写到一段 Redis Lua 脚本里，一次网络 RTT 就能完成多步校验和更新，虽然还是落到 Redis，但网络交互次数最低。</li>
<li>适合逻辑较简单的场景。</li>
</ul>
</li>
<li><strong>多级限流</strong><ul>
<li>前端做点击防抖/禁用按钮，避免用户重复快速点击；</li>
<li>服务端在 Controller 层用注解（如 <code>@RateLimiter</code>）做粗粒度限流；</li>
<li>再到业务层做精确限流、库存预判。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>分布式锁能防止并发冲突</strong>，但它并不是流量削峰的手段，<strong>并不会减少对 Redis 的调用次数</strong>；</li>
<li>如果想从源头上削峰，必须借助 <strong>本地缓存预判、网关限流、消息队列排队</strong> 等手段，才能真正降低对 Redis（或后端服务）的并发压力。</li>
</ul>
<h1 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h1><p><strong>CAP 理论</strong>，也称为 <strong>Brewer 定理</strong>，是分布式系统设计中的一个基本原则。它指出，在一个分布式存储系统中，<strong>一致性（Consistency）</strong>、<strong>可用性（Availability）</strong>、<strong>分区容错性（Partition Tolerance）</strong> 三者不可兼得，只能同时满足其中的两项。下面分点说明。</p>
<ul>
<li><strong>CAP 不告诉你选哪两个</strong>，而是帮助你在设计时<strong>明确取舍</strong>：<ul>
<li>如果业务对<strong>强一致性</strong>要求高（如支付、库存扣减），在分区时宁可牺牲可用性 → 选 <strong>CP</strong>。</li>
<li>如果业务对<strong>可用性/延迟</strong>要求高（如社交、日志收集），在分区时宁可牺牲一致性 → 选 <strong>AP</strong>。</li>
</ul>
</li>
<li>在<strong>真实业务中</strong>，常结合<strong>最终一致性</strong>、<strong>多副本延迟补偿</strong>、<strong>幂等重试</strong>等手段，综合平衡一致性与可用性。</li>
</ul>
<p>了解 CAP 理论，有助于你在做分布式架构选型时，<strong>根据业务特性、容忍度和运维成本</strong>做出最合适的权衡。</p>
<hr>
<h2 id="三个核心"><a href="#三个核心" class="headerlink" title="三个核心"></a>三个核心</h2><ol>
<li><strong>一致性（Consistency）</strong><br> 所有节点在同一时间看到的数据是一致的。一次写入操作完成后，所有后续的读取都能立刻返回最新的写入值。</li>
<li><strong>可用性（Availability）</strong><br> 每个请求都会在有限时间内得到非错误响应（不保证是最新数据，但保证服务不宕机、总有回应）。</li>
<li><strong>分区容错性（Partition Tolerance）</strong><br> 系统能够容忍网络分区（节点或网络断开）而继续提供服务。即使部分节点之间无法通信，系统仍能保持一致性或可用性之一。</li>
</ol>
<p>项目当中，CP：分布式锁判定一人一单，强一致性    AP：最终一致性，redis预扣。redis集群。</p>
<hr>
<h2 id="“不可兼得”-的含义"><a href="#“不可兼得”-的含义" class="headerlink" title="“不可兼得” 的含义"></a>“不可兼得” 的含义</h2><p>CAP 告诉我们：“当系统发生网络分区时（P发生），你必须在<strong>一致性</strong>（C）和<strong>可用性</strong>（A）之间做选择，<strong>不能同时满足</strong>。”</p>
<p>在真实的分布式环境中，<strong>网络分区故障（网络抖动、链路中断）几乎不可避免</strong>。因此，<strong>要构建一个健壮的分布式系统，必须选择在网络分区时牺牲“一致性”或“可用性”中的一项</strong>：</p>
<ul>
<li><strong>CP 系统（Consistency + Partition Tolerance）</strong>：在网络分区时，放弃可用性，保证一致性。常见于金融交易系统。</li>
<li><strong>AP 系统（Availability + Partition Tolerance）</strong>：在网络分区时，放弃一致性，保证可用性。常见于社交媒体、缓存系统。</li>
<li><strong>CA 系统（Consistency + Availability）</strong>：保证一致性和可用性，但无法容忍网络分区。严格来说，分布式环境中无法真正做到 CA，因为分区总会发生。</li>
</ul>
<table>
<thead>
<tr>
<th>模型</th>
<th>分区发生时的策略</th>
<th>场景举例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CP</strong></td>
<td>停止提供服务或延迟响应，直到网络恢复并保证数据一致</td>
<td>ZooKeeper、HBase（强一致读写）</td>
</tr>
<tr>
<td><strong>AP</strong></td>
<td>继续提供服务，但有可能读到老数据，待网络恢复后数据再最终一致</td>
<td>Cassandra、Redis Cluster（异步复制）</td>
</tr>
<tr>
<td><strong>CA</strong></td>
<td>不适用于跨网络数据中心的分布式系统；只在单机或无网络分区场景满足</td>
<td>传统关系型数据库（单实例）</td>
</tr>
</tbody></table>
<hr>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><ul>
<li><strong>Cassandra（AP）</strong><ul>
<li>选用最终一致性模型，允许在分区时继续读写，性能和可用性高，但短期内可能读不到最新写入。</li>
</ul>
</li>
<li><strong>MongoDB（CP 可调）</strong><ul>
<li>默认主从复制，主节点写入保证一致性；分区时次节点不可写（牺牲可用性），保证读写一致。</li>
</ul>
</li>
<li><strong>Redis Sentinel/ZK（CP）</strong><ul>
<li>在主备切换时，会阻止客户端写入，直到选举出新主节点，保证强一致。</li>
</ul>
</li>
</ul>
<h1 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h1><p><strong>设计线程池参数</strong></p>
<p>用户问题涉及如何根据连接池及延时设计线程池。基本原则是使用小法则（Little’s Law）：线程数 = 到达率 * 响应时间。对于10个连接、1秒响应时间的问题，建议线程池大小不应超过数据库连接池大小，尤其用于阻塞任务时。如果响应时间为10毫秒，则需调整线程池设计。通常核心线程池和最大线程数都应根据负载情况设置。是否使用异步取决于具体任务类型与需求。</p>
<p><strong>设计IO密集型线程池</strong></p>
<p>对于IO密集型任务，IO等待时间较长时，线程数应大于核心数。可以使用公式：线程数 = 核心数 * (1 + IO等待时间 / 处理时间)。这个公式在《Java并发编程实战》一书中有提到。另外，还有一篇博客推荐的公式：线程数 = 核心数 * (1 + 等待时间 / 服务时间)。我会查找相关文献引用。</p>
<p><strong>设计线程池大小</strong></p>
<p>对于线程池设计，假设最大化数据库连接池的利用率，线程池大小可以约为连接池大小乘以响应时间和思考时间的比例（加上1）。为了避免排队，通常线程池大小不超过连接池大小。如果响应时间为1秒，10个线程足够支持每秒10次请求。若响应时间为10毫秒，则10个连接能处理1000次请求。为了更好的CPU利用率，线程数可调整，考虑思考时间与阻塞时间的比例。</p>
<p>已思考 43 秒</p>
<p>在设计业务线程池时，需要综合考虑以下几方面：CPU 核心数与任务的 CPU/IO 比例、数据库连接池的并发上限、业务响应时间，以及系统的吞吐目标。常用的理论模型包括 Brian Goetz 在《Java Concurrency in Practice》中提出的线程数公式：</p>
<blockquote>
<p><strong>线程数 = 可用 CPU 核心数 × (1 + 平均等待时间 / 平均服务时间)</strong> (<a target="_blank" rel="noopener" href="https://engineering.zalando.com/posts/2019/04/how-to-set-an-ideal-thread-pool-size.html?utm_source=chatgpt.com">Zalando Engineering Blog</a>)</p>
</blockquote>
<p>以及 Little’s Law：</p>
<blockquote>
<p><strong>L = λ × W</strong><br> – L：系统中并发处理的请求数（即线程数）<br> – λ：系统的长时平均到达率（请求数/秒）<br> – W：请求的平均处理时间（秒） (<a target="_blank" rel="noopener" href="https://engineering.zalando.com/posts/2019/04/how-to-set-an-ideal-thread-pool-size.html?utm_source=chatgpt.com">Zalando Engineering Blog</a>)</p>
</blockquote>
<p>下面结合这两种方法，讨论当数据库连接池为 10 条、响应时间分别为 1 s 和 10 ms 时，如何确定线程池大小。</p>
<hr>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="1-基于-CPU-与-IO-比例的线程数公式"><a href="#1-基于-CPU-与-IO-比例的线程数公式" class="headerlink" title="1. 基于 CPU 与 IO 比例的线程数公式"></a>1. 基于 CPU 与 IO 比例的线程数公式</h3><p>对于 IO 密集型任务（如数据库调用），线程在等待 IO 完成时不会占用 CPU。Goetz 建议：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">numThreads</span> <span class="operator">=</span> numCores * (<span class="number">1</span> + waitTime / serviceTime);</span><br></pre></td></tr></table></figure>

<p>其中 waitTime 是线程等待 IO 的时间，serviceTime 是实际执行业务逻辑的时间。计算密集型任务（waitTime ≈ 0）时，线程数 ≈ CPU 核心数；IO 密集型任务时，线程数会大幅 &gt; CPU 核心数，以充分利用等待期间的空闲 CPU (<a target="_blank" rel="noopener" href="https://engineering.zalando.com/posts/2019/04/how-to-set-an-ideal-thread-pool-size.html?utm_source=chatgpt.com">Zalando Engineering Blog</a>, <a target="_blank" rel="noopener" href="https://baddotrobot.com/blog/2013/06/01/optimum-number-of-threads/?utm_source=chatgpt.com">baddotrobot.com</a>)。</p>
<h3 id="2-Little’s-Law（小定律）"><a href="#2-Little’s-Law（小定律）" class="headerlink" title="2. Little’s Law（小定律）"></a>2. Little’s Law（小定律）</h3><p>Little’s Law 给出了并行处理能力与系统延迟、吞吐率之间的关系：</p>
<blockquote>
<p>并发线程数 L = 系统吞吐率 λ × 平均延迟 W</p>
</blockquote>
<p>例如，要保持 100 QPS (λ=100) 的吞吐并且响应时间 W=0.01 s 时，需要 L=1 个并发线程才能稳定达到目标 (<a target="_blank" rel="noopener" href="https://engineering.zalando.com/posts/2019/04/how-to-set-an-ideal-thread-pool-size.html?utm_source=chatgpt.com">Zalando Engineering Blog</a>)。</p>
<h3 id="3-受数据库连接池上限约束"><a href="#3-受数据库连接池上限约束" class="headerlink" title="3. 受数据库连接池上限约束"></a>3. 受数据库连接池上限约束</h3><p>如果所有线程都在等待数据库响应，且连接池最大并发连接数为 N，则有效并发线程数不应超过 N，否则线程会在应用层排队，造成不必要的上下文切换和内存占用 (<a target="_blank" rel="noopener" href="https://docs.redhat.com/en/documentation/red_hat_build_of_keycloak/24.0/html/high_availability_guide/concepts-threads-?utm_source=chatgpt.com">红帽文档</a>, <a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E19900-01/819-4742/abehg/index.html?utm_source=chatgpt.com">Oracle 文档</a>)。</p>
<hr>
<h2 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h2><h3 id="情况-A：数据库响应时间-1-s"><a href="#情况-A：数据库响应时间-1-s" class="headerlink" title="情况 A：数据库响应时间 1 s"></a>情况 A：数据库响应时间 1 s</h3><ul>
<li><p><strong>假设</strong>：CPU 核心数 8，业务逻辑处理时间（serviceTime）≈10 ms，IO 等待时间（waitTime）≈1000 ms。</p>
</li>
<li><p><strong>按 Goetz 公式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threads = 8 * (1 + 1000/10) ≈ 8 * 101 = 808</span><br></pre></td></tr></table></figure>

<p>但数据库连接池仅 10 条，此时绝大多数线程会在 JDBC 层排队，反而降低性能 (<a target="_blank" rel="noopener" href="https://engineering.zalando.com/posts/2019/04/how-to-set-an-ideal-thread-pool-size.html?utm_source=chatgpt.com">Zalando Engineering Blog</a>, <a target="_blank" rel="noopener" href="https://docs.redhat.com/en/documentation/red_hat_build_of_keycloak/24.0/html/high_availability_guide/concepts-threads-?utm_source=chatgpt.com">红帽文档</a>)。</p>
</li>
<li><p><strong>实践建议</strong>：将线程池大小设为连接池大小的 1.1～1.25 倍，以应对瞬时小流量峰值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">corePoolSize = 10</span><br><span class="line">maximumPoolSize = 12  // 允许最多两条备用线程</span><br></pre></td></tr></table></figure>

<p>这样既能充分利用 10 条连接，又能在 1 s 的处理窗口内处理偶发的短暂冲击 (<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1208077/optimal-number-of-connections-in-connection-pool?utm_source=chatgpt.com">Stack Overflow</a>, <a target="_blank" rel="noopener" href="https://medium.com/@gaborfarkasds/so-how-big-should-that-connection-pool-be-e5c69f2e15dd?utm_source=chatgpt.com">Medium</a>)。</p>
</li>
</ul>
<h3 id="情况-B：数据库响应时间-10-ms"><a href="#情况-B：数据库响应时间-10-ms" class="headerlink" title="情况 B：数据库响应时间 10 ms"></a>情况 B：数据库响应时间 10 ms</h3><ul>
<li><p><strong>假设</strong>：waitTime=10 ms，serviceTime=10 ms，CPU 核心数 8。</p>
</li>
<li><p><strong>按 Goetz 公式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threads = 8 * (1 + 10/10) = 16</span><br></pre></td></tr></table></figure></li>
<li><p><strong>受连接池约束</strong>：由于同时只能打开 10 条连接，并发线程再多也无法并行地阻塞在 JDBC 层。此时最优线程池大小依然是 10～12 之间 (<a target="_blank" rel="noopener" href="https://docs.redhat.com/en/documentation/red_hat_build_of_keycloak/24.0/html/high_availability_guide/concepts-threads-?utm_source=chatgpt.com">红帽文档</a>, <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1208077/optimal-number-of-connections-in-connection-pool?utm_source=chatgpt.com">Stack Overflow</a>)。</p>
</li>
<li><p><strong>基于 Little’s Law</strong>：若目标吞吐 1000 QPS，W=0.01 s，则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L = λ * W = 1000 * 0.01 = 10 threads</span><br></pre></td></tr></table></figure>

<p>刚好匹配连接池大小 (<a target="_blank" rel="noopener" href="https://engineering.zalando.com/posts/2019/04/how-to-set-an-ideal-thread-pool-size.html?utm_source=chatgpt.com">Zalando Engineering Blog</a>)。</p>
</li>
</ul>
<hr>
<h2 id="最佳实践与调优"><a href="#最佳实践与调优" class="headerlink" title="最佳实践与调优"></a>最佳实践与调优</h2><ol>
<li><strong>分离不同任务线程池</strong><br> 对于数据库调用、外部 HTTP、CPU 密集型计算等，最好使用多个专用线程池，分别根据各自的 waitTime/serviceTime 及资源约束来调优 (<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/76684733/how-to-determine-corethreadsize-if-having-multiple-threadpools-in-application?utm_source=chatgpt.com">Stack Overflow</a>)。</li>
<li><strong>监控与压测“Measure, Don’t Guess”</strong><br> 所有公式与经验值仅作起点，必须通过 A/B 测试和压测（Load Test）验证性能瓶颈，动态调整 core/max、队列长度等参数 (<a target="_blank" rel="noopener" href="https://engineering.zalando.com/posts/2019/04/how-to-set-an-ideal-thread-pool-size.html?utm_source=chatgpt.com">Zalando Engineering Blog</a>)。</li>
<li><strong>考虑拒绝策略与队列类型</strong><br> 结合业务特性选择合适的队列（SynchronousQueue、LinkedBlockingQueue 等）及拒绝策略（CallerRunsPolicy、AbortPolicy 等），避免在高并发下无界队列导致 OOM。</li>
<li><strong>动态伸缩</strong><br> 在流量可预测且波动较大时，可结合 Kubernetes/HPA、Spring Cloud TaskExecutor 等方案，实现线程池在运行时动态伸缩，以更加经济地利用资源。</li>
</ol>
<hr>
<p><strong>总结</strong>：线程池大小既要遵循理论公式（Goetz 公式、Little’s Law），又要服从外部资源（如数据库连接池）的最大并发约束。对于 10 条连接池、1 s 或 10 ms 响应场景，推荐将线程池大小设置为 10～12；后续应结合压测结果不断迭代优化。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/12/redie-review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/12/redie-review/" class="post-title-link" itemprop="url">redis-review</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-12 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-12T00:00:00+08:00">2024-10-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-08 14:10:26" itemprop="dateModified" datetime="2025-05-08T14:10:26+08:00">2025-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="开篇导读"><a href="#开篇导读" class="headerlink" title="开篇导读"></a>开篇导读</h2><p>亲爱的小伙伴们大家好，马上咱们就开始实战篇的内容了，相信通过本章的学习，小伙伴们就能理解各种redis的使用啦，接下来咱们来一起看看实战篇我们要学习一些什么样的内容</p>
<ul>
<li>短信登录</li>
</ul>
<p>这一块我们会使用redis TOKEN共享session来实现</p>
<ul>
<li>商户查询缓存</li>
</ul>
<p>通过本章节，我们会理解缓存击穿，缓存穿透，缓存雪崩等问题，让小伙伴的对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容</p>
<ul>
<li>优惠卷秒杀</li>
</ul>
<p>通过本章节，我们可以学会Redis的计数器功能， 结合Lua完成高性能的redis操作，同时学会Redis分布式锁的原理，包括Redis的三种消息队列</p>
<ul>
<li>附近的商户</li>
</ul>
<p>我们利用Redis的GEOHash来完成对于地理坐标的操作</p>
<ul>
<li>UV统计</li>
</ul>
<p>主要是使用Redis来完成统计功能</p>
<ul>
<li>用户签到</li>
</ul>
<p>使用Redis的BitMap数据统计功能</p>
<ul>
<li>好友关注</li>
</ul>
<p>基于Set集合的关注、取消关注，共同关注等等功能，这一块知识咱们之前就讲过，这次我们在项目中来使用一下</p>
<ul>
<li>打人探店</li>
</ul>
<p>基于List来完成点赞列表的操作，同时基于SortedSet来完成点赞的排行榜功能</p>
<p>以上这些内容咱们统统都会给小伙伴们讲解清楚，让大家充分理解如何使用Redis</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653056228879.png" alt="1653056228879"></p>
<h2 id="短信登录：分布式session-token-redis"><a href="#短信登录：分布式session-token-redis" class="headerlink" title="短信登录：分布式session (token+redis)"></a>短信登录：分布式session (token+redis)</h2><h3 id="导入黑马点评项目"><a href="#导入黑马点评项目" class="headerlink" title="导入黑马点评项目"></a>导入黑马点评项目</h3><h4 id="导入SQL"><a href="#导入SQL" class="headerlink" title="导入SQL"></a>导入SQL</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653057872536.png" alt="1653057872536"></p>
<h4 id="有关当前模型"><a href="#有关当前模型" class="headerlink" title="有关当前模型"></a>有关当前模型</h4><p>手机或者app端发起请求，请求我们的nginx服务器，nginx基于七层模型走的事HTTP协议，可以实现基于Lua直接绕开tomcat访问redis，也可以作为静态资源服务器，轻松扛下上万并发， 负载均衡到下游tomcat服务器，打散流量，我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，所以nginx是整个项目中重要的一环。</p>
<p>在tomcat支撑起并发流量后，我们如果让tomcat直接去访问Mysql，根据经验Mysql企业级服务器只要上点并发，一般是16或32 核心cpu，32 或64G内存，像企业级mysql加上固态硬盘能够支撑的并发，大概就是4000起~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满，容易崩溃，所以我们在高并发场景下，会选择使用mysql集群，同时为了进一步降低Mysql的压力，同时增加访问的性能，我们也会加入Redis，同时使用Redis集群使得Redis对外提供更好的服务。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653059409865.png" alt="1653059409865"></p>
<h4 id="导入后端项目"><a href="#导入后端项目" class="headerlink" title="导入后端项目"></a>导入后端项目</h4><p>在资料中提供了一个项目源码：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653060237073.png" alt="1653060237073"></p>
<h4 id="导入前端工程"><a href="#导入前端工程" class="headerlink" title="导入前端工程"></a>导入前端工程</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653060337562.png" alt="1653060337562"></p>
<h4 id="运行前端项目"><a href="#运行前端项目" class="headerlink" title="运行前端项目"></a>运行前端项目</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653060588190.png" alt="1653060588190"></p>
<h3 id="基于Session实现登录流程"><a href="#基于Session实现登录流程" class="headerlink" title="基于Session实现登录流程"></a>基于Session实现登录流程</h3><p>cookie不安全，session绝对安全</p>
<p><strong>发送验证码：</strong> </p>
<p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号</p>
<p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</p>
<p><strong>短信验证码登录、注册：</strong></p>
<p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p>
<p><strong>校验登录状态:</strong></p>
<p>用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653066208144.png" alt="1653066208144"></p>
<h3 id="实现发送短信验证码功能"><a href="#实现发送短信验证码功能" class="headerlink" title="实现发送短信验证码功能"></a>实现发送短信验证码功能</h3><p><strong>页面流程</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653067054461.png" alt="1653067054461"></p>
<p><strong>具体代码如下</strong></p>
<p><strong>贴心小提示：</strong></p>
<p>具体逻辑上文已经分析，我们仅仅只需要按照提示的逻辑写出代码即可。</p>
<ul>
<li>发送验证码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.符合，生成验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.保存验证码到 session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;code&quot;</span>,code);</span><br><span class="line">    <span class="comment">// 5.发送验证码</span></span><br><span class="line">    log.debug(<span class="string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);</span><br><span class="line">    <span class="comment">// 返回ok</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>登录</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.校验验证码</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheCode</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="keyword">if</span>(cacheCode == <span class="literal">null</span> || !cacheCode.toString().equals(code))&#123;</span><br><span class="line">         <span class="comment">//3.不一致，报错</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一致，根据手机号查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//不存在，则创建</span></span><br><span class="line">        user =  createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.保存用户信息到session中</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现登录拦截功能"><a href="#实现登录拦截功能" class="headerlink" title="实现登录拦截功能"></a>实现登录拦截功能</h3><p><strong>温馨小贴士：tomcat的运行原理</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653068196656.png" alt="1653068196656"></p>
<p>当用户发起请求时，会访问我们像tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应</p>
<p>通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据</p>
<p><strong>温馨小贴士：关于threadlocal</strong></p>
<p>如果小伙伴们看过threadLocal的源码，你会发现在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，所以可以通过这种方式来做到线程隔离</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653068874258.png" alt="1653068874258"></p>
<p>拦截器代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">//1.获取session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//2.获取session中的用户</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">//3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="comment">//4.不存在，拦截，返回401状态码</span></span><br><span class="line">              response.setStatus(<span class="number">401</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.存在，保存用户信息到Threadlocal</span></span><br><span class="line">        UserHolder.saveUser((User)user);</span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让拦截器生效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// token刷新的拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="隐藏用户敏感信息"><a href="#隐藏用户敏感信息" class="headerlink" title="隐藏用户敏感信息"></a>隐藏用户敏感信息</h3><p>我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了</p>
<p>Data Transfer Object 不包含业务逻辑，只包含传输时必要的字段，精简敏感信息</p>
<p><strong>在登录方法处修改</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//7.保存用户信息到session中</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;user&quot;</span>, BeanUtils.copyProperties(user,UserDTO.class));</span><br></pre></td></tr></table></figure>

<p><strong>在拦截器处：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.存在，保存用户信息到Threadlocal</span></span><br><span class="line">UserHolder.saveUser((UserDTO) user);</span><br></pre></td></tr></table></figure>

<p><strong>在UserHolder处：将user对象换成UserDTO</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="session共享问题"><a href="#session共享问题" class="headerlink" title="session共享问题"></a>session共享问题</h3><p><strong>核心思路分析：</strong></p>
<p>每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</p>
<p>但是这种方案具有两个大问题</p>
<p>1、每台服务器中都有完整的一份session数据，服务器内存压力过大。</p>
<p>2、session拷贝数据时，可能会出现延迟，影响效率</p>
<p>所以咱们后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653069893050.png" alt="1653069893050"></p>
<p>为什么用cookie,session,redis而不是数据库？</p>
<p>有些东西并不需要持久化到数据库中，只需要存在内存中即可，键值对型数据能够实现高效的查询与获取</p>
<h3 id="Redis代替session的业务流程"><a href="#Redis代替session的业务流程" class="headerlink" title="Redis代替session的业务流程"></a>Redis代替session的业务流程</h3><h4 id="设计key的结构"><a href="#设计key的结构" class="headerlink" title="设计key的结构"></a>设计key的结构</h4><p>首先我们要思考一下利用redis来存储数据，那么到底使用哪种结构呢？由于存入的数据比较简单，我们可以考虑使用String，或者是使用哈希，如下图，如果使用String，同学们注意他的value，用多占用一点空间，如果使用哈希，则他的value中只会存储他数据本身，如果不是特别在意内存，其实使用String就可以啦。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653319261433.png" alt="1653319261433"></p>
<h4 id="设计key的具体细节"><a href="#设计key的具体细节" class="headerlink" title="设计key的具体细节"></a>设计key的具体细节</h4><p>所以我们可以使用String结构，就是一个简单的key，value键值对的方式，但是关于key的处理，session他是每个用户都有自己的session，但是redis的key是共享的，咱们就不能使用code了</p>
<p>在设计这个key的时候，我们之前讲过需要满足两点</p>
<p>1、key要具有唯一性</p>
<p>2、key要方便携带</p>
<p>如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了。</p>
<p><mark>session：浏览器请求自动携带sessionID，服务器根据sessionID访问相应的内存空间存储的信息，<mark></p>
<p><mark>redis+token：浏览器请求携带token，服务器根据token访问redis数据库存储的信息。<mark></p>
<ul>
<li><mark>前端实现逻辑：将服务端生成的<u>token</u>保存到浏览器的sessionStorage域中，在axios发送ajax请求时进行方法拦截，在请求头requestHeader中加入authorization:<u>token</u> ，因为要保存到浏览器，所以不能使用手机号作为token而应该生成一个uuid字符串<mark>: </li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241031173338907.png" alt="image-20241031173338907"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241031173340660.png" alt="image-20241031173340660"></p>
<ul>
<li><mark>后端逻辑：将token取出，根据token访问redis数据库<mark></li>
</ul>
<h4 id="整体访问流程"><a href="#整体访问流程" class="headerlink" title="整体访问流程"></a>整体访问流程</h4><p>当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653319474181.png" alt="1653319474181"></p>
<h3 id="基于Redis实现短信登录"><a href="#基于Redis实现短信登录" class="headerlink" title="基于Redis实现短信登录"></a>基于Redis实现短信登录</h3><p>这里具体逻辑就不分析了，之前咱们已经重点分析过这个逻辑啦。</p>
<p><strong>UserServiceImpl代码</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.从redis获取验证码并校验</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="keyword">if</span> (cacheCode == <span class="literal">null</span> || !cacheCode.equals(code)) &#123;</span><br><span class="line">        <span class="comment">// 不一致，报错</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.一致，根据手机号查询用户 select * from tb_user where phone = ?</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.不存在，创建新用户并保存</span></span><br><span class="line">        user = createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.保存用户信息到 redis中</span></span><br><span class="line">    <span class="comment">// 7.1.随机生成token，作为登录令牌</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 7.2.将User对象转为HashMap存储</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">            CopyOptions.create()</span><br><span class="line">                    .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                    .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line">    <span class="comment">// 7.3.存储</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">    stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);</span><br><span class="line">    <span class="comment">// 7.4.设置token有效期</span></span><br><span class="line">    stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.返回token</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决状态登录刷新问题"><a href="#解决状态登录刷新问题" class="headerlink" title="解决状态登录刷新问题"></a>解决状态登录刷新问题</h3><h4 id="初始方案思路总结"><a href="#初始方案思路总结" class="headerlink" title="初始方案思路总结"></a>初始方案思路总结</h4><p>在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，比如主页之类的那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的。</p>
<p>只有访问拦截的网页才会刷redis，这样就导致如果用户访问的是其他网页，不会出发拦截器，过期token就会失效</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653320822964.png" alt="1653320822964"></p>
<h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><p>既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653320764547.png" alt="1653320764547"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><strong>RefreshTokenInterceptor</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.基于TOKEN获取redis中的用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span>  <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">        <span class="comment">// 3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.将查询到的hash数据转为UserDTO</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 6.存在，保存用户信息到 ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">// 7.刷新token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 8.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p><strong>LoginInterceptor</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要拦截（ThreadLocal中是否有用户）</span></span><br><span class="line">        <span class="keyword">if</span> (UserHolder.getUser() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有，需要拦截，设置状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="comment">// 拦截</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有用户，则放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45673401/article/details/132065407">Hutool BeanUtils.copyProperties的四种用法 空不拷贝/忽略拷贝/空不和忽略拷贝/全拷贝_hutool beanutil.copyproperties-CSDN博客</a> </p>
<p>beanToMap 属性转换异常</p>
<h2 id="商户查询缓存-分布式缓存cache"><a href="#商户查询缓存-分布式缓存cache" class="headerlink" title="商户查询缓存 分布式缓存cache"></a>商户查询缓存 分布式缓存cache</h2><h3 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存?"></a>什么是缓存?</h3><p><strong>前言</strong>:<strong>什么是缓存?</strong></p>
<p>就像自行车,越野车的避震器<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E9%81%BF%E9%9C%87%E5%99%A8.gif"></p>
<p>举个例子:越野车,山地自行车,都拥有”避震器”,<strong>防止</strong>车体加速后因惯性,在酷似”U”字母的地形上飞跃,硬着陆导致的<strong>损害</strong>,像个弹簧一样;</p>
<p>同样,实际开发中,系统也需要”避震器”,防止过高的数据访问猛冲系统,导致其操作线程无法及时处理信息而瘫痪;</p>
<p>这在实际开发中对企业讲,对产品口碑,用户评价都是致命的;所以企业非常重视缓存技术;</p>
<p><strong>缓存(<strong>Cache),就是数据交换的</strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码(例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1</span>:Static <span class="keyword">final</span> ConcurrentHashMap&lt;K,V&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(); 本地用于高并发</span><br><span class="line"></span><br><span class="line">例<span class="number">2</span>:<span class="keyword">static</span> <span class="keyword">final</span> Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存</span><br><span class="line"></span><br><span class="line">例<span class="number">3</span>:Static <span class="keyword">final</span> Map&lt;K,V&gt; map =  <span class="keyword">new</span> <span class="title class_">HashMap</span>(); 本地缓存</span><br></pre></td></tr></table></figure>

<p>由于其被<strong>Static</strong>修饰,所以随着类的加载而被加载到<strong>内存之中</strong>,作为本地缓存,由于其又被<strong>final</strong>修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(=)导致缓存失效;</p>
<h4 id="为什么要使用缓存"><a href="#为什么要使用缓存" class="headerlink" title="为什么要使用缓存"></a>为什么要使用缓存</h4><p>一句话:因为<strong>速度快,好用</strong></p>
<p>缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低<strong>用户访问并发量带来的</strong>服务器读写压力</p>
<p>实际开发过程中,企业的数据量,少则几十万,多则几千万,这么大数据量,如果没有缓存来作为”避震器”,系统是几乎撑不住的,所以企业会大量运用到缓存技术;</p>
<p>但是缓存也会增加代码复杂度和运营的成本:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220523214414123.png"></p>
<h4 id="如何使用缓存"><a href="#如何使用缓存" class="headerlink" title="如何使用缓存"></a>如何使用缓存</h4><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p>
<p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p>
<p><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p>
<p><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p>
<p><strong>CPU缓存：</strong>当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220523212915666.png"></p>
<h3 id="添加商户缓存"><a href="#添加商户缓存" class="headerlink" title="添加商户缓存"></a>添加商户缓存</h3><p>在我们查询商户信息时，我们是直接操作从数据库中去进行查询的，大致逻辑是这样，直接查询数据库那肯定慢咯，所以我们需要增加缓存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">public Result queryShopById(@PathVariable(&quot;id&quot;) Long id) &#123;</span><br><span class="line">    //这里是直接查询数据库</span><br><span class="line">    return shopService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缓存模型和思路"><a href="#缓存模型和思路" class="headerlink" title="缓存模型和思路"></a>缓存模型和思路</h4><p>标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653322097736.png" alt="1653322097736"></p>
<h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><p>代码思路：如果缓存有，则直接返回，如果缓存不存在，则查询数据库，然后存入redis。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653322190155.png" alt="1653322190155"></p>
<h4 id="练习：商铺信息缓存处理"><a href="#练习：商铺信息缓存处理" class="headerlink" title="练习：商铺信息缓存处理"></a>练习：商铺信息缓存处理</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241101145321055.png" alt="image-20241101145321055"></p>
<p>增加程序健壮性，先查看redis是否有key，没有就创建，如果有key但是长度为0，也创建，长度不为0，肯定有key，读取后解析为list返回</p>
<h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p>
<p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p>
<p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</p>
<p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653322506393.png" alt="1653322506393"></p>
<h4 id="DB-Cache数据一致性解决方案"><a href="#DB-Cache数据一致性解决方案" class="headerlink" title="DB, Cache数据一致性解决方案"></a>DB, Cache数据一致性解决方案</h4><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p>
<p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p>
<h5 id="Cache-Aside-Pattern-旁路缓存"><a href="#Cache-Aside-Pattern-旁路缓存" class="headerlink" title="Cache Aside Pattern 旁路缓存"></a>Cache Aside Pattern 旁路缓存</h5><p>人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p>
<h5 id="Read-Write-Through-Pattern-读写穿透"><a href="#Read-Write-Through-Pattern-读写穿透" class="headerlink" title="Read/Write Through Pattern 读写穿透"></a>Read/Write Through Pattern 读写穿透</h5><p>由系统本身完成，数据库与缓存的问题交由缓存系统本身去处理，实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p>
<p>但是Redis本身并没有支持将cache写入db的功能，因此也不常见</p>
<h5 id="Write-Behind-Caching-Pattern-异步缓存写入"><a href="#Write-Behind-Caching-Pattern-异步缓存写入" class="headerlink" title="Write Behind Caching Pattern 异步缓存写入"></a>Write Behind Caching Pattern 异步缓存写入</h5><p>调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p>
<p>举例：消息队列中消息的 异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制</p>
<p> db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么 高的场景，比如浏览量、点赞量</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653322857620.png" alt="1653322857620"></p>
<h4 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h4><p>综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题</p>
<p>操作缓存和数据库时有三个问题需要考虑：</p>
<h5 id="删除cache还是更新cache？"><a href="#删除cache还是更新cache？" class="headerlink" title="删除cache还是更新cache？"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38420688/article/details/108803569">删除cache还是更新cache？</a></h5><ul>
<li><p>更新缓存：每次更新数据库都更新缓存，无效写操作较多，并且可能有线程安全问题</p>
</li>
<li><p>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</p>
</li>
</ul>
<p>无效写：假设我们每次操作数据库后，都去更新缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来。</p>
<p>线程安全：比如可能更新了某个表的一个字段，然后更新对应的缓存需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值。而另外的表数据可能已经被其他线程修改，从而出现线程安全问题。</p>
<h5 id="如何保证cache与db的操作的同时成功或失败？"><a href="#如何保证cache与db的操作的同时成功或失败？" class="headerlink" title="如何保证cache与db的操作的同时成功或失败？"></a>如何保证cache与db的操作的同时成功或失败？</h5><ul>
<li><p>单体系统，将缓存与数据库操作放在一个事务</p>
</li>
<li><p>分布式系统，利用TCC等分布式事务方案</p>
</li>
</ul>
<h5 id="先操作cache还是先操作db？"><a href="#先操作cache还是先操作db？" class="headerlink" title="先操作cache还是先操作db？"></a>先操作cache还是先操作db？</h5><ul>
<li><p>先删除缓存，再操作数据库</p>
</li>
<li><p>先操作数据库，再删除缓存</p>
</li>
</ul>
<p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653323595206.png" alt="1653323595206"></p>
<p>先删了，没来得及更新数据库20，另一个抢先未命中然后从数据库读取10并写入缓存，最后造成不一致</p>
<p>查的进程刚好缓存失效了，已经查完数据库10，没来的及写缓存，插进来一个更新的进程，更新数据库20并删缓存，最后写缓存10</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241101154820526.png" alt="image-20241101154820526"></p>
<h4 id="Cache-Aside-Pattern-代码实现"><a href="#Cache-Aside-Pattern-代码实现" class="headerlink" title="Cache Aside Pattern 代码实现"></a>Cache Aside Pattern 代码实现</h4><p>核心思路如下：</p>
<p>修改ShopController中的业务逻辑，满足下面的需求：</p>
<p>根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</p>
<p>根据id修改店铺时，先修改数据库，再删除缓存</p>
<p><strong>修改重点代码1</strong>：修改<strong>ShopServiceImpl</strong>的queryById方法</p>
<p><strong>设置redis缓存时添加过期时间</strong> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653325871232.png" alt="1653325871232"></p>
<p><strong>修改重点代码2</strong></p>
<p>代码分析：通过之前的淘汰，我们确定了采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653325929549.png" alt="1653325929549"></p>
<h3 id="缓存穿透—Cache-Penetration"><a href="#缓存穿透—Cache-Penetration" class="headerlink" title="缓存穿透—Cache Penetration"></a>缓存穿透—Cache Penetration</h3><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>缓存空对象<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ul>
<li>额外的内存消耗</li>
<li>可能造成短期的不一致</li>
</ul>
</li>
</ul>
</li>
<li>布隆过滤<ul>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点：<ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p>
<p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p>
<p>假设布隆过滤器判断这个数据不存在，则直接返回</p>
<p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653326156516.png" alt="1653326156516"></p>
<h4 id="编码解决商品查询的缓存穿透问题"><a href="#编码解决商品查询的缓存穿透问题" class="headerlink" title="编码解决商品查询的缓存穿透问题"></a>编码解决商品查询的缓存穿透问题</h4><p>核心思路如下：</p>
<p>在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的</p>
<p>现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。</p>
<p>caching sharding load balancing</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653327124561.png" alt="1653327124561"></p>
<p><strong>小总结：</strong></p>
<p>缓存穿透产生的原因是什么？</p>
<ul>
<li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li>
</ul>
<p>缓存穿透的解决方案有哪些？</p>
<ul>
<li>缓存null值</li>
<li>布隆过滤</li>
<li>增强id的复杂度，避免被猜测id规律</li>
<li>做好数据的基础格式校验</li>
<li>加强用户权限校验</li>
<li>做好热点参数的限流</li>
</ul>
<h3 id="缓存雪崩—Cache-Avalanche"><a href="#缓存雪崩—Cache-Avalanche" class="headerlink" title="缓存雪崩—Cache Avalanche"></a>缓存雪崩—Cache Avalanche</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p>
<p>解决方案：</p>
<ul>
<li>给不同的Key的TTL添加随机值</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653327884526.png" alt="1653327884526"></p>
<h3 id="缓存击穿—Hotspot-Invalid"><a href="#缓存击穿—Hotspot-Invalid" class="headerlink" title="缓存击穿—Hotspot Invalid"></a>缓存击穿—Hotspot Invalid</h3><h4 id="解决思路-1"><a href="#解决思路-1" class="headerlink" title="解决思路"></a>解决思路</h4><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>互斥锁 MUTEX</li>
<li>逻辑过期 LOGICAL EXPIRE</li>
</ul>
<p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653328022622.png" alt="1653328022622"></p>
<p>解决方案一、使用锁来解决：</p>
<p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p>
<p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653328288627.png" alt="1653328288627"></p>
<p>解决方案二、逻辑过期方案</p>
<p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p>
<p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p>
<p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653328663897.png" alt="1653328663897"></p>
<p>进行对比</p>
<p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p>
<p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653357522914.png" alt="1653357522914"></p>
<h4 id="利用互斥锁解决缓存击穿—Mutex—基于setnx"><a href="#利用互斥锁解决缓存击穿—Mutex—基于setnx" class="headerlink" title="利用互斥锁解决缓存击穿—Mutex—基于setnx"></a>利用互斥锁解决缓存击穿—Mutex—基于setnx</h4><p>核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询</p>
<p>如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653357860001.png" alt="1653357860001"></p>
<p><strong>操作锁的代码：</strong></p>
<p>核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，  如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>操作代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span>  &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">       <span class="comment">// 1、从redis中查询商铺缓存</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">       <span class="comment">// 2、判断是否存在</span></span><br><span class="line">       <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">           <span class="comment">// 存在,直接返回</span></span><br><span class="line">           <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//判断命中的值是否是空值</span></span><br><span class="line">       <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//返回一个错误信息</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4.实现缓存重构</span></span><br><span class="line">       <span class="comment">//获取互斥锁</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:shop:&quot;</span> + id;</span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">           <span class="comment">// 判断否获取成功</span></span><br><span class="line">           <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">               <span class="comment">//失败，则休眠重试</span></span><br><span class="line">               Thread.sleep(<span class="number">50</span>);</span><br><span class="line">               <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//成功，根据id查询数据库</span></span><br><span class="line">            shop = getById(id);</span><br><span class="line">           <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">           <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//将空值写入redis</span></span><br><span class="line">               stringRedisTemplate.opsForValue().set(key,<span class="string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">               <span class="comment">//返回错误信息</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//6.写入redis</span></span><br><span class="line">           stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//7.释放互斥锁 </span></span><br><span class="line">           unlock(lockKey);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> shop;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241101214618482.png" alt="image-20241101214618482"></p>
<h4 id="利用逻辑过期解决缓存击穿—LogicalExpire"><a href="#利用逻辑过期解决缓存击穿—LogicalExpire" class="headerlink" title="利用逻辑过期解决缓存击穿—LogicalExpire"></a>利用逻辑过期解决缓存击穿—LogicalExpire</h4><p><strong>需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题</strong></p>
<p>思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653360308731.png" alt="1653360308731"></p>
<p>如果封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，要么你</p>
<p><strong>步骤一、</strong></p>
<p>新建一个实体类，我们采用第二个方案，这个方案，对原来代码没有侵入性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class RedisData &#123;</span><br><span class="line">    private LocalDateTime expireTime;</span><br><span class="line">    private Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤二、</strong></p>
<p>在<strong>ShopServiceImpl</strong> 新增此方法，利用单元测试进行缓存预热</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653360807133.png" alt="1653360807133"></p>
<p><strong>在测试类中</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653360864839.png" alt="1653360864839"></p>
<p>步骤三：正式代码</p>
<p><strong>ShopServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">( Long id )</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">// 2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">        <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">// 5.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">    <span class="comment">// 6.缓存重建</span></span><br><span class="line">    <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//重建缓存</span></span><br><span class="line">                <span class="built_in">this</span>.saveShop2Redis(id,<span class="number">20L</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="封装Redis工具类—CacheClient"><a href="#封装Redis工具类—CacheClient" class="headerlink" title="封装Redis工具类—CacheClient"></a>封装Redis工具类—CacheClient</h3><p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p>
<ul>
<li>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</li>
<li>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓</li>
</ul>
<p>存击穿问题</p>
<ul>
<li>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题</li>
<li>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</li>
</ul>
<p>将逻辑进行封装</p>
<p>重点在于为了普适性要加入泛型，尽可能提高代码复用性，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">// 写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            <span class="comment">// 6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">newR</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">        <span class="comment">// 4.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3.获取锁失败，休眠并重试</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">// 返回错误信息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ShopServiceImpl 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> CacheClient cacheClient;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 解决缓存穿透</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient</span><br><span class="line">                .queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 互斥锁解决缓存击穿</span></span><br><span class="line">        <span class="comment">// Shop shop = cacheClient</span></span><br><span class="line">        <span class="comment">//         .queryWithMutex(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逻辑过期解决缓存击穿</span></span><br><span class="line">        <span class="comment">// Shop shop = cacheClient</span></span><br><span class="line">        <span class="comment">//         .queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, this::getById, 20L, TimeUnit.SECONDS);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="引入布隆过滤器-BloomFilter"><a href="#引入布隆过滤器-BloomFilter" class="headerlink" title="引入布隆过滤器 BloomFilter"></a>引入布隆过滤器 BloomFilter</h3><h4 id="引入Guava依赖"><a href="#引入Guava依赖" class="headerlink" title="引入Guava依赖"></a>引入Guava依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>33.2.1-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="将布隆过滤器交给IoC容器"><a href="#将布隆过滤器交给IoC容器" class="headerlink" title="将布隆过滤器交给IoC容器"></a>将布隆过滤器交给IoC容器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuavaConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;custom.expectedInsertions&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long expectedInsertions;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;custom.fpp&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Double fpp;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BloomFilter&lt;Long&gt; <span class="title function_">shopIdBloomFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BloomFilter.create(Funnels.longFunnel(), expectedInsertions, fpp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BloomFilter&lt;String&gt; <span class="title function_">stringBloomFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BloomFilter.create(Funnels.stringFunnel(StandardCharsets.UTF_8), expectedInsertions, fpp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol>
<li><p>bloomFilter.put() 加入布隆过滤器</p>
</li>
<li><p>bloomFilter.mightContain()判断是否存在</p>
</li>
<li><p>expectedInsertions 布隆过滤器中预期加入的数字</p>
</li>
<li><p>fpp 可接受的误判率</p>
</li>
</ol>
<h2 id="优惠卷秒杀-乐观锁、悲观锁（synchronized）"><a href="#优惠卷秒杀-乐观锁、悲观锁（synchronized）" class="headerlink" title="优惠卷秒杀 乐观锁、悲观锁（synchronized）"></a>优惠卷秒杀 乐观锁、悲观锁（synchronized）</h2><h3 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="-全局唯一ID"></a>-全局唯一ID</h3><p>每个店铺都可以发布优惠券：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653362612286.png" alt="1653362612286"></p>
<p>当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：</p>
<ul>
<li>id的规律性太明显</li>
<li>受单表数据量的限制</li>
</ul>
<p>场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。</p>
<p>场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。</p>
<p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653363100502.png" alt="1653363100502"></p>
<p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653363172079.png" alt="1653363172079">ID的组成部分：符号位：1bit，永远为0</p>
<p>时间戳：31bit，以秒为单位，可以使用69年</p>
<p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p>
<h3 id="Redis实现全局唯一Id"><a href="#Redis实现全局唯一Id" class="headerlink" title="-Redis实现全局唯一Id"></a>-Redis实现全局唯一Id</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisIdWorker</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.生成序列号</span></span><br><span class="line">        <span class="comment">// 2.1.获取当前日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">// 2.2.自增长</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<p>知识小贴士：关于countdownlatch </p>
<p>countdownlatch名为信号枪：主要的作用是同步协调在多线程的等待于唤醒问题</p>
<p>我们如果没有CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch</p>
<p>CountDownLatch 中有两个最重要的方法</p>
<p>1、countDown</p>
<p>2、await</p>
<p>await 方法 是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch  内部维护的 变量变为0时，就不再阻塞，直接放行，那么什么时候CountDownLatch   维护的变量变为0 呢，我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testIdWorker</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">        &#125;</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        es.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line">    latch.await();</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time = &quot;</span> + (end - begin));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加优惠卷"><a href="#添加优惠卷" class="headerlink" title="添加优惠卷"></a>添加优惠卷</h3><p>每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653365145124.png" alt="1653365145124"></p>
<p>tb_voucher：优惠券的基本信息，优惠金额、使用规则等<br>tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息</p>
<p>平价卷由于优惠力度并不是很大，所以是可以任意领取</p>
<p>而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段</p>
<p>**新增普通卷代码：  **VoucherController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.save(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>新增秒杀卷代码：</strong></p>
<p><strong>VoucherController</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;seckill&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addSeckillVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.addSeckillVoucher(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>VoucherServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现秒杀下单"><a href="#实现秒杀下单" class="headerlink" title="实现秒杀下单"></a>实现秒杀下单</h3><p>下单核心思路：当我们点击抢购时，会触发右侧的请求，我们只需要编写对应的controller即可</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653365839526.png" alt="1653365839526"></p>
<p>秒杀下单应该思考的内容：</p>
<p>下单时需要判断两点：</p>
<ul>
<li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li>
<li>库存是否充足，不足则无法下单</li>
</ul>
<p>下单核心逻辑分析：</p>
<p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件</p>
<p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653366238564.png" alt="1653366238564"></p>
<p>VoucherOrderServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5，扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">//扣减库存</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 6.1.订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">// 6.2.用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 6.3.代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="库存超卖问题分析"><a href="#库存超卖问题分析" class="headerlink" title="库存超卖问题分析"></a>库存超卖问题分析</h3><p>有关超卖问题分析：在我们原有代码中是这么写的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="comment">// 库存不足</span></span><br><span class="line">       <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//5，扣减库存</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">           .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">           .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">   <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">       <span class="comment">//扣减库存</span></span><br><span class="line">       <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653368335155.png" alt="1653368335155"></p>
<p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：见下图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653368562591.png" alt="1653368562591"></p>
<p><strong>悲观锁：</strong></p>
<p> 悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</p>
<p><strong>乐观锁：</strong></p>
<p>  乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas</p>
<p>  乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 == 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值</p>
<p>  其中do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var5;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">&#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> var5;</span><br></pre></td></tr></table></figure>

<p><strong>课程中的使用方式：</strong></p>
<p>课程中的使用方式是没有像cas一样带自旋的操作，也没有对version的版本号+1 ，他的操作逻辑是在操作时，对版本号进行+1 操作，然后要求version 如果是1 的情况下，才能操作，那么第一个线程在操作后，数据库中的version变成了2，但是他自己满足version=1 ，所以没有问题，此时线程2执行，线程2 最后也需要加上条件version =1 ，但是现在由于线程1已经操作过了，所以线程2，操作时就不满足version=1 的条件了，所以线程2无法执行成功</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653369268550.png" alt="1653369268550"></p>
<h3 id="乐观锁解决超卖问题"><a href="#乐观锁解决超卖问题" class="headerlink" title="乐观锁解决超卖问题"></a>乐观锁解决超卖问题</h3><p><strong>修改代码方案一、</strong></p>
<p>VoucherOrderServiceImpl 在扣减库存时，改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>) <span class="comment">//set stock = stock -1</span></span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="string">&quot;stock&quot;</span>,voucher.getStock()).update(); <span class="comment">//where id = ？ and stock = ?</span></span><br></pre></td></tr></table></figure>

<p>以上逻辑的核心含义是：只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败</p>
<p><strong>修改代码方案二、</strong></p>
<p>之前的方式要修改前后都保持一致，但是这样我们分析过，成功的概率太低，所以我们的乐观锁需要变一下，改成stock大于0 即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update().gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>); <span class="comment">//where id = ? and stock &gt; 0</span></span><br></pre></td></tr></table></figure>

<p><strong>知识小扩展：</strong></p>
<p>针对cas中的自旋压力过大，我们可以使用Longaddr这个类去解决</p>
<p>Java8 提供的一个对AtomicLong改进后的一个类，LongAdder</p>
<p>大量线程并发更新一个原子性的时候，天然的问题就是自旋，会导致并发性问题，当然这也比我们直接使用syn来的好</p>
<p>所以利用这么一个类，LongAdder来进行优化</p>
<p>如果获取某个值，则会对cell和base的值进行递增，最后返回一个完整的值</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653370271627.png" alt="1653370271627"></p>
<h3 id="优惠券秒杀-一人一单"><a href="#优惠券秒杀-一人一单" class="headerlink" title="优惠券秒杀-一人一单"></a>优惠券秒杀-一人一单</h3><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p>
<p><strong>现在的问题在于：</strong></p>
<p>优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单</p>
<p>具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653371854389.png" alt="1653371854389"></p>
<p>VoucherOrderServiceImpl  </p>
<p><strong>初步代码：增加一人一单逻辑</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.一人一单逻辑</span></span><br><span class="line">    <span class="comment">// 5.1.用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 用户已经购买过了</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6，扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">//扣减库存</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 7.1.订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line"></span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 7.3.代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>存在问题：</strong>现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作</p>
<p><strong>注意：</strong>在这里提到了非常多的问题，我们需要慢慢的来思考，首先我们的初始方案是封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">         <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 7.1.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 7.2.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 7.3.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制<strong>锁粒度</strong> 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：</p>
<h4 id="锁的真正含义"><a href="#锁的真正含义" class="headerlink" title="锁的真正含义"></a>锁的真正含义</h4><p><mark>锁的真正含义<mark>: 导致线程安全问题的线程之间需要拥有同一把锁，比如：字符串常量作为锁，意味着只要能得到这个字符串常量的锁都会参与到锁的竞争中，这会使不相关的线程被阻塞，同样的如果使用<code> synchronized(this)</code>，也会导致所有获得服务对象的线程都会参与锁的竞争，也就是所有用户都被挡在门外，引入悲观锁只是用来解决一人一单问题的，所以应该使用userId作为锁对象，这样不同的用户就不会互相影响。（数据库层面的乐观锁仍然可以有效防止库存负数的问题，先查后改）</p>
<p>拿到相同对象（锁）的线程会串行执行同步代码块，所以不同用户可以并行执行这段代码。</p>
<p>intern() 这个方法是从常量池中拿到数据，如果我们直接使用 <code>userId.toString()</code>他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">	<span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">	<span class="keyword">synchronized</span>(userId.toString().intern())&#123;</span><br><span class="line">         <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 7.1.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 7.2.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 7.3.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事务内部加锁导致事务失效"><a href="#事务内部加锁导致事务失效" class="headerlink" title="事务内部加锁导致事务失效"></a>事务内部加锁导致事务失效</h4><p>但是以上代码还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放，下一个拿到锁的对象就开始执行事务方法了，从而导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题如下：</p>
<p>在seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653373434815.png" alt="1653373434815"></p>
<h4 id="事务自调用导致事务失效"><a href="#事务自调用导致事务失效" class="headerlink" title="事务自调用导致事务失效"></a>事务自调用导致事务失效</h4><p>但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象，来操作事务</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653383810643.png" alt="1653383810643"></p>
<h4 id="事务的粒度控制"><a href="#事务的粒度控制" class="headerlink" title="事务的粒度控制"></a>事务的粒度控制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">secKillVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//省略.......</span></span><br><span class="line">    <span class="keyword">synchronized</span> (id.toString().intern()) &#123;</span><br><span class="line">        <span class="comment">//开启事务要用代理对象</span></span><br><span class="line">        <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">        <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//省略.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在回过头来再看，为什么在外部的<code>seckillVoucher()</code>需要去掉@Transactional注解？里外都声明了事务，并且传播都是默认的<code>REQUIRE</code>，外部方法先开启事务，最后<code>createVoucherOrder()</code> 也是加入的这个大事务，而这样同样会导致锁释放了，事务还没提交。</p>
<h4 id="Transactional-amp-Lock"><a href="#Transactional-amp-Lock" class="headerlink" title="@Transactional &amp; Lock"></a>@Transactional &amp; Lock</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/thisiswhy/p/15175380.html">当Transactional碰到锁，有个大坑，要小心。 - why技术 - 博客园 (cnblogs.com)</a> </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Adoucequan/article/details/123844506">事务中使用分布式锁问题_分布式锁在事务里面,加50毫秒等上一个事务提交后再执行-CSDN博客</a> </p>
<h3 id="集群环境下的并发问题"><a href="#集群环境下的并发问题" class="headerlink" title="集群环境下的并发问题"></a>集群环境下的并发问题</h3><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p>
<p>1、我们将服务启动两份，端口分别为8081和8082：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653373887844.png" alt="1653373887844"></p>
<p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653373908620.png" alt="1653373908620"></p>
<p><strong>具体操作(略)</strong></p>
<h4 id="有关锁失效原因分析"><a href="#有关锁失效原因分析" class="headerlink" title="有关锁失效原因分析"></a><strong>有关锁失效原因分析</strong></h4><p>不同JVM实例的常量池也不同，是隔绝开的，所以实例之间的互斥仅仅靠普通的对象锁是不可靠的</p>
<p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653374044740.png" alt="1653374044740"></p>
<h2 id="分布式锁—为解决分布式-集群进程间的并发安全问题"><a href="#分布式锁—为解决分布式-集群进程间的并发安全问题" class="headerlink" title="分布式锁—为解决分布式/集群进程间的并发安全问题"></a>分布式锁—为解决分布式/集群进程间的并发安全问题</h2><h3 id="基本原理和实现方式对比"><a href="#基本原理和实现方式对比" class="headerlink" title="基本原理和实现方式对比"></a>基本原理和实现方式对比</h3><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p>
<p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653374296906.png" alt="1653374296906"></p>
<p>那么分布式锁他应该满足一些什么样的条件呢？</p>
<p>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p>
<p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p>
<p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p>
<p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p>
<p>安全性：安全也是程序中必不可少的一环</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653381992018.png" alt="1653381992018"></p>
<p>常见的分布式锁有三种</p>
<p>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</p>
<p>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</p>
<p>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653382219377.png" alt="1653382219377"></p>
<h3 id="Redis分布式锁的实现核心思路"><a href="#Redis分布式锁的实现核心思路" class="headerlink" title="Redis分布式锁的实现核心思路"></a>Redis分布式锁的实现核心思路</h3><p>实现分布式锁时需要实现的两个基本方法：</p>
<ul>
<li><p>获取锁：</p>
<ul>
<li>互斥：确保只能有一个线程获取锁</li>
<li>非阻塞：尝试一次，成功返回true，失败返回false</li>
</ul>
</li>
<li><p>释放锁：</p>
<ul>
<li>手动释放</li>
<li>超时释放：获取锁时添加一个超时时间</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653382669900.png" alt="1653382669900"></p>
</li>
</ul>
<p>核心思路：</p>
<p>我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653382830810.png" alt="1653382830810"></p>
<h3 id="实现分布式锁版本一"><a href="#实现分布式锁版本一" class="headerlink" title="实现分布式锁版本一"></a>实现分布式锁版本一</h3><ul>
<li>加锁逻辑</li>
</ul>
<p><strong>锁的基本接口</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1656079017728.png" alt="1656079017728"></p>
<p><strong>SimpleRedisLock</strong></p>
<p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_PREFIX=<span class="string">&quot;lock:&quot;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId()</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>释放锁逻辑</li>
</ul>
<p>SimpleRedisLock</p>
<p>释放锁，防止删除别人的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//通过del删除锁</span></span><br><span class="line">    stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改业务代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">      <span class="comment">// 1.查询优惠券</span></span><br><span class="line">      <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">      <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">// 尚未开始</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">// 尚未开始</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// 库存不足</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">      <span class="comment">//创建锁对象(新增代码)</span></span><br><span class="line">      <span class="type">SimpleRedisLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(<span class="string">&quot;order:&quot;</span> + userId, stringRedisTemplate);</span><br><span class="line">      <span class="comment">//获取锁对象</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1200</span>);</span><br><span class="line"><span class="comment">//加锁失败</span></span><br><span class="line">      <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">          <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">          <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//释放锁</span></span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Redis分布式锁误删情况说明"><a href="#Redis分布式锁误删情况说明" class="headerlink" title="Redis分布式锁误删情况说明"></a>Redis分布式锁误删情况说明</h3><p>逻辑说明：</p>
<p>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p>
<p>解决方案：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653385920025.png" alt="1653385920025"></p>
<h3 id="解决Redis分布式锁误删问题—本线程误删了其他线程的锁"><a href="#解决Redis分布式锁误删问题—本线程误删了其他线程的锁" class="headerlink" title="解决Redis分布式锁误删问题—本线程误删了其他线程的锁"></a>解决Redis分布式锁误删问题—本线程误删了其他线程的锁</h3><p>需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用UUID表示）<br>在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</p>
<ul>
<li>如果一致则释放锁</li>
<li>如果不一致则不释放锁</li>
</ul>
<p>核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653387398820.png" alt="1653387398820"></p>
<p>具体代码如下：加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取线程标示</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">   <span class="comment">// 获取锁</span></span><br><span class="line">   <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">   <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁中的标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">// 判断标示是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id)) &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有关代码实操说明：</strong></p>
<p>在我们修改完此处代码后，我们重启工程，然后启动两个线程，第一个线程持有锁后，手动释放锁，第二个线程 此时进入到锁内部，再放行第一个线程，此时第一个线程由于锁的value值并非是自己，所以不能释放锁，也就无法删除别人的锁，此时第二个线程能够正确释放锁，通过这个案例初步说明我们解决了锁误删的问题。</p>
<h3 id="分布式锁的原子性问题—Full-GC带来的JAVA代码阻塞延时"><a href="#分布式锁的原子性问题—Full-GC带来的JAVA代码阻塞延时" class="headerlink" title="分布式锁的原子性问题—Full GC带来的JAVA代码阻塞延时"></a>分布式锁的原子性问题—Full GC带来的JAVA代码阻塞延时</h3><p><mark>Full GC<mark>，即完全垃圾回收，是指JVM对堆内存的所有区域（年轻代、老年代以及永久代/元空间）进行的全面清理过程。与之相对的是Minor GC，通常只清理年轻代。Full GC的触发通常是响应式而非主动的，比如堆内存不足、永久代满载等情况。由于Full GC涉及范围广，耗时较长，因此可能会引起应用程序的显著暂停（Stop-the-world），影响用户体验。</p>
<p><mark>判断的动作 与 真正delete的动作不是同步的<mark> 导致在delete操作之前锁已经超时释放，被另一个线程获取，但是依然被第一个线程误删</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">currentLockerId</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOCK_KEY_PREFIX + name);</span><br><span class="line">    <span class="keyword">if</span> (StrUtil.equals(currentLockerId, threadId)) &#123;</span><br><span class="line">        <span class="comment">//阻塞。。。。。</span></span><br><span class="line">        stringRedisTemplate.delete(LOCK_KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>更为极端的误删逻辑说明：</p>
<p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653387764938.png" alt="1653387764938"></p>
<h3 id="Lua脚本解决多条命令原子性问题"><a href="#Lua脚本解决多条命令原子性问题" class="headerlink" title="Lua脚本解决多条命令原子性问题"></a>Lua脚本解决多条命令原子性问题</h3><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：<a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-tutorial.html%EF%BC%8C%E8%BF%99%E9%87%8C%E9%87%8D%E7%82%B9%E4%BB%8B%E7%BB%8DRedis%E6%8F%90%E4%BE%9B%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8lua%E5%8E%BB%E6%93%8D%E4%BD%9Credis%EF%BC%8C%E5%8F%88%E8%83%BD%E4%BF%9D%E8%AF%81%E4%BB%96%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8B%BF%E9%94%81%E6%AF%94%E9%94%81%E5%88%A0%E9%94%81%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8A%A8%E4%BD%9C%E4%BA%86%EF%BC%8C%E4%BD%9C%E4%B8%BAJava%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%99%E4%B8%80%E5%9D%97%E5%B9%B6%E4%B8%8D%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%A6%81%E6%B1%82%EF%BC%8C%E5%B9%B6%E4%B8%8D%E9%9C%80%E8%A6%81%E5%A4%A7%E5%AE%B6%E8%BF%87%E4%BA%8E%E7%B2%BE%E9%80%9A%EF%BC%8C%E5%8F%AA%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E4%BB%96%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E5%8D%B3%E5%8F%AF%E3%80%82">https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了，作为Java程序员这一块并不作一个简单要求，并不需要大家过于精通，只需要知道他有什么作用即可。</a></p>
<h4 id="原子性的含义"><a href="#原子性的含义" class="headerlink" title="原子性的含义"></a><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8E%9F%E5%AD%90%E6%80%A7&spm=1001.2101.3001.7020">原子性的含义</a></h4><p>首先何为<strong>原子性</strong> ？原子性 是指<strong>操作不可分割</strong>，要么全部执行成功，要么全部执行失败，中间不会被打断。</p>
<p><strong>使用 lua 脚本就可以实现一组操作的原子性</strong>，这些操作作为一个整体，要么全部执行成功，要么全部执行失败，也就不会存在不同的操作先后执行、多个线程之间相互穿插的情况了。</p>
<h4 id="Redis-单线程模型"><a href="#Redis-单线程模型" class="headerlink" title="Redis 单线程模型"></a>Redis 单线程模型</h4><p><strong>redis 是一个单线程模型的数据库</strong>。redis 虽然可以支持多个客户端的并发连接，<strong>但是每个客户端的操作其实是按照顺序进行的</strong>。也就是说，如果一个客户端正在执行某个操作，其他客户端需要等待这个操作执行完毕后才能进行操作。</p>
<p>看到这里，应该也就能够明白了。我们把多个操作写成一个 lua 脚本，使其具备原子性，作为一个整体执行。再由于 redis 是单线程模型，<strong>不同线程的 lua 脚本是依次执行的</strong>。也就是说，<strong>只有一个线程原子性的多个操作执行完，下一个线程才可以执行</strong>。实际上也是保证了在 redis 内部不同线程操作的串行执行，从而能够解决并发安全问题。</p>
<p>因此，结合 lua 脚本可以实现原子操作，对于需要对多个 key 进行操作的场景，可以把多个操作封装到一个 lua 脚本中，这样就可以保证这些操作的原子性，避免多个线程之间的数据竞争问题，从而保证<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Redis%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020">Redis数据库</a>的数据一致性和可靠性。</p>
<h4 id="Lua-脚本语法"><a href="#Lua-脚本语法" class="headerlink" title="Lua 脚本语法"></a>Lua 脚本语法</h4><p>这里重点介绍Redis提供的调用函数，语法如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其它参数&#x27;</span>, ...)</span><br></pre></td></tr></table></figure>

<p>例如，我们要执行set name jack，则脚本是这样：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 先执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>)</span><br><span class="line"># 再执行 get name</span><br><span class="line"><span class="keyword">local</span> name = redis.call(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"># 返回</span><br><span class="line"><span class="keyword">return</span> name</span><br></pre></td></tr></table></figure>

<p>写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653392181413.png" alt="1653392181413"></p>
<p>例如，我们要执行 redis.call(‘set’, ‘name’, ‘jack’) 这个脚本，语法如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653392218531.png" alt="1653392218531"></p>
<p>如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653392438917.png" alt="1653392438917"></p>
<p>接下来我们来回一下我们释放锁的逻辑：</p>
<p>释放锁的业务流程是这样的</p>
<p>​    1、获取锁中的线程标示</p>
<p>​    2、判断是否与指定的标示（当前线程标示）一致</p>
<p>​    3、如果一致则释放锁（删除）</p>
<p>​    4、如果不一致则什么都不做</p>
<p>如果用Lua脚本来表示则是这样的：</p>
<p>最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h3 id="利用Java代码调用Lua脚本改造分布式锁"><a href="#利用Java代码调用Lua脚本改造分布式锁" class="headerlink" title="利用Java代码调用Lua脚本改造分布式锁"></a>利用Java代码调用Lua脚本改造分布式锁</h3><p>lua脚本本身并不需要大家花费太多时间去研究，只需要知道如何调用，大致是什么意思即可，所以在笔记中并不会详细的去解释这些lua表达式的含义。</p>
<p>我们的RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图股</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653393304844.png" alt="1653393304844"></p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br><span class="line">经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~</span><br></pre></td></tr></table></figure>

<p>小总结：</p>
<p>基于Redis的分布式锁实现思路：</p>
<ul>
<li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li>
<li>释放锁时先判断线程标示是否与自己一致，一致则删除锁<ul>
<li>特性：<ul>
<li>利用set nx满足互斥性</li>
<li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li>
<li>利用Redis集群保证高可用和高并发特性</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>笔者总结：我们一路走来，利用添加过期时间，防止死锁问题的发生，但是有了过期时间之后，可能出现误删别人锁的问题，这个问题我们开始是利用删之前 通过拿锁，比锁，删锁这个逻辑来解决的，也就是删之前判断一下当前这把锁是否是属于自己的，但是现在还有原子性问题，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后通过lua表达式来解决这个问题</p>
<p>但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission啦</p>
<p><strong>测试逻辑：</strong></p>
<p>第一个线程进来，得到了锁，手动删除锁，模拟锁超时了，其他线程会执行lua来抢锁，当第一天线程利用lua删除锁时，lua能保证他不能删除他的锁，第二个线程删除锁时，利用lua同样可以保证不会删除别人的锁，同时还能保证原子性。</p>
<h2 id="分布式锁-Redission"><a href="#分布式锁-Redission" class="headerlink" title="分布式锁-Redission"></a>分布式锁-Redission</h2><h3 id="分布式锁-Redission-功能介绍"><a href="#分布式锁-Redission-功能介绍" class="headerlink" title="分布式锁-Redission 功能介绍"></a>分布式锁-Redission 功能介绍</h3><p>基于setnx实现的分布式锁存在下面的问题：</p>
<p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，<strong>他的方法都是使用synchronized修饰</strong>的（锁对象都是this），假如他在A方法内，调用B方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p>
<p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p>
<p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p>
<p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653546070602.png" alt="1653546070602"></p>
<p>那么什么是Redission呢</p>
<p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p>
<p>Redission提供了分布式锁的多种多样的功能</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653546736063.png" alt="1653546736063"></p>
<h3 id="分布式锁-Redission-快速入门"><a href="#分布式锁-Redission-快速入门" class="headerlink" title="分布式锁-Redission 快速入门"></a>分布式锁-Redission 快速入门</h3><p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置Redisson客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.150.101:6379&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如何使用Redission的分布式锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 VoucherOrderServiceImpl</p>
<p>注入RedissonClient</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询优惠券</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 尚未开始</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 尚未开始</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 库存不足</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//创建锁对象 这个代码不用了，因为我们现在要使用分布式锁</span></span><br><span class="line">        <span class="comment">//SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">        <span class="comment">//获取锁对象</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">       </span><br><span class="line">		<span class="comment">//加锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">            <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="分布式锁-Redission-可重入锁原理"><a href="#分布式锁-Redission-可重入锁原理" class="headerlink" title="分布式锁-Redission 可重入锁原理"></a>分布式锁-Redission 可重入锁原理</h3><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state=0，假如有人持有这把锁，那么state=1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0 时，表示当前这把锁没有被人持有。  </p>
<p>在redission中，我们的也支持支持可重入锁</p>
<p>在分布式锁中，他采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有，所以接下来我们一起分析一下当前的这个lua表达式</p>
<p>这个地方一共有3个参数</p>
<p><strong>KEYS[1] ： 锁名称</strong></p>
<p><strong>ARGV[1]：  锁失效时间</strong></p>
<p><strong>ARGV[2]：  id + “:” + threadId; 锁的小key</strong></p>
<p>exists: 判断数据是否存在  name：是lock是否存在,如果==0，就表示当前这把锁不存在</p>
<p>redis.call(‘hset’, KEYS[1], ARGV[2], 1);此时他就开始往redis里边去写数据 ，写成一个hash结构</p>
<p>Lock{</p>
<p>​    id + <strong>“:”</strong> + threadId :  1</p>
<p>}</p>
<p>如果当前这把锁存在，则第一个条件不满足，再判断</p>
<p>redis.call(‘hexists’, KEYS[1], ARGV[2]) == 1</p>
<p>此时需要通过大key+小key判断当前这把锁是否是属于自己的，如果是自己的，则进行</p>
<p>redis.call(‘hincrby’, KEYS[1], ARGV[2], 1)</p>
<p>将当前这个锁的value进行+1 ，redis.call(‘pexpire’, KEYS[1], ARGV[1]); 然后再对其设置过期时间，如果以上两个条件都不满足，则表示当前这把锁抢锁失败，最后返回pttl，即为当前这把锁的失效时间</p>
<p>如果小伙帮们看了前边的源码， 你会发现他会去判断当前这个方法的返回值是否为null，如果是null，则对应则前两个if对应的条件，退出抢锁逻辑，如果返回的不是null，即走了第三个分支，在源码处会进行while(true)的自旋抢锁。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653548087334.png" alt="1653548087334"></p>
<h3 id="分布式锁-Redission锁重试和WatchDog机制"><a href="#分布式锁-Redission锁重试和WatchDog机制" class="headerlink" title="分布式锁-Redission锁重试和WatchDog机制"></a>分布式锁-Redission锁重试和WatchDog机制</h3><p><strong>说明</strong>：由于课程中已经说明了有关tryLock的源码解析以及其看门狗原理，所以笔者在这里给大家分析lock()方法的源码解析，希望大家在学习过程中，能够掌握更多的知识</p>
<p>抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p>
<p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p>
<p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p>
<p>所以如果返回是null，则代表着当前这哥们已经抢锁完毕，或者可重入完毕，但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，同学们可以自行往下翻一点点，你能发现有个while( true) 再次进行tryAcquire进行抢锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line"><span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line"><span class="comment">// lock acquired</span></span><br><span class="line"><span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来会有一个条件分支，因为lock方法有重载方法，一个是带参数，一个是不带参数，如果带带参数传入的值是-1，如果传入参数，则leaseTime是他本身，所以如果传入了参数，此时leaseTime != -1 则会进去抢锁，抢锁的逻辑就是之前说的那三个逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是没有传入时间，则此时也会进行抢锁， 而且抢锁时间是默认看门狗时间 commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()</p>
<p>ttlRemainingFuture.onComplete((ttlRemaining, e) 这句话相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class="line">                                        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">                                        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock acquired</span></span><br><span class="line">    <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">        scheduleExpirationRenewal(threadId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> ttlRemainingFuture;</span><br></pre></td></tr></table></figure>

<p>此逻辑就是续约逻辑，注意看commandExecutor.getConnectionManager().newTimeout（） 此方法</p>
<p>Method(  <strong>new</strong> TimerTask() {},参数2 ，参数3  )</p>
<p>指的是：通过参数2，参数3 去描述什么时候去做参数1的事情，现在的情况是：10s之后去做参数一的事情</p>
<p>因为锁的失效时间是30s，当10s之后，此时这个timeTask 就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约</p>
<p>那么大家可以想一想，假设我们的线程出现了宕机他还会续约吗？当然不会，因为没有人再去调用renewExpiration这个方法，所以等到时间之后自然就释放了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">            <span class="keyword">if</span> (ent == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">            <span class="keyword">if</span> (threadId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">// reschedule itself</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    </span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Redisson-获取锁、释放锁逻辑"><a href="#Redisson-获取锁、释放锁逻辑" class="headerlink" title="Redisson 获取锁、释放锁逻辑"></a>Redisson 获取锁、释放锁逻辑</h4><p>tryLock() 只获取一次，不重试</p>
<p>tryLock(waitTime, leaseTime, TimeUnit) 可重试，有等待时间和超时释放</p>
<p><code>leaseTime</code>超时释放时间，<code>waitTime</code>最大等待时间</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241109153113839.png" alt="image-20241109153113839"></p>
<h5 id="超时续约（TTL与业务执行情况挂钩）"><a href="#超时续约（TTL与业务执行情况挂钩）" class="headerlink" title="超时续约（TTL与业务执行情况挂钩）"></a>超时续约（TTL与业务执行情况挂钩）</h5><p>获取成功，但不设置释放时间，此时会把leaseTime设置为-1，然后开启看门狗线程，设置定时任务定时更新TTL，实现了锁有效期的不断重置。<strong>如何跟业务产生联系</strong>：当业务执行完毕会释放锁，此时会将定时任务取消。如果看门狗线程出现宕机，过一段时间也会自动释放。</p>
<p>在释放的同时会发布<code>publish</code>一个释放的消息给其他等待的线程。</p>
<h5 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h5><p>获取失败会订阅<code>subscribe</code>释放的消息，再等一段时间，如果获取到释放锁的信号，重试获取锁，如果一直没获取到，超出最大等待时间之后会返回false。</p>
<h3 id="分布式锁-Redission锁的MultiLock原理"><a href="#分布式锁-Redission锁的MultiLock原理" class="headerlink" title="分布式锁-Redission锁的MultiLock原理"></a>分布式锁-Redission锁的MultiLock原理</h3><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p>
<p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653553998403.png" alt="1653553998403"></p>
<p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653554055048.png" alt="1653554055048"></p>
<p>那么MutiLock 加锁原理是什么呢？笔者画了一幅图来说明</p>
<p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间(waitTime)，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试，重试要从头再来。</p>
<p>成功获取所有锁之后，如果之前设置了leaseTime释放时间，还要重新设置一下TTL，因为成功获取一把锁，这把锁就开始倒计时了，导致expireTime不统一</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653553093967.png" alt="1653553093967"></p>
<h3 id="分布式锁-总结"><a href="#分布式锁-总结" class="headerlink" title="分布式锁 总结"></a>分布式锁 总结</h3><h4 id="不可重入Redis分布式锁—基于setnx"><a href="#不可重入Redis分布式锁—基于setnx" class="headerlink" title="不可重入Redis分布式锁—基于setnx"></a>不可重入Redis分布式锁—基于setnx</h4><p>利用setnx互斥性，释放锁时使用线程标示防止误删</p>
<p>缺陷：不可重入（同一线程无法重复获取）无法重试（完全非阻塞）超时失效</p>
<h4 id="可重入Redis分布式锁—基于Redisson"><a href="#可重入Redis分布式锁—基于Redisson" class="headerlink" title="可重入Redis分布式锁—基于Redisson"></a>可重入Redis分布式锁—基于Redisson</h4><p>与ReentrantLock类似，利用Hash结构，记录线程标示，同时也记录重入次数（可重入）</p>
<p>使用Watchdog机制实现超时可续约，将锁与业务执行情况挂钩。</p>
<p>利用信号量，使用发布订阅这样的异步等待机制实现可重试</p>
<p>缺点：Redis主从模式下主机宕机会引起锁失效</p>
<h4 id="铁锁连环—Redisson-Multilock"><a href="#铁锁连环—Redisson-Multilock" class="headerlink" title="铁锁连环—Redisson Multilock"></a>铁锁连环—Redisson Multilock</h4><p>将多个Redisson锁合并成一把锁，必须把这些锁全部拿到才算获取成功，一扇门用若干锁锁起来。</p>
<p>缺陷：运维成本高，需要多个Redis节点，实现起来较为复杂</p>
<h2 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h2><h3 id="秒杀优化-异步秒杀思路"><a href="#秒杀优化-异步秒杀思路" class="headerlink" title="秒杀优化-异步秒杀思路"></a>秒杀优化-异步秒杀思路</h3><p>我们来回顾一下下单流程</p>
<p>当用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤</p>
<p>1、查询优惠卷</p>
<p><mark>2、判断秒杀库存是否足够<mark></p>
<p>3、查询订单</p>
<p><mark>4、校验是否是一人一单<mark></p>
<p>5、扣减库存</p>
<p>6、创建订单</p>
<p>在这六步操作中，又有很多操作是要去操作数据库的，而且还是一个线程串行执行， 这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行，那么如何加速呢？</p>
<p>在这里笔者想给大家分享一下课程内没有的思路，看看有没有小伙伴这么想，比如，我们可以不可以使用异步编排来做，或者说我开启N多线程，N多个线程，一个线程执行查询优惠卷，一个执行判断扣减库存，一个去创建订单等等，然后再统一做返回，这种做法和课程中有哪种好呢？答案是课程中的好，因为如果你采用我刚说的方式，如果访问的人很多，那么线程池中的线程可能一下子就被消耗完了，而且你使用上述方案，最大的特点在于，你觉得时效性会非常重要，但是你想想是吗？并不是，比如我只要确定他能做这件事，然后我后边慢慢做就可以了，我并不需要他一口气做完这件事，所以我们应当采用的是课程中，类似消息队列的方式来完成我们的需求，而不是使用线程池或者是异步编排的方式来完成这个需求。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653560986599.png" alt="1653560986599"></p>
<p>优化方案：我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点</p>
<p>第一个难点是我们怎么在redis中去快速校验一人一单，还有库存判断</p>
<p>第二个难点是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653561657295.png" alt="1653561657295"></p>
<p>我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua来操作</p>
<p>当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653562234886.png" alt="1653562234886"></p>
<h3 id="秒杀优化-Redis完成秒杀资格判断"><a href="#秒杀优化-Redis完成秒杀资格判断" class="headerlink" title="秒杀优化-Redis完成秒杀资格判断"></a>秒杀优化-Redis完成秒杀资格判断</h3><p>需求：</p>
<ul>
<li><p>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</p>
</li>
<li><p>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</p>
</li>
<li><p>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列  </p>
</li>
<li><p>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1656080546603.png" alt="1656080546603"></p>
</li>
</ul>
<p>VoucherServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    <span class="comment">//SECKILL_STOCK_KEY 这个变量定义在RedisConstans中</span></span><br><span class="line">    <span class="comment">//private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整lua表达式</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.参数列表</span></span><br><span class="line"><span class="comment">-- 1.1.优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 1.2.用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 1.3.订单id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1.库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2.订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1.判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2.库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3.存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.4.扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5.下单（保存用户）sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span></span><br><span class="line">redis.call(<span class="string">&#x27;xadd&#x27;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;id&#x27;</span>, orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>当以上lua表达式执行完毕后，剩下的就是根据步骤3,4来执行我们接下来的任务了</p>
<p>VoucherOrderServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//获取用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">// 1.执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">            SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(),</span><br><span class="line">            voucherId.toString(), userId.toString(), String.valueOf(orderId)</span><br><span class="line">    );</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">    <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TODO 保存阻塞队列</span></span><br><span class="line">    <span class="comment">// 3.返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="秒杀优化-基于阻塞队列实现秒杀优化"><a href="#秒杀优化-基于阻塞队列实现秒杀优化" class="headerlink" title="秒杀优化-基于阻塞队列实现秒杀优化"></a>秒杀优化-基于阻塞队列实现秒杀优化</h3><p>VoucherOrderServiceImpl</p>
<p>修改下单动作，现在我们去下单时，是通过lua表达式去原子执行判断逻辑，如果判断我出来不为0 ，则要么是库存不足，要么是重复下单，返回错误信息，如果是0，则把下单的逻辑保存到队列中去，然后异步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步处理线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">   SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于线程池处理的任务</span></span><br><span class="line"><span class="comment">// 当初始化完毕后，就会去从对列中去拿信息</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1.获取队列中的订单信息</span></span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                    <span class="comment">// 2.创建订单</span></span><br><span class="line">                    handleVoucherOrder(voucherOrder);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">          	 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取用户</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">            <span class="comment">// 2.创建锁对象</span></span><br><span class="line">            <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">            <span class="comment">// 3.尝试获取锁</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.lock();</span><br><span class="line">            <span class="comment">// 4.判断是否获得锁成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 获取锁失败，直接返回失败或者重试</span></span><br><span class="line">                log.error(<span class="string">&quot;不允许重复下单！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效</span></span><br><span class="line">                proxy.createVoucherOrder(voucherOrder);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                redisLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//a</span></span><br><span class="line">	<span class="keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks =<span class="keyword">new</span>  <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.执行lua脚本</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">                SECKILL_SCRIPT,</span><br><span class="line">                Collections.emptyList(),</span><br><span class="line">                voucherId.toString(), userId.toString(), String.valueOf(orderId)</span><br><span class="line">        );</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">        <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 2.3.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 2.4.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 2.5.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="comment">// 2.6.放入阻塞队列</span></span><br><span class="line">        orderTasks.add(voucherOrder);</span><br><span class="line">        <span class="comment">//3.获取代理对象</span></span><br><span class="line">         proxy = (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">        <span class="comment">//4.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">      <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">           log.error(<span class="string">&quot;用户已经购买过了&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="秒杀业务的优化思路"><a href="#秒杀业务的优化思路" class="headerlink" title="秒杀业务的优化思路"></a>秒杀业务的优化思路</h3><p>之前：通过查数据库判断用户是否有资格下单，然后同步创建订单对象</p>
<p>现在：</p>
<ul>
<li>先利用Redis完成库存余量、一人一单判断，提前创建订单，完成抢单业务（直接返回给前端结果）</li>
<li>再将下单业务放入阻塞队列，利用独立线程异步下单，完成数据库的更改</li>
</ul>
<h4 id="基于阻塞队列的异步秒杀存在哪些问题"><a href="#基于阻塞队列的异步秒杀存在哪些问题" class="headerlink" title="基于阻塞队列的异步秒杀存在哪些问题"></a>基于阻塞队列的异步秒杀存在哪些问题</h4><ul>
<li>内存限制问题：BlockingQueue基于JVM，会受JVM内存限制</li>
<li>数据安全问题：<ul>
<li>JVM宕机会导致订单信息全部丢失，无法进行数据库更改</li>
<li>订单从阻塞队列中取出，执行之前发生了一些问题，导致任务失败，但是已经找不回来了</li>
</ul>
</li>
</ul>
<h2 id="Redis消息队列（Stream）"><a href="#Redis消息队列（Stream）" class="headerlink" title="Redis消息队列（Stream）"></a>Redis消息队列（Stream）</h2><h3 id="Redis消息队列-认识消息队列"><a href="#Redis消息队列-认识消息队列" class="headerlink" title="Redis消息队列-认识消息队列"></a>Redis消息队列-认识消息队列</h3><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p>
<ul>
<li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li>
<li>生产者：发送消息到消息队列</li>
<li>消费者：从消息队列获取消息并处理消息</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653574849336.png" alt="1653574849336"></p>
<p>使用队列的好处在于 <strong>解耦：</strong>所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。</p>
<p>这种场景在我们秒杀中就变成了：我们下单之后，利用redis去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。</p>
<p>这里我们可以使用一些现成的mq，比如kafka，rabbitmq等等，但是呢，如果没有安装mq，我们也可以直接使用redis提供的mq方案，降低我们的部署和学习成本。</p>
<h3 id="Redis消息队列-基于List实现消息队列"><a href="#Redis消息队列-基于List实现消息队列" class="headerlink" title="Redis消息队列-基于List实现消息队列"></a>Redis消息队列-基于List实现消息队列</h3><p><strong>基于List结构模拟消息队列</strong></p>
<p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p>
<p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653575176451.png" alt="1653575176451"></p>
<p>基于List的消息队列有哪些优缺点？<br>优点：</p>
<ul>
<li>利用Redis存储，不受限于JVM内存上限</li>
<li>基于Redis的持久化机制，数据安全性有保证</li>
<li>可以满足消息有序性</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法避免消息丢失</li>
<li>只支持单消费者</li>
</ul>
<h3 id="Redis消息队列-基于PubSub的消息队列"><a href="#Redis消息队列-基于PubSub的消息队列" class="headerlink" title="Redis消息队列-基于PubSub的消息队列"></a>Redis消息队列-基于PubSub的消息队列</h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p>
<p> SUBSCRIBE channel [channel] ：订阅一个或多个频道<br> PUBLISH channel msg ：向一个频道发送消息<br> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653575506373.png" alt="1653575506373"></p>
<p>基于PubSub的消息队列有哪些优缺点？<br>优点：</p>
<ul>
<li>采用发布订阅模型，支持多生产、多消费</li>
</ul>
<p>缺点：</p>
<ul>
<li>不支持数据持久化</li>
<li>无法避免消息丢失</li>
<li>消息堆积有上限，超出时数据丢失</li>
</ul>
<h3 id="Redis消息队列-基于Stream的消息队列"><a href="#Redis消息队列-基于Stream的消息队列" class="headerlink" title="Redis消息队列-基于Stream的消息队列"></a>Redis消息队列-基于Stream的消息队列</h3><p>Stream 是 Redis 5.0引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p>
<p>发送消息的命令：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577301737.png" alt="1653577301737"></p>
<p>例如：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577349691.png" alt="1653577349691"></p>
<p>读取消息的方式之一：XREAD</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577445413.png" alt="1653577445413"></p>
<p>例如，使用XREAD读取第一个消息：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577643629.png" alt="1653577643629"></p>
<p>XREAD阻塞方式，读取最新的消息：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577659166.png" alt="1653577659166"></p>
<p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577689129.png" alt="1653577689129"></p>
<p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p>
<p>STREAM类型消息队列的XREAD命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>一个消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li>有消息漏读的风险</li>
</ul>
<h3 id="Redis消息队列-基于Stream的消息队列-消费者组"><a href="#Redis消息队列-基于Stream的消息队列-消费者组" class="headerlink" title="Redis消息队列-基于Stream的消息队列-消费者组"></a>Redis消息队列-基于Stream的消息队列-消费者组</h3><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577801668.png" alt="1653577801668"></p>
<p>创建消费者组：<br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577984924.png" alt="1653577984924"><br>key：队列名称<br>groupName：消费者组名称<br>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息<br>MKSTREAM：队列不存在时自动创建队列<br>其它常见命令：</p>
<p> <strong>删除指定的消费者组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP DESTORY key groupName</span><br></pre></td></tr></table></figure>

<p> <strong>给指定的消费者组添加消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br></pre></td></tr></table></figure>

<p> <strong>删除消费者组中的指定消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP DELCONSUMER key groupname consumername</span><br></pre></td></tr></table></figure>

<p>从消费者组读取消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>group：消费组名称</li>
<li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li>
<li>count：本次查询的最大数量</li>
<li>BLOCK milliseconds：当没有消息时最长等待时间</li>
<li>NOACK：无需手动ACK，获取到消息后自动确认</li>
<li>STREAMS key：指定队列名称</li>
<li>ID：获取消息的起始ID：</li>
</ul>
<p>“&gt;”：从下一个未消费的消息开始<br>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span><br><span class="line">位于消费者组g1的消费者c1读取一条消息，没有消息最长阻塞等待2000ms，</span><br><span class="line">消息来源key为s1，从s1下一个未消费的消息开始</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XACK s1 g1 ID1 ID2 ID3</span><br><span class="line">消息来源为s1，使用g1把ID1 ID2 ID3消息确认，从pendinglist中移除消息</span><br></pre></td></tr></table></figure>



<p>消费者监听消息的基本思路：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653578211854.png" alt="1653578211854">STREAM类型消息队列的XREADGROUP命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>可以多消费者争抢消息，加快消费速度</li>
<li>可以阻塞读取</li>
<li>没有消息漏读的风险</li>
<li>有消息确认机制，保证消息至少被消费一次</li>
</ul>
<p>最后我们来个小对比</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653578560691.png" alt="1653578560691"></p>
<h3 id="基于Redis的Stream结构作为消息队列，实现异步秒杀下单"><a href="#基于Redis的Stream结构作为消息队列，实现异步秒杀下单" class="headerlink" title="基于Redis的Stream结构作为消息队列，实现异步秒杀下单"></a>基于Redis的Stream结构作为消息队列，实现异步秒杀下单</h3><p>需求：</p>
<ul>
<li>创建一个Stream类型的消息队列，名为stream.orders</li>
<li>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</li>
<li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单\</li>
</ul>
<p>修改lua表达式,新增3.6</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1656082824939.png" alt="1656082824939"></p>
<p>VoucherOrderServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                    StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.lastConsumed())</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有消息，继续下一次循环</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                <span class="comment">//处理异常消息</span></span><br><span class="line">                handlePendingList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                    StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有异常消息，结束循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理pendding订单异常&quot;</span>, e);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Redis消息队列—Stream结构总结"><a href="#Redis消息队列—Stream结构总结" class="headerlink" title="Redis消息队列—Stream结构总结"></a>Redis消息队列—Stream结构总结</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577801668.png" alt="1653577801668"></p>
<p>STREAM类型消息队列的XREADGROUP命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>可阻塞读取</li>
<li>消息可分流：多个消费者争抢消息，加快处理速度</li>
<li>消息标示机制：确保没有消息被漏读</li>
<li>消息确认机制：获取消息后加入pending-list，处理完成要通过XACK从pending-list移除，实现消息回溯</li>
<li>保证消息至少被消费一次</li>
</ul>
<p>最后我们来个小对比</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653578560691.png" alt="1653578560691"></p>
<p>——秒杀 完——</p>
<h2 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h2><h3 id="达人探店-发布探店笔记"><a href="#达人探店-发布探店笔记" class="headerlink" title="达人探店-发布探店笔记"></a>达人探店-发布探店笔记</h3><p>发布探店笔记</p>
<p>探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个：<br>tb_blog：探店笔记表，包含笔记中的标题、文字、图片等<br>tb_blog_comments：其他用户对探店笔记的评价</p>
<p><strong>具体发布流程</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653578992639.png" alt="1653578992639"></p>
<p>上传接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;blog&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">uploadImage</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile image)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取原始文件名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line">            <span class="comment">// 生成新文件名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> createNewFileName(originalFilename);</span><br><span class="line">            <span class="comment">// 保存文件</span></span><br><span class="line">            image.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, fileName));</span><br><span class="line">            <span class="comment">// 返回结果</span></span><br><span class="line">            log.debug(<span class="string">&quot;文件上传成功，&#123;&#125;&quot;</span>, fileName);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件上传失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：同学们在操作时，需要修改SystemConstants.IMAGE_UPLOAD_DIR 自己图片所在的地址，在实际开发中图片一般会放在nginx上或者是云存储上。</p>
<p>BlogController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/blog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlogController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IBlogService blogService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(<span class="meta">@RequestBody</span> Blog blog)</span> &#123;</span><br><span class="line">        <span class="comment">//获取登录用户</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        blog.setUpdateTime(user.getId());</span><br><span class="line">        <span class="comment">//保存探店博文</span></span><br><span class="line">        blogService.saveBlog(blog);</span><br><span class="line">        <span class="comment">//返回id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="达人探店-查看探店笔记"><a href="#达人探店-查看探店笔记" class="headerlink" title="达人探店-查看探店笔记"></a>达人探店-查看探店笔记</h3><p>实现查看发布探店笔记的接口</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653579931626.png" alt="1653579931626"></p>
<p>实现代码：</p>
<p>BlogServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询blog</span></span><br><span class="line">    <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="keyword">if</span> (blog == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;笔记不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.查询blog有关的用户</span></span><br><span class="line">    queryBlogUser(blog);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="达人探店-点赞功能"><a href="#达人探店-点赞功能" class="headerlink" title="达人探店-点赞功能"></a>达人探店-点赞功能</h3><p>初始代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//修改点赞数量</span></span><br><span class="line">    blogService.update().setSql(<span class="string">&quot;liked = liked +1 &quot;</span>).eq(<span class="string">&quot;id&quot;</span>,id).update();</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题分析：这种方式会导致一个用户无限点赞，明显是不合理的</p>
<p>造成这个问题的原因是，我们现在的逻辑，发起请求只是给数据库+1，所以才会出现这个问题</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653581590453.png" alt="1653581590453"></p>
<p>完善点赞功能</p>
<p>需求：</p>
<ul>
<li>同一个用户只能点赞一次，再次点击则取消点赞</li>
<li>如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</li>
</ul>
<p>实现步骤：</p>
<ul>
<li>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</li>
<li>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1</li>
<li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</li>
<li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li>
</ul>
<p>为什么采用set集合：</p>
<p>因为我们的数据是不能重复的，当用户操作过之后，无论他怎么操作，都是</p>
<p>具体步骤：</p>
<p>1、在Blog 添加一个字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField(exist = false)</span></span><br><span class="line"><span class="keyword">private</span> Boolean isLike;</span><br></pre></td></tr></table></figure>

<p>2、修改代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">       <span class="comment">// 1.获取登录用户</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());</span><br><span class="line">       <span class="keyword">if</span>(BooleanUtil.isFalse(isMember))&#123;</span><br><span class="line">            <span class="comment">//3.如果未点赞，可以点赞</span></span><br><span class="line">           <span class="comment">//数据库点赞数+1</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">           <span class="comment">//保存用户到Redis的set集合</span></span><br><span class="line">           <span class="keyword">if</span>(isSuccess)&#123;</span><br><span class="line">               stringRedisTemplate.opsForSet().add(key,userId.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//4.如果已点赞，取消点赞</span></span><br><span class="line">           <span class="comment">//数据库点赞数-1</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">           <span class="comment">//把用户从Redis的set集合移除</span></span><br><span class="line">           <span class="keyword">if</span>(isSuccess)&#123;</span><br><span class="line">               stringRedisTemplate.opsForSet().remove(key,userId.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="达人探店-点赞排行榜"><a href="#达人探店-点赞排行榜" class="headerlink" title="达人探店-点赞排行榜"></a>达人探店-点赞排行榜</h3><p>在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的TOP5，形成点赞排行榜：</p>
<p>之前的点赞是放到set集合，但是set集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的set集合，就是咱们的sortedSet</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653805077118.png" alt="1653805077118"></p>
<p>我们接下来来对比一下这些集合的区别是什么</p>
<p>所有点赞的人，需要是唯一的，所以我们应当使用set或者是sortedSet</p>
<p>其次我们需要排序，就可以直接锁定使用sortedSet啦</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653805203758.png" alt="1653805203758"></p>
<p>修改代码</p>
<p>BlogServiceImpl</p>
<p>点赞逻辑代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">     <span class="comment">// 1.获取登录用户</span></span><br><span class="line">     <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">     <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">     <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">     <span class="keyword">if</span> (score == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 3.如果未点赞，可以点赞</span></span><br><span class="line">         <span class="comment">// 3.1.数据库点赞数 + 1</span></span><br><span class="line">         <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">         <span class="comment">// 3.2.保存用户到Redis的set集合  zadd key value score</span></span><br><span class="line">         <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">             stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 4.如果已点赞，取消点赞</span></span><br><span class="line">         <span class="comment">// 4.1.数据库点赞数 -1</span></span><br><span class="line">         <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">         <span class="comment">// 4.2.把用户从Redis的set集合移除</span></span><br><span class="line">         <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">             stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> Result.ok();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">isBlogLiked</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">     <span class="comment">// 1.获取登录用户</span></span><br><span class="line">     <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">     <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 用户未登录，无需查询是否点赞</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> user.getId();</span><br><span class="line">     <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;blog:liked:&quot;</span> + blog.getId();</span><br><span class="line">     <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">     blog.setIsLike(score != <span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>点赞列表查询列表</p>
<p>BlogController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogLikes(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MySQL自定义排序-ORDER-BY-FIELD"><a href="#MySQL自定义排序-ORDER-BY-FIELD" class="headerlink" title="MySQL自定义排序 ORDER BY FIELD"></a>MySQL自定义排序 ORDER BY FIELD</h4><p>MySQL查询结果如果不指定排序顺序，返回结果通常是不确定的，而点赞排行榜是按照用户的点赞时间先后顺序排序的，所以要显式指定特定的排序规则，</p>
<p>根据用户ids查询用户 WHERE id IN ( 5 , 1 )  结果默认是按照ids中元素的id大小升序排序的，我们要让ids的顺序保留到最后，使用ORDER BY FIELD </p>
<p>BlogService</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">    <span class="comment">// 1.查询top5的点赞用户 zrange key 0 4</span></span><br><span class="line">    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (top5 == <span class="literal">null</span> || top5.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.解析出其中的用户id</span></span><br><span class="line">    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    <span class="comment">// 3.根据用户id查询用户 WHERE id IN ( 5 , 1 ) ORDER BY FIELD(id, 5, 1)</span></span><br><span class="line">    List&lt;UserDTO&gt; userDTOS = userService.query()</span><br><span class="line">            .in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list()</span><br><span class="line">            .stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 4.返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h2><h3 id="好友关注-关注和取消关注"><a href="#好友关注-关注和取消关注" class="headerlink" title="好友关注-关注和取消关注"></a>好友关注-关注和取消关注</h3><p>针对用户的操作：可以对用户进行关注和取消关注功能。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653806140822.png" alt="1653806140822"></p>
<p>实现思路：</p>
<p>需求：基于该表数据结构，实现两个接口：</p>
<ul>
<li>关注和取关接口</li>
<li>判断是否关注的接口</li>
</ul>
<p>关注是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来标示：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653806253817.png" alt="1653806253817"></p>
<p>注意: 这里需要把主键修改为自增长，简化开发。</p>
<p>FollowController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关注</span></span><br><span class="line"><span class="meta">@PutMapping(&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long followUserId, <span class="meta">@PathVariable(&quot;isFollow&quot;)</span> Boolean isFollow)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> followService.follow(followUserId, isFollow);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取消关注</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long followUserId)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> followService.isFollow(followUserId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FollowService</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">取消关注service</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(Long followUserId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">// 2.查询是否关注 select count(*) from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId).count();</span><br><span class="line">        <span class="comment">// 3.判断</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(count &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> 关注service</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFollow)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">        <span class="comment">// 1.判断到底是关注还是取关</span></span><br><span class="line">        <span class="keyword">if</span> (isFollow) &#123;</span><br><span class="line">            <span class="comment">// 2.关注，新增数据</span></span><br><span class="line">            <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">            follow.setUserId(userId);</span><br><span class="line">            follow.setFollowUserId(followUserId);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(follow);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">            remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;()</span><br><span class="line">                    .eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="好友关注-共同关注"><a href="#好友关注-共同关注" class="headerlink" title="好友关注-共同关注"></a>好友关注-共同关注</h3><p>想要去看共同关注的好友，需要首先进入到这个页面，这个页面会发起两个请求</p>
<p>1、去查询用户的详情</p>
<p>2、去查询用户的笔记</p>
<p>以上两个功能和共同关注没有什么关系，大家可以自行将笔记中的代码拷贝到idea中就可以实现这两个功能了，我们的重点在于共同关注功能。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653806706296.png" alt="1653806706296"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserController 根据id查询用户</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span>&#123;</span><br><span class="line">	<span class="comment">// 查询详情</span></span><br><span class="line">	<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line">	<span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> Result.ok();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">	<span class="comment">// 返回</span></span><br><span class="line">	<span class="keyword">return</span> Result.ok(userDTO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BlogController  根据id查询博主的探店笔记</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/of/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogByUserId</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params">		<span class="meta">@RequestParam(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">	<span class="comment">// 根据用户查询</span></span><br><span class="line">	Page&lt;Blog&gt; page = blogService.query()</span><br><span class="line">			.eq(<span class="string">&quot;user_id&quot;</span>, id).page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));</span><br><span class="line">	<span class="comment">// 获取当前页数据</span></span><br><span class="line">	List&lt;Blog&gt; records = page.getRecords();</span><br><span class="line">	<span class="keyword">return</span> Result.ok(records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们来看看共同关注如何实现：</p>
<p>需求：利用Redis中恰当的数据结构，实现共同关注功能。在博主个人页面展示出当前用户与博主的共同关注呢。</p>
<p>当然是使用我们之前学习过的set集合咯，在set集合中，有交集并集补集的api，我们可以把两人的关注的人分别放入到一个set集合中，然后再通过api去查看这两个set集合中的交集数据。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653806973212.png" alt="1653806973212"></p>
<p>我们先来改造当前的关注列表</p>
<p>改造原因是因为我们需要在用户关注了某位用户后，需要将数据放入到set集合中，方便后续进行共同关注，同时当取消关注时，也需要从set集合中进行删除</p>
<p>FollowServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFollow)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">// 1.判断到底是关注还是取关</span></span><br><span class="line">    <span class="keyword">if</span> (isFollow) &#123;</span><br><span class="line">        <span class="comment">// 2.关注，新增数据</span></span><br><span class="line">        <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">        follow.setUserId(userId);</span><br><span class="line">        follow.setFollowUserId(followUserId);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(follow);</span><br><span class="line">        <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">            <span class="comment">// 把关注用户的id，放入redis的set集合 sadd userId followerUserId</span></span><br><span class="line">            stringRedisTemplate.opsForSet().add(key, followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;()</span><br><span class="line">                .eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId));</span><br><span class="line">        <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">            <span class="comment">// 把关注用户的id从Redis集合中移除</span></span><br><span class="line">            stringRedisTemplate.opsForSet().remove(key, followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体的关注代码：</strong></p>
<p>FollowServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">// 2.求交集</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + id;</span><br><span class="line">    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, key2);</span><br><span class="line">    <span class="keyword">if</span> (intersect == <span class="literal">null</span> || intersect.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 无交集</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.解析id集合</span></span><br><span class="line">    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 4.查询用户</span></span><br><span class="line">    List&lt;UserDTO&gt; users = userService.listByIds(ids)</span><br><span class="line">            .stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> Result.ok(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="好友关注-Feed流-实现"><a href="#好友关注-Feed流-实现" class="headerlink" title="好友关注-Feed流 实现"></a>好友关注-Feed流 实现</h3><p>当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p>
<p>对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653808641260.png" alt="1653808641260"></p>
<p>对于新型的Feed流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653808993693.png" alt="1653808993693"></p>
<p>Feed流的实现有两种模式：</p>
<p>Feed流产品有两种常见模式：<br>Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈</p>
<ul>
<li>优点：信息全面，不会有缺失。并且实现也相对简单</li>
<li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li>
</ul>
<p>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</p>
<ul>
<li>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</li>
<li>缺点：如果算法不精准，可能起到反作用<br>本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种：</li>
</ul>
<p>我们本次针对好友的操作，采用的就是Timeline的方式，只需要拿到我们关注用户的信息，然后按照时间排序即可</p>
<p>，因此采用Timeline的模式。该模式的实现方案有三种：</p>
<ul>
<li>拉模式</li>
<li>推模式</li>
<li>推拉结合</li>
</ul>
<p><strong>拉模式</strong>：也叫做读扩散</p>
<p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序</p>
<p>优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p>
<p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653809450816.png" alt="1653809450816"></p>
<p><strong>推模式</strong>：也叫做写扩散。</p>
<p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p>
<p>优点：时效快，不用临时拉取</p>
<p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653809875208.png" alt="1653809875208"></p>
<p><strong>推拉结合模式</strong>：也叫做读写混合，兼具推和拉两种模式的优点。</p>
<p>推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653812346852.png" alt="1653812346852"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241112191818612.png" alt="image-20241112191818612"></p>
<h3 id="好友关注-推送到粉丝收件箱"><a href="#好友关注-推送到粉丝收件箱" class="headerlink" title="好友关注-推送到粉丝收件箱"></a>好友关注-推送到粉丝收件箱</h3><p>需求：</p>
<ul>
<li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li>
<li>收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现</li>
<li>查询收件箱数据时，可以实现分页查询</li>
</ul>
<p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p>
<p>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</p>
<p>假设在t1 时刻，我们去读取第一页，此时page = 1 ，size = 5 ，那么我们拿到的就是10<del>6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page=2 ，size=5 ，那么此时读取到的第二页实际上是从6 开始，然后是6</del>2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653813047671.png" alt="1653813047671"></p>
<p>Feed流的滚动分页</p>
<p>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</p>
<p>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653813462834.png" alt="1653813462834"></p>
<p>核心的意思：就是我们在保存完探店笔记后，获得到当前笔记的粉丝，然后把数据推送到粉丝的redis中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取登录用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    blog.setUserId(user.getId());</span><br><span class="line">    <span class="comment">// 2.保存探店笔记</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(blog);</span><br><span class="line">    <span class="keyword">if</span>(!isSuccess)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;新增笔记失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.查询笔记作者的所有粉丝 select * from tb_follow where follow_user_id = ?</span></span><br><span class="line">    List&lt;Follow&gt; follows = followService.query().eq(<span class="string">&quot;follow_user_id&quot;</span>, user.getId()).list();</span><br><span class="line">    <span class="comment">// 4.推送笔记id给所有粉丝</span></span><br><span class="line">    <span class="keyword">for</span> (Follow follow : follows) &#123;</span><br><span class="line">        <span class="comment">// 4.1.获取粉丝id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> follow.getUserId();</span><br><span class="line">        <span class="comment">// 4.2.推送</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.返回id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="好友关注-实现分页查询收邮箱"><a href="#好友关注-实现分页查询收邮箱" class="headerlink" title="好友关注-实现分页查询收邮箱"></a>好友关注-实现分页查询收邮箱</h3><p>需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息：</p>
<p>具体操作如下：</p>
<p>1、每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件</p>
<p>2、我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据</p>
<p>综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。</p>
<p>这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653819821591.png" alt="1653819821591"></p>
<p>一、定义出来具体的返回值实体类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScrollResult</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;?&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Long minTime;</span><br><span class="line">    <span class="keyword">private</span> Integer offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlogController</p>
<p>注意：RequestParam 表示接受url地址栏传参的注解，当方法上参数的名称和url地址栏不相同时，可以通过RequestParam 来进行指定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/follow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(&quot;lastId&quot;)</span> Long max, <span class="meta">@RequestParam(value = &quot;offset&quot;, defaultValue = &quot;0&quot;)</span> Integer offset)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogOfFollow(max, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlogServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()</span><br><span class="line">        .reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 3.非空判断</span></span><br><span class="line">    <span class="keyword">if</span> (typedTuples == <span class="literal">null</span> || typedTuples.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.解析数据：blogId、minTime（时间戳）、offset</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">    <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">os</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; <span class="comment">// 5 4 4 2 2</span></span><br><span class="line">        <span class="comment">// 4.1.获取id</span></span><br><span class="line">        ids.add(Long.valueOf(tuple.getValue()));</span><br><span class="line">        <span class="comment">// 4.2.获取分数(时间戳）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> tuple.getScore().longValue();</span><br><span class="line">        <span class="keyword">if</span>(time == minTime)&#123;</span><br><span class="line">            os++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            os = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	os = minTime == max ? os : os + offset;</span><br><span class="line">    <span class="comment">// 5.根据id查询blog</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    List&lt;Blog&gt; blogs = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">        <span class="comment">// 5.1.查询blog有关的用户</span></span><br><span class="line">        queryBlogUser(blog);</span><br><span class="line">        <span class="comment">// 5.2.查询blog是否被点赞</span></span><br><span class="line">        isBlogLiked(blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.封装并返回</span></span><br><span class="line">    <span class="type">ScrollResult</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">    r.setList(blogs);</span><br><span class="line">    r.setOffset(os);</span><br><span class="line">    r.setMinTime(minTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="附近商户—GEO"><a href="#附近商户—GEO" class="headerlink" title="附近商户—GEO"></a>附近商户—GEO</h2><h3 id="附近商户-GEO数据结构的基本用法"><a href="#附近商户-GEO数据结构的基本用法" class="headerlink" title="附近商户-GEO数据结构的基本用法"></a>附近商户-GEO数据结构的基本用法</h3><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p>
<ul>
<li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li>
<li>GEODIST：计算指定的两个点之间的距离并返回</li>
<li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li>
<li>GEOPOS：返回指定member的坐标</li>
<li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li>
<li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li>
<li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</li>
</ul>
<h3 id="附近商户-导入店铺数据到GEO"><a href="#附近商户-导入店铺数据到GEO" class="headerlink" title="附近商户-导入店铺数据到GEO"></a>附近商户-导入店铺数据到GEO</h3><p>具体场景说明：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653822036941.png" alt="1653822036941"></p>
<p>当我们点击美食之后，会出现一系列的商家，商家中可以按照多种排序方式，我们此时关注的是距离，这个地方就需要使用到我们的GEO，向后台传入当前app收集的地址(我们此处是写死的) ，以当前坐标作为圆心，同时绑定相同的店家类型type，以及分页信息，把这几个条件传入后台，后台查询出对应的数据再返回。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653822021827.png" alt="1653822021827"></p>
<p>我们要做的事情是：将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。</p>
<p>但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可</p>
<p>代码</p>
<p>HmDianPingApplicationTests</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">loadShopData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询店铺信息</span></span><br><span class="line">    List&lt;Shop&gt; list = shopService.list();</span><br><span class="line">    <span class="comment">// 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合</span></span><br><span class="line">    Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">    <span class="comment">// 3.分批完成写入Redis</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 3.1.获取类型id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        <span class="comment">// 3.2.获取同类型的店铺的集合</span></span><br><span class="line">        List&lt;Shop&gt; value = entry.getValue();</span><br><span class="line">        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(value.size());</span><br><span class="line">        <span class="comment">// 3.3.写入redis GEOADD key 经度 纬度 member</span></span><br><span class="line">        <span class="keyword">for</span> (Shop shop : value) &#123;</span><br><span class="line">            <span class="comment">// stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());</span></span><br><span class="line">            locations.add(<span class="keyword">new</span> <span class="title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(</span><br><span class="line">                    shop.getId().toString(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(), shop.getY())</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.opsForGeo().add(key, locations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="附近商户-实现附近商户—redis逻辑分页查询"><a href="#附近商户-实现附近商户—redis逻辑分页查询" class="headerlink" title="附近商户-实现附近商户—redis逻辑分页查询"></a>附近商户-实现附近商户—redis逻辑分页查询</h3><p>SpringDataRedis的版本并不支持Redis 6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的POM</p>
<p>第一步：导入pom</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>第二步：</p>
<p>ShopController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/type&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;typeId&quot;)</span> Integer typeId,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;x&quot;, required = false)</span> Double x,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;y&quot;, required = false)</span> Double y</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> shopService.queryShopByType(typeId, current, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ShopServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要根据坐标查询</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 不需要坐标查询，按数据库查询</span></span><br><span class="line">            Page&lt;Shop&gt; page = query()</span><br><span class="line">                    .eq(<span class="string">&quot;type_id&quot;</span>, typeId)</span><br><span class="line">                    .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));</span><br><span class="line">            <span class="comment">// 返回数据</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(page.getRecords());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.计算分页参数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> (current - <span class="number">1</span>) * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> current * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询redis、按照距离排序、分页。结果：shopId、distance</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo() <span class="comment">// GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE</span></span><br><span class="line">                .search(</span><br><span class="line">                        key,</span><br><span class="line">                        GeoReference.fromCoordinate(x, y),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Distance</span>(<span class="number">5000</span>),</span><br><span class="line">                        RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">// 4.解析出id</span></span><br><span class="line">        <span class="keyword">if</span> (results == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();</span><br><span class="line">        <span class="keyword">if</span> (list.size() &lt;= from) &#123;</span><br><span class="line">            <span class="comment">// 没有下一页了，结束</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.1.截取 from ~ end的部分</span></span><br><span class="line">        List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());</span><br><span class="line">        Map&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(list.size());</span><br><span class="line">        list.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// 4.2.获取店铺id</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">shopIdStr</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">            ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">            <span class="comment">// 4.3.获取距离</span></span><br><span class="line">            <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> result.getDistance();</span><br><span class="line">            distanceMap.put(shopIdStr, distance);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 5.根据id查询Shop</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">        List&lt;Shop&gt; shops = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">        <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">            shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shops);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="用户签到—BitMap"><a href="#用户签到—BitMap" class="headerlink" title="用户签到—BitMap"></a>用户签到—BitMap</h2><h3 id="用户签到-BitMap功能演示"><a href="#用户签到-BitMap功能演示" class="headerlink" title="用户签到-BitMap功能演示"></a>用户签到-BitMap功能演示</h3><p>我们针对签到功能完全可以通过mysql来完成，比如说以下这张表</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653823145495.png" alt="1653823145495"></p>
<p>用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条</p>
<p>每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共22 字节的内存，一个月则最多需要600多字节</p>
<p>我们如何能够简化一点呢？其实可以考虑小时候一个挺常见的方案，就是小时候，咱们准备一张小小的卡片，你只要签到就打上一个勾，我最后判断你是否签到，其实只需要到小卡片上看一看就知道了</p>
<p>我们可以采用类似这样的方案来实现我们的签到需求。</p>
<p>我们按月来统计用户签到信息，签到记录为1，未签到则记录为0.</p>
<p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示</p>
<p>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653824498278.png" alt="1653824498278"></p>
<p>BitMap的操作命令有：</p>
<ul>
<li>SETBIT：向指定位置（offset）存入一个0或1</li>
<li>GETBIT ：获取指定位置（offset）的bit值</li>
<li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li>
<li>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li>
<li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li>
<li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li>
<li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li>
</ul>
<h4 id="1用户签到-实现签到功能"><a href="#1用户签到-实现签到功能" class="headerlink" title="1用户签到-实现签到功能"></a>1用户签到-实现签到功能</h4><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p>
<p>思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p>
<p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改bitMap。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653833970361.png" alt="1653833970361"></p>
<p><strong>代码</strong></p>
<p>UserController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> userService.sign();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.写入Redis SETBIT key offset 1</span></span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存储肯定是以字节为单位，因此后面会补0</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111230319873.png" alt="image-20241111230319873"></p>
<h4 id="用户签到-签到统计"><a href="#用户签到-签到统计" class="headerlink" title="用户签到-签到统计"></a>用户签到-签到统计</h4><p><strong>问题1：</strong>什么叫做连续签到天数？<br>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653834455899.png" alt="1653834455899"></p>
<p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p>
<p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p>
<p>  BITFIELD key GET u[dayOfMonth] 0</p>
<p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p>
<p><strong>问题3：如何从后向前遍历每个bit位？</strong></p>
<p>注意：bit<mark>Map返回的数据是10进制<mark>，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</p>
<p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p>
<p>有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653835784444.png" alt="1653835784444"></p>
<p>代码</p>
<p><strong>UserController</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sign/count&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.signCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span></span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">            key,</span><br><span class="line">            BitFieldSubCommands.create()</span><br><span class="line">                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 没有任何签到结果</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="literal">null</span> || num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.循环遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为0，说明未签到，结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不为0，说明已签到，计数器+1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="额外加餐-关于使用bitmap来解决缓存穿透的方案"><a href="#额外加餐-关于使用bitmap来解决缓存穿透的方案" class="headerlink" title="额外加餐-关于使用bitmap来解决缓存穿透的方案"></a>额外加餐-关于使用bitmap来解决缓存穿透的方案</h4><p>回顾<strong>缓存穿透</strong>：</p>
<p>发起了一个数据库不存在的，redis里边也不存在的数据，通常你可以把他看成一个攻击</p>
<p>解决方案：</p>
<ul>
<li><p>判断id&lt;0</p>
</li>
<li><p>如果数据库是空，那么就可以直接往redis里边把这个空数据缓存起来</p>
</li>
</ul>
<p>第一种解决方案：遇到的问题是如果用户访问的是id不存在的数据，则此时就无法生效</p>
<p>第二种解决方案：遇到的问题是：如果是不同的id那就可以防止下次过来直击数据</p>
<p>所以我们如何解决呢？</p>
<p>我们可以将数据库的数据，所对应的id写入到一个list集合中，当用户过来访问的时候，我们直接去判断list中是否包含当前的要查询的数据，如果说用户要查询的id数据并不在list集合中，则直接返回，如果list中包含对应查询的id数据，则说明不是一次缓存穿透数据，则直接放行。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653836416586.png" alt="1653836416586"></p>
<p>现在的问题是这个主键其实并没有那么短，而是很长的一个 主键</p>
<p>哪怕你单独去提取这个主键，但是在11年左右，淘宝的商品总量就已经超过10亿个</p>
<p>所以如果采用以上方案，这个list也会很大，所以我们可以使用bitmap来减少list的存储空间</p>
<p>我们可以把list数据抽象成一个非常大的bitmap，我们不再使用list，而是将db中的id数据利用哈希思想，比如：</p>
<p>id % bitmap.size  = 算出当前这个id对应应该落在bitmap的哪个索引上，然后将这个值从0变成1，然后当用户来查询数据时，此时已经没有了list，让用户用他查询的id去用相同的哈希算法， 算出来当前这个id应当落在bitmap的哪一位，然后判断这一位是0，还是1，如果是0则表明这一位上的数据一定不存在，  采用这种方式来处理，需要重点考虑一个事情，就是误差率，所谓的误差率就是指当发生哈希冲突的时候，产生的误差。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653836578970.png" alt="1653836578970"></p>
<h2 id="UV统计—HyperLogLog"><a href="#UV统计—HyperLogLog" class="headerlink" title="UV统计—HyperLogLog"></a>UV统计—HyperLogLog</h2><p>Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903785744056333#heading-0">HyperLogLog 算法的原理讲解以及 Redis 是如何应用它的聪明的你可能会马上想到，用 HashMap 这种数 - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/53416615">Redis源码中hyperloglog结构的实现原理是什么？ - 知乎 (zhihu.com)</a></p>
<p>首先我们搞懂两个概念：</p>
<ul>
<li>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li>
<li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li>
</ul>
<p>通常来说UV会比PV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值</p>
<p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</p>
<p>Redis中的HLL是基于string结构实现的，单个HLL的内存<strong>永远小于16kb</strong>，<strong>内存占用低</strong>的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653837988985.png" alt="1653837988985"></p>
<h3 id="UV统计-测试百万数据的统计"><a href="#UV统计-测试百万数据的统计" class="headerlink" title="UV统计-测试百万数据的统计"></a>UV统计-测试百万数据的统计</h3><p>测试思路：我们直接利用单元测试，向HyperLogLog中添加100万条数据，看看内存占用和统计效果如何</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653838053608.png" alt="1653838053608"></p>
<p>经过测试：我们会发生他的误差是在允许范围内，并且内存占用极小</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default/">1</a><a class="page-number" href="/default/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/default/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/default/page/8/">8</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">碎梦</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/scatteredream" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
