<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Arvo:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scatteredream.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="scatteredream&#39;s blog">
<meta property="og:url" content="http://scatteredream.github.io/default/page/2/index.html">
<meta property="og:site_name" content="scatteredream&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="碎梦">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://scatteredream.github.io/default/page/2/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default/page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>scatteredream's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">scatteredream's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">碎梦</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">168</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/01/14/L4%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/14/L4%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/" class="post-title-link" itemprop="url">应用层</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-14 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-14T00:00:00+08:00">2025-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-03 21:01:06" itemprop="dateModified" datetime="2025-05-03T21:01:06+08:00">2025-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="域名系统（DNS）"><a href="#域名系统（DNS）" class="headerlink" title="域名系统（DNS）"></a>域名系统（DNS）</h1><p>Domain Name System based on UDP port 53 </p>
<h2 id="域名-名字空间"><a href="#域名-名字空间" class="headerlink" title="域名 名字空间"></a>域名 名字空间</h2><p><strong>层次结构</strong>：………三级域名.二级域名.顶级域名</p>
<p><strong>根</strong>：无名字</p>
<p><strong>顶级域名</strong>：国家、组织</p>
<p><strong>二级域名</strong>（我国）：类别域名、行政区域名</p>
<p>属于不同父亲的孩子节点可以有相同的名称: <a target="_blank" rel="noopener" href="http://www.example.cn/">www.example.cn</a>  <a target="_blank" rel="noopener" href="http://www.example.com/">www.example.com</a> </p>
<h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><p>DNS服务器实际是一个分布式的数据库。主从复制，读写分离，增强可用性。服务器可以采用anycast任播技术，多台服务器使用同一IP地址，路由自动选择最近的服务器。</p>
<p>分类：</p>
<ul>
<li><strong>根域名服务器</strong>（Root）：所有的根域名服务器都知道所有顶级域名服务器的IP地址和域名<ul>
<li>根域名有13个，分布于全球的若干根域名服务器，使用IP anycast技术，每个域名有多个物理实例，但对外展示同一个 IP。</li>
</ul>
</li>
<li><strong>顶级域名服务器</strong>（Top Level Domain）：管辖属于自己的二级域名</li>
<li><strong>权限域名服务器</strong>（Authoriative Name Server）：管辖区内的域名，一个服务器管一个域名，效率比较低，所以采用 <strong>区</strong> 的概念，区是域的子集。</li>
<li><strong>本地域名服务器</strong>：不在上述层次中，但是离客户最近的DNS服务器。</li>
</ul>
<h2 id="DNS-查询顺序"><a href="#DNS-查询顺序" class="headerlink" title="DNS 查询顺序"></a>DNS 查询顺序</h2><h3 id="先查缓存的查询流程"><a href="#先查缓存的查询流程" class="headerlink" title="先查缓存的查询流程"></a>先查缓存的查询流程</h3><p><img src="C:/Users/Lenovo/Pictures/markdownfile/L4%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82.assets/image-20241129143353140.png" alt="image-20241129143353140"></p>
<ol>
<li>浏览器 DNS 缓存：首先，浏览器会检查自己的缓存中是否已经有该域名的IP地址记录。如果有，则直接使用这个IP地址，而不会发起DNS查询</li>
<li>操作系统 DNS 缓存：如果浏览器缓存中没有找到，浏览器会请求操作系统进行DNS解析。操作系统会先检查自己的DNS缓存。大多数现代操作系统都会维护一个 DNS 缓存来存储最近解析过的域名和对应的IP地址</li>
<li>本地 hosts 文件：如果操作系统缓存中也没有找到对应的记录，并且您使用的是Unix-like系统（如Linux或macOS），操作系统会查询本地的/etc/hosts文件。这个文件通常包含静态的IP地址到域名的映射</li>
<li>路由器DNS缓存：我们常用的路由器也带有自动缓存功能，路由器DNS被篡改会造成<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=216036547&content_type=Article&match_order=1&q=%E5%9F%9F%E5%90%8D%E5%8A%AB%E6%8C%81&zhida_source=entity">域名劫持</a>，将访问网址定位到另外一个服务器；</li>
<li>本地DNS服务器（递归查询，本地DNS服务器替主机查询，主机作为DNS客户端向DNS服务器请求服务）：如果/etc/hosts文件中也没有找到，操作系统会向配置的本地DNS服务器发送查询请求。这个本地DNS服务器可能是您的网络服务提供商提供的，或者是您在公司或学校网络中配置的，也具有缓存功能。本地DNS将解析结果告知客户端的同时，将记录缓存下来，当下次请求同一个域名时，直接会将记录返回，而无需再进行全球查询。</li>
<li>根域名服务器（迭代查询，从此开始就是本地DNS服务器反复查询）：如果本地DNS服务器无法解析该域名，它会向根域名服务器发送查询请求。根域名服务器会返回负责顶级域名（如.com）的权威DNS服务器的地址</li>
<li>顶级域名服务器：本地DNS服务器然后会向顶级域名服务器发送查询请求，获取该域名的权威DNS服务器的地址</li>
<li>权威DNS服务器：最后，本地DNS服务器会向权威DNS服务器发送查询请求，获取该域名的IP地址</li>
<li>返回IP地址：一旦本地DNS服务器从权威DNS服务器那里获得了IP地址，它就会将这个IP地址返回给操作系统，操作系统再返回给浏览器。浏览器最后使用这个IP地址来建立与服务器的连接</li>
</ol>
<p>在查询的过程中，一旦在某一环节找到有效的IP地址记录，就会停止后续的查询。而且，为了提高效率，本地DNS服务器和操作系统通常会对查询结果进行缓存，以便在后续请求中直接使用，减少网络延迟</p>
<h3 id="DNS-缓存"><a href="#DNS-缓存" class="headerlink" title="DNS 缓存"></a>DNS 缓存</h3><p>所谓DNS缓存是指DNS返回正确的IP地址之后，系统会将这个结果临时储存起来，并为缓存设定一个失效时间（<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=216036547&content_type=Article&match_order=1&q=TTL%E5%80%BC&zhida_source=entity">TTL值</a>），在TTL失效前，当再次访问这个网站，系统就会直接从<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=216036547&content_type=Article&match_order=1&q=DNS+%E7%BC%93%E5%AD%98&zhida_source=entity">DNS 缓存</a>中将结果返回，而不必再次委托递归服务器进行全球解析查询，加快了<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=216036547&content_type=Article&match_order=4&q=DNS%E8%A7%A3%E6%9E%90&zhida_source=entity">DNS解析</a>的流程。</p>
<p>当然TTL值失效后，系统还会自动再次询问DNS服务器以获取最新的解析结果。</p>
<h4 id="DNS-污染"><a href="#DNS-污染" class="headerlink" title="DNS 污染"></a>DNS 污染</h4><p>在中国大陆，对所有经过<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E9%95%B7%E5%9F%8E">防火长城</a>（英语：Great Firewall，常用简称：GFW）的在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE">UDP</a>的53<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E4%BF%A1%E7%AB%AF%E5%8F%A3">端口</a>上的域名查询进行IDS<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B">入侵检测</a>，一经发现与黑名单关键词相匹配的域名查询请求，会马上伪装成目标解析服务器注入伪造的查询结果。攻击仅出现在DNS查询之路由经过防火长城时。伪造的查询结果中的IP地址不是一成不变的，在一段时间后会更新。</p>
<p>对于TCP协议下的域名查询，防火长城可使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TCP%E9%87%8D%E7%BD%AE%E6%94%BB%E5%87%BB">TCP重置攻击</a>的方法进行干扰。</p>
<blockquote>
<p>重置（reset）是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">传输控制协议</a>（TCP）的一种消息，例如服务器端在没有客户端请求的端口或者其它连接信息不符时，系统的TCP协议栈就会给客户端回复一个重置通知消息，该功能本来用于应对例如服务器意外重启等情况，而防火长城阻止TCP连接的技术实际上就是比连接双方更快地发送连接重置消息，使连接双方以为对方终止了连接[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E9%95%BF%E5%9F%8E#cite_note-clayton2006-66">65]</a>。</p>
</blockquote>
<h1 id="动态主机配置协议（DHCP）"><a href="#动态主机配置协议（DHCP）" class="headerlink" title="动态主机配置协议（DHCP）"></a>动态主机配置协议（DHCP）</h1><p>Dynamic Host Configuration Protocol based on <code>UDP</code> port <code>68</code> for <code>client</code>, <code>67</code> for <code>server</code></p>
<p>采用C/S通信模式，由客户端（DHCP Client）向服务器（DHCP Server）提出配置申请</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L4%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82.assets/image-20241129172615802.png" alt="image-20241129172615802"></p>
<h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/scanf_linux/article/details/89415965#t2">报文格式</a></h2><p><strong>dhcp offer</strong>:</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L4%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82.assets/image-20241129175130504.png" alt="image-20241129175130504"></p>
<ul>
<li>Relay Agent 中继</li>
<li>Next Server 其他DHCP服务器</li>
<li>Client MAC Address 之前 Discover含有 客户端的MAC地址</li>
<li>bootp flags unicast 单播</li>
</ul>
<p><strong>dhcp offer:</strong></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L4%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82.assets/image-20241129175445723.png" alt="image-20241129175445723"></p>
<h2 id="分配IP"><a href="#分配IP" class="headerlink" title="分配IP"></a>分配IP</h2><p>  <strong>内网 使用DHCP协议</strong></p>
<ul>
<li><p>首次接入网络的DHCP客户端不知道DHCP服务器的<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/IPv4.html">IP地址</a>，为了学习到DHCP服务器的IP地址，DHCP客户端以广播方式发送<code>DHCP DISCOVER</code>报文（目的IP地址为255.255.255.255）给同一网段内的所有设备（包括DHCP服务器或中继）。<code>DHCP DISCOVER</code>报文中携带了客户端的MAC地址（<a target="_blank" rel="noopener" href="https://support.huawei.com/hedex/pages/EDOC1100087046AZJ0324D/10/EDOC1100087046AZJ0324D/10/resources/dc/dc_cfg_dhcp_6005.html#ZH-CN_CONCEPT_0176371535__c1">chaddr字段</a>）、需要请求的参数列表选项（<a target="_blank" rel="noopener" href="https://support.huawei.com/hedex/pages/EDOC1100087046AZJ0324D/10/EDOC1100087046AZJ0324D/10/resources/dc/dc_cfg_dhcp_6005.html#ZH-CN_CONCEPT_0176371535__op55">Option55</a>）、广播标志位（<a target="_blank" rel="noopener" href="https://support.huawei.com/hedex/pages/EDOC1100087046AZJ0324D/10/EDOC1100087046AZJ0324D/10/resources/dc/dc_cfg_dhcp_6005.html#ZH-CN_CONCEPT_0176371535__f1">flags字段</a>）等信息。源IP 地址0.0.0.0   目的IP:255.255.255.255</p>
</li>
<li><p>某个（可能有多个服务器）DHCP服务器A监听到了DHCP请求，能够<strong>动态</strong>管理自己的IP池，通过<code>DHCP Offer</code>给计算机分配IP地址和默认网关（用于访问外部地址）以及子网掩码和<strong>DNS</strong>、租约信息，注意并不一定要全部提供。源IP为DHCP服务器的IP  目的IP:分配给客户端的IP，里面也有客户端的MAC地址。</p>
</li>
<li><p>设备收到以后会正式提出租用请求，<code>DHCP Request</code>，源IP为0.0.0.0  目的IP:255.255.255.255，==广播==形式可以告诉其他可能存在的DHCP服务器已经向DHCP服务器A提出租用请求，。</p>
</li>
<li><p>路由器收到以后发送<code>DHCP ACK</code>，确认分配并连接成功。源IP为DHCP服务器的IP  目的IP:分配给</p>
</li>
<li><p>客户端收到<code>DHCP ACK</code>报文，会广播发送<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/ARP.html">免费ARP</a>报文，探测本网段是否有其他终端使用服务器分配的IP地址，如果在指定时间内没有收到回应，表示客户端可以使用此地址。如果收到了回应，说明有其他终端使用了此地址，客户端会向服务器发送<code>DHCP DECLINE</code>报文，并重新向服务器请求IP地址，同时，服务器会将此地址列为冲突地址。当服务器没有空闲地址可分配时，再选择冲突地址进行分配，尽量减少分配出去的地址冲突。</p>
</li>
<li><p>设备使用某个IP地址的时间有限，==单播==发送<code>DHCP Request</code>报文进行续约，如果收到<code>DHCP NAK</code>报文说明续租失败；如果到时间如果设备不再续用发送<code>DHCP Release</code>报文进行释放，DHCP服务器会回收，设备收到<code>DHCP</code>。某些设备可能需要为静态的IP，这个可以通过MAC绑定也可以手动配置。</p>
</li>
</ul>
<p><strong>宽带</strong>：</p>
<ul>
<li><p><strong>静态IP</strong>：根据运营商提供的静态IP，子网掩码，网关，DNS手动配置，是固定的IP。</p>
</li>
<li><p><strong>动态DHCP</strong> ：自动从ISP获取IP地址等网络配置信息。</p>
</li>
<li><p><strong>ADSL虚拟拨号</strong> ：使用PPPoE协议向运营商动态租用（PPPoE提供了身份验证功能，也就是宽带账号)。</p>
</li>
</ul>
<h2 id="典型场景"><a href="#典型场景" class="headerlink" title="典型场景"></a>典型场景</h2><ol>
<li><p>路由器从运营商的网络获取一个公网IP地址（通过运营商的DHCP服务器分配）。</p>
</li>
<li><p>路由器在局域网内充当DHCP服务器，为局域网设备分配私有IP地址（如192.168.0.x）。</p>
</li>
</ol>
<h2 id="RARP-协议"><a href="#RARP-协议" class="headerlink" title="RARP 协议"></a>RARP 协议</h2><p>RARP（反向地址转换协议，Reverse Address Resolution Protocol）是局域网的物理机器从网关服务器的ARP表或者缓存上根据MAC地址请求IP地址的协议。它的功能与ARP协议相反。</p>
<ol>
<li><strong>请求IP地址</strong>：当局域网中的某个物理机器只知道自己的MAC地址而不知道IP地址时，它可以通过RARP协议向RARP服务器发送一个请求，请求分配一个IP地址。</li>
<li><strong>服务器响应</strong>：RARP服务器在收到请求后，会查找其RARP列表或ARP表，查找该MAC地址对应的IP地址。如果找到匹配的MAC地址，RARP服务器就会将对应的IP地址发送给请求者。</li>
<li><strong>获取IP地址并通信</strong>：请求者在收到RARP服务器的响应后，就可以利用得到的IP地址进行网络通信。</li>
</ol>
<p><strong>RARP</strong>（Reverse Address Resolution Protocol）和<strong>DHCP</strong>（Dynamic Host Configuration Protocol）是两种网络协议，它们都可以为某个刚接入网络的设备提供IP地址以实现互联通信。区别主要有以下几点：</p>
<ol>
<li>RARP是数据链路层的协议，无法跨路由器和网段工作，每个本地网络都必须配置一台RARP服务器；而DHCP属于应用层协议，可以跨路由器和网段工作，因此多个网段可以共享同一个DHCP服务器。</li>
<li>RARP协议中，必须提前在RAPR服务器中手工配置好MAC地址和IP地址之间的映射；而DHCP允许动态的分配IP，更适应当前网络的需求。</li>
<li>RARP协议仅仅是分配IP地址，而DHCP协议不仅提供IP地址，还提供其他网络配置信息，如子网掩码、网关、DNS服务器</li>
</ol>
<h1 id="万维网（WWW）"><a href="#万维网（WWW）" class="headerlink" title="万维网（WWW）"></a>万维网（WWW）</h1><p>World Wide Web</p>
<h2 id="超文本传输协议（HTTP）"><a href="#超文本传输协议（HTTP）" class="headerlink" title="超文本传输协议（HTTP）"></a>超文本传输协议（HTTP）</h2><p><strong>HyperText Transfer Protocol</strong> based on TCP port 80</p>
<p>TCP/IP 协议四层架构的最上层 规定了服务器和浏览器之间传输数据的规则</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP">HTTP | MDN (mozilla.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">超文本传输协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<h3 id="超文本"><a href="#超文本" class="headerlink" title="超文本"></a>超文本</h3><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>基于TCP，面向连接，安全</li>
<li>基于请求-响应模型：1Request1Response</li>
<li>HTTP是无状态协议，对事务处理没有记忆能力，每次RR都是独立的<ul>
<li>多次请求之间不能共享数据，用会话技术（cookie session）解决这个问题</li>
<li>优点：速度快</li>
</ul>
</li>
</ul>
<p>HTTP 协议基于 TCP 协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。</p>
<h3 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h3><p><strong>请求行</strong>：第一行，<code>GET</code>(请求方式) 后面的<code>/</code>表示请求资源的路径，HTTP/1.1表示协议版本</p>
<p><strong>请求头</strong>：第二行开始 key: value形式</p>
<p><strong>请求体</strong>：POST请求的最后一部分，存放请求参数</p>
<p>GET请求参数在请求行中，没有请求体，参数大小有限制(URL长度限制) POST请求的参数在请求体中，参数大小无限制</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L4%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82.assets/image-20240926220614547.png" alt="image-20240926220614547"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L4%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82.assets/image-20240926221417729.png" alt="image-20240926221417729"></p>
<p><strong>Host</strong>: 请求的主机名</p>
<p><strong>User-Agent</strong>: 浏览器版本</p>
<p><strong>Accept</strong>: 浏览器能接受的资源类型，如text/* image/* */* </p>
<p><strong>Accept-Language</strong>: 浏览器的偏好语言</p>
<p><strong>Accept-Encoding</strong>: 浏览器支持的压缩类型</p>
<h3 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h3><p><strong>响应行</strong>：响应数据的第一行，HTTP/1.1表示协议版本，下一个是响应状态码，OK表示状态码描述</p>
<p><strong>响应头</strong>：key value</p>
<p><strong>响应体</strong>：最后一部分，存放响应数据</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L4%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82.assets/image-20240926221630980.png" alt="image-20240926221630980"></p>
<p><strong>Content-Type</strong>：响应内容类型，比如text/html image/jpeg</p>
<p><strong>Content-Length</strong>：响应内容长度（bytes）</p>
<p><strong>Content-Encoding</strong>：响应压缩算法 gzip等</p>
<p><strong>Cache-Control</strong>: 指示客户端如何缓存，例如max-age=300 表示最多缓存300s</p>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/http-status-codes.html">HTTP 常见状态码总结（应用层） | JavaGuide</a> </p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L4%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82.assets/image-20240926222005460.png" alt="image-20240926222005460"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L4%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82.assets/image-20240926222320894.png" alt="image-20240926222320894"></p>
<p>200 OK 404资源不存在 500 服务器异常</p>
<p>Java程序中，如果直接用自带的javawebsocketAPI 代码会变得异常繁琐，要注意请求和响应的格式要求，因此要用web服务器软件进行开发—-Tomcat</p>
<h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><h4 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h4><p>cache-control 强缓存</p>
<p>还有在协商缓存：条件get，Etag与modified同理，优先级高于modified</p>
<ul>
<li>服务器响应中带上Last-Modified:x </li>
<li>客户端下次请求就带上If-Modified-Since:x</li>
<li>如果服务器看没有过期，回复一个HTTP 304 允许使用缓存，过期了就回复HTTP 200把新的数据发过来。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/http_interview.html#http-%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF">HTTP 缓存 - 小林 coding</a>  </p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http%E7%BC%93%E5%AD%98.png" alt="img"></p>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/http-vs-https.html">HTTP vs HTTPS（应用层） | JavaGuide</a> </p>
<h4 id="HTTP-1-0-到-HTTP-3"><a href="#HTTP-1-0-到-HTTP-3" class="headerlink" title="HTTP/1.0 到 HTTP/3"></a>HTTP/1.0 到 HTTP/3</h4><p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/http1.0-vs-http1.1.html">HTTP 1.0 vs HTTP 1.1（应用层） | JavaGuide</a> </p>
<p><strong>HTTP/1.1 长连接/持续连接默认开启</strong> </p>
<ul>
<li><p>每个请求的时延都要算上额外的 TCP 握手所占用的 1 RTT</p>
</li>
<li><p>维护 TCP 连接的各种缓存和变量都需要占用资源</p>
</li>
<li><p>长连接，会复用一个 TCP 连接</p>
</li>
</ul>
<p><strong>HTTP</strong>/<strong>2</strong></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1573513">白话http2的多路复用-腾讯云开发者社区-腾讯云</a></p>
<ul>
<li><p>封装成帧，二进制编码</p>
<ul>
<li>将一个帧分为数据帧和头帧，将HttpHeader中的重复出现的部分进行编码，取代之前的ASCII文本编码，也就是压缩了头部称为头帧。</li>
<li>并且帧有编号，帧与帧之间可以乱序传输，减轻队头阻塞</li>
</ul>
</li>
<li><p><img src="https://ask.qcloudimg.com/http-save/yehe-5837318/qsm44wuriu.jpeg" alt="img"></p>
</li>
<li><p>全双工通信</p>
<ul>
<li>浏览器针对同一个域名的资源，只建立一个tcp连接通道，所有的针对这个域名的请求全部在这个通道中完成，并且引入了流的机制，这条通道可以同时处理多个request，这不同于http1.1的pepeline，http2的多路复用，对于request的响应并不会因为上一个request的响应未完成而阻塞</li>
<li>HTTP 1,1 Pipeline 虽然在一个tcp通道中实现了多个http并发，但是返回的时候是会阻塞的，谁先到达，谁先返回，顺序绝对不能乱，这就是http1.1pipeline的弊端。还有另一个pipeline的限制，只能是幂等请求（get、head等）才能应用pipeline，大部分浏览器默认是关闭pipeline的。</li>
</ul>
</li>
<li><p>服务器推和响应优先级</p>
<ul>
<li>HTTP1.1对于连续多个请求可能会开启并行的多个TCP连接，用来提高发送的效率</li>
<li>服务器根据HTML的内容解析需要发送哪些内容，在接收到HTTP请求</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/http_interview.html#http-1-1%E3%80%81http-2%E3%80%81http-3-%E6%BC%94%E5%8F%98">HTTP/1.1、HTTP/2、HTTP/3 演变 - 小林 coding</a> </p>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/http_websocket.html">WebSocket</a></h2><p>WebSocket 是一种基于 TCP 连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。</p>
<p>WebSocket 协议在 2008 年诞生，2011 年成为国际标准，几乎所有主流较新版本的浏览器都支持该协议。不过，WebSocket 不只能在基于浏览器的应用程序中使用，很多编程语言、框架和服务器都提供了 WebSocket 支持。</p>
<p>WebSocket 协议本质上是应用层的协议，用于弥补 HTTP 协议在持久通信能力上的不足。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192394.png" alt="Websocket 示意图"></p>
<p>下面是 WebSocket 的常见应用场景：</p>
<ul>
<li>视频弹幕</li>
<li>实时消息推送，详见<a target="_blank" rel="noopener" href="https://javaguide.cn/system-design/web-real-time-message-push.html">Web 实时消息推送详解</a>这篇文章</li>
<li>实时游戏对战</li>
<li>多用户协同编辑</li>
<li>社交聊天</li>
<li>……</li>
</ul>
<p>WebSocket 的工作过程可以分为以下几个步骤：</p>
<ol>
<li>客户端向服务器发送一个 HTTP 请求，请求头中包含 <code>Upgrade: websocket</code> 和 <code>Sec-WebSocket-Key</code> 等字段，表示要求升级协议为 WebSocket；</li>
<li>服务器收到这个请求后，会进行升级协议的操作，如果支持 WebSocket，它将回复一个 HTTP 101 状态码，响应头中包含 ，<code>Connection: Upgrade</code>和 <code>Sec-WebSocket-Accept: xxx</code> 等字段、表示成功升级到 WebSocket 协议。</li>
<li>客户端和服务器之间建立了一个 WebSocket 连接，可以进行双向的数据传输。数据以帧（frames）的形式进行传送，WebSocket 的每条消息可能会被切分成多个数据帧（最小单位）。发送端会将消息切割成多个帧发送给接收端，接收端接收消息帧，并将关联的帧重新组装成完整的消息。</li>
<li>客户端或服务器可以主动发送一个关闭帧，表示要断开连接。另一方收到后，也会回复一个关闭帧，然后双方关闭 TCP 连接。</li>
</ol>
<p>另外，建立 WebSocket 连接之后，通过心跳机制来保持 WebSocket 连接的稳定性和活跃性。</p>
<h2 id="内容分发网络（CDN）"><a href="#内容分发网络（CDN）" class="headerlink" title="内容分发网络（CDN）"></a>内容分发网络（CDN）</h2><p><strong>Content Distribution Network</strong></p>
<p><strong>push</strong>： 源服务器将内容推送给CDN</p>
<p><strong>pull</strong>：CDN遇到自己没有的资源就从源服务器pull过来</p>
<p><strong>anycast</strong>: 任播，与DNS服务器类似，很多CDN具有相同的IP地址，可以负载均衡。</p>
<p>CDN所需要的节点数量随着需求而不同，依照所需要服务的对象大小，有可能有数万台服务器。</p>
<p>服务器的运作方式一般是基于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Nginx">nginx</a>的模式，通过HTTP头的Host字段等方式区分服务域名来提供HTTP服务。不过，随着2017年世界各地CDN服务商纷纷推出<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTTPS">HTTPS</a>加速功能，运作方式也变得略有不同，变成了nginx+<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8D%E7%A7%B0%E6%8C%87%E7%A4%BA">SNI</a>模式，同一个CDN节点上可以借此机制绑定多个域名而为不同域名提供HTTPS服务。同时，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/BGP">BGP</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Anycast">anycast</a>技术也逐渐引入了CDN领域中。</p>
<p>P2P CDN(PCDN)：用户自愿以PC或专用设备利用闲置上行带宽充当CDN缓存节点</p>
<h1 id="进程间通信（IPC）"><a href="#进程间通信（IPC）" class="headerlink" title="进程间通信（IPC）"></a>进程间通信（IPC）</h1><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/http_rpc.html">既然有 HTTP 协议，为什么还要有 RPC？</a> </p>
<h1 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h1><h1 id="文件传送协议（FTP）"><a href="#文件传送协议（FTP）" class="headerlink" title="文件传送协议（FTP）"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">文件传送协议（FTP）</a></h1><p><strong>FTP 协议</strong> 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。</p>
<p>FTP 是基于客户—服务器（C/S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。如果我们要基于 FTP 协议开发一个文件传输的软件的话，首先需要搞清楚 FTP 的原理。关于 FTP 的原理，很多书籍上已经描述的非常详细了：</p>
<blockquote>
<p>FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：</p>
<ol>
<li>控制连接：用于传送控制信息（命令和响应）</li>
<li>数据连接：用于数据传送；</li>
</ol>
<p>这种将命令和数据分开传送的思想大大提高了 FTP 的效率。</p>
</blockquote>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/ftp.png" alt="FTP工作过程">FTP工作过程</p>
<p>注意 ：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。因此，FTP 传输的文件可能会被窃听或篡改。建议在传输敏感数据时使用更安全的协议，如 SFTP（SSH File Transfer Protocol，一种基于 SSH 协议的安全文件传输协议，用于在网络上安全地传输文件）。</p>
<h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><h2 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E7%9B%B8%E5%85%B3_RFC">SMTP</a></h2><p><strong>简单邮件传输(发送)协议（SMTP，Simple Mail Transfer Protocol）</strong> 基于 TCP 协议，是一种用于发送电子邮件的协议</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/what-is-smtp.png" alt="SMTP 协议">SMTP 协议</p>
<p>注意 ⚠️：<strong>接受邮件的协议不是 SMTP 而是 POP3 协议。</strong></p>
<p>SMTP 协议这块涉及的内容比较多，下面这两个问题比较重要：</p>
<ol>
<li>电子邮件的发送过程</li>
<li>如何判断邮箱是真正存在的？</li>
</ol>
<p><strong>电子邮件的发送过程？</strong></p>
<p>比如我的邮箱是“<a href="mailto:dabai@cszhinan.com">dabai@cszhinan.com</a>”，我要向“<a href="mailto:xiaoma@qq.com">xiaoma@qq.com</a>”发送邮件，整个过程可以简单分为下面几步：</p>
<ol>
<li>通过 <strong>SMTP</strong> 协议，我将我写好的邮件交给 163 邮箱服务器（邮局）。</li>
<li>163 邮箱服务器发现我发送的邮箱是 qq 邮箱，然后它使用 SMTP 协议将我的邮件转发到 qq 邮箱服务器。</li>
<li>qq 邮箱服务器接收邮件之后就通知邮箱为“<a href="mailto:xiaoma@qq.com">xiaoma@qq.com</a>”的用户来收邮件，然后用户就通过 <strong>POP3/IMAP</strong> 协议将邮件取出。</li>
</ol>
<p><strong>如何判断邮箱是真正存在的？</strong></p>
<p>很多场景(比如邮件营销)下面我们需要判断我们要发送的邮箱地址是否真的存在，这个时候我们可以利用 SMTP 协议来检测：</p>
<ol>
<li>查找邮箱域名对应的 SMTP 服务器地址</li>
<li>尝试与服务器建立连接</li>
<li>连接成功后尝试向需要验证的邮箱发送邮件</li>
<li>根据返回结果判定邮箱地址的真实性</li>
</ol>
<p>推荐几个在线邮箱是否有效检测工具：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://verify-email.org/">https://verify-email.org/</a></li>
<li><a target="_blank" rel="noopener" href="http://tool.chacuo.net/mailverify">http://tool.chacuo.net/mailverify</a></li>
<li><a target="_blank" rel="noopener" href="https://www.emailcamel.com/">https://www.emailcamel.com/</a></li>
</ol>
<h2 id="IMAP-POP3"><a href="#IMAP-POP3" class="headerlink" title="IMAP/POP3"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E4%BF%A1%E6%81%AF%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE">IMAP</a>/<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%83%B5%E5%B1%80%E5%8D%94%E5%AE%9A">POP3</a></h2><p>这两个协议没必要多做阐述，只需要了解 <strong>POP3 和 IMAP 两者都是负责邮件接收的协议</strong> 即可（二者也是基于 TCP 协议）。另外，需要注意不要将这两者和 SMTP 协议搞混淆了。<strong>SMTP 协议只负责邮件的发送，真正负责接收的协议是 POP3/IMAP。</strong></p>
<p>IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。</p>
<h2 id="E-mail-on-WWW"><a href="#E-mail-on-WWW" class="headerlink" title="E-mail on WWW"></a>E-mail on WWW</h2><h2 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B">MIME</a>改善了由 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc822">RFC 822</a> 转变而来的 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2822">RFC 2822</a> ，这些旧标准规定<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E9%83%B5%E4%BB%B6">电子邮件</a>标准并不允许在邮件消息中使用7位ASCII字符集以外的字符。正因如此，一些非英语字符消息和二进制文件，图像，声音等非文字消息原本都不能在电子邮件中传输（MIME可以）。MIME规定了用于表示各种各样的数据类型的符号化方法。此外，在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91">万维网</a>中使用的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTTP">HTTP协议</a>中也使用了MIME的框架，标准被扩展为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B">互联网媒体形式</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: [type]/[subtype]; parameter</span><br></pre></td></tr></table></figure>

<h1 id="Telnet-amp-SSH"><a href="#Telnet-amp-SSH" class="headerlink" title="Telnet &amp; SSH"></a>Telnet &amp; SSH</h1><p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Telnet">Telnet</a> 协议</strong> 基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/Telnet_is_vulnerable_to_eavesdropping-2.png" alt="Telnet:远程登陆协议"></p>
<p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Secure_Shell">SSH</a> （Secure Shell）</strong> 基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13P4y1o76u">SSH 握手详解 - bilibili 技术蛋老师</a> </p>
<p>SSH 的经典用途是登录到远程电脑中执行命令。除此之外，SSH 也支持隧道协议、端口映射和 X11 连接（允许用户在本地运行远程服务器上的图形应用程序）。借助 SFTP（SSH File Transfer Protocol） 或 SCP（Secure Copy Protocol） 协议，SSH 还可以安全传输文件。</p>
<p>SSH 使用客户端-服务器模型，默认端口是 22。SSH 是一个守护进程，负责实时监听客户端请求，并进行处理。大多数现代操作系统都提供了 SSH。</p>
<p>如下图所示，SSH Client（SSH 客户端）和 SSH Server（SSH 服务器）通过公钥交换生成共享的对称加密密钥，用于后续的加密通信。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/ssh-client-server.png" alt="SSH:安全的网络传输协议"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/01/12/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/12/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">计算机网络安全</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-12 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-12T00:00:00+08:00">2025-01-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-03 21:01:27" itemprop="dateModified" datetime="2025-05-03T21:01:27+08:00">2025-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="计算机面临的安全威胁"><a href="#计算机面临的安全威胁" class="headerlink" title="计算机面临的安全威胁"></a>计算机面临的安全威胁</h1><h2 id="攻击类型"><a href="#攻击类型" class="headerlink" title="攻击类型"></a>攻击类型</h2><p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/network-attack-means.html">网络攻击常见手段总结 | JavaGuide</a> </p>
<p><strong>被动攻击</strong>：也叫截获，流量分析。</p>
<p><strong>主动攻击</strong>：</p>
<ul>
<li><p><strong>篡改报文</strong>。</p>
</li>
<li><p><strong>恶意程序</strong>（病毒、蠕虫、木马、流氓软件、漏洞入侵、逻辑炸弹）</p>
</li>
<li><p><strong>拒绝服务</strong>（DoS, Denial of Service）：从互联网的一个服务器A发送大量信息到另一个服务器B，使得服务器B崩溃，拒绝服务。从多个服务器发分组又叫做分布式拒绝服务（DDoS, Distributed DoS）。负载均衡（anycast…）</p>
</li>
<li><p><strong>交换机中毒</strong>：发送大量伪造MAC帧，迅速填满交换机的交换表，使交换机无法正常提供服务。</p>
</li>
</ul>
<h2 id="安全措施"><a href="#安全措施" class="headerlink" title="安全措施"></a>安全措施</h2><ul>
<li><strong>机密性</strong>：密码技术，加密报文信息；对称加密</li>
<li><strong>信息完整性</strong>：防止报文信息被篡改；非对称加密，签名-鉴别</li>
<li><strong>端点鉴别</strong>（Authentication）：鉴别对方的真实身份；</li>
</ul>
<ul>
<li><strong>访问控制</strong>（Authorization）：确认用户的权限级别，能够进行什么样的操作。</li>
</ul>
<h3 id="Authentication（身份验证）"><a href="#Authentication（身份验证）" class="headerlink" title="Authentication（身份验证）"></a>Authentication（身份验证）</h3><p>确认用户的身份，确保用户是他声称的那个人。</p>
<p>验证用户的凭证（如用户名/密码、指纹、OTP 等）。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li>登录网站时输入用户名和密码。</li>
<li>使用指纹、面部识别或其他生物识别方式解锁设备。</li>
<li>输入短信验证码进行二次验证。</li>
</ul>
<h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h4><ul>
<li>“你是谁？”</li>
<li>解决的是<strong>身份问题</strong>。</li>
</ul>
<h3 id="Authorization（授权）"><a href="#Authorization（授权）" class="headerlink" title="Authorization（授权）"></a>Authorization（授权）</h3><p>确定已经通过身份验证的用户是否有权访问某资源或执行某操作。</p>
<p>控制用户能访问的资源或功能。</p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><ul>
<li>一个普通用户登录后不能访问管理员控制面板。</li>
<li>文件系统中，只有特定权限的用户可以修改文件。</li>
<li>云服务中，用户可能只能管理自己的项目，不能访问其他人的数据。</li>
</ul>
<h4 id="重点-1"><a href="#重点-1" class="headerlink" title="重点"></a>重点</h4><ul>
<li>“你可以做什么？”</li>
<li>解决的是<strong>权限问题</strong>。</li>
</ul>
<h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>Authentication（身份验证）</strong></th>
<th><strong>Authorization（授权）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>目的</strong></td>
<td>确认用户身份</td>
<td>确定用户访问权限</td>
</tr>
<tr>
<td><strong>处理对象</strong></td>
<td>用户的身份</td>
<td>用户的权限</td>
</tr>
<tr>
<td><strong>执行顺序</strong></td>
<td>先进行身份验证</td>
<td>只有通过身份验证后才能进行授权</td>
</tr>
<tr>
<td><strong>核心问题</strong></td>
<td>用户是否真实有效？</td>
<td>用户能访问哪些资源或执行哪些操作？</td>
</tr>
<tr>
<td><strong>技术示例</strong></td>
<td>密码验证、2FA、OAuth 登录</td>
<td>角色权限分配（RBAC）、ACL、API Token</td>
</tr>
</tbody></table>
<p><code>Authentication</code> 是 <code>Authorization</code> 的前提。<br> 一个用户必须先证明“自己是谁”，然后才能被系统允许或限制访问某些资源或执行操作。</p>
<h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h1><h2 id="两类密钥体制"><a href="#两类密钥体制" class="headerlink" title="两类密钥体制"></a>两类密钥体制</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86">对称加密</a></h3><p>双方使用同一把密钥，不对外公开，使用密钥将报文信息进行加密或者进行解密。</p>
<ul>
<li><p><strong>DES</strong>：密钥共64位，8位用于奇偶校验，实际为56位有效。</p>
</li>
<li><p><strong>3DES</strong>：使用两个DES密钥，先用K1加密，再用K2解密，再用K1加密</p>
</li>
<li><p><strong>AES</strong>：使用分组加密，密钥长度为128 192 256三种</p>
</li>
<li><p><strong>一个传统保管箱，开门和关门都是使用同一条钥匙，这是对称加密</strong> </p>
</li>
<li><p>只支持一对一通信。</p>
</li>
</ul>
<h3 id="公钥加密（非对称加密）"><a href="#公钥加密（非对称加密）" class="headerlink" title="公钥加密（非对称加密）"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">公钥加密（非对称加密）</a></h3><ul>
<li>使用密钥生成器生成密钥对，一个是公钥（对外公开），一个是私钥（自己保留）。</li>
<li>已知其中一个密钥的情况下，几乎不可能知道另外一个密钥。</li>
<li>私钥加密的数据，只能用公钥解密。公钥加密的数据，只能用私钥解密。<ul>
<li>其实不应该叫做加密和解密，应该称作D运算和E运算这两个互逆的运算，没有规定他们谁先谁后。</li>
<li>更准确的说法是私钥参与D运算，公钥参与E运算。</li>
</ul>
</li>
<li><strong>一个公开的邮箱，投递口是任何人都可以寄信进去的，这可视为公钥；</strong></li>
<li><strong>而只有信箱主人拥有钥匙可以打开信箱，这就视为私钥。</strong></li>
<li>支持多对一的通信。</li>
</ul>
<h2 id="鉴别（Authentication）"><a href="#鉴别（Authentication）" class="headerlink" title="鉴别（Authentication）"></a>鉴别（Authentication）</h2><h3 id="报文鉴别"><a href="#报文鉴别" class="headerlink" title="报文鉴别"></a>报文鉴别</h3><p>主要是鉴别报文是否被篡改。</p>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>decryption and encryption</p>
<p>A要发出信息，并进行数字签名，将报文用私钥SK<del>A</del>进行D运算（签名），其他人只能用公钥PK<del>A</del>进行E运算（鉴别）。</p>
<ul>
<li><strong>防止篡改报文</strong>：没人知道A的私钥SK<del>A</del>，窃听者使用公钥PK<del>A</del>进行E运算得出明文，篡改报文之后再D运算，另一边使用公钥PK<del>A</del>解析出的明文将会是不可读的，因此不会被欺骗。</li>
<li><strong>不可否认</strong>：既然信息明文可读，就说明没有被篡改过，而拥有私钥的只有A一个人，A就不能抵赖自己曾经的签名。</li>
</ul>
<p>上述方法是对报文本身进行了私钥加密，公钥直接可以解出报文具体内容，如果要用非对称加密实现报文内容的保密，可以在A用私钥D运算之后，再用B的公钥E运算，这样就彻底加密了报文内容，B收到以后先用B的私钥D运算，再用A的公钥E运算。</p>
<h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a><a href="../../Hash.md">哈希函数</a></h4><p>是一种摘要算法，将任意长度的报文经过哈希函数可以的到固定长度的字符串。</p>
<h4 id="结合报文鉴别码（MAC）实现数字签名报文鉴别"><a href="#结合报文鉴别码（MAC）实现数字签名报文鉴别" class="headerlink" title="结合报文鉴别码（MAC）实现数字签名报文鉴别"></a>结合报文鉴别码（MAC）实现数字签名报文鉴别</h4><p>Message Authentication Code, MAC</p>
<p>H(X) 代表 X 的哈希值；D(X) 代表 X 经过私钥的D运算以后的结果；E(X) 代表 X 经过 公钥的E运算之后的结果</p>
<p>$D(E(X)) = X$          $E(D(X)) = X$ </p>
<p>扩展报文实现的数字签名可以分为三类：</p>
<p>$A + H(A)$ ：只篡改报文A或者H(A)可以鉴别出来，但是直接换一个 X + H(X) 直接会蒙混过关，由此引出了使用密钥K来进行哈希运算的方法。</p>
<p>$A + H(A,K)$： 使用对称密钥$K$，如果报文$A$被篡改成$X$，但是攻击者不知道密钥，因此无法伪造出哈希值$H(X,K)$，另一边根据密钥计算出$H(X,K)$，就能发现报文被篡改过。这样将密钥拼接在正文之后，得出的散列值就是<strong>HMAC</strong>。JWT(Json Web Token)采用的数字签发就可以采用这样的方式 （HS256 代表 HMAC 散列函数为SHA-256）**对密钥K<u>严格要求保密</u>**。<a target="_blank" rel="noopener" href="https://ryan4yin.space/posts/jwt-algorithm-key-generation/">JWT 签名算法 HS256、RS256 及 ES256 及密钥生成 - This Cute World</a> </p>
<p>$A + D(H(A))$：使用私钥对报文的哈希进行D运算，其他人使用公钥对密文进行E运算能够得出哈希值，将这个哈希值和报文段的哈希值比较即可。如果$A$被篡改为$X$，攻击者因为不知道发送者的私钥，因此无法得出一个正确的$D(H(X))$，这时候发给接收者，接受者再对攻击者伪造的哈希值密文进行E运算，得出哈希值肯定和真正的$H(X)$不同，这就是RS256和ES256的原理。**由此方法扩展出的报文<u>不可伪造，也不可否认</u>**，同时可以运用到分布式架构中，一个服务签发，其他服务验证只需要公钥即可。ES256（ECDSA）使用椭圆曲线计算公钥。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kirito-c/p/12402066.html">JWT 签名算法 HS256、RS256 及 ES256 及密钥生成 - 於清樂 - 博客园</a> </p>
<h3 id="实体鉴别"><a href="#实体鉴别" class="headerlink" title="实体鉴别"></a>实体鉴别</h3><h4 id="对称密钥"><a href="#对称密钥" class="headerlink" title="对称密钥"></a>对称密钥</h4><p>主要是验证来访者的确是访问者，也就是鉴别身份。</p>
<p>相比于报文鉴别，实体鉴别只需要鉴别一次发送者即可，后续传输不需要鉴别，使用<strong>共享对称密钥</strong>，如果第三方C截获了A发给B的验证信息，并未破译报文，而是直接伪装成A给B发消息，这样B就会错误地与C建立起联系。把以前窃听到的数据原封不动地重新发送给接收方，这就叫 <strong>重放攻击</strong>。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/2229240">重放攻击_百度百科</a> </p>
<p>重放攻击的基本原理就是把以前<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%AA%83%E5%90%AC/1624599?fromModule=lemma_inlink">窃听</a>到的数据原封不动地重新发送给接收方。很多时候，网络上传输的数据是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8A%A0%E5%AF%86/752748?fromModule=lemma_inlink">加密</a>过的，此时窃听者无法得到数据的准确意义。但如果他知道这些数据的作用，就可以在不知道数据内容的情况下通过再次发送这些数据达到愚弄接收端的目的。例如，有的系统会将鉴别信息进行简单加密后进行传输，这时攻击者虽然无法窃听<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AF%86%E7%A0%81/65553?fromModule=lemma_inlink">密码</a>，但他们却可以首先截取加密后的口令然后将其重放，从而利用这种方式进行有效的攻击。再比如，假设网上存款系统中，一条消息表示用户支取了一笔存款，攻击者完全可以多次发送这条消息而偷窃存款。</p>
</blockquote>
<p>因此采取的措施就是尽量能够让B端验证清楚A的身份。K(X)表示用密钥加密过的X</p>
<p>A先发身份信息 + 一个大随机不重复数<code>RA</code>，B收到后响应一个<code>RB</code>和<code>K(RA)</code>，因此对于A端而言B端是可信的；A端再发送<code>K(RB)</code>，因此对于B端而言A端是可信的。需要注意的是每次会话都都需要重新验证，并且需要有足够的空间存储不同会话的不同随机数。</p>
<h4 id="非对称密钥"><a href="#非对称密钥" class="headerlink" title="非对称密钥"></a>非对称密钥</h4><p>对于上文的不重复随机数，B可以用B自己的私钥加密RA，A用B的公钥解密得出RA；A用自己的私钥加密RB，B用A的公钥解密RB。这里C可以生成自己的私钥和公钥，分别截获RA和RB，仍然能够冒充A，与B进行通信。不过A与B根本没有进行通信，A端很容易察觉到。</p>
<p><strong>中间人攻击</strong>：假设AB通信双方并没有提前知道对方的公钥是什么。</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8.assets/image-20241129155621051.png" alt="image-20241129155621051"></p>
<p>C截获A的身份验证信息和RB，用自己的私钥加密RB得到D<del>C</del>(RB)返回给B，同时把RB转发给A，A向对方索取公钥，C就把自己的公钥发给A，但是仍然把公钥的请求转发给A，A发出了自己的D<del>A</del>(RB)和公钥，但均被C所截获。</p>
<p>A跟B开始建立通信，B就把发送的数据用C的公钥加密，C直接可以用自己的私钥解密，解密出来以后再用A的公钥加密，发给A，看似A和B建立了保密通信，实际上C能够神不知鬼不觉地窃取信息。</p>
<blockquote>
<p>SSL劫持</p>
<p>当今绝大部分网站采用HTTPS方式进行访问，也就是用户与网站服务器间建立<a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/SSL.html">SSL</a>连接，基于SSL证书进行数据验证和加密。HTTPS可以在一定程度上减少中间人攻击，但是攻击者还是会使用各种技术尝试破坏HTTPS，SSL劫持就是其中的一种。SSL劫持也称为SSL证书欺骗，攻击者伪造网站服务器证书，公钥替换为自己的公钥，然后将虚假证书发给用户。此时用户浏览器会提示不安全，但是如果用户安全意识不强继续浏览，攻击者就可以控制用户和服务器之间的通信，解密流量，窃取甚至篡改数据。</p>
</blockquote>
<h2 id="密钥分配与管理"><a href="#密钥分配与管理" class="headerlink" title="密钥分配与管理"></a>密钥分配与管理</h2><h3 id="对称密钥交换"><a href="#对称密钥交换" class="headerlink" title="对称密钥交换"></a>对称密钥交换</h3><h4 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h4><h5 id="难点：大数因式分解"><a href="#难点：大数因式分解" class="headerlink" title="难点：大数因式分解"></a>难点：大数因式分解</h5><p>公开的数字：公钥D，N</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8.assets/image-20241129230424076-1732894652386-1.png" alt="image-20241129230424076"></p>
<p>难点：算出T的值，也就是要分解N。</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8.assets/image-20241129230521315-1732944264022-8.png" alt="image-20241129230521315"></p>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li>使用场景较广泛，适合需要加密数据、验证签名的场合。</li>
<li>不适合直接交换大数据（效率较低）。</li>
</ul>
<h5 id="RSA-的缺陷"><a href="#RSA-的缺陷" class="headerlink" title="RSA 的缺陷"></a>RSA 的缺陷</h5><p>没有前向保密性，所有的数字（质数乘积N，公钥E）必须提前沟通好，依赖于长期的静态密钥对（公钥和私钥）来交换对称密钥，而没有使用每次会话生成的临时密钥对。在 RSA 密钥交换过程中，如果服务器的私钥被泄露，攻击者可以解密所有使用该私钥加密的对称密钥，进而恢复以前的会话数据，从而破坏了前向保密性。</p>
<h4 id="Diffle-Hellman-密钥交换"><a href="#Diffle-Hellman-密钥交换" class="headerlink" title="Diffle-Hellman 密钥交换"></a>Diffle-Hellman 密钥交换</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/599518034">一文搞懂Diffie-Hellman密钥交换协议 - 知乎</a> </p>
<h5 id="难点：离散对数"><a href="#难点：离散对数" class="headerlink" title="难点：离散对数"></a>难点：离散对数</h5><p>公开的数字：P、G、双方的公钥。</p>
<ul>
<li><p>正向计算简单，逆向计算难（即在有限域上计算  $g^x \mod p$ 的逆运算很难）</p>
</li>
<li><p>依赖于离散对数的计算难度，使用的素数位数越长，安全性越高。</p>
</li>
<li><p>易受中间人攻击，因此通常结合认证机制（如数字签名）使用。</p>
</li>
</ul>
<h5 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li>专用于安全密钥交换，通常与对称加密算法结合使用。</li>
<li>不支持数据加密或签名。</li>
</ul>
<p>由8和19无法逆推回x与y，由$19^x \mod 23 = 8^y \mod 23$ 也无法推出x和y的值</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8.assets/image-20241129230002490.png" alt="image-20241129230002490"></p>
<h5 id="ECDHE"><a href="#ECDHE" class="headerlink" title="ECDHE"></a>ECDHE</h5><p>static DH算法 – &gt; DHE算法 – &gt; ECDHE算法</p>
<p><strong>static DH</strong> 算法里有一方的私钥是静态的，也就说每次密钥协商的时候有一方的私钥都是一样的，一般是服务器方固定，即 a 不变，客户端的私钥则是随机生成的。 于是，DH 交换密钥时就只有客户端的公钥是变化，而服务端公钥是不变的，那么随着时间延长，黑客就会截获海量的密钥协商过程的数据，因为密钥协商的过程有些数据是公开的，黑客就可以依据这些数据暴力破解出服务器的私钥，然后就可以计算出会话密钥了，于是之前截获的加密数据会被破解，所以 static DH 算法<strong>不具备前向安全性</strong>。</p>
<p><strong>DHE</strong> </p>
<ul>
<li><strong>Ephemeral（临时密钥）</strong>：在 DHE 中，”Ephemeral” 表示每次会话都生成新的密钥对（临时密钥）。因此，即使密钥在某一时刻被泄露，它也无法用于恢复以前的通信，增强了前向保密性（forward secrecy）。</li>
</ul>
<p>G、P可以固定，DHE 每次需要传递的数据就是计算出来的公钥，不过大数乘除性能不好，于是有了ECDHE，用ECC提高性能。</p>
<p><strong>ECDHE</strong>（Elliptic Curve Diffie-Hellman Ephemeral） 是 Diffie-Hellman 协议的椭圆曲线版本，使用椭圆曲线加密（ECC，Elliptic Curve Cryptography）来代替传统的基于大数的计算。椭圆曲线加密在相同的安全级别下，所需的密钥长度比传统的 DH 小得多，从而提高了计算效率。</p>
<h4 id="密钥分发中心（KDC）"><a href="#密钥分发中心（KDC）" class="headerlink" title="密钥分发中心（KDC）"></a>密钥分发中心（KDC）</h4><p>Key Distribution Center</p>
<h3 id="公钥体制：CA"><a href="#公钥体制：CA" class="headerlink" title="公钥体制：CA"></a>公钥体制：CA</h3><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89">Certificate Authority 证书权威机构</a></p>
<p>除非A与B线下沟通好公钥，不然总是有可能会被中间人攻击（即中间人会截获请求者的公钥，替换成自己的公钥），那么如何保证B的公钥能准确无误传到A手上不被篡改呢？需要第三方进行数字签名，CA用自己的私钥将报文信息数字签名，也就是MAC报文鉴别码。最终报文鉴别码附在报文后面$B + D(H(B))$</p>
<p>这里的报文B包含：</p>
<ul>
<li>B的身份验证信息（我是B）</li>
<li>B的公钥（我的公钥是xxx）</li>
</ul>
<p>因此，B需要提供证书，A需要把证书的报文部分进行哈希运算，然后用报文中B提供的公钥进行E运算，看得出的结果是否相同，如果不同说明证书被篡改，不可信。一切的基础是建立在CA上面，CA是一个大家都认可的权威机构</p>
<h4 id="CA-标准：X-509（PKI）"><a href="#CA-标准：X-509（PKI）" class="headerlink" title="CA 标准：X.509（PKI）"></a>CA 标准：X.509（PKI）</h4><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89">公开密钥认证 - 维基百科，自由的百科全书</a> Public Key Infrastructure</p>
<p><strong>数字证书标准</strong>：</p>
<ul>
<li>X.509 版本</li>
<li>数字证书名称、序列号</li>
<li>本数字签名证书使用的签名算法（CA进行数字签名的非对称算法）</li>
<li>数字签名的公钥（私钥由签发者保存）</li>
<li>签发者的唯一标识符</li>
<li>数字证书的有效期</li>
<li>数字证书的主体名（数字证书拥有者及其拥有的公钥的唯一标识符）</li>
</ul>
<h4 id="CA-信任链：多级认证系统"><a href="#CA-信任链：多级认证系统" class="headerlink" title="CA 信任链：多级认证系统"></a>CA 信任链：多级认证系统</h4><p>万一中级证书不能信任了，还可以让根证书再找一个中级证书，因为信任根证书，也自然信任这个新的中级证书，但如果根证书直接信任某个网站的证书，万一根证书被攻破不能信任了，那就找不到可以信任的了。</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8.assets/image-20241129222025691.png" alt="image-20241129222025691"></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A0%B9%E8%AF%81%E4%B9%A6">根证书</a>：所有信任链的起点，使用私钥自签。根证书获得广泛认可，通常已预先安装在各种软件（包括<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8">浏览器</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E9%83%B5%E4%BB%B6%E7%94%A8%E6%88%B6%E7%AB%AF">电邮软件</a>等），作为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E4%BB%BB%E9%8F%88">信任链</a>的起点，来自于公认可靠的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%94%BF%E5%BA%9C%E6%9C%BA%E5%85%B3">政府机关</a>（如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A6%99%E6%B8%AF%E9%83%B5%E6%94%BF">香港邮政</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%B0%E7%81%A3%E7%B6%B2%E8%B7%AF%E8%B3%87%E8%A8%8A%E4%B8%AD%E5%BF%83">台湾网络信息中心</a>）、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84">证书颁发机构</a>公司（如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DigiCert">DigiCert</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Google">Google</a>）、非营利组织（如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Let's_Encrypt">Let’s Encrypt</a>）等，与各大软件商透过严谨的核认程序才在不同的软件广泛部署。由于部署程序复杂费时，需要行政人员的授权及机构法人身份的核认，一张根证书有效期可能长达二十年以上。在某些企业，也可能会在内部电脑自行安装企业自签的根证书，以支持<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%86%85%E9%83%A8%E7%BD%91">内部网</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%BD%AF%E4%BB%B6">企业级软件</a>；但是这些证书可能未被广泛认可，只在企业内部适用。</p>
<p><strong>中介证书</strong>：认证机构的一个重要任务就是为客户签发证书，虽然广泛认可的认证机构都已拥有根证书，相对应的私钥可用以签署其他证书，但因为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86">密钥管理</a>和行政考虑，一般会先行签发中介证书，才为客户作数字签署。中介证书的有效期会较根证书为短，并可能对不同类别的客户有不同的中介证书作分工。</p>
<p><strong>TLS 服务器证书</strong>：服务器通常以域名形式在互联网上提供服务，服务器证书上<strong>主体</strong>的<strong>通用名称</strong>就会是相应的域名，相关机构名称则写在<strong>组织</strong>或<strong>单位</strong>一栏上。服务器证书（包括公钥）和私钥会安装于服务器（例如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Apache_HTTP_Server">Apache</a>），等待客户端连接时<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8F%A1%E6%89%8B_(%E6%8A%80%E6%9C%AF)">协议加密细节</a>。客户端的软件（如浏览器）会执行<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%AA%8D%E8%AD%89%E8%B7%AF%E5%BE%91%E9%A9%97%E8%AD%89%E7%AE%97%E6%B3%95&action=edit&redlink=1">认证路径验证算法</a>以确保安全，如果未能肯定加密通道是否安全（例如证书上的主体名称不对应网站域名、服务器使用了自签证书、或加密算法不够强），可能会警告用户。</p>
<p><strong>TLS 客户端证书</strong>：有时候，某些TLS服务器可能会在建立加密通道时，要求客户端提供客户端证书，以验证<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD">身份</a>及<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6">控制访问权限</a>。客户端证书包含电子邮件地址或个人姓名，而不是主机名。但客户端证书比较不常见，因为考虑到技术门槛及成本因素，通常都是由服务提供者验证客户身份，而不是依赖第三方认证机构。通常，需要使用到客户端证书的服务都是内部网的企业级软件，他们会设立自己的内部根证书，由企业的技术人员在企业内部的电脑安装相关客户端证书以便使用。在公开的互联网，大多数网站都是使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC_(%E8%AA%8D%E8%AD%89)">登录密码</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Cookie">Cookie</a>来验证用户，而不是客户端证书。客户端证书在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8">RPC系统</a>中更常见，用于验证连接设备的许可授权。</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%AD%BE%E8%AF%81%E4%B9%A6">自签证书</a>：在用于小范围测试等目的的时候，用户也可以自己生成数字证书，但没有任何可信赖的人签名，这种自签名证书通常不会被广泛信任，使用时可能会遇到电脑软件的安全警告。</p>
<h4 id="CA-撤销名单"><a href="#CA-撤销名单" class="headerlink" title="CA 撤销名单"></a>CA 撤销名单</h4><p>CA 撤销名单：尚未到期就被<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84">证书颁发机构</a>吊销的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6">数字证书</a>的名单。</p>
<ul>
<li>吊销：该证书被不可逆的吊销。例如，它被不当的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84">证书颁发机构</a>颁发了证书，或者私钥被认为已经破坏。被吊销的最常见的原因是用户不再独有私钥，而私钥则被窃取。</li>
<li>吊扣：这个状态是可逆的。</li>
</ul>
<p>每个CA都有对应的CA证书撤销名单，里面包含着证书的序列号。有 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9C%A8%E7%BA%BF%E8%AF%81%E4%B9%A6%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE">OCSP</a> 和 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AF%81%E4%B9%A6%E5%90%8A%E9%94%80%E5%88%97%E8%A1%A8">CRL</a> 两种形式</p>
<blockquote>
<p>非关键 CA 颁发者: URI: <a target="_blank" rel="noopener" href="http://secure.globalsign.com/cacert/gsrsaovsslca2018.crt">http://secure.globalsign.com/cacert/gsrsaovsslca2018.crt</a> </p>
<p>OCSP 响应者: URI: <a target="_blank" rel="noopener" href="http://ocsp.globalsign.com/gsrsaovsslca2018">http://ocsp.globalsign.com/gsrsaovsslca2018</a></p>
</blockquote>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/crl.png" alt="img"></p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/ocsp.png" alt="img"></p>
<h1 id="HTTPS-SSL-TLS"><a href="#HTTPS-SSL-TLS" class="headerlink" title="HTTPS (SSL/TLS)"></a>HTTPS (SSL/TLS)</h1><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/http_interview.html#http-%E4%B8%8E-https">HTTPS  HTTP</a> </p>
<h2 id="传输层安全（TLS）"><a href="#传输层安全（TLS）" class="headerlink" title="传输层安全（TLS）"></a>传输层安全（TLS）</h2><p>Transport Layer Security</p>
<h3 id="TLS-握手（TLS-1-2）"><a href="#TLS-握手（TLS-1-2）" class="headerlink" title="TLS 握手（TLS 1.2）"></a>TLS 握手（TLS 1.2）</h3><p>在TCP threeway handshake之后，就会开始TLS handshake</p>
<p>两种交换会话密钥的算法：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_rsa.html#rsa-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B">RSA 握手</a> 和 <a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_ecdhe.html">ECDHE 握手</a> 后者支持前向安全，现在使用更加广泛</p>
<h4 id="RSA-握手"><a href="#RSA-握手" class="headerlink" title="RSA 握手"></a>RSA 握手</h4><p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8.assets/image-20241130161720294.png" alt="image-20241130161720294"></p>
<ol>
<li><strong>ClientHello</strong>: 客户端向服务器发送随机数<code>client random</code>，TLS版本，支持的加密套件列表。</li>
<li><strong>ServerHello</strong>: 服务器响应随机数<code>server random</code>，确认好加密套件，下发服务器证书(<code>Certificate</code>)。<ul>
<li>证书里有用于<code>premaster</code>加密的服务器公钥</li>
</ul>
</li>
<li><strong>Client Key Exchange</strong>: 客户端证书验证通过后，生成另一个随机数<code>premaster secret</code>，通过<strong>服务器证书的公钥</strong>加密</li>
<li>服务器用私钥解密获取<code>premaster secret</code>，双方根据<code>premaster secret</code>和两个随机数生成<code>session key</code> </li>
<li><strong>Change Cipher Spec</strong>: 客户端通知接下来要使用会话密钥进行通信了，之前都是明文通信。切换加密标准</li>
<li><strong>Finishd</strong>: 客户端计算之前发出的明文消息的摘要（Hash），再用<code>session key</code>加密后发给服务端</li>
<li>服务端重复5,6步，双方认证加解密无问题，则可以开始正式发送用<code>session key</code>加密后的<code>application data</code> </li>
</ol>
<p><img src="https://ask.qcloudimg.com/http-save/4069756/e6zkf4qwi7.jpeg" alt="img"></p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/https_rsa.png" alt="img"> </p>
<h5 id="加密套件（Cipher-Suite）"><a href="#加密套件（Cipher-Suite）" class="headerlink" title="加密套件（Cipher Suite）"></a>加密套件（Cipher Suite）</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43408952/article/details/124715927">TLS 各种加密套件_tls加密套件-CSDN博客</a> </p>
<p><strong>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</strong> </p>
<ul>
<li><strong>密钥交换策略</strong>（Key Exchange/Arrangement）：用于交换对称密钥。<strong>RSA</strong>、DH、DHE、<strong>ECDHE</strong>、PSK</li>
<li><strong>数字签名算法</strong>（Authentication）：用于验证证书。<strong>RSA</strong>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95"><strong>DSA</strong></a> 、ECDSA</li>
<li><strong>对称加密算法</strong>（Block/stream ciphers）：用于加密消息流。<strong>ChaCha20</strong>、<strong>AES</strong>、DES等</li>
<li><strong>MAC 算法</strong>（Message authentication）：用于创建报文鉴别码，例如<strong>SHA-256</strong>，MD5，消息流每个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%9D%97">数据块</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%AF%86%E6%95%A3%E5%88%97">加密散列</a>。(分块加密信息以后的报文摘要)</li>
</ul>
<h5 id="前向安全性（Forward-Secrecy）"><a href="#前向安全性（Forward-Secrecy）" class="headerlink" title="前向安全性（Forward Secrecy）"></a>前向安全性（Forward Secrecy）</h5><p>共享密钥被攻破不会导致之前的会话信息全部泄露。Perfect Forward Secrecy</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/45203206">如何理解前向安全性？和完美前向保密（perfect forward secrecy）区别？ - 知乎</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/348420897">有了共享密钥为什么还需要会话密钥？ - 知乎</a> </p>
<p><strong>有了premaster key为什么要session key？</strong> </p>
<p>RSA握手中不把premaster key直接当做对称密钥，单次session key泄露不会造成之前的会话信息都泄露。</p>
<p>前向安全性问题出在共享密钥上，RSA握手的共享公-私密钥对是长期不变的，也就是说如果服务端用于RSA加密的私钥泄露会导致之前的会话信息全部暴露。如果对每次会话都生成一对RSA密钥对，理论可行，但是性能不如后面要介绍的ECDHE。</p>
<p> 双<strong>RSA</strong>虽然也能实现<strong>PFS</strong>，但是效率太差，没有公司会采用， 基本都是<strong>RSA + ECDHE</strong>。 </p>
<h4 id="ECDHE-握手"><a href="#ECDHE-握手" class="headerlink" title="ECDHE 握手"></a>ECDHE 握手</h4><p>椭圆曲线最重要的参数是<strong>椭圆曲线类型</strong>（基点G）[RSA 算法的替代品：X25519/Ed25519 使用记录 | 存在感消失的地方|ω•`)](<a target="_blank" rel="noopener" href="https://akarin.dev/2021/09/16/a-taste-of-curve25519/">https://akarin.dev/2021/09/16/a-taste-of-curve25519/</a>)  </p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8.assets/image-20241130165130228.png" alt="image-20241130165130228"></p>
<ol>
<li><strong>ClientHello</strong>: 客户端向服务器发送<strong>随机数</strong>client random，TLS版本，支持的加密套件列表</li>
<li><strong>ServerHello</strong>: 服务器响应<strong>随机数</strong>server random，确认好双方都支持的加密套件，同时下发服务器<strong>证书</strong>(<code>certificate</code>)<ul>
<li>证书中的公钥用于鉴别自己发出的签名有效。</li>
</ul>
</li>
<li><strong>Server Key Exchange</strong>: 生成随机数作为<strong>临时私钥</strong>，保留在本地。公开<strong>椭圆曲线</strong>基点G，一般是X25519，根据G和临时生成的私钥，算出<strong>公钥</strong>发给客户端。为了保证公钥不被篡改，同时会使用RSA进行数字签名。</li>
<li><strong>Client Key Exchange</strong>: 客户端验证通过后，生成自己临时私钥，根据基点G算出<strong>公钥</strong>，发送给服务器。</li>
<li>这样，双方知道了对方的公钥，就可以开始算共享密钥了。</li>
<li>之后的步骤就是互相发送change cipher spec+finished，ECDHE可以在客户端发完信息之后可以直接开始发送<code>application data</code> </li>
</ol>
<p><img src="https://ask.qcloudimg.com/http-save/4069756/0mhr8kq63w.jpeg" alt="img"></p>
<p>==抓包实战== </p>
<p><u>搭建https server（springboot）</u></p>
<ol>
<li><strong>生成自签名证书</strong>，使用jdk的keytool生成证书</li>
</ol>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -<span class="keyword">alias</span> wxl -keyalg RSA -keysize <span class="number">2048</span> -storetype PKCS12 -keystore wxl-ssl-<span class="keyword">key</span>.p12 -validity <span class="number">3650</span></span><br></pre></td></tr></table></figure>

<ul>
<li>-genkey：表示要创建一个新的密钥</li>
<li>-alias：keystore别名</li>
<li>-keyalg：加密算法</li>
<li>-keysize：密钥长度</li>
<li>-storetype：密钥类型</li>
<li>-keystore：文件存放位置</li>
<li>-validity：密钥有效期，单位为天</li>
</ul>
<ol start="2">
<li><strong>springboot配置https</strong></li>
</ol>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8443</span></span><br><span class="line">  <span class="attr">ssl:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">key-store:</span> <span class="string">classpath:wxl-ssl-key.p12</span></span><br><span class="line">    <span class="attr">key-store-password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">key-store-type:</span> <span class="string">PKCS12</span></span><br><span class="line">    <span class="attr">enabled-protocols:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TLSv1.2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>enabled-protocols表示支持启用的TLS版本，这里配置仅TLS1.2</li>
</ul>
<p><u>请求并抓包</u></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://localhost:8443/hello -k</span><br></pre></td></tr></table></figure>

<p>tcp.port == 8443</p>
<h5 id="TLS-False-Start"><a href="#TLS-False-Start" class="headerlink" title="TLS False Start"></a>TLS False Start</h5><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000004003319">https - TLS False Start究竟是如何加速网站的 - 野狗科技官方专栏 - SegmentFault 思否</a> </p>
<p><img src="https://ask.qcloudimg.com/http-save/4069756/0mhr8kq63w.jpeg" alt="img"></p>
<blockquote>
<p>The recommended whitelists are such that if cryptographic algorithms suitable for forward secrecy would possibly be negotiated, no False Start will take place if the current handshake fails to provide forward secrecy.</p>
<p><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7918">RFC 7918 - Transport Layer Security (TLS) False Start</a> </p>
</blockquote>
<p>ECDHE和DHE支持前向保密，所以可以使用TLS抢跑。</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1420297">90%的人都不懂的TLS握手优化-腾讯云开发者社区-腾讯云</a> </p>
<h3 id="TLS-记录"><a href="#TLS-记录" class="headerlink" title="TLS 记录"></a>TLS 记录</h3><p>TLS 握手主要用来解决服务器的可信度问题，TLS 记录可以解决报文的压缩、加密和数据认证的问题。</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8.assets/image-20241130224715135.png" alt="image-20241130224715135"></p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E8%AE%B0%E5%BD%95%E5%8D%8F%E8%AE%AE.png" alt="img"></p>
<h3 id="TLS-漏洞"><a href="#TLS-漏洞" class="headerlink" title="TLS 漏洞"></a>TLS 漏洞</h3><hr>
<p><u><strong>协议设计上的漏洞</strong></u>：一些漏洞源于TLS协议本身的设计缺陷，通常会在新版本中修复：</p>
<p><strong>BEAST（Browser Exploit Against SSL/TLS）</strong></p>
<ul>
<li><strong>描述</strong>：BEAST 攻击利用 TLS 1.0 中的 CBC 模式实现的设计缺陷，通过中间人攻击窃取加密数据。</li>
<li><strong>修复</strong>：TLS 1.1 和更高版本已经修复了该问题，同时推荐使用 AES-GCM 等替代的加密模式。</li>
</ul>
<p><strong>CRIME（Compression Ratio Info-leak Made Easy）</strong></p>
<ul>
<li><strong>描述</strong>：通过利用TLS压缩功能，攻击者可以猜测敏感数据（如会话Cookie）。</li>
<li><strong>修复</strong>：禁用TLS压缩功能。</li>
</ul>
<p><strong>POODLE（Padding Oracle On Downgraded Legacy Encryption）</strong></p>
<ul>
<li><strong>描述</strong>：POODLE 利用 SSL 3.0 中的填充漏洞进行攻击，针对使用CBC模式的实现。</li>
<li><strong>修复</strong>：废弃 SSL 3.0 并采用更安全的协议版本（如 TLS 1.2+）。</li>
</ul>
<p><strong>Downgrade Attacks</strong></p>
<ul>
<li><strong>描述</strong>：攻击者通过中间人攻击强制客户端和服务器降级到不安全的协议版本（如 SSL 3.0 或早期 TLS 版本）。</li>
<li><strong>修复</strong>：使用 <strong>TLS_FALLBACK_SCSV</strong> 标记防止协议降级攻击。</li>
</ul>
<p><strong>Logjam</strong></p>
<ul>
<li><strong>描述</strong>：Logjam 攻击利用 Diffie-Hellman 密钥交换中的弱参数（512位素数），允许攻击者破解加密。</li>
<li><strong>修复</strong>：升级到更强的密钥（2048位或以上），并禁用弱算法。</li>
</ul>
<hr>
<p><u><strong>实现上的漏洞</strong></u>：许多漏洞是由于TLS库实现中存在的错误或疏漏，而不是协议本身的问题。</p>
<p><strong>Heartbleed</strong></p>
<ul>
<li><strong>描述</strong>：这是 OpenSSL 的实现漏洞，允许攻击者通过 Heartbeat 扩展读取服务器内存中的敏感数据（如私钥）。</li>
<li><strong>修复</strong>：修复受影响的 OpenSSL 版本，更新到无漏洞的版本。</li>
</ul>
<p><strong>ROBOT（Return Of Bleichenbacher’s Oracle Threat）</strong></p>
<ul>
<li><strong>描述</strong>：利用某些TLS实现中的 RSA 加密模式缺陷，通过构造恶意数据包破解私钥。</li>
<li><strong>修复</strong>：修复实现并采用更安全的加密模式。</li>
</ul>
<p><strong>Zero-Length Padding</strong></p>
<ul>
<li><strong>描述</strong>：某些TLS实现接受零长度的填充，可能被攻击者利用进行漏洞利用。</li>
<li><strong>修复</strong>：严格遵循协议规范，确保填充字段符合要求。</li>
</ul>
<hr>
<p><u><strong>配置和使用上的问题</strong></u>：即使TLS协议和实现没有漏洞，不当的配置或使用也可能导致安全隐患。</p>
<p><strong>弱密码套件</strong></p>
<ul>
<li>使用已知不安全的加密算法或过短的密钥长度（如RC4或1024位RSA）。</li>
<li><strong>解决方法</strong>：禁用弱密码套件，使用推荐的安全算法（如 AES-GCM、ChaCha20-Poly1305）。</li>
</ul>
<p><strong>过期或伪造的证书</strong></p>
<ul>
<li>如果服务器使用过期、伪造或不可信的证书，攻击者可以进行中间人攻击。</li>
<li><strong>解决方法</strong>：确保证书可信且未过期，并使用 Certificate Transparency 来检测伪造证书。</li>
</ul>
<p><strong>主机名验证问题</strong></p>
<ul>
<li>一些TLS实现未正确验证证书中的主机名，可能导致攻击者伪装成合法服务器。</li>
<li><strong>解决方法</strong>：强制严格的主机名验证。</li>
</ul>
<p><strong>会话恢复漏洞</strong></p>
<ul>
<li>TLS会话恢复功能（如会话ID或会话票据）在设计或实现上可能存在漏洞，导致会话劫持。</li>
<li><strong>解决方法</strong>：确保会话恢复机制的实现安全，并定期刷新密钥。</li>
</ul>
<hr>
<p><u><strong>环境相关漏洞</strong></u></p>
<p><strong>硬件漏洞</strong></p>
<ul>
<li>硬件加速器或HSM（硬件安全模块）可能存在漏洞，攻击者可以利用其生成弱密钥或泄露数据。</li>
</ul>
<p><strong>随机数生成问题</strong></p>
<ul>
<li>如果随机数生成器的质量不足，攻击者可能预测到密钥。</li>
<li><strong>解决方法</strong>：使用高质量的随机数生成器（如 /dev/urandom 或硬件随机数生成器）。</li>
</ul>
<p><strong>中间人攻击</strong></p>
<ul>
<li>攻击者通过篡改DNS或ARP欺骗迫使客户端连接到恶意服务器，伪装成合法的TLS服务。</li>
<li><strong>解决方法</strong>：使用 HSTS（HTTP Strict Transport Security）和证书锁定（Certificate Pinning）。</li>
</ul>
<hr>
<p><u><strong>社会工程和弱安全操作</strong></u>：即使TLS协议本身非常安全，攻击者可能利用社会工程或操作疏漏来绕过安全机制</p>
<ul>
<li>攻击者诱骗用户接受不可信的证书。</li>
<li>管理员错误配置服务器，允许使用过时的协议版本。</li>
</ul>
<hr>
<h4 id="如何应对TLS漏洞？"><a href="#如何应对TLS漏洞？" class="headerlink" title="如何应对TLS漏洞？"></a>如何应对TLS漏洞？</h4><ol>
<li><strong>升级协议和实现</strong><ul>
<li>确保使用最新版本的TLS（推荐TLS 1.2或TLS 1.3）。</li>
<li>定期更新TLS库（如OpenSSL、BoringSSL、GnuTLS）。</li>
</ul>
</li>
<li><strong>禁用弱配置</strong><ul>
<li>禁用SSL 2.0、SSL 3.0和TLS 1.0。</li>
<li>禁用RC4和其他已知不安全的密码套件。</li>
</ul>
</li>
<li><strong>安全的服务器配置</strong><ul>
<li>强制使用强加密算法。</li>
<li>使用2048位以上的密钥和推荐的椭圆曲线（如 P-256）。</li>
</ul>
</li>
<li><strong>监控和检测</strong><ul>
<li>定期扫描服务器的TLS配置，使用工具如 SSL Labs 的服务器测试工具。</li>
<li>监控网络流量中的潜在攻击行为。</li>
</ul>
</li>
</ol>
<h3 id="TLS-1-3"><a href="#TLS-1-3" class="headerlink" title="TLS 1.3"></a>TLS 1.3</h3><p><img src="https://cdn.xiaolincoding.com//mysql/other/0877fe78380bf34ad3b28768e59fb53a.png" alt="图片"></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28850798">TLS 1.3科普——新特性与协议实现 - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/187262056">TLS 1.3 进行时 - 知乎</a> </p>
<h4 id="2-RTT（TLS-1-2）"><a href="#2-RTT（TLS-1-2）" class="headerlink" title="2-RTT（TLS 1.2）"></a>2-RTT（TLS 1.2）</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wusanga/p/17386098.html">TLS1.2握手流程分析（RSA，ECDHE），和TLS1.3区别 - wuworker - 博客园</a> </p>
<p><img src="https://pic2.zhimg.com/v2-485b564d2209a3108575a1b13a52d715_1440w.jpg" alt="img"></p>
<h4 id="1-RTT"><a href="#1-RTT" class="headerlink" title="1-RTT"></a>1-RTT</h4><p>TLS1.2 为了考虑各种兼容性，保留了许多加密套件，这就使得客户端必须提前和服务端协商好用哪一种加密套件，这也导致了必须空出一个RTT专门协商，因此变成2-RTT。1.3只剩下5种，省去协商步骤，变成了1-RTT。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TLS_AES_256_GCM_SHA384</span><br><span class="line">TLS_CHACHA20_POLY1305_SHA256</span><br><span class="line">TLS_AES_128_GCM_SHA256</span><br><span class="line">TLS_AES_128_CCM_8_SHA256</span><br><span class="line">TLS_AES_128_CCM_SHA256</span><br></pre></td></tr></table></figure>

<p>TLS 1.3 在之前版本的基础上删除了那些不安全的加密算法，这些加密算法包括：</p>
<ul>
<li>RSA 密钥传输 —— 不支持前向安全性</li>
<li>CBC 模式密码 —— 易受 BEAST 和 Lucky 13 攻击</li>
<li>RC4 流密码 —— 在 HTTPS 中使用并不安全</li>
<li>SHA-1 哈希函数 —— 建议以 SHA-2 取而代之</li>
<li>任意 Diffie-Hellman 组—— CVE-2016-0701 漏洞</li>
<li>输出密码 —— 易受 FREAK 和 LogJam 攻击</li>
</ul>
<p>TLS 1.3 只支持<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86">AEAD认证模式</a> 同时完成加密和完整性校验，不再允许对加密报文进行压缩、不再允许双方发起重协商，密钥的改变不再需要发送change_cipher_spec报文给对方。对称加密算法只有AES，Chacha20，摘要算法只有 SHA，密钥交换算法只有ECDHE。</p>
<p><img src="https://pic2.zhimg.com/v2-91669b8728eb5b0fa2d88730425f9391_1440w.jpg" alt="img"></p>
<h4 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0-RTT"></a>0-RTT</h4><p><img src="https://pic4.zhimg.com/v2-083c00146d71e75adbcab401e57c90e1_1440w.jpg" alt="img"></p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/59539201f006d7dc0a06333617e5ea85.png" alt="图片"></p>
<h2 id="HTTPS-优化（TLS-性能优化）"><a href="#HTTPS-优化（TLS-性能优化）" class="headerlink" title="HTTPS 优化（TLS 性能优化）"></a><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1420297">HTTPS 优化（TLS 性能优化）</a></h2><p>上文的TLS漏洞已经说明了提高安全性的措施，下列措施为提高TLS性能的措施</p>
<h3 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h3><ul>
<li>计算密集型任务，升级的是<strong>CPU</strong>而不是网卡等IO设备，如果CPU有针对 <strong>AES-NI</strong> 的特性，可以使用AES，否则可以选择chacha20</li>
</ul>
<h3 id="软件优化"><a href="#软件优化" class="headerlink" title="软件优化"></a>软件优化</h3><ul>
<li>升级Linux，升级OpenSSL</li>
</ul>
<h3 id="协议优化：节省RTT"><a href="#协议优化：节省RTT" class="headerlink" title="协议优化：节省RTT"></a>协议优化：节省RTT</h3><p>（整体的握手过程还是需要的）</p>
<ul>
<li><strong>密钥交换算法</strong>：使用<code>ECDHE</code>而不是<code>RSA</code>，<code>ECDHE</code>支持前向安全，因此也支持 <code>TLS False Start</code>，发送ClientKeyExchange的同时可以开始发送<code>application data</code>节省 <code>1 RTT</code>。</li>
<li><strong>升级TLS版本</strong>：TLS 1.3 相比于 TLS 1.2 废除了不安全的加密套件，总数变少，因此不需要协商套件的过程，可以节省<code>1 RTT</code>。</li>
</ul>
<h3 id="证书优化：节省客户端验证时间"><a href="#证书优化：节省客户端验证时间" class="headerlink" title="证书优化：节省客户端验证时间"></a>证书优化：节省客户端验证时间</h3><ul>
<li><strong>证书类型</strong>：在相同的安全强度下，<code>ECDSA</code> 椭圆曲线证书相比于 <code>RSA</code> 证书的密钥长度减少很多，减少了验证证书完整性的时间。</li>
<li><strong>证书验证流程</strong>：验证证书信任链的时候，<code>OCSP</code> 相比于 <code>CRL</code> 实时性更高，不用逐行读取文件；<ul>
<li>进一步提升性能可以启用<code>OCSP Stapling</code>，服务器周期性地向 CA 获取证书状态，CA会在状态上签名防止篡改，在发出ServerHello的同时也把有效信息发给客户端。</li>
</ul>
</li>
</ul>
<h3 id="会话复用：复用会话密钥"><a href="#会话复用：复用会话密钥" class="headerlink" title="会话复用：复用会话密钥"></a>会话复用：复用会话密钥</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mrpre/article/details/77868669">TLS/SSL 协议详解 (22)会话复用_ssl会话复用-CSDN博客</a> 抓包</p>
<p><strong>以下技术都是建立在已经建立过一次连接的基础上的，可以节省第一次以后会话的RTT，是用来免去握手过程的</strong></p>
<ul>
<li><strong>Session ID</strong>：将与每个客户端的会话密钥缓存在服务器内存里，形成 id-key的键值对形式，ClientHello带上session id，节省<code>1 RTT</code>，缺点是不支持分布式和消耗服务器内存。</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/sessionid.png" alt="img"></p>
<ul>
<li><strong>Session Ticket</strong>：服务器可以将会话密钥再次用<strong>只有自己知道的密钥</strong>加密，然后附上有效期进行签发，以session ticket的形式交给客户端进行缓存，ClientHello带上ticket，服务器验证有效期（类似JWT）也能节省 <code>1 RTT</code> ，分布式之间需要共享这个密钥。</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/ticket.png" alt="img"></p>
<ul>
<li><strong>Pre-shared Key</strong>：TLS 1.3 引入的新特性，将 Session Ticket 和 早期的 application data 一并发送给服务器 直接变成<code>0-RTT</code> ，因为不用协商套件。</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8.assets/image-20241130172210036.png" alt="image-20241130172210036"></p>
<p>会话复用会影响前向安全性，还可能会受到重放攻击，解决方案：</p>
<ul>
<li>只对幂等请求（GET）开放0-RTT；</li>
<li>对session ticket添加有效期；</li>
</ul>
<h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Secure_Shell">SSH</a> （Secure Shell）</strong> 基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13P4y1o76u">SSH 握手详解 - bilibili 技术蛋老师</a> </p>
<p>SSH 的经典用途是登录到远程电脑中执行命令。除此之外，SSH 也支持隧道协议、端口映射和 X11 连接（允许用户在本地运行远程服务器上的图形应用程序）。借助 SFTP（SSH File Transfer Protocol） 或 SCP（Secure Copy Protocol） 协议，SSH 还可以安全传输文件。</p>
<p>SSH 使用客户端-服务器模型，默认端口是 22。SSH 是一个守护进程，负责实时监听客户端请求，并进行处理。大多数现代操作系统都提供了 SSH。</p>
<p>如下图所示，SSH Client（SSH 客户端）和 SSH Server（SSH 服务器）通过公钥交换生成共享的对称加密密钥，用于后续的加密通信。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/ssh-client-server.png" alt="SSH:安全的网络传输协议"></p>
<p>SSH以<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">非对称加密</a>实现<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81">身份验证</a>：</p>
<p>身份验证有多种途径，例如其中一种方法是使用自动生成的公钥-私钥对来简单地加密网络连接，随后使用密码认证进行登录；另一种方法是人工生成一对公钥和私钥，通过生成的密钥进行认证，这样就可以在不输入密码的情况下登录。任何人都可以自行生成密钥。公钥需要放在待访问的电脑之中，而对应的私钥需要由用户自行保管。认证过程基于生成出来的私钥，但整个认证过程中私钥本身不会传输到网络中。</p>
<h1 id="IPsec"><a href="#IPsec" class="headerlink" title="IPsec"></a>IPsec</h1><img src="https://download.huawei.com/mdl/image/download?uuid=17c579f40e0b440e98a35544fcbbd3dc" alt="IPsec加密验证过程" style="zoom:150%;" />


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/01/10/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/10/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82/" class="post-title-link" itemprop="url">传输层</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-10 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-10T00:00:00+08:00">2025-01-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-03 20:59:50" itemprop="dateModified" datetime="2025-05-03T20:59:50+08:00">2025-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>LAB：<a target="_blank" rel="noopener" href="https://media.pearsoncmg.com/ph/esm/ecs_kurose_compnetwork_8/cw/">Student Resources | Kurose/Ross, Computer Networking: a Top-Down Approach, 8/e</a> </p>
<h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><h2 id="port"><a href="#port" class="headerlink" title="port"></a>port</h2><p>0-65536 TCP Header中为16位无符号整数</p>
<p>IP地址能够标识主机，但是通信是由主机中的应用进程发起和接收的，必须让应用进程拥有一个标识，而本地进程ID（PID）在各个OS之间并不统一（因为要写入TCP头部，而各个OS发送的TCPHeader必须统一），如果是给特定的应用进程分配一个特定的ID，显然也不行，因为通信双方并不必须知道对方的真正身份，因此，最后的结果就是在传输层和应用层的界面上开一些特定的“门”，进程需要的时候就分配给他，这就是软件端口（port）的由来。</p>
<h3 id="服务器端口号"><a href="#服务器端口号" class="headerlink" title="服务器端口号"></a>服务器端口号</h3><ul>
<li>1-1023: 标准规定的应用强制占用。</li>
</ul>
<table>
<thead>
<tr>
<th>HTTP</th>
<th>HTTPS</th>
<th>DNS</th>
<th>RIP</th>
<th>BGP</th>
<th>Telnet</th>
<th>FTP</th>
<th>SMTP</th>
<th>SSH</th>
<th>RMI</th>
</tr>
</thead>
<tbody><tr>
<td>80</td>
<td>443</td>
<td>53</td>
<td>520</td>
<td>179</td>
<td>23</td>
<td>21</td>
<td>25</td>
<td>22</td>
<td>111</td>
</tr>
</tbody></table>
<ul>
<li>1024-49151: 登记端口。</li>
</ul>
<h3 id="客户端端口"><a href="#客户端端口" class="headerlink" title="客户端端口"></a>客户端端口</h3><ul>
<li><p>49152-65535(16384个): 客户端发起connect动态分配，属于临时端口号，断开连接或者通信结束就会收回。</p>
</li>
<li><p>一些系统中可能会出现超过65536的情况，但是由于TCP Header的限制，必须要对端口号 % 65536</p>
</li>
</ul>
<h4 id="如何提高服务器并发能力"><a href="#如何提高服务器并发能力" class="headerlink" title="如何提高服务器并发能力"></a>如何提高服务器并发能力</h4><p>一般来讲，通过增加服务器内存、修改最大FD个数等，可以做到单台服务器支持10万+的TCP并发。当然，在真实的商用场景下，单台服务器都会编入<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=231771466&content_type=Article&match_order=1&q=%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4&zhida_source=entity">分布式集群</a>，通过负载均衡算法动态的调度不同用户的请求给最空闲的服务器，如果服务器平均内存使用超过80%的警戒线，那么就会及时采用限流或者扩展集群的方式来保证服务，绝对不会出现服务器的内存被耗尽的情况，那样就算事故了。</p>
<h2 id="TCP-UDP绑定相同端口"><a href="#TCP-UDP绑定相同端口" class="headerlink" title="TCP UDP绑定相同端口"></a>TCP UDP绑定相同端口</h2><p>IP数据报中的协议字段可以区分TCP还是UDP，因此靠这个字段就能将IP数据报准确交给对应的协议软件实现，然后软件根据抽象的端口找到应用进程，两个协议的端口并不是一个域。</p>
<h2 id="多个TCP-服务进程绑定相同端口"><a href="#多个TCP-服务进程绑定相同端口" class="headerlink" title="多个TCP 服务进程绑定相同端口"></a>多个TCP 服务进程绑定相同端口</h2><p>IP不同，端口相同，也是可以的。</p>
<p>0.0.0.0:8888 表示监听所有IP地址的8888端口</p>
<h2 id="客户端端口的复用"><a href="#客户端端口的复用" class="headerlink" title="客户端端口的复用"></a>客户端端口的复用</h2><p>可以，因为TCP连接有4个元素才能唯一确定，只要有一个不一样就是不同的TCP连接</p>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/quic.html">4.17 如何基于 UDP 协议实现可靠传输？ | 小林coding</a> </p>
<p>User Datagram Protocol 用户数据报协议</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><strong>无连接</strong>：传输数据之前不需要建立起连接，直接发送即可，可以是一对一，多对一，一对多，多对多。</li>
<li><strong>不可靠</strong>：可能出现差错，丢失，重复，不能保证按序到达，也就是<strong>尽最大努力交付</strong>，这也使得首部开销比较小。</li>
<li><strong>面向数据报</strong>：无论应用层交给 UDP 多长的报文，UDP 都照样发送，即一次发送一个报文。对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。而接收方在接收数据报的时候，也不会像面对 TCP 无穷无尽的二进制流那样不清楚啥时候能结束。</li>
<li>没有拥塞控制</li>
</ul>
<p>优点还有可扩展性强：TCP实现固化在操作系统中，有时性能可能不能满足部分需求，开发者可以利用UDP的特性，在应用层实现可靠传输，比如QUIC协议</p>
<h2 id="UDP-Datagram"><a href="#UDP-Datagram" class="headerlink" title="UDP Datagram"></a>UDP Datagram</h2><p>总长度8B，源端口和目的端口各占2B，然后是UDP的PDU长度（2B），最后是检验和（2B）。</p>
<ul>
<li><strong>udp长度</strong>：max: 65535B min: 8B 整个UDP数据报的长度</li>
<li><strong>检验和</strong>：添加伪首部[<strong>源IP</strong>(4B), <strong>目的IP</strong>(4B), <strong>全0</strong>(1B), <strong>17</strong>[1B,表示UDP协议类型], <strong>UDP长度</strong>(2B)]，计算检验和先将检验和位置0，然后将添加了伪首部的<strong>整个UDP数据报</strong>划分成若干个16位字，不够补零，最后将这些字按位相加，高位进位溢出进到低位，最后取反码放到检验和。IP packet只检验首部，而UDP datagram全部都检验。</li>
</ul>
<table>
<thead>
<tr>
<th>源端口</th>
<th>目的端口</th>
<th>UDP数据报长度</th>
<th>检验和</th>
</tr>
</thead>
<tbody><tr>
<td>2B</td>
<td>2B</td>
<td>2B</td>
<td>2B</td>
</tr>
</tbody></table>
<p>如果UDP发现检验和不正确，就直接丢弃数据报</p>
<p>如果UDP发现目的端口不准确，就丢弃数据报，随后由ICMP发送一条“终点不可达”的差错报告报文（traceroute）</p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>Transmission Control Protocol，传输控制协议</p>
<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul>
<li><strong>面向连接</strong>：传输数据之前必须建立起双方的连接，传输完双方应该断开连接，只能是点对点通信。</li>
<li><strong>可靠</strong>：通过TCP传送的数据，无差错，不丢失，不重复，按序到达，这也使得首部开销比较大。</li>
<li><strong>全双工</strong>：双方可以同时收发信息，设有接收和发送缓冲区</li>
<li><strong>面向字节流</strong>：将应用层交下来的数据不是以<strong>消息报为单位</strong>向目的主机发送，而是看作无结构的字节流，TCP不懂字节流的含义是什么，这些数据可能被<strong>切割和组装</strong>成各种数据包，但是发送者发出的字节流和接受者收到的字节流必须一样，并且应用能够正确识别这些无意义字节流的含义，将其还原为有意义的应用层数据。接收端收到这些数据包后没有正确还原原来的消息，就会有“粘包”的现象。</li>
</ul>
<h2 id="可靠传输协议：ARQ"><a href="#可靠传输协议：ARQ" class="headerlink" title="可靠传输协议：ARQ"></a>可靠传输协议：ARQ</h2><p>ARQ（Automatic Repeat reQuest，自动重传请求）是计算机网络中用于确保数据可靠传输的一种关键技术。它主要通过确认（ACK）和超时重传两种机制，在不可靠的网络服务上实现可靠的数据传输。当发送方在一定时间内未收到确认帧时，它会自动重发数据包，直到收到确认为止。ARQ协议分为<strong>停止等待ARQ</strong>和<strong>连续ARQ</strong>两种类型，每种都有其特定的应用场景和优缺点。</p>
<ol>
<li>ARQ是一种可以在不可靠的数据通道上可靠地传输数据的方案，所以其实链路层和传输层都用了ARQ，并不专属某一层。</li>
<li>并不是一条连接只要有一层用了ARQ，它的上层的通信就是可靠的。因为ARQ只保证使用它的点到点是可靠的，比如数据链路层只保证你和你的路由器通信可靠，你的路由器到小区的路由器通信也可靠， 但是路由器本身会故障，会拥塞丢包，也就是点本身会产生问题。</li>
<li>所以需要在传输层或者应用层再加一层ARQ保障整条数据通道的可靠性。比如你自己写程序要在应用层通信，但传输层不用tcp想用udp，也可以在你程序里用ARQ协来实现可靠性。</li>
<li><strong>注意：</strong> 在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发。<ul>
<li>分组和确认分组都必须进行编号。</li>
<li>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。</li>
</ul>
</li>
</ol>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82.assets/image-20241203213134835.png" alt="image-20241203213134835"></p>
<h3 id="停止-等待ARQ的逐步优化"><a href="#停止-等待ARQ的逐步优化" class="headerlink" title="停止-等待ARQ的逐步优化"></a>停止-等待ARQ的逐步优化</h3><h4 id="v2-x"><a href="#v2-x" class="headerlink" title="v2.x"></a>v2.x</h4><h5 id="v2-0：给数据包加上校验和，防止数据包出现比特差错"><a href="#v2-0：给数据包加上校验和，防止数据包出现比特差错" class="headerlink" title="v2.0：给数据包加上校验和，防止数据包出现比特差错"></a>v2.0：给数据包加上校验和，防止数据包出现比特差错</h5><ul>
<li>2.0的第一个问题：<strong>接收方的ACK可能有比特差错</strong></li>
<li>2.0的第二个问题：<strong>发送方未正确接收ACK直接重发，接收方不会区分是不是重传的包，导致交给上层重复的数据。</strong></li>
</ul>
<h5 id="v2-1如何解决v2-0问题？"><a href="#v2-1如何解决v2-0问题？" class="headerlink" title="v2.1如何解决v2.0问题？"></a>v2.1如何解决v2.0问题？</h5><ol>
<li><strong>给ACK加一个校验和。</strong></li>
</ol>
<ul>
<li>发送方收到ACK，说明是接收方正确收到了，发送下一个数据包。</li>
<li>发送方收到NAK或者校验和出错的包，选择重发这个数据包。</li>
</ul>
<p>此时还没有解决第二个问题，接收方正常接收发出ACK，如果发送方收到一个校验和错误的响应（本来应该是ACK）然后重传，但是接收方会把重传的包当成全新的，这样就导致了重复的问题。</p>
<ol start="2">
<li><strong>在不丢包的情况下，给数据包附上一bit标识符，让接收方区分是否为重发的数据包。</strong></li>
</ol>
<ul>
<li>发送方发的时候就注明是0号数据包，接收方鉴别无误就可以转换到准备接收下一个数据包的状态并发送ACK，如果发送方收到了ACK，皆大欢喜继续发下一个数据包</li>
<li>如果发送方并未正确收到ACK，则需要重发此包，而接收方早就转换到准备接收新数据包的状态了，再次接收到旧数据包直接选择丢弃，但也要记得再发一下ACK，提醒发送者可以发送新数据包了。</li>
</ul>
<h5 id="v2-2：改善接收方的响应结构"><a href="#v2-2：改善接收方的响应结构" class="headerlink" title="v2.2：改善接收方的响应结构"></a>v2.2：改善接收方的响应结构</h5><p><strong>去除NAK，在ACK内部用一个比特位表示ACK或者NAK</strong></p>
<ul>
<li>接收方准备接收0号，如果出错，则发送ACK<del>1</del>，发送方仍处于等待ACK<del>0</del>的状态，收到的只要不是ACK<del>0</del>，就会重发。</li>
<li>接收方准备接收0号，如果正确，则发送ACK<del>0</del>，准备接收新数据包，而发送方如果没有正确收到这个ACK<del>0</del>，会再次重发，这时候接收方会再次发送ACK<del>0</del>让发送方知晓 上个数据包已经被正确接收，提醒发送者可以开始新数据包，然后把这个重复的丢弃。</li>
</ul>
<h5 id="v2-x的问题"><a href="#v2-x的问题" class="headerlink" title="v2.x的问题"></a>v2.x的问题</h5><p>如果<strong>数据包丢了</strong>，接收方收不到自然也谈不上响应，再如果，<strong>响应丢了</strong>，<strong>响应迟到了</strong>，发送者就会陷入空等状态</p>
<h4 id="v3-0：比特交换协议"><a href="#v3-0：比特交换协议" class="headerlink" title="v3.0：比特交换协议"></a>v3.0：比特交换协议</h4><p>可靠的传输协议，也叫比特交换协议，在在v2可以解决丢包和迟到的问题。</p>
<ol>
<li>从<strong>发送方角度</strong>考虑，<strong>把超时作为重传的唯一根据</strong>。</li>
</ol>
<ul>
<li><p>如果在准备接收ACK<del>1</del>的情况下收到<strong>错误响应</strong>（ACK<del>0</del>或者校验和错误），则什么也不做，等待超时重发</p>
</li>
<li><p>发出分组即启动timer，一定时间内没有收到<strong>正确的响应</strong>到了timeout，则重发并重启timer；</p>
</li>
<li><p><strong>收到正确的响应</strong>就停止timer，转换到准备发下一个分组的状态，如果有这个如果这时有响应发来，肯定是迟到的响应，不予理会。</p>
</li>
</ul>
<ol start="2">
<li>因为有传播时延和排队处理时延，所以可能会出现过早超时然后重发的情况</li>
</ol>
<ul>
<li><p>接受者的角度肯定是收到1，ACK<del>1</del>然后准备接收0，这时候再次接到1，此时回答一个ACK<del>1</del>，然后丢弃重复的1。</p>
</li>
<li><p>发送者如果在等待上方传下来数据的情况下收到了响应，说明这肯定是一个迟到的响应，不予理会。</p>
</li>
</ul>
<p>v3总结：</p>
<p>发一个数据包，等对应的ACK，超时了就重发，必须且只能收到一次对应的ACK，收到就转变状态不等了，来再多也没用。</p>
<h5 id="v3-0的问题"><a href="#v3-0的问题" class="headerlink" title="v3.0的问题"></a>v3.0的问题</h5><ul>
<li>时间利用上不如v2，但是基于时间的重传和基于ACK比特位的重传是冲突的，因此问题不算大。</li>
<li>最根本的还是停止等待对时间资源的浪费。</li>
</ul>
<h3 id="Go-Back-N（回退N步）：流水线式的发送与接收"><a href="#Go-Back-N（回退N步）：流水线式的发送与接收" class="headerlink" title="Go Back N（回退N步）：流水线式的发送与接收"></a>Go Back N（回退N步）：流水线式的发送与接收</h3><p>Go Back N：发送窗口，累计确认，超时重传。</p>
<p><strong>发送方</strong>：</p>
<ol>
<li>维护一个发送窗口(N)，用来限制一次最多发送的包数目，基于超时重传</li>
</ol>
<ul>
<li>在窗口以前的默认已经成功发送了(0-base)，窗口内部有的已经发送处于等待响应的状态(base-nextseqnum)，有的还没有发送过(nextseqnum+1 - base+N-1)。</li>
<li>应用层传下来的data，如果分配到的序号超过窗口，拒绝（或者缓存一下），在窗口内，填到nextseqnum++处。</li>
<li>在发送窗口中的包，发送base时start timer，一直把从base到nextseqnum的包都发出去，如果timeout就把这些包全部重发一遍。</li>
</ul>
<ol start="2">
<li>接收ACK</li>
</ol>
<ul>
<li>根据ACK中的编号滑动窗口边缘(base=getacknum+1) 这里的ACK包含的序号是接收方封装的，接收方的逻辑可以保证此序号之前的全部正确传输。</li>
<li>如果滑动窗口之后，base = nextseqnum 说明窗口内已经没有要发送的分组，stop timer，如果还有，那就restart timer，继续等待。</li>
</ul>
<p><strong>接收方</strong>：</p>
<ol>
<li><strong>累计确认</strong>：只需要维护一个序号expectedseqnum，顾名思义，接收方必须按序ACK，按序递交给上层。</li>
</ol>
<ul>
<li>收到的包确实是自己想要的，于是就发一个ACK<del>expectedseqnum</del>，随后递交给应用层，然后ex…num自增，表明自己要接收下一个包<ul>
<li>假定ACK响应中的序号N，对于接收方来说序号&lt;=N的全部正确递交给上层了。</li>
</ul>
</li>
<li>没有收到自己想要的包，就丢弃，并把上次制作好的ACK重新发送，提醒发送方该滑动窗口了。（<strong>可能是因为发送方没有正确识别ACK造成的冗余分组</strong>）</li>
</ul>
<p>意味着即使之前已经接受过正确的分组也要丢弃，expectedseqnum之后的情况是未知的，因此只能回退重传。</p>
<p>单个分组的错传，会引起之后的大量分组重传。</p>
<h3 id="Selective-Repeat（选择重传）：无需按序ACK，不累计确认"><a href="#Selective-Repeat（选择重传）：无需按序ACK，不累计确认" class="headerlink" title="Selective Repeat（选择重传）：无需按序ACK，不累计确认"></a>Selective Repeat（选择重传）：无需按序ACK，不累计确认</h3><p>Selective Repeat 特点：接收窗口，乱序ACK，按序交付上层</p>
<p>接收方不丢弃正确的乱序分组，而是先进行ACK然后缓存，并不直接交给上层。</p>
<ul>
<li>对于发送方来说，对方对base序号的ACK是发送窗口滑动的唯一标准。</li>
<li>对于接收方来说，成功按序递交给上层是接收窗口滑动的唯一标准。</li>
</ul>
<p><strong>发送方</strong>：</p>
<ol>
<li>维护发送窗口：</li>
</ol>
<ul>
<li>对于应用层传下来的数据，仍然不变。</li>
<li>在发送窗口的包，为每一个包都设置一个timer，单独计时。</li>
</ul>
<ol start="2">
<li>接收ACK：</li>
</ol>
<ul>
<li>ACK对应编号标记为已ACK，</li>
<li>如果ACKnum = send_base，则说明可以移动了，移动到第一个未ACK的序号处<ul>
<li>例子：窗口变成OOOOXXXXOXX，则滑动后的窗口为XXXXOXXXXXX</li>
</ul>
</li>
</ul>
<p><strong>接收方</strong>：可以不按序ACK，但是递交给上层需要按序，维护一个接收窗口</p>
<ul>
<li>序号在窗口里面的，没问题的就发个ACK<ul>
<li>失序的（在窗口中间的）先缓存好，等于rcv_base则准备交付给应用层，将从rcv_base开始所有缓存好的包 连续、按序交给应用层</li>
</ul>
</li>
</ul>
<p><strong>冗余分组</strong>：</p>
<p>对于接收者来说，ACKnum=rcv_base就可以开始滑动了，表明rcv_base之前的数据肯定已经正确交付给应用层了，但是并不能保证这个ACK就一定能被正确解析，因此发送窗口可能会迟迟不滑动导致一直重传（冗余分组）</p>
<ul>
<li>如果序号是[base-N 到 base-1]的，即使之前ACK过了，也还是会回复ACK，不断尝试提醒发送方滑动发送窗口。</li>
</ul>
<h4 id="窗口注意事项"><a href="#窗口注意事项" class="headerlink" title="窗口注意事项"></a>窗口注意事项</h4><ul>
<li><strong>接收窗口与发送窗口并不总是完全的同步，可能会错开一部分，不过接收窗口的base也不会完全超过发送窗口，毕竟如果还没发送，也就谈不上接收过了。</strong></li>
</ul>
<ul>
<li><p><strong>序号范围与窗口大小</strong>序号是循环利用的，如果窗口太大，序号范围太小，就有可能发生重传的分组被当成是新分组的情况</p>
<ul>
<li><p>序号是0~3 窗口大小为3，0 1 2 ACK过了传给上层，接收窗口滑动变成 3 0 1</p>
</li>
<li><p>ACK没有被正确接收，因此0,1,2重传，此时0和1就被当成是<strong>全新</strong>的数据了。</p>
</li>
</ul>
</li>
</ul>
<p><strong>窗口大小与序号的关系计算</strong></p>
<p>假设序号0-N-1，窗口大小为M，M &lt;= N 发送窗口为序号0到M-1</p>
<ul>
<li>对于SR来说，最坏的情况，接收窗口为序号M到M+M-1(一共M个)，而2M-1不能超过序号N-1，否则就会有上面的问题，因此$M\le \frac{N}{2}$ </li>
<li>对于GBN来说，窗口只有一个宽度，因此$M\le N-1$ </li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82.assets/image-20241203204645293.png" alt="image-20241203204645293"></p>
<h3 id="可靠传输协议的关键"><a href="#可靠传输协议的关键" class="headerlink" title="可靠传输协议的关键"></a>可靠传输协议的关键</h3><ul>
<li><p>确认机制：没差错要ACK</p>
<ul>
<li>保证没有比特差错：分组和ACK都要有校验位。</li>
</ul>
</li>
<li><p>对于超时（未得到正确的ACK）重传</p>
<ul>
<li>发送时使用timer进行计时，超时则重传，</li>
<li>可能带来的冗余分组问题，要让接收方能分辨出冗余分组<ul>
<li>接收方如何对待冗余分组：发送者给分组添加序号，接收方根据序号分辨这是一个重传的还是新的分组。<ul>
<li>并且发出的ACK也要携带序号，提醒哪个分组被正确收到了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>窗口、流水线发送：提高信道利用率</p>
<ul>
<li>窗口大小：窗口之间不同步（无法避免）但是窗口太大，导致重传分组被当做新的分组。</li>
</ul>
</li>
</ul>
<p>一个默认的假设：除了丢包，包并不会被重新排序。</p>
<p>而现实是传输层下方是不可靠信道，并不保证数据准确无误并且一定按序到达，因此应当将互联网看成是一个不定时发送的缓存，由于序号复用，这样可能会有相同序列号的分组出现在信道中，产生冲突。假定一个分组在网络中有TTL，超过TTL，序号就一定能够被再次使用。</p>
<h3 id="GBN-vs-SR"><a href="#GBN-vs-SR" class="headerlink" title="GBN vs SR"></a>GBN vs SR</h3><table>
<thead>
<tr>
<th>特性</th>
<th>GBN</th>
<th>SR</th>
</tr>
</thead>
<tbody><tr>
<td>重传策略</td>
<td>从丢失的分组开始，重新发送整个窗口</td>
<td>仅重传出错或超时的分组</td>
</tr>
<tr>
<td>接收端处理</td>
<td>按顺序接收分组，否则丢弃</td>
<td>接收乱序分组并缓存</td>
</tr>
<tr>
<td>计时器数量</td>
<td>1 个计时器</td>
<td>N 个计时器（每个分组一个计时器）</td>
</tr>
<tr>
<td>适用场景</td>
<td>高丢包率但传输顺序严格的环境</td>
<td>低丢包率，允许乱序接收的环境</td>
</tr>
<tr>
<td>发送窗口</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>接收窗口</td>
<td>1</td>
<td>N</td>
</tr>
</tbody></table>
<h4 id="Go-Back-N-GBN"><a href="#Go-Back-N-GBN" class="headerlink" title="Go-Back-N (GBN)"></a>Go-Back-N (GBN)</h4><ul>
<li><strong>特点</strong>：<ol>
<li>发送端最多可以连续发送 <strong>N 个未确认的分组</strong>。</li>
<li>如果在超时时间内没有收到某个分组的确认，应从该分组开始 <strong>重新发送其后所有分组</strong>。</li>
</ol>
</li>
<li><strong>计时器需求</strong>：<br>GBN 协议只需要一个 **==全局计时器==**，用于跟踪 <strong>最早发送但尚未确认的分组（窗口起点）</strong>。<ul>
<li>一旦计时器超时，直接 <strong>回退到该分组并重传整个窗口</strong>，不需要为每个分组单独计时。</li>
<li>原因是 GBN 要求分组必须 <strong>按顺序到达</strong>，只要有一个分组超时，所有后续分组都需要重发。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Selective-Repeat-SR"><a href="#Selective-Repeat-SR" class="headerlink" title="Selective Repeat (SR)"></a>Selective Repeat (SR)</h4><ul>
<li><strong>特点</strong>：<ol>
<li>支持接收端 <strong>乱序接收</strong>，允许正确接收的分组先缓存。</li>
<li>发送端只重传超时或出错的分组，而不是整个窗口。</li>
</ol>
</li>
<li><strong>计时器需求</strong>：<br>由于 SR 可以 <strong>选择性重传特定分组</strong>，每个分组都需要一个 **==独立的计时器==**。<ul>
<li>如果某个分组超时，只重传该分组，而不影响其他分组。</li>
<li>因此，发送端必须为 <strong>窗口内的每个分组维护单独的计时器</strong>，以便精确控制每个分组的超时和重传行为。</li>
</ul>
</li>
</ul>
<h2 id="基于字节流"><a href="#基于字节流" class="headerlink" title="基于字节流"></a>基于字节流</h2><h3 id="数据包分片"><a href="#数据包分片" class="headerlink" title="数据包分片"></a>数据包分片</h3><ul>
<li>以太网帧总长度至少64B，数据负载不能超过MTU，首部+FCS 18 因此要求 IP数据报长度在 <code>46~1500</code>Byte</li>
</ul>
<ul>
<li><p>IP首部至少20B，因此传输层数据包为<code>26~1480</code> Byte</p>
</li>
<li><p>TCP首部20B TCP报文段的数据部分为<code>6~1460</code>Byte</p>
</li>
<li><p>UDP首部8B UDP数据报的数据部分为<code>18~1472</code>Byte</p>
</li>
<li><p>这些都是为了迎合以太网帧的帧大小限制。当超过了这个限制，就要对IP数据包进行分片。</p>
</li>
</ul>
<h3 id="UDP：无法在传输层分片"><a href="#UDP：无法在传输层分片" class="headerlink" title="UDP：无法在传输层分片"></a>UDP：无法在传输层分片</h3><p>超过了数据部分的大小只能通过IP进行分片，分多个IP数据报发送。</p>
<p>它并没有协商的能力，所以它只能直接把用户发送的数据，传给网络层（<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=105481550&content_type=Article&match_order=1&q=IP%E5%B1%82&zhida_source=entity">IP层</a>），由网络层来进行分片。</p>
<p>对 网络层（IP层）来说：它并不知道上层传过来的数据，到底是 TCP 还是 UDP，它并不关心也没有能力区分。</p>
<p>如果发现数据过大，那么 IP 层会自动对数据进行切割，分片。用 UDP 协议发送，那么如果网络发生了波动，丢失了某个 IP 包分片， 对于 UDP 而言， 它没有反馈丢失了哪个分片给发送方的能力，这就意味着：50k 的数据全都丢失了，如果需要重传，就得再次完整的传递这 50k 的数据。</p>
<blockquote>
<p>UDP 协议头有 2 byte 表示长度的字段。所以实际 UDP 数据包的长度不能超过65507字节（65,535 − 8字节UDP报头 − 20字节IP头部）</p>
<p>TCP 是<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=105481550&content_type=Article&match_order=1&q=%E6%B5%81%E6%95%B0%E6%8D%AE&zhida_source=entity">流数据</a>，没有该限制。</p>
</blockquote>
<p>而 TCP 只会重传这一个丢失的分片包。</p>
<p>所以如果一个应用采用 UDP 来通讯，一般都会特意控制下单个包体的大小，从而提高传输效率。</p>
<h3 id="TCP：可以在传输层协商自行分片"><a href="#TCP：可以在传输层协商自行分片" class="headerlink" title="TCP：可以在传输层协商自行分片"></a>TCP：可以在传输层协商自行分片</h3><h4 id="最大分段大小（Maxitum-Segment-Size-MSS）"><a href="#最大分段大小（Maxitum-Segment-Size-MSS）" class="headerlink" title="最大分段大小（Maxitum Segment Size, MSS）"></a>最大分段大小（Maxitum Segment Size, MSS）</h4><p>这里首先要说下：MSS（Maxitum Segment Size）最大分段大小，它是 TCP 协议里面的一个概念。</p>
<p>MSS 要保证一个TCP报文段，加上TCPIP首部长度以后，适合单个链路层帧。</p>
<p>TCP 在建立连接的时候，会协商双方的MSS值，通常这个 MSS 会控制在 MTU 以内：最大 IP 包大小减去 IP 和 TCP 协议头的大小。（其最终目的：<strong>就是尽量避免 IP 分片</strong>）1500-20-20 = 1460 </p>
<p>这样 TCP 就可以在自己这一层，把用户发送的数据，预先分成多个大小限制在 MTU 里的 TCP 包。每个 TCP 的分片包，都完整了包含了 TCP 头信息，方便在接收方重组。</p>
<blockquote>
<p>如果某些情况导致：已经分好的 TCP 分片，还是大于了 MTU，那就在 IP 层中，再执行一次分片。<br>这个时候如果数据丢了，那也只需要重传这一个 TCP 的分片，而不是整个原始的 50k 数据。</p>
</blockquote>
<p>而 IP（<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc791#section-3.1">RFC 791</a>）中规定所有主机或路由器必须能够接受576字节以内的数据报，576字节以上不保证能接受，有一定可能会分片。<a target="_blank" rel="noopener" href="https://blog.csdn.net/BuquTianya/article/details/88136381">RFC791（IP协议）——协议格式_rfc 791-CSDN博客</a> </p>
<p>严格讲，这并非是协商出来一个统一的MSS值，TCP允许连接两端使用各自不同的MSS值。例如，这会发生在参与TCP连接的一台设备使用非常少的内存处理到来的TCP分组。</p>
<h4 id="基于字节流的解决方案"><a href="#基于字节流的解决方案" class="headerlink" title="基于字节流的解决方案"></a>基于字节流的解决方案</h4><p>应用层传到 TCP 协议的数据，不是以<strong>数据报为单位</strong>向目的主机发送，而是以<strong>字节流</strong>的方式发送到下游，这些数据可能被<strong>切割和组装</strong>成各种数据包，接收端（应用层）收到这些数据包后没有正确还原原来的消息，因此出现粘包现象。</p>
<p>正因为<strong>基于数据报</strong>和<strong>基于字节流</strong>的差异，<strong>TCP 发送端发 10 次字节流数据，而这时候接收端可以分 100 次去取数据，每次取数据的长度可以根据处理能力作调整；但 UDP 发送端发了 10 次数据报，那接收端就要在 10 次收完，且发了多少，就取多少，确保每次都是一个完整的数据报。</strong></p>
<p>根本原因是应用层不知道消息的边界在哪里，不知道字节流的开始和结束位置，错误地划分了数据包序列中间的边界</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E4%BC%A0%E8%BE%93%E5%B1%82.assets/image-20241127185012804.png" alt="image-20241127185012804"></p>
<ul>
<li>定长：FTP</li>
</ul>
<ul>
<li><p>分隔符：SMTP HTTP</p>
<p>可以通过特殊的标志作为头尾，比如当收到了<code>0xfffffe</code>或者回车符，则认为收到了新消息的头，此时继续取数据，直到收到下一个头标志<code>0xfffffe</code>或者尾部标记，才认为是一个完整消息。类似的像 HTTP 协议里当使用 <strong>chunked 编码</strong> 传输时，使用若干个 chunk 组成消息，最后由一个标明长度为 0 的 chunk 结束。</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82.assets/image-20241127215347024.png" alt="image-20241127215347024"></p>
</li>
<li><p>TLV：HTTP Content-Length  WebSocket Protobuf Thrift</p>
<p>这个一般配合上面的特殊标志一起使用，在收到头标志时，里面还可以带上消息长度，以此表明在这之后多少 byte 都是属于这个消息的。如果在这之后正好有符合长度的 byte，则取走，作为一个完整消息给应用层使用。在实际场景中，HTTP 中的<code>Content-Length</code>就起了类似的作用，当接收端收到的消息长度小于 Content-Length 时，说明还有些消息没收到。那接收端会一直等，直到拿够了消息或超时，关于这一点<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247484204&idx=1&sn=0e83aabb2a48570b5bec563a777f4d26&scene=21#wechat_redirect">上一篇文章</a>里有更详细的说明</p>
<p>基于<a target="_blank" rel="noopener" href="https://search.bilibili.com/all?from_source=webcommentline_search&keyword=TLV&seid=7175035739223351950">TLV</a>的协议，接收段不断的检查Tag，如果收到tag就会去取length，这里面有一个点就是tag和length是定长的，比如tag是四个字符，length占4个字节。取到length以后就读取length个字节的<a target="_blank" rel="noopener" href="https://search.bilibili.com/all?from_source=webcommentline_search&keyword=value&seid=7175035739223351950">value</a>。理论上value后面接着的就是下一个tag</p>
</li>
</ul>
<p>Netty <strong>解决方案</strong></p>
<ul>
<li><p>定长解码器 <code>FixedLengthFrameDecoder</code> </p>
</li>
<li><p>分割字符解码器 <code>DelimeterBasedFrameDecoder</code></p>
</li>
<li><p>长度字段解码器 <code>LengthFieldBasedFrameDecoder</code></p>
</li>
</ul>
<h2 id="面向连接的-TCP-协议实现"><a href="#面向连接的-TCP-协议实现" class="headerlink" title="面向连接的 TCP 协议实现"></a>面向连接的 TCP 协议实现</h2><p>TCP连接可以由一个四元组（源IP, 源PORT, 目的IP, 目的PORT）唯一确定服务器的目的IP, 目的PORT一般是不会变化的，因此理论上TCP最大支持的连接数是 $2^{32} \times 2^{16} = 2^{48}$个，而TCP在linux系统中的实现用的是一个叫socket的编程接口实现的，socket本身就是一个文件，一个TCP连接就创建一个SOCKET FD因此还应该考虑服务器最大的内存大小。</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82.assets/31b78572f43299995ba9b1b2988928c5.jpg" alt="31b78572f43299995ba9b1b2988928c5"></p>
<h3 id="TCP-Segment"><a href="#TCP-Segment" class="headerlink" title="TCP Segment"></a>TCP Segment</h3><p><img src="C:/Users/Lenovo/Pictures/markdownfile/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82.assets/image-20241204212832687.png" alt="image-20241204212832687"></p>
<p>PSH = 1，数据不会缓存，立即交给上层（PUSH）</p>
<p>URG = 1，紧急数据指针指定了</p>
<h3 id="可靠传输（reliable-transmission）"><a href="#可靠传输（reliable-transmission）" class="headerlink" title="可靠传输（reliable transmission）"></a>可靠传输（reliable transmission）</h3><p>一个TCP报文段中的数据部分长度不能超过MSS，可以包含若干字节。</p>
<h4 id="累积确认（cumulative-acknowledgement）"><a href="#累积确认（cumulative-acknowledgement）" class="headerlink" title="累积确认（cumulative acknowledgement）"></a>累积确认（cumulative acknowledgement）</h4><p>在TCP中并无数据长度的说法，在接收端和发送端眼中数据是没有边界、没有长度、但<strong>有序</strong>的字节流，用序号来标识字节。</p>
<ul>
<li>TCP Segment中的<strong>序号</strong>（Seq）<strong>代表第一个字节在<u>发送端</u>的序号</strong>。<ul>
<li>初始序号可以是随机的</li>
</ul>
</li>
<li><u>发送者</u>用<strong>确认号</strong>（ACK）来提醒对方，<strong>自己下一个想要接收对方的Seq = ACK的字节</strong>。</li>
</ul>
<h5 id="按序接收"><a href="#按序接收" class="headerlink" title="按序接收"></a>按序接收</h5><p>TCP只记录第一个字节流是有序的，因此TCP也应按序接收，ACK = n，代表着序号n以前的数据都被正确接收。只确认到第一个丢失字节为止的位置。</p>
<p><strong>失序</strong>：回顾可靠传输协议GBN与SR，一个重要的区别就是SR对于失序的报文会选择先缓存再发送ACK，而GBN会直接丢弃，TCP的实现就是先保留，然后等待缺少的字节填补间隔</p>
<p><strong>捎带确认</strong>：发送数据方同时也可以是接收数据方，这样可以在携带数据的报文中捎带进行确认。比如 Telnet <code>echo</code> 功能中，服务端会把确认号装在回复给客户端的报文中，与此同时还运输了数据</p>
<p><strong>无数据的ACK报文</strong>：有的报文只是有一个确认的功能，没有带任何数据，但是Seq字段也不能空，所以还是会填Seq字段，只是一个逻辑上的标号</p>
<h4 id="超时重传（timeout-retransmission）"><a href="#超时重传（timeout-retransmission）" class="headerlink" title="超时重传（timeout retransmission）"></a>超时重传（timeout retransmission）</h4><ul>
<li><p>RTO（Retransmission Time Out）：重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传。</p>
</li>
<li><p>RTO 的确定是一个关键问题，因为它直接影响到 TCP 的性能和效率。如果 RTO 设置得太小，会导致不必要的重传，增加网络负担；如果 RTO 设置得太大，会导致数据传输的延迟，降低吞吐量。因此，RTO 应该根据网络的实际状况，动态地进行调整。</p>
</li>
<li><p>RTT 的值会随着网络的波动而变化，所以 TCP 不能直接使用 RTT 作为 RTO。为了动态地调整 RTO，TCP 协议采用了一些算法，如加权移动平均（EWMA）算法，Karn 算法，Jacobson 算法等，这些算法都是根据往返时延（RTT）的测量和变化来估计 RTO 的值。</p>
</li>
<li><p>超时间隔是通过统计学加上适当的估计算出来的，但是必须大于 1 RTT+路由器处理时延。</p>
</li>
<li><p>不采用重传后的样本（Karn 算法）因为不知道这个ACK是对重传的ACK还是迟到的ACK，因此不统计重传的RTT</p>
</li>
<li><p>如果突然变得拥塞，导致大量超时重传，无法统计样本的RTT，造成RTT无法及时更新，因此每次重传都把RTO翻倍，也是一种拥塞控制的机制，防止过度阻塞</p>
</li>
</ul>
<h5 id="快速重传（fast-retransmit）"><a href="#快速重传（fast-retransmit）" class="headerlink" title="快速重传（fast retransmit）"></a>快速重传（fast retransmit）</h5><p>防止间隔加倍导致网络时延过大，<strong>乱序到达则发送冗余ACK</strong>，收到3次冗余ACK，就重传一次对应ACK序号的数据。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>TCP 接收方操作</th>
</tr>
</thead>
<tbody><tr>
<td>收到按顺序的分段，其序列号是接收方期望的。所有数据的序列号都小于或等于期望的序列号并已被确认。</td>
<td>延迟发送ACK。等待最多500毫秒以接收下一个按顺序到达的分段。如果在此时间间隔内未接收到下一个分段，则发送一个ACK。</td>
</tr>
<tr>
<td>收到按顺序的分段，其序列号是接收方期望的，并且有另一个按顺序的分段正在等待ACK发送。</td>
<td>立即发送单个累计ACK，确认两个按顺序的分段。</td>
</tr>
<tr>
<td>收到乱序的分段，其序列号大于期望的序列号。检测到数据的缺口（gap）。</td>
<td>立即发送冗余ACK，表明<strong>下一期望接收的字节的序列号</strong>（即<strong>缺口的起始序列号</strong>）。</td>
</tr>
<tr>
<td>收到的分段能够部分或完全填补接收数据中的缺口。</td>
<td>立即发送ACK，前提是该分段的起始序列号正好是<strong>缺口的起始序列号</strong>。</td>
</tr>
</tbody></table>
<p>GBN协议中，用变量expectedseqnum表示expectedseqnum以前的数据都已经正确接收， 接收方将不停发送具有expectedseqnum<del>1</del>的ACK（之前已经发过了，因此是冗余ACK），直到正确收到具有expectedseqnum<del>1</del>的数据。==GBN== </p>
<h5 id="选择重传-SACK"><a href="#选择重传-SACK" class="headerlink" title="选择重传 SACK"></a>选择重传 SACK</h5><p>改进的方法就是 SACK（Selective Acknowledgment），简单来讲就是在快速重传的基础上，<strong>返回最近收到的报文段的序列号范围</strong>，这样客户端就知道，哪些数据包已经到达服务器了。</p>
<p>**冗余SACK ** </p>
<p>DSACK，即重复 SACK，这个机制是在 SACK 的基础上，额外携带信息，<strong>告知发送方有哪些数据包自己重复接收了</strong>。DSACK 的目的是帮助发送方判断，是否发生了包失序、ACK 丢失、包重复或伪重传。让 TCP 可以更好的做网络流控。</p>
<h4 id="GBN-or-SR"><a href="#GBN-or-SR" class="headerlink" title="GBN or SR?"></a>GBN or SR?</h4><p><strong>累计确认</strong></p>
<p>TCP实现中包含了累计确认这个GBN的要素，但是TCP对于失序的部分不会直接丢弃，也不回复ACK，而是暂存形成一个数据缺口。</p>
<p>对于超时重传，TCP只会让流水线发送中第一个未确认的字节重传，并且如果接受到了序号更大的ACK，连重传也不需要；而GBN规定只要没有收到第一个的ACK，后面不管是否收到必须全部重传。</p>
<p>一些TCP实现中也可以采用SR，不必使用累计确认。</p>
<p><strong>接收窗口</strong></p>
<p>TCP有接收窗口，GBN的接收窗口宽度只有1，SR也有接收窗口，但是SR并不是累计确认。</p>
<h3 id="流量控制（flow-control）"><a href="#流量控制（flow-control）" class="headerlink" title="流量控制（flow control）"></a>流量控制（flow control）</h3><p>不同于网络中的拥塞控制机制，流量控制是用来使发送方与接收方速率相匹配的机制，提醒发送方能发多少避免接收方缓冲区溢出。</p>
<h4 id="接收窗口（rwnd）"><a href="#接收窗口（rwnd）" class="headerlink" title="接收窗口（rwnd）"></a>接收窗口（rwnd）</h4><ul>
<li><p>TCP接收方维护 <code>lastByteRcvd</code>（最后一个递交给应用进程的）与 <code>lastByteRead</code>（最后一个确认的，rcv_base或expectedseqnum）二者差值即为接收缓冲区中的现有字节数，由此可以计算出缓冲区的可用字节数字rwnd。<code>rwnd = RcvBufferSize - (lastByteRcvd - lastByteRead)</code> </p>
</li>
<li><p>TCP发送方维护<code>lastByteSent</code>（最后一个发送的nextSeqnum，）与<code>lastByteAck</code>（最后一个确认的，send_base）二者差值即为所有已发送但未收到确认的字节数，<code>lastByteSent - lastByteAck &lt;= rwnd</code> 否则就阻塞发送方，也就是说发送窗口和接收窗口是一个概念。</p>
</li>
</ul>
<h5 id="TCP-零窗口探测"><a href="#TCP-零窗口探测" class="headerlink" title="TCP 零窗口探测"></a>TCP 零窗口探测</h5><ul>
<li>如果rwnd = 0，发送方仍会发送一个特殊的1字节的段（就是下一字节的数据，没新的数据段发送的时候发一个ack），强制接收端重新宣布下一个期望的字节和窗口大小（rwnd），与此同时启动一个探测定时器（persistence timer）</li>
<li>如果接收方回复的窗口rwnd仍然为0，则发送方的探测定时器加倍。</li>
<li>没有收到ACK，在发送探测包的最大次数之后连接超时（Reset或者关闭TCP连接）</li>
</ul>
<h4 id="传输效率"><a href="#传输效率" class="headerlink" title="传输效率"></a>传输效率</h4><h5 id="Nagle-算法"><a href="#Nagle-算法" class="headerlink" title="Nagle 算法"></a>Nagle 算法</h5><p>如果数据段只有1个字符，21字节的报文段只有1B的数据，带宽利用率就很低</p>
<p>Nagle算法：如果连续发字节，先发一个，收到确认之后把缓存的一连串一起发出去；一旦到达发送窗口或者MSS就立即发出。</p>
<h5 id="糊涂窗口综合征"><a href="#糊涂窗口综合征" class="headerlink" title="糊涂窗口综合征"></a>糊涂窗口综合征</h5><ul>
<li>接收窗口空出1字节就急忙通知对方，对方发过来1字节又占满缓冲区</li>
<li>接收方有足够的接收缓存再去通知，rwnd = Rcvbuffer/2 或 MSS即可通知</li>
<li>尽可能地在MSS范围内提升报文段内数据的比例，提升利用率</li>
</ul>
<h3 id="连接管理（connection-management）"><a href="#连接管理（connection-management）" class="headerlink" title="连接管理（connection management）"></a>连接管理（connection management）</h3><h4 id="连接建立：三次握手（three-way-handshake）"><a href="#连接建立：三次握手（three-way-handshake）" class="headerlink" title="连接建立：三次握手（three-way handshake）"></a>连接建立：三次握手（three-way handshake）</h4><p>ACK比特用于表示ACK确认号字段有效</p>
<ol>
<li>客户端发送<strong>SYN</strong>报文：Seq = x，SYN = 1 (ACK比特 = 0) </li>
<li>服务器<strong>SYNACK</strong>报文：Seq = y，SYN = 1，ACK确认号 = x + 1 (ACK比特 = 1)</li>
<li>客户端<strong>ACK</strong>报文 ：Seq = x + 1，SYN = 0，ACK确认号 = y + 1 (ACK比特 = 1)</li>
</ol>
<h5 id="SYN-泛洪-SYN-cookie"><a href="#SYN-泛洪-SYN-cookie" class="headerlink" title="SYN 泛洪: SYN cookie"></a>SYN 泛洪: SYN cookie</h5><p>服务器收到SYN报文将会缓存y，用于核对下一个ACK的值是否为y+1，存到内存中，SYN攻击的原理就是不发送ACK，因此服务器会不断缓存y，建立许多半连接，最终不堪重负。解决方法就是服务器不去储存y，而是用特别的方法生成，y = H(IP1, IP2, key) 关键在于只有服务器知道的key，而合法的客户端会回复ACK报文，服务端接收以后只需要用相同的哈希函数再次计算y，看看是不是和ACK报文中的y相同，如果相同，则建立连接。</p>
<h5 id="RST-连接重置"><a href="#RST-连接重置" class="headerlink" title="RST 连接重置"></a>RST 连接重置</h5><p>用于强制中断当前的连接，如果SYN报文的目的端口并未有套接字在监听，说明这个请求非法，于是响应报文RST置1</p>
<p>在 <strong>TCP</strong> 重置攻击中，攻击者通过向通信的一方或双方发送伪造的消息，告诉它们立即断开连接，从而使通信双方连接中断。正常情况下，如果客户端收发现到达的报文段对于相关连接而言是不正确的，<strong>TCP</strong> 就会发送一个重置报文段，从而导致 <strong>TCP</strong> 连接的快速拆卸。</p>
<p><strong>TCP</strong> 重置攻击利用这一机制，通过向通信方发送伪造的重置报文段，欺骗通信双方提前关闭 TCP 连接。如果伪造的重置报文段完全逼真，接收者就会认为它有效，并关闭 <strong>TCP</strong> 连接，防止连接被用来进一步交换信息。服务端可以创建一个新的 <strong>TCP</strong> 连接来恢复通信，但仍然可能会被攻击者重置连接。万幸的是，攻击者需要一定的时间来组装和发送伪造的报文，所以一般情况下这种攻击只对长连接有杀伤力，对于短连接而言，你还没攻击呢，人家已经完成了信息交换。</p>
<p>从某种意义上来说，伪造 <strong>TCP</strong> 报文段是很容易的，因为 <strong>TCP/IP</strong> 都没有任何内置的方法来验证服务端的身份。有些特殊的 IP 扩展协议（例如 <code>IPSec</code>）确实可以验证身份，但并没有被广泛使用。客户端只能接收报文段，并在可能的情况下使用更高级别的协议（如 <code>TLS</code>）来验证服务端的身份。但这个方法对 <strong>TCP</strong> 重置包并不适用，因为 <strong>TCP</strong> 重置包是 <strong>TCP</strong> 协议本身的一部分，无法使用更高级别的协议进行验证</p>
<h4 id="连接断开：四次挥手（four-way-handshake）"><a href="#连接断开：四次挥手（four-way-handshake）" class="headerlink" title="连接断开：四次挥手（four-way handshake）"></a>连接断开：四次挥手（four-way handshake）</h4><p>FIN比特 置1</p>
<ol>
<li>客户端发送FIN，提醒服务器要断开连接，</li>
<li>服务器随即回复ACK，表示已经收到消息准备断开，发送完剩余数据之后，在发送FIN并关闭连接，告知客户端，服务器这边已经关闭了，服务器等待最后一个ACK</li>
<li>客户端收到FIN以后开始定时并回复ACK，超时即CLOSED。服务端收到客户端ACK之后正式CLOSED</li>
</ol>
<p>TIME-WAIT timer：如果客户端发的ack丢失，服务器还得重传Fin，如果客户端这边早早CLOSED，就收不到服务器Fin，也就发不出ack，服务器的套接字状态无法正式CLOSED</p>
<h4 id="TCP-状态转换"><a href="#TCP-状态转换" class="headerlink" title="TCP 状态转换"></a>TCP 状态转换</h4><h5 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h5><p><img src="C:/Users/Lenovo/Pictures/markdownfile/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82.assets/10d2447d4713399745cdb4937cf56a41.jpg" alt="10d2447d4713399745cdb4937cf56a41"></p>
<h5 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h5><p><img src="C:/Users/Lenovo/Pictures/markdownfile/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82.assets/05f6445ba70b616b59a5c690c306d522.jpg" alt="05f6445ba70b616b59a5c690c306d522"></p>
<h3 id="拥塞控制（congestion-control）"><a href="#拥塞控制（congestion-control）" class="headerlink" title="拥塞控制（congestion control）"></a>拥塞控制（congestion control）</h3><h4 id="拥塞窗口（cwnd）"><a href="#拥塞窗口（cwnd）" class="headerlink" title="拥塞窗口（cwnd）"></a>拥塞窗口（cwnd）</h4><ul>
<li><strong>拥塞窗口</strong>（congestion window, cwnd）：取决于中间的网络条件，由发送方控制，cwnd/RTT就是发送速率。</li>
<li><strong>接收窗口</strong>（receive window, rwnd）：由接收方可用缓存控制的，限制发送速率。</li>
<li><strong>对于发送方</strong>：<code>lastByteSent - lastByteAck &lt;= min(cwnd,rwnd)</code>  </li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82.assets/image-20241205212918399.png" alt="image-20241205212918399"></p>
<p>下面为了方便研究，将cwnd作为TCP发送的主要瓶颈。</p>
<h4 id="基于丢包的拥塞控制（loss-based）"><a href="#基于丢包的拥塞控制（loss-based）" class="headerlink" title="基于丢包的拥塞控制（loss-based）"></a>基于丢包的拥塞控制（loss-based）</h4><p>TCP 对于拥塞控制给出如下三个<strong>指导性原则</strong>：</p>
<ul>
<li><p>如果出现丢包（冗余ACK或超时重传），那说明网络可能出现了拥塞状况，将缩短拥塞窗口，限制发送量</p>
</li>
<li><p>如果出现正常ACK，说明对方正确接收了，网络状况良好，将扩大拥塞窗口，增加发送量</p>
</li>
<li><p>带宽探测：探测拥塞开始的速率，增加发送速率以与ACK匹配，出现丢包则从该速率回退，然后继续探测。</p>
</li>
</ul>
<p>拥塞控制算法有慢启动-拥塞避免-快速恢复三个状态，下图为FSM:</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82.assets/image-20241205213030112.png" alt="image-20241205213030112"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82.assets/image-20241205212615649.png"></p>
<h5 id="慢启动（slow-start）"><a href="#慢启动（slow-start）" class="headerlink" title="慢启动（slow-start）"></a>慢启动（slow-start）</h5><p>初始cwnd = 1 MSS，发送1个字节，得到1 ACK, cwnd增大1 MSS，第二次发送2个字节，1个ACK增大1 MSS，呈<strong>指数增长</strong>。（2^n^ MSS per RTT）</p>
<p>cwnd是动态变化的，只要接收到ACK就会让cwnd增大，即使上一个RTT的ACK还没接收完，也对下一个RTT的能发送的字节数影响不大，因为接收完上一个RTT的所有ACK，意味着cwnd已经在上一RTT的基础上翻倍了，而此时肯定CWND还没被占满。</p>
<p>慢启动阈值ssthresh：阈值内部慢启动，超出阈值则拥塞避免</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82.assets/image-20241205220630888.png" alt="image-20241205220630888"></p>
<p><strong>三种结束慢启动的方式</strong>：</p>
<ul>
<li><p><strong>超时重传</strong>：<strong>timeout</strong>，则将 <strong>ssthresh</strong>(slow-start threshold)设置为cwnd/2，重置 cwnd = 1 MSS，重新开始<strong>慢启动过程</strong>，然后执行重传。</p>
</li>
<li><p><strong>可能再次发生拥塞</strong>： <strong>cwnd &gt;= ssthresh</strong>，说明再增大可能就要再次拥塞了，应该更加谨慎地增加cwnd，进入<strong>拥塞避免</strong>模式。</p>
</li>
<li><p><strong>快速重传</strong>：<strong>冗余ACK = 3</strong>（连续收到4个相同的ACK）触发快速重传<u>之前</u>，ssthresh设置为cwnd/2，cwnd减半并加上3 MSS，进入<strong>快速恢复</strong>模式。</p>
</li>
</ul>
<p>因此，cwnd &lt; ssthresh 仍然处于慢启动的状态。</p>
<h5 id="拥塞避免（congestion-avoidance）"><a href="#拥塞避免（congestion-avoidance）" class="headerlink" title="拥塞避免（congestion avoidance）"></a>拥塞避免（congestion avoidance）</h5><p>ssthresh 是导致拥塞的cwnd / 2，因此到了第二次cwnd增大到ssthresh就应当减小增加的速度，呈<strong>线性增长</strong>（1 MSS per RTT）</p>
<p>如果cwnd是10个MSS大小，则在一次 RTT中发10MSS字节，假如一个报文段是1MSS，每个ACK加十分之一MSS，这些报文段全部确认之后，cwnd总共加了1MSS </p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82.assets/image-20241205215843491-1733407571075-4.png" alt="image-20241205215843491"></p>
<p><strong>两种结束拥塞避免的方式</strong>：</p>
<ul>
<li><strong>超时重传</strong>：<strong>timeout</strong>，则将ssthresh(slow-start threshold)设置为cwnd/2，重置 cwnd = 1 MSS，重新开始<strong>慢启动过程</strong>，然后执行重传。重新回到<strong>慢启动</strong>。</li>
<li><strong>快速重传</strong>：<strong>冗余ACK = 3</strong>（连续收到4个相同的ACK）触发快速重传<u>之前</u>，ssthresh设置为cwnd/2，cwnd减半并加上3 MSS，进入<strong>快速恢复</strong>模式。</li>
</ul>
<h5 id="快速恢复（fast-recovery）"><a href="#快速恢复（fast-recovery）" class="headerlink" title="快速恢复（fast recovery）"></a>快速恢复（fast recovery）</h5><p>快速重传以后进入快速恢复状态，既然发的是冗余ACK，说明收到的是失序的正确报文段，加3MSS更加接近实际结果。</p>
<h6 id="TCP-Reno-vs-TCP-Tahoe"><a href="#TCP-Reno-vs-TCP-Tahoe" class="headerlink" title="TCP Reno vs TCP Tahoe"></a>TCP Reno vs TCP Tahoe</h6><ul>
<li>Tahoe: Cut to 1 MSS when loss detected (either t-d-ACK or timeout)</li>
<li>Reno: Cut to roughly half on loss detected by triple duplicate ACK </li>
</ul>
<p>TCP Reno会在快速重传之后进入快速恢复状态，TCP Tahoe则没有快速恢复状态</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82.assets/image-20241205223629221.png" alt="image-20241205223629221"></p>
<h6 id=""><a href="#" class="headerlink" title=""></a></h6><h5 id="AIMD：加性增乘性减"><a href="#AIMD：加性增乘性减" class="headerlink" title="AIMD：加性增乘性减"></a>AIMD：加性增乘性减</h5><p>Additive-Increase, Multiplicative-Decrease 增加是一个一个加上去的，减少是立马减半的。</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82.assets/image-20241205225111917.png" alt="image-20241205225111917"></p>
<h5 id="TCP-CUBIC：更加激进但有效地探测带宽"><a href="#TCP-CUBIC：更加激进但有效地探测带宽" class="headerlink" title="TCP CUBIC：更加激进但有效地探测带宽"></a>TCP CUBIC：更加激进但有效地探测带宽</h5><p><img src="C:/Users/Lenovo/Pictures/markdownfile/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82.assets/image-20241205225702555.png" alt="image-20241205225702555"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82.assets/image-20241205225712876.png" alt="image-20241205225712876"><br>$$<br>W = { \vert K - t \vert } ^3+W_{max}<br>$$<br>在Linux默认开启，在拥塞避免阶段，用一个立方函数来代替线性增长，能够在即将可能发生拥塞（到达上次开始丢包的cwnd）时放慢增长速率</p>
<h4 id="其他拥塞控制方法"><a href="#其他拥塞控制方法" class="headerlink" title="其他拥塞控制方法"></a>其他拥塞控制方法</h4><h5 id="基于时延的拥塞控制（delay）"><a href="#基于时延的拥塞控制（delay）" class="headerlink" title="基于时延的拥塞控制（delay）"></a>基于时延的拥塞控制（delay）</h5><p>Loss-based: Increase sending rate until a loss (timeout) and then cut back</p>
<p>Delay-based: Do the same until RTT reaches RTTcongested</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82.assets/image-20241206202843219.png" alt="image-20241206202843219"></p>
<h5 id="基于网络协作的拥塞控制（network-assisted）"><a href="#基于网络协作的拥塞控制（network-assisted）" class="headerlink" title="基于网络协作的拥塞控制（network-assisted）"></a>基于网络协作的拥塞控制（network-assisted）</h5><p><img src="C:/Users/Lenovo/Pictures/markdownfile/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82.assets/image-20241206202921921.png" alt="image-20241206202921921"></p>
<h5 id="TCP-公平性"><a href="#TCP-公平性" class="headerlink" title="TCP 公平性"></a>TCP 公平性</h5><p>if $K$ TCP sessions share same bottleneck link  of bandwidth $R$, each should have average rate of $R/K$</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82.assets/image-20241206203243736.png" alt="image-20241206203243736"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/L3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82.assets/image-20241206203312056.png" alt="image-20241206203312056"></p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_optimize.html">如何优化 TCP? | 小林coding</a> </p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_problem.html">TCP 协议有什么缺陷？ | 小林coding</a> </p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_http_keepalive.html">TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？ | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_drop.html">用了 TCP 协议，数据一定不会丢吗？ | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_tls.html#tcp-fast-open">HTTPS 中 TLS 和 TCP 能同时握手吗？TCP FastOpen  | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_unplug_the_network_cable.html">拔掉网线后， 原本的 TCP 连接还存在吗？ | 小林coding</a> </p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_down_and_crash.html">TCP 连接，一端断电和进程崩溃有什么区别？ | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_queue.html">TCP 半连接队列和全连接队列 | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html">4.1 TCP 三次握手与四次挥手面试题 | 小林coding</a> </p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_three_fin.html">TCP 四次挥手，可以变成三次吗？ | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/out_of_order_fin.html">四次挥手中收到乱序的 FIN 包会如何处理？ | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/isn_deff.html">为什么 TCP 每次建立连接时，初始化序列号都要不一样呢？ | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/syn_drop.html">SYN 报文什么时候情况下会被丢弃？ | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/time_wait_recv_syn.html#%E5%85%88%E8%AF%B4%E7%BB%93%E8%AE%BA">在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？ | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_tw_reuse_close.html">tcp_tw_reuse 为什么默认是关闭的？ | 小林coding</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/quic.html">如何基于 UDP 协议实现可靠传输？ | 小林coding</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/01/06/OS%20Booting%20&%20Operating%20Modes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/06/OS%20Booting%20&%20Operating%20Modes/" class="post-title-link" itemprop="url">操作系统启动 CPU模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-06 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-06T00:00:00+08:00">2025-01-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-03 21:13:49" itemprop="dateModified" datetime="2025-05-03T21:13:49+08:00">2025-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Operating-Modes"><a href="#Operating-Modes" class="headerlink" title="Operating Modes"></a>Operating Modes</h1><p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241219213730449.png" alt="image-20241219213730449"></p>
<ul>
<li>x86-64 架构的处理器正常工作在 <u>Long Mode</u>，支持 64 位 OS/UEFI，有两个子模式<ul>
<li><u>64-bit Mode</u>: 只能运行 64 位软件，32 位软件需要重新编译</li>
<li><u>Compatibility Mode</u>: 兼容 32 位和 16 位保护模式软件，不支持实模式/虚拟86</li>
</ul>
</li>
<li>IA-32 或 x86 架构的处理器(i286后)正常工作在 <u>Protected Mode</u>，支持 32 位 OS/UEFI<ul>
<li><u>Protected Mode</u>: 支持运行 32 位 和 16 位保护模式的软件</li>
<li><u>Virtual 8086 Mode</u>: 类似 Compatibility Mode，可直接向下兼容运行 real mode 软件</li>
</ul>
</li>
<li>8086 处理器的 <u>Real Mode</u>，最高支持 16 位的操作系统，只能运行实模式软件</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220141424897.png" alt="image-20241220141424897"></p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/80186">80186</a> 和早期的 CPU 仅仅只有一种操作模式，也就是相当于后来芯片的这种 Real Mode；</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/80286">80286</a> 和之后的 x86 CPU 都是以 Real Mode 开机，然后经过 BIOS/UEFI, Bootloader 等引导程序切换到 Protected Mode 或 Long Mode，以便运行 32 或 64 位的操作系统。</p>
</li>
<li><p>启动操作系统之后，通常是在对应模式下运行，如果要运行向前兼容的程序只能使用子模式，切换模式需要重新初始化 CPU 代价太大</p>
</li>
</ul>
<h2 id="Real-Mode"><a href="#Real-Mode" class="headerlink" title="Real Mode"></a>Real Mode</h2><p>80286 以前：</p>
<p><strong>Intel 80186</strong>是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Intel">Intel</a>针对<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E4%B8%9A%E6%8E%A7%E5%88%B6">工业控制</a>／<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E4%BF%A1">通信</a>等嵌入式市场，于1982年推出的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/8086">8086</a>处理器的扩展产品，除8086内核，另外包括了中断控制器、定时器、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%8E%A5%E8%A8%98%E6%86%B6%E9%AB%94%E5%AD%98%E5%8F%96">DMA</a>、I/O、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/UART">UART</a>、片选电路等外设。</p>
<p><strong>实模式</strong>，Real mode[Real-Address Mode]，是Intel <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/80286">80286</a>和之后的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X86">x86</a>兼容<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CPU">CPU</a>的操作模式。实模式的特性是20位寻址空间，最大寻址空间1MB，最大分段64KB，可以直接软件访问<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/BIOS">BIOS</a>以及周边硬件，没有任何硬件等级的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6%E9%AB%94%E4%BF%9D%E8%AD%B7">保护</a>观念或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%B7%A5">多任务</a>支持。所有的80286系列和之后的x86 CPU都是以实模式下开机；<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/80186">80186</a>和早期的CPU仅仅只有一种操作模式，也就是相当于后来芯片的这种实模式。CPU <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%8D%E4%BD%8D/6156307?fromModule=lemma_inlink">复位</a>（reset）或加电（power on）的时候以实模式启动。</p>
<p>实模式出现于早期 8088 CPU 时期。当时由于 CPU 的性能有限，一共有 20 位<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=8464187&content_type=Article&match_order=1&q=%E5%9C%B0%E5%9D%80%E7%BA%BF&zhida_source=entity">地址线</a>（所以地址空间只有1MB），以及 8 个 16 位的通用寄存器，以及 4 个 16 位的段寄存器。16 位寄存器只能支持64KB的线性地址空间，需要使用另外一个寄存器配合才能利用所有的地址线，因此这种管理内存的方式称为<strong>段式管理</strong>（segmentation）由于 80286 以前只有实模式一种，当时并不叫实模式，286 以后出现保护模式才给以前这个模式取名叫实模式，而硬件上有一定改进，因此 8086 和 80286 的实模式还有有一些细微区别的。详见A20 Gate</p>
<h3 id="x86-Registers"><a href="#x86-Registers" class="headerlink" title="x86 Registers"></a>x86 Registers</h3><p>图中绿色标记为 8086 的 4 个段寄存器，还有剩下的 16 位寄存器</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Booting%20&%20Operating%20Modes.assets/image-20241221225031752.png" alt="image-20241221225031752"></p>
<ul>
<li>4 个段寄存器 <strong>CS</strong>、<strong>SS</strong>、<strong>DS</strong> 和 <strong>ES</strong>，用来描述特定段的基址，不能混用，都是 16 位；</li>
<li>1 个指令指针寄存器 <strong>IP</strong> ， 用于和 CS 组成 <strong>CS:IP</strong> 逻辑地址，指向下一条要执行的指令，16 位；</li>
<li>8 个通用寄存器，其中 <strong>SP</strong> 一般固定用于保存堆栈指针，其他可以任意混用，16 位；</li>
<li>1 个程序状态字 <strong>FLAGS</strong>(<strong>PSW</strong>, Program Status Word) 16 位，保存当前程序执行的一些状态和结果的某些信息</li>
</ul>
<h3 id="Segmentation-before-80286"><a href="#Segmentation-before-80286" class="headerlink" title="Segmentation before 80286"></a>Segmentation before 80286</h3><p><img src="C:/Users/Lenovo/Pictures/markdownfile/Bootloader.assets/20131020015240765.jpeg" alt="img"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220001927471.png" alt="image-20241220001927471"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220141646817.png" alt="image-20241220141646817"></p>
<p>当某个指令想要访问某个内存地址时，它通常需要用下面的这种格式来表示：(段基址：段偏移量) </p>
<ul>
<li><p>段基址：它的值是由<strong>段寄存器</strong>提供的(一般来说，段寄存器有6种，分别为cs，ds，ss，es，fs，gs，这几种段寄存器都有自己的特殊意义，这里不做介绍)</p>
<ul>
<li>段寄存器除了有 16 位的可见部分，还有不可见的隐藏部分：描述符缓存“descriptor cache”或隐藏寄存器“shadow register” 当一个段选择子装入段寄存器的可见部分，处理器同时也把它指向的段表内容缓存cache中，避免在翻译逻辑地址时花费额外的开销去访问段表。处理器指令中可以明示使用哪些段寄存器，这将替换掉默认使用的段寄存器。</li>
</ul>
</li>
<li><p>段内偏移量：代表你要访问的这个内存地址距离这个段基址的偏移。它的值由<strong>通用数据寄存器</strong>来提供的，所以也是 16 位。那么两个 16 位的值如何组合成一个20位的地址呢？CPU采用的方式是把段寄存器所提供的段基址先向左移4位。这样就变成了一个20位的值，然后再与段偏移量相加。段偏移量16位，因此最大分段为 64 KB</p>
</li>
<li><p><code>物理地址 = 段基址 &lt;&lt; 4 位 + 段内偏移</code> </p>
<ul>
<li>段寄存器是0xff00，段偏移量为0x0110，物理地址 0xff00&lt;&lt;4 + 0x0110 = 0xff110</li>
</ul>
</li>
</ul>
<p>实模式的”实”更多地体现在其地址是<strong>真实的物理地址</strong>(Real-Address Mode)</p>
<p>段基址 + 偏移，Segmentation 分段的雏形，逻辑地址</p>
<h3 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h3><p>由于程序可以任意修改当前的 CS/DS 值，所有程序可以使用全部  1 MB 的内存，所以这个CPU几乎没有办法有效地支持多任务，因为两个程序一起运行的话很容易互相踩到内存。所以当时的使用的方式系统中同时运行的只有一个应用程序和一个DOS操作系统。操作系统和应用规定了各自能使用的内存地址范围，比如说DOS只使用高 64KB 的内存，其它的内存给应用程序使用。这样就可以互不影响。要想运行另一个应用程序必须先退出当前运行的应用程序。</p>
<h3 id="A20-Gate"><a href="#A20-Gate" class="headerlink" title="A20 Gate"></a>A20 Gate</h3><p>在 8086 时代使用CS&lt;&lt; 4 + IP计算物理地址， 从理论上讲，最大可以表示的数值是 0xFFFF0 + 0xFFFF = 0x10FFEF，即大约1M+64KB-16B,然而由于当时的地址线只有 20 根（A0~A19)，这个地址最前面的1无法被表示，当CS=0xFFFF时，实际访问的地址0x10FFEF就变成了0xFFEF，这也导致当时程序编写者为了适应这个问题使用了特殊的技巧。到了80286，地址线变成24位，此时0x10FFEF可以访问到了。为了兼容性考虑，由A20 Gate来控制第21根地址总线的开关。能够在实模式下增加了对额外 65,520 字节（64 KB - 16 字节）内存的访问，而无需进行重大软件更改。</p>
<ul>
<li>开关打开：实模式能访问10000-10FFEF的高地址</li>
<li>开关关闭：实模式无法访问10000-10FFEF，保护模式只能访问 0到1M，2M到3M，寻址空间减少一半。</li>
</ul>
<p>另外实模式和8086还有中断向量的区别，详见虚拟 86 模式</p>
<h2 id="Protected-Mode"><a href="#Protected-Mode" class="headerlink" title="Protected Mode"></a>Protected Mode</h2><p>80286 到 80386 开始：<br><strong>保护模式</strong>，Protected Mode，内存保护模式，寻址采用32位段和偏移量，最大寻址空间为4GB，最大分段4GB 。保护模式拥有内存保护，分页系统，以及硬件支持的虚拟内存等功能，支持抢占式多任务调度，CPU 特权模式。在保护模式下，进行寻址时，段寄存器值不再被简单的解析为段基址，而是全局/局部描述符表（GDT/LDT）的索引，也即是所谓的段选择子。</p>
<p>80286 开始支持保护模式，但是寄存器仍然是 16 位，属于 16 位的保护模式。</p>
<p>80386 以后，CPU 寄存器变成 32 位，IA-32 的保护模式寻址发生了一定变化: 地址线的个数从原来的20根变为现在的32根，所以可以访问的内存空间也从 1 MB 变为 4 GB。实模式下的内存地址计算方式就已经不再适合了。</p>
<h3 id="80286-Protected-Mode-16-bit"><a href="#80286-Protected-Mode-16-bit" class="headerlink" title="80286 Protected Mode(16-bit)"></a>80286 Protected Mode(16-bit)</h3><p><img src="C:/Users/Lenovo/Pictures/markdownfile/Bootloader.assets/080810-protected-286-segments.png" alt="undefined"></p>
<h4 id="New-Features-of-80286"><a href="#New-Features-of-80286" class="headerlink" title="New Features of 80286"></a>New Features of 80286</h4><ul>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/80286">Intel 80286</a> 的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E7%B8%BD%E7%B7%9A">地址总线</a>增加到 24 位，物理最大可寻址空间为 2^24^（即16 MB）</p>
</li>
<li><p>寄存器：</p>
<ul>
<li><p>通用寄存器的位数仍为 16 位，只能使用段式管理，增加了保护模式通过段表间接访存</p>
</li>
<li><p>引入了 机器状态字 <strong>MSW</strong>(Machine Status Word)寄存器用来控制处理器整体的状态，比如保护模式与实模式的切换</p>
</li>
<li><p>引入 <strong>GDTR</strong> <strong>LDTR</strong> <strong>IDTR</strong> <strong>TR</strong>，工作在保护模式，为分段服务，是多任务实现的基础</p>
</li>
</ul>
</li>
<li><p>80286 保护模式下的应用程序能访问的内存<strong>线性地址空间仅为 64 KB</strong>，非常有限。所以程序员编写使用大内存的应用程序时还必须使用远指针、近指针，相当繁琐。这影响了 80286 保护模式的推广使用。</p>
</li>
</ul>
<h4 id="x86-Segmentation"><a href="#x86-Segmentation" class="headerlink" title="x86 Segmentation"></a>x86 Segmentation</h4><h5 id="Descriptor-Table"><a href="#Descriptor-Table" class="headerlink" title="Descriptor Table"></a>Descriptor Table</h5><p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220142126857-1734679595859-13-1734679601817-15.png" alt="image-20241220142126857"></p>
<p>在80286中，CS/DS/ES/FS寄存器存储的内容变成了选择子。使用段表管理之后，CPU 使用的就是逻辑地址（段选择子+偏移量），经过段表翻译才能有实际物理地址，而段描述符表只有系统内核才能修改。这就保证了一个进程只能访问内核分配给他的段上的物理内存。寻址时，依然是 base and bound 的思想，只不过要先去段表中查找段表项，里面有对应段的物理地址以及界限以及权限位，这里就体现出了虚拟内存的保护作用，之前偏移量受位数限制，现在偏移量不能超过界限，并且必须通过权限鉴别。</p>
<p>下图为段表（描述符表）的基本情况：共 3 个，可直接访问的有 GDT 与 LDT 两个，IDT 是中断表，里面的描述符指向的都是特定的段，也叫 Gate</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220152155629.png" alt="image-20241220152155629"></p>
<p>选择子一共有 16 位：</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220175738856.png" alt="image-20241220175738856"></p>
<ul>
<li>高 13 位是段表的 index；</li>
<li>TI(Table Index)为第 2 位，表示选择 GDT 还是 LDT，有专门的 GDTR、LDTR 寄存器保存段表基址 STBaseAddress。<img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220142058130-1734679404141-3.png" alt="image-20241220142058130"><ul>
<li><p>LDT 存放在 GPT 的 LDT 类型描述符中，LDT 本身是一个段，而 GDT 不是一个段</p>
</li>
<li><p>访问 LDT 需要使用段选择子，为了减少访问 LDT 时段转换的次数，LDT 的段选择符，段基址，界限都要放在 LDTR 寄存器之中。</p>
</li>
<li><p>GDT 本身不是一个段，而是线性地址空间的一个数据结构；GDT 的线性基地址和长度必须加载进 GDTR 之中。因为每个描述符长度是8，所以 GDT 的基地址最好进行8字节对齐。</p>
</li>
<li><p>段寄存器仍然有之前类似 TLB 的 <strong>缓存</strong> 机制，有可见和不可见两个部分：</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220180035716.png" alt="image-20241220180035716"></p>
</li>
</ul>
</li>
<li>0 - 1 为权限位(RPL) RPL 称为<strong>请求</strong>权限级别。<img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Booting%20&%20Operating%20Modes.assets/image-20241221224507677.png" alt="image-20241221224507677"><ul>
<li><strong>CPL</strong> 是当前<strong>正在执行的代码段</strong>的特权级（CS 寄存器的低 2 位）<ul>
<li>0 和 3 分别表示用户态和内核态.中间是驱动程序的优先界别</li>
<li>CPL只在代码段改变时改变，即跳转指令 JMP CALL</li>
</ul>
</li>
<li>RPL 是对于一个段的请求特权级别</li>
<li><code>max&#123;RPL,CPL&#125; &lt; DPL</code> 方可访问此段</li>
</ul>
</li>
</ul>
<h4 id="Address-Translation"><a href="#Address-Translation" class="headerlink" title="Address Translation"></a>Address Translation</h4><p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220180347195.png" alt="image-20241220180347195"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220141603315.png" alt="image-20241220141603315"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/Bootloader.assets/929457-20161229210613367-1902103210-1734526656105-28.png" alt="img"></p>
<p><code>STEntry Address = STBaseAddress + 8 * index</code>  DTEntry 的大小 = 每条目 8 字节</p>
<p>Descriptor(DTEntry) 中含有段基址 界限 DPL 等       物理地址 = 段基址 + 偏移 </p>
<p>CS:IP 组合称为逻辑地址，CS 唯一对应到段表的一个条目，应用程序内存不够用时，需要调用一些系统调用，让 DOS 分配一段内存，把这段内存的 base, limit 做成一个条目（Descriptor）加入到GDT或LDT中， 只有OS能更改CS，如果用户擅自更改CS，段表中找不到对应条目，会发生segmentation fault。逻辑地址一共有13+1=14位有效，偏移16位，因此虚拟内存 1 GB。但是地址线数量限制了物理内存大小最大 16 MB。</p>
<p>基于这种内存管理方式，用户应用程序可以实现动态链接。比如说一个程序分为代码段、数据段、零初始化段等，它依赖的库也是分段的，系统在加载程序时，只需为每个段分配一段内存，并为每个段设置一个描述符即可。 每个段的起始地址可以在加载时根据实际情况修改。</p>
<p>为了区分不同段的功能，可以在TYPE字段设置，比如代码段可读可执行，数据段可读可写等。</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220180319764.png" alt="image-20241220180319764"></p>
<h4 id="Workflow-Example"><a href="#Workflow-Example" class="headerlink" title="Workflow Example"></a>Workflow Example</h4><p>为了加深理解，用一个简单的指令执行流程来说明：</p>
<ol>
<li>取指：CPU 从 CS:IP 逻辑地址 获取指令的物理地址，取指令(16bit)，CS不变，IP+2；<ul>
<li>CS 此时就是一个选择子，只要代码段无变化，当前指令的执行权限就不变</li>
</ul>
</li>
<li>译码：翻译指令，指令被解析为 <code>MOV AX, [BX]</code> 操作数的逻辑地址 DS:BX 算出物理地址</li>
<li>执行：从物理地址取数，将 取来的数存到 AX 通用寄存器</li>
</ol>
<h3 id="IA-32-Protected-Mode-32-bit"><a href="#IA-32-Protected-Mode-32-bit" class="headerlink" title="IA-32 Protected Mode(32-bit)"></a>IA-32 Protected Mode(32-bit)</h3><h4 id="New-Features-of-80386"><a href="#New-Features-of-80386" class="headerlink" title="New Features of 80386"></a>New Features of <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/80386">80386</a></h4><ol>
<li><p>首次在 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X86">x86</a> 处理器中实现了 32 位系统（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IA-32">IA-32</a>）；</p>
</li>
<li><p>可配合使用 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=80387&action=edit&redlink=1">80387</a> 数字<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BC%94%E5%8A%A9%E8%99%95%E7%90%86%E5%99%A8">辅助处理器</a>增强<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B5%AE%E7%82%B9">浮点</a>运算能力；</p>
</li>
<li><p>首次采用 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98">高速缓存</a>（外置）解决内存速度瓶颈问题；</p>
</li>
<li><p>在 IA-32 保护模式下，CPU 的 32 条地址线全部有效，可寻址高达 4 GB 的物理地址空间；</p>
<p>Descriptor 的变化，可以看到变成 32位 基地址：</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/929457-20161230154447711-2105143159-1734688534787-30.png" alt="img"></p>
</li>
<li><p>寄存器变化：</p>
<ol>
<li><p>在原来的四个段寄存器的基础上引入两个通用数据段寄存器 FS 和 GS；</p>
</li>
<li><p>除了段寄存器，其他寄存器全部升级到 32 位，名称加前缀 E，代表扩展；</p>
</li>
<li><p>将 80286 引入的 16 位 <strong>MSW</strong> 扩展为几个 32 位控制寄存器 <strong>CRx</strong> 用于控制机器特性。比如实模式、保护模式的切换以及分页机制的开启(CR0)页表的物理地址(CR3)，相对静态，初始化或特性切换时才改动，因此只有内核态可访问，以及还有用于调试的DRx寄存器；</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220175501376.png" alt="image-20241220175501376"></p>
</li>
<li><p>保护模式下的分段机制使用的寄存器 GDTR IDTR LDTR TR 有一些变化</p>
</li>
</ol>
</li>
</ol>
<h4 id="Flat-Memory-Model"><a href="#Flat-Memory-Model" class="headerlink" title="Flat Memory Model"></a>Flat Memory Model</h4><p><strong>最初的 Flat Model</strong>: </p>
<p>8086 以前，地址总线和数据寄存器只有 16 位，线性地址<strong>等于</strong>物理地址，最多支持64 KB的内存</p>
<p><strong>Real-Address Mode model</strong>: 实模式分段</p>
<p>1978 年的 8086 开始引入了内存<strong>分段</strong>，这使得 16 位 CPU 可以访问超过 64 KB (65,536字节)的内存，实际上 8086 CPU到内存的地址总线是 20 位，即可访问2^20^=1MB内存。</p>
<p>在 16 位模式，要让应用程序使用多个存储器分段（能够访问大于64K的内存）相当复杂。根源在于：数据总线位数少于地址总线，并且没有适当的地址算术指令适合做整个存储器范围的平面寻址，平面寻址方式也可以用像实模式那样的两个寄存器配合的乘法操作完成，但这会导致较慢的程序执行速度。并且 8086 只支持固定大小的段，这就引出了真正的分段机制</p>
<p><strong>Segmented Model</strong>: 保护模式分段</p>
<p>1982 年面世的 80286 不再将段寄存器左移 4 位作为段基址，而是索引到段表中获取段基址，这就是虚拟地址。</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220002439505-1734680053190-17.png" alt="image-20241220002439505"></p>
<p>分段机制有固有的问题：处理器的实模式与保护模式，以及 80386 推出的虚拟 86 模式，分段最大 64 KiB（使用 16 位索引寄存器）。在实模式下的分段架构的内存空间会有所重叠，这是一种不好的设计。</p>
<p><strong>32-bit Flat Memory Model</strong>: 32 位分页</p>
<p>1985 年面世的 80386 及其后续处理器的 32 位保护模式下，一个分段长度上限是2^20^个粒度单位，粒度可以是 1 字节或 4K 字节（一页），因此分段长度上限可以是 4 GB，与 32 位数据寄存器匹配。随着 32 位操作系统的推出，以及更舒适的 32-bit Flat Memory Model，到 1990 年末期几乎淘汰了使用分段寻址，转而使用分页寻址。</p>
<p>然而使用 32-bit Flat Memory Model 最多只能访问 4 GB 的线性地址空间，这种限制并没有远离日常。此时，分段机制可以支持更多根地址线，比如奔腾Pro, 2, 3在 IA-32 的架构下拥有 36 条地址线，最大64 GB的内存，就靠分段的支持，但这种最终回归到分段的尴尬，经常被引述为朝着 64 位处理器发展的动机。</p>
<p><strong>真正的 Flat Memory Model</strong>: 64 位分页</p>
<p>2003 年问世的 x86-64 架构下，强制实现了 Flat Memory Model 这种最简明有效的寻址模型，但保留了使用段寄存器 FS 或 GS 的 64 位下的分段寻址。</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220153250680.png" alt="image-20241220153250680"></p>
<h4 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h4><p><img src="C:/Users/Lenovo/Pictures/markdownfile/Bootloader.assets/2560px-080810-protected-386-paging.svg.png" alt="undefined"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/Bootloader.assets/image-20241219214149653.png" alt="image-20241219214149653"></p>
<p><strong>页表</strong>：采用二级页表，10+10+12 划分</p>
<p><strong>多进程</strong>：每个进程有一个页表，页表的物理地址存储在 CR3 寄存器</p>
<p>在Intel 80386及以后的版本中，保护模式保留了 80286 保护模式的分段机制，但增加了分页单元作为分段单元和物理总线之间的第二层地址转换。</p>
<ol>
<li>逻辑地址是 48 位，16 位属于段号，32 位偏移量，段表项中的段基址也是 32 位</li>
<li>应用程序寻址首先根据段号和段表基址定位到段表项，段的基地址加上偏移量算出线性地址</li>
<li>若关闭分页单元，段基址就是物理地址，直接送到地址总线上进行访存。</li>
<li>若启用分页单元，段表项存储的段基址是线性地址，而不是 80286 那样的物理地址。分页单元负责最终查询页表将这些线性地址转换为物理地址。</li>
</ol>
<p>80386 分页内存管理，比 80286 保护模式寻址具有更多的优点：</p>
<ul>
<li>操作系统可以控制与限制进程对页面的访问权限</li>
<li>为应用程序创造一个连续的、独立的、线性的虚拟内存空间</li>
<li>页面可以移出<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AD%98">主存</a>，存入更慢速的次级<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%96%E5%AD%98%E5%82%A8%E5%99%A8">外存</a>如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98">硬盘</a>。这使得操作系统可以使用比物理内存更大的存储空间。</li>
</ul>
<h4 id="CR0-Enabling-Features"><a href="#CR0-Enabling-Features" class="headerlink" title="CR0: Enabling Features"></a>CR0: Enabling Features</h4><ol>
<li>通过清除 CR0 控制寄存器中的最低位，可以返回实模式，但这是一项特权操作，以增强安全性和鲁棒性。相比之下，80286 只能通过强制处理器重置来返回实模式，例如由三重故障或使用外部硬件。</li>
<li>控制寄存器 CR0 中的位 0 用 PE 标记，控制分段管理机制的操作，所以把它们称为保护控制位。 PE 控制分段管理机制。 PE=0，处理器运行于实模式； PE=1，处理器运行于保护方式。</li>
<li>是否启用分页由 CR0 的位 31 标记</li>
</ol>
<h4 id="Enabling-Protected-Mode"><a href="#Enabling-Protected-Mode" class="headerlink" title="Enabling Protected Mode"></a>Enabling Protected Mode</h4><p>进入保护模式前，必须初始化 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8">GDT</a>，并最少包含三个描述符：空描述符、CS 描述符以及 DS 描述符。并把（全局描述符表的所占用的字节数-1）和 GDT 的物理地址保存到 GDTR 寄存器中。如果是IBM兼容的机器，则还需要打开 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/A20%E6%80%BB%E7%BA%BF">A20总线</a> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; 设置CR0寄存器的PE位</span><br><span class="line">mov eax, cr0       ; 必须通过其他寄存器来修改CR0寄存器</span><br><span class="line">or eax, 1</span><br><span class="line">mov cr0, eax</span><br><span class="line"></span><br><span class="line">; 远转移 (cs = 代码段描述符)</span><br><span class="line">jmp cs:@pmode</span><br><span class="line"></span><br><span class="line">[bits 32]</span><br><span class="line">@pmode:</span><br><span class="line">; 现在已经进入了保护模式</span><br></pre></td></tr></table></figure>

<h3 id="Virtual-8086-Mode"><a href="#Virtual-8086-Mode" class="headerlink" title="Virtual 8086 Mode"></a>Virtual 8086 Mode</h3><p>80286 开始的保护模式支持<strong>更大的寻址空间</strong>和<strong>一定程度的保护措施</strong>，但是为了<strong>向下兼容</strong>运行在实模式下的软件，仍然保留了实模式（BIOS 工作在实模式，因此在正式启动操作系统之前必须运行在实模式，开始启动的<strong>第一步就是将实模式转换为保护模式</strong>）启动系统之后，80286 的 16 位保护模式，受硬件的限制，不支持分页，多任务支持也有限，因此不能向下兼容实模式的软件，<strong>必须遵循一定的标准将实模式代码重新编译、汇编才能在 16 位的保护模式运行</strong>，这就造成了诸多不便。</p>
<p>80386 开始的 IA-32 架构中，寄存器扩展至 32 位，随之而来的 32 位保护模式较完整，因此可以<strong>在 32 位保护模式直接运行 16 位实模式程序</strong>，也就是虚拟 8086 模式。</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/Bootloader.assets/image-20241219214209871.png" alt="image-20241219214209871"></p>
<ul>
<li>利用健全的多任务机制，多个虚拟 86 程序可以和 32 位程序并发执行，提升效率</li>
<li>利用分页机制，模拟出和 8086 一样的寻址方式，段基址 &lt;&lt; 4 + 段内的偏移地址，寻址空间为1 MB，将不同虚拟 86 程序的地址空间映射到不同的物理地址上，这样每个虚拟86任务看起来都认为自己在 0 ~ 1 MB 的地址空间。</li>
</ul>
<h4 id="Real-mode-Virtual-8086-8086"><a href="#Real-mode-Virtual-8086-8086" class="headerlink" title="Real mode/Virtual 8086/8086"></a>Real mode/Virtual 8086/8086</h4><p>下表可以看出 实模式、8086、虚拟 86 的中断向量表是不完全一致的</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220173857308.png" alt="image-20241220173857308"></p>
<ul>
<li>和实模式、8086相比：</li>
</ul>
<ol>
<li>段描述符加载之后会缓存，加快之后的访存速度</li>
<li>虚拟 8086 模式并不是完美兼容的，因为在 16 位架构里没有保护概念，CPU 也没有特权指令这一说，所以改变段寄存器、直接访问硬件等操作会陷入 OS 或者抛出异常，这就导致这些指令无法正常运行，但也没有办法，为了适应现代操作系统，只能放弃对这些应用的支持。</li>
</ol>
<h3 id="IA-32-Address-Translation"><a href="#IA-32-Address-Translation" class="headerlink" title="IA-32 Address Translation"></a>IA-32 Address Translation</h3><p>在 x86-64 架构下，长模式以外的三种模式也叫做 Legacy Mode </p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/Bootloader.assets/image-20241219214044009-1734615684145-17.png" alt="image-20241219214044009"></p>
<h2 id="Long-Mode-IA-32e-Mode"><a href="#Long-Mode-IA-32e-Mode" class="headerlink" title="Long Mode(IA-32e Mode)"></a>Long Mode(IA-32e Mode)</h2><p>在x86-64 等现代新架构中，长模式是64位操作系统可以访问64位指令和寄存器的模式，有两个子模式。 </p>
<p>64位程序在称为 64-bit Mode 的子模式下运行，32 位和 16 位保护模式程序在称为 Compatibility Mode 的子模式下执行，其允许 64 位操作系统运行现有的 16 位和 32 位 x86 应用程序。 在兼容模式下运行的应用程序使用 32 位或 16 位寻址，并且可以访问前 4 GB 虚拟地址空间。传统 x86 指令前缀在 16 位和 32 位地址和操作数大小之间切换。 与 64 位模式一样，兼容性模式由操作系统在单个代码段的基础上启用。</p>
<p>然而，与 64-bit Mode 不同的是，x86 分段功能与传统 x86 架构中相同，使用 16 位或 32 位保护模式语义。从应用程序的角度来看，兼容模式看起来就像传统的 x86 保护模式环境。然而，从操作系统的角度来看，地址转换、中断和异常处理以及系统数据结构都使用 64 位长模式机制。</p>
<p>删除了 HW Task Switch, TSS 变成一个堆栈表, 不再存储段相关的信息</p>
<h3 id="x86-64-Registers"><a href="#x86-64-Registers" class="headerlink" title="x86-64 Registers"></a>x86-64 Registers</h3><p>x86-64 架构在长模式（64 位模式）下，大部分寄存器位数增加为 64 位，前缀位为 R</p>
<ul>
<li>分段的概念被无限弱化：其中四个段寄存器 CS、SS、DS 和 ES 被强制设置为基地址 0，并且限制为 2^64^ ，形式上还有内存分段，但实际上所有内存都在唯一的一个分段中。</li>
<li>段寄存器 FS 和 GS 仍然可以具有非零基地址，这允许操作系统将这些段用于特殊目的。与传统模式使用的 GDT 机制不同，这些段的基地址存储在特定于模型的寄存器中。 x86-64架构还提供了特殊的 SWAPGS 指令，该指令允许交换内核模式和用户模式基地址。例如，x86-64 上的 Microsoft Windows 使用 FS 段指向线程环境块(TEB)，这是每个线程的一个小型数据结构，其中包含有关异常处理、线程局部变量和其他每线程状态的信息。同样，Linux 内核使用 GS 段来进行类似的线程本地存储(TLS)</li>
</ul>
<p><strong>应用程序编程</strong>使用如下寄存器：</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220183652263.png" alt="image-20241220183652263"></p>
<p>系统编程使用如下寄存器：    </p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220183817147.png" alt="image-20241220183817147"></p>
<h3 id="Address-Translation-1"><a href="#Address-Translation-1" class="headerlink" title="Address Translation"></a>Address Translation</h3><p><img src="C:/Users/Lenovo/Pictures/markdownfile/Bootloader.assets/image-20241219213948185.png" alt="image-20241219213948185"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220183850040.png" alt="image-20241220183850040"></p>
<h3 id="Legacy-Mode"><a href="#Legacy-Mode" class="headerlink" title="Legacy Mode"></a>Legacy Mode</h3><p>以前的模式统称 Legacy Mode</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220184344031.png" alt="image-20241220184344031"></p>
<h1 id="Interrupt-and-Exception-Handling"><a href="#Interrupt-and-Exception-Handling" class="headerlink" title="Interrupt and Exception Handling"></a>Interrupt and Exception Handling</h1><h2 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h2><p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/computer-interrupt1-l.jpg" alt="PPT - BIOS and DOS Interrupts PowerPoint Presentation, free download ..."></p>
<h3 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h3><p>中断可以分为硬件和软件引起的中断</p>
<ul>
<li>硬件中断(Hardware) 通常是 CPU 执行指令过程中收到外部硬件的中断信号，属于外部中断<img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/273421-20210821212504824-517540124.png" alt="img"><ul>
<li>可屏蔽中断：<strong>INTR</strong> 引脚传入，可以通过 <code>IF</code> 标志位屏蔽</li>
<li>不可屏蔽中断：<strong>NMI</strong> 引脚传入(Non-maskable Interrupt)，电源掉电、内存读写错误、总线奇偶校验错误等灾难性的错误，不可屏蔽，CPU 必须立刻处理。有一个专用的中断向量号，一般是不可屏蔽的，这样可以防止嵌套执行，直到 <code>IRET</code> 从中断返回</li>
<li>通过中断控制器从总线读取中断向量，高级可编程中断控制器 <strong>APIC</strong> 可以通过 LINT 引脚接收中断，可以处理 INTR 和 NMI，如果 APIC 禁用则会使用 INTR 和 NMI</li>
<li>CPU 收到硬中断以后需要保存执行现场，转去执行中断服务程序（ISR, Interrupt Service Routine）硬中断是异步、随机、无法预知的。</li>
</ul>
</li>
<li>软件中断(Software) 通常显式调用中断指令触发的中断，属于内部中断<ul>
<li>基础的汇编指令，由指令提供中断向量号 <code>INT n</code> </li>
</ul>
</li>
<li>中断服务程序的最后一条一定是 <code>IRET</code> 指令，恢复原先程序的执行</li>
</ul>
<h3 id="Exception-Processor"><a href="#Exception-Processor" class="headerlink" title="Exception(Processor)"></a>Exception(Processor)</h3><p>异常主要是 CPU 执行指令过程中发现的，属于内部中断,从源头来看，大体分为三类：</p>
<ol>
<li>处理器在执行指令的过程中检测到的程序错误(program error)，比如 <code>zero division</code> </li>
<li>软件生成的异常：<code>INTO, INT1, INT2, INT3, BOUND</code> 指令。有一些异常提供错误码，发生异常需要将错误码压栈，以便正确处理。如果使用 <code>INT n</code> 模拟异常，不会提供错误码，会将 EIP 指令指针错误提供，可能会出现错误。<ul>
<li><code>INTO</code>: Overflow</li>
<li><code>INT3</code>: Breakpoint, debugging</li>
<li><code>BOUND</code>: Bound Range Exceeded</li>
<li><code>UD</code>: Invalid Opcode</li>
</ul>
</li>
<li>还有一些异常源是机器检查（Machine-check）提供的</li>
</ol>
<h2 id="Restart"><a href="#Restart" class="headerlink" title="Restart"></a>Restart</h2><p>下文的 中断/异常处理程序 泛指 处理中断或异常的程序</p>
<ol>
<li><code>Fault</code>: (<strong>RETRY</strong>) 异常处理程序 返回指向 <strong>异常源指令</strong> 的指针，因此将会<strong>重新执行</strong>这条指令。一般是在无法正常通过地址访问到操作数就会触发这种异常，最典型的比如 Page Fault，为了能正确恢复需要 CPU 保存必要的寄存器（上下文）。</li>
<li><code>Trap</code>: (<strong>CONTINUE</strong>) 异常处理程序 返回指向 <strong>异常源的后一条指令</strong> 的指针，因此将会从下一条指令开始，最大特点就是不会影响程序执行的连贯性。比如 INTO 溢出异常，不过这里的下一条指的是逻辑上的下一条，他不一定和异常源相邻。比如执行 JMP 指令，返回的是指向 JMP 目的地的指针。</li>
<li><code>Abort</code>: (<strong>EXIT</strong>) 会影响程序的执行的连贯性，具体来说就是 异常处理程序 不能保证可靠的返回，旨在发生abort异常时收集有关处理器状态的诊断信息，然后尽可能优雅地关闭应用程序和系统。</li>
<li><code>Interrupt</code>: 中断严格支持程序的正确返回，不会影响可靠性与程序执行的连贯性，除非是掉电或者是硬件错误。中断虽然不可预知，但是 CPU 有完善的应对策略：首先，CPU 在每个指令周期都会检查是否有中断，一般是在最后阶段。第二，在开始执行 中断处理程序 之前，一定会保存当时指令执行的现场以便恢复执行，比如 I/O 操作，恢复时执行的指令就是中断前执行的最后一条指令的下一条</li>
</ol>
<h2 id="IDT"><a href="#IDT" class="headerlink" title="IDT"></a>IDT</h2><h3 id="Interrupt-Descriptor-Table"><a href="#Interrupt-Descriptor-Table" class="headerlink" title="Interrupt Descriptor Table"></a>Interrupt Descriptor Table</h3><p><img src="C:/Users/Lenovo/Pictures/markdownfile/Bootloader.assets/image-20241219181455217.png" alt="image-20241219181455217"></p>
<p>中断描述符表是一张用于存储<strong>中断处理程序入口</strong>的表格，每个表项（Entry）是一个中断描述符（Gate Descriptor），用于指明当某个中断或异常发生时，中断/异常处理程序 的入口地址、权限等信息。为了帮助处理异常和中断，需要处理器进行特殊处理的每个体系结构定义的异常和每个中断条件都被分配了一个唯一的标识号，称为中断向量号。处理器使用分配给异常或中断的向量号作为中断描述符表 (IDT) 的索引。该表提供了异常或中断 中断/异常处理程序 的入口点。中断表的索引范围是 0 到 255。</p>
<ul>
<li><p><code>0</code> 到 <code>31</code> 范围内的向量编号由 Intel 64 和 IA-32 体系结构保留，用于体系结构定义的异常和中断。并非所有中断都有相应的处理函数。该范围内未分配的向量编号被保留，不能使用。 </p>
</li>
<li><p><code>32</code> 到 <code>255</code> 范围内的向量编号被指定为用户定义的中断，并且不被 Intel 64 和 IA-32 体系结构保留，这些中断通常分配给外部 I/O 设备，以使这些设备能够通过外部硬件中断机制之一向处理器发送中断。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th><strong>Trap Table</strong></th>
<th><strong>IDT</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>适用范围</strong></td>
<td>较简单的操作系统或教学架构中使用</td>
<td>主要用于 x86 架构的保护模式</td>
</tr>
<tr>
<td><strong>数据结构</strong></td>
<td>简单的映射表</td>
<td>复杂的描述符表，包含地址和其他元信息</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>仅存储中断处理程序地址</td>
<td>支持权限管理、段选择、复杂异常和硬件中断处理</td>
</tr>
<tr>
<td><strong>实现机制</strong></td>
<td>直接使用固定大小的数组存储入口地址</td>
<td>通过描述符表实现，包含段选择子和偏移地址的组合</td>
</tr>
</tbody></table>
<p><strong>CPU 上电后（Real Mode阶段）：</strong> </p>
<ul>
<li>在实模式下，CPU 使用一个简单的中断向量表（Interrupt Vector Table, IVT），这是一个固定位置的内存表，系统刚引导时，内存0x00000到0x0003FF共1KB的空间用于存放中断向量表。每个中断向量占用4个字节，共可存储 256 个中断向量，中断向量表中存储的是异常处理程序的起始地址。</li>
<li>这个 IVT 是 16 位架构的中断处理机制，和 IDT 不同。</li>
</ul>
<p><strong>进入保护模式（Protected Mode）时：</strong> </p>
<ul>
<li>当系统进入保护模式后，操作系统需要配置自己的 IDT，因为保护模式支持更复杂的中断和异常处理。</li>
<li>操作系统初始化过程中会：<ol>
<li>分配一块内存用于存储 IDT。</li>
<li>填充 IDT 条目（包括中断号、处理程序地址、权限等）。</li>
<li>使用 <code>lidt</code> 指令加载 IDT 的基址和限制到 CPU 的 IDTR 寄存器。</li>
</ol>
</li>
</ul>
<p><strong>进入长模式（Long Mode）时：</strong></p>
<ul>
<li>在 64 位模式（长模式）下，IDT 同样需要重新设置，因为长模式支持更复杂的地址模式和更大的描述符。</li>
<li>通常操作系统会重新配置或直接复用保护模式下的 IDT。</li>
</ul>
<p>不过，本质都是中断向量表，本质存储的都是Handler入口</p>
<h3 id="Workflow"><a href="#Workflow" class="headerlink" title="Workflow"></a>Workflow</h3><p><img src="C:/Users/Lenovo/Pictures/markdownfile/Bootloader.assets/image-20241219204336594.png" alt="image-20241219204336594"></p>
<ol>
<li><p><strong>中断或异常发生</strong>：</p>
<ul>
<li>CPU 收到一个中断或异常信号。</li>
<li>信号对应一个中断号（Interrupt Vector），范围是 <code>0-255</code>。</li>
</ul>
</li>
<li><p><strong>查找 IDT</strong>（interrupt Descriptor Table）</p>
<ul>
<li>CPU 从 <strong>IDTR 寄存器</strong> 中读取 IDT 的基地址（起始地址）。</li>
</ul>
</li>
</ol>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220095504456.png" alt="image-20241220095504456"></p>
<ol start="3">
<li><p><strong>跳转到处理程序</strong>：</p>
<ul>
<li><p>根据中断向量在 IDT 中找到对应的 Descriptor (比如中断门和陷阱门)</p>
</li>
<li><p>Descriptor 中存储了 段选择器（Selector）和偏移量用来定位 中断/异常处理程序 的位置、特权级、类型（中断门、陷阱门、任务门等）</p>
</li>
<li><p>CPU 跳转到 中断/异常处理程序 并开始执行中断或异常的处理。</p>
</li>
</ul>
</li>
</ol>
<h3 id="Gate-Descriptors"><a href="#Gate-Descriptors" class="headerlink" title="Gate Descriptors"></a>Gate Descriptors</h3><h4 id="Interrupt-Trap-Gate"><a href="#Interrupt-Trap-Gate" class="headerlink" title="Interrupt/Trap Gate"></a>Interrupt/Trap Gate</h4><p><img src="C:/Users/Lenovo/Pictures/markdownfile/Bootloader.assets/image-20241219204408842.png" alt="image-20241219204408842"></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>中断门(Interrupt Gate)</th>
<th>陷阱门(Trap Gate)</th>
<th align="left">任务门(Task Gate)</th>
</tr>
</thead>
<tbody><tr>
<td>触发来源</td>
<td>硬件中断/软件中断</td>
<td>异常/软件触发</td>
<td align="left">任务切换</td>
</tr>
<tr>
<td>IF 标志位</td>
<td><code>IF</code> 自动清零（关中断）</td>
<td><code>IF</code> 不变（不屏蔽中断）</td>
<td align="left">与任务无关</td>
</tr>
<tr>
<td>跳转目标</td>
<td>中断服务例程</td>
<td>异常或调试服务例程</td>
<td align="left">任务状态段（TSS）</td>
</tr>
<tr>
<td>返回方式</td>
<td><code>IRET</code> 指令</td>
<td><code>IRET</code> 指令</td>
<td align="left">任务切换完成后返回</td>
</tr>
<tr>
<td>典型用途</td>
<td>硬件中断处理</td>
<td>调试、异常处理</td>
<td align="left">多任务</td>
</tr>
</tbody></table>
<h4 id="Call-Gate"><a href="#Call-Gate" class="headerlink" title="Call Gate"></a>Call Gate</h4><p><strong>调用门</strong>(Call Gate)：调用门可以通过 <code>CALL</code> <code>JMP</code> 调用，从一个低特权级代码段跳转到另外一个高特权级的代码段，存在 GDT 和 LDT 中，但从未被实际使用过。对于系统调用的实现来说，这是不方便的并且不是最佳实现。大多数操作系统使用<strong>陷阱门</strong>（Linux 中的 <code>INT 0x80</code> 和 Windows 中的 <code>INT 0x2E</code>）或更强大的 <code>SYSENTER/SYSEXIT</code> 指令来代替调用门</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; CALL 指令与 JMP 指令示例</span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    call 0x10:0x0000      ; 调用子程序 需要返回(my_function)</span><br><span class="line">    jmp  0x18:0x0000      ; 无条件跳转 不需要返回(end_program)</span><br><span class="line"></span><br><span class="line">0x10:0x0000:</span><br><span class="line">    ; 子程序代码</span><br><span class="line">    ret                   ; 返回主程序</span><br><span class="line"></span><br><span class="line">0x18:0x0000:</span><br><span class="line">    ; 程序结束</span><br><span class="line">    mov eax, 1            ; 系统调用号（exit）</span><br><span class="line">    xor ebx, ebx          ; 返回值（0）</span><br><span class="line">    int 0x80              ; TRAP into kernel</span><br></pre></td></tr></table></figure>

<h4 id="Task-Gate"><a href="#Task-Gate" class="headerlink" title="Task Gate"></a>Task Gate</h4><p>详见下文的硬件任务切换</p>
<h2 id="HW-Task-Switch"><a href="#HW-Task-Switch" class="headerlink" title="HW Task Switch"></a>HW Task Switch</h2><h3 id="Task-Gate-1"><a href="#Task-Gate-1" class="headerlink" title="Task Gate"></a>Task Gate</h3><p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220170638814-1734685697132-27.png" alt="image-20241220170638814"></p>
<p>在中断处理过程(IDT)或者在GDT LDT里索引到任务门，会开启硬件任务切换，影响着。</p>
<p><strong>任务门</strong>(Task Gate)：为多任务处理提供<strong>硬件</strong>支持，跳转到 TSS，目前不被使用。</p>
<p><strong>任务状态段</strong>(TSS, Task Status Segment): 保存了任务的执行上下文环境</p>
<h3 id="Task-Status-Segment"><a href="#Task-Status-Segment" class="headerlink" title="Task Status Segment"></a>Task Status Segment</h3><p><strong>TSS Descriptor 的结构，位于 GDT 中：</strong></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220094926788-1734660034533-1.png" alt="image-20241220094926788"></p>
<p>一般 TSS 的 DPL 是小于3的，因为只有操作系统内核才有权调度任务</p>
<hr>
<p><strong>IA-32 TSS 内部的结构</strong>：</p>
<ul>
<li><p>I/O map的基地址， bitmap 本体通常映射到 TSS，通过 bitmap 限制进程对 IO 端口的访问</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220180936358.png" alt="image-20241220180936358"></p>
</li>
<li><p>本进程对应的 LDT Selector</p>
</li>
<li><p>所有的x86普通寄存器：6 个段，8个通用，1 个指令指针，1 个程序状态字</p>
</li>
<li><p>CR3 页表地址</p>
</li>
<li><p>其他特权级别的栈段和栈指针 SS2<del>0 ESP2</del>0 (内核栈)</p>
</li>
<li><p>用于嵌套任务的 link，也就是上一个 父任务的 TSS Selector</p>
</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220001641685.png" alt="image-20241220001641685"></p>
<p><strong>TSS 寻址：</strong></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220001517922-1734684881103-23.png" alt="image-20241220001517922"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220094649039.png" alt="image-20241220094649039"></p>
<hr>
<h3 id="Workflow-1"><a href="#Workflow-1" class="headerlink" title="Workflow"></a>Workflow</h3><p>处理器能够<strong>自动</strong>保存执行上下文，响应来自硬件或软件的请求，恢复另一任务的上下文：</p>
<ol>
<li>显式切换：<code>CALL/JMP tss_selector</code> <code>CALL/JMP task_gate_selector</code></li>
<li>隐式切换：中断/错误处理程序触发</li>
<li>可以通过控制特定的中断向量陷入 IDT 中的特定 Task Gate 来完成跳转，比如<code>INT n</code></li>
<li>嵌套任务的 <code>IRET</code>，EFLAGS 的 <code>NT</code> 标志位(Nested Tasks) 置位用于嵌套任务的跳转。</li>
</ol>
<p>下面为通过 IDT 的 Task Gate 进行任务切换的例子：</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220100119251.png" alt="image-20241220100119251"></p>
<ul>
<li><p>TR 寄存器结构如下：</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220001552753-1734684981103-25.png" alt="image-20241220001552753"></p>
</li>
<li><p>当 依赖 TSS 进行任务切换的时候，CPU 做了以下几件事情：</p>
</li>
</ul>
<ol>
<li><strong>保存现场</strong>：当前 TSS 中所有寄存器值填写到当前的 <strong>TR</strong> 寄存器（task register）指向的 TSS 中</li>
<li><strong>加载新现场</strong>：把新 TSS Selector 载入 <strong>TR</strong> ，<strong>按照一定的检验流程</strong>把新的 TSS 覆盖到寄存器。</li>
<li><strong>开始执行新代码</strong>：新设置的 EIP 指向将要执行的新代码</li>
</ol>
<ul>
<li><strong>缺点</strong>： 受硬件限制较大，且流程繁杂，不灵活也不便于调试</li>
</ul>
<ol>
<li>TSS 只能存在 GDT （最大长度只有 8,192）(TSS+LDT)*2+12=8192,最多 4090 个进程    </li>
<li>算上检验流程要消耗 200 多个时钟周期，全部串行，中间出现一个差错就无法切换成功。</li>
<li>硬件的切换过于重量级，保存完整的上下文，实际上任务切换不一定需要那么多寄存器</li>
</ol>
<p>ex. <strong>嵌套任务切换</strong></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220172753514.png" alt="image-20241220172753514"></p>
<h3 id="SW-Task-Switch"><a href="#SW-Task-Switch" class="headerlink" title="SW Task Switch"></a>SW Task Switch</h3><p><strong>操作系统</strong> 将关键的上下文内容存到类似 PCB 等自由可控的轻量环境中，可以完全控制任务切换逻辑，能够支持指令流水的并行优化技术，更加适合复杂的多任务调度算法，提升性能。</p>
<p>Linux 2.4之前的内核有进程最大数的限制，受限制的原因是，每一个进程都有自已的 TSS 和 LDT。Linux 2.4以后，在同一个CPU上的进程使用同一个 TSS，有效内容只剩下 <code>ESP0</code> 和<code>IO MAP Address</code> </p>
<ul>
<li><code>ESP0</code>: 内核堆栈指针，因为linux完全使用分页，所以SS段没有用处</li>
<li><code>IO bitmap</code>: 控制进程的 I/O 许可</li>
</ul>
<h2 id="Stack-Usage-by-Handler"><a href="#Stack-Usage-by-Handler" class="headerlink" title="Stack Usage by Handler"></a>Stack Usage by Handler</h2><p><strong>有特权级别的转换</strong>（为防止恶意程序,一般会切换，比如系统调用、异常 陷入 OS 的内核模式）:</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220162644295.png" alt="image-20241220162644295"></p>
<p>因为有特权级别切换，因此要根据 TSS 里的内核栈段 SS0 和 ESP0 切换到处理程序自己的栈上，保存好被中断程序原先的 SS 和 ESP，将他的 CS, EIP, EFLAGS 也搬过去，最后将错误码压栈。</p>
<hr>
<p>如果没有特权级别转换，就不会切换执行堆栈，内核中发生了中断或者异常：</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220165159628.png" alt="image-20241220165159628"></p>
<h2 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h2><p><img src="C:/Users/Lenovo/Pictures/markdownfile/Bootloader.assets/image-20241219194949413.png" alt="image-20241219194949413"><img src="C:/Users/Lenovo/Pictures/markdownfile/Bootloader.assets/image-20241219204058993.png" alt="image-20241219204058993"></p>
<h3 id="INTR"><a href="#INTR" class="headerlink" title="INTR"></a>INTR</h3><p>从 0 到 32 的任何向量的中断都可以通过 INTR 引脚传递到处理器，并且从 16 到 32 的任何向量都可以通过本地 APIC 传递。当通过 INTR 引脚模拟异常向量中断(比如 Page Fault)，处理器不会将错误码压栈，因此异常处理程序可能无法正确运行。（和 <code>INT n</code> 的问题一样） </p>
<h4 id="EFLAGS-PSW"><a href="#EFLAGS-PSW" class="headerlink" title="EFLAGS(PSW)"></a>EFLAGS(PSW)</h4><p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220002704824.png" alt="image-20241220002704824"></p>
<h4 id="Masking-maskable-interrupts"><a href="#Masking-maskable-interrupts" class="headerlink" title="Masking maskable interrupts"></a>Masking maskable interrupts</h4><p><img src="C:/Users/Lenovo/Pictures/markdownfile/Bootloader.assets/2f761a5d7cb13f08919db2447c92f0aa.png" alt="在这里插入图片描述"></p>
<ol>
<li><code>STI</code><del>SET</del>, <code>CLI</code><del>CLEAR</del>这两个特权指令可以改变 <code>IF</code> 标志位（位于程序状态字 PSW, aka EFLAGS）控制 CPU 是否能够响应外部中断请求，是多重中断的基本条件，<code>IRET</code>也可以改变</li>
<li><strong>关中断</strong>：将 <code>IF</code> 中断标志位置零，用于保护现场、恢复现场和跳转到 ISR。</li>
<li>在执行 ISR 之前可以<strong>开中断</strong>，执行 ISR 的过程可以被其他中断打断，如果使用中断屏蔽技术(MASK)，就可以实现多重中断，高优先级有权打断低优先级，反之则不行。</li>
<li><strong>中断屏蔽技术</strong>：每个中断可以设置其他中断源的 <code>mask</code> ，被设置为0则被停止执行</li>
</ol>
<h1 id="OS-Booting"><a href="#OS-Booting" class="headerlink" title="OS Booting"></a>OS Booting</h1><p>一些早期的计算机系统，在接收到来自操作人员或外围设备的启动信号后，可以将极少量的固定指令加载到存储器的特定位置，初始化至少一个CPU，然后将CPU指向这些指令并执行指令这些指令通常从一些外围设备（可以由操作员通过开关选择）启动输入操作。其他系统可能会直接向外围设备或 I/O 控制器发送硬件命令，从而执行极其简单的输入操作（例如“将系统设备的扇区 0 读取到从位置 1000 开始的内存中”），从而有效地加载一个小文件。然后开始==链式引导系统启动==。</p>
<p>对于现代操作系统，当计算机关闭时，其软件（包括操作系统、应用程序代码和数据）仍存储在非易失性存储器中。当计算机开机时，它的 RAM 中通常没有操作系统或其加载程序。计算机首先执行存储在 ROM（后来的EEPROM，NOR Flash）中的相对较小的程序（也就是 ==BIOS== 与 ==UEFI==）。该程序支持就地执行，初始化 CPU 和主板，初始化 DRAM（特别是在x86系统上），访问非易失性存储器设备（通常是块寻址设备，例如 NAND Flash、SSD、HDD）或其他可以将操作系统程序和数据加载到 RAM 中的设备（U盘、CD-ROM、甚至是网络设备）此外，该程序还可以初始化显示设备（例如GPU）、文本输入设备（例如键盘）和指针输入设备（例如鼠标）加载到 RAM 中的第一个程序可能不足以加载操作系统，而必须加载另一个更大的程序，它加载的程序称为第二阶段引导加载程序（狭义上的 ==Bootloader==）</p>
<h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h2><p><strong>B</strong>asic <strong>I</strong>nput/<strong>O</strong>utput <strong>S</strong>ystem，基本输入输出系统，主要负责硬件层面的初始化和基本 I/O 管理，目标是找到设备上的 Bootloader，从Bootloader启动操作系统。</p>
<p>早年，BIOS 存储于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ROM">ROM</a>芯片上；现在的 BIOS 多存储于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%96%83%E8%A8%98%E6%86%B6%E9%AB%94">闪存</a>芯片上，这方便了 BIOS 的更新。BIOS 也可从<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E5%8D%A1">网卡</a>等设备启动。</p>
<p>当电脑通电，BIOS 就会从存储器上加载，执行<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E9%9B%BB%E8%87%AA%E6%AA%A2">加电自检</a>（POST），测试和初始化 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CPU">CPU</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8">RAM</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%8E%A5%E8%A8%98%E6%86%B6%E9%AB%94%E5%AD%98%E5%8F%96">DMA</a>控制器、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%99%B6%E7%89%87%E7%B5%84">芯片组</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%8D%B5%E7%9B%A4">键盘</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E7%A2%9F">软盘</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%A2%9F">硬盘</a>等设备。</p>
<p>所有的 Option ROM（扩展 BIOS 程序）被加载后，BIOS 就试图从启动设备（如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%A2%9F">硬盘</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E7%A2%9F">软盘</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%89%E7%A2%9F">光盘</a>）加载 Bootloader，由 Bootloader 加载<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1">操作系统</a>。BIOS 以 16 位<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9C%9F%E5%AF%A6%E6%A8%A1%E5%BC%8F">实模式</a>执行。现代操作系统以<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%9D%E8%AD%B7%E6%A8%A1%E5%BC%8F">保护模式</a>或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%95%BF%E6%A8%A1%E5%BC%8F">长模式</a>执行。</p>
<h3 id="BIOS-Filmware"><a href="#BIOS-Filmware" class="headerlink" title="BIOS Filmware"></a>BIOS Filmware</h3><p>BIOS 本身是汇编语言代码，是在 16 位实模式下执行的，由于 x86-64 是一个高度兼容的<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=100152930&content_type=Article&match_order=1&q=%E6%8C%87%E4%BB%A4%E9%9B%86&zhida_source=entity">指令集</a>，也为了迁就 BIOS 的 16 位实模式的运行环境，所以即使现在的 CPU 都已是 64 位，如果还是在 BIOS 启动（基本见于 09 年以前的主板），在开机时仍然都是在 16 位实模式下执行的。16 位实模式直接能访问的内存只有 1 MB，就算你安了 4G、8G 或者 16 G 还是 32 G 内存，到了 BIOS 上一律只先认前 1 MB。在这 1 M内存中，前 640 K 称为基本内存，后面 384 K 内存留给开机必要硬件和各类 BIOS 本身使用。</p>
<h3 id="BIOS-Setup"><a href="#BIOS-Setup" class="headerlink" title="BIOS Setup"></a>BIOS Setup</h3><p>大约从<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/80386">80386</a> PC开始，个人电脑的 BIOS ROM 集成了设置程序（Setup）。主板的 CMOS 芯片用于存储 BIOS 设置值及硬件侦测值。</p>
<p>现代的 BIOS 可以让用户选择由哪个启动设备启动电脑，如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%89%E7%A2%9F%E6%A9%9F">光盘驱动器</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%A2%9F">硬盘</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E7%A2%9F">软盘</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9A%A8%E8%BA%AB%E7%A2%9F">U盘</a>等等。现代大多数 BIOS 支持图形化交互界面，有一些是厂商制作的，用户可以用鼠标键盘完成操作。</p>
<h4 id="CMOS"><a href="#CMOS" class="headerlink" title="CMOS"></a>CMOS</h4><p>CMOS 是计算机上另一个重要的存储器。之所以提到它，是因为 BIOS 程序的设置值、硬件参数侦测值就保存在 CMOS 中。而且，在 BIOS 程序启动计算机时，需要加载 CMOS 中的设置值。CMOS 通常被集成在南桥芯片组中。UEFI 系统则多用 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/NVRAM">NVRAM</a> 存储设置。</p>
<ul>
<li>BIOS 芯片属于 ROM ，不需要供电保存信息，其中存储的是固件（filmware，程序代码）</li>
<li>CMOS 芯片属于 RAM，内容在断电会消失，存储的是普通信息。主板上的钮扣电池用于让 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CMOS">CMOS </a>存储 BIOS 设置值，以及电脑在断电时依然可以让系统时钟运作。把<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E6%A9%9F%E6%9D%BF">主板</a>的电池拆出，便可重置其内容，拆出电池也会重置系统时钟。</li>
</ul>
<h3 id="Pre-booting"><a href="#Pre-booting" class="headerlink" title="Pre-booting"></a>Pre-booting</h3><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>先进行 CPU 初始化：当按下电源开关时，电源就开始向主板和其他设备供电，这时电压还不稳定，在早期的南北桥主板上，由主板北桥向CPU发复位信号，对CPU初始化；稳定电压后复位信号便撤掉。而对于现在的单南桥主板，则由CPU自身调整稳定电压达到初始化的目的，当电压稳定后，CPU 便在系统BIOS保留的内存地址处执行跳转 BIOS 起始处指令，开始执行 POST 自检。</p>
<p><strong>加电自检</strong>(POST, Power-On Self Test)是计算机 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/BIOS">BIOS</a> 的一个重要功能，主要用于在 BIOS 加载操作系统之前检查计算机设备硬件是否存在问题，进而保证计算机的正常运行。在设备启动的过程中，自检程序主要检查<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CPU">CPU</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8">内存</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/I/O">I/O设备</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E6%9D%BF">主板</a>等对计算机正常运行会产生影响的设备硬件。</p>
<p>在POST自检中，BIOS 只检查系统的必要核心硬件是否有问题，主要是 CPU、640K基本内存、显卡是否正常，PS/2 键盘控制器、系统时钟是否有错误等等。由于 POST 检查在显卡初始化以前，因此在这个阶段如发生错误，是无法在屏幕上显示的，不过主板上还有个报警扬声器，而且如果主板的 8255 外围可编程接口芯片没有损坏的话，POST报警声音一定是会出来的。可以根据报警声的不同大致判断错误所在，一般情况下，一声短“嘀”声基本代表正常启动，不同的错误则是不同的短“嘀”声和长“嘀”声组合。POST 自检结束后，BIOS 开始调用中断完成各种硬件初始化工作。</p>
<h4 id="BIOS-Interrupt-Call"><a href="#BIOS-Interrupt-Call" class="headerlink" title="BIOS Interrupt Call"></a>BIOS Interrupt Call</h4><p><img src="C:/Users/Lenovo/Pictures/markdownfile/OS%20Extra.assets/image-20241220173802326.png" alt="image-20241220173802326"></p>
<p>与中断相对的是轮询（polling）<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jadeshu/p/10663505.html">中断向量表 - jadeshu - 博客园</a> </p>
<p><strong>CPU 上电后（实模式阶段）：</strong> </p>
<ul>
<li>在实模式下，CPU 使用一个简单的中断向量表（Interrupt Vector Table, IVT），这是一个固定位置的内存表，系统刚引导时，内存0x00000到0x0003FF共1KB的空间用于存放中断向量表。每个中断向量占用4个字节，共可存储256个中断向量，中断向量表中存储的是异常处理程序的起始地址。这个 IVT 是 16 位架构的中断处理机制，和 IDT 不同。</li>
</ul>
<p><strong>进入保护模式（Protected Mode）或长模式（Long Mode）时：</strong> </p>
<ul>
<li>当系统进入保护模式后，操作系统需要配置自己的 IDT，因为保护模式支持更复杂的中断和异常处理。</li>
<li>操作系统初始化过程中会：<ol>
<li>分配一块内存用于存储 IDT。</li>
<li>填充 IDT 条目（包括中断号、处理程序地址、权限等）。</li>
<li>使用 <code>lidt</code> 指令加载 IDT 的基址和限制到 CPU。</li>
</ol>
</li>
</ul>
<p>BIOS 可通过 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/BIOS%E4%B8%AD%E6%96%B7%E5%91%BC%E5%8F%AB">BIOS 中断调用</a>为 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MS-DOS">MS-DOS</a> 操作系统及 MS-DOS 程序提供磁盘、键盘、显示等标准服务。通过 BIOS 中断调用访问视频硬件非常缓慢。许多现代操作系统（如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Windows">Windows</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Linux">Linux</a>）的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%95%9F%E5%8B%95%E7%A8%8B%E5%BC%8F">启动程序</a>(Bootloader)会使用 BIOS 中断调用加载内核，然后由<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8">内核</a>将处理器从16位<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9C%9F%E5%AF%A6%E6%A8%A1%E5%BC%8F">实模式</a>转换到32位<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%9D%E8%AD%B7%E6%A8%A1%E5%BC%8F">保护模式</a>（或64位<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%95%BF%E6%A8%A1%E5%BC%8F">长模式</a>）</p>
<p>在INTEL后续的32位CPU中，使用中断描述符表 IDT 来代替中断向量表 IVT。中断描述符表的起始地址由中断描述符表寄存器（IDTR）来定位，因此不再限于底部1K位置。另一方面，中断描述符表的每一个项目——称作门描述符——除了含有中断处理程序地址信息外，还包括许多属性／类型位。门描述符分为三类：任务门、中断门和自陷门。CPU对不同的门有不同的调用（处理）方式。</p>
<h4 id="HW-Initialization"><a href="#HW-Initialization" class="headerlink" title="HW Initialization"></a>HW Initialization</h4><p>硬件初始化工作是通过 BIOS 中断调用实现的，经过POST检测后，电脑终于出现了开机启动画面，这就是已经检测到了显卡并完成了初始化。但是请注意，由于BIOS是在16位实模式运行，因此该画面是以VGA分辨率（640*480，纵横比 4:3）显示的，因为实模式最高支持的就是 VGA。以前的小 14-17 寸CRT显示器由于都是 4:3 比例，最高分辨率也比较低，因此这个开机启动画面没有什么违和感，但现在的液晶显示器基本上都是宽屏 16:9 的，分辨率也较高，因此在这样的显示屏下，启动画面上的一切东西显示都可以说“惨不忍睹”——图形被拉长，字体很大很模糊，可以很明显看到显示字体的锯齿。</p>
<h3 id="Bootloader-Location"><a href="#Bootloader-Location" class="headerlink" title="Bootloader Location"></a>Bootloader Location</h3><p>引导启动的过程也是使用 BIOS 中断调用，因为 BIOS 处在实模式，Bootloader 才能切换模式</p>
<p>BIOS 根据 Setup 中用户指定的硬件启动顺序，如果将启动顺序设为“第一：DVD 驱动器；第二：硬盘驱动器”，固件会先尝试从 DVD 驱动器启动，再尝试从本地的硬盘驱动器启动。BIOS 负责硬件和软件间的相互通信。如果发现所有硬件都没有能引导操作系统的记录，则会在屏幕上显示相应错误信息（NO ROM BASIC）将电脑维持在 16 位实模式。BIOS 只识别到由主引导记录（MBR）初始化的硬盘。</p>
<h4 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h4><p>主引导扇区，Master Boot Record，BIOS 检查时会把硬盘最初一个扇区(MBR)加载到内存中。</p>
<p>它在硬盘上的三维地址(CHS 地址)为（柱面，磁头，扇区）＝（0，0，1）</p>
<p>MBR 位于磁盘的第一个扇区（LBA 0），其大小为 <strong>512 字节</strong>，划分如下：</p>
<ul>
<li><strong>前 446 字节</strong>: 引导代码（Bootloader Code）</li>
<li><strong>接下来的 64 字节</strong>: 分区表（DPT, Disk Partition Table），记录最多 4 个主分区的信息</li>
<li><strong>最后的 2 字节</strong>: 魔数（Signature, 0x55AA），表示这是一个有效的 MBR。</li>
</ul>
<p>BIOS 硬件检查方式：这个存储设备的前 512 字节是不是以0x55 0xAA(10101010,01010101)结尾？如果不是就按照顺序检查下一个，如果是就加载这 512 字节内部的引导代码，然后执行它。</p>
<p>MBR 最开头是第一阶段引导代码。主要作用是在检查分区表是否正确和在系统硬件完成自检以后，在活跃分区的 PBR 找到并执行 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F">Bootloader</a> 主程序（如 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GNU_GRUB">GNU GRUB</a>），不依赖任何操作系统，而且启动代码也是可以改变的，从而能够实现<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%9A%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC&action=edit&redlink=1">多系统引导</a>  </p>
<p>MBR 还记录着硬盘本身的相关信息以及硬盘各个分区的大小及位置信息（分区表），是数据信息的重要入口。如果它受到破坏，硬盘上的基本数据结构信息将会丢失，需要用繁琐的方式试探性的重建数据结构信息后才可能重新访问原先的数据。因为 512B 的限制，分区表也有限制，MBR 支持最大卷为2 TB（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Terabyte">Terabyte</a>s）并且每个磁盘最多有4个主分区（或3个主分区，1个扩展分区和无限制的逻辑驱动器）</p>
<h4 id="Sector-amp-LBA"><a href="#Sector-amp-LBA" class="headerlink" title="Sector &amp; LBA"></a>Sector &amp; LBA</h4><p>在 GPT 分区中，每一个数据读写单元成为 LBA（逻辑块地址），一个“逻辑块”相当于传统 MBR 分区中的一个“扇区”，之所以会有区别，是因为GPT除了要支持传统硬盘，还需要支持以 NAND FLASH 为材料的 SSD 硬盘。</p>
<p>不像磁盘那样有磁片，而磁片又划分磁道和扇区来保存数据，因此，闪存材料需要采用模拟扇区来保持统一性。这些硬盘的一个读写单元是 2KB 或 4KB，所以，GPT 分区中干脆用 LBA 来表示一个基础读写块，当 GPT 分区用在传统硬盘上时，通常，LBA 就等于扇区号，有些物理硬盘支持 2KB 或 4KB 对齐，此时，LBA 所表示的一个逻辑块就是 2KB的空间，为了方便，我们后面仍然将逻辑块称为扇区。</p>
<p>以 CHS 寻址的硬盘， 最高容量是 512×63×256×1024=8064 MiB，BIOS 使用的是 LBA 寻址</p>
<h2 id="UEFI"><a href="#UEFI" class="headerlink" title="UEFI"></a>UEFI</h2><p>作为 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/BIOS">BIOS </a>的替代方案，可扩展固件接口 UEFI 负责 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E9%9B%BB%E8%87%AA%E6%AA%A2">加电自检</a>（POST）、联系操作系统以及提供连接操作系统与硬件的接口。前身是 EFI</p>
<h3 id="EFI"><a href="#EFI" class="headerlink" title="EFI"></a>EFI</h3><p>虽然 BIOS 作为电脑加电启动所必不可少的部分，但是从其于 1975 年诞生之日起近 30 余年，16 位汇编语言代码，1 M 内存寻址，调用中断一条条执行的理念和方式竟然一点都没有改变，虽然经各大主板商不懈努力，BIOS 也有了 ACPI、USB 设备支持，PnP 即插即用支持等新东西，但是这在根本上没有改变 BIOS 的本质，而英特尔为了迁就这些旧技术，不得不在一代又一代处理器中保留着 16 位实模式，否则根本无法开机。英特尔推出了可扩展固件接口(EFI, Extensible Filmware Interface) 和后继的 UEFI(Unified EFI) ，是现在电脑的主要预启动环境。</p>
<h4 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h4><ol>
<li>摒弃 16 位实模式，完全是 32 位或 64 位模式，在 EFI 中可以实现处理器的最大寻址，因此可以在任何内存地址存放任何信息</li>
<li>模块化，C 语言风格的参数堆栈传递方式，动态链接的形式构建的系统，通用性和兼容性较好，在 EFI 驱动环境(DXE)中解释执行 EFI 字节码（虚拟机器指令）写成的 EFI 驱动，识别系统硬件并完成硬件初始化。EFI 的驱动开发非常简单，基于 EFI 的驱动模型原则上可以使 EFI 接触到所有硬件功能</li>
<li>和 OS 相比，EFI 没有中断访问机制，只能轮询</li>
<li>只有简单的存储器管理机制，在段保护模式下只将存储器分段，所有程序都可以存取任何一段位置，不提供真实的保护服务。</li>
<li>支持 GPT 分区模式</li>
<li>区分不同的开机模式，向前兼容模式(Legacy) 可以启动 16 和 32 位的操作系统，采用64位UEFI固件的PC，在UEFI 开机模式下只能执行64位操作系统启动程序</li>
</ol>
<h4 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h4><p><strong>全局唯一标识分区表</strong> GUID Partition Table，使用通用唯一标识符(也称为全局唯一标识符(GUID))对物理计算机存储设备(例如硬盘驱动器或固态驱动器)的分区表进行布局</p>
<p>在MBR硬盘中，分区信息直接存储于主引导扇区中（其中还存储着引导 Bootloader 的引导代码）但在GPT硬盘中，分区表的位置信息储存在GPT头中。出于兼容性考虑，硬盘的第一个扇区仍然用作 MBR，之后才是 GPT 头。为了减少分区表损坏的风险，GPT在硬盘最后保存了一份分区表的副本。其中的 EFI 系统分区可以被 EFI 存取，用来存取部分驱动和应用程序。</p>
<img src="C:/Users/Lenovo/Pictures/markdownfile/Read.assets/1024px-GUID_Partition_Table_Scheme.svg.png" alt="undefined" style="zoom: 33%;" />

<p>GPT分区表的结构。此例中，每个逻辑块（LBA）为512字节，每个分区的记录为128字节。负数的LBA地址表示从最后的块开始倒数，−1表示最后一个块。</p>
<p><strong>保护性 MBR（Protective MBR）</strong></p>
<ul>
<li><strong>位置</strong>: 分区表的第一个扇区（LBA 0）。</li>
<li><strong>作用</strong>: 这是兼容性区域，用于保护 GPT 磁盘免受旧式 MBR 工具的意外覆盖。保护性 MBR 声明整个磁盘为一个分区，以阻止不支持 GPT 的软件误将磁盘视为未分区。</li>
</ul>
<p><strong>GPT 标头（GPT Header）</strong> </p>
<ul>
<li><strong>位置</strong>: 磁盘的第一个逻辑块地址（LBA 1）。</li>
<li><strong>作用</strong>: 包含 GPT 的全局信息，包括分区表的起始位置、大小和校验和。</li>
</ul>
<p><strong>分区条目表（Partition Entries）</strong></p>
<ul>
<li><strong>位置</strong>: 通常从 LBA 2 开始，连续占用一定数量的扇区。</li>
<li><strong>作用</strong>: 存储每个分区的详细信息，包括分区类型、GUID、起始和结束地址。</li>
</ul>
<p><strong>引导分区（EFI System Partition, ESP）</strong></p>
<ul>
<li><strong>位置</strong>: 通常是 GPT 分区中专门指定的一部分（由 EFI 分区条目指定）</li>
<li><strong>作用</strong>: 用于存储 Bootloader EFI 文件、操作系统引导管理器，以及其他必要的启动文件。EFI 系统分区可以位于任何地方，只要分区条目中有正确的指向即可。实际上是一个FAT32文件系统</li>
<li><strong>固定 GUID</strong>: <code>C12A-7328-F81F-11D2-BA4B-00A0-C93E-C93B</code></li>
</ul>
<p><strong>备份 GPT 数据</strong></p>
<ul>
<li><strong>位置</strong>: 通常在磁盘的最后几个逻辑块地址（倒数第一个扇区存储备份 GPT Header，倒数第二个扇区起存储备份分区条目）。</li>
<li><strong>作用</strong>: 用于恢复主 GPT 数据结构。</li>
</ul>
<h4 id="UEFI-Optimization"><a href="#UEFI-Optimization" class="headerlink" title="UEFI Optimization"></a>UEFI Optimization</h4><ol>
<li>拥有完整的图形驱动。EFI多数还是一种类DOS界面（仍然是640*480VGA分辨率），只支持PS/2键盘操作（极少数支持鼠标操作）。无论是PS/2还是USB键盘和鼠标，UEFI一律是支持的，而且UEFI在显卡也支持GOP VBIOS的时候，显示的设置界面是显卡高分辨率按640*480或1024*768显示</li>
<li>安全启动。固件验证：根据硬件签名对各硬件判断，只有符合认证的硬件驱动才会被加载</li>
</ol>
<h3 id="Pre-booting-1"><a href="#Pre-booting-1" class="headerlink" title="Pre-booting"></a>Pre-booting</h3><img src="C:/Users/Lenovo/Pictures/markdownfile/Read.assets/Efi_flowchart_extended.jpg" alt="undefined" style="zoom: 67%;" />

<h4 id="POST-1"><a href="#POST-1" class="headerlink" title="POST"></a>POST</h4><p>当打开电源开关时，电脑的主要部件都开始有了供电，与 BIOS 不同的是，UEFI 预加载(Pre-EFI)环境首先开始执行，负责 CPU 和内存（是全部容量）的初始化工作，这里如出现重要问题，电脑即使有报警喇叭也不会响，因为 UEFI 没有去驱动 8255 发声，不过预加载环境只检查 CPU 和内存，如果这两个主要硬件出问题，屏幕没显示可以立即确定，另外一些主板会有提供LED提示，可根据CPU或内存亮灯大致判断故障。</p>
<h4 id="HW-Initialization-1"><a href="#HW-Initialization-1" class="headerlink" title="HW Initialization"></a>HW Initialization</h4><p>CPU 和内存初始化成功后，驱动执行环境（DXE）载入，当 DXE 载入后，UEFI 就具有了逐个加载UEFI 驱动的能力，在此阶段，UEFI 会迭代搜索各个硬件的 UEFI 驱动并相继加载，加载各种总线（包括PCI、SATA、USB、ISA）及硬件的 UEFI 驱动程序，完成硬件初始化工作，这相比 BIOS 的中断速度会快的多，同样如加载显卡的 UEFI 驱动成功，电脑也会出现启动画面，硬件驱动全部加载完毕后，最后同 BIOS 一样，去寻找硬盘上的操作系统的引导启动程序。</p>
<p>UEFI 应用程序（UEFI Application）和 UEFI 驱动程序（UEFI driver）是 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E5%8F%AF%E6%89%A7%E8%A1%8C">PE格式</a> 的<code>.efi</code>文件，可用C语言编写。</p>
<h3 id="Bootloader-Location-1"><a href="#Bootloader-Location-1" class="headerlink" title="Bootloader Location"></a>Bootloader Location</h3><p>UEFI 引导管理程序可以直接从支持的文件系统（如FAT32）中读取启动文件，而不依赖硬件中断和传统的16位服务调用，UEFI 整体就处在保护模式或者长模式下。</p>
<p>在启动操作系统的阶段，同样是根据启动记录的启动顺序，转到相应设备（GPT）引导记录，引导操作系统并进入，在 UEFI 开机模式下，Bootloader 本身也是 UEFI 应用程序，其 EFI 文件存储在 EFI 系统分区（ESP）</p>
<p>这里需要注意的是，UEFI 在检测到无任何操作系统启动设备时，会直接进入 UEFI 设置页面，而不是像 BIOS 那样黑屏显示相关信息。</p>
<p>如果启动传统 MBR 设备，则需要打开 CSM 支持。</p>
<h2 id="Legacy-MBR"><a href="#Legacy-MBR" class="headerlink" title="Legacy + MBR"></a>Legacy + MBR</h2><p><strong>MBR+Legacy</strong> 是通过引导代码指向 <strong>Bootloader</strong> 文件.</p>
<ul>
<li><p><strong>Windows</strong>: </p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/Read.assets/1460000020850912-1734487610917-44.png" alt="image"></p>
<ul>
<li><p>Windows 中根据 MBR 分区表指向活跃分区记录 PBR，这里启动系统用的分区和真正装系统的分区不一定在一起，Windows 的 PBR 可以识别 FAT32 和 NTFS 两种分区，找到分区根目录的 bootmgr 文件，并加载、执行 bootmgr。</p>
</li>
<li><p>bootmgr 没有 MBR 和 PBR 的大小限制，可以做更多的事，它会加载并分析BCD启动项存储，而且 bootmgr 可以跨越磁盘读取文件。所以无论我们有几个磁盘，在多少块磁盘上装了 Windows，一个电脑只需要一个 bootmgr 就行了。bootmgr 会去加载某磁盘某 NTFS 分区的 <code>\Windows\System32\WinLoad.exe</code>，然后，由 <code>WinLoad.exe</code> 启动 Windows (<code>ntoskrnl.exe</code>) 系统分区和启动分区可能不是位于同一分区。</p>
</li>
</ul>
</li>
<li><p>Linux:</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/Read.assets/v2-709d9b2f76d718894bcc04c706986fcf_1440w-1734485433191-9-1734487325852-39-1734487632482-49.jpg" alt="img"></p>
<ul>
<li><p>写入 0 号扇区的 446 字节是第一阶段，其作用就是用来找到和加载真正的Grub bootloader主程序，也就是位于操作系统启动分区的Grub2第二阶段的程序。而且受限于446字节的大小，这个阶段的stage1 binary是不包含文件系统功能 对应 boot.img</p>
</li>
<li><p>被加载Stage1加载后，解析/boot/grub2/grub.cfg配置文件，跟据该配置文件的定义，显示多系统的启动选择界面，或者直接加载Linux kernel和文件系统，然后就由Kernel来启动后续的过程。Grub2 Stage2的镜像对应于core.img，位置为/boot/grub2/i386-pc目录下。</p>
</li>
</ul>
</li>
</ul>
<h2 id="UEFI-GPT"><a href="#UEFI-GPT" class="headerlink" title="UEFI + GPT"></a>UEFI + GPT</h2><p>**GPT+UEFI **没有明显的引导代码指向 Bootloader EFI 文件</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/Read.assets/1460000020850915.png" alt="image"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/Read.assets/1460000020850916-1734486587950-27.png" alt="image"></p>
<p>GPT 直接把 Bootloader 存到 EFI 分区</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>MBR + Legacy</th>
<th>GPT + UEFI</th>
</tr>
</thead>
<tbody><tr>
<td>代码位置</td>
<td>磁盘第一个扇区 (LBA 0)</td>
<td>EFI 分区</td>
</tr>
<tr>
<td>引导文件</td>
<td>BIOS 引导代码</td>
<td>支持 EFI 格式文件 (.efi)</td>
</tr>
<tr>
<td>机制</td>
<td>根据引导代码启动 Bootloader</td>
<td>UEFI 直接去读取并运行 Bootloader</td>
</tr>
<tr>
<td>代码大小</td>
<td>446 字节 非 Bootloader 本身</td>
<td>Bootloader，上限取决于 EFI 分区大小</td>
</tr>
<tr>
<td>Bootloader</td>
<td>MBR 同时存储分区表和引导代码，Bootloader 在其他位置</td>
<td>GPT 分区表 存储分区信息，ESP 分区直接存储 Bootloader</td>
</tr>
</tbody></table>
<p>Legacy 无法识别 GPT 分区表格式，所以也就没有 Legacy + GPT 组合方式。</p>
<p>UEFI 可同时识别 MBR 分区(开启 CSM 模式)和 GPT 分区，所以在 UEFI 下，MBR 和 GPT 磁盘都可用于启动操作系统。不过由于微软限制，UEFI 下使用 Windows 安装程序安装操作系统是只能将系统安装在 GPT 磁盘中。</p>
<h2 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h2><p>加载到 RAM 中的第一个程序可能不足以加载操作系统，而必须加载另一个更大的程序。第一个加载到 RAM 中的程序称为第一阶段引导加载程序（BIOS、UEFI），它加载的程序称为第二阶段引导加载程序（狭义上的 Bootloader）</p>
<p>Bootloader 有 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/GNU_GRUB">GNU GRUB</a>、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/REFInd">rEFInd</a>、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SYSLINUX">Syslinux</a>、Windows 的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/BOOTMGR">BOOTMGR</a>、 和 Windows NT/2000/XP 的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/NTLDR">NTLDR</a> 等，它们本身不是操作系统，但能够正确加载操作系统并将 CPU 控制权转移到它;操作系统随后会自行初始化并可能加载额外的设备驱动程序。</p>
<p>Bootloader 不需要驱动程序来进行自身操作，可以使用系统固件（例如 BIOS、UEFI 或开放固件）提供的通用存储访问方法，但通常硬件功能有限且性能较低。</p>
<p>许多 Bootloader 可以配置为给用户提供多种引导选择。这些选择可以包括不同的操作系统（用于从不同分区或驱动器进行双重或多重引导）、同一操作系统的不同版本（以防新版本出现意外问题）、不同的操作系统加载选项（例如，引导至不同的操作系统）、安全模式），以及一些无需操作系统即可运行的独立程序，例如内存测试程序（例如 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memtest86%2B">memtest86+</a>）、基本 shell（如 GNU GRUB 中），甚至游戏。</p>
<p>一些 Bootloader 可以加载其他 Bootloader，例如，GRUB 可以加载 BOOTMGR 而不是直接加载 Windows。通常，默认选择是预先选择的，并有一定的时间延迟，在此期间用户可以按某个键来更改选择；在此延迟之后，默认选择将自动运行，因此无需交互即可正常启动。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2025/01/05/L2%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/05/L2%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/" class="post-title-link" itemprop="url">网络层</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-05 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-05T00:00:00+08:00">2025-01-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-03 20:58:14" itemprop="dateModified" datetime="2025-05-03T20:58:14+08:00">2025-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h1><h2 id="家用无线路由器组网示意图"><a href="#家用无线路由器组网示意图" class="headerlink" title="家用无线路由器组网示意图"></a>家用无线路由器组网示意图</h2><p>通过ADSL或者FTTx与ISP相连</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241124141658211.png" alt="image-20241124141658211"></p>
<h2 id="网络层提供不可靠的传输服务"><a href="#网络层提供不可靠的传输服务" class="headerlink" title="网络层提供不可靠的传输服务"></a>网络层提供不可靠的传输服务</h2><h3 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h3><p>先建立起虚电路（Virtual Circuit）通过虚电路的存储转发搭配可靠的协议建立起可靠的服务。</p>
<h3 id="无连接的数据报服务"><a href="#无连接的数据报服务" class="headerlink" title="无连接的数据报服务"></a>无连接的数据报服务</h3><p>因为计算机本身有强大的计算功能，因此完全可以将可靠的传输交给终端主机本身去做，网络层设计得尽量简单，向上提供简单的，无连接的，尽最大努力交付的数据报服务(datagram/packet) 不保证分组一定到达，到达也不保证顺序就是发送的顺序。</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/91fbdd548f6b4e86d639649f7aae4c30.jpg" alt="91fbdd548f6b4e86d639649f7aae4c30"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/87d7a972d7095f0f2bcf894527d05dd1.jpg" alt="87d7a972d7095f0f2bcf894527d05dd1"></p>
<h2 id="网络层的两个层面"><a href="#网络层的两个层面" class="headerlink" title="网络层的两个层面"></a>网络层的两个层面</h2><ul>
<li><strong>控制层面</strong>：负责维护路由表，和其他路由节点进行路由数据交互。典型协议就是各种路由选择协议（OSPF、BGP）</li>
<li><strong>数据层面</strong>：负责根据路由表将 分组/数据报 转发到其他路由器。典型协议就是IP</li>
<li><strong>SDN</strong>：软件定义网络，将控制层面用一个远程控制器实现，路由器只需要做转发数据报的工作就可以了。</li>
</ul>
<h1 id="IP（Internet-Protocol）"><a href="#IP（Internet-Protocol）" class="headerlink" title="IP（Internet Protocol）"></a>IP（Internet Protocol）</h1><p>各个局域网通过路由器相互连接称为一个虚拟的互联网，internet</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/internet_protocol_ip_address_diagram.png" alt="IP 地址使数据包到达其目的地"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/256851fcb6cde44eb5d73863a00da8b2-1732450187866-2.jpg" alt="256851fcb6cde44eb5d73863a00da8b2"></p>
<h2 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h2><p>IPv4 32位 有网络号和主机号两个部分，网络号唯一标识互联网中的一个网络，主机号表示网络中的一台设备（网络号+主机号才能唯一确定一台设备）</p>
<h3 id="ABC-分类地址"><a href="#ABC-分类地址" class="headerlink" title="ABC 分类地址"></a>ABC 分类地址</h3><p>网络号分别是前8位，前16位，前24位，随着互联网用户暴涨，固定的分类方法显然已经无法满足需求。</p>
<h3 id="无类别域间路由-Classless-Inter-Domain-Routing-CIDR"><a href="#无类别域间路由-Classless-Inter-Domain-Routing-CIDR" class="headerlink" title="无类别域间路由(Classless Inter-Domain Routing,==CIDR==)"></a>无类别域间路由(Classless Inter-Domain Routing,==<strong>CIDR</strong>==)</h3><ul>
<li>不采用固定分类的做法，把网络前缀的位数放到最后。</li>
<li>网络前缀完全相同的处于同一个CIDR地址块中。</li>
<li>128.14.35.7/20 表示网络号是前20位。</li>
<li>原先的分类地址法只能分出3级8/16/24，较为死板和浪费，B类地址也无法表示C类地址，导致路由表的膨胀。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.0/24</span><br><span class="line">192.168.1.0/24</span><br><span class="line">192.168.2.0/24</span><br></pre></td></tr></table></figure>

<ul>
<li>路由聚合：这3个地址块可以用192.168.0.0/22概括起来，多个子网的地址具有相同的前缀，便于聚合。</li>
</ul>
<h3 id="子网掩码（subnet-mask）"><a href="#子网掩码（subnet-mask）" class="headerlink" title="子网掩码（subnet mask）"></a>子网掩码（subnet mask）</h3><p>告诉计算机网络前缀的位数，128.14.35.7/20的子网掩码是255.255.240.0（二进制比点分十进制更加直观）子网掩码和主机的IP地址进行按位与运算结果即为网络地址。子网是在一个IP网络中划分子网使我们能将一个至少从逻辑上看上去单一的大型网络分成若干个较小的网络。而主机必须知道自己的IP地址，也要知道自己处于哪一个网段，因此mask就诞生了</p>
<h3 id="Facts-about-IP-address"><a href="#Facts-about-IP-address" class="headerlink" title="Facts about IP address"></a>Facts about IP address</h3><ul>
<li>IP地址实质上是对接口指派地址，路由器有多个接口，说明接入到多个网络中，准确转发到多个网络中需要根据IP。</li>
<li>同一局域网的主机IP网络前缀相同，网络地址的主机号必须全0。</li>
<li>路由器必须处在不同网络中，必须有大于等于2个IP地址，两台交换机互连仍在同一网络中。</li>
<li>交换机只有MAC地址，没有IP地址。</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241124133937330.png" alt="image-20241124133937330"></p>
<h3 id="匿名网络（Anoymous-Unnumbered-Network）"><a href="#匿名网络（Anoymous-Unnumbered-Network）" class="headerlink" title="匿名网络（Anoymous/Unnumbered Network）"></a>匿名网络（Anoymous/Unnumbered Network）</h3><ul>
<li><p>从网络层的严格定义来说，<strong>网络层主要负责不同网络之间的路由和转发</strong>。路由器用了几个接口就表示接到几个网络</p>
</li>
<li><p>即使路由器间直接相连，也需要抽象为一个点对点网络（匿名网络）不过通常为了节省资源，并不分配IP地址</p>
</li>
<li><p>A为公网<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/0?fromModule=lemma_inlink">主机</a>，D为拥有公网IP的主机，通信过程为A－B－C－D，B和C用unnumbered，没有必要占用两个ip地址了，让B、C间的口借用另一边口的地址，这样B和C就只是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%93%BE%E8%B7%AF%E5%B1%82/0?fromModule=lemma_inlink">链路层</a>连接[ip unnumber_百度百科](<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ip">https://baike.baidu.com/item/ip</a> unnumber/4480818) 。如果两台路由器之间还有一个拥有主机的网络E，就必须给接口指派一个网络E的地址。</p>
</li>
</ul>
<h1 id="地址解析协议（Address-Resolution-Protocol-ARP）"><a href="#地址解析协议（Address-Resolution-Protocol-ARP）" class="headerlink" title="地址解析协议（Address Resolution Protocol, ARP）"></a>地址解析协议（Address Resolution Protocol, ARP）</h1><ul>
<li><p>网络层基于IP地址（虚拟地址），主机A有IP<del>1</del>= 192.168.38.10， 主机B有IP<del>2</del>=192.168.38.11 </p>
</li>
<li><p>下层为上层提供服务，所以上层可以不用管下层的实现细节，体现在：主机只需要一个包含源IP和目标IP的数据报即可交给网卡开始传输。实际上数据链路层的网卡要根据IP<del>2</del>解析出应该发给哪个MAC地址，以便构造以太网帧时填入目标MAC地址。<strong>ARP</strong>就提供了IP地址到MAC地址的映射。</p>
</li>
</ul>
<h2 id="ARP-高速缓存（ARP-Cache）"><a href="#ARP-高速缓存（ARP-Cache）" class="headerlink" title="ARP 高速缓存（ARP Cache）"></a>ARP 高速缓存（ARP Cache）</h2><p>这是主机中的一个映射表，缓存了IP-&gt;MAC的关系，经常动态变换，所以也叫 ARP 高速缓存</p>
<ul>
<li><p>刚刚上电，ARP Cache为空，此时就要发送一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE#ARP%E6%8A%A5%E6%96%87">ARP报文</a>（<strong>广播</strong>帧 ARP request），目标MAC地址是“FF.FF.FF.FF.FF.FF”，这表示向<strong>同一网段内</strong>的所有主机发出这样的询问：“192.168.38.11的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MAC%E5%9C%B0%E5%9D%80">MAC地址</a>是什么？” </p>
</li>
<li><p>网络内其他主机并不响应ARP询问，只有<strong>同一网段内</strong>的主机B接收到这个帧时，才向主机A做出回应（ARP response）：“192.168.38.11的MAC地址是00-BB-00-62-C2-02”，此回应以<strong>单播</strong>方式进行。</p>
</li>
<li><p>这样，主机A就知道主机B的MAC地址，它就可以向主机B发送信息。同时它还更新自己的ARP cache，下次再向主机B发送信息时，直接从ARP缓存表里查找就可。实际上，ARP Request中包含源IP和源MAC，这样B收到帧的时候就能直接写入ARP缓存，不需要多余通信</p>
</li>
<li><p>ARP Cache 会设置<strong>生存时间</strong>（Time To Live, TTL）逾期会自动删除，给新的映射关系留下空间（因为可能有的网卡坏了MAC地址也换了，IP地址因为是软件地址，不会跟着硬件走）</p>
</li>
</ul>
<h2 id="ARP-代理（ARP-Proxy）"><a href="#ARP-代理（ARP-Proxy）" class="headerlink" title="ARP 代理（ARP Proxy）"></a>ARP 代理（ARP Proxy）</h2><p>ARP 只适用于<strong>同一局域网</strong>内部的IP到MAC的映射。<strong>不同局域网之间</strong>的通信依靠路由器，主机会把IP数据报发给自己的默认网关（也就是路由器）由于默认网关是IP地址形式，所以也要发一个ARP请求广播帧来获取<strong>路由器的MAC地址</strong>，随后将自己的IP数据报封装成以太网帧发给路由器R<del>1</del>。</p>
<p>路由器R<del>1</del>获取网帧之后经过剥离拿到IP数据报，如果目标IP恰好跟R<del>1</del>在同一个网络内，那么再次通过ARP找到目标IP的MAC地址即可。如果<strong>仍然不在同一个网络</strong>内，则需要查路由表来确定下一跳应该发到哪个网络。</p>
<p><strong>广播域隔离</strong>：路由器并不会在不同子网间转发<strong>基于MAC地址的广播帧</strong>，同样也不会转发<strong>IP广播数据报</strong>，因为这样可能会造成<strong>广播风暴</strong>，瘫痪网络。</p>
<p><strong>为什么不直接使用MAC地址通信</strong>：MAC地址相比于IP地址的劣势</p>
<ul>
<li>MAC帧格式并不统一（以太网帧、802.11帧<del>Wi-Fi</del>等）地址转换过程非常复杂，并且和硬件绑定缺乏灵活性</li>
<li>使用更高层次的抽象IP地址就可以屏蔽上述差异，灵活分配，具体由ARP协议负责找到IP对应的MAC。</li>
<li>MAC地址可轻易被伪造或篡改，而IP地址则可以结合其他协议（如防火墙和ACL）进行更复杂的安全策略。</li>
</ul>
<h1 id="IP-数据报首部（IP-Header）"><a href="#IP-数据报首部（IP-Header）" class="headerlink" title="IP 数据报首部（IP Header）"></a>IP 数据报首部（IP Header）</h1><p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/d448bf2729381d8aa9f09d12f454726d.png" alt="d448bf2729381d8aa9f09d12f454726d"></p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>长度（bit）</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>版本</td>
<td>4</td>
<td>区分协议的版本 (IPv4, IPv6等)</td>
</tr>
<tr>
<td>首部长度</td>
<td>4</td>
<td>整个<strong>首部</strong>的长度，单位4字节（0101（20字节）~1111（60字节））</td>
</tr>
<tr>
<td>区分服务</td>
<td>8</td>
<td>用来获得更好的服务类型，区分服务类型才使用</td>
</tr>
<tr>
<td>总长度</td>
<td>16</td>
<td>单位字节，首部+数据的总长度，最大65536，实际上超过1500（MTU）必须分片，如果分片，则为这个数据报分片的总长度</td>
</tr>
<tr>
<td>标识</td>
<td>16</td>
<td>IP 软件给每个 IP 数据报分配的标识，属于<strong>同一个数据报的分片标识相同</strong></td>
</tr>
<tr>
<td>标志</td>
<td>3</td>
<td>0 | DF | MF (MF =  1表示还有分片，MF = 0表示最后一个分片，DF = 1不允许分片)</td>
</tr>
<tr>
<td>片偏移（Offset）</td>
<td>13</td>
<td>单位8字节，$2^{13}\times8 = 65536$，表示<strong>分片的数据</strong>在<strong>原数据</strong>中的偏移量</td>
</tr>
<tr>
<td>生存时间（TTL）</td>
<td>8</td>
<td><strong>数据报的寿命</strong>，以前单位为秒，后来变成了<strong>跳数</strong>，减少路由表配置错误导致的网络风暴</td>
</tr>
<tr>
<td>协议</td>
<td>8</td>
<td>用来标识数据部分使用的是什么协议（ICMP, UDP, TCP, OSPF 等）</td>
</tr>
<tr>
<td>首部校验和（Checksum）</td>
<td>16</td>
<td><strong>首部</strong>按照16位字划分成如上图的几行，将首部各行加和的反码填入，发送者会先置0，然后再运算，接收者会直接运算结果，如果不出错结果肯定是0</td>
</tr>
<tr>
<td>源地址</td>
<td>32</td>
<td>源 IPv4 地址</td>
</tr>
<tr>
<td>目的地址</td>
<td>32</td>
<td>目标 IPv4 地址</td>
</tr>
<tr>
<td>可变部分</td>
<td>1~40</td>
<td>用于排错、测量和安全功能，由于是可变 加重路由器的负担，可有可无，IPv6 变为定长</td>
</tr>
<tr>
<td>数据部分（Payload）</td>
<td>——</td>
<td>上层传下来的数据</td>
</tr>
</tbody></table>
<h2 id="从以太网帧中找出目的IP地址"><a href="#从以太网帧中找出目的IP地址" class="headerlink" title="从以太网帧中找出目的IP地址"></a>从以太网帧中找出目的IP地址</h2><p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241124195904437.png" alt="image-20241124195904437"></p>
<p>以太网帧有14B的头，IP的目的地址之前有16B的头，因此目的地址从第31个字节开始</p>
<h1 id="IP-转发分组过程"><a href="#IP-转发分组过程" class="headerlink" title="IP 转发分组过程"></a>IP 转发分组过程</h1><h2 id="基于终点转发：前缀匹配"><a href="#基于终点转发：前缀匹配" class="headerlink" title="基于终点转发：前缀匹配"></a>基于终点转发：前缀匹配</h2><table>
<thead>
<tr>
<th>前缀匹配</th>
<th>下一跳</th>
</tr>
</thead>
<tbody><tr>
<td>128.1.2.192/26</td>
<td>直接，接口1</td>
</tr>
<tr>
<td>128.1.2.128/26</td>
<td>直接，接口2</td>
</tr>
<tr>
<td>128.1.3.64/26</td>
<td>R<del>2</del></td>
</tr>
</tbody></table>
<p>ARP代理机制中，我们接触到了逐跳转发的概念，如果转发到第一个路由器和目标IP仍然不在一个网络，就要转发到路由表的下一跳。</p>
<p><strong>路由表</strong>：分别是网络IP地址、子网掩码和下一跳，网络地址和子网掩码确定接口在哪个网络，下一跳同样是网络的地址而不是主机的IP地址，这主要是为了防止浪费，提高转发的效率。</p>
<p><strong>匹配前缀</strong>：将子网掩码和目的地址相与 得出的网络地址匹配，则进入下一跳，否则继续匹配下一个</p>
<p>R<del>1</del>查到下一跳之后，会将下一跳IP地址传给数据链路层，用ARP解析出路由器R<del>2</del>的MAC地址。</p>
<p>因此，查找路由表的过程就是寻找前缀匹配的过程。</p>
<h2 id="查询路由表"><a href="#查询路由表" class="headerlink" title="查询路由表"></a>查询路由表</h2><h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3><p>CIDR路由聚合可以将网络前缀相同的地址块合并，初衷就是减少路由表项，但同时也减少了路由的具体性，举例：</p>
<p><code>128.1.24.0/22</code>与<code>128.1.24.0/24</code> 这两个CIDR地址块并不一致，尽管后者可以聚合到前者中，但是如果特意不聚合（比如公司B和公司A同时从ISP申请了同一网段的IP地址），放到路由表就表示不同的网段，</p>
<p><strong>128.1.24.0/24</strong>：</p>
<ul>
<li>掩码：<code>255.255.255.0</code></li>
<li>包含的地址范围：<code>128.1.24.0 ~ 128.1.24.255</code> （公司A）</li>
</ul>
<p><strong>128.1.24.0/22</strong>：</p>
<ul>
<li>掩码：<code>255.255.252.0</code></li>
<li>表面上可以包含的地址范围：<code>128.1.24.0 ~ 128.1.27.255</code> </li>
<li>实际上包含的地址范围： <code>128.1.25.0/24</code>, <code>128.1.26.0/24</code>, <code>128.1.27.0/24</code> (公司B)</li>
<li>为了节省空间，使用路由聚合将公司B的3个地址块聚合成1个大地址块</li>
</ul>
<p>多个前缀匹配成功（精确和模糊网段同时出现在路由表），模糊网段实际上并没有包括这个精确网段，路由器采取的原则是 <strong>最长前缀匹配</strong> ，如果不这样做，会被错误路由到模糊的网段，找不到目标。</p>
<p>为了方便这个实践这个原则，路由表会按照前缀长度进行排序，越长防越靠前，避免发生错误多余的查找。</p>
<p>路由表中还有两个特殊的可选路由项：</p>
<h3 id="主机路由（host-route）"><a href="#主机路由（host-route）" class="headerlink" title="主机路由（host route）"></a>主机路由（host route）</h3><p>前缀长度是32位，直接定位到一台主机，目标IP和主机路由相同，则直接认定匹配，网络测试比较方便，免去地址聚合带来的不确定性</p>
<h3 id="默认路由（default-route）"><a href="#默认路由（default-route）" class="headerlink" title="默认路由（default route）"></a>默认路由（default route）</h3><p><strong>网络前缀</strong>：</p>
<ul>
<li><code>0.0.0.0</code>：表示网络地址是 0。</li>
<li><code>/0</code>：表示前缀长度是 0 位，也就是说没有固定的前缀，所有 IP 地址的前缀都可以匹配它。</li>
</ul>
<p><strong>含义</strong>：</p>
<ul>
<li>默认路由是路由表中的一个“兜底规则”。</li>
<li>当某个目标地址不匹配任何其他路由条目时，数据包会被转发到默认路由指向的下一跳（指定的网关）。</li>
<li>适用于对外连接较少的路由器（比如这个路由器不直接跟外网连接，而是通过另一个网关）</li>
</ul>
<p>当路由表中存在更精确的匹配（如 <code>/24</code> 或 <code>/16</code>），则优先使用更精确的匹配；只有当没有其他匹配时，才使用默认路由。这个可以减少路由表的条数，提高单个路由表的查询性能。</p>
<h1 id="网际控制报文协议（ICMP）"><a href="#网际控制报文协议（ICMP）" class="headerlink" title="网际控制报文协议（ICMP）"></a>网际控制报文协议（ICMP）</h1><h2 id="ICMP报文种类"><a href="#ICMP报文种类" class="headerlink" title="ICMP报文种类"></a>ICMP报文种类</h2><h3 id="差错报告报文"><a href="#差错报告报文" class="headerlink" title="差错报告报文"></a>差错报告报文</h3><ul>
<li><p>终点不可达：路由器或主机无法交付数据报时向源点发送destination unreachable，比如UDP数据包目标是一个不存在的端口</p>
<ul>
<li><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241126195147654.png" alt="image-20241126195147654"></li>
</ul>
</li>
<li><p>时间超过：TTL归零，路由器要丢弃数据报，并向源点发送time exceeded</p>
</li>
<li><p>参数问题：IP首部出错，BAD IP HEADER</p>
</li>
<li><p>改变路由：路由器发现了更好的路由，遂向主机发送redirecting，改变默认路由</p>
</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241125220916277.png" alt="image-20241125220916277"></p>
<p>ICMP的数据部分包括IP数据报首部，和IP数据负载的前8字节（UDP，TCP的目标端口和源端口，TCP报文段的发送序列号）</p>
<h3 id="询问报文"><a href="#询问报文" class="headerlink" title="询问报文"></a>询问报文</h3><ul>
<li>回送请求、回送回答：向特定主机发送的询问，收到回答用来测试可达和主机状态</li>
<li>时间戳请求、时间戳回答：利用时间戳可以计算往返时间</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h3><p>Packet InterNet Gopher ，应用层直接调用网络层的一个例子，向节点连续发送ICMP回送请求报文，可以计算出往返时间，统计出丢失的分组数（不知道原因）</p>
<p>ECHO REQUEST(8)    ECHO REPLY(0)</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241125221744772.png" alt="image-20241125221744772"></p>
<h4 id="socket编程实现"><a href="#socket编程实现" class="headerlink" title="socket编程实现"></a>socket编程实现</h4><p><img src="https://cdn.xiaolincoding.com//mysql/other/eb0963a11439dff361dbe0e7a8876abd.png" alt="图片"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241126203039467.png" alt="image-20241126203039467"></p>
<p>UNIX系统编程实现中，计算机传输层以下比较底层的部分通过socket接口封装起来，调用比较方便，socket编程接口就是应用程序访问网络，操作网卡的方式。</p>
<p>创建socket套接字时有不同的参数，可以选择基于字节流（TCP）/数据报（UDP），另外一个方面，还可以选择协议TCP UDP 或者ICMP，这样socket</p>
<p>在 TCP 传输中创建的方式是 <code>socket(AF_INET, SOCK_STREAM, 0)</code> 其中 <code>AF_INET</code> 表示将使用 IPV4 里 host:port 的方式去解析待会你输入的网络地址。<code>SOCK_STREAM</code> 是指使用面向字节流的 TCP 协议，工作在传输层。 创建好了 socket 之后，就可以愉快的把要传输的数据写到这个文件里。调用 socket 的<code>sendto</code>接口的过程中进程会从用户态进入到内核态，最后会调用到 <code>sock_sendmsg</code> 方法。 然后进入传输层，带上TCP头。网络层带上IP头，数据链路层带上 MAC头等一系列操作后。进入网卡的发送队列 ring buffer ，顺着网卡就发出去了。 回到 ping ， 整个过程也基本跟 TCP 发数据类似，差异的地方主要在于，创建 socket 的时候用的是 <code>socket(AF_INET,SOCK_RAW,IPPROTO_ICMP)</code>，<code>SOCK_RAW</code> 是原始套接字 ，工作在网络层， 所以构建ICMP（网络层协议）的数据，是再合适不过了。ping 在进入内核态后最后也是调用的 <code>sock_sendmsg</code> 方法，进入到网络层后加上ICMP和IP头后，数据链路层加上MAC头，也是顺着网卡发出。        </p>
<p>因此 本质上ping 跟 普通应用发消息 在程序流程上没太大差别。 这也解释了<strong>为什么当你发现怀疑网络有问题的时候，别人第一时间是问你能ping通吗？</strong>因为可以简单理解为ping就是自己组了个数据包，让系统按着其他软件发送数据的路径往外发一遍，能通的话说明其他软件发的数据也能通。</p>
<h4 id="PING-127-0-0-1"><a href="#PING-127-0-0-1" class="headerlink" title="PING 127.0.0.1"></a>PING 127.0.0.1</h4><p>PING localhost 127.0.0.1 本机IP都会走回环路径</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/c1019a8be584b27c4fc8b8abda9d3cf1.png" alt="图片"></p>
<p>The local network card is actually a “fake network network card”. It does not have a <strong>ring buffer</strong> like the “real network card”. The “fake network card” will push data into a linked list called <code>input_pkt_queue</code>. This linked list is actually shared by <strong>all</strong> network cards, and contains various messages sent to this machine. After the message is sent to this linked list, a soft interrupt will be triggered。</p>
<p>0.0.0.0 ping不通，不过服务器listen0.0.0.0表示监听所有目标地址</p>
<h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><ol>
<li>记录路由路径和路由时间</li>
<li>确定链路的MTU</li>
</ol>
<p>连续发送多个数据报(含有目标端口非法的UDP数据报)，TTL从1开始递增，路由器减TTL并准备转发，此时看到TTL归零就会向源点发送ICMP <strong>时间超过</strong> 差错报告报文，能够记录路由的路径，如果路由到目标主机，目标主机不会继续转发，也不会减TTL，看到UDP数据报不合法向源点发送ICMP <strong>终点不可达</strong> 差错报告报文。</p>
<p>每个TTL会发送3个相同数据报</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241125221948199.png" alt="image-20241125221948199"></p>
<p>第二个作用：<strong>故意设置不分片，从而确定路径的 MTU</strong>。</p>
<p>First, when the sending host sends an IP datagram, it sets the DF(Don’t Fragment) flag bit in the IP packet header to 1. According to this flag, routers on the way will not fragment large data packets, but will <strong>discard</strong> the packets.</p>
<p>Subsequently, the value of the <strong>MTU on the data link</strong> is sent to the sending host through an ICMP unreachable message. The type of the unreachable message is “Fragmentation is required but the DF-bit is set.”</p>
<p>Each time the sending host receives an ICMP error message, it reduces the packet size to locate an appropriate MTU value so that it can reach the target host.</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241126195846876.png" alt="image-20241126195846876"></p>
<h1 id="网际分组管理协议（IGMP）"><a href="#网际分组管理协议（IGMP）" class="headerlink" title="网际分组管理协议（IGMP）"></a>网际分组管理协议（IGMP）</h1><h2 id="一对多通信"><a href="#一对多通信" class="headerlink" title="一对多通信"></a>一对多通信</h2><h3 id="IP-单播（Unicast）"><a href="#IP-单播（Unicast）" class="headerlink" title="IP 单播（Unicast）"></a>IP 单播（Unicast）</h3><p>单播是点对点通信，一台设备直接与另一台设备通信。数据包通过网络传输到特定的目标地址。</p>
<p><strong>特点</strong></p>
<ul>
<li>每个数据包有唯一的目标 IP 地址。</li>
<li>用于一对一的通信场景。</li>
<li>网络负载低，目标明确。</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>普通的网页浏览、邮件通信等。</li>
<li>服务器与客户端的直接通信。</li>
</ul>
<p><strong>示例</strong><br>一台电脑向服务器（如 192.168.1.1）请求网页内容。</p>
<h3 id="IP-广播（Broadcast）"><a href="#IP-广播（Broadcast）" class="headerlink" title="IP 广播（Broadcast）"></a>IP 广播（Broadcast）</h3><table>
<thead>
<tr>
<th>网络号</th>
<th>主机号</th>
<th>源地址使用</th>
<th>目的地址使用</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>OK</td>
<td>NO</td>
<td>本网络的本主机，用于 DHCP，此时本主机 IP 未知</td>
</tr>
<tr>
<td>0</td>
<td>X</td>
<td>OK</td>
<td>NO</td>
<td>本网络的 X 主机</td>
</tr>
<tr>
<td>127</td>
<td>除全0和全1</td>
<td>OK</td>
<td>OK</td>
<td>本地软件测试环回地址 (loopback)</td>
</tr>
<tr>
<td><strong>Y</strong></td>
<td><strong>全1</strong></td>
<td><strong>NO</strong></td>
<td><strong>OK</strong></td>
<td><strong>Y 网络的广播（路由器参与转发）</strong></td>
</tr>
<tr>
<td><strong>全1</strong></td>
<td><strong>全1</strong></td>
<td><strong>NO</strong></td>
<td><strong>OK</strong></td>
<td><strong>本网络的广播（路由器不参与转发）</strong></td>
</tr>
</tbody></table>
<p>由此可见，IP 广播主要是聚焦局域网（LAN）所有主机都会接收广播消息，无需特定的接收者。</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li>地址解析协议（ARP）。</li>
<li>动态主机配置协议（DHCP）的请求。</li>
</ul>
<h3 id="IP-多播（Multicast）"><a href="#IP-多播（Multicast）" class="headerlink" title="IP 多播（Multicast）"></a>IP 多播（Multicast）</h3><ul>
<li><strong>定义</strong>：<br>多播是一种将数据包发送给特定一组接收者（多播组）的通信方式。这组接收者需要事先加入一个特定的多播组，只有组内的成员会接收到数据包。也叫组播</li>
<li><strong>特点</strong>：<ul>
<li>可以跨越多个网络。</li>
<li>使用 <strong>多播地址</strong>：IPv4中的多播地址范围是 <code>224.0.0.0</code> 到 <code>239.255.255.255</code>。（D类地址）</li>
<li>接收者需要加入一个多播组（通过 IGMP 协议进行管理）。</li>
<li>节省带宽，因为数据只发送给需要的设备。</li>
</ul>
</li>
<li><strong>优缺点</strong>：<ul>
<li><strong>优点</strong>：更高效，特别是在需要发送给大量接收者时。</li>
<li><strong>缺点</strong>：需要更多的配置和支持，例如多播路由器。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li>视频会议。</li>
<li>实时股票行情分发。</li>
<li>流媒体广播。</li>
</ul>
</li>
</ul>
<h3 id="IP-任播（Anycast）"><a href="#IP-任播（Anycast）" class="headerlink" title="IP 任播（Anycast）"></a>IP 任播（Anycast）</h3><p><img src="C:/Users/Lenovo/Pictures/markdownfile/L2%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241129180917624.png" alt="image-20241129180917624"></p>
<p><strong>定义</strong><br>任播是点对最近点通信，数据包发送给一个目标地址，但由多个具有相同地址的设备接收，最终到达距离最近的一个设备。</p>
<p><strong>特点</strong></p>
<ul>
<li>使用普通的单播地址，但配置在多个设备上。</li>
<li>路由选择最近的目标（通常基于最短路径）。</li>
<li>增强服务的可用性和效率。用于负载均衡和冗余。</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>内容分发网络（CDN）。</li>
<li>公共 DNS 服务（如 Google 的 8.8.8.8）。</li>
</ul>
<p><strong>示例</strong><br>用户请求 DNS 服务，数据包被路由到最近的 DNS 服务器（多个 DNS 服务器配置了同样的地址 8.8.8.8）。</p>
<h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>单播</td>
<td>一对一通信，目标明确</td>
<td>普通网络通信（网页、邮件等）</td>
</tr>
<tr>
<td>组播</td>
<td>一对多通信，针对订阅组传输</td>
<td>视频直播、分布式同步等</td>
</tr>
<tr>
<td>广播</td>
<td>一对全通信，子网内所有设备接收</td>
<td>ARP、DHCP 发现等</td>
</tr>
<tr>
<td>任播</td>
<td>一对最近点通信，选择最近设备</td>
<td>CDN、全球 DNS 服务等</td>
</tr>
</tbody></table>
<h3 id="局域网上的硬件多播"><a href="#局域网上的硬件多播" class="headerlink" title="局域网上的硬件多播"></a>局域网上的硬件多播</h3><p>MAC地址 FF:FF:FF:FF:FF:FF为<strong>广播地址</strong></p>
<p>MAC地址 第一个字节末位为1 表示多播，前25位固定不变，后23位来自D类IP地址的后23位 为MAC多播地址</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h3><h3 id="多播路由协议"><a href="#多播路由协议" class="headerlink" title="多播路由协议"></a>多播路由协议</h3><p>本质区别：多播路由需要考虑源地址的组和网络，也要考虑目的地址的组和网络</p>
<h1 id="缓解IPv4地址短缺"><a href="#缓解IPv4地址短缺" class="headerlink" title="缓解IPv4地址短缺"></a>缓解IPv4地址短缺</h1><h2 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h2><h2 id="虚拟专用网络（Virtual-Private-Network-VPN）"><a href="#虚拟专用网络（Virtual-Private-Network-VPN）" class="headerlink" title="虚拟专用网络（Virtual Private Network, VPN）"></a>虚拟专用网络（Virtual Private Network, VPN）</h2><h3 id="专用IP地址与隧道技术（tunnel）"><a href="#专用IP地址与隧道技术（tunnel）" class="headerlink" title="专用IP地址与隧道技术（tunnel）"></a>专用IP地址与隧道技术（tunnel）</h3><p><code>10.0.0.0 ~ 10.255.255.255</code> 1个A类网络</p>
<p><code>172.16.0.0 ~ 172.31.255.255</code> 16个B类网络</p>
<p><code>192.168.0.0 ~ 192.168.255.255</code> 256个C类网络</p>
<p>IP地址短缺，机构内部的主机都会使用专用IP网段，如果机构内部的主机AB分隔两地需要进行通信，私密性和安全性是关键，要么向运营商租用昂贵的电信线路将他们直接连成局域网，</p>
<p>要么利用互联网，用两台路由器静态配置IP，将原本的IP数据报加密后封装到一个新的IP数据报中，这个新的IP数据报负责在公网进行路由传递，最终到达目标主机所在网络的路由器，由路由器将数据报交付给目标主机。</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241125223910383.png" alt="image-20241125223910383"></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>目标IP</th>
<th>源IP</th>
<th>所属网络</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>10.2.0.3</td>
<td>10.1.0.1</td>
<td>10.1.0.0</td>
</tr>
<tr>
<td>2</td>
<td>194.4.5.6</td>
<td>125.1.2.3</td>
<td>公网IP</td>
</tr>
<tr>
<td>3</td>
<td>10.2.0.3</td>
<td>10.1.0.1</td>
<td>10.2.0.0</td>
</tr>
</tbody></table>
<p>步骤2是外层数据报，13都是内层的加密数据报内容。</p>
<h2 id="网络地址转换（Network-Address-Translation-NAT）"><a href="#网络地址转换（Network-Address-Translation-NAT）" class="headerlink" title="网络地址转换（Network Address Translation, NAT）"></a>网络地址转换（Network Address Translation, NAT）</h2><p>同样是IP地址短缺的背景，路由器给主机分配了专用IP网段，内网IP的数据包根本不可能在公网上传播，因为公网上的路由器都是屏蔽掉了这些私网IP，因此主机要通过路由器的公网IP向外发送消息，但是之后外部就无法联络内部，此时就出现了网络地址转换（NAT）NAT提供了主机的专用IP地址到路由器所持公网IP的映射关系，外部发送消息到路由器的特定公网IP，NAT路由器根据映射表将消息转发到对应的主机。</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241125225315413.png" alt="image-20241125225315413"></p>
<h3 id="NAPT"><a href="#NAPT" class="headerlink" title="NAPT"></a>NAPT</h3><p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241125225356469.png" alt="image-20241125225356469"></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>网络地址转换（Network Address Translation，NAT）机制的问题在于，NAT设备自动屏蔽了非内网主机主动发起的连接，也就是说，从外网发往内网的数据包将被NAT设备丢弃，这使得位于不同NAT设备之后的主机之间无法直接交换信息。这一方面保护了内网主机免于来自外部网络的攻击，另一方面也为P2P通信带来了一定困难。Internet上的NAT设备大多是地址限制圆锥形NAT或端口限制圆锥形 NAT，外部主机要与内网主机相互通信，必须由内网主机主动发起连接，使 NAT设备产生一个映射条目，这就有必要研究一下<strong>内网穿透</strong>技术。</p>
<h3 id="内网穿透（Intranet-penetration）"><a href="#内网穿透（Intranet-penetration）" class="headerlink" title="内网穿透（Intranet penetration）"></a>内网穿透（Intranet penetration）</h3><h4 id="UDP-打洞"><a href="#UDP-打洞" class="headerlink" title="UDP 打洞"></a>UDP 打洞</h4><h5 id="通信双方一台位于-NAT-之后"><a href="#通信双方一台位于-NAT-之后" class="headerlink" title="通信双方一台位于 NAT 之后"></a>通信双方一台位于 NAT 之后</h5><p>一台主机B有一个公网 IP，另一台主机A有一个内网 IP。如图2.4所示， A 位于 NAT 之后，并拥有[IP 地址：端口]对[10.0.0.1：1234]， B位于 NAT 之前，并拥有[IP 地址：端口]对[138.76.29.7：1234]，NAT 拥有公网 IP 155.99.25.11。由于  B 有一个公网 IP， A 可以直接通过 TCP 连接到[138.76.29.7：1234]，然而，如果  B 向  A 发起主动连接，则不会成功。此时，需要一个公有的服务器辅助进行内网穿透。 A 和  B 向服务器发起登陆请求，并保持一个 TCP 或 UDP 连接，服务器记录其 IP 地址和端口号，这里服务器对  A 是记录其经过 NAT 映射之后的 IP 和端口号。当  B 想连接  A 时，首先向服务器提出请求，服务器在收到请求后向  A 发出打洞命令，并将  B 的[IP 地址：端口]对发给  A， A 根据接收到的 IP地址和端口号向  B 发起 TCP 连接或发送 UDP 数据包。接下来  A 和 B 之间便可以建立数据传输通道。</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241125230637435.png" alt="image-20241125230637435"></p>
<h5 id="通信双方主机均位于NAT设备之后"><a href="#通信双方主机均位于NAT设备之后" class="headerlink" title="通信双方主机均位于NAT设备之后"></a>通信双方主机均位于NAT设备之后</h5><p>两台主机都处于内网中，如图2.5所示。服务器记录的[IP 地址：端口]对是  A 和  B 经过 NAT 映射之后的IP 地址和端口号，此时， A 和  B 之间任意方向的连接请求都会被对方的 NAT 设备屏蔽。 A 首先向服务器提出连接请求，服务器将  A 的 IP地址和端口号对[155.99.25.11:51200]发给  B，并向  B 发出打洞命令； B 收到服务器的打洞命令后首先向[155.99.25.11:51200]发送一定数目的 UDP探测包或 TCP 连接请求，在 NAT B 上打一个方向为[155.99.25.11:51200]的洞， B 随后向服务器报告打洞完成；服务器在收到  B 的报告后将  B 的公网IP 地址和端口号对[110.10.33.10：5000]，此时由于 NAT B 上已经留下了对应于[155.99.25.11:51200]方向的洞， A 向[110.10.33.10：5000]发出的数据包或连接请求将不会被丢弃。</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241125230725093.png" alt="image-20241125230725093"></p>
<p>这项技术需要使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">圆锥型NAT</a>设备，对称型NAT不能使用这项技术。</p>
<h4 id="STUN（NAT会话穿越应用程序）"><a href="#STUN（NAT会话穿越应用程序）" class="headerlink" title="STUN（NAT会话穿越应用程序）"></a>STUN（NAT会话穿越应用程序）</h4><p>NAT 穿越技术拥有这样的功能，它能够让网络应用程序主动发现自己位于 NAT 设备之后，并且会主动获得 NAT 设备的公有 IP，并为自己建立端口映射条目，注意这些都是 NAT设备后的应用程序自动完成的。</p>
<p>也就是说，在 NAT 穿透技术中，NAT设备后的应用程序处于主动地位，它已经明确地知道 NAT 设备要修改它外发的数据包，于是它主动配合 NAT 设备的操作，主动地建立好映射，这样就不像以前由 NAT 设备来建立映射了。</p>
<p>说人话，就是客户端主动从 NAT 设备获取公有 IP 地址，然后自己建立端口映射条目，然后用这个条目对外通信，就不需要 NAT 设备来进行转换了。</p>
<h1 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h1><h2 id="静态配置路由导致的路由环路"><a href="#静态配置路由导致的路由环路" class="headerlink" title="静态配置路由导致的路由环路"></a>静态配置路由导致的路由环路</h2><p>聚合路由和精确路由同时出现在一张路由表中，应该按照精确地址进行匹配，（模糊地址中不包括精确地址）</p>
<p><strong>路由配置错误</strong>：路由表手动配置错误导致出现路由环路。</p>
<p><strong>聚合不存在的网络</strong>：路由表中只有模糊地址，但是模糊地址里面不存在某个精确地址，而目的地址是精确地址会导致数据包会被错误地路由到模糊的网络，因此路由器应当配置黑洞路由，将不存在的地址路由到黑洞中（丢弃）</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241127123732804.png" alt="image-20241127123732804"></p>
<p><strong>网络故障</strong>：路由器检测到与其直连的网络发生故障会把路由表中的条目删除，但下次来就不知道要转发到哪里，只能交给默认路由，此时可能会导致环路，正确的做法是故障时启用对应网络的黑洞路由，恢复时关闭黑洞路由，启用正常的接口路由    </p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241127124109191.png" alt="image-20241127124109191"></p>
<h2 id="路由协议概述"><a href="#路由协议概述" class="headerlink" title="路由协议概述"></a>路由协议概述</h2><p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241127124155110.png" alt="image-20241127124155110"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241127124212549.png" alt="image-20241127124212549"></p>
<p>路由表：对网络拓扑计算最优化</p>
<p>转发表：使得查找过程最优化，优化路由表的查找性能</p>
<h2 id="路由信息协议（Routing-Information-Protocol-RIP）"><a href="#路由信息协议（Routing-Information-Protocol-RIP）" class="headerlink" title="路由信息协议（Routing Information Protocol, RIP）"></a>路由信息协议（Routing Information Protocol, RIP）</h2><ul>
<li>属于内部网关协议（IGP），是一个自治系统内部的路由协议</li>
<li>最早出现的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%9D%E9%9B%A2%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1%E5%8D%94%E5%AE%9A">距离向量路由协议</a>，其主要应用于规模较小的、可靠性要求较低的网络。收敛速度较慢，支持的广播网络规模有限</li>
<li>路由<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95">算法</a>是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Bellman-Ford">Bellman-Ford</a>算法</li>
</ul>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul>
<li><p>每隔30秒会与相邻的路由器交换子消息，以动态的建立<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E8%A1%A8">路由表</a>。</p>
</li>
<li><p><strong>RIP规定度量值取0~15之间的整数，大于或等于16的跳数被定义为无穷大。</strong></p>
</li>
<li><p>对方的路由表复制过来，下一跳全部改成对方，距离全部加1；</p>
</li>
<li><p>不存在网络B的条目，直接添加；</p>
</li>
<li><p>存在网络A的条目，下一跳相同，直接更新；</p>
</li>
<li><p>存在网络A的条目，下一跳不同，距离更短才更新；距离相同则添加条目（等价负载均衡）；距离更长则不更新。</p>
</li>
</ul>
<h3 id="问题：坏消息传得慢"><a href="#问题：坏消息传得慢" class="headerlink" title="问题：坏消息传得慢"></a>问题：坏消息传得慢</h3><p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241127124509184.png" alt="image-20241127124509184"></p>
<ul>
<li><strong>水平分割</strong>：水平分割指的是RIP从某个接口学到的路由，不会从该接口再发回给邻居设备。在帧中继和X.25等NBMA网络中，水平分割功能缺省为禁止状态。</li>
<li><strong>触发更新</strong>：触发更新是指路由信息发生变化时，立即向邻居设备发送触发更新报文，通知变化的路由信息。（触发更新不会触发接收路由器重置自己的更新定时器）</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241127125439393.png" alt="image-20241127125439393"></p>
<p>检测到不可达：说明之前距离是1（直连接口）</p>
<p>收敛：R3 到网络距离为1，R2和R1到网络的距离为2</p>
<p>不可达：R3 到网络距离为16，通告给R2，变更距离为16，随后R1没来得及更新，就将自己的路由表内容发给了</p>
<h2 id="开放式最短路径优先（Open-Shortest-Path-First-OSPF）"><a href="#开放式最短路径优先（Open-Shortest-Path-First-OSPF）" class="headerlink" title="开放式最短路径优先（Open Shortest Path First, OSPF）"></a>开放式最短路径优先（Open Shortest Path First, OSPF）</h2><ul>
<li><p>属于内部网关协议（IGP）</p>
</li>
<li><p>在链路状态路由协议中，每个节点都知晓整个网络的拓扑信息。各节点使用自己了解的网络拓扑情况来各自独立地对网络中每个可能的目的地址计算出其最佳的转发地址（下一跳）。所有最佳转发地址汇集到一起构成该节点的完整路由表。与距离-矢量路由协议使用的那种每个节点与其相邻节点分享自己的路由表的工作方式不同，链路状态路由协议的工作方式是节点间仅传播用于构造网络连通图所需的信息。最初创建这类协议就是为了解决距离-矢量路由协议收敛缓慢的缺点，然而，为此链路状态路由协议会消耗大量的内存与处理器能力。</p>
</li>
<li><p>大多数<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%9C%8D%E5%8A%A1%E4%BE%9B%E5%BA%94%E5%95%86">ISP</a>必须使用BGP来与其他ISP建立路由连接（尤其是当它们采取多宿主连接时）</p>
</li>
<li><p>采用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95">Dijkstra 算法</a>计算<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%A0%91">最短路径树</a>，使用“开销（Cost）”作为路由度量。</p>
</li>
<li><p>链路状态数据库（LSDB）用来保存当前<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91">网络拓扑</a>结构，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8">路由器</a>上属于同一区域的链路状态数据库是相同的（属于多个区域的路由器会为每个区域维护一份链路状态数据库）。</p>
</li>
<li><p>基于 IP 协议，路由信息直接封装在 IP 数据报中</p>
</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241127125916904.png" alt="image-20241127125916904"></p>
<h2 id="边界网关协议（Border-Gateway-Protocol-BGP）"><a href="#边界网关协议（Border-Gateway-Protocol-BGP）" class="headerlink" title="边界网关协议（Border Gateway Protocol, BGP）"></a>边界网关协议（Border Gateway Protocol, BGP）</h2><p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241127125154032.png" alt="image-20241127125154032"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241127125208832.png" alt="image-20241127125208832"></p>
<h2 id="向路由选择协议提供服务的实体"><a href="#向路由选择协议提供服务的实体" class="headerlink" title="向路由选择协议提供服务的实体"></a>向路由选择协议提供服务的实体</h2><p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%B1%82.assets/image-20241127125231763.png" alt="image-20241127125231763"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/12/30/L1%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF&%E7%89%A9%E7%90%86%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/30/L1%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF&%E7%89%A9%E7%90%86%E5%B1%82/" class="post-title-link" itemprop="url">物理层&数据链路层</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-30 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-30T00:00:00+08:00">2024-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-03 20:56:36" itemprop="dateModified" datetime="2025-05-03T20:56:36+08:00">2025-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%86">同轴电缆 - 维基百科，自由的百科全书</a> </p>
<p><strong>单向通信</strong>：Simplex，只有一个方向的通信，没有反向的交互。</p>
<p><strong>半双工</strong>：Half-Duplex，可以收发信息，但无法同时收发。</p>
<p><strong>全双工</strong>：Full-Duplex，可以同时收发信息。双工通信需要两条信道。</p>
<hr>
<p><strong>基带信号</strong>：基本频带信号，来自信源的信号。</p>
<p><strong>调制</strong>：将基带信号做一定的转换，使之能够在信道内传输。</p>
<p><strong>基带调制</strong>（编码）：将数字信号做一定转换，仍然是数字信号，但是更能适应信道特性。</p>
<p><strong>带通调制</strong>：使用载波（Carrier）调制数字信号，搬到频率较高的频段，转成模拟信号，以便在模拟信道中传输。</p>
<hr>
<p><strong>奈氏准则</strong>：带宽W，则码元传输最高速率是2W/个每秒，超过则会出现严重的码间串扰。</p>
<p><strong>香农公式</strong>：信噪比越大，带宽越高，极限传输速率越高。</p>
<hr>
<p><strong>导引型传输媒体</strong>：双绞线、同轴电缆、光缆。</p>
<p><strong>非导引型传输媒体</strong>：无线电微波通信（蜂窝网）、短波通信、微波接力（卫星通信）。</p>
<hr>
<p><strong>信道复用</strong>：解决多节点接入同一信道的冲突问题，码分、时分、波分、频分、空分、正交。</p>
<hr>
<p><strong>宽带接入</strong>：ADSL、拨号上网(猫, modem)  HFC、FTTx（光纤到x，光猫, ONT）。</p>
<h1 id="数据链路层（LAN）"><a href="#数据链路层（LAN）" class="headerlink" title="数据链路层（LAN）"></a>数据链路层（LAN）</h1><h2 id="数据链路层面对的三个问题"><a href="#数据链路层面对的三个问题" class="headerlink" title="数据链路层面对的三个问题"></a>数据链路层面对的三个问题</h2><ul>
<li><strong>帧</strong>（Frame）：用帧来封装分组交换的基本单位（IP数据报），限定IP数据报的长度（MTU），用特定字符（如SOH EOT）来作为帧与帧之间的界限。</li>
<li><strong>透明传输</strong>（Transparency）：也叫二进制安全（Binary-Safe），如果数据负载（Payload）中恰好出现了和界限字符二进制码相同的部分，则应该通过转义字符（ESC）加以区分。</li>
<li><strong>差错检验</strong>（Error Detection）：以帧为单位，使用循环冗余校验（Cyclic Redundancy Check）检查二进制比特是否传输错误（比特差错）有则丢弃数据帧，主要是帧内部的差错。<ul>
<li>可靠传输：链路层的发送端发什么，接收端就收到什么。（没有比特差错，也没有帧之间的差错）</li>
<li>确认、重传机制：如果是可靠的信道（如有线链路）则不需要重传，如果是信道质量较差的无线链路传输，则有重传机制，也就是提供可靠的传输。</li>
</ul>
</li>
</ul>
<h2 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h2><p>一对一，典型协议：PPP协议（宽带上网的PPPoE，用户和ISP之间连接）</p>
<h2 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h2><p>一对多，总线型拓扑以太网，典型协议：CSMA/CD (载波侦听多点接入/碰撞检测)</p>
<p><strong>共享信道</strong>：</p>
<ul>
<li><p>静态分配：FrequencyDM,CodeDM,WaveDM,TimeDM，对于局域网来说成本太高。</p>
</li>
<li><p>动态分配：</p>
<ul>
<li><p>随机接入：随时发送，碰撞导致传输率降低，CSMA/CD检测碰撞(IEEE 802.3 / DIX Ethernet V2)</p>
</li>
<li><p>受控接入：令牌环局域网 (IEEE 802.5) </p>
</li>
</ul>
</li>
</ul>
<p><strong>LLC</strong>（Logical Link Control）：逻辑链路控制，早期有很多局域网标准，用LLC来标识使用哪一种标准，后来只剩以太网</p>
<p><strong>MAC</strong>（Media Access Control）：媒体接入控制，控制传输媒体的层级。</p>
<h3 id="适配器（Adapter）"><a href="#适配器（Adapter）" class="headerlink" title="适配器（Adapter）"></a>适配器（Adapter）</h3><p>硬件上也叫做网卡，ROM中存放MAC地址（硬件地址），承担着串行/并行信号的转换工作（作为内外信号的一个缓冲区）将IP数据报封装成帧发送出去，或是接收网帧并提供校验，通过则发给CPU开始IO，校验失败则丢弃网帧，超过也会丢弃。</p>
<h3 id="以太网（Ethernet）"><a href="#以太网（Ethernet）" class="headerlink" title="以太网（Ethernet）"></a>以太网（Ethernet）</h3><h4 id="以太网的两大特征"><a href="#以太网的两大特征" class="headerlink" title="以太网的两大特征"></a>以太网的两大特征</h4><ul>
<li>无连接：不必事先建立连接，不可靠，尽最大努力交付，是否需要重传完全依赖于高层的控制</li>
<li>曼彻斯特编码：方便接收方提取位同步信号，能够有效标示码元。</li>
</ul>
<h4 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h4><ul>
<li>MA（Multiple Access）： 多点接入 多台主机接入总线。</li>
<li>CS（Carrier Sense）： 信道监听，边发送边监听信道的电压变化。</li>
<li>CD（Collision Detection）：监听到别人发送了（检测到碰撞）就停止自己的发送，避免浪费网络资源。由于传播时延，导致真正碰撞发生一段时间，B才会检测到发生碰撞停止发送，再过一段时间等B传到A，A才会意识到发生碰撞了</li>
</ul>
<h5 id="二进制指数退避-BEB"><a href="#二进制指数退避-BEB" class="headerlink" title="二进制指数退避(BEB)"></a>二进制指数退避(BEB)</h5><p>Binary Exponential Backoff</p>
<p>二进制指数退避算法是一种网络协议中用于解决数据传输冲突的方法。在以太网的CSMA/CD协议中，当多个设备尝试同时发送数据时，可能会发生冲突。为了减少冲突的发生，二进制指数退避算法被用来计算设备在重传前应等待的时间。通过随机化退避时间，有效地减少了连续冲突的可能性。随着重传次数的增加，退避时间的上限也随之增加，这有助于在网络负载较重时平滑流量。然而，这种方法牺牲了时间效率，因为退避时间可能会指数增长，导致数据传输的延迟。此外，当退避时间达到一定阈值时，算法会停止增加退避时间，以避免无限制的延迟。</p>
<p>二进制指数退避算法的基本步骤如下：</p>
<ol>
<li>确定基本退避时间，通常设为一个争用期时间，例如以太网中为51.2微秒。</li>
<li>定义重传次数K，取重传次数和10的较小值，即K=min(重传次数, 10)。</li>
<li>从集合[0, 1, 2, …, (2^K - 1)]中随机选择一个整数R。</li>
<li>计算退避时间T，即T=R×基本退避时间。</li>
<li>如果重传次数达到16次仍未成功，则放弃传输并报告给上层协议。</li>
</ol>
<h4 id="总线型拓扑以太网"><a href="#总线型拓扑以太网" class="headerlink" title="总线型拓扑以太网"></a>总线型拓扑以太网</h4><ul>
<li><p>只能是半双工通信，适配器使用CSMA/CD协议</p>
</li>
<li><p>不能确定信道空闲后某一时间发送的帧一定不碰撞（发送的不确定性）</p>
</li>
<li><p>信道空闲一段时间（这段时间称为争用期/碰撞窗口 collision window）之后，才能保证发送的帧一定不碰撞，因此各站点需竞争</p>
</li>
</ul>
<h4 id="基于集线器的星形拓扑以太网（10BASE-T）"><a href="#基于集线器的星形拓扑以太网（10BASE-T）" class="headerlink" title="基于集线器的星形拓扑以太网（10BASE-T）"></a>基于集线器的星形拓扑以太网（10BASE-T）</h4><ul>
<li><p>使用双绞线 RJ-45 作为线缆和插头，使用集线器（hub）作为中心硬件</p>
</li>
<li><p>集线器内部仍然是用电子器件模拟实际电缆，实际上仍是总线型拓扑，适配器使用CSMA/CD协议</p>
</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/7f194dec14ad2db7fe353c0893c1ad62-1732332398363-2.jpg" alt="7f194dec14ad2db7fe353c0893c1ad62"></p>
<h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4><p>一个帧在发送之前必须经过若干个争用期2τ（发生碰撞），然后经过发送时延T<del>0</del>，再经历一个传播时延τ才能发到对面。发送过程占用总线的时间为T<del>0</del> + τ<br>$$<br>a=\frac{\tau}{T_0}<br>$$<br>因为传播时延τ的存在，碰撞之后不能立即检测到，造成了信道浪费，所以比值a越小越好，也就是连线尽量短一些，控制以太网帧长度不能太短（大于64字节）也不能太长（小于1518字节，MTU + 其他标识位）</p>
<h3 id="以太网帧"><a href="#以太网帧" class="headerlink" title="以太网帧"></a>以太网帧</h3><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>以太网的MAC地址为48位二进制数，有两个保留的标识位G/L与I/G，一共能表示2^46^个不同的地址，和网卡绑定在一起，存在网卡的ROM中，例：E4-FD-45-3E-4A-A4</p>
<h4 id="以太网帧、MAC帧格式（DIX-Ethernet-V2）"><a href="#以太网帧、MAC帧格式（DIX-Ethernet-V2）" class="headerlink" title="以太网帧、MAC帧格式（DIX Ethernet V2）"></a>以太网帧、MAC帧格式（DIX Ethernet V2）</h4><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F#Ethernet_II">以太网帧格式 - 维基百科，自由的百科全书</a> </p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF&%E7%89%A9%E7%90%86%E5%B1%82.assets/8639303972e62f982d1666dffca21057.jpg" alt="8639303972e62f982d1666dffca21057"></p>
<ul>
<li><p>前方7B是同步字段，告诉网卡调整时钟和发送端同步，最后1B也是同步段，11表示之后才是真正的以太网帧。</p>
</li>
<li><p>接下来的12B是<strong>目标地址</strong>和<strong>源地址</strong>，目标地址在前方便检查是不是发给自己的。</p>
</li>
<li><p><strong>类型</strong>占2B，用来区分数据负载<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%B1%BB%E5%9E%8B">以太类型</a>的字段ARP、IPv4等</p>
</li>
<li><p><strong>数据负载</strong>部分，长度最小为46B（整个以太网帧不能小于64B，否则CSMA/CD不能正常工作，还有好处就是提高了帧的传输效率(有效部分占的bi’lv)），最大为MTU(1500B，太长会导致发送与转发负担太重，一点小差错就要重传，反而降低了效率)</p>
</li>
<li><p><strong>FCS</strong>（帧校验序列）长度为固定4B，FCS不检测前8B的同步字段。</p>
</li>
<li><p>以太网帧有效长度 64B-1518B</p>
</li>
<li><p>有帧开始定界符，没有帧结束符或者长度。因为以太网使用曼彻斯特编码，因此只需要在帧之间留出一定空隙即可，检测到空隙则表示帧的结束。</p>
</li>
</ul>
<h2 id="物理层扩展以太网"><a href="#物理层扩展以太网" class="headerlink" title="物理层扩展以太网"></a>物理层扩展以太网</h2><ul>
<li><p><strong>转发器</strong>（repeater）：也叫中继器，早先通过其扩大局域网的物理范围</p>
</li>
<li><p><strong>集线器</strong>：将主机用光纤加一个modem与<strong>集线器</strong>（hub）连接起来，再用一个集线器分别连接几个集线器，这样做比较简单，但是系统总吞吐量有严重的木桶效应，hub也不能缓存网帧，比较低效。</p>
</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF&%E7%89%A9%E7%90%86%E5%B1%82.assets/2d8d54ff5a6ea450f7378124fb8cf209-1732358355703-4.jpg" alt="2d8d54ff5a6ea450f7378124fb8cf209"></p>
<h2 id="数据链路层扩展以太网"><a href="#数据链路层扩展以太网" class="headerlink" title="数据链路层扩展以太网"></a>数据链路层扩展以太网</h2><h3 id="网桥（bridge）"><a href="#网桥（bridge）" class="headerlink" title="网桥（bridge）"></a>网桥（bridge）</h3><p>使用软件，根据目的地址转发和过滤帧，维护一个地址表来确定具体的转发目标。能够隔离碰撞域</p>
<h3 id="交换机（switch）"><a href="#交换机（switch）" class="headerlink" title="交换机（switch）"></a>交换机（switch）</h3><ul>
<li><p>实质是多端口网桥，能够支持并行通信，并且有专门的硬件芯片用来转发过滤，比网桥快很多。</p>
</li>
<li><p>每个端口之间都是独占传输域，能够进行全双工通信（也就不用遵守CSMA/CD）总吞吐量没有木桶效应。</p>
</li>
<li><p>端口有存储器，能在繁忙时将网帧暂存。支持存储转发和直通（cut-through）多种方式，减小交换时延。</p>
</li>
<li><p>凭借<strong>自学习</strong>功能维护一个地址表（交换表），根据发出网帧的源MAC地址，将端口映射到MAC地址。</p>
</li>
</ul>
<h4 id="自学习"><a href="#自学习" class="headerlink" title="自学习"></a>自学习</h4><p>省去了人工配置的麻烦，即插即用</p>
<ul>
<li><p>一开始地址表为空，交换机通过MAC地址的源地址部分，确定A地址对应端口1，填到地址表中</p>
</li>
<li><p>不知道目标B地址的端口，因此采用<strong>广播帧</strong>的形式，其他网卡收到帧，发现目标地址不是自己，遂直接丢弃</p>
</li>
<li><p>B收到网帧，发现是发给自己的，收下。B再发出网帧到A，因此地址表中添加了B地址对应端口2的记录</p>
</li>
<li><p>下次有人想发给A或者B，直接按照地址表转发到对应端口就可以，不用再次<strong>广播</strong></p>
</li>
<li><p>弊端：广播帧可能会导致频繁的端口之间转发，消耗了很多没有必要消耗的网络资源（广播风暴）</p>
</li>
</ul>
<h3 id="虚拟局域网（Virtual-Local-Area-Network-VLAN）"><a href="#虚拟局域网（Virtual-Local-Area-Network-VLAN）" class="headerlink" title="虚拟局域网（Virtual Local Area Network, VLAN）"></a>虚拟局域网（Virtual Local Area Network, VLAN）</h3><p><a target="_blank" rel="noopener" href="https://support.huawei.com/enterprise/zh/doc/EDOC1100088136">IEEE 802.1Q封装的VLAN数据帧格式 - 华为</a> </p>
<ul>
<li><p>将一个大局域网（广播域）分成几个小的局域网，减少网络风暴的发生，并且能提高局域网内的私密性、安全性。</p>
</li>
<li><p>IEEE 802.1Q帧在原先的MAC帧的源地址后、类型字段前添加了VLAN字段，用于不同交换机之间的传输：</p>
</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF&%E7%89%A9%E7%90%86%E5%B1%82.assets/77e8ffb822418303da48f04e1094c8a4.jpg" alt="77e8ffb822418303da48f04e1094c8a4"></p>
<ul>
<li>在两台交换机之间能够组出很多个(4096)不同的网络（VLAN）如果发送目标横跨交换机，则交换机1会发送IEEE 802.1Q帧，再由交换机2将标签去掉把原先的MAC帧传给目标。</li>
</ul>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF&%E7%89%A9%E7%90%86%E5%B1%82.assets/359e5dc70c67ed8789ffb347a4237c7f.jpg" alt="359e5dc70c67ed8789ffb347a4237c7f"></p>
<ul>
<li>对于A与C的通信，他们不属于同一个局域网，因此不是数据链路层所能解决的，需要路由器（当然有的交换机也有附加的功能，称为L3/L2 switch，与L2 switch相对）</li>
</ul>
<h2 id="以太网的宽带接入（PPPoE）"><a href="#以太网的宽带接入（PPPoE）" class="headerlink" title="以太网的宽带接入（PPPoE）"></a>以太网的宽带接入（PPPoE）</h2><ul>
<li>ADSL、拨号上网需要猫（调制解调器，modem）负责模拟信号和数字信号的转换</li>
<li>如果是光纤到户FTTH需要光猫（光纤网络终端，Optical Network Terminal）负责光信号与数字信号的转换</li>
<li>FTTB，FTTF则连光猫也不需要了</li>
</ul>
<h1 id="无线网络"><a href="#无线网络" class="headerlink" title="无线网络"></a>无线网络</h1><h2 id="无线网络与以太网"><a href="#无线网络与以太网" class="headerlink" title="无线网络与以太网"></a>无线网络与以太网</h2><p><strong>物理介质：</strong></p>
<ul>
<li>**无线网络 (Wi-Fi 和蜂窝移动网络)**：使用无线电波或微波作为通信介质，无需物理线缆。</li>
<li>**以太网 (Ethernet)**：使用有线连接（如双绞线、光纤）作为通信介质，需要物理布线。</li>
</ul>
<p><strong>标准协议：</strong></p>
<ul>
<li><strong>无线网络</strong>：<ul>
<li>**Wi-Fi (802.11 系列)**：基于 IEEE 802.11 协议，适用于局域网 (WLAN)。</li>
<li><strong>蜂窝移动网络</strong>：包括 2G、3G、4G、5G，主要用于广域网 (WAN)。</li>
</ul>
</li>
<li><strong>以太网</strong>：基于 IEEE 802.3 协议，主要应用于局域网 (LAN)。</li>
</ul>
<p><strong>覆盖范围：</strong></p>
<ul>
<li><strong>无线网络</strong>：<ul>
<li>Wi-Fi 的典型覆盖范围是几十米，适合室内使用。</li>
<li>蜂窝网络覆盖范围更广，可以跨城市、国家甚至全球。</li>
</ul>
</li>
<li><strong>以太网</strong>：<ul>
<li>受限于线缆长度，一般在100米以内，需要交换机或路由器扩展覆盖范围。</li>
</ul>
</li>
</ul>
<p><strong>传输速度：</strong></p>
<ul>
<li><strong>无线网络</strong>：<ul>
<li>Wi-Fi 6（802.11ax）理论速度可达 9.6 Gbps。</li>
<li>蜂窝网络的 5G 技术最高速度可达 10 Gbps。</li>
</ul>
</li>
<li><strong>以太网</strong>：<ul>
<li>常见的千兆以太网 (1 Gbps) 和万兆以太网 (10 Gbps) 具有更稳定的高速连接。</li>
</ul>
</li>
</ul>
<p><strong>移动性：</strong></p>
<ul>
<li><strong>无线网络</strong>：用户可以自由移动而不影响网络连接，尤其是蜂窝网络支持无缝切换。</li>
<li><strong>以太网</strong>：由于需要有线连接，设备的移动性受到限制。</li>
</ul>
<p><strong>安全性：</strong></p>
<ul>
<li><strong>无线网络</strong>：容易受到信号干扰和窃听攻击，需要依赖加密协议（如 WPA3）增强安全性。</li>
<li><strong>以太网</strong>：由于是物理连接，安全性相对较高，受到外部攻击的风险较低。</li>
</ul>
<h2 id="碰撞协议"><a href="#碰撞协议" class="headerlink" title="碰撞协议"></a>碰撞协议</h2><h3 id="CSMA-CA-Collision-Avoidance-WLAN"><a href="#CSMA-CA-Collision-Avoidance-WLAN" class="headerlink" title="CSMA/CA: Collision Avoidance (WLAN)"></a>CSMA/CA: <strong>Collision Avoidance</strong> (WLAN)</h3><ul>
<li><p><strong>机制</strong>：</p>
<ol>
<li><strong>监听信道</strong>：设备在发送数据前先监听信道是否空闲。</li>
<li>**等待随机时间 (Backoff)**：即使信道空闲，设备也会等待一段随机时间，以减少多个设备同时发送的概率。</li>
<li>**发送 RTS/CTS (可选)**：使用请求发送 (RTS) 和清除发送 (CTS) 控制帧来保留信道，避免隐藏节点问题。其他节点在监听到 RTS 或 CTS 时暂停发送数据，从而减少冲突风险。</li>
<li>**确认 (ACK)**：接收端发送确认帧，确保数据成功接收。如果未收到确认，则重新发送数据。</li>
</ol>
</li>
<li><p><strong>优点</strong>：</p>
<ol>
<li>避免了碰撞的直接发生，适合共享信道的无线环境。</li>
<li>RTS/CTS 机制解决隐藏节点问题，减少冲突概率。</li>
</ol>
</li>
<li><p><strong>缺点</strong>：</p>
<ol>
<li><p>增加额外的通信开销（RTS、CTS 和 ACK 等控制帧）。</p>
</li>
<li><p>多用户高并发时容易导致延迟增加和吞吐量下降。</p>
</li>
</ol>
</li>
</ul>
<h3 id="CSMA-CD-Collision-Detection-Ethernet"><a href="#CSMA-CD-Collision-Detection-Ethernet" class="headerlink" title="CSMA/CD: Collision Detection (Ethernet)"></a>CSMA/CD: <strong>Collision Detection</strong> (<strong>Ethernet</strong>)</h3><ul>
<li><p><strong>机制</strong>：</p>
<ol>
<li><strong>监听信道</strong>：设备在发送数据前检测信道是否空闲。</li>
<li><strong>发送数据</strong>：如果信道空闲，立即发送数据。</li>
<li><strong>检测碰撞</strong>：发送时同时监听信道，如果检测到冲突（信号干扰或能量变化），停止发送。</li>
<li>**退避 (Backoff)**：碰撞后等待随机时间重试发送（BEB），减少再次碰撞概率。</li>
</ol>
<ul>
<li><strong>现代以太网多采用交换机连接，并支持全双工通信，每个设备有独立信道，不再使用 CSMA/CD。无碰撞问题，提高效率和可靠性。支持更高的带宽和多设备并发通信。</strong></li>
</ul>
</li>
<li><p>优点：</p>
<ol>
<li>机制简单，适合有线环境。</li>
<li>在小型局域网中具有较高效率。</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>需要碰撞发生后才能检测和处理，效率相对低于 CSMA/CA。</li>
<li>在高负载环境下碰撞频率增加，导致性能下降。</li>
</ol>
</li>
</ul>
<h3 id="CSMA-CA-vs-CSMA-CD"><a href="#CSMA-CA-vs-CSMA-CD" class="headerlink" title="CSMA/CA vs. CSMA/CD"></a>CSMA/CA vs. CSMA/CD</h3><table>
<thead>
<tr>
<th>协议</th>
<th>解决冲突方式</th>
<th>使用环境</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CSMA/CD</strong></td>
<td>冲突检测 + 重传</td>
<td>有线网络（如以太网）</td>
<td>高速、低延迟</td>
</tr>
<tr>
<td><strong>CSMA/CA</strong></td>
<td>冲突避免 + 请求确认</td>
<td>无线网络（如Wi-Fi）</td>
<td>更安全、适合无线不稳定环境</td>
</tr>
</tbody></table>
<ul>
<li><strong>CSMA/CD</strong> 适合<strong>有线网络</strong>，由于信道稳定，可以边发送边检测冲突并重试。</li>
<li><strong>CSMA/CA</strong> 适合<strong>无线网络</strong>，因为无线信号不稳定，通过握手机制降低冲突发生的概率。</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th><strong>CSMA/CD</strong></th>
<th><strong>CSMA/CA</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>应用场景</strong></td>
<td>有线网络（以太网, 802.3）</td>
<td>无线网络（如 Wi-Fi/802.11）</td>
</tr>
<tr>
<td><strong>冲突处理机制</strong></td>
<td>冲突检测（Collision Detection）</td>
<td>冲突避免（Collision Avoidance）</td>
</tr>
<tr>
<td><strong>数据发送机制</strong></td>
<td>先发送数据，边发送边检测冲突。</td>
<td>发送前通过 RTS/CTS 机制避免冲突。</td>
</tr>
<tr>
<td><strong>检测方式</strong></td>
<td>可通过检测电压变化检测冲突（有线信号明显）。</td>
<td>无法检测冲突（无线信号难以同时发送和接收）。</td>
</tr>
<tr>
<td><strong>解决冲突方法</strong></td>
<td>冲突发生后停止发送，退避后重试。</td>
<td>通过等待时间和握手机制减少冲突。</td>
</tr>
<tr>
<td><strong>适用介质</strong></td>
<td>有线介质，信号传播稳定。</td>
<td>无线介质，信号传播容易受到干扰。</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>高速、低延迟，适合稳定传输环境。</td>
<td>延迟较高，适合信号不稳定的环境。</td>
</tr>
<tr>
<td><strong>是否完全避免碰撞</strong></td>
<td>碰撞不可避免，需通过重传恢复</td>
<td>理论上可以避免，但控制开销较大</td>
</tr>
<tr>
<td><strong>现代改进</strong></td>
<td>使用交换机+全双工，完全避免碰撞</td>
<td>保留 CSMA/CA，适合无线共享环境</td>
</tr>
</tbody></table>
<h2 id="WPAN"><a href="#WPAN" class="headerlink" title="WPAN"></a>WPAN</h2><p><strong>WPAN（Wireless Personal Area Network，无线个人区域网络）</strong> 是一种覆盖范围较小的无线网络技术，通常用于个人设备之间的短距离通信</p>
<p><strong>1. 定义与特点</strong></p>
<p><strong>定义：</strong>WPAN 是一种用于设备之间<strong>短距离无线通信</strong>的网络技术，支持个人或便携式设备的互联互通，例如手机、笔记本电脑、无线耳机等。</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>覆盖范围小：</strong> 通常在 <strong>10米</strong> 左右，有些技术最多支持 <strong>100米</strong>。</li>
<li><strong>低功耗：</strong> 适合便携式设备使用，续航时间长。</li>
<li><strong>高便携性：</strong> 支持移动设备随时建立网络。</li>
<li><strong>点对点通信：</strong> 支持多种设备直接连接，无需复杂的基础设施。</li>
<li><strong>成本低廉：</strong> 适合小型设备和物联网应用。</li>
</ul>
<p><strong>2. 常见-协议与标准</strong></p>
<table>
<thead>
<tr>
<th>协议/标准</th>
<th>描述</th>
<th>应用场景</th>
<th>防碰撞协议</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Bluetooth</strong></td>
<td>短距离无线通信标准，覆盖范围约 10 米，低功耗版本为 BLE。</td>
<td>无线耳机、键盘、鼠标、传感器设备等。</td>
<td><strong>FHSS</strong> 和 <strong>AFH</strong></td>
</tr>
<tr>
<td><strong>ZigBee</strong></td>
<td>专为低功耗和低数据速率设计的无线标准，适合物联网应用。</td>
<td>智能家居、远程控制、传感器网络。</td>
<td><strong>CSMA/CA</strong></td>
</tr>
<tr>
<td><strong>Infrared (IR)</strong></td>
<td>基于红外线通信的短距离无线技术，传输速率较低。</td>
<td>遥控器、数据同步、设备控制。</td>
<td><strong>TDMA</strong></td>
</tr>
<tr>
<td><strong>UWB (Ultra-Wideband)</strong></td>
<td>提供高精度定位和高速传输，适合短距离数据交换和测距应用。</td>
<td>精准定位、物联网设备、车联网通信。</td>
<td></td>
</tr>
<tr>
<td><strong>NFC (Near Field Communication)</strong></td>
<td>超短距离无线通信，通常在几厘米范围内进行快速数据交换。</td>
<td>移动支付、门禁卡、电子票务。</td>
<td><strong>TDMA</strong></td>
</tr>
</tbody></table>
<p>小型无线设备（如 RFID）采用 <strong>Slotted ALOHA</strong>，适合简单需求。</p>
<p><strong>3. 应用场景</strong></p>
<ol>
<li><strong>智能家居：</strong> ZigBee 协议用于灯光控制、温度调节等智能设备之间的互联。</li>
<li><strong>物联网（IoT）：</strong> BLE 和 ZigBee 支持低功耗设备之间的数据采集与传输。</li>
<li><strong>移动支付：</strong> NFC 支持手机支付、身份识别等功能。</li>
<li><strong>便携设备互联：</strong> Bluetooth 用于耳机、智能手表等无线连接。</li>
<li><strong>健康监测：</strong> 无线传感器与可穿戴设备之间的数据交互。</li>
<li><strong>精准定位：</strong> UWB 支持室内定位和安全设备跟踪。</li>
</ol>
<p><strong>4. 与其他-网络的比较</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>范围</th>
<th>特点</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>WPAN</strong></td>
<td>1-10 米</td>
<td>短距离、低功耗、适合个人设备通信。</td>
<td>蓝牙、ZigBee、NFC。</td>
</tr>
<tr>
<td><strong>WLAN</strong></td>
<td>10-100 米</td>
<td>支持中等距离的高速无线通信，需要基础设施。</td>
<td>Wi-Fi。</td>
</tr>
<tr>
<td><strong>WMAN</strong></td>
<td>1-10 千米</td>
<td>城域无线网络，适合大规模覆盖。</td>
<td>WiMAX。</td>
</tr>
<tr>
<td><strong>WWAN</strong></td>
<td>覆盖整个地区或国家</td>
<td>广域无线网络，通过蜂窝网络支持移动设备通信。</td>
<td>4G、5G 移动通信网络。</td>
</tr>
</tbody></table>
<h2 id="移动网络"><a href="#移动网络" class="headerlink" title="移动网络"></a>移动网络</h2><p>CSMA/CA 和 CSMA/CD 是分布式介质访问控制协议，属于动态划分信道</p>
<ul>
<li><p>竞争式访问（监听信道）：<strong>CSMA</strong> 并不通过物理上的分离信道来避免冲突，而是让多个用户共享同一个信道。因此会有冲突的风险。当信道繁忙时，用户需要监听并等待信道空闲才能发送数据。信道的访问是竞争式的，用户依赖于监听信道的状态来判断是否发送数据。</p>
</li>
<li><p>适合短距离、设备数量较少的环境，如家庭或办公室的无线网络</p>
</li>
<li><p>通信节点之间自主决定发送时机，不需要集中式调度。</p>
</li>
<li><p>采用竞争机制，存在碰撞和重传开销，效率较低，不适合大规模、高负载的网络环境。</p>
</li>
</ul>
<p>蜂窝网络：</p>
<ul>
<li><p>CDMA TDMA FDMA 这些 MA 技术通过时间、频率、伪随机码等方式将信道划分为多个独立的信道，每个用户独占属于自己的信道，属于静态划分信道</p>
</li>
<li><p><strong>蜂窝网络的流量远高于局域网（如 Wi-Fi）</strong>，需要更高的效率和更严格的资源调度</p>
</li>
<li><p>采用集中式的<strong>基站控制</strong>，具有严格的调度和资源分配机制。</p>
</li>
<li><p>需要支持<strong>用户移动性</strong>，并保证跨基站切换过程的无缝通信。</p>
</li>
<li><p>需要满足严格的<strong>服务质量（QoS）</strong>要求，例如语音通话和视频流的低延迟、高可靠性。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>技术</th>
<th>工作方式</th>
<th>应用场景</th>
<th>主要特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ALOHA</strong></td>
<td>随机发送，碰撞后重传</td>
<td>低负载无线通信</td>
<td>简单但碰撞率高，适合控制信令。</td>
</tr>
<tr>
<td><strong>Slotted ALOHA</strong></td>
<td>分时发送，减少碰撞</td>
<td>控制信道接入（如 GSM 控制信道）RFID</td>
<td>效率较高，但需要时钟同步。</td>
</tr>
<tr>
<td><strong>TDMA</strong></td>
<td>固定时隙分配，无碰撞</td>
<td>GSM、低速蜂窝网络</td>
<td>高效，但资源利用率依赖时隙分配。</td>
</tr>
<tr>
<td><strong>FDMA</strong></td>
<td>频率划分，无碰撞</td>
<td>早期模拟蜂窝和2G网络</td>
<td>固定频率分配，利用率低。</td>
</tr>
<tr>
<td><strong>CDMA</strong></td>
<td>扩频码区分用户，无碰撞</td>
<td>3G 网络、CDMA2000</td>
<td>无需时隙和频率划分，抗干扰能力强。</td>
</tr>
<tr>
<td><strong>OFDMA</strong></td>
<td>子载波分配，无碰撞</td>
<td>4G LTE 和 5G NR</td>
<td>支持多用户，频谱利用率高，适合高负载。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/12/29/%E7%BD%91%E7%BB%9C%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/29/%E7%BD%91%E7%BB%9C%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">OSI参考模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-29 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-29T00:00:00+08:00">2024-12-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-03 20:53:02" itemprop="dateModified" datetime="2025-05-03T20:53:02+08:00">2025-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E7%BD%91%E7%BB%9C%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.assets/image-20241206210725603.png" alt="image-20241206210725603"></p>
<p>表示层：数据的编解码与加解密，以及压缩，socket也属于这一层</p>
<p>会话层：连接的建立</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h2><p>inter-前缀意为“相互的”，internet表示相互连接的网络，任意的通信协议。</p>
<p>Internet表示全球最大的开放特定计算机网络，使用TCP/IP协议族作为通信规则，前身为ARPANET</p>
<h3 id="发展概述"><a href="#发展概述" class="headerlink" title="发展概述"></a>发展概述</h3><h4 id="ARPANET-gt-Internet"><a href="#ARPANET-gt-Internet" class="headerlink" title="ARPANET -&gt; Internet"></a>ARPANET -&gt; Internet</h4><ul>
<li>1969，ARPANET</li>
<li>mid 1970s，多种网络互联的研究</li>
<li><strong>1983</strong>，TCP/IP成为ARPANET的标准协议，也是公认的Internet诞生时间</li>
</ul>
<h4 id="三级结构的Internet"><a href="#三级结构的Internet" class="headerlink" title="三级结构的Internet"></a>三级结构的Internet</h4><ul>
<li>1985，NSFNET</li>
<li>1990，ARPANET closed</li>
<li>1991，Internet开始商业化</li>
</ul>
<h4 id="多层次ISP结构的Internet"><a href="#多层次ISP结构的Internet" class="headerlink" title="多层次ISP结构的Internet"></a>多层次ISP结构的Internet</h4><ul>
<li>1993，NSFNET逐渐被商用Internet主干网取代，政府机构将其交给ISP运营</li>
<li>1994，万维网WWW技术促使因特网迅猛发展</li>
<li>1995，NSFNET停止运作，Internet正式商业化</li>
</ul>
<h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><p> <img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028134459569.png" alt="image-20241028134459569"></p>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028134717845.png" alt="image-20241028134717845"></p>
<h3 id="标准化—RFC"><a href="#标准化—RFC" class="headerlink" title="标准化—RFC"></a>标准化—RFC</h3><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028134853049.png" alt="image-20241028134853049"></p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028134950779.png" alt="image-20241028134950779"></p>
<h2 id="信息交换技术"><a href="#信息交换技术" class="headerlink" title="信息交换技术"></a>信息交换技术</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028151306409.png" alt="image-20241028151306409"></p>
<h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028151319591.png" alt="image-20241028151319591"></p>
<p>报文加首部，便于给交换机提供信息</p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028151351499.png" alt="image-20241028151351499"></p>
<p>将原来的报文分组，带首部依次发送每个组</p>
<h2 id="计算机网络概念"><a href="#计算机网络概念" class="headerlink" title="计算机网络概念"></a>计算机网络概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><p><strong>互连</strong></p>
<p>通过有线/无线方式进行通信</p>
<p><strong>集合</strong></p>
<p>至少两台以上计算机</p>
<p><strong>自治</strong></p>
<p>独立的计算机，具备自己的硬件和软件，</p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><strong>一些</strong> 通用可编程的<strong>硬件</strong>（包括智能手机、电脑等各种计算机，这些硬件并不只用于数据通信，而且能支持广泛的应用程序）<strong>互联</strong>而成。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><strong>按交换技术分类</strong></p>
<ul>
<li>电路交换</li>
<li>报文交换</li>
<li>分组交换</li>
</ul>
<p><strong>按使用者分类</strong></p>
<ul>
<li>专用</li>
<li>公用</li>
</ul>
<p><strong>按传输介质分类</strong></p>
<ul>
<li>有线 Wired</li>
<li>无线 Wireless</li>
</ul>
<p><strong>按覆盖范围分类</strong></p>
<p>覆盖范围从大到小排列：</p>
<ul>
<li><strong>广域网</strong> <strong>WAN</strong> Wide Area 国家、洲</li>
<li>城域网 MAN Metropolitan Area 城市 </li>
<li><strong>局域网</strong> <strong>LAN</strong> Local Area 机构、楼房</li>
<li>个域网 PAN Personal Area 个人电子设备 组成的多处理机系统WPAN </li>
</ul>
<p><strong>按拓扑结构分类</strong></p>
<ul>
<li><p>总线</p>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028160634851.png" alt="image-20241028160634851"></p>
</li>
<li><p>星型</p>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028160648577.png" alt="image-20241028160648577"></p>
</li>
<li><p>环形</p>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028160700477.png" alt="image-20241028160700477"></p>
</li>
<li><p>网状</p>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028160718347.png" alt="image-20241028160718347"></p>
</li>
</ul>
<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><h4 id="比特、字节、速率（数据率，比特率）"><a href="#比特、字节、速率（数据率，比特率）" class="headerlink" title="比特、字节、速率（数据率，比特率）"></a>比特、字节、速率（数据率，比特率）</h4><p>1 GiB = 2^30^ B（操作系统）  1 GB = 10^9^ B（硬盘厂商） binary 表示二进制</p>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028161416193.png" alt="image-20241028161416193"></p>
<ul>
<li>kilo bps, ==k==bps, Mbps, Gbps, Tbps : 1000</li>
<li>B, KB, MB, GB, GB : 1024 </li>
<li>bps 进制为1000，Byte 进制为1024，8 b = 1 B</li>
</ul>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028161845070.png" alt="image-20241028161845070"></p>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028162145504.png" alt="image-20241028162145504"></p>
<h4 id="带宽（Band-Width）"><a href="#带宽（Band-Width）" class="headerlink" title="带宽（Band Width）"></a>带宽（Band Width）</h4><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028163439507.png" alt="image-20241028163439507"></p>
<p>1 Mbps = 0.125 MB/s = 128 KB/s 下载速度一般用字节表示</p>
<h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028163850891.png" alt="image-20241028163850891"></p>
<h4 id="时延（Delay）"><a href="#时延（Delay）" class="headerlink" title="时延（Delay）"></a>时延（Delay）</h4><h5 id="主机的发送速率"><a href="#主机的发送速率" class="headerlink" title="主机的发送速率"></a>主机的发送速率</h5><p>主机的发送速率，由<strong>网卡的发送速率</strong>、<strong>信道带宽</strong>、<strong>接口速率</strong>共同决定，取最小的那一个，速率应该尽量匹配。</p>
<h5 id="发送时延、传播时延、处理时延"><a href="#发送时延、传播时延、处理时延" class="headerlink" title="发送时延、传播时延、处理时延"></a>发送时延、传播时延、处理时延</h5><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028164902463.png" alt="image-20241028164902463"></p>
<p><strong>发送时延</strong>-&gt;发送速率和分组数据包长度</p>
<p><strong>传播时延</strong>-&gt;电线长度和光速（电磁波速率）</p>
<p><strong>处理时延</strong>-&gt;忽略</p>
<p>在发送数据时，电流的大小或电压水平会发生变化，这些变化被用来表示一串二进制码。具体来说，以下是这个过程的简要说明：</p>
<ol>
<li><strong>信号变化</strong>：在数字信号传输中，电流或电压会在不同的电平之间切换。比如，当电流达到某个高电压水平时，可以表示比特1，而在低电压水平时表示比特0。</li>
<li><strong>时间同步</strong>：为了确保接收方能够正确识别这些电压变化，发送方和接收方通常会使用时钟信号进行同步。这保证了信号在正确的时间被读取，从而将电流的变化准确地转化为二进制数据。</li>
<li><strong>比特流的形成</strong>：这些电流变化在时间轴上连续发生，从而形成一个比特流（例如 10101010），每个比特对应一个电压状态的变化。</li>
</ol>
<p>通过这些方式，电流的变化被抽象为数字信息，使得数据可以在计算机和网络之间进行有效传输。</p>
<h6 id="哪一个占主导？"><a href="#哪一个占主导？" class="headerlink" title="哪一个占主导？"></a>哪一个占主导？</h6><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028164759500.png" alt="image-20241028164759500"></p>
<h5 id="时延计算要点"><a href="#时延计算要点" class="headerlink" title="时延计算要点"></a>时延计算要点</h5><p><strong>1个分组，1段链路</strong></p>
<p>从上图也可以看出，即使是100MB的数据块，一共是800M个比特，发送时延都是全部计入的，而传播时延只需将距离除以传输速度即可。</p>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241029204300220.png" alt="image-20241029204300220"></p>
<p>横坐标是时间，纵坐标是位置，比特是一个接着一个向前传播的，发送时延取决于发送方：每个比特的发送时间都要计入发送时延，传播时延取决于最后一个比特的尾部传到对面所需的时间。</p>
<p><strong>n个分组，n段链路</strong></p>
<ul>
<li>第一段链路：n个分组发送时延+1个传播时延</li>
<li>第二段链路：发送和接收同时进行，等到第一段链路传输完成，第二段还剩最后1个分组未发送，因此第二段链路的实际时延为1个分组发送时延+1个传播时延</li>
</ul>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241029205641630.png" alt="image-20241029205641630"></p>
<ul>
<li>n段路,m组：n个传播时延+[m+(n-1)*1]个分组发送时延，</li>
<li>存储转发：只有完整地接收一个比特，才能开始发送的工作</li>
</ul>
<p><strong>电路交换和分组交换时延</strong></p>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241029211907159.png" alt="image-20241029211907159"></p>
<ul>
<li>电路先要建立连接，然后直接发送整个报文，<strong>没有存储转发</strong>，相当于一组一链路</li>
<li><strong>分组交换不用先建立连接，每一个分组采用存储转发方式</strong>。牢记四个变量：<ul>
<li><strong>1个分组发送时间</strong>，</li>
<li><strong>分组数量</strong>，</li>
<li><strong>1个链路传播时间</strong>，</li>
<li><strong>链路数量</strong> </li>
</ul>
</li>
</ul>
<p><strong>报文交换和分组交换</strong></p>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241029213402856.png" alt="image-20241029213402856"></p>
<p>报文交换需要整整发送两次，分组交换需要发送组数加1次，流水线</p>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241029214114258.png" alt="image-20241029214114258"></p>
<h5 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h5><p>传播时延x带宽 传播过去一个比特的时间内，发送了多少比特，也称为比特单位的链路长度</p>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028170442570.png" alt="image-20241028170442570"></p>
<h4 id="往返时间（RTT）"><a href="#往返时间（RTT）" class="headerlink" title="往返时间（RTT）"></a>往返时间（RTT）</h4><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028180207539.png" alt="image-20241028180207539"></p>
<p>Round-Trip 传输耗时要考虑在内，<strong>双向交互</strong></p>
<h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028180135459.png" alt="image-20241028180135459"></p>
<h4 id="丢包率（Packet-Loss）"><a href="#丢包率（Packet-Loss）" class="headerlink" title="丢包率（Packet Loss）"></a>丢包率（Packet Loss）</h4><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028181110596.png" alt="image-20241028181110596"></p>
<p>一些路由算法在未满时就会有丢包操作</p>
<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><h3 id="OSI-参考模型-amp-TCP-IP-模型"><a href="#OSI-参考模型-amp-TCP-IP-模型" class="headerlink" title="OSI 参考模型 &amp; TCP/IP 模型"></a>OSI 参考模型 &amp; TCP/IP 模型</h3><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241029195855494.png" alt="image-20241029195855494"></p>
<p>表示层：通信双方交换信息表示问题（数据格式转换），包括字符集转换，数据格式化，文本压缩，数据加密和解密的工作</p>
<p>会话层：对话管理，会话管理</p>
<img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028182558729.png" alt="image-20241028182558729"  />

<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028182833901.png" alt="image-20241028182833901"></p>
<p>网络Network 网际Internet</p>
<p>核心：TCP IP</p>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028182726625.png" alt="image-20241028182726625"></p>
<h3 id="分层的必要性"><a href="#分层的必要性" class="headerlink" title="分层的必要性"></a>分层的必要性</h3><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028190200363.png" alt="image-20241028190200363"></p>
<h4 id="信号（bit）如何在两台机器之间传输—物理层"><a href="#信号（bit）如何在两台机器之间传输—物理层" class="headerlink" title="信号（bit）如何在两台机器之间传输—物理层"></a>信号（bit）如何在两台机器之间传输—物理层</h4><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028185123827.png" alt="image-20241028185123827"></p>
<h4 id="分组如何在网络内传输—数据链路层（MAC地址）"><a href="#分组如何在网络内传输—数据链路层（MAC地址）" class="headerlink" title="分组如何在网络内传输—数据链路层（MAC地址）"></a>分组如何在网络内传输—数据链路层（MAC地址）</h4><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028185259670.png" alt="image-20241028185259670"></p>
<p>PPP ARP </p>
<h4 id="分组如何在不同网络间传输（路由）—网络层（IP地址）"><a href="#分组如何在不同网络间传输（路由）—网络层（IP地址）" class="headerlink" title="分组如何在不同网络间传输（路由）—网络层（IP地址）"></a>分组如何在不同网络间传输（路由）—网络层（IP地址）</h4><p>核心协议：IP ICMP</p>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028185452878.png" alt="image-20241028185452878"></p>
<h4 id="进程之间基于网络的通信，端到端的通信—传输层（端口号）"><a href="#进程之间基于网络的通信，端到端的通信—传输层（端口号）" class="headerlink" title="进程之间基于网络的通信，端到端的通信—传输层（端口号）"></a>进程之间基于网络的通信，端到端的通信—传输层（端口号）</h4><p>核心协议：TCP UDP</p>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028185918747.png" alt="image-20241028185918747"></p>
<h4 id="应用进程之间的交互实现特定网络—应用层"><a href="#应用进程之间的交互实现特定网络—应用层" class="headerlink" title="应用进程之间的交互实现特定网络—应用层"></a>应用进程之间的交互实现特定网络—应用层</h4><p>核心协议:HTTP POP3 SMTP（TCP）  DNS  RTP(UDP)</p>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028190013193.png" alt="image-20241028190013193"></p>
<h3 id="案例：在浏览器敲下一个URL后发生了什么？—应用进程间基于网络的通信"><a href="#案例：在浏览器敲下一个URL后发生了什么？—应用进程间基于网络的通信" class="headerlink" title="案例：在浏览器敲下一个URL后发生了什么？—应用进程间基于网络的通信"></a>案例：在浏览器敲下一个URL后发生了什么？—应用进程间基于网络的通信</h3><p>浏览器发送HTTP请求（访问URL指向的资源），HTTP属于应用层协议，需要向下传输通过物理层传到路由器的物理层，再向上传输到达网络层，经过解析之后，再通过物理层传到服务器的物理层，物理层向上传输到应用层，应用层的Web服务器应用程序会解析HTTP报文，之后返回HTTP响应（URL对应的资源），通过类似的方法传回给浏览器进程。</p>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/9c941130d600033193a3e02800da8fd.jpg" alt="9c941130d600033193a3e02800da8fd"></p>
<h3 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h3><p>对等<strong>实体</strong>通过所属层级的通信<strong>协议</strong>，在下方层级的<strong>服务</strong>（下层两个对等实体间的逻辑通信能够向上层提供服务）下进行逻辑通信（不用考虑其他层，实际上这种通信不存在）。</p>
<h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><h5 id="对等实体"><a href="#对等实体" class="headerlink" title="对等实体"></a>对等实体</h5><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028204310699.png" alt="image-20241028204310699"></p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028204254883.png" alt="image-20241028204254883"></p>
<h5 id="语法：定义报文格式"><a href="#语法：定义报文格式" class="headerlink" title="语法：定义报文格式"></a>语法：定义报文格式</h5><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028204056703.png" alt="image-20241028204056703"></p>
<h5 id="语义：根据语法解析报文内容，定义出双方行为"><a href="#语义：根据语法解析报文内容，定义出双方行为" class="headerlink" title="语义：根据语法解析报文内容，定义出双方行为"></a>语义：根据语法解析报文内容，定义出双方行为</h5><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028204146999.png" alt="image-20241028204146999"></p>
<h5 id="同步：行为发生的时序关系（先后顺序）"><a href="#同步：行为发生的时序关系（先后顺序）" class="headerlink" title="同步：行为发生的时序关系（先后顺序）"></a>同步：行为发生的时序关系（先后顺序）</h5><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028204026941.png" alt="image-20241028204026941"></p>
<h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028203948172.png" alt="image-20241028203948172"></p>
<h5 id="服务访问点、服务原语"><a href="#服务访问点、服务原语" class="headerlink" title="服务访问点、服务原语"></a>服务访问点、服务原语</h5><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028203743701.png" alt="image-20241028203743701"></p>
<h5 id="协议数据单元PDU、服务数据单元SDU"><a href="#协议数据单元PDU、服务数据单元SDU" class="headerlink" title="协议数据单元PDU、服务数据单元SDU"></a>协议数据单元PDU、服务数据单元SDU</h5><p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20241028203909481.png" alt="image-20241028203909481"></p>
<h1 id="面试要点"><a href="#面试要点" class="headerlink" title="面试要点"></a>面试要点</h1><ol>
<li>TCP/IP协议体系的认知 </li>
<li>链路层<ol>
<li>以太网帧的格式</li>
<li>MTU的概念</li>
<li>ARP协议（掌握一下ARP缓存的原理）</li>
</ol>
</li>
<li>网络层<ol>
<li>掌握IP的首部格式</li>
<li>掌握IP的分片</li>
<li>掌握IP选路</li>
<li>ICMP协议<ol>
<li>掌握报文格式</li>
<li>分类：查询 + 差错</li>
<li>两种 + 五种</li>
</ol>
</li>
</ol>
</li>
<li>传输层<ol>
<li>UDP，次要一点，掌握特点和首部各个字段</li>
<li>掌握TCP<ol>
<li>特点 + 首部字段 + 可靠机制</li>
<li>连接控制 ： 三次握手，四次挥手，同时打开，同时关闭，半关闭（可能问到为什么需要）</li>
<li>流量控制机制：滑动窗口，慢启动，拥塞避免，快速重传，快速恢复</li>
<li>超时重传机制</li>
</ol>
</li>
</ol>
</li>
<li>应用层<ol>
<li>掌握DNS协议<ol>
<li>名字空间</li>
<li>指针查询（反向查找或逆向解析）基本原理</li>
<li>DNS缓存</li>
</ol>
</li>
<li>FTP协议（活化石）：<ol>
<li>控制流和数据流</li>
<li>两种工作模式： PASV 和 PORT</li>
<li>各种指令和响应码</li>
<li>断点续传和匿名FTP的概念</li>
</ol>
</li>
<li>HTTP协议：<ol>
<li>报文格式：请求报文，响应报文，请求头各种字段，响应头各种字段。</li>
<li>HTTP状态码。</li>
<li>HTTPS协议。</li>
<li>握手的详细过程。</li>
<li>摘要算法，数字签名，数字证书的原理和过程。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">OSI模型 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p>在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/9636548?fromModule=lemma_inlink">网络通信</a>的过程中，将发出数据的主机称为源主机，接收数据的主机称为目的主机。当源主机发出数据时，数据在源主机中从上层向下层传送。源主机中的应用进程先将数据交给应用层，应用层加上必要的控制信息就成了报文流，向下传给传输层。传输层将收到的数据单元加上本层的控制信息，形成报文段、数据报，再交给网际层。网际层加上本层的控制信息据报，传给网络接口层。网络接口层将网际层交下来的IP数据报组装成帧，并以比特流的形式传给网络硬件（即物理层），数据就离开源主机。</p>
<p><img src="C:\Users\Lenovo\Pictures\markdownfile/image-20240921220715692.png" alt="image-20240921220715692"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/12/28/%E5%88%86%E5%B1%82%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/28/%E5%88%86%E5%B1%82%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">计网分层概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-28 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-28T00:00:00+08:00">2024-12-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-03 20:51:33" itemprop="dateModified" datetime="2025-05-03T20:51:33+08:00">2025-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="物理层、数据链路层"><a href="#物理层、数据链路层" class="headerlink" title="物理层、数据链路层"></a>物理层、数据链路层</h1><p><strong>双绞线、集线器（HUB）</strong>：多台计算机之间物理连接，遇到并发情况会有<strong>数据碰撞与紊乱</strong>，而且数据都是广播形式传递，无法同时向上和向下传输（半双工，相当于对讲机，只能听不能说）。CSMA/CD协议，发送以前进行载波侦听。属于物理层。</p>
<p><strong>交换机：</strong>全双工。物理连接，也支持和其他交换机连接（桥接）能更好处理并发情况，里面有一张mac地址表，用来区分不同设备，计算机1第一次联络计算机2，将计算机2的MAC地址发送给交换机，由于不知道这个mac对应哪个接口，交换机通过数据泛洪的方式，广播给所有计算机，都收到了，但只有计算机2对应的接口会回应，mac表中添加计算机2的信息，以后他们的通信就不需要广播了。<u>在数据链路层</u>。</p>
<p>重点：以太网帧 MTU概念 ARP协议(MAC和IP互查，缓存)</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="MAC-LLC"><a href="#MAC-LLC" class="headerlink" title="MAC LLC"></a>MAC LLC</h3><table>
<thead>
<tr>
<th align="right"></th>
<th><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">介质访问控制(MAC, Media Access Control)</a></th>
</tr>
</thead>
<tbody><tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2">电路交换(Channel-based)</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A2%91%E5%88%86%E5%A4%9A%E5%9D%80">FDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E4%BA%A4%E9%A0%BB%E5%88%86%E5%A4%9A%E5%9D%80">OFDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%B3%A2%E5%88%86%E5%A4%9A%E5%9D%80&action=edit&redlink=1">WDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SC-FDMA">SC-FDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%B6%E5%88%86%E5%A4%9A%E5%9D%80">TDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%9A%E9%A2%91%E6%97%B6%E5%88%86%E5%A4%9A%E5%9D%80&action=edit&redlink=1">MF-TDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%87%AA%E7%BB%84%E7%BB%87%E6%97%B6%E5%88%86%E5%A4%9A%E5%9D%80&action=edit&redlink=1">STDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%A2%BC%E5%A4%9A%E9%87%8D%E9%80%B2%E6%8E%A5">CDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/W-CDMA">W-CDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TD-CDMA">TD-CDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TD-SCDMA">TD-SCDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DS-CDMA">DS-CDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/FH-CDMA">FH-CDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E4%BA%A4%E9%A0%BB%E5%88%86%E5%A4%9A%E5%9D%80">OFHMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%9A%E8%BD%BD%E6%B3%A2%E7%A0%81%E5%88%86%E5%A4%9A%E5%9D%80&action=edit&redlink=1">MC-CDMA</a>SDMA<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%A7%E5%AE%B9%E9%87%8F%E7%A9%BA%E5%88%86%E5%A4%9A%E5%9D%80&action=edit&redlink=1">HC-SDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%9E%81%E5%88%86%E5%A4%9A%E5%9D%80&action=edit&redlink=1">PDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%84%89%E5%86%B2%E5%9C%B0%E5%9D%80%E5%A4%9A%E9%87%8D%E5%AD%98%E5%8F%96&action=edit&redlink=1">PAMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%97%B6%E6%9C%BA%E9%A9%B1%E5%8A%A8%E5%A4%9A%E5%9D%80&action=edit&redlink=1">ODMA</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">分组交换(Packet-based)</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%86%B2%E7%AA%81%E5%B9%B2%E6%89%B0%E6%81%A2%E5%A4%8D&action=edit&redlink=1">冲突干扰恢复</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%86%B2%E7%AA%81%E9%81%BF%E5%85%8D&action=edit&redlink=1">冲突避免</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%97%A0%E5%86%B2%E7%AA%81&action=edit&redlink=1">无冲突</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ALOHA">ALOHA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Slotted_ALOHA">Slotted ALOHA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=R-ALOHA&action=edit&redlink=1">R-ALOHA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%A6%E5%86%B2%E7%AA%81%E9%81%BF%E5%85%8D%E7%9A%84%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5&action=edit&redlink=1">MACA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%B8%A6%E5%86%B2%E7%AA%81%E9%81%BF%E5%85%8D%E7%9A%84%E6%97%A0%E7%BA%BF%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5&action=edit&redlink=1">MACAW</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BD%BD%E6%B3%A2%E4%BE%A6%E5%90%AC%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE">CSMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CSMA/CD">CSMA/CD</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CSMA/CA">CSMA/CA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%88%86%E6%95%A3%E5%BC%8F%E5%8D%94%E8%AA%BF%E5%8A%9F%E8%83%BD&action=edit&redlink=1">DCF</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%82%B9%E5%8D%8F%E8%B0%83%E5%8A%9F%E8%83%BD">PCF</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%B7%B7%E5%90%88%E5%8D%8F%E8%B0%83%E5%8A%9F%E8%83%BD&action=edit&redlink=1">HCF</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%B8%A6%E5%86%B2%E7%AA%81%E9%81%BF%E5%85%8D%E4%B8%8E%E5%88%86%E8%A7%A3%E7%9A%84%E6%9C%89%E8%BD%BD%E6%B3%A2%E4%BE%A6%E5%90%AC%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE&action=edit&redlink=1">CSMA/CARP</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A4%E7%89%8C%E7%8E%AF">令牌环</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A4%E7%89%8C%E6%80%BB%E7%BA%BF">令牌总线</a><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mobile_Slotted_Aloha">MS-ALOHA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9A%A8%E5%BB%BA%E5%8D%B3%E9%80%A3%E7%B6%B2%E8%B7%AF">MANET</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BB%8A%E8%BC%89%E9%9A%A8%E6%84%8F%E8%A1%8C%E5%8B%95%E7%B6%B2%E8%B7%AF">VANET</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%BB%B6%E8%BF%9F%E5%AE%B9%E5%BF%8D%E7%BD%91%E7%BB%9C&action=edit&redlink=1">DTN</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%8A%A8%E6%80%81%E6%BA%90%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE&action=edit&redlink=1">动态源路由协议</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%99%E5%B7%A5">双工方法</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%99%E5%B7%A5#%E6%99%82%E5%88%86%E9%9B%99%E5%B7%A5">时分双工</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%99%E5%B7%A5#%E9%A0%BB%E5%88%86%E9%9B%99%E5%B7%A5">频分双工</a></td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E9%93%BE%E8%B7%AF%E6%8E%A7%E5%88%B6">逻辑链路控制 - 维基百科，自由的百科全书 (wikipedia.org)</a> LLC</p>
<h3 id="无线网络"><a href="#无线网络" class="headerlink" title="无线网络"></a>无线网络</h3><h4 id="移动网络-Celluar-Network"><a href="#移动网络-Celluar-Network" class="headerlink" title="移动网络 (Celluar Network)"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%9C%82%E7%AA%9D%E7%BD%91%E7%BB%9C">移动网络 (Celluar Network)</a></h4><table>
<thead>
<tr>
<th align="right"></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/0G">0G</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%84%A1%E7%B7%9A%E9%9B%BB%E8%A9%B1">无线电话</a> （1946）</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E5%8B%95%E9%9B%BB%E8%A9%B1%E7%B3%BB%E7%B5%B1">MTS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Improved_Mobile_Telephone_Service&action=edit&redlink=1">IMTS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Altai_%EF%BC%88mobile_telephone_system%EF%BC%89&action=edit&redlink=1">Altai</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=OLT_%EF%BC%88mobile_network%EF%BC%89&action=edit&redlink=1">OLT</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=MTD_%EF%BC%88mobile_network%EF%BC%89&action=edit&redlink=1">MTA - MTB - MTC - MTD</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Advanced_Mobile_Telephone_System&action=edit&redlink=1">AMTS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Autotel&action=edit&redlink=1">Autotel （PALM）</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Autoradiopuhelin&action=edit&redlink=1">ARP</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=B-Netz&action=edit&redlink=1">B-Netz</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=AMR_radiotelephone_network_%EF%BC%88Czechoslovakia%EF%BC%89&action=edit&redlink=1">AMR</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/1G">1G</a>（1979）</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E6%AF%94%E5%BC%8F%E8%A1%8C%E5%8B%95%E9%9B%BB%E8%A9%B1%E7%B3%BB%E7%B5%B1">AMPS</a>家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E6%AF%94%E5%BC%8F%E8%A1%8C%E5%8B%95%E9%9B%BB%E8%A9%B1%E7%B3%BB%E7%B5%B1">AMPS - N-AMPS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Total_Access_Communication_System&action=edit&redlink=1">TACS - ETACS</a>其它<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Nordic_Mobile_Telephone&action=edit&redlink=1">NMT</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=C-Netz&action=edit&redlink=1">C-450</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Hicap&action=edit&redlink=1">Hicap</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Mobitex&action=edit&redlink=1">Mobitex</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=DataTAC&action=edit&redlink=1">DataTAC</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/2G">2G</a>（1991）</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GSM">GSM</a>/<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/3GPP">3GPP</a>家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GSM">GSM</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%B7%AF%E4%BA%A4%E6%8F%9B%E6%95%B8%E6%93%9A">CSD - HSCSD</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/3GPP2">3GPP2</a>家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CdmaOne">cdmaOne （IS-95）</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E6%AF%94%E5%BC%8F%E8%A1%8C%E5%8B%95%E9%9B%BB%E8%A9%B1%E7%B3%BB%E7%B5%B1">AMPS</a>家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/D-AMPS">D-AMPS （IS-54 and IS-136）</a>其它<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%9C%82%E7%AA%9D%E6%95%B0%E5%AD%97%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE">CDPD</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E6%95%B0%E5%AD%97%E5%A2%9E%E5%BC%BA%E7%BD%91%E7%BB%9C">iDEN</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/PDC">PDC</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AA%E4%BA%BA%E6%89%8B%E6%8C%81%E5%BC%8F%E7%94%B5%E8%AF%9D%E7%B3%BB%E7%BB%9F">PHS</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/2G">2G过渡 （2.5G, 2.75G）</a></td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GSM">GSM</a>/3GPP家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GPRS">GPRS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GSM%E5%A2%9E%E5%BC%BA%E6%95%B0%E6%8D%AE%E7%8E%87%E6%BC%94%E8%BF%9B">EDGE/EGPRS - Evolved EDGE</a>3GPP2家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CDMA2000">CDMA2000 1X</a>（TIA/EIA/IS-2000）<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CDMA2000">CDMA2000 1X Advanced</a>其它<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E6%95%B0%E5%AD%97%E5%A2%9E%E5%BC%BA%E7%BD%91%E7%BB%9C">WiDEN</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E5%A2%9E%E5%BC%B7%E7%84%A1%E7%B7%9A%E9%9B%BB%E8%A9%B1%E7%B3%BB%E7%B5%B1">DECT</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/3G">3G</a>（2001）</td>
<td>3GPP家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E7%A7%BB%E5%8A%A8%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F">UMTS</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/W-CDMA">UTRA-FDD / W-CDMA</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/FOMA">FOMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TD-SCDMA">UTRA-TDD LCR / TD-SCDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E7%A7%BB%E5%8A%A8%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F">UTRA-TDD HCR / TD-CDMA</a>3GPP2家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EV-DO">CDMA2000 1xEV-DO Release 0</a>（TIA/IS-856）</td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/3G">3G过渡 （3.5G, 3.75G, 3.9G）</a></td>
<td>3GPP家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%80%9F%E5%B0%81%E5%8C%85%E5%AD%98%E5%8F%96">HSPA</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%80%9F%E5%B0%81%E5%8C%85%E5%AD%98%E5%8F%96">HSDPA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%80%9F%E5%B0%81%E5%8C%85%E5%AD%98%E5%8F%96">HSUPA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%BC%94%E8%BF%9B%E5%BC%8FHSPA">HSPA+</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%BC%94%E8%BF%9B%E5%BC%8FHSPA">DC-HSDPA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%95%B7%E6%9C%9F%E6%BC%94%E9%80%B2%E6%8A%80%E8%A1%93">LTE</a>（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/E-UTRA">E-UTRA</a>）3GPP2家族CDMA2000 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EV-DO">1xEV-DO Revision A</a>（TIA/EIA/IS-856-A）<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EV-DO">EV-DO Revision B</a>（TIA/EIA/IS-856-B）<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EV-DO">EV-DO Revision C</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%B5%E6%B0%94%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%BC%9A">IEEE</a>家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WiMAX">Mobile WiMAX</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IEEE_802.16">IEEE 802.16e</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E4%BA%A4%E9%A0%BB%E5%88%86%E5%A4%8D%E7%94%A8">Flash-OFDM</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=IEEE_802.20&action=edit&redlink=1">iBurst （IEEE 802.20）</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WiBro">WiBro</a>   <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%B4%B2%E7%94%B5%E4%BF%A1%E6%A0%87%E5%87%86%E5%8D%8F%E4%BC%9A">ETSI</a>家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=HiperMAN&action=edit&redlink=1">HiperMAN</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/4G">4G</a>（2009） <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=IMT_Advanced&action=edit&redlink=1">IMT Advanced</a> （2013）</td>
<td>3GPP家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%B2%E9%9A%8E%E9%95%B7%E6%9C%9F%E6%BC%94%E9%80%B2%E6%8A%80%E8%A1%93">LTE Advanced</a>（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/E-UTRA">E-UTRA</a>）<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%B2%E9%9A%8E%E5%8D%87%E7%B4%9A%E7%89%88%E9%95%B7%E6%9C%9F%E6%BC%94%E9%80%B2%E6%8A%80%E8%A1%93">LTE Advanced Pro</a>（4.5G Pro/pre-5G/4.9G）IEEE家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WiMAX">WiMAX</a>（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IEEE_802.16">IEEE 802.16</a>m） WiMax 2.1 （<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LTE-TDD">LTE-TDD</a>/ <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%95%B7%E6%9C%9F%E6%BC%94%E9%80%B2%E6%8A%80%E8%A1%93">TD-LTE</a>）<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WiBro">WiBro</a></td>
</tr>
<tr>
<td align="right"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/5G">5G</a>（2019） <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=IMT-2020&action=edit&redlink=1">IMT-2020</a> （开发中）</td>
<td>3GPP家族<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/5G_NR">NR</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=NR-IIoT&action=edit&redlink=1">NR-IIoT</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=LTE-M&action=edit&redlink=1">LTE-M</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/NB-IoT">NB-IoT</a> 其它<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=DECT-5G&action=edit&redlink=1">DECT-5G</a></td>
</tr>
<tr>
<td align="right">相关</td>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%9C%82%E7%AA%9D%E7%BD%91%E7%BB%9C">蜂窝网络</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A2%91%E5%88%86%E5%A4%9A%E5%9D%80">FDMA</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E4%BA%A4%E9%A0%BB%E5%88%86%E5%A4%9A%E5%9D%80">OFDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%B6%E5%88%86%E5%A4%9A%E5%9D%80">TDMA</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Self-organized_time-division_multiple_access&action=edit&redlink=1">STDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%89%A9%E9%A2%91">SSMA</a> CDMA<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A9%BA%E5%88%86%E5%A4%9A%E5%9D%80">SDMA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A0%BB%E8%AD%9C%E6%95%88%E7%8E%87">频谱效率</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%9C%82%E7%AA%9D%E7%BD%91%E7%BB%9C%E9%A2%91%E7%8E%87&action=edit&redlink=1">频段</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/GSM%E9%A2%91%E6%AE%B5">GSM</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/UMTS%E9%A2%91%E6%AE%B5">UMTS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%80%8B%E4%BA%BA%E9%80%9A%E8%A8%8A%E6%9C%8D%E5%8B%99">PCS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=LTE_frequency_bands&action=edit&redlink=1">LTE</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/5G_NR%E9%A2%91%E6%AE%B5">5G NR</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%AF%AC%E9%A0%BB">移动宽频</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Push-to-talk">Push-to-talk</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MIMO">MIMO</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%95%BF%E6%9C%9F%E6%BC%94%E8%BF%9B%E8%AF%AD%E9%9F%B3%E6%89%BF%E8%BD%BD">VoLTE</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/VoNR">VoNR</a></td>
</tr>
</tbody></table>
<h4 id="无线局域网-WLAN"><a href="#无线局域网-WLAN" class="headerlink" title="无线局域网  (WLAN)"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91">无线局域网  (WLAN)</a></h4><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IEEE_802.11_(%E5%8E%9F%E5%A7%8B%E6%A0%87%E5%87%86)">IEEE 802.11</a> 是无线局域网（WLAN）的通用标准。</p>
<p>1999年，几家富有远见的公司联合起来组成了一个全球性非营利性协会——无线以太网兼容性联盟（Wireless Ethernet Compatibility Alliance, WECA），其目标是使用一种新的无线网络技术，无论品牌如何，都能带来最佳的用户体验。在2000年，该小组采用术语“Wi-Fi”作为其技术工作的专有名称，并宣布了正式名称：Wi-Fi Alliance。Wi-Fi产品经由Wi-Fi联盟的一家独立授权测试实验室进行严格测试，产品成功通过测试后，授予制造商或销售商使用Wi-Fi标志、Wi-Fi CERTIFIED标志和相关商标，Wi-Fi联盟使用术语“Wi-Fi CERTIFIED”来称呼这类通过认证的产品。802.11ax为Wi-Fi 6。</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Wi-Fi">Wi-Fi</a>与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IEEE_802.11">IEEE 802.11</a>常常被混淆，两者的区别可以概述为IEEE 802.11是一种无线局域网标准，而Wi-Fi是IEEE 802.11标准的一种实现。</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%84%A1%E7%B7%9A%E6%8E%A5%E5%85%A5%E9%BB%9E">无线接入点 - 维基百科，自由的百科全书 (wikipedia.org)</a> WAP</p>
<h5 id="无线个人网-WPAN"><a href="#无线个人网-WPAN" class="headerlink" title="无线个人网 (WPAN)"></a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%BA%BF%E4%B8%AA%E4%BA%BA%E7%BD%91">无线个人网 (WPAN)</a></h5><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%97%8D%E7%89%99">蓝牙 - 维基百科，自由的百科全书 (wikipedia.org)</a> Bluetooth (WPAN，IEEE 802.15.1)</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ZigBee">ZigBee - 维基百科，自由的百科全书 (wikipedia.org)</a> ZigBee (LR-WPAN，IEEE 802.15.4)</p>
<h3 id="有线局域网-LAN"><a href="#有线局域网-LAN" class="headerlink" title="有线局域网 (LAN)"></a>有线局域网 (LAN)</h3><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91">以太网 - 维基百科，自由的百科全书 (wikipedia.org)</a> Ethernet LAN (IEEE 802.3)</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AE">点对点协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> PPP</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/PPPoE">PPPoE - 维基百科，自由的百科全书 (wikipedia.org)</a> PPP over Ethernet PPPoE</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/PPPoA">PPPoA - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%92%A5%E8%99%9F%E9%80%A3%E7%B7%9A">拨号连接 - 维基百科，自由的百科全书 (wikipedia.org)</a> Dial-up</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%88%B6%E8%A7%A3%E8%B0%83%E5%99%A8">调制解调器 - 维基百科，自由的百科全书 (wikipedia.org)</a> 猫 modem</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E7%94%A8%E6%88%B7%E7%BA%BF%E8%B7%AF">数字用户线路 - 维基百科，自由的百科全书 (wikipedia.org)</a> DSL</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ADSL">非对称数字用户线路- 维基百科，自由的百科全书 (wikipedia.org)</a> ADSL</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%BA%E6%8E%A5%E5%B0%88%E7%B7%9A">固接专线 - 维基百科，自由的百科全书 (wikipedia.org)</a> IPLC</p>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E4%BA%A4%E6%8F%9B%E5%99%A8">网络交换机 - 维基百科，自由的百科全书 (wikipedia.org)</a> Network switch</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A9%8B%E6%8E%A5%E5%99%A8">桥接器 - 维基百科，自由的百科全书 (wikipedia.org)</a> 网桥 Network Bridge</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E5%8D%A1">网络适配器 - 维基百科，自由的百科全书 (wikipedia.org)</a> 网卡 Network Adapter</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%86%E7%B7%9A%E5%99%A8">集线器 - 维基百科，自由的百科全书 (wikipedia.org)</a> Hub</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/8P8C">8P8C - 维基百科，自由的百科全书 (wikipedia.org)</a> RJ45</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%B2%E8%A1%8C%E7%AB%AF%E5%8F%A3">串行接口 - 维基百科，自由的百科全书 (wikipedia.org)</a> COM</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E8%A1%8C%E7%AB%AF%E5%8F%A3">并行端口 - 维基百科，自由的百科全书 (wikipedia.org)</a> LPT</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/USB">USB - 维基百科，自由的百科全书 (wikipedia.org)</a> Universal Serial Bus</p>
<h2 id="校验算法"><a href="#校验算法" class="headerlink" title="校验算法"></a>校验算法</h2><p>CRC（循环冗余校验）和汉明码都是错误检测和纠正的算法，但它们的底层原理和用途有所不同：</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%A0%E9%94%99%E7%A0%81">纠错码 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<h3 id="CRC（循环冗余校验）"><a href="#CRC（循环冗余校验）" class="headerlink" title="CRC（循环冗余校验）"></a>CRC（循环冗余校验）</h3><p>CRC 是一种通过数学方法检测数据传输错误的技术。它在底层通过<strong>多项式除法</strong>来生成校验码，将数据视为一个二进制多项式，并与一个预定的生成多项式相除。CRC的底层原理包括以下几个步骤：</p>
<ol>
<li><strong>数据多项式化</strong>：将待校验的数据视为一个二进制多项式，例如“1011”对应 ($x^3 + x + 1$)。</li>
<li><strong>生成多项式</strong>：选择一个生成多项式（如 CRC-32 使用 ($x^{32} + x^{26} + x^{23} + \ldots + x + 1$)）。</li>
<li><strong>模2除法</strong>：将数据多项式和生成多项式进行模2除法（不需要进位的二进制除法），余数即为CRC校验码。</li>
<li><strong>传输和校验</strong>：接收方用相同的生成多项式再进行除法运算，若余数为零，则说明数据没有错误。</li>
</ol>
<p>CRC 常用于检测网络传输中的错误，因为其计算效率高，适合硬件实现，并能检测较高概率的错误。</p>
<p>2^n^M  % P = FCS (Frame Check Sequence, 帧检验序列)</p>
<p>2^n^M + FCS % P = 0  如果M在传输过程中出现差错，结果将几乎不可能为0</p>
<h3 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h3><p>汉明码是一种<strong>错误纠正码</strong>，可以检测并纠正单比特错误，部分版本还能检测双比特错误。它的原理基于在数据中加入特定的校验位，使得数据在传输时出现单比特错误时可以被定位并纠正。</p>
<ol>
<li><strong>奇偶校验位的设置</strong>：汉明码会在原始数据中插入多个位置的奇偶校验位。这些位置是按二的幂次方设置的（如第1、2、4、8位等），每个校验位负责检查某些特定位置的数据位。</li>
<li><strong>校验位计算</strong>：每个校验位用来检查特定数据位的奇偶性。对于一个给定的二进制数据，可以通过指定的位操作生成一组校验位。</li>
<li><strong>错误检测和纠正</strong>：传输后，通过重新计算校验位的结果并与收到的校验位对比，可以检测并定位单个比特错误的位置，然后进行纠正。</li>
</ol>
<p>汉明码适用于内存或磁盘数据校验和恢复等场景，但较不适合复杂错误模式的网络数据传输。</p>
<h2 id="多址接入"><a href="#多址接入" class="headerlink" title="多址接入"></a>多址接入</h2><p>当多个用户接入网络时，解决如何高效地共享一个无线资源（时间/频率/空间/载波）的技术。</p>
<h3 id="CSMA-载波侦听多路访问"><a href="#CSMA-载波侦听多路访问" class="headerlink" title="CSMA 载波侦听多路访问"></a>CSMA 载波侦听多路访问</h3><p>严格意义上不算MA，因为并没有真正共享</p>
<p>CSMA（Carrier Sense Multiple Access） 是一种<strong>载波监听多址接入</strong>协议，通常用于有线网络中，允许多台设备共享同一信道资源。CSMA 的核心思想是通过监听信道来避免冲突，主要有以下两种变体：</p>
<h4 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h4><p><strong>（Collision Detection，碰撞检测）</strong>半双工</p>
<ul>
<li>应用于有线以太网（如 IEEE 802.3 标准）。在此模式下，设备在发送数据前先监听信道。如果信道空闲，数据即可发送；如果信道忙，设备会等待空闲后发送。</li>
<li>若在发送过程中发生冲突（检测到信号碰撞），设备会立即停止发送，并在随机时间后重试。</li>
<li>CSMA/CD 主要用于有线网络，如早期的以太网，由于信道冲突频繁，现已逐渐被交换式以太网替代。</li>
</ul>
<h4 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA/CA"></a>CSMA/CA</h4><p><strong>（Collision Avoidance，碰撞避免）</strong></p>
<ul>
<li>常用于无线网络（如 Wi-Fi/IEEE 802.11），因无线信道难以检测碰撞。</li>
<li>CSMA/CA 通过在发送数据前监听信道，并等待一定时间以减少冲突发生，确保信道空闲时才进行发送。</li>
<li>CSMA/CA 的碰撞避免机制更加适合无线信道的开放式环境。</li>
</ul>
<h3 id="CDMA-码分多址"><a href="#CDMA-码分多址" class="headerlink" title="CDMA 码分多址"></a>CDMA 码分多址</h3><p>多路复用技术</p>
<p>CDMA 是<strong>码分多址接入</strong>（Code Division Multiple Access）技术，主要用于蜂窝网络中。CDMA 的关键思想是通过为每个用户分配独特的伪随机码（PN 码）来区分不同用户的数据流，这样多个用户可以在同一频带内同时发送数据而不产生干扰。CDMA 的工作原理和优势如下：</p>
<ul>
<li><strong>伪随机码分配</strong>：每个用户的数据流会被一个特定的伪随机码调制，接收端利用相同的伪随机码解调，从而提取对应的数据。</li>
<li><strong>同时占用信道</strong>：不同用户使用不同的伪随机码，可以在同一频带内同时传输数据，极大提高了频谱利用率。</li>
<li><strong>抗干扰能力强</strong>：CDMA 的码分多址方式在信号干扰和路径损耗上有较强的容忍度，适合蜂窝移动通信。</li>
<li><strong>应用</strong>：CDMA 主要应用于 2G、3G 的通信网络，特别是在美国、韩国的移动通信系统中被广泛使用，如 CDMA2000。</li>
</ul>
<h4 id="WCDMA"><a href="#WCDMA" class="headerlink" title="WCDMA"></a>WCDMA</h4><p>WCDMA（Wideband Code Division Multiple Access） 是<strong>宽带码分多址接入</strong>技术，基于 CDMA 的一种改进版本，是 3GPP（第三代合作伙伴计划）推出的 3G 标准之一。它在 CDMA 基础上使用更宽的带宽，从而提高数据速率和网络容量，是全球范围内 3G 网络的主流技术之一。</p>
<ul>
<li><strong>更宽的频谱带宽</strong>：WCDMA 使用 5 MHz 的带宽（相比 CDMA 的 1.25 MHz 带宽），支持更高的数据传输速率和更多用户接入。</li>
<li><strong>更高的数据速率</strong>：在理想条件下，WCDMA 可实现高达 2 Mbps 的速率，支持语音、数据、视频等多种业务。</li>
<li><strong>频谱效率</strong>：通过更宽的频谱和 CDMA 的抗干扰特性，WCDMA 能在高用户密度环境下提供稳定的连接。</li>
<li><strong>应用</strong>：WCDMA 被广泛应用于全球的 3G 网络中，尤其是欧洲和亚洲的 GSM 网络运营商采用 WCDMA 技术升级到 3G。此技术在 4G LTE 的发展中逐步退出历史舞台。</li>
</ul>
<h4 id="TD-SCDMA"><a href="#TD-SCDMA" class="headerlink" title="TD-SCDMA"></a>TD-SCDMA</h4><p><strong>TD-SCDMA</strong>（Time Division Synchronous Code Division Multiple Access，时分同步码分多址）是中国自主研发的第三代移动通信标准，也是 3G 标准之一，由中国大唐电信和西门子公司联合开发，并被国际电信联盟（ITU）接纳为 3G 标准之一。TD-SCDMA 在中国得到了广泛的应用，但在国际市场上相对较少。</p>
<p>TD-SCDMA 的优势</p>
<ul>
<li><strong>频谱利用率高</strong>：采用 TDD 模式和同步技术，使得 TD-SCDMA 的频谱利用率相比传统的 FDD 制式更高，适合频谱资源紧张的环境。</li>
<li><strong>适合不对称数据业务</strong>：可以根据实际流量需求调整上下行资源分配，特别适合数据业务占用较高的场景。</li>
<li><strong>自主知识产权</strong>：TD-SCDMA 是中国自主研发的 3G 标准，拥有大量核心专利，减少了对外部技术的依赖。</li>
</ul>
<p>TD-SCDMA 的局限性</p>
<ul>
<li><strong>国际支持度低</strong>：TD-SCDMA 主要在中国应用，国际上接受度不高，设备的生态系统较小，终端设备支持度有限。</li>
<li><strong>覆盖和稳定性问题</strong>：与 WCDMA 和 CDMA2000 相比，TD-SCDMA 的覆盖范围和信号穿透性相对较差，容易受信号衰减影响。</li>
<li><strong>技术升级受限</strong>：由于 3G 技术已经逐渐被淘汰，TD-SCDMA 的技术升级和演进受到了较大限制。</li>
</ul>
<h3 id="FDMA-频分多址"><a href="#FDMA-频分多址" class="headerlink" title="FDMA 频分多址"></a>FDMA 频分多址</h3><p>FDMA（Frequency Division Multiple Access）</p>
<ul>
<li><strong>原理</strong>：通过将可用频谱划分成多个独立的频段，每个用户使用一个独立的频段传输数据，彼此不会干扰。</li>
<li><strong>应用</strong>：早期的模拟蜂窝网络（如 1G），一些卫星通信系统也使用 FDMA。</li>
<li><strong>特点</strong>：实现简单，适合带宽分配相对固定的场景，但频谱利用效率不高。</li>
</ul>
<h4 id="OFDMA-正交频分多址"><a href="#OFDMA-正交频分多址" class="headerlink" title="OFDMA 正交频分多址"></a>OFDMA 正交频分多址</h4><p>OFDMA（Orthogonal Frequency Division Multiple Access）</p>
<ul>
<li><strong>原理</strong>：将信道划分为多个子载波，通过正交性减少子载波之间的干扰，允许多个用户同时占用不同的子载波进行传输。</li>
<li><strong>应用</strong>：4G LTE、Wi-Fi 6（802.11ax）、WiMAX（802.16）等。</li>
<li><strong>特点</strong>：频谱利用效率高，适合宽带数据传输，并在密集环境下表现优异。</li>
</ul>
<h4 id="SC-FDMA-单载波频分多址"><a href="#SC-FDMA-单载波频分多址" class="headerlink" title="SC-FDMA 单载波频分多址"></a>SC-FDMA 单载波频分多址</h4><p>SC-FDMA（Single Carrier Frequency Division Multiple Access）单载波频分多址</p>
<ul>
<li><p><strong>原理</strong>：将上行链路的数据划分成多个子载波进行传输，使用单载波调制来减少功率峰值。</p>
</li>
<li><p><strong>应用</strong>：4G LTE 上行链路。</p>
</li>
<li><p><strong>特点</strong>：降低了上行链路中的峰均功率比（PAPR），适合移动设备的功率限制。</p>
</li>
<li></li>
</ul>
<h3 id="TDMA-时分多址"><a href="#TDMA-时分多址" class="headerlink" title="TDMA 时分多址"></a>TDMA 时分多址</h3><p>TDMA（Time Division Multiple Access）</p>
<ul>
<li>原理：将信道分为不同的时间片，每个用户轮流在特定时间片上使用信道，从而达到多用户共享信道的目的。</li>
<li><strong>应用</strong>：GSM（2G）、PHS、部分卫星通信。</li>
<li><strong>特点</strong>：在一定程度上提高了频谱利用率，但时延较高，受限于用户数量增加后的带宽分配。</li>
</ul>
<h3 id="SDMA-空分多址"><a href="#SDMA-空分多址" class="headerlink" title="SDMA 空分多址"></a>SDMA 空分多址</h3><p>SDMA（Space Division Multiple Access）</p>
<ul>
<li><strong>原理</strong>：通过空间隔离的方式区分用户信号，通常结合智能天线等技术，在同一频段和时间使用不同方向的波束来服务不同用户。</li>
<li><strong>应用</strong>：主要在蜂窝基站和无线局域网中使用，配合 MIMO（多输入多输出）技术使用，增强信道容量。</li>
<li><strong>特点</strong>：适合用户密集度高的环境，频谱利用效率较高。</li>
</ul>
<h3 id="NOMA-非正交多址"><a href="#NOMA-非正交多址" class="headerlink" title="NOMA 非正交多址"></a>NOMA 非正交多址</h3><p>NOMA（Non-Orthogonal Multiple Access）</p>
<ul>
<li><strong>原理</strong>：不同用户可以同时占用同一时间和频率资源，通过功率差异进行用户分离，接收端使用 SIC（Successive Interference Cancellation）分离信号。</li>
<li><strong>应用</strong>：5G 网络中使用较多，提升频谱效率。</li>
<li><strong>特点</strong>：频谱利用效率高，适合高用户密度场景，但对接收端的处理要求较高。</li>
</ul>
<h3 id="PDMA-模式分割多址"><a href="#PDMA-模式分割多址" class="headerlink" title="PDMA 模式分割多址"></a>PDMA 模式分割多址</h3><p>PDMA（Pattern Division Multiple Access）</p>
<ul>
<li><strong>原理</strong>：通过对信号的模式（如频域、时域、空域等）进行不同配置来分割用户信道。</li>
<li><strong>应用</strong>：5G NR（New Radio）新型多址接入技术之一。</li>
<li><strong>特点</strong>：结合空间、时间等多个维度的模式，进一步提高频谱效率。</li>
</ul>
<h3 id="MIMO"><a href="#MIMO" class="headerlink" title="MIMO"></a>MIMO</h3><p>MIMO（Multiple Input Multiple Output）多输入多输出</p>
<ul>
<li><strong>原理</strong>：通过多根天线发送和接收多个数据流，提高信道容量。</li>
<li><strong>应用</strong>：4G LTE、Wi-Fi 6、5G 等。</li>
<li><strong>特点</strong>：不属于严格的多址技术，但与 SDMA、OFDMA 等结合，能够显著提升数据传输速率和覆盖范围。</li>
</ul>
<h3 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h3><ul>
<li><strong>原理</strong>：用户在任意时间段发送数据包，碰撞后重新发送；时隙 ALOHA 则将时间分割成固定时隙，用户在时隙开始时发送数据，减少了冲突概率。</li>
<li><strong>应用</strong>：早期的卫星通信、无线传感器网络。</li>
<li><strong>特点</strong>：简单易实现，但冲突率高，频谱利用率较低，通常不用于高效的现代网络。</li>
</ul>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p><strong>IP地址：</strong>MAC地址属于物理地址，不够抽象，换了网卡还得重新建立联系。IP 地址是在计算机网络中用于标识设备的，然而它本身与具体的硬件设备无关<strong>是为了支持路由而设计的</strong>，使得数据能够在复杂的网络中找到目标设备，本质上是网络层的一种抽象，根据一定的规则和协议进行分配，帮助实现数据包在全球范围内的传输。</p>
<p><strong>ARP协议</strong>:实际通信还是要通过物理地址也就是mac的，机器1传给交换机目标IP地址，机器2收到ip广播，记录来源的mac地址，这样机器2就知道了机器1的mac，并将自己的mac返回给机器1（<strong>ARP</strong>协议,根据IP解析MAC）以后就能直接通信。缺点：MAC地址表溢出，全网泛洪，效率低下。（<u>网络层和数据链路层的边界</u>） </p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E5%88%86%E5%B1%82%E6%A6%82%E8%BF%B0.assets/image-20240921204958721.png" alt="image-20240921204958721"></p>
<p><strong>子网掩码：</strong> 上述交换机的缺点导致其只能连接少数设备，所以就应该把网络分成一个个子网，由交换机负责单个子网的通信，子网掩码就是告诉计算机 子网的ID是IP前几位，消息发给交换机，如果根据子网掩码，目的IP不是子网，就将信息传给路由器。<u>网络层</u> </p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E5%88%86%E5%B1%82%E6%A6%82%E8%BF%B0.assets/image-20240921204925827.png" alt="image-20240921204925827"> </p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E5%88%86%E5%B1%82%E6%A6%82%E8%BF%B0.assets/image-20240921205145960.png" alt="image-20240921205145960"></p>
<p><strong>路由器：</strong> 同一台路由器连接的计算机，他们的<strong>网关</strong>(子网的关口、出口)相同，都是路由器的IP地址。路由器上有一张路由表，可以配置目标网段和 next jump ，用来决定各网段消息下一步应该交给哪个路由器。OSPF自动学习自动管理路由表，BGP是为了应对庞大的网络，确定数据包的最佳路径。在<u>网络层</u></p>
<p><strong>路由器vs交换机</strong> </p>
<ol>
<li><strong>工作层次不同</strong>：</li>
</ol>
<ul>
<li><strong>路由器</strong>：工作在 <strong>网络层（OSI 模型的第 3 层）</strong>，基于 IP 地址来转发数据包。它可以在不同的网络之间进行数据转发，比如将本地局域网与互联网连接起来。路由器可以通过 IP 地址进行路由选择，确定数据包的最佳传输路径。</li>
<li><strong>交换机</strong>：工作在 <strong>数据链路层（OSI 模型的第 2 层）</strong>，基于 MAC 地址来转发数据帧。它用于在同一个局域网（LAN）内连接多个设备，并通过 MAC 地址表来进行帧的转发和处理。高端交换机（如三层交换机）也可以在网络层上进行工作，具备一定的路由功能。</li>
</ul>
<ol start="2">
<li><strong>主要用途</strong>：</li>
</ol>
<ul>
<li><strong>路由器</strong>：用于连接<strong>不同的网络</strong>，比如将你的家庭网络或局域网与互联网连接。它不仅能处理 LAN 内部的通信，还能通过 WAN 端口将内部网络连接到外部网络（如互联网）。路由器在网络之间转发数据，并为不同的网络分配和管理 IP 地址。</li>
<li><strong>交换机</strong>：用于<strong>同一网络</strong>中的设备互联，主要在局域网（LAN）内部使用。交换机可以通过多个端口连接多个设备（如电脑、服务器、打印机等），并基于 MAC 地址表快速高效地在这些设备之间转发数据。它不会管理或处理外部网络通信。</li>
</ul>
<ol start="3">
<li><strong>数据转发方式</strong>：</li>
</ol>
<ul>
<li><strong>路由器</strong>：根据<strong>IP 地址</strong>进行路由。它维护一个路由表，用来确定数据包的最佳路径，可能需要跨越多个网络。路由器使用不同的网络协议（如 OSPF、BGP）来管理和更新这些路由表。</li>
<li><strong>交换机</strong>：根据<strong>MAC 地址</strong>转发数据帧。它通过学习每个设备的 MAC 地址并将其存储在 MAC 地址表中，来确定应该将数据帧转发到哪个端口。交换机在一个局域网内部通过这种方式高效转发流量。</li>
</ul>
<ol start="4">
<li><strong>连接范围</strong>：</li>
</ol>
<ul>
<li><strong>路由器</strong>：通常连接<strong>不同的网络</strong>，比如家庭网络和互联网之间，或者连接多个子网。它的主要作用是通过不同的 IP 网段来连接和隔离不同的网络。</li>
<li><strong>交换机</strong>：主要连接<strong>同一个局域网中的设备</strong>，如多台计算机、打印机等，形成一个共享的局域网。</li>
</ul>
<ol start="5">
<li><strong>网络地址分配与管理</strong>：</li>
</ol>
<ul>
<li><strong>路由器</strong>：一般可以通过 <strong>DHCP（动态主机配置协议）</strong> 分配 IP 地址，管理局域网内设备的 IP 地址，并充当网络的网关，将局域网中的设备连接到外部网络。</li>
<li><strong>交换机</strong>：通常不具备 DHCP 等功能，它只是转发数据，不会负责分配 IP 地址。不过，高级管理型交换机可能具备一些网络管理功能。</li>
</ul>
<ol start="6">
<li><strong>NAT（网络地址转换）功能</strong>：</li>
</ol>
<ul>
<li><strong>路由器</strong>：大多数路由器提供 <strong>NAT 功能</strong>，这允许多个内网设备通过一个公共 IP 地址访问外部网络（如互联网）。NAT 会在网络地址翻译时修改 IP 数据包的源或目标 IP 地址。</li>
<li><strong>交换机</strong>：没有 NAT 功能。它仅在局域网内部转发数据帧，不处理 IP 层的转换。</li>
</ul>
<p>重点：ip首部格式 ip分片 ip选路 路由表 ICMP格式、分类(2+5)</p>
<h2 id="协议-1"><a href="#协议-1" class="headerlink" title="协议"></a>协议</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE">地址解析协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> ARP IPv4 IP地址到MAC地址 ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%82%BB%E5%B1%85%E5%8F%91%E7%8E%B0%E5%8D%8F%E8%AE%AE">邻居发现协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> NDP 基于IPv6</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE">网际协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> IP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%8E%A7%E5%88%B6%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE">互联网控制消息协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> ICMP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%BB%84%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE">互联网组管理协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> IGMP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BE%B9%E7%95%8C%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE">边界网关协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> BGP 基于 TCP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE">内部网关协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> IGP </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E5%BC%8F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%BC%98%E5%85%88">开放式最短路径优先 - 维基百科，自由的百科全书 (wikipedia.org)</a> OSPF 基于IP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E5%8D%8F%E8%AE%AE">路由信息协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> RIP 基于UDP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IPsec">IPsec - 维基百科，自由的百科全书 (wikipedia.org)</a> IPSec</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">网络地址转换 - 维基百科，自由的百科全书 (wikipedia.org)</a> NAT  ✅</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E7%B6%B2%E8%B7%AF%E6%8F%92%E5%BA%A7">网络套接字 - 维基百科，自由的百科全书 (wikipedia.org)</a> Socket  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%9C%8D%E5%8A%A1%E4%BE%9B%E5%BA%94%E5%95%86">互联网服务提供商 - 维基百科，自由的百科全书 (wikipedia.org)</a>ISP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%89%98%E7%AE%A1%E6%9C%8D%E5%8A%A1">互联网托管服务 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%89%E5%B0%8E%E7%BA%96%E7%B6%AD">光导纤维 - 维基百科，自由的百科全书 (wikipedia.org)</a> Fiber</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE">隧道协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> Tunnel  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E8%B7%AF%E7%94%B1%E5%B0%81%E8%A3%85">通用路由封装 - 维基百科，自由的百科全书 (wikipedia.org)</a> GRE</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E7%A7%81%E4%BA%BA%E7%B6%B2%E8%B7%AF">虚拟专用网 - 维基百科，自由的百科全书 (wikipedia.org)</a> VPN  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8">代理服务器 - 维基百科，自由的百科全书 (wikipedia.org)</a> Proxy  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SOCKS">SOCKS - 维基百科，自由的百科全书 (wikipedia.org)</a> SOCKS</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E5%A2%99">防火墙 - 维基百科，自由的百科全书 (wikipedia.org)</a> Firewall</p>
<h2 id="硬件-1"><a href="#硬件-1" class="headerlink" title="硬件"></a>硬件</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8">路由器 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BD%8F%E5%AE%85%E7%BD%91%E5%85%B3">住宅网关 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p>Network Address Transition</p>
<p><strong>NAT协议，公网IP</strong>：IPv4数目限制，子网共用一个IP，发送数据的时候传给路由器，路由器内部<strong>NAT</strong>映射表记录内网IP对应的内网端口以及随机分配的可用公网端口号，信息从路由器的端口里出去，之后报文里的IP和端口全部都是公网的（篡改）冒充子网计算机跟目的地通信。某个端口收到响应，路由器根据NAT表映射到内网的IP跟端口，然后把响应传给桌子往计算机</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E5%88%86%E5%B1%82%E6%A6%82%E8%BF%B0.assets/image-20240921211102189.png" alt="image-20240921211102189"></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E5%88%86%E5%B1%82%E6%A6%82%E8%BF%B0.assets/image-20240921211225744.png" alt="image-20240921211225744"></p>
<p>目的地的路由器收到报文后，再次根据NAT映射表，将报文精准发送给对应IP的对应端口，但是此时的目的地并不知道来源的真实端口和IP。因此不能直接与其通信，两台处于不同子网的设备是不能相互找到和通信的，因此有了端口转发，VPN等方式通信</p>
<ol>
<li><strong>内部到外部的通信</strong></li>
</ol>
<ul>
<li>内网设备（使用私有 IP 地址）发起访问外部网络的请求时，NAT 会将内网设备的私有 IP 地址和端口号转换为路由器的公共 IP 地址和一个动态分配的外部端口。</li>
<li>这种方式允许内网设备共享一个公共 IP 地址，通过不同的外部端口来区分多个连接。</li>
</ul>
<ol start="2">
<li><strong>外部响应的处理</strong></li>
</ol>
<ul>
<li>当外部网络（例如互联网上的服务器）响应内网设备的请求时，NAT 路由器根据维护的 NAT 表将外部响应流量（发往公共 IP 地址和端口）转换回相应的内网设备的私有 IP 地址和端口。</li>
<li>这使得内网设备能够从外部网络获取响应数据。</li>
</ul>
<ol start="3">
<li><strong>默认不处理外部对内部的主动连接</strong></li>
</ol>
<ul>
<li>NAT 的设计初衷是为了<strong>保护内网</strong>，并允许内网设备访问外部网络。所以，外部设备<strong>无法直接发起请求</strong>到 NAT 后的内网设备，除非进行额外的配置（例如端口转发）。</li>
<li>当外部网络试图访问路由器的公共 IP 地址时，NAT 路由器会没有匹配的 NAT 规则来将外部请求路由到内网设备，因为没有预先建立的映射关系。</li>
</ul>
<p><strong>如何让外部访问内部设备</strong>？</p>
<p>虽然默认情况下 NAT 不允许外部设备主动访问内网设备，但通过一些配置，可以实现外部访问内部网络：</p>
<ol>
<li><strong>端口转发（Port Forwarding）</strong>：<ul>
<li>通过手动配置 NAT 路由器，你可以将外部的特定端口请求映射到内网设备的 IP 地址和端口。这样，当外部网络访问路由器的公共 IP 地址和该端口时，路由器会将流量转发给指定的内网设备。</li>
<li>例如，将外部的 <code>203.0.113.5:8080</code> 端口映射到内网设备 <code>192.168.1.10:80</code>，从而实现外部访问内网中的 Web 服务器。</li>
</ul>
</li>
<li><strong>DMZ（Demilitarized Zone，非军事区）</strong>：<ul>
<li>DMZ 功能允许你将内网中的某台设备完全暴露给外部网络。所有未指定端口的外部请求都将被路由到 DMZ 主机。</li>
<li>这使得外部设备能够访问该主机，但同时也减少了该设备的安全性。</li>
</ul>
</li>
<li><strong>VPN（虚拟专用网络）</strong>：<ul>
<li>通过在外部设备和内网之间建立 VPN 连接，外部设备可以成为虚拟子网中的一部分，获得与内网设备直接通信的能力。VPN 通常是一种更安全的访问内部设备的方式。</li>
</ul>
</li>
<li><strong>反向连接</strong>：<ul>
<li>内网设备可以主动与外部设备建立连接（如通过反向 SSH 隧道），让外部设备通过该连接间接访问内网中的设备。</li>
</ul>
</li>
</ol>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E5%88%86%E5%B1%82%E6%A6%82%E8%BF%B0.assets/image-20240921211251306.png" alt="image-20240921211251306"></p>
<h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p><strong>分配IP</strong>  <strong>内网-使用DHCP协议</strong>首次连接路由器，设备要广播DHCP Discover 请求，表示自己需要连接网络。路由器监听DHCP请求，能够<strong>动态</strong>管理自己的IP池，通过DHCP Offer给计算机分配IP地址和默认网关（用于访问外部地址）以及子网掩码和<strong>DNS</strong> 设备收到以后Request，路由器收到以后发送ACK，确认分配并连接成功。设备使用某个IP地址的时间有限，到时间如果设备不再续用，DHCP服务器会回收。某些设备可能需要为静态的IP，这个可以通过MAC绑定也可以手动配置。</p>
<p> <strong>公网</strong> <strong>静态：</strong>根据运营商提供的静态IP，子网掩码，网关，dns手动配置。<strong>动态DHCP</strong>。 <strong>拨号</strong> 家庭公网使用PPPoE协议向运营商动态租用（PPPoE提供了身份验证功能，也就是宽带账号)</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>IP和<strong>域名 Domain Name</strong> dns可以将域名解析为ip地址，提供了用户友好的方式来访问互联网资源 属于<u>应用层</u> </p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p><strong>端口</strong>：同一台设备中，不同应用程序有不同端口，发送地址时候要加上目标端口和目标IP (UDP给应用程序标注了身份)<u>传输层</u></p>
<p><strong>TCP</strong>: UDP没有确认机制，可靠性差于是有了TCP，在不可靠信道上建立可靠连接,但是速度慢，网络游戏和视频流仍然使用UDP</p>
<p><strong>重试机制</strong>(接收方确认) <u>传输层</u></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E5%88%86%E5%B1%82%E6%A6%82%E8%BF%B0.assets/image-20240921210407572.png" alt="image-20240921210407572"></p>
<p><strong>数据分包整理机制</strong>（分包，标注序号，大段数据的小段错误不用全部重新发送，接收方回复确认要针对序号进行回复）</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E5%88%86%E5%B1%82%E6%A6%82%E8%BF%B0.assets/image-20240921210327520.png" alt="image-20240921210327520"></p>
<p><strong>连接的建立</strong>（三次握手）</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E5%88%86%E5%B1%82%E6%A6%82%E8%BF%B0.assets/image-20240921210305337.png" alt="image-20240921210305337"></p>
<p><strong>流量控制机制，动态调整一次发送分包个数</strong>（滑动窗口、拥塞控制，慢启动，快速重传，快速恢复）</p>
<p>接收方一次可能接不住全部包</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E5%88%86%E5%B1%82%E6%A6%82%E8%BF%B0.assets/image-20240921210631037.png" alt="image-20240921210631037"></p>
<p> <strong>连接的断开</strong>（四次挥手）</p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E5%88%86%E5%B1%82%E6%A6%82%E8%BF%B0.assets/image-20240921210704880.png" alt="image-20240921210704880"></p>
<p><strong>应用层传输协议</strong></p>
<p><img src="C:/Users/Lenovo/Pictures/markdownfile/%E5%88%86%E5%B1%82%E6%A6%82%E8%BF%B0.assets/image-20240921210737934.png" alt="image-20240921210737934"></p>
<h2 id="协议-2"><a href="#协议-2" class="headerlink" title="协议"></a>协议</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BC%8F">网络控制程序 - 维基百科，自由的百科全书 (wikipedia.org)</a> NCP</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">传输控制协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> TCP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5">用户数据报协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> UDP  ✅</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TCP/UDP%E7%AB%AF%E5%8F%A3%E5%88%97%E8%A1%A8">TCP/UDP端口列表 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<p>重点：udp tcp(特点，首部，校验和，连接控制三握四挥 同关 同开 半关，流量控制记住，超时重传)</p>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>理论上讲，有了以上三层协议的支持，数据已经可以从一个主机上的应用程序传输到另一台主机的应用程序了，但此时传过来的数据是字节流，不能很好的被程序识别，操作性差，因此，应用层定义了各种各样的协议来规范数据格式，常见的有<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/http/243074?fromModule=lemma_inlink">http</a>,ftp,<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/smtp/175887?fromModule=lemma_inlink">smtp</a>等，在请求<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Header/688992?fromModule=lemma_inlink">Header</a>中，分别定义了请求数据格式Accept和响应数据格式Content-Type，有了这个规范以后，当对方接收到请求以后就知道该用什么格式来解析，然后对请求进行处理，最后按照请求方要求的格式将数据返回，请求端接收到响应后，就按照规定的格式进行解读。</p>
<p>除了HTTP和HTTPS之外，还有很多其他的网络协议，用于不同的应用和目的。以下是一些常见的协议：</p>
<ol>
<li>**FTP (File Transfer Protocol)**：用于在计算机之间传输文件。前缀为 <code>ftp://</code>。</li>
<li>**SFTP (Secure File Transfer Protocol)**：在FTP的基础上增加了加密层，确保文件传输的安全性。前缀通常为 <code>sftp://</code>。</li>
<li>**FTPS (FTP Secure)**：FTP的安全版本，通过TLS/SSL加密传输。前缀为 <code>ftps://</code>。</li>
<li>**SMTP (Simple Mail Transfer Protocol)**：用于发送电子邮件。虽然它通常不在URL中直接使用，但它是邮件服务器之间传输邮件的主要协议。</li>
<li>**IMAP (Internet Message Access Protocol)**：用于从邮件服务器检索电子邮件。常见的前缀是 <code>imap://</code>。</li>
<li>**POP3 (Post Office Protocol version 3)**：也是用于从邮件服务器检索电子邮件的协议，前缀为 <code>pop3://</code>。</li>
<li><strong>Telnet</strong>：一种远程终端协议，用于通过网络连接到远程计算机。前缀为 <code>telnet://</code>。</li>
<li>**SSH (Secure Shell)**：用于安全地远程登录到计算机系统。前缀为 <code>ssh://</code>。</li>
<li><strong>HTTP（Hypertext Transfer Protocol）</strong>：超文本传输协议，是一种用于从web服务器传输网页的协议。<ol>
<li><code>http://</code> 表示该网页使用的是HTTP协议。HTTP是一个无状态的协议，意味着每次请求都是独立的，不会记录之前的交互状态。</li>
<li><code>https://</code>：在HTTP的基础上，HTTPS（HTTP Secure）增加了加密层（使用TLS/SSL协议），用于确保数据在传输过程中是安全的。<code>https://</code> 用于需要保护数据隐私和完整性的网页，如在线银行和购物网站。</li>
</ol>
</li>
</ol>
<h2 id="应用间通信架构"><a href="#应用间通信架构" class="headerlink" title="应用间通信架构"></a>应用间通信架构</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BB%88%E7%AB%AF/15634871">终端（通信技术术语）_百度百科 (baidu.com)</a> Terminal终端</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA">网络主机 - 维基百科，自由的百科全书 (wikipedia.org)</a> Host主机</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Host_(network)">Host (network) - Wikipedia</a> Host</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%AE%A2%E6%88%B7%E6%9C%BA/5937024">主从式架构 - 服务器-客户机(C/S)_百度百科 (baidu.com)</a> Client/Server  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器 - 维基百科，自由的百科全书 (wikipedia.org)</a> server  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model">Client–server model - Wikipedia</a>C/S  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/B%2FS%E7%BB%93%E6%9E%84/4868588">B/S结构_百度百科 (baidu.com)</a> Browser/Server  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Distributed_computing#Examples">Distributed computing - Wikipedia</a> 分布式计算 </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A">进程间通信 - 维基百科，自由的百科全书 (wikipedia.org)</a> IPC</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Inter-process_communication">Inter-process communication - Wikipedia</a> IPC</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8">远程过程调用(Remote Procedure Call) - 维基百科，自由的百科全书 (wikipedia.org)</a> RPC  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Remote_procedure_call">Remote procedure call - Wikipedia</a> RPC</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Java_remote_method_invocation">Java remote method invocation - Wikipedia</a> Java RMI </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Java%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8">Java远程方法调用 - 维基百科，自由的百科全书 (wikipedia.org)</a> Java RMI</p>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multitier_architecture">Multitier architecture - Wikipedia</a> 多层架构</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%AD%89%E7%B6%B2%E8%B7%AF">点对点网络 - 维基百科，自由的百科全书 (wikipedia.org)</a> P2P</p>
</li>
</ul>
<h2 id="软件设计模式"><a href="#软件设计模式" class="headerlink" title="软件设计模式"></a>软件设计模式</h2><table>
<thead>
<tr>
<th align="center">Designing Pattern</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80">设计模式</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%89%B5%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">创建型</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82">抽象工厂</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F">生成器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95">工厂方法</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E6%A8%A1%E5%BC%8F">惰性初始</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">原型</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B5%90%E6%A7%8B%E5%9E%8B%E6%A8%A1%E5%BC%8F">结构型</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">适配器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A9%8B%E6%8E%A5%E6%A8%A1%E5%BC%8F">桥接</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Composite_pattern&action=edit&redlink=1">Composite</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%AE%E9%A5%B0%E6%A8%A1%E5%BC%8F">修饰</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%96%E8%A7%80%E6%A8%A1%E5%BC%8F">外观</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F">享元</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">代理</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%82%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">行为型</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F">责任链</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F">命令</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Interpreter_pattern&action=edit&redlink=1">Interpreter</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F">迭代器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F">中介者</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Memento_pattern&action=edit&redlink=1">Memento</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">观察者</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Specification_pattern&action=edit&redlink=1">Specification</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=State_pattern&action=edit&redlink=1">State</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F">策略</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95">模板方法</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F">访问者</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BD%B5%E7%99%BC%E5%9E%8B%E6%A8%A1%E5%BC%8F">并行模式</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E4%B8%BB%E5%8A%A8%E5%AF%B9%E8%B1%A1&action=edit&redlink=1">主动对象</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E9%98%BB%E6%AD%A2%E6%A8%A1%E5%BC%8F&action=edit&redlink=1">阻止</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Binding_properties&action=edit&redlink=1">Binding properties</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E6%A8%A1%E5%BC%8F">双重检查锁定模式</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8">异步方法调用</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Guarded_suspension&action=edit&redlink=1">Guarded suspension</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Join%E6%A8%A1%E5%BC%8F&action=edit&redlink=1">Join</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%94%81_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">锁</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Messaging&action=edit&redlink=1">Messaging</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%A3%E8%A6%96%E5%99%A8_(%E7%A8%8B%E5%BA%8F%E5%90%8C%E6%AD%A5%E5%8C%96)">监视器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Proactor_pattern&action=edit&redlink=1">Proactor</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%BA%94%E5%99%A8%E6%A8%A1%E5%BC%8F">反应器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AF%BB%E5%86%99%E9%94%81">读写锁</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">调度</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%B1%A0">线程池</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8">线程局部存储</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F">架构模式</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Action%E2%80%93Domain%E2%80%93Responder&action=edit&redlink=1">ADR</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Broker_pattern&action=edit&redlink=1">Broker</a>主从式架构<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E7%BB%84%E4%BB%B6%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B">CBD</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1">DAO</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">主动记录</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E6%98%A0%E5%B0%84%E5%99%A8%E6%A8%A1%E5%BC%8F">数据映射器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88">DDD</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Data_transfer_object&action=edit&redlink=1">Data transfer object</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Front_controller&action=edit&redlink=1">Front controller</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Identity_map_pattern&action=edit&redlink=1">Identity map</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Interceptor_pattern&action=edit&redlink=1">Interceptor</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC">控制反转</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MVC">MVC</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9C%8D%E5%8B%99">微服务</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Model-view-presenter">MVP</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%96%AE%E9%AB%94%E5%BC%8F%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F">单体式应用程序</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%B1%82%E6%9E%B6%E6%9E%84">多层架构</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Naked_objects&action=edit&redlink=1">Naked objects</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%AD%89%E7%B6%B2%E8%B7%AF">P2P</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85">发布/订阅</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2">REST</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">SOA</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Specification_pattern&action=edit&redlink=1">Specification</a></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%91%E8%AE%A1%E7%AE%97">云</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97">分布式</a></td>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%96%B7%E8%B7%AF%E5%99%A8%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F">断路器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%91%BD%E4%BB%A4%E9%98%9F%E5%88%97%E5%88%86%E7%A6%BB&action=edit&redlink=1">CQRS</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%A1%A5%E5%81%BF%E4%BA%A4%E6%98%93&action=edit&redlink=1">补偿交易</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95">索引表</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E9%A2%86%E5%AF%BC%E8%80%85%E9%80%89%E4%B8%BE&action=edit&redlink=1">领导者选举</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MapReduce">MapReduce</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE&action=edit&redlink=1">物化视图</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(%E8%BD%AF%E4%BB%B6)">管道</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%BF%87%E6%BB%A4%E5%99%A8_(%E8%BD%AF%E4%BB%B6)&action=edit&redlink=1">过滤器</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85">发布/订阅</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%88%86%E7%89%87_(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84)&action=edit&redlink=1">分片</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%8A%82%E6%B5%81%E8%BF%87%E7%A8%8B_(%E8%AE%A1%E7%AE%97)&action=edit&redlink=1">节流</a></td>
</tr>
<tr>
<td align="center">其他模式</td>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Blackboard_design_pattern&action=edit&redlink=1">Blackboard</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Business_delegate_pattern&action=edit&redlink=1">Business delegate</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Composite_entity_pattern&action=edit&redlink=1">Composite entity</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F">委托</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">依赖注入</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Intercepting_filter_pattern&action=edit&redlink=1">Intercepting filter</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%83%B0%E6%80%A7%E8%BC%89%E5%85%A5">惰性加载</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Method_chaining&action=edit&redlink=1">Method chaining</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%8B%9F%E5%AF%B9%E8%B1%A1">模拟对象</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F">空对象</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F">对象池</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Servant_(design_pattern)&action=edit&redlink=1">Servant</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Twin_pattern&action=edit&redlink=1">Twin</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Type_Tunnel_pattern&action=edit&redlink=1">Type tunnel</a></td>
</tr>
<tr>
<td align="center">书籍</td>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80">设计模式：可复用面向对象软件的基础</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A2%BC%E5%A4%A7%E5%85%A8">代码大全</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E4%BC%81%E4%B8%9A%E9%9B%86%E6%88%90%E6%A8%A1%E5%BC%8F&action=edit&redlink=1">企业集成模式</a></td>
</tr>
<tr>
<td align="center">人物</td>
<td align="center"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%8B%E9%87%8C%E6%96%AF%E6%89%98%E4%BD%9B%C2%B7%E4%BA%9A%E5%8E%86%E5%B1%B1%E5%A4%A7">克里斯托佛·亚历山大</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9F%83%E9%87%8C%E5%B8%8C%C2%B7%E4%BC%BD%E7%91%AA">埃里希·伽玛</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Ralph_Johnson&action=edit&redlink=1">Ralph Johnson</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=John_Vlissides&action=edit&redlink=1">John Vlissides</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%91%9B%E4%BE%86%E8%BF%AA%C2%B7%E5%B8%83%E5%8D%80">葛来迪·布区</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%82%AF%E7%89%B9%C2%B7%E8%B2%9D%E5%85%8B">肯特·贝克</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B2%83%E5%BE%B7%C2%B7%E5%9D%8E%E5%AE%81%E5%AE%89">沃德·坎宁安</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A9%AC%E4%B8%81%C2%B7%E7%A6%8F%E5%8B%92">马丁·福勒</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Robert_Martin&action=edit&redlink=1">Robert Martin</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Jim_Coplien&action=edit&redlink=1">Jim Coplien</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Douglas_Schmidt&action=edit&redlink=1">Douglas Schmidt</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Linda_Rising">Linda Rising</a></td>
</tr>
</tbody></table>
<h2 id="协议-3"><a href="#协议-3" class="headerlink" title="协议"></a>协议</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">域名系统 - 维基百科，自由的百科全书 (wikipedia.org)</a> DNS 基于 TCP UDP  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E8%AE%BE%E7%BD%AE%E5%8D%8F%E8%AE%AE">动态主机设置协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> DHCP 基于UDP  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">超文本传输协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> HTTP  ✅</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE">超文本传输安全协议 - 维基百科，自由的百科全书 (wikipedia.org)</a>HTTPS  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WebDAV">WebDAV - 维基百科，自由的百科全书 (wikipedia.org)</a> WebDav</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WebSocket">WebSocket - 维基百科，自由的百科全书 (wikipedia.org)</a> WebSocket  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/BitTorrent_(%E5%8D%8F%E8%AE%AE)">BitTorrent (协议) - 维基百科，自由的百科全书 (wikipedia.org)</a> BitTorrent</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%95%A3%E5%BC%8F%E9%9B%9C%E6%B9%8A%E8%A1%A8">分布式散列表 - 维基百科，自由的百科全书 (wikipedia.org)</a> DHT</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EDonkey%E7%BD%91%E7%BB%9C">eDonkey网络 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91">万维网 - 维基百科，自由的百科全书 (wikipedia.org)</a> WWW  ✅</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8">网页浏览器 - 维基百科，自由的百科全书 (wikipedia.org)</a> WWW Browser  ✅</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WebRTC">WebRTC - 维基百科，自由的百科全书 (wikipedia.org)</a> WebRTC</p>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">文件传输协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> FTP  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E4%BF%A1%E6%81%AF%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE">因特网信息访问协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> IMAP ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">简单邮件传输协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> SMTP  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%83%B5%E5%B1%80%E5%8D%94%E5%AE%9A">邮局协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> POP  ✅</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MQTT">消息队列遥测传输- 维基百科，自由的百科全书 (wikipedia.org)</a> MQTT</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E6%99%82%E9%96%93%E5%8D%94%E5%AE%9A">网络时间协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> NTP</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AE%9E%E6%97%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">实时传输协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> RTP    </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/VoIP">VoIP - 维基百科，自由的百科全书 (wikipedia.org)</a> VoIP</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%A4%BA%E5%B1%82">表示层 - 维基百科，自由的百科全书 (wikipedia.org)</a> Presentation Layser</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Telnet">Telnet - 维基百科，自由的百科全书 (wikipedia.org)</a> Telnet  ✅</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Secure_Shell">Secure Shell - 维基百科，自由的百科全书 (wikipedia.org)</a> SSH  ✅</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D%E5%B1%82">会话层 - 维基百科，自由的百科全书 (wikipedia.org)</a> Session Layer </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A">传输层安全性协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> SSL/TLS  ✅</li>
</ul>
</li>
</ul>
<p>重点：</p>
<p>dns 指针查询 反向查找 逆向解析 dns 缓存 名字空间</p>
<p>ftp 控制流 数据流 工作模式pasv+port 指令+响应码 断点续传</p>
<p>http 报文格式（请求头字段和响应头字段）状态码</p>
<p>https 详细握手 摘要算法 数字签名 数字证书 </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/12/26/Netty%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/26/Netty%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">Netty 最佳实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-26 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-26T00:00:00+08:00">2024-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 15:17:07" itemprop="dateModified" datetime="2025-04-27T15:17:07+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/netty/" itemprop="url" rel="index"><span itemprop="name">netty</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/12/26/Netty%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/11/30/java.util.concurrent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/30/java.util.concurrent/" class="post-title-link" itemprop="url">java.util.concurrent</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-30 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-30T00:00:00+08:00">2024-11-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 14:37:58" itemprop="dateModified" datetime="2025-04-27T14:37:58+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/juc/" itemprop="url" rel="index"><span itemprop="name">juc</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-Concurrency-Overview"><a href="#Java-Concurrency-Overview" class="headerlink" title="Java Concurrency Overview"></a>Java Concurrency Overview</h1><h2 id="java-lang-Thread"><a href="#java-lang-Thread" class="headerlink" title="java.lang.Thread"></a><code>java.lang.Thread</code></h2><ol>
<li><p><strong>线程创建与运行</strong>:</p>
<ul>
<li><strong>继承 <code>Thread</code> 类</strong>: 继承 <code>Thread</code> 并重写 <code>run()</code> 方法<ul>
<li><code>new MyThread().start()</code> </li>
</ul>
</li>
<li><strong>实现 <code>Runnable</code> 接口</strong>: 实现 <code>Runnable</code> 实现 <code>run()</code> 方法<ul>
<li><code>new Thread(runnable).start()</code> </li>
</ul>
</li>
</ul>
</li>
<li><p><strong>线程生命周期</strong>:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/640.png" alt="Java 线程状态变迁图"></p>
<ul>
<li><strong>New</strong>: <code>new Thread()</code>, 还没有调用 <code>start()</code> </li>
<li><strong>Runnable</strong>: 线程已经调用了 <code>start()</code> / 获取锁等待 CPU 调度执行，操作系统层面属于 <strong>Ready</strong> 和 <strong>Running</strong> 状态</li>
<li><strong>Blocked</strong>:  等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</li>
<li><strong>Waiting</strong>: 操作系统的 <strong>Sleep</strong> 状态，等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。需要等待其他线程做出一些特定动作（通知或中断）</li>
<li><strong>Timed Waiting</strong>: 无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。获取锁之后调用 <code>wait(long ms)</code> <code>sleep(long ms)</code> 可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li>
<li><strong>Terminated</strong>: <code>run()</code> 执行完毕正常退出或者抛出了未处理的异常</li>
</ul>
</li>
<li><p><strong>Thread Methods</strong>:</p>
<ul>
<li><strong><code>start()</code></strong>: 线程转为 Runnable 可运行状态，相当于 <code>pthread_create()</code></li>
<li><strong><code>run()</code></strong>: 线程应该执行的方法，相当于 <code>pthread_create()</code> 传的函数指针</li>
<li><strong><code>sleep(long millis)</code></strong>: 调用者睡眠一段时间</li>
<li><strong><code>join()</code></strong>: 父线程等待子线程执行完毕再继续执行</li>
<li><strong><code>interrupt()</code></strong>: 使线程中断</li>
<li><code>currentThread()</code>: 获取当前执行的线程对象</li>
<li><code>get/setName()</code>: 获取线程名称</li>
<li><code>yield()</code>: 声明当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。只是对线程调度器的一个建议，只是建议具有相同优先级的其它线程可以运行。只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。</li>
<li><code>setDaemon()</code>: 将一个线程设置为守护线程。当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。main() 属于非守护线程。</li>
</ul>
</li>
<li><p>线程安全：</p>
<ol>
<li><p>线程互斥同步：<code>synchronized</code> <code>ReentrantLock</code> </p>
</li>
<li><p>线程非阻塞同步：<code>AtomicInteger</code> (CAS)</p>
</li>
<li><p>无同步：<code>ThreadLocal</code> 利用线程各自的栈(FutureTask，线程池)</p>
</li>
</ol>
</li>
<li><p>线程通信与协作：</p>
<ul>
<li><code>thread.join()</code> 父线程与子线程的通信</li>
<li><code>object.wait()/notify()/notifyAll()</code> 可用于 synchronized 对象锁</li>
<li><code>condition.await()/signal()/signalAll()</code> 可用于 Lock 的条件变量</li>
<li>或者使用共享内存，volatile/while轮询 的形式隐式通信</li>
</ul>
</li>
</ol>
<h2 id="java-util-concurrent"><a href="#java-util-concurrent" class="headerlink" title="java.util.concurrent"></a><code>java.util.concurrent</code></h2><p>**<mark><a href="#jvm">理论基础</a><mark>**：</p>
<ol>
<li><p><strong>JVM</strong> 对并发的支持：</p>
<ul>
<li><strong>JMM 内存模型</strong> 解决由于 Cache、指令重排序导致的可见性、有序性问题</li>
<li><code>synchronized</code> 用于解决 CPU 时分复用(操作系统调度)导致的原子性问题<ul>
<li>偏向锁、轻量级锁与重量级锁，理解锁升级和锁优化机制，如自旋锁与锁消除。</li>
</ul>
</li>
<li><code>volatile</code> 用于解决指令重排序与可见性问题</li>
<li><code>final</code> 创建不可变对象或常量(线程安全)，内存可见性</li>
<li>happens-before 原则</li>
</ul>
</li>
<li><p>常见<strong>并发设计模式</strong>：</p>
<ul>
<li><p><strong>生产者-消费者模式：</strong> 使用阻塞队列（BlockingQueue）优化实现。</p>
</li>
<li><p><strong>读写分离模式：</strong> 提高读写性能，适合数据库访问优化，读写锁、CoW 集合。</p>
</li>
<li><p><strong>线程池模式：</strong> 使用线程池 ThreadPool 统一管理线程资源。</p>
</li>
<li><p><strong>Future 模式：</strong> 提供任务执行结果的异步返回。</p>
</li>
</ul>
</li>
<li><p><strong>死锁检测与避免策略</strong></p>
</li>
</ol>
<p><strong>可选：</strong>虚拟线程、Reactor、Disruptor</p>
<p><code>java.util.concurrent</code> 给并发控制提供更多可用的操作:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/format,webp.webp" alt="img"></p>
<ol>
<li><p><strong><mark><a href="#lock">Locks</a><mark></strong>:（悲观锁）</p>
<ul>
<li><strong>ReentrantLock</strong>: 相同线程可以重复持有同一把锁</li>
<li><strong>ReentrantReadWriteLock</strong>: 有读锁和写锁两部分组成，支持多线程读取和单个线程写入</li>
<li><strong>StampedLock</strong>: 不可重入的读写锁</li>
<li><strong>LockSupport</strong>: 提供线程阻塞同步原语<ul>
<li><code>park()</code> <code>unpark(thread)</code> </li>
</ul>
</li>
<li><strong>Condition</strong>: 更细粒度的线程同步</li>
<li><strong>AbstractQueuedSynchronizer</strong>: AQS 自定义同步器</li>
</ul>
</li>
<li><p><strong><mark><a href="#tools">Tools</a><mark></strong>(Synchronizers): 和锁配合使用，线程安全工具类</p>
<ul>
<li><strong>CountDownLatch</strong>: Allows one or more threads to wait until a set of operations being performed in other threads completes. 闭锁是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待</li>
<li><strong>CyclicBarrier</strong>: A barrier that all threads must reach before any thread can proceed.（栅栏） 是因为是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 ，并且在释放等待线程后可以重用。</li>
<li><strong>Semaphore</strong>: Controls access to a resource by multiple threads. 它的本质是一个“共享锁“。信号量维护了一个信号量许可集。线程可以通过调用 acquire()来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过release()来释放它所持有的信号量许可。</li>
</ul>
</li>
<li><p><strong><mark><a href="#atomic">Atomic Variables</a><mark></strong>: CAS Lock-free(乐观锁)</p>
<ul>
<li><strong>AtomicBoolean</strong>, <strong>AtomicInteger</strong>, <strong>AtomicLong</strong></li>
<li><strong>AtomicIntegerArray</strong> These classes support lock-free thread-safe programming on single variables using low-level atomic operations.</li>
<li>CAS 构建自旋锁</li>
<li>ABA 问题与解决方案（如 AtomicStampedReference）。</li>
</ul>
</li>
<li><p><strong><mark><a href="#executor">Executor</a><mark></strong>: 线程池及异步任务相关</p>
<ul>
<li><p><strong>Callable</strong>: 和 Runnable 类似，但是有返回值</p>
</li>
<li><p><strong>Future</strong> <strong>FutureTask</strong> </p>
<ul>
<li>CompletableFuture 异步编程</li>
</ul>
</li>
<li><p><strong>ExecutorService</strong>: A flexible interface for managing and controlling thread execution.</p>
<ul>
<li><strong>ThreadPoolExecutor</strong>: 通常所说的线程池</li>
</ul>
</li>
<li><p><strong>Fork/Join</strong> 框架</p>
</li>
</ul>
</li>
<li><p><strong>Concurrent Collections/Maps</strong>: 线程安全的集合</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-concurrent-collections.png" alt="Concurrent Collections"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-thread-x-juc-overview-2.png" alt="image"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Collection-Hierarchy-concurrent-1735225309564-38.png" alt="Collection Hierarchy concurrent"></p>
<ul>
<li><strong>ConcurrentHashMap</strong> 线程安全的哈希表</li>
<li><strong>CopyOnWriteArrayList</strong> CoW List</li>
<li><strong>CopyOnWriteArraySet</strong> CoW Set</li>
<li><strong>BlockingQueue</strong> 阻塞队列</li>
</ul>
</li>
</ol>
<h1 id="JVM-支持"><a href="#JVM-支持" class="headerlink" title="JVM 支持"></a><span id="jvm">JVM 支持</span></h1><h2 id="并发问题的根源"><a href="#并发问题的根源" class="headerlink" title="并发问题的根源"></a>并发问题的根源</h2><h3 id="CPU-时分复用"><a href="#CPU-时分复用" class="headerlink" title="CPU 时分复用"></a>CPU 时分复用</h3><p>**<mark>原子性<mark>**：一个过程要么完全执行并且执行的过程不会被任何因素打断，要么就完全不执行。</p>
<p>操作系统基于受限直接执行(Limited Direct Execution)来运行任务，基于 CPU 的时钟中断对任务进行调度，通过这种 CPU 虚拟化技术让应用程序认为是自己在独占 CPU。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">i += <span class="number">1</span>;<span class="comment">// 线程1执行</span></span><br><span class="line">i += <span class="number">1</span>;<span class="comment">// 线程2执行</span></span><br><span class="line"><span class="comment">/*注意：i += 1 需要三条 CPU 指令</span></span><br><span class="line"><span class="comment">1. 将变量 i 从内存读取到 CPU寄存器；</span></span><br><span class="line"><span class="comment">2. 在CPU寄存器中执行 i + 1 操作；</span></span><br><span class="line"><span class="comment">3. 将最后的结果 i 写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。*/</span></span><br></pre></td></tr></table></figure>

<p>由于CPU分时复用（线程切换）的存在，线程 1 执行了第一条指令后，就切换到线程 2 执行，假如线程 2 执行了这三条指令后，再切换会线程 1 执行后续两条指令，将造成最后写到内存中的 <code>i</code> 是 2 而不是 3</p>
<blockquote>
<p>在 Java 中，可以借助<code>synchronized</code>、各种 <code>Lock</code> 以及各种原子类实现原子性。</p>
<p><code>synchronized</code> 和各种 <code>Lock</code> 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 <code>volatile</code>或者<code>final</code>关键字）来保证原子操作。</p>
</blockquote>
<h3 id="CPU-Cache"><a href="#CPU-Cache" class="headerlink" title="CPU Cache"></a>CPU Cache</h3><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/cpu-cache-protocol.png" alt="缓存一致性协议" style="zoom:67%;" />

<p><mark><strong>可见性</strong><mark>：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。</p>
<ol>
<li>CPU Cache 缓存的是物理内存数据，用于解决 CPU 处理速度和物理内存不匹配的问题<ul>
<li>多核缓存与主内存交互时需要遵守的原则和规范叫做 <strong>缓存一致协议</strong>，如 MESI</li>
</ul>
</li>
<li>应用程序眼中是一片完整的虚拟内存，由操作系统提供内存的虚拟化，将虚拟内存地址映射到真正的物理内存空间中。<ul>
<li>操作系统也要解决缓存(比如 TLB)与内存(比如页表)的一致性问题</li>
</ul>
</li>
</ol>
<blockquote>
<p>在 Java 中，可以借助<code>synchronized</code>、<code>volatile</code> 以及各种 <code>Lock</code> 实现可见性。</p>
<p>如果我们将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
</blockquote>
<h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>**<mark>有序性<mark>**：即程序执行的顺序按照代码的先后顺序执行。</p>
<p>为了提升执行速度/性能，计算机在执行程序代码的时候，会对指令进行重排序。 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。<strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p>
<blockquote>
<p>在 Java 中，<code>volatile</code> 关键字可以禁止指令进行重排序优化。</p>
</blockquote>
<h4 id="编译器优化重排"><a href="#编译器优化重排" class="headerlink" title="编译器优化重排"></a>编译器优化重排</h4><p>编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</p>
<p>对于编译器，禁止重排两句代码的指令，需要在它们之间插入 compiler fence。</p>
<h4 id="CPU-优化重排"><a href="#CPU-优化重排" class="headerlink" title="CPU 优化重排"></a>CPU 优化重排</h4><p>对于处理器，通过插入内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence，一种 CPU 指令）的方式来禁止特定类型的处理器重排序。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障变量的可见性。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/413889872">并发编程：乱序执行的那些事儿 - 知乎</a>  <a target="_blank" rel="noopener" href="https://www.cnblogs.com/maycap/p/15690751.html">图解CPU为何要乱序执行 - last_coding - 博客园</a>  </p>
<h5 id="指令级并行重排-乱序执行-ILP"><a href="#指令级并行重排-乱序执行-ILP" class="headerlink" title="指令级并行重排/乱序执行(ILP)"></a>指令级并行重排/乱序执行(ILP)</h5><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2586739-20211214234820966-1713761498.png" alt="img" style="zoom: 80%;" />

<p>RISC 架构的特点就是指令长度相等，执行时间恒定(通常为一个时钟周期)，因此处理器设计起来就很简单，可以通过深长的流水线达到很高的频率，IBM 的 Power6 就可以轻松地达到 4.7GHz 的起步频率。和 RISC 相反，CISC 指令的长度不固定，执行时间也不固定，因此 Intel 的 RISC/CISC 混合处理器架构就要通过 Instruction Fetch &amp; Decode 将 x86 指令翻译为 μops，从而获得 RISC 架构的长处，提升内部执行效率。x86 指令大部分简单指令可以一对一翻译为 μops，复杂的可能 1 ~ 4 条 μops。解码器是按位数取指的，在经过译码，因此每次可能产生多条 μops。</p>
<p>计算机执行符合局部性原理，这里不仅指同个指令可能重复执行，也指内存访问。而内存访问显然是比较慢的，<strong>对多条指令重新排序，把访存相关的指令放到一起，显然是可以提升效率的。</strong></p>
<h5 id="内存系统重排"><a href="#内存系统重排" class="headerlink" title="内存系统重排"></a>内存系统重排</h5><p>另外，内存系统也会有“重排序”，但又不是真正意义上的重排序。在 JMM 里表现为主内存和线程的本地内存可能不一致，进而导致程序在多线程下执行可能出现问题。</p>
<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a><mark>Java 内存模型<mark></h2><p>并发编程环境下，像 CPU 多级缓存和指令重排这类设计可能会导致程序运行出现一些问题。就比如说我们上面提到的指令重排序就可能会让多线程程序的执行出现问题。</p>
<p>JMM 说白了就是定义了一些规范来解决这些问题，例如 JMM 抽象了 happens-before 原则（后文会详细介绍到）来解决指令重排序问题。开发者可以利用 JMM 规范更方便地开发多线程程序。Java 开发者不需要了解底层原理，直接使用并发相关的一些关键字和类（比如 <code>volatile</code>、<code>synchronized</code>、各种 <code>Lock</code>）即可开发出并发安全的程序。</p>
<p>与 Java 内存区域要区分开：</p>
<ul>
<li>JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说<strong>堆主要用于存放对象实例</strong>，栈用来存放局部变量。</li>
<li>Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</li>
</ul>
<h3 id="线程与主内存"><a href="#线程与主内存" class="headerlink" title="线程与主内存"></a>线程与主内存</h3><p>在当前的 Java 内存模型下，线程可以把变量保存 <strong>本地内存</strong> （比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/jmm.png" alt="JMM(Java 内存模型)" style="zoom:60%;" />

<ul>
<li><strong>主内存</strong>：所有线程创建的实例对象都存放在主内存中，不管该实例对象是<strong>成员变量</strong>，还是<strong>局部变量</strong>，类信息、<strong>常量</strong>、<strong>静态变量</strong>都是放在主内存中。为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。</li>
<li><strong>本地内存</strong>：每个线程都有一个私有的本地内存，本地内存存储了该线程以读 / 写共享变量的副本。每个线程只能操作自己本地内存中的变量，<strong>无法直接访问其他线程的本地内存</strong>。线程间通信必须通过主内存来进行。本地内存是 JMM 抽象出来的一个概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。图中的线程1想和线程2通信，线程1必须把自己的共享变量副本同步到住内存里，然后线程2需要从主内存读取，读取的共享变量是否是线程1修改过的，是不知道的，由此引发了线程安全问题。</li>
<li>Java 内存模型定义了八种同步操作，规定了关于主内存与工作内存直接的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现细节。规定了一些同步规则来保证这些同步操作的正确执行 <a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/jmm.html#jmm-%E6%98%AF%E5%A6%82%E4%BD%95%E6%8A%BD%E8%B1%A1%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%B8%BB%E5%86%85%E5%AD%98%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">详见 JavaGuide</a> </li>
</ul>
<h3 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a>happens-before 原则</h3><p>JSR 133 引入了 happens-before 这个概念来描述<strong>两个操作之间的内存可见性</strong>。</p>
<p>happens-before 原则的诞生是为了程序员和编译器、处理器之间的平衡。程序员追求的是易于理解和编程的强内存模型，遵守既定规则编码即可。编译器和处理器追求的是较少约束的弱内存模型，让它们尽己所能地去优化性能，让性能最大化。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220731155332375-1735372822645-10-1735372984006-14.png" alt="img" style="zoom:70%;" />

<ul>
<li>为了对编译器和处理器的约束尽可能少，只要<strong>不改变程序的执行结果</strong>（单线程程序和正确执行的多线程程序），编译器和处理器怎么进行重排序优化都行。两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。</li>
<li>对于会改变程序执行结果的重排序，JMM 要求<u>编译器</u>和<u>处理器</u>必须<mark>禁止<mark>这种重排序。</li>
</ul>
<p>happens-before 原则表达的意义其实并不是一个操作发生在另外一个操作的前面，虽然这从程序员的角度上来说也并无大碍。更准确地来说，它更想表达的意义是**前一个操作的结果对于后一个操作<mark>是可见的<mark>**，无论这两个操作是否在同一个线程里。</p>
<p>具体规则：1. 按照代码先后顺序 2. 线程的 <code>start()</code> 先于其他所有动作 3. 传递性</p>
<ol start="4">
<li><p>Monitor 的解锁 happens- before 于随后对此 Monitor 的加锁 <code>synchronized</code></p>
</li>
<li><p>对 <code>volatile</code> 域的<mark>写<mark>，happens- before 于任意的后续对此 <code>volatile</code> 域的<mark>读<mark> </p>
<ul>
<li><code>volatile</code> 仅保证变量读写操作的可见性和有序性，不保证复合操作（ <code>i++</code>）的原子性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 线程1</span></span><br><span class="line">a = <span class="number">1</span>;        <span class="comment">// 普通写</span></span><br><span class="line">flag = <span class="literal">true</span>;  <span class="comment">// volatile 写</span></span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;   <span class="comment">// volatile 读</span></span><br><span class="line">    System.out.println(a); <span class="comment">// 一定会输出 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>保证 <code>flag = true</code> 的写入之前，<code>a = 1</code> 已经执行完毕，并且对线程 2 可见。</li>
<li>在 JDK 5 之前，由于没有禁止 volatile 指令重排序，<code>a = 1</code> 可能会被移动到 <code>flag = true</code> 之后执行，导致线程 2 看到 <code>flag</code> 为 true，但 <code>a</code> 的值仍然是 0。这种情况显然是违背直觉的，也无法确保程序正确性。</li>
<li>在 JDK 5 及之后，<code>a = 1</code> 一定会在 <code>flag = true</code> 之前执行， <code>flag = true</code> 一定在 <code>if(flag)</code> 之前执行，从而保证了有序性和内存可见性。</li>
</ul>
</li>
</ol>
<p><strong>JMM 与 happens-before</strong></p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220731084604667.png" alt="happens-before 与 JMM 的关系" style="zoom:67%;" />

<p>程序员在 happens-before 提供的内存可见性基础上编程，JMM 的实现：根据编译器和处理器的重排序规则，如果出现了重排序，除非没有影响执行结果，否则就禁止重排序：为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。实现细节对于程序员是透明的，只要保证程序执行时语义不改变即可。</p>
<h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a><mark><code>volatile</code> 关键字<mark></h2><ol>
<li><p><code>volatile</code> 关键字并非 Java 语言特有，在 C 语言里也有，其最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 <code>volatile</code> 修饰，这就告诉编译器这个变量是共享且不稳定的，每次使用它都到主存中进行读取。（可见性）</p>
</li>
<li><p>在 Java 中，<code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是<strong>防止 JVM 的指令重排序</strong>。 如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。（有序性）（Unsafe 类的内存屏障方法也可以实现 volatile 相同的效果）</p>
</li>
<li><p><code>volatile</code> 无法保证原子性。</p>
</li>
</ol>
<h3 id="双重校验实现单例：volatile-synchronized"><a href="#双重校验实现单例：volatile-synchronized" class="headerlink" title="双重校验实现单例：volatile + synchronized"></a>双重校验实现单例：<code>volatile</code> + <code>synchronized</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton unique;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getunique</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (unique &lt;mark&gt; <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁(对象锁)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (unique &lt;mark&gt; <span class="literal">null</span>) &#123;</span><br><span class="line">                    unique = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unique;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 <code>unique</code> 的写操作: <code>unique = new Singleton();</code> 可以分成如下三步</p>
<ol>
<li>为 <code>unique</code> 分配内存空间 malloc</li>
<li>初始化 <code>unique</code> initialize</li>
<li>将 <code>unique</code> 指向分配的引用地址(赋值)</li>
</ol>
<p>对 <code>unique</code> 的读操作: <code>if (unique == null)</code> </p>
<p><code>volatile</code> 使 <strong>写操作的第 3 步</strong> 一定对读操作可见；</p>
<p>但是指令重排仍然会导致一些问题，在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getunique</code>() 后发现 <code>unique</code> 不为空，因此返回 <code>unique</code>，但此时 <code>unique</code> 还未被初始化。<code>volatile</code> 能够禁止这种重排。</p>
<h2 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a><mark><code>synchronized</code> 关键字<mark></h2><p><code>synchronized</code> 是 Java 中的一个关键字，也叫做对象锁，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。它是 Java 内置的同步机制，在 JVM 中实现，隐式获取、自动释放。</p>
<p>在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。这是因为监视器锁（Monitor）是依赖于底层的操作系统的互斥锁 <code>mutex</code> 和条件变量 <code>cond</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>
<p>在 Java 6 之后， <code>synchronized</code> 引入了大量的优化如<strong>自旋锁</strong>、适应性自旋锁、<strong>锁消除</strong>、<strong>锁粗化</strong>、<del>-偏向锁-</del>、<strong>轻量级锁</strong>等技术来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多。因此， <code>synchronized</code> 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 <code>synchronized</code> 。</p>
<blockquote>
<p>由于偏向锁增加了 JVM 的复杂性，同时也并没有为所有应用都带来性能提升。因此，在 JDK 15 中，偏向锁被默认关闭（仍然可以使用 <code>-XX:+UseBiasedLocking</code> 启用偏向锁），在 JDK 18 中，偏向锁已经被彻底废弃（无法通过命令行打开）。</p>
</blockquote>
<ul>
<li>加在实例方法上，相当于<code>synchronized(this)</code>；</li>
<li>加在静态方法上，相当于<code>synchronized(Example.class)</code>；</li>
<li>尽量使用<code>this</code>作为对象锁，不要图方便使用字符串常量等</li>
</ul>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><h4 id="同步代码块与同步方法"><a href="#同步代码块与同步方法" class="headerlink" title="同步代码块与同步方法"></a>同步代码块与同步方法</h4><p><strong><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong></p>
<p>含有同步代码块的字节码中包含一个 <code>monitorenter</code> 指令以及两个 <code>monitorexit</code> 指令，这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放。</p>
<p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<blockquote>
<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的。每个对象中都内置了一个 <code>ObjectMonitor</code> 对象。</p>
<p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p>
</blockquote>
<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p>
<p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p>
<p><strong>同步方法</strong>：<code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取而代之的是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p>
<h4 id="可重入性-Reentrancy"><a href="#可重入性-Reentrancy" class="headerlink" title="可重入性 (Reentrancy)"></a>可重入性 (Reentrancy)</h4><p><code>synchronized</code> 的可重入性依赖于 <strong>Monitor 对象</strong> 的 <strong>锁计数器</strong> 和 <strong>锁持有线程ID</strong>。</p>
<p>同一个线程每进入一次同步方法或者对象锁相同的同步代码块，就会将锁计数器+1，退出时-1，减到0则释放锁</p>
<h4 id="ObjectMonitor"><a href="#ObjectMonitor" class="headerlink" title="ObjectMonitor"></a>ObjectMonitor</h4><p>synchronized 是基于管程实现的，核心的数据结构是 ObjectMonitor，AQS也基于MESA管程</p>
<p><strong>ObjectMonitor 的核心作用</strong></p>
<ul>
<li>保证同一时刻只有一个线程能执行同步代码块（<strong>互斥</strong>）。</li>
<li>提供线程之间的等待和唤醒机制（<strong>条件变量</strong>）。</li>
</ul>
<p>每个 Java 对象都与一个 对象监视器锁 关联，用于控制对该对象的访问权限。采用 Mesa 语义</p>
<p><strong>底层机制</strong> </p>
<ul>
<li><strong>互斥锁（Mutex）</strong>：<ul>
<li>Monitor 使用操作系统的互斥锁来实现互斥访问。</li>
<li>重量级锁通过内核态的同步原语（如 <code>futex</code> 或 <code>pthread_mutex</code>）挂起和唤醒线程。</li>
</ul>
</li>
<li><strong>条件变量（Condition Variable）</strong>：<ul>
<li>等待队列和条件变量用于管理线程状态。<code>pthread_cond</code></li>
<li>条件变量依赖于操作系统的 <code>wait()</code> 和 <code>signal()</code> 机制，控制线程等待和唤醒。</li>
</ul>
</li>
<li><strong>线程阻塞与唤醒</strong>：<ul>
<li>当线程无法获取锁时，Monitor 会将其挂起，并调用操作系统的线程调度机制。</li>
<li>被唤醒的线程通过抢占式调度重新竞争锁资源。</li>
</ul>
</li>
</ul>
<h3 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h3><p>锁主要有四种状态：无锁、偏向锁、轻量级锁、重量级锁，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3230688-20231101142724469-1226844103.png" alt="img" style="zoom: 80%;" />

<p><strong>对象头中的 Mark Word</strong></p>
<p>Java 对象在内存中由以下部分组成：</p>
<table>
<thead>
<tr>
<th>内存布局</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>对象头（Header）</td>
<td>4 字节 Mark Word、4 字节 <code>.class</code> Pointer</td>
</tr>
<tr>
<td>实例数据</td>
<td>实例变量存储的数据</td>
</tr>
<tr>
<td>对齐填充</td>
<td>用于内存对齐，按照8字节填充</td>
</tr>
</tbody></table>
<p>Mark Word 是对象头中的一部分，存储对象的状态和锁信息。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/443934-20201207134826598-1740849743.png" alt="img"></p>
<p><strong>注：锁状态会根据竞争情况自动升级，从偏向锁到轻量级锁，再到重量级锁。</strong> </p>
<h3 id="synchronized-与-volatile-的区别"><a href="#synchronized-与-volatile-的区别" class="headerlink" title="synchronized 与 volatile 的区别"></a><code>synchronized</code> 与 <code>volatile</code> 的区别</h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li>
<li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li>
<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a><code>final</code> 关键字</h2><p><a target="_blank" rel="noopener" href="https://www.nenggz.com/md/java/thread/java-thread-x-key-final.html">关键字: final详解 | Java 全栈知识体系</a> </p>
<p>用 final 修饰的类不可以被继承，用 final 修饰的方法不可以被覆写，用 final 修饰的属性一旦初始化以后不可以被修改。当然，我们不关心这些段子，这节，我们来看看 final 带来的内存可见性影响。</p>
<p>之前在说双重检查的单例模式的时候，提过了一句，如果所有的属性都使用了 final 修饰，那么 volatile 也是可以不要的，这就是 final 带来的可见性影响。</p>
<p>在对象的构造方法中设置 final 属性，<strong>同时在对象初始化完成前，不要将此对象的引用写入到其他线程可以访问到的地方</strong>（不要让引用在构造函数中逸出）。如果这个条件满足，当其他线程看到这个对象的时候，那个线程始终可以看到正确初始化后的对象的 final 属性。</p>
<p>上面说得很明白了，final 属性的写操作不会和此引用的赋值操作发生重排序，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.finalField = v; ...; sharedRef = x;</span><br></pre></td></tr></table></figure>

<h2 id="ThreadLocal-lt-T-gt"><a href="#ThreadLocal-lt-T-gt" class="headerlink" title="ThreadLocal&lt;T&gt;"></a><mark><code>ThreadLocal&lt;T&gt;</code><mark></h2><p><code>ThreadLocal</code> 主要用于以下场景：</p>
<ol>
<li><strong>线程安全的变量管理：</strong> 比如事务管理、用户会话等。</li>
<li><strong>避免同步锁：</strong> 替代传统的锁机制，提高并发性能。</li>
<li><strong>数据库连接或会话缓存：</strong> 每个线程维护自己的数据库连接实例。</li>
</ol>
<p>T 用于表示 ThreadLocal 存的值类型</p>
<p>ThreadLocal在Spring中发挥着巨大的作用，在管理request作用域中的bean、事务管理、任务调度、aop等模块都出现了它的身影。<br>Spring中绝大部分Bean都可以声明成Singleton作用域，采用ThreadLocal进行封装，因此有状态的bean就能够以 Singleton的方式在多线程中正常工作了。</p>
<h3 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h3><p><strong>JVM 提供线程隔离：</strong></p>
<ul>
<li>每个线程都有自己的栈空间和线程私有变量。</li>
<li>JVM 将 <code>Thread</code> 对象与其局部变量绑定，保证变量不被其他线程访问。</li>
</ul>
<p><strong>JDK 提供 <code>ThreadLocal</code>：</strong> </p>
<ul>
<li><code>ThreadLocal</code> 依赖于每个线程 (<code>Thread</code> 对象) 内部的 <code>ThreadLocalMap</code> 实现数据存储，每个线程都持有一个独立的 <code>ThreadLocalMap</code> 实例</li>
<li><code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</li>
<li><code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</li>
<li>每次访问 <code>ThreadLocal</code> 时，都会从当前线程的 <code>ThreadLocalMap</code> 查找对应的value。</li>
<li>不同线程之间的 <code>ThreadLocalMap</code> 互不影响，因此保证了变量的线程隔离性。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2-CFHd4NU8.png" alt="img"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/ThreadLocal-01.png" alt="ThreadLocal各引用间的关系"></p>
<p>哈希冲突解决：开放地址法（线性探测）</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>注意泛型、remove避免内存泄露 public static final</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义 ThreadLocal 变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// tl = ThreadLocal.withInitial(() -&gt; 0) 可以设置初始值</span></span><br><span class="line">tl.set(<span class="number">100</span>); <span class="comment">// 当前线程设置值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get(); <span class="comment">// 获取当前线程的值</span></span><br><span class="line">tl.remove(); <span class="comment">// 避免内存泄漏</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241230193230746.png" alt="image-20241230193230746"></p>
<p>如图 在 web 请求到达时，进入controller之前的interceptor可以</p>
<h3 id="内存泄漏：弱引用与强引用"><a href="#内存泄漏：弱引用与强引用" class="headerlink" title="内存泄漏：弱引用与强引用"></a>内存泄漏：弱引用与强引用</h3><p>key 是 ThreadLocal 对象，弱引用；value 是 Object 对象，强引用。</p>
<p>那么在<code>ThreadLocal.get()</code>的时候，发生<code>GC</code>之后，<code>key</code>是否是<code>null</code>？</p>
<p>为了搞清楚这个问题，我们需要搞清楚<code>Java</code>的<strong>四种引用类型</strong>：</p>
<ul>
<li><strong>强引用</strong>：我们常常 new 出来的对象就是强引用类型，只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足的时候</li>
<li><strong>软引用</strong>：使用 SoftReference 修饰的对象被称为软引用，软引用指向的对象在内存要溢出的时候被回收</li>
<li><strong>弱引用</strong>：使用 WeakReference 修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收</li>
<li><strong>虚引用</strong>：虚引用是最弱的引用，在 Java 中使用 PhantomReference 进行定义。虚引用中唯一的作用就是用队列接收对象即将死亡的通知</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/5-GYIVKEun.png" alt="img"></p>
<p>当作为 key 的 <code>ThreadLocal</code> 实例失去强引用后，只要发生 GC 就会被回收，但是其对应的 value <code>Object</code> 仍然存在于 <code>ThreadLocalMap</code> 中，因为 <code>Entry</code> 对象强引用了它。如果线程持续存活（例如线程池中的线程），<code>ThreadLocalMap</code> 也会一直存在，导致 key 为 <code>null</code> 的 entry 无法被垃圾回收，机会造成内存泄漏。</p>
<ol>
<li>在使用完 <code>ThreadLocal</code> 后，<mark>务必调用 <code>remove()</code> 方法<mark>。 这是最安全和最推荐的做法。 <code>remove()</code> 方法会从 <code>ThreadLocalMap</code> 中显式地移除对应的 entry，彻底解决内存泄漏的风险。 即使将 <code>ThreadLocal</code> 定义为 <code>static final</code>，也强烈建议在每次使用后调用 <code>remove()</code>。</li>
<li>在线程池等线程复用的场景下，<mark>使用 <code>try-finally</code> 块<mark>可以确保即使发生异常，<code>remove()</code> 方法也一定会被执行。</li>
</ol>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a><span id="lock">锁</span></h1><p><code>java.util.concurrent.locks</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241230173434255-1735551283426-42.png" alt="image-20241230173434255"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241230173500715.png" alt="image-20241230173500715"></p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><mark><code>ReentrantLock</code><mark></h2><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个<mark>可重入<mark>且<mark>独占式<mark>的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了<strong>非阻塞</strong>、<strong>超时</strong>、<strong>中断</strong>、<strong>公平锁和非公平锁</strong>等高级功能。</p>
<p>继承关系：实现了 Lock 接口，有一个 Sync 内部类，Sync 继承了 AQS，加锁和释放锁基本在 Sync 中实现，Sync 有公平锁 FairSync 和非公平锁 NonfairSync 两个子类。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aqs.png" alt="Classes"></p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本如上，finally 逻辑一定要释放锁，防止死锁</p>
<h3 id="与-synchronized-比较"><a href="#与-synchronized-比较" class="headerlink" title="与 synchronized 比较"></a>与 <code>synchronized</code> 比较</h3><table>
<thead>
<tr>
<th></th>
<th><code>synchronized</code></th>
<th><code>ReentrantLock</code></th>
</tr>
</thead>
<tbody><tr>
<td>实现</td>
<td><strong>JVM</strong> 底层关键字</td>
<td><strong>JDK</strong> API</td>
</tr>
<tr>
<td>公平锁</td>
<td>不支持</td>
<td>可显式指定 <code>new Reentrantlock(true)</code></td>
</tr>
<tr>
<td>多条件/选择通信</td>
<td>只支持一个条件变量</td>
<td>Condition 支持多个条件变量</td>
</tr>
<tr>
<td>线程通信API</td>
<td><code>wait()</code> <code>notify()</code> <code>notifyAll()</code></td>
<td><code>await()</code> <code>signal()</code> <code>signalAll()</code> <code>lock.newCondition()</code></td>
</tr>
<tr>
<td>可重入</td>
<td>支持</td>
<td>支持 <code>getHoldCount()</code> 查看重入次数</td>
</tr>
<tr>
<td>超时等待</td>
<td>不支持</td>
<td>支持 <code>tryLock(timeout)</code> 超时返回机制</td>
</tr>
<tr>
<td>释放</td>
<td>进出代码块自动完成</td>
<td>手动 (<code>lock()</code> <code>unlock()</code>)</td>
</tr>
<tr>
<td>中断</td>
<td>不可响应中断</td>
<td><code>lock.lockInterruptibly()</code></td>
</tr>
<tr>
<td>阻塞获取</td>
<td>只能阻塞获取</td>
<td>支持非阻塞获取<code>tryLock()</code> 失败直接返回</td>
</tr>
</tbody></table>
<p>超时等待：防止死锁， 防止线程无限期阻塞</p>
<p>等待可中断：获取锁的线程在阻塞等待的过程中，如果其他线程中断当前线程 <code>interrupt()</code> ，就会抛出 <code>InterruptedException</code> 异常，可以捕获该异常，做一些处理操作</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>包含独占写锁和共享读锁，在读多写少的情况下性能很好，分为可重入<code>ReentrantReadWriteLock</code> 和不可重入 <code>StampedLock</code> <a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#reentrantreadwritelock-%E6%98%AF%E4%BB%80%E4%B9%88">详见 JavaGuide</a> </p>
<p>ReentrantReadWriteLock </p>
<p>1、读写锁接口ReadWriteLock接口的一个具体实现，实现了读写锁的分离， </p>
<p>2、支持公平和非公平，底层也是基于AQS实现 </p>
<p>3、允许从写锁降级为读锁 流程：先获取写锁，然后获取读锁，最后释放写锁；但不能从读锁升级到写锁 </p>
<p>4、重入：读锁后还可以获取读锁；获取了写锁之后既可以再次获取写锁又可以获取读锁 核心：读锁是共享的，写锁是独占的。 读和读之间不会互斥，读和写、写和读、写和写之间才会互斥， 主要是提升了读写的性能</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a><span id="tools"><mark>AQS<mark></span></h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解 - waterystone - 博客园</a> </p>
<p><strong>AQS（AbstractQueuedSynchronizer）</strong> 是 <strong>Java 并发包</strong>（<code>java.util.concurrent</code>）提供的一个<strong>底层同步框架</strong>，是一个抽象类，用来实现锁和同步器。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，</p>
<ul>
<li>独占：<code>tryAcquire-tryRelease</code>(ReentrantLock)</li>
<li>共享：<code>tryAcquireShared-tryReleaseShared</code>(Semaphore, CountDownLatch)</li>
<li>AQS也支持同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code> </li>
</ul>
<h3 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ol>
<li><p><strong>共享变量 (state)：</strong> </p>
<ul>
<li>AQS 内部有一个整数 <code>volatile</code> 变量 <code>state</code>，用来表示当前锁的状态，比如 0 表示空闲，1 表示已占用。</li>
<li>多个线程可以通过 <strong>CAS 操作</strong>来修改这个共享变量，从而实现并发控制。</li>
</ul>
</li>
<li><p><strong>等待队列 (CLH FIFO队列)：</strong> </p>
<p><code>Node</code>: 含有<code>thread</code>对象</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/40cb932a64694262993907ebda6a0bfetplv-k3u1fbpfcp-zoom-1.png" alt="img"></p>
<ul>
<li>如果线程无法获取共享资源，就进入一个等待队列，这个队列是一个<strong>双向链表</strong>结构。</li>
</ul>
<p><code>waitStatus</code>: </p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/785ca26c055b5be2761374af6a0c7bc5.webp?x-image-process=image/format,png#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><strong>CANCELLED</strong>(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li>
<li><strong>SIGNAL</strong>(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</li>
<li><strong>CONDITION</strong>(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将<strong>从等待队列转移到同步队列中</strong>，等待获取同步锁。</li>
<li><strong>PROPAGATE</strong>(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li>
<li><strong>0</strong>：新结点入队时的默认状态。</li>
</ul>
<p>注意，<strong>负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用&gt;0、&lt;0来判断结点的状态是否正常</strong>。</p>
</li>
<li><p><strong>模板方法：</strong>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可<strong>，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</strong> </p>
<ul>
<li><p><code>isHeldExclusively()</code>：是否正在独占资源。只有用到condition才需要去实现它。</p>
</li>
<li><p><code>tryAcquire(int i)</code>：独占方式。尝试获取资源，成功则返回true，失败则返回false。</p>
</li>
<li><p><code>tryRelease(int i</code>)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</p>
</li>
<li><p><code>tryAcquireShared(int i)</code>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</p>
</li>
<li><p><code>tryReleaseShared(int i)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>
</li>
<li><p>参数 <code>i</code> 表示共享资源的个数，<code>tryAcquire</code> 就是在更改 <code>state</code></p>
<ul>
<li>以<code>ReentrantLock</code>为例，<code>tryLock()</code>就是在非阻塞获取，<code>lock()</code>就是真正的获取过程，先<code>initialTryLock()</code> 一下，逻辑和<code>tryLock()</code>类似这里默认state就是1，因为是Lock自己内部的。如果失败了才真正<code>acquire(1)</code>，这里的1就代表资源的个数（锁的个数）只有1，这里才开始重写AQS的内容，<code>tryAcquire(1)</code> 开始…</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!initialTryLock())</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解 - waterystone - 博客园</a> </p>
<ol>
<li>尝试获取<ul>
<li>如果共享资源空闲，线程可以直接占用资源。</li>
<li>如果锁已被占用，线程会创建一个节点加入队列尾部。</li>
</ul>
</li>
<li>排队等待<ul>
<li>前一个线程释放锁时，会通知队列中的下一个线程。</li>
<li>通知机制依赖 <code>LockSupport.park()</code> 和 <code>LockSupport.unpark()</code> 实现线程通信。</li>
</ul>
</li>
<li>被唤醒的线程继续尝试获取锁，如果成功，则从队列中移除原队头，老二称为新的队头。</li>
</ol>
<p><strong>CLR 队列节点大致结构</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 等待状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 通知下一个线程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 已取消 已放弃</span></span><br><span class="line">    <span class="type">int</span> waitStatus; </span><br><span class="line"></span><br><span class="line">    Node prev; <span class="comment">// 前驱节点</span></span><br><span class="line">    Node next; <span class="comment">// 后继节点</span></span><br><span class="line">    Thread thread; <span class="comment">// 当前线程引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/721070-20170504110246211-10684485-1735391533653-31-1735395150328-37.png" alt="img"></p>
<h5 id="acquire-int"><a href="#acquire-int" class="headerlink" title="acquire(int)"></a><code>acquire(int)</code></h5><p>获取操作：<code>acquire(int arg)</code>：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/721070-20151102145743461-623794326-1735395145015-35-1735395190296-39.png" alt="img"></p>
<p>如图所示，队头是当前共享资源占用者，AQS保证严格按照入队顺序唤醒，老二被<code>unpark</code>之后尝试获取，如果成功自己就是队头，之前的队头将来会自动回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 acquire() 方法中，当 if 语句的条件返回 true 后，就会调用 selfInterrupt() ，该方法会中断当前线程，为什么需要中断当前线程呢？当 if 判断为 true 时，需要 tryAcquire() 返回 false ，并且 acquireQueued() 返回 true 。其中 acquireQueued() 方法返回的是线程被唤醒之后的 中断状态 ，通过执行 Thread.interrupted() 来返回。该方法在返回中断状态的同时，会清除线程的中断状态。因此如果 if 判断为 true ，表明线程的中断状态为 true ，但是调用 Thread.interrupted() 之后，线程的中断状态被清除为 false ，因此需要重新执行 selfInterrupt() 来重新设置线程的中断状态。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aqs-acquire-exclusive-1735447666698-3-1735447685230-5-1735447698634-7.png" alt="Exclusive Acquire"></p>
<p><strong>尝试获取</strong>：<code>tryAcquire(int arg)</code> : 应该由具体的实现类去实现(对status的CAS操作)</p>
<ul>
<li><p>以ReentrantLock为例：</p>
<ul>
<li><p>非公平锁(NotFairSync)：<code>tryAcquire()</code> 无需考虑队列中是否有前驱节点，前面有人也可以试着抢一下。失败后再排队。</p>
</li>
<li><p>公平锁(FairSync)：<code>tryAcquire()</code> 只有 !hasQueuedPredecessors() 才能尝试acquire</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static final class NonfairSync extends Sync:</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getState() == <span class="number">0</span> &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// static final class FairSync extends Sync:</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (getState() == <span class="number">0</span> &amp;&amp; !hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">       compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">       setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>**线程入队: **<code>addWaiter(Node)</code> <code>enq(Node)</code></p>
<p>应该用CAS更新，有快速和自旋两个阶段，快速插入是队列已经初始化了，尝试一次CAS更改</p>
<p>如果快速插入的CAS不成功，就进行自旋CAS插入<code>enq()</code> 同时，如果未初始化会先初始化队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、将当前线程封装为 Node 节点。</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">// 2、如果 pred ！= null，则证明 tail 节点已经被初始化，直接将 Node 节点加入队列即可。 CAS</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 2.1、通过 CAS 控制并发安全。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、初始化队列，并将新创建的 Node 节点加入队列。</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 1、通过 CAS 操作保证队列初始化的并发安全</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2、与 addWaiter() 方法中节点入队的操作相同</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程睡眠</strong>：<code>acquireQueued(Node, int arg)</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS：令队列中的节点尝试获取锁，并且对线程进行阻塞。</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//标记是否成功拿到资源</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 1、如果已经是老二，就可以再去尝试获取一下。</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2、判断线程是否可以阻塞，如果可以，则阻塞当前线程。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 3、如果获取锁失败，就会取消获取锁，将节点状态更新为 CANCELLED。</span></span><br><span class="line">        <span class="keyword">if</span> (failed)<span class="comment">// 等待过程中没有成功获取资源（超时/中断）</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS：判断当前线程节点是否可以阻塞。</span></span><br><span class="line"><span class="comment">// 前面可能有已经放弃的节点，应该挪到最后一个正常等待的节点后边；</span></span><br><span class="line"><span class="comment">// 并且只有前面节点状态为 `SIGNAL` 才能睡，不是的话就应该改成`SIGNAL`再睡</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="comment">// 1、前继节点状态正常，直接返回 true 即可。</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 2、ws &gt; 0 表示前继节点的状态异常，即为 CANCELLED 状态，需要跳过异常状态的节点。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3、如果前继节点的状态不是 SIGNAL，也不是 CANCELLED，就将状态设置为 SIGNAL。</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS 如果确实可以睡，就睡在`parkAndCheckInterrupt()`里等待唤醒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1、线程阻塞到这里 等待unpark()或interrupt()唤醒自己；</span></span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 2、线程被唤醒之后，返回线程中断状态</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="release-int"><a href="#release-int" class="headerlink" title="release(int)"></a><code>release(int)</code></h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aqs-release.png" alt="Release"></p>
<p>线程唤醒：<code>unparkSuccessor()</code> 唤醒队头之后第一个未放弃正常等待的节点，从后往前找。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;<span class="comment">//找到头结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);<span class="comment">//唤醒等待队列里的下一个线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//底层基于 LockSupport.unpark(thread);</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//这里，node一般为当前线程所在的结点。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)<span class="comment">//置零当前线程所在的结点状态，允许失败。</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;<span class="comment">//找到下一个需要唤醒的结点s</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">//如果为空或已取消</span></span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev) </span><br><span class="line">     <span class="comment">// 从后向前遍历,找到头节点后面第一个正常等待的节点</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)<span class="comment">//从这里可以看出，&lt;=0的结点，都是还有效的结点。</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);<span class="comment">//唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aqs-addWaiter.png" alt="img"></p>
<p>为什么prev链是强一致的？因为addWaiter()里每次compareAndSetTail(pred, node)之前都有node.prev = pred，enq()会反复尝试CAStail，直到成功。一旦CAStail成功，该node.prev就成功挂在之前的tail结点上而且是唯一的，这时其他新结点的prev只能尝试往新tail结点上挂。这里的组合用法非常巧妙，能保证CAS之前的prev链强一致，但不能保证CAS后的next链强一致。</p>
<p><code>acquireShared(int arg)</code>  </p>
<p>前面逻辑基本一致，先try 如果失败了，就准备入队，</p>
<p><code>setHeadAndPropagate(Node node, int propagate)</code> </p>
<p>如果自己成了老二并且尝试获取成功，如果资源还有剩余，就会唤醒下一个正常等待的节点：</p>
<p>这些都是失败了就会寻找安全点，进入睡眠</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    setHead(node);<span class="comment">//head指向自己</span></span><br><span class="line">     <span class="comment">//如果还有剩余量，继续唤醒下一个邻居线程</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>releaseShared(int arg)</code> </p>
<p>独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                unparkSuccessor(h);<span class="comment">//唤醒后继</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)<span class="comment">// head发生变化</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="AQS-的常见应用"><a href="#AQS-的常见应用" class="headerlink" title="AQS 的常见应用"></a>AQS 的常见应用</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-thread-x-juc-overview-lock.png" alt="image"></p>
<p>AQS 本身不是直接用来加锁的，而是作为<strong>其他锁工具的基础</strong>。</p>
<ul>
<li><strong>ReentrantLock（可重入锁）：</strong> 用于线程互斥。<ul>
<li> <code>state</code> 表示重入次数，每lock一次就+1，unlock一次就-1，因此获取和释放要一一对应，否则就会死锁，tryAcquire(1)</li>
</ul>
</li>
<li><strong>Semaphore（信号量）：</strong> 控制并发访问的线程数。tryAcquire(n)</li>
<li><strong>CountDownLatch（计数器）：</strong> 等待多个线程完成任务。tryAcquire(n)<ul>
<li> <code>state = N</code>，N 个子线程执行任务，每个子线程执行完后<code>countDown()</code> 一次，也就是 CAS 减 1，<code>state</code> 归零之后，会<code>unpark(callerThread)</code> 主调用线程，主线程从<code>await</code> 返回，继续后面的动作。</li>
</ul>
</li>
<li><strong>ReadWriteLock（读写锁）：</strong> 支持多个读线程和一个写线程。</li>
</ul>
<h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><code>Semaphore</code></h4><p>Semaphore 是 synchronized 的加强版，作用是控制线程的并发数量（允许 自定义多少线程同时访问）。就这一点而言，单纯的synchronized 关键字是实现不了的。</p>
<p>Semaphore有一个构造函数， 可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待， 等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中 传入的int型整数n=1，相当于变成了一个synchronized了。</p>
<p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，而<code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。</p>
<p>Semaphore 的使用简单，我们这里假设有 N(N&gt;5) 个线程来获取 <code>Semaphore</code> 中的共享资源，下面的代码表示同一时刻 N 个线程中只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。</p>
<p>当初始的资源个数为 1 的时候，<code>Semaphore</code> 退化为独占锁。</p>
<p><code>Semaphore</code> 有两种模式：公平和非公平 </p>
<p><code>Semaphore</code> 是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为 <code>permits</code>，你可以将 <code>permits</code> 的值理解为许可证的数量，只有拿到许可证的线程才能执行。</p>
<p>调用<code>semaphore.acquire()</code> ，线程尝试获取许可证，如果 <code>state &gt;= 0</code> 的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state-1</code>。如果 <code>state&lt;0</code> 的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。</p>
<p>调用<code>semaphore.release();</code> ，线程尝试释放许可证，并使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state+1</code>。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 <code>state</code> 的值 <code>state=state-1</code> ，如果 <code>state&gt;=0</code> 则获取令牌成功，否则重新进入阻塞队列，挂起线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始共享资源数量</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取1个许可</span></span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">// 释放1个许可</span></span><br><span class="line">semaphore.release();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreExample</span> &#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">300</span>);</span><br><span class="line">    <span class="comment">// 初始许可证数量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">      threadPool.execute(() -&gt; &#123;<span class="comment">// Lambda 表达式的运用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          semaphore.acquire();<span class="comment">// 获取一个许可，所以可运行线程数量为20/1=20</span></span><br><span class="line">          test(threadnum);</span><br><span class="line">          semaphore.release();<span class="comment">// 释放一个许可</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><code>CountDownLatch</code></h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>releaseShared()</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。</p>
<p>当主线程调用 <code>await()</code> 方法的时候，实际是<code>tryAcquireShared(1)和acquire(1)</code>: 如果 <strong>state 不为 0</strong>，表示计数器未归零，线程会被<strong>封装成 Node 并加入 AQS 的等待队列</strong>中，并进入 <strong>阻塞状态</strong>。<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。直到 <code>count</code> 个线程调用了<code>countDown()</code>使 state 值被减为 0，或者调用<code>await()</code>的线程被中断，该线程才会从阻塞中被唤醒，<code>await()</code> 方法之后的语句得到执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted() ||</span><br><span class="line">        (tryAcquireShared(arg) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         acquire(<span class="literal">null</span>, arg, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">0L</span>) &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 减-1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        signalNext(head);<span class="comment">// SIGNAL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">signalNext</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; (s = h.next) != <span class="literal">null</span> &amp;&amp; s.status != <span class="number">0</span>) &#123;</span><br><span class="line">        s.getAndUnsetStatus(WAITING);</span><br><span class="line">        LockSupport.unpark(s.waiter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample1</span> &#123;</span><br><span class="line">    <span class="comment">// 处理文件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//处理文件的业务操作</span></span><br><span class="line">                    <span class="comment">//......</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//表示一个文件已经被完成</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="用法及注意事项"><a href="#用法及注意事项" class="headerlink" title="用法及注意事项"></a>用法及注意事项</h5><ol>
<li>某一线程在开始运行前等待 n 个线程执行完毕 : 将 <code>CountDownLatch</code> 的计数器初始化为 n （<code>new CountDownLatch(n)</code>），每当一个任务线程执行完毕，就将计数器减 1 （<code>countdownlatch.countDown()</code>），当计数器的值变为 0 时，在 <code>CountDownLatch 上 await()</code> 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</li>
<li>实现多个线程开始执行任务的最大并行性：注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 <code>CountDownLatch</code> 对象，将其计数器初始化为 1 （<code>new CountDownLatch(1)</code>），多个线程在开始执行任务前首先 <code>coundownlatch.await()</code>，当主线程调用 <code>countDown()</code> 时，计数器变为 0，<strong>多个线程同时被唤醒</strong>。</li>
</ol>
<p>与 <code>CountDownLatch</code> 的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用 <code>CountDownLatch.await()</code> 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p>
<p>其他 N 个线程必须引用闭锁对象，因为他们需要通知 <code>CountDownLatch</code> 对象，他们已经完成了各自的任务。这种通知机制是通过 <code>CountDownLatch.countDown()</code>方法来完成的；每调用一次这个方法，在构造函数中初始化的 count 值就减 1。所以当 N 个线程都调 用了这个方法，count 的值等于 0，然后主线程就能通过 <code>await()</code>方法，恢复执行自己的任务。</p>
<p>再插一嘴：<code>CountDownLatch</code> 的 <code>await()</code> 方法使用不当很容易产生死锁，比如我们上面代码中的 for 循环改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount-<span class="number">1</span>; i++) &#123;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就导致 <code>count</code> 的值没办法等于 0，然后就会导致一直等待。</p>
<h5 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a><code>CyclicBarrier</code></h5><p>一个加强版的CountDownLatch。</p>
<p>作用就是会让所有线程都等待完成后才会继续下一步行 动。 CyclicBarrier初始化时规定一个数目，然后计算调用了CyclicBarrier.await()进入等待的线程数。 当线程数达到了这个数目时，所有进入等待状态的线程被唤醒并继续</p>
<p>CyclicBarrier初始时还可带一个Runnable的参数， 此Runnable任务在CyclicBarrier的数目达到 后，所有其它线程被唤醒前被执行。</p>
<h3 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a><code>ConditionObject</code></h3><p>Usage</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!conditionMet()) &#123;</span><br><span class="line">        condition.await(); <span class="comment">// 等待条件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行条件满足后的逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其他线程中：</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    updateCondition();</span><br><span class="line">    condition.signal(); <span class="comment">// 通知等待的线程</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Condition-的等待队列"><a href="#Condition-的等待队列" class="headerlink" title="Condition 的等待队列"></a>Condition 的等待队列</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Monitor.png" alt="Monitor"></p>
<p><code>ConditionObject</code> 维护一个<strong>等待队列</strong>（<mark>单向链表<mark>），其中每个节点是一个AQS CLH 队列的 <code>Node</code> ，节点的 <code>waitStatus</code> 被设置为 <code>COND</code>，表示属于Condition的等待队列节点。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/979960-20180430090729190-1934051559.png" alt="img"></p>
<p><code>ConditionNode</code> 关键字段：</p>
<ul>
<li><code>waitStatus</code>：<code>COND</code> </li>
<li><code>nextWaiter</code>：指向下一个等待节点。</li>
</ul>
<p><code>ConditionObject</code> 拥有等待队列的 <strong>头尾指针</strong>：</p>
<ul>
<li><code>firstWaiter</code>：指向队列头部（第一个等待线程）。</li>
<li><code>lastWaiter</code>：指向队列尾部（最后一个等待线程）。</li>
</ul>
<p>挂起自己的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isReleasable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> status &lt;= <span class="number">1</span> || Thread.currentThread().isInterrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">block</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!isReleasable()) LockSupport.park();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>线程调用 <code>await()</code> 进入等待队列，同时释放锁(AQS的独占锁实现，比如ReentrantLock)。<ol>
<li>调用 <code>addConditionWaiter()</code> 将线程加入条件队列。</li>
<li>调用 <code>fullyRelease()</code> 释放当前线程持有的锁。</li>
<li>判断线程是否进入同步队列，如果没有，则阻塞线程。</li>
<li>被唤醒后，通过 <code>reacquireQueued()</code> 重新获取锁。</li>
</ol>
</li>
<li>线程被阻塞，直到被其他线程唤醒（<code>signal()</code> 或 <code>signalAll()</code>）。<ol>
<li>检查调用线程是否持有锁。</li>
<li>调用 <code>doSignal()</code> 将条件队列中的节点移动到同步队列。</li>
<li>调用 <code>LockSupport.unpark()</code> 唤醒节点线程。</li>
</ol>
</li>
<li>被唤醒后，该线程进入 <strong>AQS 的 CLH 队列</strong> 排队尝试重新获取锁。</li>
</ol>
<h4 id="await"><a href="#await" class="headerlink" title="await()"></a><code>await()</code></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/979960-20180430095049880-331436771.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把当前线程的节点加入到等待队列中　</span></span><br><span class="line"><span class="comment">//调用await()的线程已经获取锁，所以在加入等待队列后，需要释放锁，并且唤醒后继节点线程</span></span><br><span class="line"><span class="comment">//挂起当前线程，当别的线程调用了signal（），并且是当前线程被唤醒的时候才从返回</span></span><br><span class="line"><span class="comment">//当被唤醒后，该线程会尝试去获取锁，只有获取到了才会从await()返回，否则挂起自己</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 创建节点并加入等待队列</span></span><br><span class="line">    <span class="type">ConditionNode</span> <span class="variable">node</span> <span class="operator">=</span> newConditionNode();</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> enableWait(node);<span class="comment">// 加入等待队列，唤醒同步队列的后继节点</span></span><br><span class="line">    LockSupport.setCurrentBlocker(<span class="built_in">this</span>); <span class="comment">// for back-compatibility</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>, cancelled = <span class="literal">false</span>, rejected = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/********************* 无法进入同步队列，循环 ******************************/</span></span><br><span class="line">    <span class="keyword">while</span> (!canReacquire(node)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interrupted |= Thread.interrupted()) &#123; <span class="comment">// 被中断 取消</span></span><br><span class="line">            <span class="keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((node.status &amp; COND) != <span class="number">0</span>) &#123;<span class="comment">// 未被中断 状态是COND 挂起自己</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rejected)</span><br><span class="line">                    node.block();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ForkJoinPool.managedBlock(node);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">                rejected = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">//其他情况，自选等待</span></span><br><span class="line">            Thread.onSpinWait();    <span class="comment">// awoke while enqueuing</span></span><br><span class="line">    &#125;</span><br><span class="line">    LockSupport.setCurrentBlocker(<span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/******** 从上方的循环中跳出，清除 status，准备ReAcquire，进入同步队列  ********/</span></span><br><span class="line">    node.clearStatus();</span><br><span class="line">    acquire(node, savedState, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cancelled) &#123;</span><br><span class="line">            unlinkCancelledWaiters(node);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="enableWait-node"><a href="#enableWait-node" class="headerlink" title="enableWait(node)"></a><code>enableWait(node)</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">enableWait</span><span class="params">(ConditionNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// 先检查是否拥有独占锁 </span></span><br><span class="line">    <span class="keyword">if</span> (isHeldExclusively()) &#123;</span><br><span class="line">        </span><br><span class="line">        node.waiter = Thread.currentThread();</span><br><span class="line">        node.setStatusRelaxed(COND | WAITING);</span><br><span class="line">        <span class="comment">// 尾插法插入条件变量的等待队列中</span></span><br><span class="line">        <span class="type">ConditionNode</span> <span class="variable">last</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">            firstWaiter = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last.nextWaiter = node;</span><br><span class="line">        lastWaiter = node;</span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 释放锁并唤醒同步队列中的下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState))</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有独占锁就需要将节点状态改变为 CANCELLED</span></span><br><span class="line">    node.status = CANCELLED; <span class="comment">// lock not held or inconsistent</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="canReacquire-node"><a href="#canReacquire-node" class="headerlink" title="canReacquire(node)"></a><code>canReacquire(node)</code></h5><p>如果一个在等待队列中的节点现在能够参与同步队列的 ReAcquire，返回 true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Returns true if a node that was initially placed on a condition</span></span><br><span class="line"><span class="comment">         * queue is now ready to reacquire on sync queue.*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canReacquire</span><span class="params">(ConditionNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// check links, not status to avoid enqueue race</span></span><br><span class="line">    Node p; <span class="comment">// traverse unless known to be bidirectionally linked</span></span><br><span class="line">    <span class="comment">// 必须要有前驱节点才能</span></span><br><span class="line">    <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; (p = node.prev) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (p.next == node || isEnqueued(node));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Returns true if node is found in traversal from tail */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isEnqueued</span><span class="params">(Node node)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="unlinkCancelledWaiters-node"><a href="#unlinkCancelledWaiters-node" class="headerlink" title="unlinkCancelledWaiters(node)"></a><code>unlinkCancelledWaiters(node)</code></h5><p><strong>机制</strong>：通过遍历队列节点检查状态标记，将已取消的节点从队列中断开引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">(ConditionNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span> || node.nextWaiter != <span class="literal">null</span> || node == lastWaiter) &#123;</span><br><span class="line">        <span class="type">ConditionNode</span> <span class="variable">w</span> <span class="operator">=</span> firstWaiter, trail = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (w != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ConditionNode</span> <span class="variable">next</span> <span class="operator">=</span> w.nextWaiter;</span><br><span class="line">            <span class="keyword">if</span> ((w.status &amp; COND) == <span class="number">0</span>) &#123;</span><br><span class="line">                w.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (trail == <span class="literal">null</span>)</span><br><span class="line">                    firstWaiter = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    trail.nextWaiter = next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                    lastWaiter = trail;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                trail = w;</span><br><span class="line">            w = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="doSignal-firstNode-all"><a href="#doSignal-firstNode-all" class="headerlink" title="doSignal(firstNode, all)"></a><code>doSignal(firstNode, all)</code></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/979960-20180430101906927-1765442903.png" alt="img"></p>
<p>signal(）方法首先会判断当前线程是不是独占的持有锁，从等待队列中取出第一个节点，并将其移动到 AQS 的同步队列中，然后唤醒等待线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(ConditionNode first, <span class="type">boolean</span> all)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ConditionNode</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">        <span class="keyword">if</span> ((firstWaiter = next) == <span class="literal">null</span>)</span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((first.getAndUnsetStatus(COND) &amp; COND) != <span class="number">0</span>) &#123;</span><br><span class="line">            enqueue(first);</span><br><span class="line">            <span class="keyword">if</span> (!all)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ConditionNode</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="signalAll"><a href="#signalAll" class="headerlink" title="signalAll()"></a><code>signalAll()</code></h5><p>与 <code>signal()</code> 类似，只是将所有等待节点依次移动到同步队列并唤醒。<code>signalAll()</code> 会唤醒所有线程，但可能导致“惊群效应”（即多个线程争夺锁），需要根据场景合理选择 <code>signal()</code> 或 <code>signalAll()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ConditionNode</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="死锁排查——JPS"><a href="#死锁排查——JPS" class="headerlink" title="死锁排查——JPS"></a>死锁排查——JPS</h3><p>jps进程状态工具 <strong>jps.exe 工具是 jdk 自带的，在 %JAVA_HOME%/bin 目录下。</strong></p>
<p>第一步：打开idea提供terminal终端命令行，使用<code>jps -l</code>查看进程<br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20230105200845649-1781815144.png" alt="DeadLock1"><br>第二步：使用<code>jstack 进程号</code>查看堆栈信息<br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20230105201438568-23123605.png" alt="DeadLock2"><br>一般情况信息在最后面<br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/3039212-20230105201125421-886160053.png" alt="DeadLock3"></p>
<h1 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a><span id="atomic">原子变量</span></h1><p>一个操作具有原子性，即该操作不可分割、不可中断。即使在多个线程同时执行时，该操作要么全部执行完成，要么不执行，不会被其他线程看到部分完成的状态。</p>
<p><code>java.util.concurrent.atomic</code> 包中的 <code>Atomic</code> 原子类提供了一种线程安全的方式来操作单个变量。<code>Atomic</code> 类依赖于 CAS（Compare-And-Swap，比较并交换）乐观锁来保证其方法的原子性，而不需要使用传统的锁机制（如 <code>synchronized</code> 块或 <code>ReentrantLock</code>）。</p>
<h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a><mark>乐观锁与悲观锁<mark></h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁总是假设最坏的情况，即一定会发生线程安全问题，因此必须串行访问临界区，<code>synchronized</code> 和 <code>ReentrantLock</code> 就是悲观锁，高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题（线程获得锁的顺序不当时），影响代码的正常运行。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。</p>
<p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败并重试，会出现类似活锁的问题，这样同样会非常影响性能，导致 CPU 飙升。</p>
<p>不过，大量失败重试的问题也是可以解决的，像我们前面提到的 <code>LongAdder</code>以空间换时间的方式就解决了这个问题。</p>
<p><strong>理论上</strong>：</p>
<ul>
<li>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li>
<li>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li>
</ul>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>一般是在数据库表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。线程 A 更新数据时读入版本号为 1，此时插入一个线程 B 抢先操作完并提交使版本号更新为 2，线程 A 要提交的时候发现版本号不对，因此重新进行更新操作。</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>CAS 是一条原子操作，依赖于 CPU 的一条指令，在 Java 中由 Unsafe 类(native本地方法类)实现，一共有三个参数：要更新的变量，变量的预期值（旧值），要赋给变量的新值；返回值为CAS是否成功。具体原理参见OSTEP Concurrency 部分，<code>do-while</code> 循环也是自旋锁的原理。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><h5 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h5><p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong> </p>
<p>解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<h5 id="自旋开销大"><a href="#自旋开销大" class="headerlink" title="自旋开销大"></a>自旋开销大</h5><p>CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p>
<h5 id="只对单个变量有效"><a href="#只对单个变量有效" class="headerlink" title="只对单个变量有效"></a>只对单个变量有效</h5><p>CAS 操作仅能对单个共享变量有效。当需要操作多个共享变量时，CAS 就显得无能为力。不过，从 JDK 1.5 开始，Java 提供了<code>AtomicReference</code>类，这使得我们能够保证引用对象之间的原子性。通过将多个变量封装在一个对象中，我们可以使用<code>AtomicReference</code>来执行 CAS 操作。</p>
<p>除了 <code>AtomicReference</code> 这种方式之外，还可以利用加锁来保证。</p>
<h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><p>基本类型：<code>AtomicInteger/Long/Boolean</code></p>
<p>数组类型：<code>AtomicXXXArray</code>  XXX = <code>Integer/Long/Reference</code></p>
<p>引用类型：<code>AtomicReference</code> <code>AtomicStampedReference</code> 引用类型解决ABA</p>
<p>基本方法就是 get getAndAdd getAndIncrement compareAndSet getAndSet</p>
<ul>
<li><code>LongAdder</code>:  消耗内存更多，适合写多读少的情况</li>
<li><code>LongAccumulator</code>: generalized version of LongAdder, use <code>LongBinaryOperator</code> as operations</li>
</ul>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a><span id="executor">线程池</span></h1><h2 id="Future-lt-V-gt"><a href="#Future-lt-V-gt" class="headerlink" title="Future&lt;V&gt;"></a><code>Future&lt;V&gt;</code></h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241230173414548.png" alt="image-20241230173414548"></p>
<p><code>Future</code> 提供了一种轮询/阻塞的方式来获取异步任务的结果，但它不直接支持通知机制，而是需要主动检查任务是否完成。提供方法检查任务是否完成、等待任务完成和获取结果。</p>
<p>是 <code>submit()</code>  的返回值，   isDone() 检查是否完成，get() 阻塞等待返回结果</p>
<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a><code>Callable</code></h3><p>Callable 接口类似于 Runnable，从名字就可以看出来了，会返回结果，并且可以抛出返回结果的异常，使用 <strong>call()</strong> 方法代替 <strong>run()</strong> 方法，适合需要结果的任务。可以直接提交到线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureCallableExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        Callable&lt;Integer&gt; task = () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时任务</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务是否完成: &quot;</span> + future.isDone());</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 阻塞等待结果</span></span><br><span class="line">            System.out.println(<span class="string">&quot;任务结果: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="FutureTask-lt-V-gt"><a href="#FutureTask-lt-V-gt" class="headerlink" title="FutureTask&lt;V&gt;"></a><code>FutureTask&lt;V&gt;</code></h3><p>FutureTask 表示一个异步运算的任务，实现了 Runnable 和 Future 接口（RunnableFuture）</p>
<p>FutureTask 通过传入 Callable 的实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然也可以传入 Runnable 的实现类，但是 Runnable 没有返回值，因此需要额外传入一个指定的返回值。V 表示返回值的类型</p>
<p>只有当任务完成的时候结果才能取回，如果<mark>任务尚未完成 <code>get()</code> 方法将会阻塞<mark>。</p>
<p>FutureTask 可以 submit 到线程池，还可以可以直接作为 Thread 构造器的参数(Runnable)创建新线程（实践中不建议直接创建新线程）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Callable&lt;String&gt; callable = () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;任务完成!&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行其他任务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程正在执行其他任务...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get(); <span class="comment">// 阻塞等待</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行结果: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a><code>ExecutorService</code></h2><p>继承了 ExecutorService 并进行一定程度扩展</p>
<p><code>shutdown()</code> 关闭            <code>submit()</code> 提交任务</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/java-concurrent-executors.png" alt="Executors"></p>
<h3 id="execute-Runnable-command-Runnable-ONLY"><a href="#execute-Runnable-command-Runnable-ONLY" class="headerlink" title="execute(Runnable command) (Runnable ONLY)"></a><code>execute(Runnable command)</code> (<strong>Runnable ONLY</strong>)</h3><p>ThreadPoolExecutor 实现的方法，定义在 <strong><code>Executor</code></strong> 接口中。</p>
<p>只支持提交 <strong><code>Runnable</code></strong> 类型的任务。无返回值，无法获取任务执行结果。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/thread-pool-principle.png" alt="图解线程池实现原理"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********源码************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment"> * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment"> * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment"> * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment"> * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment"> * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment"> * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment"> * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment"> * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment"> * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment"> * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment"> * and so reject the task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 1. 当前线程数 &lt; corePoolSize，创建核心线程</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 如果corePoolSize已满，将任务放入阻塞队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command); <span class="comment">// 检查是否需要拒绝</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 任务队列已满，尝试扩展到 maximumPoolSize</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command); <span class="comment">// 执行拒绝策略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用例</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务1执行: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;);</span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>

<h4 id="submit-supports-Callable-Runnable"><a href="#submit-supports-Callable-Runnable" class="headerlink" title="submit() (supports Callable, Runnable)"></a><code>submit()</code> (supports Callable, Runnable)</h4><p>可以提交 Callable 和 Runnable 任务，返回的是 Future 对象</p>
<ol>
<li>**<code>Runnable</code>**：不返回结果的任务。</li>
<li>**<code>Callable&lt;T&gt;</code>**：<mark>可以返回结果或抛出异常的任务<mark>。</li>
<li>**<code>T result</code>**：指定任务完成后返回的结果。可以给Runnable人工指定返回值，不指定也行</li>
</ol>
<ul>
<li>返回 <strong><code>Future</code></strong> 对象，用于获取任务执行的结果或状态，并且可以方便异常处理。</li>
</ul>
<p>定义在 <strong><code>ExecutorService</code></strong> 接口中，由<code>AbstractExecutorService</code>实现。支持 <strong><code>Runnable</code></strong> 和 <strong><code>Callable</code></strong> 两种任务类型。返回一个 <strong><code>Future&lt;T&gt;</code></strong> 对象，可以获取任务结果或判断任务状态。</p>
<p>主要的任务就是将 Runnable 或者 Callable 封装成 <strong>FutureTask</strong>，FutureTask 实现了 RunnableFuture（实现了 Runnable）可以直接作为 execute(Runnable command) 的参数，查看返回值本身跟线程池没关系，是 Future 的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br><span class="line">Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务2执行: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务结果: &quot;</span> + future.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>

<h3 id="Executors-工具类提供的默认线程池"><a href="#Executors-工具类提供的默认线程池" class="headerlink" title="Executors 工具类提供的默认线程池"></a>Executors 工具类提供的默认线程池</h3><table>
<thead>
<tr>
<th>线程池类型</th>
<th>核心线程数</th>
<th>最大线程数</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>FixedThreadPool</strong></td>
<td>固定数量</td>
<td>固定数量</td>
<td>固定线程数，适合长期稳定的任务执行。积压任务排队等待</td>
</tr>
<tr>
<td><strong>CachedThreadPool</strong></td>
<td>0</td>
<td>无限制</td>
<td>动态扩展线程，适合短期大量任务。60s 回收空闲位置</td>
</tr>
<tr>
<td><strong>SingleThreadExecutor</strong></td>
<td>1</td>
<td>1</td>
<td>单线程执行任务，保证顺序。</td>
</tr>
<tr>
<td><strong>ScheduledThreadPool</strong></td>
<td>固定数量</td>
<td>无限制</td>
<td>支持延迟和周期性任务调度。</td>
</tr>
<tr>
<td><strong>WorkStealingPool</strong></td>
<td>CPU 核心数</td>
<td>CPU 核心数</td>
<td>支持并行任务执行和任务窃取算法。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 固定大小线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 可缓存线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">// 单线程线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">// 定时任务线程池</span></span><br><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 定时任务</span></span><br><span class="line">pool.schedule(() -&gt; System.out.println(<span class="string">&quot;delay&quot;</span>), <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 周期任务</span></span><br><span class="line">pool.scheduleAtFixedRate(() -&gt; System.out.println(<span class="string">&quot;周期&quot;</span>), </span><br><span class="line">                         <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><h4 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h4><ul>
<li>**<code>execute()</code>**：只关注任务执行，不关注结果或异常处理。适合无需返回值的任务，只支持Runnable。</li>
<li>**<code>submit()</code>**：既关注任务执行，也关注结果和异常处理，适合需要返回结果的任务，除了Runnable 也支持 Callable，返回 Future，对其调用get()会阻塞当前任务。</li>
</ul>
<p><strong>最佳实践：</strong> 优先使用 **<code>submit()</code>**，即使不需结果，也可以捕获潜在异常，避免线程池异常崩溃。</p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ul>
<li><strong>使用<code>execute()</code>提交任务</strong>：当任务通过<code>execute()</code>提交到线程池并在执行过程中抛出异常时，如果这个异常没有在任务内被捕获，那么该异常会导致当前线程终止，并且异常会被打印到控制台或日志文件中。线程池会检测到这种线程终止，并创建一个新线程来替换它，从而保持配置的线程数不变。</li>
<li><strong>使用<code>submit()</code>提交任务</strong>：对于通过<code>submit()</code>提交的任务，如果在任务执行中发生异常，这个异常不会直接打印出来。相反，异常会被封装在由<code>submit()</code>返回的<code>Future</code>对象中。当调用<code>Future.get()</code>方法时，可以捕获到一个<code>ExecutionException</code>。在这种情况下，线程不会因为异常而终止，它会继续存在于线程池中，准备执行后续的任务。</li>
</ul>
<p>简单来说：使用<code>execute()</code>时，未捕获异常导致线程终止，线程池创建新线程替代；使用<code>submit()</code>时，异常被封装在<code>Future</code>中，线程继续复用。</p>
<p>这种设计允许<code>submit()</code>提供更灵活的错误处理机制，因为它允许调用者决定如何处理异常，而<code>execute()</code>则适用于那些不需要关注执行结果的场景。</p>
<h4 id="使用自定义线程池-ThreadPoolExecutor"><a href="#使用自定义线程池-ThreadPoolExecutor" class="headerlink" title="使用自定义线程池 ThreadPoolExecutor"></a><mark>使用自定义线程池 <code>ThreadPoolExecutor</code><mark></h4><p>**避免使用 <code>Executors</code> 创建线程池：推荐直接使用<code>ThreadPoolExecutor</code> 自定义线程池：因为 **<code>Executors</code> 默认队列为 <strong>无限队列</strong>，可能导致内存溢出。除了避免 OOM 的原因之外，不推荐使用 <code>Executors</code>提供快捷的线程池的原因：</p>
<ul>
<li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。<ul>
<li>CPU 密集型任务的 <code>WT/ST</code> 接近或者等于 0，因此， 线程数可以设置为 N（CPU 核心数）∗（1+0）= N，和我们上面说的 N（CPU 核心数）+1 差不多。</li>
<li>IO 密集型任务下，几乎全是线程等待时间，从理论上来说，你就可以将线程数设置为 2N（按道理来说，WT/ST 的结果应该比较大，这里选择 2N 的原因应该是为了避免创建过多线程吧）。</li>
</ul>
</li>
</ul>
<h5 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h5><p>建议实践中手动指定线程池配置，ThreadPoolExecutor的构造器共有七个参数：</p>
<ol>
<li><p><code>int corePoolSize</code>: 核心线程数     </p>
</li>
<li><p><code>int maxPoolSize</code>: 最大线程数</p>
</li>
<li><p><code>long keepAliveTime</code>: 非核心线程闲置的最长时间，超时销毁</p>
</li>
<li><p><code>TimeUnit unit</code>: 时间单位，枚举</p>
</li>
<li><p><code>BlockingQueue&lt;Runnable&gt; workQueue</code>: 保存任务的阻塞队列</p>
<ul>
<li><p>如果运行的线程数少于 corePoolSize，则执行器始终倾向于添加新线程而不是排队。</p>
</li>
<li><p>如果 corePoolSize 或更多线程正在运行，对请求进行排队而不是添加新线程。</p>
</li>
<li><p>如果请求无法排队，则会创建一个新线程，如果超出了 MaximumPoolSize，拒绝策略</p>
</li>
</ul>
</li>
</ol>
<ul>
<li><code>SynchronousQueue</code>不会保存任务，直接递交给线程，没有就创建，需要maxPoolSize很大，<code>CachedThreadPool</code> 就属于这种，创建无限个线程也会OOM。</li>
<li><code>LinkedBlockingQueue</code>为无界队列，默认最大容量为 <strong>Integer.MAX_VALUE</strong>，可能会导致任务积压 OOM，比如 Fixed 和 Single<ul>
<li>当所有 <code>corePoolSize</code> 线程都忙时，使用无界队列（例如没有预定义容量的 LinkedBlockingQueue）将导致新任务在队列中等待。</li>
<li>线程最多只有corePoolSize，maxSize没有影响。</li>
<li>当每个任务完全独立于其他任务时，这可能是合适的，因此任务不会影响彼此的执行；例如，在网页服务器中。虽然这种排队方式对于平滑请求的瞬态突发很有用，但它当命令平均到达速度继续快于处理速度时，可能发生OOM</li>
</ul>
</li>
<li><code>ArrayBlockingQueue</code>为有界队列，防止OOM：<ul>
<li>使用大队列和小池可以最大限度地减少 CPU 使用率、操作系统资源和上下文切换开销，但可能会导致人为降低吞吐量。</li>
<li>使用小队列通常需要更大的池，提高了 CPU 的利用率，但遇到不可接受的调度开销时也会降低吞吐量。</li>
</ul>
</li>
</ul>
<p><strong><u>Optional</u> Parameters</strong>：</p>
<ol start="5">
<li><code>ThreadFactory threadFactory</code>: 线程工厂，创建新线程，支持自定义线程名称等属性。</li>
</ol>
<ul>
<li>默认为 <code>Executors.defaultThreadFactory()</code> </li>
</ul>
<ol start="6">
<li><code>RejectedExecutionHandler handler</code>: 线程池满负荷(队列满且maxPoolSize)的拒绝策略</li>
</ol>
<ul>
<li><code>AbortPolicy</code>(default): 抛出<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/RejectedExecutionException.html"><code>RejectedExecutionException</code></a> 异常</li>
<li><code>CallerRunsPolicy</code>: 由提交任务的线程直接执行任务，防止任务丢失。这提供了一个简单的反馈控制机制，将减慢新任务提交的速度。</li>
<li><code>DiscardOldestPolicy</code>: 丢弃最旧未执行的任务，工作队列头部的任务将被删除，然后重试执行（可能会再次失败，导致重复执行）。这种策略很少被接受</li>
<li><code>DiscardPolicy</code>: 直接丢弃，不抛出任何异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">// 队列长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>线程池可以使用getter setter等方法进行参数的访问与更改</p>
</li>
<li><p>使用 Spring 内部线程池 ThreadPoolTaskExecutor 时，一定要手动自定义，合理配置参数，不然会出现生产问题（一个请求创建一个线程）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(name=&quot;threadPoolExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">threadPoolExecutor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">// 返回可用处理器的Java虚拟机的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">processNum</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors(); </span><br><span class="line">        <span class="type">int</span> <span class="variable">corePoolSize</span> <span class="operator">=</span> (<span class="type">int</span>) (processNum / (<span class="number">1</span> - <span class="number">0.2</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxPoolSize</span> <span class="operator">=</span> (<span class="type">int</span>) (processNum / (<span class="number">1</span> - <span class="number">0.5</span>));</span><br><span class="line">        threadPoolExecutor.setCorePoolSize(corePoolSize); <span class="comment">// 核心池大小</span></span><br><span class="line">        threadPoolExecutor.setMaxPoolSize(maxPoolSize); <span class="comment">// 最大线程数</span></span><br><span class="line">        threadPoolExecutor.setQueueCapacity(maxPoolSize * <span class="number">1000</span>); <span class="comment">// 队长</span></span><br><span class="line">        threadPoolExecutor.setThreadPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        threadPoolExecutor.setDaemon(<span class="literal">false</span>);</span><br><span class="line">        threadPoolExecutor.setKeepAliveSeconds(<span class="number">300</span>);<span class="comment">// 线程空闲时间</span></span><br><span class="line">        <span class="comment">// 线程名字前缀</span></span><br><span class="line">        threadPoolExecutor.setThreadNamePrefix(<span class="string">&quot;test-Executor-&quot;</span>); </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> threadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h5><ul>
<li><p>给线程池(实际上是ThreadFactory)命名，有助于定位问题。一般可以使用 Guava：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                        .setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>)</span><br><span class="line">                        .setDaemon(<span class="literal">true</span>).build();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize,</span><br><span class="line">  maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue,</span><br><span class="line"> threadFactory);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="适度复用"><a href="#适度复用" class="headerlink" title="适度复用"></a><strong>适度</strong>复用</h4><ul>
<li><p>要<mark>适当复用<mark>线程池，不要一个请求创建一个线程池，浪费资源且效率极低。</p>
</li>
<li><p>根据当前业务的情况对线程池进行配置，<mark>不同业务不要复用线程池<mark>：父任务占满线程池，导致子任务阻塞，但是父任务也同时被子任务阻塞，造成互相等待的死锁局面。</p>
</li>
</ul>
<h4 id="正确关闭"><a href="#正确关闭" class="headerlink" title="正确关闭"></a>正确关闭</h4><p>释放资源，shutdown(Now)不过只是异步通知，不会同步阻塞等待。</p>
<ul>
<li><strong><code>void shutdown()</code></strong> 有序关闭，执行完先前提交的任务。</li>
<li><strong><code>List&lt;Runnable&gt; shutdownNow()</code></strong> 停止所有正在执行的任务，停止正在等待的任务的处理，并返回正在等待执行的任务的列表。</li>
<li><code>awaitTermination</code> 同步阻塞等待</li>
<li>实现了autoclosable，close方法可以阻塞等待，因此trywithresource</li>
</ul>
<h4 id="不要和-JDK-自带-ThreadLocal-共用"><a href="#不要和-JDK-自带-ThreadLocal-共用" class="headerlink" title="不要和 JDK 自带 ThreadLocal 共用"></a>不要和 JDK 自带 ThreadLocal 共用</h4><p>这是因为线程池会复用线程对象，与线程对象绑定的类的静态属性 <code>ThreadLocal</code> 变量也会被重用，这就导致一个线程可能获取到其他线程的<code>ThreadLocal</code> 值。</p>
<h4 id="不要放入耗时任务"><a href="#不要放入耗时任务" class="headerlink" title="不要放入耗时任务"></a>不要放入耗时任务</h4><p>线程池本身的目的是为了提高任务执行效率，避免因频繁创建和销毁线程而带来的性能开销。如果将耗时任务提交到线程池中执行，可能会导致线程池中的线程被长时间占用，无法及时响应其他任务，甚至会导致线程池崩溃或者程序假死。这些任务可以采用异步 <code>CompletableFuture</code> 完成</p>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a><code>CompletableFuture</code></h2><p><code>Future</code> 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 <code>get()</code> 方法为阻塞调用。Java 8 才被引入<code>CompletableFuture</code> 类可以解决<code>Future</code> 的这些缺陷。<code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。对某些部分可以并行执行的异步任务支持比较好。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>runAsync</code></strong></td>
<td>执行无返回值异步任务。</td>
</tr>
<tr>
<td><strong><code>supplyAsync</code></strong></td>
<td>执行有返回值异步任务。</td>
</tr>
<tr>
<td><strong><code>thenApply</code></strong></td>
<td>转换结果并返回新的结果。</td>
</tr>
<tr>
<td><strong><code>thenAccept</code></strong></td>
<td>消费结果但不返回新结果。</td>
</tr>
<tr>
<td><strong><code>thenCombine</code></strong></td>
<td>合并两个任务的结果。</td>
</tr>
<tr>
<td><strong><code>allOf</code></strong> / <strong><code>anyOf</code></strong></td>
<td>等待所有任务完成 / 任意任务完成。</td>
</tr>
<tr>
<td><strong><code>exceptionally</code></strong> / <strong><code>handle</code></strong></td>
<td>处理异常并提供默认值或继续处理结果。</td>
</tr>
</tbody></table>
<p>以下是 <strong><code>CompletableFuture</code></strong> 的使用示例及详解：</p>
<h3 id="任务创建"><a href="#任务创建" class="headerlink" title="任务创建"></a>任务创建</h3><p><strong>创建异步任务：</strong><code>runAsync()</code><strong>：执行无返回值任务。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行异步任务：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;);</span><br><span class="line">future.join(); <span class="comment">// 等待任务执行完成</span></span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>join()</code>**：等待任务执行完成（类似 **<code>get()</code>**，但不会抛出 checked 异常）。</li>
</ul>
<p><strong>执行有返回值任务：</strong><code>supplyAsync()</code><strong>：执行有返回值任务。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;计算中...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;计算结果：&quot;</span> + future.join());</span><br></pre></td></tr></table></figure>

<h3 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h3><p><code>thenApply</code> - 对任务结果进行变换（同步执行）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span>)</span><br><span class="line">        .thenApply(result -&gt; result * <span class="number">2</span>); <span class="comment">// 结果翻倍</span></span><br><span class="line">System.out.println(future.join()); <span class="comment">// 输出 20</span></span><br></pre></td></tr></table></figure>

<p><code>thenAccept</code> - 消费结果，不返回新的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">        .thenAccept(result -&gt; System.out.println(<span class="string">&quot;结果: &quot;</span> + result));</span><br></pre></td></tr></table></figure>

<p><code>thenRun</code> - 不关心前一任务结果，直接执行下一步操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;任务完成&quot;</span>)</span><br><span class="line">        .thenRun(() -&gt; System.out.println(<span class="string">&quot;继续执行任务&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="组合多个任务"><a href="#组合多个任务" class="headerlink" title="组合多个任务"></a>组合多个任务</h3><p><code>thenCombine</code> - 合并两个任务结果，组合两个任务结果，并执行新任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span>);</span><br><span class="line">CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; result = future1.thenCombine(future2, (a, b) -&gt; a + b);</span><br><span class="line">System.out.println(<span class="string">&quot;结果: &quot;</span> + result.join()); <span class="comment">// 输出 30</span></span><br></pre></td></tr></table></figure>

<p><code>allOf</code> - 等待所有任务完成，但不返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;任务1&quot;</span>)),</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;任务2&quot;</span>)),</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;任务3&quot;</span>))</span><br><span class="line">);</span><br><span class="line">all.join(); <span class="comment">// 等待所有任务完成</span></span><br></pre></td></tr></table></figure>

<p><code>anyOf</code> - 任意任务完成即结束，返回第一个任务的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Object&gt; any = CompletableFuture.anyOf(</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;任务1&quot;</span>),</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;任务2&quot;</span>),</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;任务3&quot;</span>)</span><br><span class="line">);</span><br><span class="line">System.out.println(<span class="string">&quot;最快完成的任务: &quot;</span> + any.join());</span><br></pre></td></tr></table></figure>

<h3 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h3><p><code>exceptionally</code> - 捕获异常并返回默认值，继续执行任务链。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;任务异常&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;捕获异常: &quot;</span> + ex.getMessage());</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 返回默认值</span></span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;结果: &quot;</span> + future.join()); <span class="comment">// 输出 -1</span></span><br></pre></td></tr></table></figure>

<p><code>handle</code>- 捕获异常并处理结果,同时处理正常结果和异常情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;计算出错&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;).handle((result, ex) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理异常: &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 返回默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;最终结果: &quot;</span> + future.join());</span><br></pre></td></tr></table></figure>

<h3 id="线程池自定义"><a href="#线程池自定义" class="headerlink" title="线程池自定义"></a>线程池自定义</h3><p>指定线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;自定义线程池: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;, executor).join();</span><br><span class="line"></span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>

<p>**异步任务默认使用 **<code>ForkJoinPool.commonPool()</code>，但可以自定义线程池以控制资源。</p>
<h3 id="例：批量任务处理"><a href="#例：批量任务处理" class="headerlink" title="例：批量任务处理"></a>例：批量任务处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;CompletableFuture&lt;Integer&gt;&gt; futures = IntStream.range(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">        .mapToObj(i -&gt; CompletableFuture.supplyAsync(() -&gt; i * <span class="number">2</span>))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; allDone = CompletableFuture.allOf(</span><br><span class="line">        futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>])</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">allDone.join();</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; results = futures.stream()</span><br><span class="line">        .map(CompletableFuture::join)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;所有结果: &quot;</span> + results);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <strong><code>allOf()</code></strong> 确保所有任务完成。</li>
<li>收集各任务结果并返回。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有结果: [2, 4, 6, 8, 10]</span><br></pre></td></tr></table></figure>

<h3 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/virtual-thread.html">虚拟线程</a></h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default/">1</a><span class="page-number current">2</span><a class="page-number" href="/default/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/default/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">碎梦</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/scatteredream" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
