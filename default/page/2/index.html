<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Arvo:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scatteredream.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="scatteredream&#39;s blog">
<meta property="og:url" content="http://scatteredream.github.io/default/page/2/index.html">
<meta property="og:site_name" content="scatteredream&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="碎梦">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://scatteredream.github.io/default/page/2/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default/page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>scatteredream's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">scatteredream's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">碎梦</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">97</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/20/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/20/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">点评项目优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-20T00:00:00+08:00">2024-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 15:33:58" itemprop="dateModified" datetime="2025-04-27T15:33:58+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="hmdp-optimization"><a href="#hmdp-optimization" class="headerlink" title="hmdp-optimization"></a>hmdp-optimization</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><mark>STRING<mark> </p>
<ul>
<li><code>sign:&#123;userId&#125;:202411</code> 2024年11月的userId的签到信息 （bitmap）</li>
<li><code>incr:order:2024:11:10</code> 2024年11月10号的订单序列号serialNumber，唯一id（timestamp&lt;&lt;32 | serialNumber）</li>
<li><code>seckill:stock:&#123;voucherId&#125;</code> voucherId的优惠券对应的库存</li>
<li><code>cache:shop:&#123;shopId&#125;</code> shopId的商铺信息</li>
<li><code>login:code:&#123;phoneNumber&#125;</code> 验证码信息</li>
</ul>
<p><mark>LIST<mark> </p>
<ul>
<li><code>cache:shoptype</code>（商铺类型信息JSON数组）</li>
</ul>
<p><mark>ZSET<mark> </p>
<ul>
<li><p><code>shop:geo:&#123;shopId&#125;</code> 商铺地理位置信息</p>
</li>
<li><p><code>blog:liked:&#123;blogId&#125;</code> blogId的博客点赞信息，包括userId 以及对应的score（unix时间）</p>
</li>
<li><p><code>feed:&#123;userId&#125;</code> userId 的收件箱，保存笔记时推送到所有粉丝（看看谁follow了我）包括了 blogId 以及对应的score </p>
</li>
</ul>
<p><mark>SET<mark> </p>
<ul>
<li><code>follows:&#123;userId&#125;</code> userId 关注的人</li>
<li><code>seckill:order:&#123;voucherId&#125;</code> 抢过voucherId的优惠券的人的集合</li>
</ul>
<p><mark>HASH<mark> </p>
<ul>
<li><code>login:token:&#123;token&#125;</code> 存储token对应的userDTO </li>
</ul>
<h2 id="feed-滚动"><a href="#feed-滚动" class="headerlink" title="feed 滚动"></a>feed 滚动</h2><p>10-6 5-1 一共是两页，传统分页在feed流是不适用的，因为我们的数据会随时发生变化，</p>
<p>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</p>
<h2 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h2><p>blog blog评论 关注的人(x在t时间关注了y) 用户表 </p>
<p>商铺 商铺类别</p>
<p>券 秒杀券 秒杀券订单</p>
<h2 id="热key-大key"><a href="#热key-大key" class="headerlink" title="热key 大key"></a>热key 大key</h2><p>在处理热key、大key以及分表问题时，可以采用以下策略进行优化：</p>
<hr>
<h3 id="一、热Key处理方案"><a href="#一、热Key处理方案" class="headerlink" title="一、热Key处理方案"></a><strong>一、热Key处理方案</strong></h3><ol>
<li><p><strong>监控与识别</strong><br>• 使用Redis监控工具（如<code>redis-cli --hotkeys</code>、<code>MONITOR</code>命令）或APM系统（如Prometheus）识别高频访问的key。<br>• 业务侧预判热点（如秒杀商品ID、热门话题），提前介入优化。</p>
</li>
<li><p><strong>多级缓存</strong><br>• <strong>本地缓存</strong>：结合Guava Cache或Caffeine，将热key缓存在应用服务器本地，减少Redis压力。<br>• <strong>分布式缓存冗余</strong>：复制热key到多个Redis实例（如<code>key:1</code>, <code>key:2</code>），通过随机访问分散压力。</p>
</li>
<li><p><strong>缓存续期与互斥锁</strong><br>• <strong>逻辑过期</strong>：Value中存储过期时间，异步更新缓存，避免物理过期后大量请求穿透到DB。<br>• <strong>互斥锁（Mutex Lock）</strong>：缓存失效时，仅允许一个线程重建数据，其他线程等待或返回降级结果。</p>
</li>
<li><p><strong>读写分离与分片</strong><br>• 使用Redis Cluster或Codis分片，分散热key压力。<br>• 读写分离：通过从节点处理读请求，主节点处理写请求。</p>
</li>
</ol>
<hr>
<h3 id="二、大Key处理方案"><a href="#二、大Key处理方案" class="headerlink" title="二、大Key处理方案"></a><strong>二、大Key处理方案</strong></h3><ol>
<li><p><strong>拆分与分片</strong><br>• <strong>横向拆分</strong>：将大Hash/List按字段或元素拆分（如<code>user:1000:info</code>拆为<code>user:1000:base</code>、<code>user:1000:contact</code>）。<br>• <strong>分片存储</strong>：对Key添加分片后缀（如<code>user:&#123;id%10&#125;:profile</code>），分散存储。</p>
</li>
<li><p><strong>异步删除</strong><br>• 使用<code>UNLINK</code>替代<code>DEL</code>，非阻塞删除大Key。<br>• 渐进式删除：通过脚本分批删除Hash/Set元素（如<code>HSCAN</code>遍历删除）。</p>
</li>
<li><p><strong>压缩与存储优化</strong><br>• 序列化优化：使用Protobuf或MessagePack替代JSON。<br>• 冷热分离：将大Key中低频数据存入MySQL/HBase，高频数据保留在Redis。</p>
</li>
<li><p><strong>设计规避</strong><br>• 避免单个Key存储超过1MB的数据。<br>• 使用HyperLogLog替代大Set统计UV，或使用TimeSeries存储时序数据。</p>
</li>
</ol>
<hr>
<h3 id="三、分表方案（以MySQL为例）"><a href="#三、分表方案（以MySQL为例）" class="headerlink" title="三、分表方案（以MySQL为例）"></a><strong>三、分表方案（以MySQL为例）</strong></h3><ol>
<li><p><strong>水平分表</strong><br>• <strong>规则分片</strong>：按哈希（如<code>user_id % 100</code>）、范围（如时间戳）或一致性哈希拆分数据。<br>• <strong>中间件</strong>：使用ShardingSphere、Vitess等工具自动路由查询。</p>
</li>
<li><p><strong>垂直分表</strong><br>• 将大表按列拆分（如用户基础信息表<code>user_base</code>与扩展信息表<code>user_extend</code>），减少单行数据量。</p>
</li>
<li><p><strong>全局ID与查询优化</strong><br>• 分布式ID生成（雪花算法、Redis自增ID）避免主键冲突。<br>• 冗余字段或索引表：通过异步维护冗余字段（如商户ID+订单ID）支持多维度查询。</p>
</li>
<li><p><strong>结合Redis</strong><br>• 缓存分表路由信息（如<code>user_shard:1000 -&gt; shard_2</code>），加速查询。<br>• 热数据缓存：将分表后的热数据单独缓存，降低DB压力。</p>
</li>
</ol>
<hr>
<h3 id="四、Redis分片与集群"><a href="#四、Redis分片与集群" class="headerlink" title="四、Redis分片与集群"></a><strong>四、Redis分片与集群</strong></h3><ol>
<li><p><strong>Redis Cluster</strong><br>• 自动分片（16384 slots），支持水平扩展和高可用。<br>• 通过<code>CRC16(key) % 16384</code>计算slot，分散数据。</p>
</li>
<li><p><strong>客户端分片</strong><br>• 使用一致性哈希算法（如Jedis的<code>ShardedJedis</code>）在客户端路由请求。</p>
</li>
<li><p><strong>Proxy方案</strong><br>• 通过Twemproxy或Codis代理层管理分片，对业务透明。</p>
</li>
</ol>
<hr>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a><strong>五、总结</strong></h3><p>• <strong>热Key</strong>：多级缓存 + 分片 + 异步更新。<br>• <strong>大Key</strong>：拆分 + 异步删除 + 设计规避。<br>• <strong>分表</strong>：合理分片规则 + 中间件 + 缓存加速。<br>• <strong>监控</strong>：实时监控Key大小和QPS，提前预防问题。</p>
<p>通过组合以上策略，可显著提升系统性能和稳定性，应对高并发与大数据的挑战。</p>
<h2 id="延迟双删"><a href="#延迟双删" class="headerlink" title="延迟双删"></a>延迟双删</h2><p>通过重试、过期时间、补偿机制保证最终一致性，避免因删除失败导致脏数据长期存在。</p>
<p>延迟双删是解决缓存与数据库一致性的策略，步骤如下：</p>
<ol>
<li>删除缓存。</li>
<li>更新数据库。</li>
<li>延迟一段时间（如等主从同步完成）。</li>
<li>再次删除缓存。</li>
</ol>
<p><strong>若第二次删除失败</strong>：</p>
<ul>
<li><strong>重试机制</strong>：将删除操作加入重试队列（如消息队列），确保最终成功。</li>
<li><strong>设置缓存过期时间</strong>：即使删除失败，缓存也会自动失效，减少不一致的时间窗口。</li>
<li><strong>异步补偿</strong>：通过定时任务检查并清理残留脏数据。</li>
</ul>
<h2 id="缓存：旁路缓存"><a href="#缓存：旁路缓存" class="headerlink" title="缓存：旁路缓存"></a>缓存：旁路缓存</h2><p>Cache Aside Pattern（旁路缓存机制）是一种广泛应用于高并发系统的缓存设计模式，其核心目标是<strong>解决缓存与数据库之间的数据一致性问题</strong>，同时提升系统的读取性能。以下是该模式的具体解决场景、实现原理及实际应用分析：</p>
<hr>
<h3 id="解决的问题场景"><a href="#解决的问题场景" class="headerlink" title="解决的问题场景"></a><strong>解决的问题场景</strong></h3><h4 id="读多写少的高并发场景"><a href="#读多写少的高并发场景" class="headerlink" title="读多写少的高并发场景"></a><strong>读多写少的高并发场景</strong></h4><p>• <strong>典型场景</strong>：用户信息查询、商品详情页、新闻内容页等。<br>• <strong>痛点</strong>：直接读取数据库会导致性能瓶颈，缓存能显著降低数据库压力，但需保证缓存与数据库的一致性。</p>
<h4 id="数据更新后的缓存一致性"><a href="#数据更新后的缓存一致性" class="headerlink" title="数据更新后的缓存一致性"></a><strong>数据更新后的缓存一致性</strong></h4><p>• <strong>痛点</strong>：数据更新时，若缓存与数据库的更新顺序或策略不当，可能引发脏读、旧数据残留等问题。</p>
<h4 id="缓存穿透与雪崩的规避"><a href="#缓存穿透与雪崩的规避" class="headerlink" title="缓存穿透与雪崩的规避"></a><strong>缓存穿透与雪崩的规避</strong></h4><p>• <strong>痛点</strong>：恶意请求或缓存失效时，大量请求穿透到数据库，导致数据库过载甚至宕机。</p>
<hr>
<h3 id="Cache-Aside-Pattern-的实现原理"><a href="#Cache-Aside-Pattern-的实现原理" class="headerlink" title="Cache Aside Pattern 的实现原理"></a><strong>Cache Aside Pattern 的实现原理</strong></h3><h4 id="读流程（优先读缓存）"><a href="#读流程（优先读缓存）" class="headerlink" title="读流程（优先读缓存）"></a><strong>读流程（优先读缓存）</strong></h4><p>• <strong>步骤</strong>：  </p>
<pre><code>1. 客户端读取数据时，先查询缓存。  
2. 若缓存命中（Cache Hit），直接返回结果。  
3. 若缓存未命中（Cache Miss），查询数据库，将结果写入缓存后返回。  
   • **代码示例**：  
</code></pre>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Data <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 先查缓存</span></span><br><span class="line">    <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 缓存未命中，查数据库</span></span><br><span class="line">    data = database.read(key);</span><br><span class="line">    <span class="comment">// 3. 回填缓存</span></span><br><span class="line">    cache.set(key, data, TTL);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写流程（更新数据库后失效缓存）"><a href="#写流程（更新数据库后失效缓存）" class="headerlink" title="写流程（更新数据库后失效缓存）"></a><strong>写流程（更新数据库后失效缓存）</strong></h4><p>• <strong>步骤</strong>：  </p>
<pre><code>1. 客户端更新数据时，先更新数据库。  
2. 删除缓存（而非更新缓存），确保下次读取时触发缓存回填。  
   • **代码示例**：  
</code></pre>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(String key, Data newData)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 更新数据库</span></span><br><span class="line">    database.update(key, newData);</span><br><span class="line">    <span class="comment">// 2. 删除缓存</span></span><br><span class="line">    cache.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="核心解决的问题"><a href="#核心解决的问题" class="headerlink" title="核心解决的问题"></a><strong>核心解决的问题</strong></h3><h4 id="缓存与数据库的一致性"><a href="#缓存与数据库的一致性" class="headerlink" title="缓存与数据库的一致性"></a><strong>缓存与数据库的一致性</strong></h4><p>• <strong>旧数据问题</strong>：直接更新缓存可能导致并发场景下出现脏数据（如两个并发写操作顺序错乱）。<br>• <strong>解决方案</strong>：通过“更新数据库 + 删除缓存”的组合，确保下一次读请求回填最新数据。</p>
<h4 id="降低并发写冲突"><a href="#降低并发写冲突" class="headerlink" title="降低并发写冲突"></a><strong>降低并发写冲突</strong></h4><p>• <strong>场景示例</strong>：若先删除缓存再更新数据库，可能因网络延迟导致其他线程读到旧数据并回填缓存。<br>• <strong>优化策略</strong>：采用 <strong>延迟双删</strong>（先删缓存→更新数据库→再删缓存），但需权衡复杂度。</p>
<h4 id="规避缓存穿透与雪崩"><a href="#规避缓存穿透与雪崩" class="headerlink" title="规避缓存穿透与雪崩"></a><strong>规避缓存穿透与雪崩</strong></h4><p>• <strong>缓存穿透</strong>：恶意查询不存在的数据（如不存在的用户ID）。<br>  • <strong>解决方案</strong>：缓存空值（Null Object）并设置较短TTL。<br>• <strong>缓存雪崩</strong>：大量缓存同时失效导致数据库被击穿。<br>  • <strong>解决方案</strong>：设置随机化过期时间（如基础TTL + 随机偏移量）。</p>
<hr>
<h3 id="实际应用案例"><a href="#实际应用案例" class="headerlink" title="实际应用案例"></a><strong>实际应用案例</strong></h3><h4 id="案例1：电商商品库存更新"><a href="#案例1：电商商品库存更新" class="headerlink" title="案例1：电商商品库存更新"></a><strong>案例1：电商商品库存更新</strong></h4><p>• <strong>场景</strong>：用户下单后扣减库存。<br>• <strong>流程</strong>：  </p>
<pre><code>1. 更新数据库库存（原子操作：`UPDATE stock SET count=count-1 WHERE product_id=xxx AND count&gt;0`）。  
2. 删除商品库存缓存（`cache.delete(&quot;product_stock_xxx&quot;)`）。  
3. 后续查询库存时触发缓存回填，读取最新值。
</code></pre>
<h4 id="案例2：用户信息更新"><a href="#案例2：用户信息更新" class="headerlink" title="案例2：用户信息更新"></a><strong>案例2：用户信息更新</strong></h4><p>• <strong>场景</strong>：用户修改昵称后，前端需要展示最新数据。<br>• <strong>流程</strong>：  </p>
<pre><code>1. 更新数据库用户表。  
2. 删除用户信息缓存（如 `cache.delete(&quot;user_info_123&quot;)`）。  
3. 下次读取时从数据库加载新数据并回填缓存。
</code></pre>
<hr>
<h3 id="与其他缓存模式的对比"><a href="#与其他缓存模式的对比" class="headerlink" title="与其他缓存模式的对比"></a><strong>与其他缓存模式的对比</strong></h3><table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>特点</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Cache Aside</strong></td>
<td>应用层控制缓存逻辑，更新数据库后删除缓存，简单但需处理并发问题。</td>
<td>读多写少，一致性要求较高</td>
</tr>
<tr>
<td><strong>Read/Write Through</strong></td>
<td>缓存层代理数据库操作，应用无需感知缓存逻辑（如Redis Module）。</td>
<td>缓存与数据库强绑定，逻辑简单化</td>
</tr>
<tr>
<td><strong>Write Behind</strong></td>
<td>异步批量更新数据库，缓存作为写入缓冲区，吞吐量高但存在数据丢失风险。</td>
<td>写密集且允许短暂数据不一致（如日志）</td>
</tr>
</tbody></table>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p><strong>并发场景下的极端问题</strong>：<br>• <strong>问题</strong>：A线程读缓存未命中→查询旧数据库数据→B线程更新数据库并删缓存→A线程回填旧数据到缓存。<br>• <strong>解决方案</strong>：加分布式锁（如Redisson）或设置缓存更新版本号。  </p>
</li>
<li><p><strong>缓存删除失败的重试机制</strong>：<br>• <strong>方案</strong>：引入消息队列（如Kafka）异步重试删除缓存。  </p>
</li>
<li><p><strong>冷启动预热</strong>：<br>• <strong>方案</strong>：系统启动时加载热点数据到缓存（如Top 100商品）。</p>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>Cache Aside Pattern 通过<strong>优先读缓存、更新数据库后失效缓存</strong>的策略，解决了高并发下缓存与数据库的一致性问题，适用于读多写少且对一致性要求较高的场景。实际应用中需结合业务特点，处理并发冲突、缓存穿透/雪崩等问题，必要时引入异步重试、分布式锁等机制。</p>
<h2 id="缓存更新失败怎么办？重试机制"><a href="#缓存更新失败怎么办？重试机制" class="headerlink" title="缓存更新失败怎么办？重试机制"></a>缓存更新失败怎么办？重试机制</h2><p>在 Cache Aside Pattern 中，若 <strong>更新数据库后删除缓存的操作失败</strong>，会导致缓存中残留旧数据，后续读请求可能返回不一致的结果。以下是分层解决方案，涵盖 <strong>容错设计、补偿机制和业务兜底策略</strong>：</p>
<hr>
<h3 id="容错设计：同步重试"><a href="#容错设计：同步重试" class="headerlink" title="容错设计：同步重试"></a><strong>容错设计：同步重试</strong></h3><h4 id="本地重试（立即重试）"><a href="#本地重试（立即重试）" class="headerlink" title="本地重试（立即重试）"></a><strong>本地重试（立即重试）</strong></h4><p>• <strong>场景</strong>：因网络抖动或瞬时故障导致删除缓存失败。<br>• <strong>实现</strong>：在业务代码中增加同步重试逻辑（如最多 3 次）。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(String key, Data newData)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 更新数据库</span></span><br><span class="line">    database.update(key, newData);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 删除缓存，最多重试3次</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">retryCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (retryCount &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cache.delete(key);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            retryCount++;</span><br><span class="line">            <span class="keyword">if</span> (retryCount &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;删除缓存失败，key=&#123;&#125;&quot;</span>, key);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>• <strong>缺点</strong>：同步重试可能阻塞业务线程，影响吞吐量。</p>
<h4 id="异步重试（解耦处理）"><a href="#异步重试（解耦处理）" class="headerlink" title="异步重试（解耦处理）"></a><strong>异步重试（解耦处理）</strong></h4><p>• <strong>场景</strong>：重试操作无需阻塞主流程。<br>• <strong>实现</strong>：将失败操作提交到线程池或消息队列异步处理。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(String key, Data newData)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 更新数据库</span></span><br><span class="line">    database.update(key, newData);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 异步删除缓存</span></span><br><span class="line">    executor.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cache.delete(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;删除缓存失败，key=&#123;&#125;&quot;</span>, key);</span><br><span class="line">            <span class="comment">// 可进一步提交到死信队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>• <strong>优点</strong>：不阻塞主线程，适用于高并发场景。</p>
<hr>
<h3 id="补偿机制：异步队列-定时任务"><a href="#补偿机制：异步队列-定时任务" class="headerlink" title="补偿机制：异步队列 + 定时任务"></a><strong>补偿机制：异步队列 + 定时任务</strong></h3><h4 id="消息队列（最终一致性）"><a href="#消息队列（最终一致性）" class="headerlink" title="消息队列（最终一致性）"></a><strong>消息队列（最终一致性）</strong></h4><p>• <strong>场景</strong>：缓存服务不可用，需保证最终一致性。<br>• <strong>实现</strong>：</p>
<pre><code>1. 删除缓存失败时，将 `key` 写入消息队列（如 Kafka、RocketMQ）。
2. 消费者监听队列，持续重试删除操作。
3. 设置最大重试次数，超过后触发告警。
</code></pre>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除缓存失败后提交到MQ</span></span><br><span class="line">mqProducer.send(<span class="string">&quot;cache-retry-topic&quot;</span>, key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// MQ消费者逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumeCacheRetry</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxRetry</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxRetry; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cache.delete(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            sleep(<span class="number">1000</span> * i); <span class="comment">// 指数退避</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    alert(<span class="string">&quot;缓存删除失败，需人工处理 key=&quot;</span> + key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>• <strong>优点</strong>：解耦业务逻辑，确保最终成功。</p>
<h4 id="定时补偿任务"><a href="#定时补偿任务" class="headerlink" title="定时补偿任务"></a><strong>定时补偿任务</strong></h4><p>• <strong>场景</strong>：消息队列不可用或需兜底。<br>• <strong>实现</strong>：</p>
<pre><code>1. 记录删除失败的 `key` 到数据库或本地文件。
2. 定时任务扫描失败记录，重新发起删除。
</code></pre>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 记录失败操作</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> cache_failures (key, retry_count) <span class="keyword">VALUES</span> (<span class="string">&#x27;key1&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定时任务伪代码</span></span><br><span class="line">List<span class="operator">&lt;</span>CacheFailure<span class="operator">&gt;</span> failures <span class="operator">=</span> queryFailures();</span><br><span class="line"><span class="keyword">for</span> (CacheFailure failure : failures) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        cache.delete(failure.getKey());</span><br><span class="line">        deleteFailureRecord(failure);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        incrementRetryCount(failure);</span><br><span class="line">        if (failure.getRetryCount() <span class="operator">&gt;</span> <span class="number">5</span>) &#123;</span><br><span class="line">            alert(&quot;缓存删除失败，key=&quot; <span class="operator">+</span> failure.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="业务兜底策略"><a href="#业务兜底策略" class="headerlink" title="业务兜底策略"></a><strong>业务兜底策略</strong></h3><h4 id="设置较短缓存过期时间（TTL）"><a href="#设置较短缓存过期时间（TTL）" class="headerlink" title="设置较短缓存过期时间（TTL）"></a><strong>设置较短缓存过期时间（TTL）</strong></h4><p>• <strong>实现</strong>：即使删除失败，旧数据也会在 TTL 后自动失效。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入缓存时设置较短TTL（如30秒）</span></span><br><span class="line">cache.set(key, data, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>• <strong>优点</strong>：简单有效，避免长期不一致。<br>• <strong>缺点</strong>：短期不一致窗口仍存在。</p>
<h4 id="强制读数据库（降级开关）"><a href="#强制读数据库（降级开关）" class="headerlink" title="强制读数据库（降级开关）"></a><strong>强制读数据库（降级开关）</strong></h4><p>• <strong>场景</strong>：缓存删除持续失败，且业务无法容忍不一致。<br>• <strong>实现</strong>：通过配置中心动态开关，绕过缓存直接读数据库。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Data <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (config.isCacheDegraded()) &#123;</span><br><span class="line">        <span class="keyword">return</span> database.read(key); <span class="comment">// 降级读数据库</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="版本号或时间戳校验"><a href="#版本号或时间戳校验" class="headerlink" title="版本号或时间戳校验"></a><strong>版本号或时间戳校验</strong></h4><p>• <strong>实现</strong>：在缓存值和数据库记录中存储版本号，读取时校验。</p>
<pre><code>1. 写数据库时更新版本号。
2. 读缓存时若版本号低于数据库，则忽略缓存。
</code></pre>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Data <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">CachedData</span> <span class="variable">cached</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">    <span class="type">Data</span> <span class="variable">dbData</span> <span class="operator">=</span> database.read(key);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="literal">null</span> &amp;&amp; cached.version == dbData.version) &#123;</span><br><span class="line">        <span class="keyword">return</span> cached.data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dbData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结方案"><a href="#总结方案" class="headerlink" title="总结方案"></a><strong>总结方案</strong></h3><table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>解决方案</strong></th>
<th><strong>适用性</strong></th>
</tr>
</thead>
<tbody><tr>
<td>瞬时故障</td>
<td>同步重试（3次以内）</td>
<td>低并发，容忍短暂阻塞</td>
</tr>
<tr>
<td>缓存服务不稳定</td>
<td>异步队列 + 重试（最终一致性）</td>
<td>高并发，要求最终一致</td>
</tr>
<tr>
<td>长期不可用</td>
<td>降级读数据库 + 告警</td>
<td>高一致性要求场景</td>
</tr>
<tr>
<td>无法接受任何不一致</td>
<td>版本号校验 + 同步双写</td>
<td>金融、交易等强一致性场景</td>
</tr>
</tbody></table>
<hr>
<h3 id="生产建议"><a href="#生产建议" class="headerlink" title="生产建议"></a><strong>生产建议</strong></h3><ol>
<li><strong>监控与告警</strong>：<br>• 监控缓存删除失败率、MQ堆积量、降级开关状态。<br>• 设置阈值告警（如每分钟失败次数 &gt; 100）。  </li>
<li><strong>自动化处理</strong>：<br>• 结合运维工具自动重启缓存节点或切换集群。  </li>
<li><strong>压测与演练</strong>：<br>• 模拟缓存删除失败场景，验证重试和降级逻辑的有效性。</li>
</ol>
<h2 id="缓存更新失败后错数据被访问多次"><a href="#缓存更新失败后错数据被访问多次" class="headerlink" title="缓存更新失败后错数据被访问多次"></a>缓存更新失败后错数据被访问多次</h2><p>在重试过程中，若缓存中的错误数据被多次访问，会导致业务逻辑错误或用户体验受损。以下是分层解决方案，结合 <strong>快速失效、降级兜底、数据校验</strong> 等多种手段，最大限度减少错误数据的影响：</p>
<hr>
<h3 id="快速失效：标记缓存为“待修复”状态"><a href="#快速失效：标记缓存为“待修复”状态" class="headerlink" title="快速失效：标记缓存为“待修复”状态"></a><strong>快速失效：标记缓存为“待修复”状态</strong></h3><h4 id="写入标记-短-TTL"><a href="#写入标记-短-TTL" class="headerlink" title="写入标记 + 短 TTL"></a><strong>写入标记 + 短 TTL</strong></h4><p>• <strong>实现</strong>：在删除缓存失败时，写入一个特殊标记（如 <code>key_pending</code>）并设置短 TTL（如 5 秒），提示后续请求该数据可能不准确。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(String key, Data newData)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 更新数据库</span></span><br><span class="line">    database.update(key, newData);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 尝试删除缓存</span></span><br><span class="line">        cache.delete(key);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 3. 删除失败时，写入待修复标记</span></span><br><span class="line">        cache.set(key + <span class="string">&quot;_pending&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">5</span>); <span class="comment">// 标记存在 5 秒</span></span><br><span class="line">        <span class="comment">// 提交异步重试任务</span></span><br><span class="line">        retryQueue.add(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>• <strong>读取逻辑</strong>：若发现 <code>key_pending</code> 存在，直接读数据库并更新缓存。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Data <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否存在待修复标记</span></span><br><span class="line">    <span class="keyword">if</span> (cache.exists(key + <span class="string">&quot;_pending&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">dbData</span> <span class="operator">=</span> database.read(key);</span><br><span class="line">        cache.set(key, dbData, TTL); <span class="comment">// 主动修复缓存</span></span><br><span class="line">        cache.delete(key + <span class="string">&quot;_pending&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dbData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常缓存逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a><strong>熔断降级</strong></h4><p>• <strong>实现</strong>：监控缓存删除失败率，超过阈值时触发熔断，后续请求直接读数据库。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (failureRate &gt; <span class="number">0.1</span>) &#123; <span class="comment">// 10%失败率触发熔断</span></span><br><span class="line">    degradeCacheRead(); <span class="comment">// 降级为直读数据库</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="主动修复：异步补偿-版本控制"><a href="#主动修复：异步补偿-版本控制" class="headerlink" title="主动修复：异步补偿 + 版本控制"></a><strong>主动修复：异步补偿 + 版本控制</strong></h3><h4 id="版本号校验"><a href="#版本号校验" class="headerlink" title="版本号校验"></a><strong>版本号校验</strong></h4><p>• <strong>实现</strong>：在数据库和缓存中存储数据版本号（如时间戳或递增序号）。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(String key, Data newData)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 更新数据库并递增版本</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">newVersion</span> <span class="operator">=</span> database.updateWithVersion(key, newData);</span><br><span class="line">    <span class="comment">// 2. 删除缓存时携带版本号</span></span><br><span class="line">    cache.delete(key + <span class="string">&quot;:&quot;</span> + newVersion); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Data <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">latestVersion</span> <span class="operator">=</span> database.getVersion(key);</span><br><span class="line">    <span class="type">CachedData</span> <span class="variable">cached</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="literal">null</span> &amp;&amp; cached.version == latestVersion) &#123;</span><br><span class="line">        <span class="keyword">return</span> cached.data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 版本不一致，触发修复</span></span><br><span class="line">    <span class="type">Data</span> <span class="variable">dbData</span> <span class="operator">=</span> database.read(key);</span><br><span class="line">    cache.set(key, dbData, latestVersion, TTL);</span><br><span class="line">    <span class="keyword">return</span> dbData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异步补偿任务"><a href="#异步补偿任务" class="headerlink" title="异步补偿任务"></a><strong>异步补偿任务</strong></h4><p>• <strong>实现</strong>：后台任务定期扫描数据库与缓存的一致性。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkConsistency</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; keys = database.getAllKeys();</span><br><span class="line">    <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">dbVersion</span> <span class="operator">=</span> database.getVersion(key);</span><br><span class="line">        <span class="type">CachedData</span> <span class="variable">cached</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (cached == <span class="literal">null</span> || cached.version &lt; dbVersion) &#123;</span><br><span class="line">            <span class="comment">// 触发缓存修复</span></span><br><span class="line">            <span class="type">Data</span> <span class="variable">dbData</span> <span class="operator">=</span> database.read(key);</span><br><span class="line">            cache.set(key, dbData, dbVersion, TTL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="业务层兜底：读写分离-流量染色"><a href="#业务层兜底：读写分离-流量染色" class="headerlink" title="业务层兜底：读写分离 + 流量染色"></a><strong>业务层兜底：读写分离 + 流量染色</strong></h3><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a><strong>读写分离</strong></h4><p>• <strong>实现</strong>：将修复期间的读请求路由到数据库主库（避免从库延迟）。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Data <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isCacheDegraded()) &#123;</span><br><span class="line">        <span class="comment">// 读主库</span></span><br><span class="line">        <span class="keyword">return</span> masterDatabase.read(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="流量染色"><a href="#流量染色" class="headerlink" title="流量染色"></a><strong>流量染色</strong></h4><p>• <strong>实现</strong>：对部分用户请求添加标记，强制读数据库并对比缓存数据。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Data <span class="title function_">getData</span><span class="params">(String key, <span class="type">boolean</span> forceCheck)</span> &#123;</span><br><span class="line">    <span class="type">Data</span> <span class="variable">cachedData</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (forceCheck) &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">dbData</span> <span class="operator">=</span> database.read(key);</span><br><span class="line">        <span class="keyword">if</span> (!dbData.equals(cachedData)) &#123;</span><br><span class="line">            <span class="comment">// 记录不一致日志并修复</span></span><br><span class="line">            cache.set(key, dbData, TTL);</span><br><span class="line">            <span class="keyword">return</span> dbData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cachedData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结方案-1"><a href="#总结方案-1" class="headerlink" title="总结方案"></a><strong>总结方案</strong></h3><table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>解决方案</strong></th>
<th><strong>适用性</strong></th>
</tr>
</thead>
<tbody><tr>
<td>短暂删除失败（网络抖动）</td>
<td>标记待修复 + 读取时主动修复</td>
<td>高并发，允许短暂不一致</td>
</tr>
<tr>
<td>长期缓存服务不可用</td>
<td>熔断降级 + 直读数据库</td>
<td>强一致性要求场景</td>
</tr>
<tr>
<td>数据版本频繁变更</td>
<td>版本号校验 + 异步补偿任务</td>
<td>金融、订单等关键业务</td>
</tr>
<tr>
<td>灰度验证修复效果</td>
<td>流量染色 + 强制对比</td>
<td>需要验证缓存一致性的场景</td>
</tr>
</tbody></table>
<hr>
<h3 id="生产级最佳实践"><a href="#生产级最佳实践" class="headerlink" title="生产级最佳实践"></a><strong>生产级最佳实践</strong></h3><ol>
<li><strong>监控埋点</strong>：<br>• 监控缓存删除失败率、版本不一致比例、修复任务耗时。<br>• 配置告警（如版本不一致率 &gt; 1% 时触发）。  </li>
<li><strong>自动化修复</strong>：<br>• 结合运维工具自动触发补偿任务，避免人工干预。  </li>
<li><strong>压力测试</strong>：<br>• 模拟缓存删除失败场景，验证修复逻辑的吞吐量和延迟。  </li>
<li><strong>动态配置</strong>：<br>• 通过配置中心动态调整 TTL、重试次数、熔断阈值。  </li>
</ol>
<p>通过以上方案，即使在重试过程中缓存数据暂时错误，也能通过快速失效、主动修复和业务降级，将影响范围控制在最小，最终保障数据一致性。</p>
<h2 id="缓存穿透：布隆过滤器"><a href="#缓存穿透：布隆过滤器" class="headerlink" title="缓存穿透：布隆过滤器"></a>缓存穿透：布隆过滤器</h2><ol>
<li>在ShopService中加入布隆过滤器。<ul>
<li>Service Bean 初始化之后（PostConstruct）进行一次查询，将商铺id放入布隆过滤器</li>
<li>本来商铺的数据是经过预热的，秒杀时商铺可以看做不会增加数据</li>
<li><code>getAvoidPenetrationUsingBloom()</code> 能够先将id加入布隆过滤器中，如果不存在直接返回null。缓存命中真实数据, 直接返回数据</li>
</ul>
</li>
</ol>
<p>作为面试官，针对项目中布隆过滤器（Bloom Filter）防止缓存穿透的实现，我会从以下角度层层递进提问，考察候选人对技术细节、设计权衡和实际问题的理解：</p>
<hr>
<h3 id="基础原理与场景理解"><a href="#基础原理与场景理解" class="headerlink" title="基础原理与场景理解"></a><strong>基础原理与场景理解</strong></h3><ol>
<li><p><strong>缓存穿透是什么？</strong><br>• 预期回答：频繁查询数据库中不存在的数据，绕过缓存直接冲击数据库，导致性能风险。<br>• 延伸问题：如何区分缓存穿透、缓存击穿、缓存雪崩？能否举例说明？</p>
</li>
<li><p><strong>为什么选择布隆过滤器？</strong><br>• 预期回答：空间效率高，可快速判断“数据一定不存在”的场景，避免无效查询。<br>• 延伸问题：布隆过滤器的误判率对业务有何影响？如何量化这种影响？</p>
</li>
</ol>
<hr>
<h3 id="技术实现细节"><a href="#技术实现细节" class="headerlink" title="技术实现细节"></a><strong>技术实现细节</strong></h3><ol start="3">
<li><p><strong>布隆过滤器如何与缓存结合？</strong><br>• 预期回答：查询前先经过布隆过滤器，若返回“不存在”则直接拦截请求；若返回“可能存在”，则查询缓存或数据库。<br>• 延伸问题：如何初始化布隆过滤器？是否需要在系统启动时预热数据？</p>
</li>
<li><p><strong>如何设计布隆过滤器的参数？</strong><br>• 预期回答：根据预期数据量（n）、可接受的误判率（p），计算所需位数组大小（m）和哈希函数数量（k），公式为：<br>  ( $m = -\frac{n \ln p}{(\ln 2)^2}$ ), ( $k = \frac{m}{n} \ln 2$ )。<br>• 延伸问题：如果数据量持续增长，如何动态扩容布隆过滤器？</p>
</li>
</ol>
<hr>
<h3 id="设计权衡与优化"><a href="#设计权衡与优化" class="headerlink" title="设计权衡与优化"></a><strong>设计权衡与优化</strong></h3><ol start="5">
<li><p><strong>布隆过滤器的误判率如何处理？</strong><br>• 预期回答：通过调整参数降低误判率，或在业务层添加兜底机制（如白名单）。<br>• 延伸问题：误判导致合法请求被拦截时，如何监控和修复？是否引入二级缓存？</p>
</li>
<li><p><strong>布隆过滤器不支持删除，如何应对数据删除场景？</strong><br>• 预期回答：使用变种结构如 Counting Bloom Filter 计数，或标记删除延迟更新。<br>• 延伸问题：如果是高频率更新的数据（如电商库存），如何避免频繁重建布隆过滤器？</p>
</li>
</ol>
<hr>
<p><strong>替代方案与对比</strong></p>
<ol start="7">
<li><p><strong>除了布隆过滤器，还有哪些方案可以防止缓存穿透？</strong><br>• 预期回答：缓存空值（Null Object）、互斥锁（Mutex Lock）、异步预热等。<br>• 延伸问题：什么场景下更适合缓存空值而非布隆过滤器？两者的性能差异如何？</p>
</li>
<li><p><strong>布隆过滤器与布谷鸟过滤器（Cuckoo Filter）的优劣对比？</strong><br>• 预期回答：布谷鸟过滤器支持删除、空间效率更高，但实现复杂度更高。<br>• 延伸问题：在内存敏感的场景下，如何选择数据结构？</p>
</li>
</ol>
<hr>
<p><strong>实际应用与故障排查</strong></p>
<ol start="9">
<li><p><strong>项目中布隆过滤器的误判率监控指标是什么？</strong><br>• 预期回答：通过日志或监控系统追踪误判次数与总请求数的比例，调整参数或重建过滤器。<br>• 延伸问题：如何测试布隆过滤器的实际误判率是否符合预期？</p>
</li>
<li><p><strong>是否遇到过布隆过滤器未能解决的极端情况？如何应对？</strong><br>◦ 预期回答：例如恶意攻击构造大量哈希碰撞，需结合限流（Rate Limiting）或IP黑名单。<br>◦ 延伸问题：如果数据库新增了一条本应被布隆过滤器拦截的数据，如何保证一致性？</p>
</li>
</ol>
<hr>
<p><strong>分布式环境挑战</strong></p>
<ol start="11">
<li><p><strong>在分布式系统中，如何维护布隆过滤器的数据一致性？</strong><br>◦ 预期回答：中心化存储（如Redis）或分片同步（需权衡网络开销）。<br>◦ 延伸问题：Redis的布隆过滤器模块（如RedisBloom）是否支持动态扩容？</p>
</li>
<li><p><strong>如何避免布隆过滤器成为单点瓶颈？</strong><br>◦ 预期回答：本地缓存+定期同步，或采用分层过滤（如本地布隆过滤器+全局布隆过滤器）。  </p>
</li>
</ol>
<h3 id="布隆过滤器满了"><a href="#布隆过滤器满了" class="headerlink" title="布隆过滤器满了"></a>布隆过滤器满了</h3><p>布隆过滤器的容量由其位数组大小和哈希函数数量决定。当布隆过滤器“满”（即误判率显著上升）时，可以通过以下方式处理：</p>
<ul>
<li><strong>扩容</strong>：创建一个更大的布隆过滤器，并重新插入所有原始数据（前提是原始数据可访问）。</li>
<li><strong>重建</strong>：若无法扩容且原始数据不可用，只能清空并重新初始化，但会导致历史数据丢失。</li>
<li><strong>分层过滤</strong>：结合多个布隆过滤器（如分片或层级结构），将不同范围的数据分散到不同过滤器中。</li>
</ul>
<h3 id="如何迁移布隆过滤器的数据？"><a href="#如何迁移布隆过滤器的数据？" class="headerlink" title="如何迁移布隆过滤器的数据？"></a><strong>如何迁移布隆过滤器的数据？</strong></h3><p>迁移需要依赖原始数据，步骤如下：</p>
<ol>
<li><strong>创建新过滤器</strong>：构建一个更大的布隆过滤器（更大的位数组和相同/优化的哈希函数）。</li>
<li><strong>重新插入数据</strong>：遍历原始数据集，将每个元素重新哈希并插入新过滤器。</li>
<li><strong>替换旧过滤器</strong>：完成迁移后，用新过滤器替换旧过滤器。</li>
</ol>
<p><strong>注意</strong>：若原始数据不可用，迁移无法完成，需清空或接受更高的误判率。</p>
<h3 id="能否从小布隆过滤器升级到更大的？"><a href="#能否从小布隆过滤器升级到更大的？" class="headerlink" title="能否从小布隆过滤器升级到更大的？"></a><strong>能否从小布隆过滤器升级到更大的？</strong></h3><p><strong>可以</strong>，但必须满足以下条件：</p>
<ul>
<li><strong>哈希函数兼容</strong>：新过滤器的哈希函数需要与旧过滤器兼容（例如，位数组扩容后，哈希值需映射到新数组范围）。</li>
<li><strong>依赖原始数据</strong>：需遍历原始数据重新插入到新过滤器中，否则直接合并位数组可能导致误判率不可控。</li>
</ul>
<h3 id="单体应用中的-BloomFilter-选择建议"><a href="#单体应用中的-BloomFilter-选择建议" class="headerlink" title="单体应用中的 BloomFilter 选择建议"></a><strong>单体应用中的 BloomFilter 选择建议</strong></h3><p>在单体应用中，若需使用布隆过滤器，<strong>Guava BloomFilter 是推荐选择</strong>，原因如下：</p>
<ul>
<li><strong>轻量易用</strong>：无需依赖外部服务（如 Redis），适合单体架构。</li>
<li><strong>高性能</strong>：基于内存的位操作，判断时间复杂度为 O(k)（k 为哈希函数数量）。</li>
<li><strong>灵活配置</strong>：通过 <code>expectedInsertions</code> 和 <code>fpp</code> 平衡内存与误判率。</li>
</ul>
<p>**<mark>静态数据集<mark>**（如预加载的ID列表）：</p>
<ul>
<li>初始化时指定 <code>expectedInsertions</code> 为数据集大小，<code>fpp</code> 根据业务容忍度设置（如 1%）。</li>
</ul>
<p>**<mark>动态数据集<mark>**（如实时去重）：</p>
<ul>
<li>监控填充率：通过 <code>expectedInsertions</code> 和 <code>actualInsertions</code> 估算填充率（例如 <code>filter.approximateElementCount()</code>）。</li>
<li><strong>提前预防写满</strong>：当实际插入量接近 <code>expectedInsertions</code> 时，创建更大的新过滤器并迁移数据。</li>
<li><strong>兜底方案</strong>：若数据不可回溯，可接受更高的误判率，或周期性重置过滤器（牺牲部分业务逻辑准确性）。</li>
</ul>
<p>**<mark>资源受限环境<mark>**：</p>
<ul>
<li>降低 <code>fpp</code> 要求：适当提高误判率以减少内存占用。</li>
<li>使用 <code>策略模式</code> 结合多级过滤：例如先用 <code>HashSet</code> 过滤高频元素，再用 <code>BloomFilter</code> 处理长尾数据。</li>
</ul>
<h2 id="RedisBloom"><a href="#RedisBloom" class="headerlink" title="RedisBloom"></a>RedisBloom</h2><h3 id="RedisBloom-的特色功能详解"><a href="#RedisBloom-的特色功能详解" class="headerlink" title="RedisBloom 的特色功能详解"></a>RedisBloom 的特色功能详解</h3><p>RedisBloom 是 Redis 的一个扩展模块，提供了一系列概率数据结构（Probabilistic Data Structures），在分布式场景下表现出色。以下是其核心特色功能及优势：</p>
<hr>
<h4 id="支持多种概率数据结构"><a href="#支持多种概率数据结构" class="headerlink" title="支持多种概率数据结构"></a><strong>支持多种概率数据结构</strong></h4><p>RedisBloom 不仅包含标准布隆过滤器，还提供以下高级数据结构：<br>• <strong>布隆过滤器（Bloom Filter, BF）</strong>：<br>  支持快速判断元素是否存在，适用于去重、缓存穿透防护等场景。<br>• <strong>计数布隆过滤器（Counting Bloom Filter, CBF）</strong>：<br>  允许删除元素（通过计数器增减），解决了传统布隆过滤器无法删除的问题。<br>• <strong>Cuckoo 过滤器（Cuckoo Filter, CF）</strong>：<br>  相比布隆过滤器，支持删除操作且空间效率更高，误判率更低。<br>• <strong>Top-K 计数器（Top-K）</strong>：<br>  统计高频元素（如热点关键词），支持动态更新和查询 Top N 结果。<br>• <strong>Count-Min Sketch（CMS）</strong>：<br>  估算数据流的频率分布（如统计用户行为次数），适用于大数据量下的近似统计。</p>
<p><strong>示例命令</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 布隆过滤器：添加元素并检查存在性</span></span><br><span class="line">BF.ADD myfilter <span class="string">&quot;item1&quot;</span></span><br><span class="line">BF.EXISTS myfilter <span class="string">&quot;item1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cuckoo 过滤器：添加并删除元素</span></span><br><span class="line">CF.ADDNX mycuckoo <span class="string">&quot;item2&quot;</span></span><br><span class="line">CF.DEL mycuckoo <span class="string">&quot;item2&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="动态扩容与自动缩放"><a href="#动态扩容与自动缩放" class="headerlink" title="动态扩容与自动缩放"></a><strong>动态扩容与自动缩放</strong></h4><p>• <strong>自动扩容能力</strong>：<br>  RedisBloom 的布隆过滤器在初始化时可设置 <code>CAPACITY</code> 和 <code>ERROR RATE</code>，当插入元素数量接近容量上限时，<strong>自动创建子过滤器并分摊哈希计算</strong>，无需手动重建。<br>• <strong>弹性扩展</strong>：<br>  通过 <code>BF.RESERVE</code> 命令可动态调整容量和误判率，适应数据量增长。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化一个支持自动扩容的布隆过滤器</span></span><br><span class="line">BF.RESERVE myautofilter 0.01 1000 AUTOEXPAND 1</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="分布式与高可用支持"><a href="#分布式与高可用支持" class="headerlink" title="分布式与高可用支持"></a><strong>分布式与高可用支持</strong></h4><p>• <strong>天然分布式</strong>：<br>  作为 Redis 模块，支持 Redis 集群模式，数据分片存储在多个节点，适合大规模分布式系统。<br>• <strong>持久化与灾备</strong>：<br>  利用 Redis 的 RDB/AOF 持久化机制，数据可持久保存；通过主从复制、哨兵模式或 Redis Cluster 实现高可用。</p>
<hr>
<h4 id="高性能与低延迟"><a href="#高性能与低延迟" class="headerlink" title="高性能与低延迟"></a><strong>高性能与低延迟</strong></h4><p>• <strong>内存优化</strong>：<br>  位数组和哈希算法针对内存效率优化，例如 Cuckoo 过滤器比传统布隆过滤器节省 20%~30% 空间。<br>• <strong>批量操作</strong>：<br>  支持批量添加（<code>BF.MADD</code>）和批量检查（<code>BF.MEXISTS</code>），减少网络开销。</p>
<p><strong>性能对比</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>单次请求耗时</th>
<th>批量（1000元素）耗时</th>
</tr>
</thead>
<tbody><tr>
<td><code>BF.ADD</code></td>
<td>0.1ms</td>
<td>10ms</td>
</tr>
<tr>
<td><code>BF.MADD</code></td>
<td>-</td>
<td>2ms</td>
</tr>
</tbody></table>
<hr>
<h4 id="灵活的配置与管理"><a href="#灵活的配置与管理" class="headerlink" title="灵活的配置与管理"></a><strong>灵活的配置与管理</strong></h4><p>• <strong>自定义参数</strong>：<br>  初始化时可指定容量（<code>CAPACITY</code>）、误判率（<code>ERROR RATE</code>）、扩容策略（<code>AUTOEXPAND</code>）等。<br>• <strong>过期时间（TTL）</strong>：<br>  结合 Redis 的 <code>EXPIRE</code> 命令，可为过滤器设置自动过期清理。<br>• <strong>信息监控</strong>：<br>  通过 <code>BF.INFO</code> 命令查看过滤器状态（如元素数量、内存占用）。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建过滤器并设置过期时间</span></span><br><span class="line">BF.RESERVE myfilter 0.01 10000</span><br><span class="line">EXPIRE myfilter 3600  <span class="comment"># 1小时后自动删除</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="与-Redis-生态无缝集成"><a href="#与-Redis-生态无缝集成" class="headerlink" title="与 Redis 生态无缝集成"></a><strong>与 Redis 生态无缝集成</strong></h4><p>• <strong>Lua 脚本支持</strong>：<br>  可在脚本中直接调用 RedisBloom 命令，实现复杂逻辑（如原子性操作）。<br>• <strong>事务与管道</strong>：<br>  结合 Redis 事务（<code>MULTI/EXEC</code>）和管道（Pipeline），提升批量操作效率。<br>• <strong>发布订阅（Pub/Sub）</strong>：<br>  监听过滤器状态变化（如容量告警），触发业务逻辑。</p>
<hr>
<h3 id="适用场景对比"><a href="#适用场景对比" class="headerlink" title="适用场景对比"></a><strong>适用场景对比</strong></h3><table>
<thead>
<tr>
<th>场景</th>
<th>Guava BloomFilter</th>
<th>RedisBloom</th>
</tr>
</thead>
<tbody><tr>
<td><strong>单机应用</strong></td>
<td>✅ 轻量、高性能</td>
<td>❌ 需 Redis 依赖</td>
</tr>
<tr>
<td><strong>分布式系统</strong></td>
<td>❌ 无法跨节点共享</td>
<td>✅ 天然支持</td>
</tr>
<tr>
<td><strong>动态扩容需求</strong></td>
<td>❌ 需手动重建</td>
<td>✅ 自动扩展</td>
</tr>
<tr>
<td><strong>数据持久化</strong></td>
<td>❌ 内存数据易丢失</td>
<td>✅ RDB/AOF 持久化</td>
</tr>
<tr>
<td><strong>高频删除操作</strong></td>
<td>❌ 不支持</td>
<td>✅ Cuckoo/Counting BF</td>
</tr>
</tbody></table>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>RedisBloom 的核心优势在于：</p>
<ol>
<li><strong>多数据结构支持</strong>：覆盖从存在性判断（布隆/Cuckoo 过滤器）到频率统计（Top-K/CMS）的多样化场景。</li>
<li><strong>分布式能力</strong>：无缝集成 Redis 集群和高可用架构，适合微服务和大规模系统。</li>
<li><strong>自动化运维</strong>：动态扩容、持久化、监控告警等特性降低运维成本。</li>
<li><strong>高性能与弹性</strong>：内存优化和批量操作保障低延迟，适应高并发需求。</li>
</ol>
<p>对于需要扩展性、持久化或分布式协作的场景，RedisBloom 是比 Guava BloomFilter 更强大的选择。</p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><h3 id="简述你的登录逻辑（token-双拦截器）"><a href="#简述你的登录逻辑（token-双拦截器）" class="headerlink" title="简述你的登录逻辑（token 双拦截器）"></a>简述你的登录逻辑（token 双拦截器）</h3><p>短信登录的短信怎么发送的?</p>
<ul>
<li>使用hutool生成的随机六位数验证码</li>
</ul>
<p>如何标识用户</p>
<ul>
<li>（手机号）</li>
</ul>
<p>项目的权限刷新什么意思</p>
<ul>
<li>（登录时判断是否注册）</li>
</ul>
<p>在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，比如主页之类的那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的。</p>
<p>只有访问拦截的网页才会刷redis，这样就导致如果用户访问的是其他网页，不会出发拦截器，过期token就会失效</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653320822964.png" alt="初始方案思路总结"></p>
<p>既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653320764547.png" alt="优化拦截器"></p>
<h3 id="为什么要用thread-local"><a href="#为什么要用thread-local" class="headerlink" title="为什么要用thread local"></a>为什么要用thread local</h3><p>thread local底层你懂吗？会出现什么问题？内存泄漏知道吗？怎么解决的</p>
<p>内存泄露</p>
<p><code>ThreadLocal&lt;T&gt;</code> 主要用于以下场景：</p>
<ol>
<li><strong>线程安全的变量管理：</strong> 比如事务管理、用户会话等。</li>
<li><strong>避免同步锁：</strong> 替代传统的锁机制，提高并发性能。</li>
<li><strong>数据库连接或会话缓存：</strong> 每个线程维护自己的数据库连接实例。避免显式传递参数。</li>
</ol>
<p>T 用于表示 ThreadLocal 存的值类型 线程对象的ThreadLocalMap </p>
<h4 id="ThreadLocal-的核心用法"><a href="#ThreadLocal-的核心用法" class="headerlink" title="ThreadLocal 的核心用法"></a><strong>ThreadLocal 的核心用法</strong></h4><ol>
<li><p><strong>创建 ThreadLocal 实例</strong><br>通常声明为 <code>static final</code>，避免重复创建。可以通过 <code>withInitial</code> 或重写 <code>initialValue</code> 设置默认值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 8+ 推荐方式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="string">&quot;default&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统方式（重写 initialValue）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>设置和获取值</strong><br>使用 <code>set()</code> 和 <code>get()</code> 方法操作当前线程的副本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.set(<span class="string">&quot;value&quot;</span>); <span class="comment">// 设置当前线程的值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get(); <span class="comment">// 获取当前线程的值</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>清理资源</strong><br>务必在 <code>finally</code> 块中调用 <code>remove()</code>，防止内存泄漏：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="comment">// ... 业务逻辑 ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.remove(); <span class="comment">// 清理当前线程的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><ul>
<li>ThreadLocalMap 的键是弱引用（ThreadLocal 实例），但值是强引用。若 ThreadLocal 被回收，但线程未销毁（如线程池复用），值对象可能无法回收。</li>
<li>线程复用可能导致残留旧值，需确保每次任务结束后清理 ThreadLocal。</li>
<li><strong>解决</strong>：始终在 <code>finally</code> 块中调用 <code>remove()</code>。</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li>默认情况下，子线程无法继承父线程的 ThreadLocal 值。若需要继承，使用 <code>InheritableThreadLocal</code>。</li>
<li><strong>局限性</strong>：线程池场景中，子线程可能复用旧线程，导致继承的值并非最新。</li>
</ul>
<h2 id="异步秒杀"><a href="#异步秒杀" class="headerlink" title="异步秒杀"></a>异步秒杀</h2><p>项目为什么要加个消息队列?</p>
<ul>
<li>redis效率比较高，而数据库效率不如redis快，tomcat中的程序，会进行串行操作，分成如下几步：查询优惠卷、<mark>判断秒杀库存是否足够<mark>、查询订单、<mark>校验是否是一人一单<mark>、扣减库存、创建订单。在这六步操作中，又有很多操作是要去操作数据库的，而且还是一个线程串行执行， 这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行。</li>
<li>将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息</li>
<li>为什么不使用线程池或者异步编排。如果访问的人很多，那么线程池中的线程可能一下子就被消耗完了，而且你使用上述方案，最大的特点在于，你觉得时效性会非常重要，但是你想想是吗？并不是，比如我只要确定他能做这件事，然后我后边慢慢做就可以了，我并不需要他一口气做完这件事，所以我们应当采用的是课程中，类似消息队列的方式来完成我们的需求，而不是使用线程池或者是异步编排的方式来完成这个需求。</li>
</ul>
<p>在用户异步下单时，后端会接收到/voucher-order/seckill/{} 的请求，此时VoucherOrderController会调用<code>seckillVoucher</code>方法。执行lua脚本，判断用户的购买资格，有购买资格的话，生成orderId，并将用户id和优惠券id一起存入订单消息中，然后将订单消息存入RabbitMQ消息队列，等待<strong>消费者异步消费</strong>。</p>
<p>订单接口的幂等性是怎么做的？</p>
<ul>
<li>（意思就是post请求带着：一个用户id，一个优惠卷id。发送多次请求，如何保证只有一个成功，也就是一人一单）</li>
</ul>
<p>库存扣减之后，还要去insert一个新的订单，你是如何保存这个的一致性的？</p>
<ul>
<li>使用spring自带的事务，将其放到一个事务里</li>
</ul>
<p>抢优惠券没有及时处理怎么办?</p>
<ul>
<li>（通知用户已经抢了，延迟推送结果）</li>
</ul>
<p>抢优惠券处理完了如何通知用户？</p>
<ul>
<li>（没有通知）</li>
</ul>
<p>秒杀场景下扣减库存太慢了怎么办？</p>
<ul>
<li>（数据库集群，分库分表，索引优化，Redis热key，大key，Redis缓存过小）</li>
</ul>
<h2 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h2><hr>
<h3 id="针对单体架构高并发下请求堆积问题的分层解决方案"><a href="#针对单体架构高并发下请求堆积问题的分层解决方案" class="headerlink" title="针对单体架构高并发下请求堆积问题的分层解决方案"></a>针对单体架构高并发下请求堆积问题的分层解决方案</h3><hr>
<h4 id="紧急止血：快速缓解当前压力"><a href="#紧急止血：快速缓解当前压力" class="headerlink" title="紧急止血：快速缓解当前压力"></a><strong>紧急止血：快速缓解当前压力</strong></h4><ol>
<li><p><strong>限流降级</strong><br>• <strong>限流策略</strong>：<br>  ◦ 使用令牌桶或漏桶算法限制接口请求速率（如 Guava RateLimiter 或 Sentinel）。<br>  ◦ 针对非核心功能直接降级（返回静态页或简化逻辑）。<br>• <strong>代码示例</strong>：  </p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Sentinel 限流</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;coreApi&quot;, blockHandler = &quot;handleBlock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">coreApi</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handleBlock</span><span class="params">(BlockException ex)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;系统繁忙，请稍后重试！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>异步化处理</strong><br>• <strong>消息队列缓冲</strong>：<br>  ◦ 将非实时请求写入消息队列（如 RabbitMQ/Kafka），异步消费。<br>  ◦ 示例：订单支付后的通知、日志记录等操作异步化。<br>• <strong>代码示例</strong>：  </p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订单支付主逻辑同步处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">payOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 核心支付逻辑</span></span><br><span class="line">    processPayment(order);</span><br><span class="line">    <span class="comment">// 2. 通知类操作异步化</span></span><br><span class="line">    mq.send(<span class="string">&quot;payment_success_queue&quot;</span>, order.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>扩容与负载均衡</strong><br>• <strong>垂直扩容</strong>：临时升级服务器配置（CPU、内存）。<br>• <strong>水平扩容</strong>：<br>  ◦ 通过 Nginx 负载均衡部署多个单体实例。<br>  ◦ 使用云服务自动扩展组（如 AWS Auto Scaling）。  </p>
</li>
</ol>
<hr>
<h4 id="性能优化：提升单机处理能力"><a href="#性能优化：提升单机处理能力" class="headerlink" title="性能优化：提升单机处理能力"></a><strong>性能优化：提升单机处理能力</strong></h4><ol>
<li><p><strong>代码层优化</strong><br>• <strong>减少锁竞争</strong>：<br>  ◦ 使用无锁数据结构（如 ConcurrentHashMap）。<br>  ◦ 缩小同步代码块范围，避免全局锁。<br>• <strong>优化算法复杂度</strong>：<br>  ◦ 将 O(n²) 逻辑优化为 O(n) 或 O(log n)。<br>• <strong>示例</strong>：  </p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前：双重循环匹配</span></span><br><span class="line"><span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Order order : orders) &#123;</span><br><span class="line">        <span class="keyword">if</span> (user.getId().equals(order.getUserId())) &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化后：使用 Map 降低复杂度</span></span><br><span class="line">Map&lt;Long, User&gt; userMap = users.stream().collect(Collectors.toMap(User::getId, u -&gt; u));</span><br><span class="line"><span class="keyword">for</span> (Order order : orders) &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMap.get(order.getUserId());</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>数据库优化</strong><br>• <strong>索引优化</strong>：<br>  ◦ 通过 EXPLAIN 分析慢查询，添加缺失索引。<br>  ◦ 避免全表扫描，限制查询范围（如时间区间分页）。<br>• <strong>批量操作</strong>：<br>  ◦ 合并多次 INSERT/UPDATE 为批量操作。  </p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 批量插入优化</span></span><br><span class="line">jdbcTemplate.batchUpdate(<span class="string">&quot;INSERT INTO log (content) VALUES (?)&quot;</span>, logs, <span class="number">100</span>, (ps, log) -&gt; &#123;</span><br><span class="line">    ps.setString(<span class="number">1</span>, log.getContent());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>缓存加速</strong><br>• <strong>本地缓存</strong>：<br>  ◦ 使用 Caffeine 缓存热点数据（如配置表、频繁查询的用户信息）。<br>  ◦ 示例：缓存用户基本信息，TTL 设置为 5 分钟。<br>• <strong>分布式缓存</strong>：<br>  ◦ Redis 缓存复杂查询结果（如商品详情页）。  </p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Product <span class="title function_">getProduct</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;product:&quot;</span> + id;</span><br><span class="line">    <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (product == <span class="literal">null</span>) &#123;</span><br><span class="line">        product = database.queryProduct(id);</span><br><span class="line">        redis.setex(key, <span class="number">3600</span>, product); <span class="comment">// 缓存1小时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="架构改造：逐步拆分与异步解耦"><a href="#架构改造：逐步拆分与异步解耦" class="headerlink" title="架构改造：逐步拆分与异步解耦"></a><strong>架构改造：逐步拆分与异步解耦</strong></h4><ol>
<li><p><strong>关键模块拆分</strong><br>• <strong>第一步：拆分高负载模块</strong><br>  ◦ 将消息处理、文件上传等资源密集型模块独立为微服务。<br>  ◦ 示例：将消息消费者拆分为独立服务，单独扩展。<br>• <strong>技术栈</strong>：<br>  ◦ 使用 Spring Cloud 或 Dubbo 实现服务化。  </p>
</li>
<li><p><strong>数据库拆分</strong><br>• <strong>读写分离</strong>：<br>  ◦ 主库处理写操作，从库处理读操作（通过 ShardingSphere 或 MyCAT）。<br>• <strong>分库分表</strong>：<br>  ◦ 按用户ID哈希分表，分散单表压力。  </p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按 user_id 分表（user_table_0, user_table_1）</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> user_table_0 (id <span class="type">BIGINT</span>, user_id <span class="type">BIGINT</span>, ...) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> HASH(user_id <span class="operator">%</span> <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>消息队列解耦</strong><br>• <strong>削峰填谷</strong>：<br>  ◦ 使用 Kafka 承接突发流量，消费者按能力处理。<br>  ◦ 示例：秒杀请求先写入 Kafka，异步处理订单。<br>• <strong>代码示例</strong>：  </p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者快速响应</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleSeckillRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    kafka.send(<span class="string">&quot;seckill_requests&quot;</span>, request);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;请求已受理，请等待结果！&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者批量处理</span></span><br><span class="line"><span class="meta">@KafkaListener(topics = &quot;seckill_requests&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processSeckill</span><span class="params">(List&lt;Request&gt; requests)</span> &#123;</span><br><span class="line">    batchProcessOrders(requests);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="长期运维：监控与自动化"><a href="#长期运维：监控与自动化" class="headerlink" title="长期运维：监控与自动化"></a><strong>长期运维：监控与自动化</strong></h4><ol>
<li><p><strong>全链路监控</strong><br>• <strong>指标采集</strong>：<br>  ◦ 使用 Prometheus + Grafana 监控 CPU、内存、线程池、数据库连接池。<br>• <strong>日志追踪</strong>：<br>  ◦ 通过 ELK（Elasticsearch + Logstash + Kibana）定位慢请求。  </p>
</li>
<li><p><strong>自动化弹性伸缩</strong><br>• <strong>Kubernetes 部署</strong>：<br>  ◦ 根据 CPU 使用率自动扩展 Pod 实例。<br>• <strong>云服务集成</strong>：<br>  ◦ AWS Lambda 处理突发流量（Serverless 无服务器架构）。  </p>
</li>
<li><p><strong>容灾与备份</strong><br>• <strong>多可用区部署</strong>：<br>  ◦ 在云环境中跨可用区（AZ）部署实例，避免单点故障。<br>• <strong>定期备份</strong>：<br>  ◦ 使用 XtraBackup 或 AWS RDS 快照备份数据库。  </p>
</li>
</ol>
<hr>
<h3 id="方案对比与选型建议"><a href="#方案对比与选型建议" class="headerlink" title="方案对比与选型建议"></a><strong>方案对比与选型建议</strong></h3><table>
<thead>
<tr>
<th><strong>方案</strong></th>
<th><strong>实施难度</strong></th>
<th><strong>见效速度</strong></th>
<th><strong>适用阶段</strong></th>
<th><strong>成本</strong></th>
</tr>
</thead>
<tbody><tr>
<td>限流降级</td>
<td>低</td>
<td>立即</td>
<td>紧急处理</td>
<td>低</td>
</tr>
<tr>
<td>代码优化</td>
<td>中</td>
<td>1-3天</td>
<td>短期优化</td>
<td>低</td>
</tr>
<tr>
<td>数据库读写分离</td>
<td>高</td>
<td>1周</td>
<td>中期架构调整</td>
<td>中</td>
</tr>
<tr>
<td>微服务拆分</td>
<td>高</td>
<td>1-3个月</td>
<td>长期重构</td>
<td>高</td>
</tr>
<tr>
<td>消息队列削峰</td>
<td>中</td>
<td>3-7天</td>
<td>中期解耦</td>
<td>中</td>
</tr>
</tbody></table>
<hr>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h3><ol>
<li><strong>短期优先</strong>：限流 + 异步化 + 扩容，快速释放系统压力。  </li>
<li><strong>中期优化</strong>：代码性能优化 + 数据库调优 + 缓存加速。  </li>
<li><strong>长期重构</strong>：分步骤拆解单体为微服务，引入弹性伸缩与自动化运维。  </li>
</ol>
<p>通过分层策略逐步推进，在保障系统稳定的前提下，最终实现高并发场景下的可持续扩展能力。</p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁在数据库层面的实现确实存在并发冲突的问题，但通过合理的设计和优化策略，可以在高并发场景下保持较好的性能。以下从技术实现、优化策略和场景适配三个维度详细说明：</p>
<hr>
<h3 id="乐观锁的核心原理"><a href="#乐观锁的核心原理" class="headerlink" title="乐观锁的核心原理"></a>乐观锁的核心原理</h3><p><strong>实现方式</strong>：通过版本号（Version）或时间戳（Timestamp）机制实现。更新时检查当前版本是否匹配，若匹配则更新成功并递增版本号，否则拒绝操作。</p>
<p><strong>SQL示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> </span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> new_value, version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> #&#123;id&#125; <span class="keyword">AND</span> version <span class="operator">=</span> #&#123;old_version&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>关键特点</strong>：无锁检测，仅在提交时判断版本，适合读多写少场景。</p>
<hr>
<h3 id="高并发下的冲突瓶颈"><a href="#高并发下的冲突瓶颈" class="headerlink" title="高并发下的冲突瓶颈"></a>高并发下的冲突瓶颈</h3><ol>
<li><p><strong>冲突率高时的表现</strong>：<br>• 大量事务因版本不匹配而失败，需重试或回滚。<br>• 频繁的磁盘I/O和锁竞争导致吞吐量下降。</p>
</li>
<li><p><strong>数据库行锁的影响</strong>：<br>• 即使使用乐观锁，MySQL等数据库在执行UPDATE时仍会对行加排他锁，直到事务提交。<br>• 长事务会加剧锁竞争，需缩短事务时间。</p>
</li>
</ol>
<hr>
<h3 id="优化策略与实践方案"><a href="#优化策略与实践方案" class="headerlink" title="优化策略与实践方案"></a>优化策略与实践方案</h3><h4 id="精细化锁粒度"><a href="#精细化锁粒度" class="headerlink" title="精细化锁粒度"></a><strong>精细化锁粒度</strong></h4><p>   • <strong>字段拆分</strong>：对高频更新字段独立维护版本号，减少无关字段的冲突。<br>     <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> user_points </span><br><span class="line"><span class="keyword">SET</span> points <span class="operator">=</span> points <span class="operator">+</span> <span class="number">100</span>, point_version <span class="operator">=</span> point_version <span class="operator">+</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">123</span> <span class="keyword">AND</span> point_version <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><br>   • <strong>分桶计数</strong>：将计数器拆分为多个桶（如100个），随机选择桶更新，查询时求和。<br>     <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> counters </span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">value</span> <span class="operator">=</span> <span class="keyword">value</span> <span class="operator">+</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">WHERE</span> bucket_id <span class="operator">=</span> <span class="built_in">FLOOR</span>(RAND() <span class="operator">*</span> <span class="number">100</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="无锁化设计"><a href="#无锁化设计" class="headerlink" title="无锁化设计"></a><strong>无锁化设计</strong></h4><p>   • <strong>原子操作</strong>：利用数据库内置原子能力，避免CAS检查。<br>     <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 直接增减，无需版本号</span></span><br><span class="line"><span class="keyword">UPDATE</span> products <span class="keyword">SET</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><br>   • <strong>状态机约束</strong>：通过WHERE子句添加业务条件，确保状态合法。<br>     <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> orders </span><br><span class="line"><span class="keyword">SET</span> status <span class="operator">=</span> <span class="string">&#x27;paid&#x27;</span> </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">456</span> <span class="keyword">AND</span> status <span class="operator">=</span> <span class="string">&#x27;unpaid&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="异步合并与缓冲"><a href="#异步合并与缓冲" class="headerlink" title="异步合并与缓冲"></a><strong>异步合并与缓冲</strong></h4><p>   • <strong>本地队列</strong>：在应用层合并短时间内相同资源的写操作，批量提交。<br>   • <strong>Redis中间层</strong>：在缓存层预扣库存，通过定时任务同步至数据库。<br>     <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Redis Lua脚本实现原子扣减</span></span><br><span class="line"><span class="keyword">local</span> stock = redis.call(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;product:100:stock&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> stock &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;DECR&#x27;</span>, <span class="string">&#x27;product:100:stock&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<h4 id="冲突处理与重试"><a href="#冲突处理与重试" class="headerlink" title="冲突处理与重试"></a><strong>冲突处理与重试</strong></h4><p>   • <strong>指数退避重试</strong>：在应用层实现自动重试逻辑，避免无限循环。<br>     <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update_with_retry</span>(<span class="params">max_retries=<span class="number">3</span></span>):</span><br><span class="line">    retries = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> retries &lt; max_retries:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 执行乐观锁更新</span></span><br><span class="line">            <span class="keyword">return</span> success</span><br><span class="line">        <span class="keyword">except</span> VersionConflict:</span><br><span class="line">            sleep(<span class="number">2</span> ** retries)</span><br><span class="line">            retries += <span class="number">1</span></span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;Max retries exceeded&quot;</span>)</span><br></pre></td></tr></table></figure><br>   • <strong>熔断降级</strong>：当冲突超过阈值时，暂时禁用写操作，返回兜底结果。</p>
<h4 id="数据库调优"><a href="#数据库调优" class="headerlink" title="数据库调优"></a><strong>数据库调优</strong></h4><p>   • <strong>短事务原则</strong>：确保事务尽量简短，及时提交释放行锁。<br>   • <strong>读写分离</strong>：将读请求分流到只读副本，减轻主库压力。<br>   • <strong>索引优化</strong>：避免全表扫描导致锁升级为表锁（如MySQL的InnoDB行锁特性）。</p>
<hr>
<h3 id="场景适配与方案选型"><a href="#场景适配与方案选型" class="headerlink" title="场景适配与方案选型"></a>场景适配与方案选型</h3><ol>
<li><p><strong>秒杀场景</strong>：<br>• <strong>预扣库存</strong>：Redis集群+异步落库。<br>• <strong>限流削峰</strong>：令牌桶算法控制请求速率。</p>
</li>
<li><p><strong>账户余额更新</strong>：<br>• <strong>事务拆分</strong>：余额变更与流水记录分离，流水表使用异步插入。</p>
</li>
<li><p><strong>评论点赞计数</strong>：<br>• <strong>内存累加</strong>：应用层缓存计数，定时批量写入。</p>
</li>
</ol>
<hr>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>乐观锁的并发瓶颈并非无解，关键在于结合业务特点选择优化方向：<br>• <strong>减少冲突</strong>：通过拆分资源、无锁化操作降低竞争。<br>• <strong>提升吞吐</strong>：利用异步化、批量处理减少I/O开销。<br>• <strong>柔性设计</strong>：在强一致性和最终一致性之间寻找平衡点。</p>
<p>最终方案需权衡开发成本、数据一致性和性能要求，例如金融交易需强一致，而社交 feed 可接受短暂延迟。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>使用 唯一标识 + 分布式锁 + 数据库唯一约束 保证订单提交的幂等性，做到一人一单、防止超卖，</p>
<p>是的，**<code>@RabbitListener</code> 监听消息的同步处理逻辑可以结合 <code>CompletableFuture</code> 实现异步操作**，尤其适用于需要异步执行耗时任务（如数据库操作、外部接口调用等）的场景。以下是具体实现方案及注意事项：</p>
<h3 id="基础实现思路"><a href="#基础实现思路" class="headerlink" title="基础实现思路"></a><strong>基础实现思路</strong></h3><p>• <strong>核心目标</strong>：在 <code>@RabbitListener</code> 方法内启动异步任务，避免阻塞 RabbitMQ 的监听线程。<br>• <strong>消息确认策略</strong>：需结合手动 ACK 模式，确保异步任务完成后才确认消息，避免消息丢失。</p>
<hr>
<h3 id="实现代码示例"><a href="#实现代码示例" class="headerlink" title="实现代码示例"></a><strong>实现代码示例</strong></h3><h4 id="配置手动-ACK-模式"><a href="#配置手动-ACK-模式" class="headerlink" title="配置手动 ACK 模式"></a><strong>配置手动 ACK 模式</strong></h4><p>在 <code>application.yml</code> 中启用手动确认：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span> <span class="comment"># 手动ACK</span></span><br></pre></td></tr></table></figure>

<h4 id="异步处理消息"><a href="#异步处理消息" class="headerlink" title="异步处理消息"></a><strong>异步处理消息</strong></h4><p>在 <code>@RabbitListener</code> 方法中使用 <code>CompletableFuture</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;order.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message message, Channel channel, <span class="meta">@Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="type">long</span> tag)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msgBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动异步任务</span></span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 异步扣减逻辑（如库存、积分）</span></span><br><span class="line">            deductService.asyncDeduct(msgBody);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 任务成功：手动ACK</span></span><br><span class="line">            channel.basicAck(tag, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 任务失败：NACK并重新入队（根据业务决定是否重试）</span></span><br><span class="line">            channel.basicNack(tag, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, asyncExecutor); <span class="comment">// 指定自定义线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置异步线程池"><a href="#配置异步线程池" class="headerlink" title="配置异步线程池"></a><strong>配置异步线程池</strong></h4><p>避免占用默认线程池资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;asyncExecutor&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Executor <span class="title function_">asyncExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">        <span class="number">5</span>, <span class="number">10</span>, <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="关键注意事项"><a href="#关键注意事项" class="headerlink" title="关键注意事项"></a><strong>关键注意事项</strong></h3><h4 id="消息确认与可靠性"><a href="#消息确认与可靠性" class="headerlink" title="消息确认与可靠性"></a><strong>消息确认与可靠性</strong></h4><p>• <strong>ACK/NACK 必须在异步线程中执行</strong>：RabbitMQ 的 <code>Channel</code> 对象非线程安全，需确保在异步任务内调用 <code>basicAck</code>/<code>basicNack</code>。<br>• <strong>防止消息丢失</strong>：异步任务异常时，通过 <code>basicNack</code> 的 <code>requeue</code> 参数控制消息重试（需业务逻辑幂等）。</p>
<h4 id="线程池管理"><a href="#线程池管理" class="headerlink" title="线程池管理"></a><strong>线程池管理</strong></h4><p>• <strong>拒绝策略</strong>：当线程池满载时，使用 <code>CallerRunsPolicy</code> 让主线程执行任务，避免消息堆积。<br>• <strong>资源隔离</strong>：为不同业务分配独立线程池，避免互相影响。</p>
<h4 id="业务幂等性"><a href="#业务幂等性" class="headerlink" title="业务幂等性"></a><strong>业务幂等性</strong></h4><p>• <strong>防重复处理</strong>：消息可能因重试被多次消费，需通过唯一ID+状态机/数据库锁保证扣减操作幂等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：通过唯一ID保证幂等</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncDeduct</span><span class="params">(String orderId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (deductLock.tryLock(orderId)) &#123; <span class="comment">// 自定义分布式锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行扣减</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            deductLock.unlock(orderId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a><strong>性能优化建议</strong></h3><p>• <strong>批量消费</strong>：结合 <code>@RabbitListener</code> 的 <code>containerFactory</code> 配置批量消费，提升吞吐量。<br>• <strong>异步任务拆分</strong>：若扣减逻辑涉及多个步骤，可进一步用 <code>CompletableFuture</code> 编排子任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(() -&gt; deductStep1(), asyncExecutor)</span><br><span class="line">    .thenRunAsync(() -&gt; deductStep2(), asyncExecutor)</span><br><span class="line">    .exceptionally(ex -&gt; &#123;</span><br><span class="line">        channel.basicNack(tag, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>• <strong>可行性</strong>：<code>@RabbitListener</code> + <code>CompletableFuture</code> 能有效实现异步处理，提升消息消费速度。<br>• <strong>核心要点</strong>：<br>  • 手动 ACK/NACK 需在异步任务内完成。<br>  • 异步线程池需合理配置，避免资源耗尽。<br>  • 业务逻辑必须幂等，防止消息重试导致数据不一致。<br>• <strong>适用场景</strong>：适用于需要异步化、耗时较长的消息处理逻辑（如IO密集型操作）。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/12/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/" class="post-title-link" itemprop="url">黑马点评项目</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-12 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-12T00:00:00+08:00">2024-10-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 15:33:58" itemprop="dateModified" datetime="2025-04-27T15:33:58+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="实战篇Redis"><a href="#实战篇Redis" class="headerlink" title="实战篇Redis"></a>实战篇Redis</h1><h2 id="开篇导读"><a href="#开篇导读" class="headerlink" title="开篇导读"></a>开篇导读</h2><p>亲爱的小伙伴们大家好，马上咱们就开始实战篇的内容了，相信通过本章的学习，小伙伴们就能理解各种redis的使用啦，接下来咱们来一起看看实战篇我们要学习一些什么样的内容</p>
<ul>
<li>短信登录</li>
</ul>
<p>这一块我们会使用redis TOKEN共享session来实现</p>
<ul>
<li>商户查询缓存</li>
</ul>
<p>通过本章节，我们会理解缓存击穿，缓存穿透，缓存雪崩等问题，让小伙伴的对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容</p>
<ul>
<li>优惠卷秒杀</li>
</ul>
<p>通过本章节，我们可以学会Redis的计数器功能， 结合Lua完成高性能的redis操作，同时学会Redis分布式锁的原理，包括Redis的三种消息队列</p>
<ul>
<li>附近的商户</li>
</ul>
<p>我们利用Redis的GEOHash来完成对于地理坐标的操作</p>
<ul>
<li>UV统计</li>
</ul>
<p>主要是使用Redis来完成统计功能</p>
<ul>
<li>用户签到</li>
</ul>
<p>使用Redis的BitMap数据统计功能</p>
<ul>
<li>好友关注</li>
</ul>
<p>基于Set集合的关注、取消关注，共同关注等等功能，这一块知识咱们之前就讲过，这次我们在项目中来使用一下</p>
<ul>
<li>打人探店</li>
</ul>
<p>基于List来完成点赞列表的操作，同时基于SortedSet来完成点赞的排行榜功能</p>
<p>以上这些内容咱们统统都会给小伙伴们讲解清楚，让大家充分理解如何使用Redis</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653056228879.png" alt="1653056228879"></p>
<h2 id="短信登录：分布式session-token-redis"><a href="#短信登录：分布式session-token-redis" class="headerlink" title="短信登录：分布式session (token+redis)"></a>短信登录：分布式session (token+redis)</h2><h3 id="导入黑马点评项目"><a href="#导入黑马点评项目" class="headerlink" title="导入黑马点评项目"></a>导入黑马点评项目</h3><h4 id="导入SQL"><a href="#导入SQL" class="headerlink" title="导入SQL"></a>导入SQL</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653057872536.png" alt="1653057872536"></p>
<h4 id="有关当前模型"><a href="#有关当前模型" class="headerlink" title="有关当前模型"></a>有关当前模型</h4><p>手机或者app端发起请求，请求我们的nginx服务器，nginx基于七层模型走的事HTTP协议，可以实现基于Lua直接绕开tomcat访问redis，也可以作为静态资源服务器，轻松扛下上万并发， 负载均衡到下游tomcat服务器，打散流量，我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，所以nginx是整个项目中重要的一环。</p>
<p>在tomcat支撑起并发流量后，我们如果让tomcat直接去访问Mysql，根据经验Mysql企业级服务器只要上点并发，一般是16或32 核心cpu，32 或64G内存，像企业级mysql加上固态硬盘能够支撑的并发，大概就是4000起~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满，容易崩溃，所以我们在高并发场景下，会选择使用mysql集群，同时为了进一步降低Mysql的压力，同时增加访问的性能，我们也会加入Redis，同时使用Redis集群使得Redis对外提供更好的服务。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653059409865.png" alt="1653059409865"></p>
<h4 id="导入后端项目"><a href="#导入后端项目" class="headerlink" title="导入后端项目"></a>导入后端项目</h4><p>在资料中提供了一个项目源码：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653060237073.png" alt="1653060237073"></p>
<h4 id="导入前端工程"><a href="#导入前端工程" class="headerlink" title="导入前端工程"></a>导入前端工程</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653060337562.png" alt="1653060337562"></p>
<h4 id="运行前端项目"><a href="#运行前端项目" class="headerlink" title="运行前端项目"></a>运行前端项目</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653060588190.png" alt="1653060588190"></p>
<h3 id="基于Session实现登录流程"><a href="#基于Session实现登录流程" class="headerlink" title="基于Session实现登录流程"></a>基于Session实现登录流程</h3><p>cookie不安全，session绝对安全</p>
<p><strong>发送验证码：</strong> </p>
<p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号</p>
<p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</p>
<p><strong>短信验证码登录、注册：</strong></p>
<p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p>
<p><strong>校验登录状态:</strong></p>
<p>用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653066208144.png" alt="1653066208144"></p>
<h3 id="实现发送短信验证码功能"><a href="#实现发送短信验证码功能" class="headerlink" title="实现发送短信验证码功能"></a>实现发送短信验证码功能</h3><p><strong>页面流程</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653067054461.png" alt="1653067054461"></p>
<p><strong>具体代码如下</strong></p>
<p><strong>贴心小提示：</strong></p>
<p>具体逻辑上文已经分析，我们仅仅只需要按照提示的逻辑写出代码即可。</p>
<ul>
<li>发送验证码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.符合，生成验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.保存验证码到 session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;code&quot;</span>,code);</span><br><span class="line">    <span class="comment">// 5.发送验证码</span></span><br><span class="line">    log.debug(<span class="string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);</span><br><span class="line">    <span class="comment">// 返回ok</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>登录</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.校验验证码</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheCode</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="keyword">if</span>(cacheCode == <span class="literal">null</span> || !cacheCode.toString().equals(code))&#123;</span><br><span class="line">         <span class="comment">//3.不一致，报错</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一致，根据手机号查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//不存在，则创建</span></span><br><span class="line">        user =  createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.保存用户信息到session中</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现登录拦截功能"><a href="#实现登录拦截功能" class="headerlink" title="实现登录拦截功能"></a>实现登录拦截功能</h3><p><strong>温馨小贴士：tomcat的运行原理</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653068196656.png" alt="1653068196656"></p>
<p>当用户发起请求时，会访问我们像tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应</p>
<p>通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据</p>
<p><strong>温馨小贴士：关于threadlocal</strong></p>
<p>如果小伙伴们看过threadLocal的源码，你会发现在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，所以可以通过这种方式来做到线程隔离</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653068874258.png" alt="1653068874258"></p>
<p>拦截器代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">//1.获取session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//2.获取session中的用户</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">//3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="comment">//4.不存在，拦截，返回401状态码</span></span><br><span class="line">              response.setStatus(<span class="number">401</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.存在，保存用户信息到Threadlocal</span></span><br><span class="line">        UserHolder.saveUser((User)user);</span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让拦截器生效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// token刷新的拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="隐藏用户敏感信息"><a href="#隐藏用户敏感信息" class="headerlink" title="隐藏用户敏感信息"></a>隐藏用户敏感信息</h3><p>我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了</p>
<p>Data Transfer Object 不包含业务逻辑，只包含传输时必要的字段，精简敏感信息</p>
<p><strong>在登录方法处修改</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//7.保存用户信息到session中</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;user&quot;</span>, BeanUtils.copyProperties(user,UserDTO.class));</span><br></pre></td></tr></table></figure>

<p><strong>在拦截器处：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.存在，保存用户信息到Threadlocal</span></span><br><span class="line">UserHolder.saveUser((UserDTO) user);</span><br></pre></td></tr></table></figure>

<p><strong>在UserHolder处：将user对象换成UserDTO</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="session共享问题"><a href="#session共享问题" class="headerlink" title="session共享问题"></a>session共享问题</h3><p><strong>核心思路分析：</strong></p>
<p>每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</p>
<p>但是这种方案具有两个大问题</p>
<p>1、每台服务器中都有完整的一份session数据，服务器内存压力过大。</p>
<p>2、session拷贝数据时，可能会出现延迟，影响效率</p>
<p>所以咱们后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653069893050.png" alt="1653069893050"></p>
<p>为什么用cookie,session,redis而不是数据库？</p>
<p>有些东西并不需要持久化到数据库中，只需要存在内存中即可，键值对型数据能够实现高效的查询与获取</p>
<h3 id="Redis代替session的业务流程"><a href="#Redis代替session的业务流程" class="headerlink" title="Redis代替session的业务流程"></a>Redis代替session的业务流程</h3><h4 id="设计key的结构"><a href="#设计key的结构" class="headerlink" title="设计key的结构"></a>设计key的结构</h4><p>首先我们要思考一下利用redis来存储数据，那么到底使用哪种结构呢？由于存入的数据比较简单，我们可以考虑使用String，或者是使用哈希，如下图，如果使用String，同学们注意他的value，用多占用一点空间，如果使用哈希，则他的value中只会存储他数据本身，如果不是特别在意内存，其实使用String就可以啦。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653319261433.png" alt="1653319261433"></p>
<h4 id="设计key的具体细节"><a href="#设计key的具体细节" class="headerlink" title="设计key的具体细节"></a>设计key的具体细节</h4><p>所以我们可以使用String结构，就是一个简单的key，value键值对的方式，但是关于key的处理，session他是每个用户都有自己的session，但是redis的key是共享的，咱们就不能使用code了</p>
<p>在设计这个key的时候，我们之前讲过需要满足两点</p>
<p>1、key要具有唯一性</p>
<p>2、key要方便携带</p>
<p>如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了。</p>
<p><mark>session：浏览器请求自动携带sessionID，服务器根据sessionID访问相应的内存空间存储的信息，<mark></p>
<p><mark>redis+token：浏览器请求携带token，服务器根据token访问redis数据库存储的信息。<mark></p>
<ul>
<li><mark>前端实现逻辑：将服务端生成的<u>token</u>保存到浏览器的sessionStorage域中，在axios发送ajax请求时进行方法拦截，在请求头requestHeader中加入authorization:<u>token</u> ，因为要保存到浏览器，所以不能使用手机号作为token而应该生成一个uuid字符串<mark>: </li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241031173338907.png" alt="image-20241031173338907"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241031173340660.png" alt="image-20241031173340660"></p>
<ul>
<li><mark>后端逻辑：将token取出，根据token访问redis数据库<mark></li>
</ul>
<h4 id="整体访问流程"><a href="#整体访问流程" class="headerlink" title="整体访问流程"></a>整体访问流程</h4><p>当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653319474181.png" alt="1653319474181"></p>
<h3 id="基于Redis实现短信登录"><a href="#基于Redis实现短信登录" class="headerlink" title="基于Redis实现短信登录"></a>基于Redis实现短信登录</h3><p>这里具体逻辑就不分析了，之前咱们已经重点分析过这个逻辑啦。</p>
<p><strong>UserServiceImpl代码</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.从redis获取验证码并校验</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="keyword">if</span> (cacheCode == <span class="literal">null</span> || !cacheCode.equals(code)) &#123;</span><br><span class="line">        <span class="comment">// 不一致，报错</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.一致，根据手机号查询用户 select * from tb_user where phone = ?</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.不存在，创建新用户并保存</span></span><br><span class="line">        user = createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.保存用户信息到 redis中</span></span><br><span class="line">    <span class="comment">// 7.1.随机生成token，作为登录令牌</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 7.2.将User对象转为HashMap存储</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">            CopyOptions.create()</span><br><span class="line">                    .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                    .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line">    <span class="comment">// 7.3.存储</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">    stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);</span><br><span class="line">    <span class="comment">// 7.4.设置token有效期</span></span><br><span class="line">    stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.返回token</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决状态登录刷新问题"><a href="#解决状态登录刷新问题" class="headerlink" title="解决状态登录刷新问题"></a>解决状态登录刷新问题</h3><h4 id="初始方案思路总结"><a href="#初始方案思路总结" class="headerlink" title="初始方案思路总结"></a>初始方案思路总结</h4><p>在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，比如主页之类的那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的。</p>
<p>只有访问拦截的网页才会刷redis，这样就导致如果用户访问的是其他网页，不会出发拦截器，过期token就会失效</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653320822964.png" alt="1653320822964"></p>
<h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><p>既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653320764547.png" alt="1653320764547"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><strong>RefreshTokenInterceptor</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.基于TOKEN获取redis中的用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span>  <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">        <span class="comment">// 3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.将查询到的hash数据转为UserDTO</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 6.存在，保存用户信息到 ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">// 7.刷新token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 8.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p><strong>LoginInterceptor</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要拦截（ThreadLocal中是否有用户）</span></span><br><span class="line">        <span class="keyword">if</span> (UserHolder.getUser() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有，需要拦截，设置状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="comment">// 拦截</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有用户，则放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45673401/article/details/132065407">Hutool BeanUtils.copyProperties的四种用法 空不拷贝/忽略拷贝/空不和忽略拷贝/全拷贝_hutool beanutil.copyproperties-CSDN博客</a> </p>
<p>beanToMap 属性转换异常</p>
<h2 id="商户查询缓存-分布式缓存cache"><a href="#商户查询缓存-分布式缓存cache" class="headerlink" title="商户查询缓存 分布式缓存cache"></a>商户查询缓存 分布式缓存cache</h2><h3 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存?"></a>什么是缓存?</h3><p><strong>前言</strong>:<strong>什么是缓存?</strong></p>
<p>就像自行车,越野车的避震器<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E9%81%BF%E9%9C%87%E5%99%A8.gif"></p>
<p>举个例子:越野车,山地自行车,都拥有”避震器”,<strong>防止</strong>车体加速后因惯性,在酷似”U”字母的地形上飞跃,硬着陆导致的<strong>损害</strong>,像个弹簧一样;</p>
<p>同样,实际开发中,系统也需要”避震器”,防止过高的数据访问猛冲系统,导致其操作线程无法及时处理信息而瘫痪;</p>
<p>这在实际开发中对企业讲,对产品口碑,用户评价都是致命的;所以企业非常重视缓存技术;</p>
<p><strong>缓存(<strong>Cache),就是数据交换的</strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码(例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1</span>:Static <span class="keyword">final</span> ConcurrentHashMap&lt;K,V&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(); 本地用于高并发</span><br><span class="line"></span><br><span class="line">例<span class="number">2</span>:<span class="keyword">static</span> <span class="keyword">final</span> Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存</span><br><span class="line"></span><br><span class="line">例<span class="number">3</span>:Static <span class="keyword">final</span> Map&lt;K,V&gt; map =  <span class="keyword">new</span> <span class="title class_">HashMap</span>(); 本地缓存</span><br></pre></td></tr></table></figure>

<p>由于其被<strong>Static</strong>修饰,所以随着类的加载而被加载到<strong>内存之中</strong>,作为本地缓存,由于其又被<strong>final</strong>修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(=)导致缓存失效;</p>
<h4 id="为什么要使用缓存"><a href="#为什么要使用缓存" class="headerlink" title="为什么要使用缓存"></a>为什么要使用缓存</h4><p>一句话:因为<strong>速度快,好用</strong></p>
<p>缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低<strong>用户访问并发量带来的</strong>服务器读写压力</p>
<p>实际开发过程中,企业的数据量,少则几十万,多则几千万,这么大数据量,如果没有缓存来作为”避震器”,系统是几乎撑不住的,所以企业会大量运用到缓存技术;</p>
<p>但是缓存也会增加代码复杂度和运营的成本:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220523214414123.png"></p>
<h4 id="如何使用缓存"><a href="#如何使用缓存" class="headerlink" title="如何使用缓存"></a>如何使用缓存</h4><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p>
<p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p>
<p><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p>
<p><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p>
<p><strong>CPU缓存：</strong>当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220523212915666.png"></p>
<h3 id="添加商户缓存"><a href="#添加商户缓存" class="headerlink" title="添加商户缓存"></a>添加商户缓存</h3><p>在我们查询商户信息时，我们是直接操作从数据库中去进行查询的，大致逻辑是这样，直接查询数据库那肯定慢咯，所以我们需要增加缓存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">public Result queryShopById(@PathVariable(&quot;id&quot;) Long id) &#123;</span><br><span class="line">    //这里是直接查询数据库</span><br><span class="line">    return shopService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缓存模型和思路"><a href="#缓存模型和思路" class="headerlink" title="缓存模型和思路"></a>缓存模型和思路</h4><p>标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653322097736.png" alt="1653322097736"></p>
<h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><p>代码思路：如果缓存有，则直接返回，如果缓存不存在，则查询数据库，然后存入redis。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653322190155.png" alt="1653322190155"></p>
<h4 id="练习：商铺信息缓存处理"><a href="#练习：商铺信息缓存处理" class="headerlink" title="练习：商铺信息缓存处理"></a>练习：商铺信息缓存处理</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241101145321055.png" alt="image-20241101145321055"></p>
<p>增加程序健壮性，先查看redis是否有key，没有就创建，如果有key但是长度为0，也创建，长度不为0，肯定有key，读取后解析为list返回</p>
<h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p>
<p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p>
<p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</p>
<p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653322506393.png" alt="1653322506393"></p>
<h4 id="DB-Cache数据一致性解决方案"><a href="#DB-Cache数据一致性解决方案" class="headerlink" title="DB, Cache数据一致性解决方案"></a>DB, Cache数据一致性解决方案</h4><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p>
<p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p>
<h5 id="Cache-Aside-Pattern-旁路缓存"><a href="#Cache-Aside-Pattern-旁路缓存" class="headerlink" title="Cache Aside Pattern 旁路缓存"></a>Cache Aside Pattern 旁路缓存</h5><p>人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p>
<h5 id="Read-Write-Through-Pattern-读写穿透"><a href="#Read-Write-Through-Pattern-读写穿透" class="headerlink" title="Read/Write Through Pattern 读写穿透"></a>Read/Write Through Pattern 读写穿透</h5><p>由系统本身完成，数据库与缓存的问题交由缓存系统本身去处理，实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p>
<p>但是Redis本身并没有支持将cache写入db的功能，因此也不常见</p>
<h5 id="Write-Behind-Caching-Pattern-异步缓存写入"><a href="#Write-Behind-Caching-Pattern-异步缓存写入" class="headerlink" title="Write Behind Caching Pattern 异步缓存写入"></a>Write Behind Caching Pattern 异步缓存写入</h5><p>调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p>
<p>举例：消息队列中消息的 异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制</p>
<p> db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么 高的场景，比如浏览量、点赞量</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653322857620.png" alt="1653322857620"></p>
<h4 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h4><p>综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题</p>
<p>操作缓存和数据库时有三个问题需要考虑：</p>
<h5 id="删除cache还是更新cache？"><a href="#删除cache还是更新cache？" class="headerlink" title="删除cache还是更新cache？"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38420688/article/details/108803569">删除cache还是更新cache？</a></h5><ul>
<li><p>更新缓存：每次更新数据库都更新缓存，无效写操作较多，并且可能有线程安全问题</p>
</li>
<li><p>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</p>
</li>
</ul>
<p>无效写：假设我们每次操作数据库后，都去更新缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来。</p>
<p>线程安全：比如可能更新了某个表的一个字段，然后更新对应的缓存需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值。而另外的表数据可能已经被其他线程修改，从而出现线程安全问题。</p>
<h5 id="如何保证cache与db的操作的同时成功或失败？"><a href="#如何保证cache与db的操作的同时成功或失败？" class="headerlink" title="如何保证cache与db的操作的同时成功或失败？"></a>如何保证cache与db的操作的同时成功或失败？</h5><ul>
<li><p>单体系统，将缓存与数据库操作放在一个事务</p>
</li>
<li><p>分布式系统，利用TCC等分布式事务方案</p>
</li>
</ul>
<h5 id="先操作cache还是先操作db？"><a href="#先操作cache还是先操作db？" class="headerlink" title="先操作cache还是先操作db？"></a>先操作cache还是先操作db？</h5><ul>
<li><p>先删除缓存，再操作数据库</p>
</li>
<li><p>先操作数据库，再删除缓存</p>
</li>
</ul>
<p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653323595206.png" alt="1653323595206"></p>
<p>先删了，没来得及更新数据库20，另一个抢先未命中然后从数据库读取10并写入缓存，最后造成不一致</p>
<p>查的进程刚好缓存失效了，已经查完数据库10，没来的及写缓存，插进来一个更新的进程，更新数据库20并删缓存，最后写缓存10</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241101154820526.png" alt="image-20241101154820526"></p>
<h4 id="Cache-Aside-Pattern-代码实现"><a href="#Cache-Aside-Pattern-代码实现" class="headerlink" title="Cache Aside Pattern 代码实现"></a>Cache Aside Pattern 代码实现</h4><p>核心思路如下：</p>
<p>修改ShopController中的业务逻辑，满足下面的需求：</p>
<p>根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</p>
<p>根据id修改店铺时，先修改数据库，再删除缓存</p>
<p><strong>修改重点代码1</strong>：修改<strong>ShopServiceImpl</strong>的queryById方法</p>
<p><strong>设置redis缓存时添加过期时间</strong> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653325871232.png" alt="1653325871232"></p>
<p><strong>修改重点代码2</strong></p>
<p>代码分析：通过之前的淘汰，我们确定了采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653325929549.png" alt="1653325929549"></p>
<h3 id="缓存穿透—Cache-Penetration"><a href="#缓存穿透—Cache-Penetration" class="headerlink" title="缓存穿透—Cache Penetration"></a>缓存穿透—Cache Penetration</h3><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>缓存空对象<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ul>
<li>额外的内存消耗</li>
<li>可能造成短期的不一致</li>
</ul>
</li>
</ul>
</li>
<li>布隆过滤<ul>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点：<ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p>
<p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p>
<p>假设布隆过滤器判断这个数据不存在，则直接返回</p>
<p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653326156516.png" alt="1653326156516"></p>
<h4 id="编码解决商品查询的缓存穿透问题"><a href="#编码解决商品查询的缓存穿透问题" class="headerlink" title="编码解决商品查询的缓存穿透问题"></a>编码解决商品查询的缓存穿透问题</h4><p>核心思路如下：</p>
<p>在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的</p>
<p>现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。</p>
<p>caching sharding load balancing</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653327124561.png" alt="1653327124561"></p>
<p><strong>小总结：</strong></p>
<p>缓存穿透产生的原因是什么？</p>
<ul>
<li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li>
</ul>
<p>缓存穿透的解决方案有哪些？</p>
<ul>
<li>缓存null值</li>
<li>布隆过滤</li>
<li>增强id的复杂度，避免被猜测id规律</li>
<li>做好数据的基础格式校验</li>
<li>加强用户权限校验</li>
<li>做好热点参数的限流</li>
</ul>
<h3 id="缓存雪崩—Cache-Avalanche"><a href="#缓存雪崩—Cache-Avalanche" class="headerlink" title="缓存雪崩—Cache Avalanche"></a>缓存雪崩—Cache Avalanche</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p>
<p>解决方案：</p>
<ul>
<li>给不同的Key的TTL添加随机值</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653327884526.png" alt="1653327884526"></p>
<h3 id="缓存击穿—Hotspot-Invalid"><a href="#缓存击穿—Hotspot-Invalid" class="headerlink" title="缓存击穿—Hotspot Invalid"></a>缓存击穿—Hotspot Invalid</h3><h4 id="解决思路-1"><a href="#解决思路-1" class="headerlink" title="解决思路"></a>解决思路</h4><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>互斥锁 MUTEX</li>
<li>逻辑过期 LOGICAL EXPIRE</li>
</ul>
<p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653328022622.png" alt="1653328022622"></p>
<p>解决方案一、使用锁来解决：</p>
<p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p>
<p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653328288627.png" alt="1653328288627"></p>
<p>解决方案二、逻辑过期方案</p>
<p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p>
<p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p>
<p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653328663897.png" alt="1653328663897"></p>
<p>进行对比</p>
<p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p>
<p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653357522914.png" alt="1653357522914"></p>
<h4 id="利用互斥锁解决缓存击穿—Mutex—基于setnx"><a href="#利用互斥锁解决缓存击穿—Mutex—基于setnx" class="headerlink" title="利用互斥锁解决缓存击穿—Mutex—基于setnx"></a>利用互斥锁解决缓存击穿—Mutex—基于setnx</h4><p>核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询</p>
<p>如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653357860001.png" alt="1653357860001"></p>
<p><strong>操作锁的代码：</strong></p>
<p>核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，  如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>操作代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span>  &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">       <span class="comment">// 1、从redis中查询商铺缓存</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">       <span class="comment">// 2、判断是否存在</span></span><br><span class="line">       <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">           <span class="comment">// 存在,直接返回</span></span><br><span class="line">           <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//判断命中的值是否是空值</span></span><br><span class="line">       <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//返回一个错误信息</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4.实现缓存重构</span></span><br><span class="line">       <span class="comment">//获取互斥锁</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:shop:&quot;</span> + id;</span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">           <span class="comment">// 判断否获取成功</span></span><br><span class="line">           <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">               <span class="comment">//失败，则休眠重试</span></span><br><span class="line">               Thread.sleep(<span class="number">50</span>);</span><br><span class="line">               <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//成功，根据id查询数据库</span></span><br><span class="line">            shop = getById(id);</span><br><span class="line">           <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">           <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//将空值写入redis</span></span><br><span class="line">               stringRedisTemplate.opsForValue().set(key,<span class="string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">               <span class="comment">//返回错误信息</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//6.写入redis</span></span><br><span class="line">           stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//7.释放互斥锁 </span></span><br><span class="line">           unlock(lockKey);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> shop;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241101214618482.png" alt="image-20241101214618482"></p>
<h4 id="利用逻辑过期解决缓存击穿—LogicalExpire"><a href="#利用逻辑过期解决缓存击穿—LogicalExpire" class="headerlink" title="利用逻辑过期解决缓存击穿—LogicalExpire"></a>利用逻辑过期解决缓存击穿—LogicalExpire</h4><p><strong>需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题</strong></p>
<p>思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653360308731.png" alt="1653360308731"></p>
<p>如果封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，要么你</p>
<p><strong>步骤一、</strong></p>
<p>新建一个实体类，我们采用第二个方案，这个方案，对原来代码没有侵入性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class RedisData &#123;</span><br><span class="line">    private LocalDateTime expireTime;</span><br><span class="line">    private Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤二、</strong></p>
<p>在<strong>ShopServiceImpl</strong> 新增此方法，利用单元测试进行缓存预热</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653360807133.png" alt="1653360807133"></p>
<p><strong>在测试类中</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653360864839.png" alt="1653360864839"></p>
<p>步骤三：正式代码</p>
<p><strong>ShopServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">( Long id )</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">// 2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">        <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">// 5.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">    <span class="comment">// 6.缓存重建</span></span><br><span class="line">    <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//重建缓存</span></span><br><span class="line">                <span class="built_in">this</span>.saveShop2Redis(id,<span class="number">20L</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="封装Redis工具类—CacheClient"><a href="#封装Redis工具类—CacheClient" class="headerlink" title="封装Redis工具类—CacheClient"></a>封装Redis工具类—CacheClient</h3><p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p>
<ul>
<li>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</li>
<li>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓</li>
</ul>
<p>存击穿问题</p>
<ul>
<li>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题</li>
<li>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</li>
</ul>
<p>将逻辑进行封装</p>
<p>重点在于为了普适性要加入泛型，尽可能提高代码复用性，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">// 写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            <span class="comment">// 6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">newR</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">        <span class="comment">// 4.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3.获取锁失败，休眠并重试</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">// 返回错误信息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ShopServiceImpl 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> CacheClient cacheClient;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 解决缓存穿透</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient</span><br><span class="line">                .queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 互斥锁解决缓存击穿</span></span><br><span class="line">        <span class="comment">// Shop shop = cacheClient</span></span><br><span class="line">        <span class="comment">//         .queryWithMutex(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逻辑过期解决缓存击穿</span></span><br><span class="line">        <span class="comment">// Shop shop = cacheClient</span></span><br><span class="line">        <span class="comment">//         .queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, this::getById, 20L, TimeUnit.SECONDS);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="引入布隆过滤器-BloomFilter"><a href="#引入布隆过滤器-BloomFilter" class="headerlink" title="引入布隆过滤器 BloomFilter"></a>引入布隆过滤器 BloomFilter</h3><h4 id="引入Guava依赖"><a href="#引入Guava依赖" class="headerlink" title="引入Guava依赖"></a>引入Guava依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>33.2.1-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="将布隆过滤器交给IoC容器"><a href="#将布隆过滤器交给IoC容器" class="headerlink" title="将布隆过滤器交给IoC容器"></a>将布隆过滤器交给IoC容器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuavaConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;custom.expectedInsertions&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long expectedInsertions;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;custom.fpp&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Double fpp;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BloomFilter&lt;Long&gt; <span class="title function_">shopIdBloomFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BloomFilter.create(Funnels.longFunnel(), expectedInsertions, fpp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BloomFilter&lt;String&gt; <span class="title function_">stringBloomFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BloomFilter.create(Funnels.stringFunnel(StandardCharsets.UTF_8), expectedInsertions, fpp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol>
<li><p>bloomFilter.put() 加入布隆过滤器</p>
</li>
<li><p>bloomFilter.mightContain()判断是否存在</p>
</li>
<li><p>expectedInsertions 布隆过滤器中预期加入的数字</p>
</li>
<li><p>fpp 可接受的误判率</p>
</li>
</ol>
<h2 id="优惠卷秒杀-乐观锁、悲观锁（synchronized）"><a href="#优惠卷秒杀-乐观锁、悲观锁（synchronized）" class="headerlink" title="优惠卷秒杀 乐观锁、悲观锁（synchronized）"></a>优惠卷秒杀 乐观锁、悲观锁（synchronized）</h2><h3 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="-全局唯一ID"></a>-全局唯一ID</h3><p>每个店铺都可以发布优惠券：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653362612286.png" alt="1653362612286"></p>
<p>当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：</p>
<ul>
<li>id的规律性太明显</li>
<li>受单表数据量的限制</li>
</ul>
<p>场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。</p>
<p>场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。</p>
<p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653363100502.png" alt="1653363100502"></p>
<p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653363172079.png" alt="1653363172079">ID的组成部分：符号位：1bit，永远为0</p>
<p>时间戳：31bit，以秒为单位，可以使用69年</p>
<p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p>
<h3 id="Redis实现全局唯一Id"><a href="#Redis实现全局唯一Id" class="headerlink" title="-Redis实现全局唯一Id"></a>-Redis实现全局唯一Id</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisIdWorker</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.生成序列号</span></span><br><span class="line">        <span class="comment">// 2.1.获取当前日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">// 2.2.自增长</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<p>知识小贴士：关于countdownlatch </p>
<p>countdownlatch名为信号枪：主要的作用是同步协调在多线程的等待于唤醒问题</p>
<p>我们如果没有CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch</p>
<p>CountDownLatch 中有两个最重要的方法</p>
<p>1、countDown</p>
<p>2、await</p>
<p>await 方法 是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch  内部维护的 变量变为0时，就不再阻塞，直接放行，那么什么时候CountDownLatch   维护的变量变为0 呢，我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testIdWorker</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;id = &quot;</span> + id);</span><br><span class="line">        &#125;</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        es.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line">    latch.await();</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time = &quot;</span> + (end - begin));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加优惠卷"><a href="#添加优惠卷" class="headerlink" title="添加优惠卷"></a>添加优惠卷</h3><p>每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653365145124.png" alt="1653365145124"></p>
<p>tb_voucher：优惠券的基本信息，优惠金额、使用规则等<br>tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息</p>
<p>平价卷由于优惠力度并不是很大，所以是可以任意领取</p>
<p>而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段</p>
<p>**新增普通卷代码：  **VoucherController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.save(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>新增秒杀卷代码：</strong></p>
<p><strong>VoucherController</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;seckill&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addSeckillVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.addSeckillVoucher(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>VoucherServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现秒杀下单"><a href="#实现秒杀下单" class="headerlink" title="实现秒杀下单"></a>实现秒杀下单</h3><p>下单核心思路：当我们点击抢购时，会触发右侧的请求，我们只需要编写对应的controller即可</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653365839526.png" alt="1653365839526"></p>
<p>秒杀下单应该思考的内容：</p>
<p>下单时需要判断两点：</p>
<ul>
<li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li>
<li>库存是否充足，不足则无法下单</li>
</ul>
<p>下单核心逻辑分析：</p>
<p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件</p>
<p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653366238564.png" alt="1653366238564"></p>
<p>VoucherOrderServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5，扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">//扣减库存</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 6.1.订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">// 6.2.用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 6.3.代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="库存超卖问题分析"><a href="#库存超卖问题分析" class="headerlink" title="库存超卖问题分析"></a>库存超卖问题分析</h3><p>有关超卖问题分析：在我们原有代码中是这么写的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="comment">// 库存不足</span></span><br><span class="line">       <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//5，扣减库存</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">           .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">           .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">   <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">       <span class="comment">//扣减库存</span></span><br><span class="line">       <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653368335155.png" alt="1653368335155"></p>
<p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：见下图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653368562591.png" alt="1653368562591"></p>
<p><strong>悲观锁：</strong></p>
<p> 悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</p>
<p><strong>乐观锁：</strong></p>
<p>  乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas</p>
<p>  乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 == 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值</p>
<p>  其中do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var5;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">&#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> var5;</span><br></pre></td></tr></table></figure>

<p><strong>课程中的使用方式：</strong></p>
<p>课程中的使用方式是没有像cas一样带自旋的操作，也没有对version的版本号+1 ，他的操作逻辑是在操作时，对版本号进行+1 操作，然后要求version 如果是1 的情况下，才能操作，那么第一个线程在操作后，数据库中的version变成了2，但是他自己满足version=1 ，所以没有问题，此时线程2执行，线程2 最后也需要加上条件version =1 ，但是现在由于线程1已经操作过了，所以线程2，操作时就不满足version=1 的条件了，所以线程2无法执行成功</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653369268550.png" alt="1653369268550"></p>
<h3 id="乐观锁解决超卖问题"><a href="#乐观锁解决超卖问题" class="headerlink" title="乐观锁解决超卖问题"></a>乐观锁解决超卖问题</h3><p><strong>修改代码方案一、</strong></p>
<p>VoucherOrderServiceImpl 在扣减库存时，改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>) <span class="comment">//set stock = stock -1</span></span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="string">&quot;stock&quot;</span>,voucher.getStock()).update(); <span class="comment">//where id = ？ and stock = ?</span></span><br></pre></td></tr></table></figure>

<p>以上逻辑的核心含义是：只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败</p>
<p><strong>修改代码方案二、</strong></p>
<p>之前的方式要修改前后都保持一致，但是这样我们分析过，成功的概率太低，所以我们的乐观锁需要变一下，改成stock大于0 即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update().gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>); <span class="comment">//where id = ? and stock &gt; 0</span></span><br></pre></td></tr></table></figure>

<p><strong>知识小扩展：</strong></p>
<p>针对cas中的自旋压力过大，我们可以使用Longaddr这个类去解决</p>
<p>Java8 提供的一个对AtomicLong改进后的一个类，LongAdder</p>
<p>大量线程并发更新一个原子性的时候，天然的问题就是自旋，会导致并发性问题，当然这也比我们直接使用syn来的好</p>
<p>所以利用这么一个类，LongAdder来进行优化</p>
<p>如果获取某个值，则会对cell和base的值进行递增，最后返回一个完整的值</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653370271627.png" alt="1653370271627"></p>
<h3 id="优惠券秒杀-一人一单"><a href="#优惠券秒杀-一人一单" class="headerlink" title="优惠券秒杀-一人一单"></a>优惠券秒杀-一人一单</h3><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p>
<p><strong>现在的问题在于：</strong></p>
<p>优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单</p>
<p>具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653371854389.png" alt="1653371854389"></p>
<p>VoucherOrderServiceImpl  </p>
<p><strong>初步代码：增加一人一单逻辑</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.一人一单逻辑</span></span><br><span class="line">    <span class="comment">// 5.1.用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 用户已经购买过了</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6，扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">//扣减库存</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 7.1.订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line"></span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 7.3.代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>存在问题：</strong>现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作</p>
<p><strong>注意：</strong>在这里提到了非常多的问题，我们需要慢慢的来思考，首先我们的初始方案是封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">         <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 7.1.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 7.2.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 7.3.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制<strong>锁粒度</strong> 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：</p>
<h4 id="锁的真正含义"><a href="#锁的真正含义" class="headerlink" title="锁的真正含义"></a>锁的真正含义</h4><p><mark>锁的真正含义<mark>: 导致线程安全问题的线程之间需要拥有同一把锁，比如：字符串常量作为锁，意味着只要能得到这个字符串常量的锁都会参与到锁的竞争中，这会使不相关的线程被阻塞，同样的如果使用<code> synchronized(this)</code>，也会导致所有获得服务对象的线程都会参与锁的竞争，也就是所有用户都被挡在门外，引入悲观锁只是用来解决一人一单问题的，所以应该使用userId作为锁对象，这样不同的用户就不会互相影响。（数据库层面的乐观锁仍然可以有效防止库存负数的问题，先查后改）</p>
<p>拿到相同对象（锁）的线程会串行执行同步代码块，所以不同用户可以并行执行这段代码。</p>
<p>intern() 这个方法是从常量池中拿到数据，如果我们直接使用 <code>userId.toString()</code>他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">	<span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">	<span class="keyword">synchronized</span>(userId.toString().intern())&#123;</span><br><span class="line">         <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 7.1.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 7.2.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 7.3.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事务内部加锁导致事务失效"><a href="#事务内部加锁导致事务失效" class="headerlink" title="事务内部加锁导致事务失效"></a>事务内部加锁导致事务失效</h4><p>但是以上代码还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放，下一个拿到锁的对象就开始执行事务方法了，从而导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题如下：</p>
<p>在seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653373434815.png" alt="1653373434815"></p>
<h4 id="事务自调用导致事务失效"><a href="#事务自调用导致事务失效" class="headerlink" title="事务自调用导致事务失效"></a>事务自调用导致事务失效</h4><p>但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象，来操作事务</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653383810643.png" alt="1653383810643"></p>
<h4 id="事务的粒度控制"><a href="#事务的粒度控制" class="headerlink" title="事务的粒度控制"></a>事务的粒度控制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">secKillVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//省略.......</span></span><br><span class="line">    <span class="keyword">synchronized</span> (id.toString().intern()) &#123;</span><br><span class="line">        <span class="comment">//开启事务要用代理对象</span></span><br><span class="line">        <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">        <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//省略.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在回过头来再看，为什么在外部的<code>seckillVoucher()</code>需要去掉@Transactional注解？里外都声明了事务，并且传播都是默认的<code>REQUIRE</code>，外部方法先开启事务，最后<code>createVoucherOrder()</code> 也是加入的这个大事务，而这样同样会导致锁释放了，事务还没提交。</p>
<h4 id="Transactional-amp-Lock"><a href="#Transactional-amp-Lock" class="headerlink" title="@Transactional &amp; Lock"></a>@Transactional &amp; Lock</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/thisiswhy/p/15175380.html">当Transactional碰到锁，有个大坑，要小心。 - why技术 - 博客园 (cnblogs.com)</a> </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Adoucequan/article/details/123844506">事务中使用分布式锁问题_分布式锁在事务里面,加50毫秒等上一个事务提交后再执行-CSDN博客</a> </p>
<h3 id="集群环境下的并发问题"><a href="#集群环境下的并发问题" class="headerlink" title="集群环境下的并发问题"></a>集群环境下的并发问题</h3><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p>
<p>1、我们将服务启动两份，端口分别为8081和8082：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653373887844.png" alt="1653373887844"></p>
<p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653373908620.png" alt="1653373908620"></p>
<p><strong>具体操作(略)</strong></p>
<h4 id="有关锁失效原因分析"><a href="#有关锁失效原因分析" class="headerlink" title="有关锁失效原因分析"></a><strong>有关锁失效原因分析</strong></h4><p>不同JVM实例的常量池也不同，是隔绝开的，所以实例之间的互斥仅仅靠普通的对象锁是不可靠的</p>
<p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653374044740.png" alt="1653374044740"></p>
<h2 id="分布式锁—为解决分布式-集群进程间的并发安全问题"><a href="#分布式锁—为解决分布式-集群进程间的并发安全问题" class="headerlink" title="分布式锁—为解决分布式/集群进程间的并发安全问题"></a>分布式锁—为解决分布式/集群进程间的并发安全问题</h2><h3 id="基本原理和实现方式对比"><a href="#基本原理和实现方式对比" class="headerlink" title="基本原理和实现方式对比"></a>基本原理和实现方式对比</h3><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p>
<p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653374296906.png" alt="1653374296906"></p>
<p>那么分布式锁他应该满足一些什么样的条件呢？</p>
<p>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p>
<p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p>
<p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p>
<p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p>
<p>安全性：安全也是程序中必不可少的一环</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653381992018.png" alt="1653381992018"></p>
<p>常见的分布式锁有三种</p>
<p>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</p>
<p>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</p>
<p>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653382219377.png" alt="1653382219377"></p>
<h3 id="Redis分布式锁的实现核心思路"><a href="#Redis分布式锁的实现核心思路" class="headerlink" title="Redis分布式锁的实现核心思路"></a>Redis分布式锁的实现核心思路</h3><p>实现分布式锁时需要实现的两个基本方法：</p>
<ul>
<li><p>获取锁：</p>
<ul>
<li>互斥：确保只能有一个线程获取锁</li>
<li>非阻塞：尝试一次，成功返回true，失败返回false</li>
</ul>
</li>
<li><p>释放锁：</p>
<ul>
<li>手动释放</li>
<li>超时释放：获取锁时添加一个超时时间</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653382669900.png" alt="1653382669900"></p>
</li>
</ul>
<p>核心思路：</p>
<p>我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653382830810.png" alt="1653382830810"></p>
<h3 id="实现分布式锁版本一"><a href="#实现分布式锁版本一" class="headerlink" title="实现分布式锁版本一"></a>实现分布式锁版本一</h3><ul>
<li>加锁逻辑</li>
</ul>
<p><strong>锁的基本接口</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1656079017728.png" alt="1656079017728"></p>
<p><strong>SimpleRedisLock</strong></p>
<p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_PREFIX=<span class="string">&quot;lock:&quot;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId()</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>释放锁逻辑</li>
</ul>
<p>SimpleRedisLock</p>
<p>释放锁，防止删除别人的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//通过del删除锁</span></span><br><span class="line">    stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改业务代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">      <span class="comment">// 1.查询优惠券</span></span><br><span class="line">      <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">      <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">// 尚未开始</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">// 尚未开始</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// 库存不足</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">      <span class="comment">//创建锁对象(新增代码)</span></span><br><span class="line">      <span class="type">SimpleRedisLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(<span class="string">&quot;order:&quot;</span> + userId, stringRedisTemplate);</span><br><span class="line">      <span class="comment">//获取锁对象</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1200</span>);</span><br><span class="line"><span class="comment">//加锁失败</span></span><br><span class="line">      <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">          <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">          <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//释放锁</span></span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Redis分布式锁误删情况说明"><a href="#Redis分布式锁误删情况说明" class="headerlink" title="Redis分布式锁误删情况说明"></a>Redis分布式锁误删情况说明</h3><p>逻辑说明：</p>
<p>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p>
<p>解决方案：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653385920025.png" alt="1653385920025"></p>
<h3 id="解决Redis分布式锁误删问题—本线程误删了其他线程的锁"><a href="#解决Redis分布式锁误删问题—本线程误删了其他线程的锁" class="headerlink" title="解决Redis分布式锁误删问题—本线程误删了其他线程的锁"></a>解决Redis分布式锁误删问题—本线程误删了其他线程的锁</h3><p>需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用UUID表示）<br>在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</p>
<ul>
<li>如果一致则释放锁</li>
<li>如果不一致则不释放锁</li>
</ul>
<p>核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653387398820.png" alt="1653387398820"></p>
<p>具体代码如下：加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取线程标示</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">   <span class="comment">// 获取锁</span></span><br><span class="line">   <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">   <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁中的标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">// 判断标示是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id)) &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有关代码实操说明：</strong></p>
<p>在我们修改完此处代码后，我们重启工程，然后启动两个线程，第一个线程持有锁后，手动释放锁，第二个线程 此时进入到锁内部，再放行第一个线程，此时第一个线程由于锁的value值并非是自己，所以不能释放锁，也就无法删除别人的锁，此时第二个线程能够正确释放锁，通过这个案例初步说明我们解决了锁误删的问题。</p>
<h3 id="分布式锁的原子性问题—Full-GC带来的JAVA代码阻塞延时"><a href="#分布式锁的原子性问题—Full-GC带来的JAVA代码阻塞延时" class="headerlink" title="分布式锁的原子性问题—Full GC带来的JAVA代码阻塞延时"></a>分布式锁的原子性问题—Full GC带来的JAVA代码阻塞延时</h3><p><mark>Full GC<mark>，即完全垃圾回收，是指JVM对堆内存的所有区域（年轻代、老年代以及永久代/元空间）进行的全面清理过程。与之相对的是Minor GC，通常只清理年轻代。Full GC的触发通常是响应式而非主动的，比如堆内存不足、永久代满载等情况。由于Full GC涉及范围广，耗时较长，因此可能会引起应用程序的显著暂停（Stop-the-world），影响用户体验。</p>
<p><mark>判断的动作 与 真正delete的动作不是同步的<mark> 导致在delete操作之前锁已经超时释放，被另一个线程获取，但是依然被第一个线程误删</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">currentLockerId</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOCK_KEY_PREFIX + name);</span><br><span class="line">    <span class="keyword">if</span> (StrUtil.equals(currentLockerId, threadId)) &#123;</span><br><span class="line">        <span class="comment">//阻塞。。。。。</span></span><br><span class="line">        stringRedisTemplate.delete(LOCK_KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>更为极端的误删逻辑说明：</p>
<p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653387764938.png" alt="1653387764938"></p>
<h3 id="Lua脚本解决多条命令原子性问题"><a href="#Lua脚本解决多条命令原子性问题" class="headerlink" title="Lua脚本解决多条命令原子性问题"></a>Lua脚本解决多条命令原子性问题</h3><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：<a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-tutorial.html%EF%BC%8C%E8%BF%99%E9%87%8C%E9%87%8D%E7%82%B9%E4%BB%8B%E7%BB%8DRedis%E6%8F%90%E4%BE%9B%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8lua%E5%8E%BB%E6%93%8D%E4%BD%9Credis%EF%BC%8C%E5%8F%88%E8%83%BD%E4%BF%9D%E8%AF%81%E4%BB%96%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8B%BF%E9%94%81%E6%AF%94%E9%94%81%E5%88%A0%E9%94%81%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8A%A8%E4%BD%9C%E4%BA%86%EF%BC%8C%E4%BD%9C%E4%B8%BAJava%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%99%E4%B8%80%E5%9D%97%E5%B9%B6%E4%B8%8D%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%A6%81%E6%B1%82%EF%BC%8C%E5%B9%B6%E4%B8%8D%E9%9C%80%E8%A6%81%E5%A4%A7%E5%AE%B6%E8%BF%87%E4%BA%8E%E7%B2%BE%E9%80%9A%EF%BC%8C%E5%8F%AA%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E4%BB%96%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E5%8D%B3%E5%8F%AF%E3%80%82">https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了，作为Java程序员这一块并不作一个简单要求，并不需要大家过于精通，只需要知道他有什么作用即可。</a></p>
<h4 id="原子性的含义"><a href="#原子性的含义" class="headerlink" title="原子性的含义"></a><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8E%9F%E5%AD%90%E6%80%A7&spm=1001.2101.3001.7020">原子性的含义</a></h4><p>首先何为<strong>原子性</strong> ？原子性 是指<strong>操作不可分割</strong>，要么全部执行成功，要么全部执行失败，中间不会被打断。</p>
<p><strong>使用 lua 脚本就可以实现一组操作的原子性</strong>，这些操作作为一个整体，要么全部执行成功，要么全部执行失败，也就不会存在不同的操作先后执行、多个线程之间相互穿插的情况了。</p>
<h4 id="Redis-单线程模型"><a href="#Redis-单线程模型" class="headerlink" title="Redis 单线程模型"></a>Redis 单线程模型</h4><p><strong>redis 是一个单线程模型的数据库</strong>。redis 虽然可以支持多个客户端的并发连接，<strong>但是每个客户端的操作其实是按照顺序进行的</strong>。也就是说，如果一个客户端正在执行某个操作，其他客户端需要等待这个操作执行完毕后才能进行操作。</p>
<p>看到这里，应该也就能够明白了。我们把多个操作写成一个 lua 脚本，使其具备原子性，作为一个整体执行。再由于 redis 是单线程模型，<strong>不同线程的 lua 脚本是依次执行的</strong>。也就是说，<strong>只有一个线程原子性的多个操作执行完，下一个线程才可以执行</strong>。实际上也是保证了在 redis 内部不同线程操作的串行执行，从而能够解决并发安全问题。</p>
<p>因此，结合 lua 脚本可以实现原子操作，对于需要对多个 key 进行操作的场景，可以把多个操作封装到一个 lua 脚本中，这样就可以保证这些操作的原子性，避免多个线程之间的数据竞争问题，从而保证<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Redis%E6%95%B0%E6%8D%AE%E5%BA%93&spm=1001.2101.3001.7020">Redis数据库</a>的数据一致性和可靠性。</p>
<h4 id="Lua-脚本语法"><a href="#Lua-脚本语法" class="headerlink" title="Lua 脚本语法"></a>Lua 脚本语法</h4><p>这里重点介绍Redis提供的调用函数，语法如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其它参数&#x27;</span>, ...)</span><br></pre></td></tr></table></figure>

<p>例如，我们要执行set name jack，则脚本是这样：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 先执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>)</span><br><span class="line"># 再执行 get name</span><br><span class="line"><span class="keyword">local</span> name = redis.call(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"># 返回</span><br><span class="line"><span class="keyword">return</span> name</span><br></pre></td></tr></table></figure>

<p>写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653392181413.png" alt="1653392181413"></p>
<p>例如，我们要执行 redis.call(‘set’, ‘name’, ‘jack’) 这个脚本，语法如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653392218531.png" alt="1653392218531"></p>
<p>如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653392438917.png" alt="1653392438917"></p>
<p>接下来我们来回一下我们释放锁的逻辑：</p>
<p>释放锁的业务流程是这样的</p>
<p>​    1、获取锁中的线程标示</p>
<p>​    2、判断是否与指定的标示（当前线程标示）一致</p>
<p>​    3、如果一致则释放锁（删除）</p>
<p>​    4、如果不一致则什么都不做</p>
<p>如果用Lua脚本来表示则是这样的：</p>
<p>最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h3 id="利用Java代码调用Lua脚本改造分布式锁"><a href="#利用Java代码调用Lua脚本改造分布式锁" class="headerlink" title="利用Java代码调用Lua脚本改造分布式锁"></a>利用Java代码调用Lua脚本改造分布式锁</h3><p>lua脚本本身并不需要大家花费太多时间去研究，只需要知道如何调用，大致是什么意思即可，所以在笔记中并不会详细的去解释这些lua表达式的含义。</p>
<p>我们的RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图股</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653393304844.png" alt="1653393304844"></p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br><span class="line">经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~</span><br></pre></td></tr></table></figure>

<p>小总结：</p>
<p>基于Redis的分布式锁实现思路：</p>
<ul>
<li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li>
<li>释放锁时先判断线程标示是否与自己一致，一致则删除锁<ul>
<li>特性：<ul>
<li>利用set nx满足互斥性</li>
<li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li>
<li>利用Redis集群保证高可用和高并发特性</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>笔者总结：我们一路走来，利用添加过期时间，防止死锁问题的发生，但是有了过期时间之后，可能出现误删别人锁的问题，这个问题我们开始是利用删之前 通过拿锁，比锁，删锁这个逻辑来解决的，也就是删之前判断一下当前这把锁是否是属于自己的，但是现在还有原子性问题，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后通过lua表达式来解决这个问题</p>
<p>但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission啦</p>
<p><strong>测试逻辑：</strong></p>
<p>第一个线程进来，得到了锁，手动删除锁，模拟锁超时了，其他线程会执行lua来抢锁，当第一天线程利用lua删除锁时，lua能保证他不能删除他的锁，第二个线程删除锁时，利用lua同样可以保证不会删除别人的锁，同时还能保证原子性。</p>
<h2 id="分布式锁-Redission"><a href="#分布式锁-Redission" class="headerlink" title="分布式锁-Redission"></a>分布式锁-Redission</h2><h3 id="分布式锁-Redission-功能介绍"><a href="#分布式锁-Redission-功能介绍" class="headerlink" title="分布式锁-Redission 功能介绍"></a>分布式锁-Redission 功能介绍</h3><p>基于setnx实现的分布式锁存在下面的问题：</p>
<p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，<strong>他的方法都是使用synchronized修饰</strong>的（锁对象都是this），假如他在A方法内，调用B方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p>
<p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p>
<p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p>
<p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653546070602.png" alt="1653546070602"></p>
<p>那么什么是Redission呢</p>
<p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p>
<p>Redission提供了分布式锁的多种多样的功能</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653546736063.png" alt="1653546736063"></p>
<h3 id="分布式锁-Redission-快速入门"><a href="#分布式锁-Redission-快速入门" class="headerlink" title="分布式锁-Redission 快速入门"></a>分布式锁-Redission 快速入门</h3><p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置Redisson客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.150.101:6379&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如何使用Redission的分布式锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 VoucherOrderServiceImpl</p>
<p>注入RedissonClient</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询优惠券</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 尚未开始</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 尚未开始</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 库存不足</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//创建锁对象 这个代码不用了，因为我们现在要使用分布式锁</span></span><br><span class="line">        <span class="comment">//SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">        <span class="comment">//获取锁对象</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">       </span><br><span class="line">		<span class="comment">//加锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">            <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="分布式锁-Redission-可重入锁原理"><a href="#分布式锁-Redission-可重入锁原理" class="headerlink" title="分布式锁-Redission 可重入锁原理"></a>分布式锁-Redission 可重入锁原理</h3><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state=0，假如有人持有这把锁，那么state=1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0 时，表示当前这把锁没有被人持有。  </p>
<p>在redission中，我们的也支持支持可重入锁</p>
<p>在分布式锁中，他采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有，所以接下来我们一起分析一下当前的这个lua表达式</p>
<p>这个地方一共有3个参数</p>
<p><strong>KEYS[1] ： 锁名称</strong></p>
<p><strong>ARGV[1]：  锁失效时间</strong></p>
<p><strong>ARGV[2]：  id + “:” + threadId; 锁的小key</strong></p>
<p>exists: 判断数据是否存在  name：是lock是否存在,如果==0，就表示当前这把锁不存在</p>
<p>redis.call(‘hset’, KEYS[1], ARGV[2], 1);此时他就开始往redis里边去写数据 ，写成一个hash结构</p>
<p>Lock{</p>
<p>​    id + <strong>“:”</strong> + threadId :  1</p>
<p>}</p>
<p>如果当前这把锁存在，则第一个条件不满足，再判断</p>
<p>redis.call(‘hexists’, KEYS[1], ARGV[2]) == 1</p>
<p>此时需要通过大key+小key判断当前这把锁是否是属于自己的，如果是自己的，则进行</p>
<p>redis.call(‘hincrby’, KEYS[1], ARGV[2], 1)</p>
<p>将当前这个锁的value进行+1 ，redis.call(‘pexpire’, KEYS[1], ARGV[1]); 然后再对其设置过期时间，如果以上两个条件都不满足，则表示当前这把锁抢锁失败，最后返回pttl，即为当前这把锁的失效时间</p>
<p>如果小伙帮们看了前边的源码， 你会发现他会去判断当前这个方法的返回值是否为null，如果是null，则对应则前两个if对应的条件，退出抢锁逻辑，如果返回的不是null，即走了第三个分支，在源码处会进行while(true)的自旋抢锁。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653548087334.png" alt="1653548087334"></p>
<h3 id="分布式锁-Redission锁重试和WatchDog机制"><a href="#分布式锁-Redission锁重试和WatchDog机制" class="headerlink" title="分布式锁-Redission锁重试和WatchDog机制"></a>分布式锁-Redission锁重试和WatchDog机制</h3><p><strong>说明</strong>：由于课程中已经说明了有关tryLock的源码解析以及其看门狗原理，所以笔者在这里给大家分析lock()方法的源码解析，希望大家在学习过程中，能够掌握更多的知识</p>
<p>抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p>
<p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p>
<p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p>
<p>所以如果返回是null，则代表着当前这哥们已经抢锁完毕，或者可重入完毕，但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，同学们可以自行往下翻一点点，你能发现有个while( true) 再次进行tryAcquire进行抢锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line"><span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line"><span class="comment">// lock acquired</span></span><br><span class="line"><span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来会有一个条件分支，因为lock方法有重载方法，一个是带参数，一个是不带参数，如果带带参数传入的值是-1，如果传入参数，则leaseTime是他本身，所以如果传入了参数，此时leaseTime != -1 则会进去抢锁，抢锁的逻辑就是之前说的那三个逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是没有传入时间，则此时也会进行抢锁， 而且抢锁时间是默认看门狗时间 commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()</p>
<p>ttlRemainingFuture.onComplete((ttlRemaining, e) 这句话相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class="line">                                        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">                                        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock acquired</span></span><br><span class="line">    <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">        scheduleExpirationRenewal(threadId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> ttlRemainingFuture;</span><br></pre></td></tr></table></figure>

<p>此逻辑就是续约逻辑，注意看commandExecutor.getConnectionManager().newTimeout（） 此方法</p>
<p>Method(  <strong>new</strong> TimerTask() {},参数2 ，参数3  )</p>
<p>指的是：通过参数2，参数3 去描述什么时候去做参数1的事情，现在的情况是：10s之后去做参数一的事情</p>
<p>因为锁的失效时间是30s，当10s之后，此时这个timeTask 就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约</p>
<p>那么大家可以想一想，假设我们的线程出现了宕机他还会续约吗？当然不会，因为没有人再去调用renewExpiration这个方法，所以等到时间之后自然就释放了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">            <span class="keyword">if</span> (ent == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">            <span class="keyword">if</span> (threadId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">// reschedule itself</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    </span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Redisson-获取锁、释放锁逻辑"><a href="#Redisson-获取锁、释放锁逻辑" class="headerlink" title="Redisson 获取锁、释放锁逻辑"></a>Redisson 获取锁、释放锁逻辑</h4><p>tryLock() 只获取一次，不重试</p>
<p>tryLock(waitTime, leaseTime, TimeUnit) 可重试，有等待时间和超时释放</p>
<p><code>leaseTime</code>超时释放时间，<code>waitTime</code>最大等待时间</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241109153113839.png" alt="image-20241109153113839"></p>
<h5 id="超时续约（TTL与业务执行情况挂钩）"><a href="#超时续约（TTL与业务执行情况挂钩）" class="headerlink" title="超时续约（TTL与业务执行情况挂钩）"></a>超时续约（TTL与业务执行情况挂钩）</h5><p>获取成功，但不设置释放时间，此时会把leaseTime设置为-1，然后开启看门狗线程，设置定时任务定时更新TTL，实现了锁有效期的不断重置。<strong>如何跟业务产生联系</strong>：当业务执行完毕会释放锁，此时会将定时任务取消。如果看门狗线程出现宕机，过一段时间也会自动释放。</p>
<p>在释放的同时会发布<code>publish</code>一个释放的消息给其他等待的线程。</p>
<h5 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h5><p>获取失败会订阅<code>subscribe</code>释放的消息，再等一段时间，如果获取到释放锁的信号，重试获取锁，如果一直没获取到，超出最大等待时间之后会返回false。</p>
<h3 id="分布式锁-Redission锁的MultiLock原理"><a href="#分布式锁-Redission锁的MultiLock原理" class="headerlink" title="分布式锁-Redission锁的MultiLock原理"></a>分布式锁-Redission锁的MultiLock原理</h3><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p>
<p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653553998403.png" alt="1653553998403"></p>
<p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653554055048.png" alt="1653554055048"></p>
<p>那么MutiLock 加锁原理是什么呢？笔者画了一幅图来说明</p>
<p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间(waitTime)，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试，重试要从头再来。</p>
<p>成功获取所有锁之后，如果之前设置了leaseTime释放时间，还要重新设置一下TTL，因为成功获取一把锁，这把锁就开始倒计时了，导致expireTime不统一</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653553093967.png" alt="1653553093967"></p>
<h3 id="分布式锁-总结"><a href="#分布式锁-总结" class="headerlink" title="分布式锁 总结"></a>分布式锁 总结</h3><h4 id="不可重入Redis分布式锁—基于setnx"><a href="#不可重入Redis分布式锁—基于setnx" class="headerlink" title="不可重入Redis分布式锁—基于setnx"></a>不可重入Redis分布式锁—基于setnx</h4><p>利用setnx互斥性，释放锁时使用线程标示防止误删</p>
<p>缺陷：不可重入（同一线程无法重复获取）无法重试（完全非阻塞）超时失效</p>
<h4 id="可重入Redis分布式锁—基于Redisson"><a href="#可重入Redis分布式锁—基于Redisson" class="headerlink" title="可重入Redis分布式锁—基于Redisson"></a>可重入Redis分布式锁—基于Redisson</h4><p>与ReentrantLock类似，利用Hash结构，记录线程标示，同时也记录重入次数（可重入）</p>
<p>使用Watchdog机制实现超时可续约，将锁与业务执行情况挂钩。</p>
<p>利用信号量，使用发布订阅这样的异步等待机制实现可重试</p>
<p>缺点：Redis主从模式下主机宕机会引起锁失效</p>
<h4 id="铁锁连环—Redisson-Multilock"><a href="#铁锁连环—Redisson-Multilock" class="headerlink" title="铁锁连环—Redisson Multilock"></a>铁锁连环—Redisson Multilock</h4><p>将多个Redisson锁合并成一把锁，必须把这些锁全部拿到才算获取成功，一扇门用若干锁锁起来。</p>
<p>缺陷：运维成本高，需要多个Redis节点，实现起来较为复杂</p>
<h2 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h2><h3 id="秒杀优化-异步秒杀思路"><a href="#秒杀优化-异步秒杀思路" class="headerlink" title="秒杀优化-异步秒杀思路"></a>秒杀优化-异步秒杀思路</h3><p>我们来回顾一下下单流程</p>
<p>当用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤</p>
<p>1、查询优惠卷</p>
<p><mark>2、判断秒杀库存是否足够<mark></p>
<p>3、查询订单</p>
<p><mark>4、校验是否是一人一单<mark></p>
<p>5、扣减库存</p>
<p>6、创建订单</p>
<p>在这六步操作中，又有很多操作是要去操作数据库的，而且还是一个线程串行执行， 这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行，那么如何加速呢？</p>
<p>在这里笔者想给大家分享一下课程内没有的思路，看看有没有小伙伴这么想，比如，我们可以不可以使用异步编排来做，或者说我开启N多线程，N多个线程，一个线程执行查询优惠卷，一个执行判断扣减库存，一个去创建订单等等，然后再统一做返回，这种做法和课程中有哪种好呢？答案是课程中的好，因为如果你采用我刚说的方式，如果访问的人很多，那么线程池中的线程可能一下子就被消耗完了，而且你使用上述方案，最大的特点在于，你觉得时效性会非常重要，但是你想想是吗？并不是，比如我只要确定他能做这件事，然后我后边慢慢做就可以了，我并不需要他一口气做完这件事，所以我们应当采用的是课程中，类似消息队列的方式来完成我们的需求，而不是使用线程池或者是异步编排的方式来完成这个需求。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653560986599.png" alt="1653560986599"></p>
<p>优化方案：我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点</p>
<p>第一个难点是我们怎么在redis中去快速校验一人一单，还有库存判断</p>
<p>第二个难点是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653561657295.png" alt="1653561657295"></p>
<p>我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua来操作</p>
<p>当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653562234886.png" alt="1653562234886"></p>
<h3 id="秒杀优化-Redis完成秒杀资格判断"><a href="#秒杀优化-Redis完成秒杀资格判断" class="headerlink" title="秒杀优化-Redis完成秒杀资格判断"></a>秒杀优化-Redis完成秒杀资格判断</h3><p>需求：</p>
<ul>
<li><p>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</p>
</li>
<li><p>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</p>
</li>
<li><p>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列  </p>
</li>
<li><p>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1656080546603.png" alt="1656080546603"></p>
</li>
</ul>
<p>VoucherServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    <span class="comment">//SECKILL_STOCK_KEY 这个变量定义在RedisConstans中</span></span><br><span class="line">    <span class="comment">//private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整lua表达式</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.参数列表</span></span><br><span class="line"><span class="comment">-- 1.1.优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 1.2.用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 1.3.订单id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1.库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2.订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1.判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2.库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3.存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.4.扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5.下单（保存用户）sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span></span><br><span class="line">redis.call(<span class="string">&#x27;xadd&#x27;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;id&#x27;</span>, orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>当以上lua表达式执行完毕后，剩下的就是根据步骤3,4来执行我们接下来的任务了</p>
<p>VoucherOrderServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">//获取用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">// 1.执行lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">            SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(),</span><br><span class="line">            voucherId.toString(), userId.toString(), String.valueOf(orderId)</span><br><span class="line">    );</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">    <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TODO 保存阻塞队列</span></span><br><span class="line">    <span class="comment">// 3.返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="秒杀优化-基于阻塞队列实现秒杀优化"><a href="#秒杀优化-基于阻塞队列实现秒杀优化" class="headerlink" title="秒杀优化-基于阻塞队列实现秒杀优化"></a>秒杀优化-基于阻塞队列实现秒杀优化</h3><p>VoucherOrderServiceImpl</p>
<p>修改下单动作，现在我们去下单时，是通过lua表达式去原子执行判断逻辑，如果判断我出来不为0 ，则要么是库存不足，要么是重复下单，返回错误信息，如果是0，则把下单的逻辑保存到队列中去，然后异步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步处理线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">   SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于线程池处理的任务</span></span><br><span class="line"><span class="comment">// 当初始化完毕后，就会去从对列中去拿信息</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1.获取队列中的订单信息</span></span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                    <span class="comment">// 2.创建订单</span></span><br><span class="line">                    handleVoucherOrder(voucherOrder);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">          	 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取用户</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">            <span class="comment">// 2.创建锁对象</span></span><br><span class="line">            <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">            <span class="comment">// 3.尝试获取锁</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.lock();</span><br><span class="line">            <span class="comment">// 4.判断是否获得锁成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 获取锁失败，直接返回失败或者重试</span></span><br><span class="line">                log.error(<span class="string">&quot;不允许重复下单！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效</span></span><br><span class="line">                proxy.createVoucherOrder(voucherOrder);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                redisLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//a</span></span><br><span class="line">	<span class="keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks =<span class="keyword">new</span>  <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.执行lua脚本</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">                SECKILL_SCRIPT,</span><br><span class="line">                Collections.emptyList(),</span><br><span class="line">                voucherId.toString(), userId.toString(), String.valueOf(orderId)</span><br><span class="line">        );</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">        <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.1.不为0 ，代表没有购买资格</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 2.3.订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 2.4.用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 2.5.代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="comment">// 2.6.放入阻塞队列</span></span><br><span class="line">        orderTasks.add(voucherOrder);</span><br><span class="line">        <span class="comment">//3.获取代理对象</span></span><br><span class="line">         proxy = (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">        <span class="comment">//4.返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">      <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="comment">// 5.1.查询订单</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).count();</span><br><span class="line">        <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经购买过了</span></span><br><span class="line">           log.error(<span class="string">&quot;用户已经购买过了&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// where id = ? and stock &gt; 0</span></span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 扣减失败</span></span><br><span class="line">            log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="秒杀业务的优化思路"><a href="#秒杀业务的优化思路" class="headerlink" title="秒杀业务的优化思路"></a>秒杀业务的优化思路</h3><p>之前：通过查数据库判断用户是否有资格下单，然后同步创建订单对象</p>
<p>现在：</p>
<ul>
<li>先利用Redis完成库存余量、一人一单判断，提前创建订单，完成抢单业务（直接返回给前端结果）</li>
<li>再将下单业务放入阻塞队列，利用独立线程异步下单，完成数据库的更改</li>
</ul>
<h4 id="基于阻塞队列的异步秒杀存在哪些问题"><a href="#基于阻塞队列的异步秒杀存在哪些问题" class="headerlink" title="基于阻塞队列的异步秒杀存在哪些问题"></a>基于阻塞队列的异步秒杀存在哪些问题</h4><ul>
<li>内存限制问题：BlockingQueue基于JVM，会受JVM内存限制</li>
<li>数据安全问题：<ul>
<li>JVM宕机会导致订单信息全部丢失，无法进行数据库更改</li>
<li>订单从阻塞队列中取出，执行之前发生了一些问题，导致任务失败，但是已经找不回来了</li>
</ul>
</li>
</ul>
<h2 id="Redis消息队列（Stream）"><a href="#Redis消息队列（Stream）" class="headerlink" title="Redis消息队列（Stream）"></a>Redis消息队列（Stream）</h2><h3 id="Redis消息队列-认识消息队列"><a href="#Redis消息队列-认识消息队列" class="headerlink" title="Redis消息队列-认识消息队列"></a>Redis消息队列-认识消息队列</h3><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p>
<ul>
<li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li>
<li>生产者：发送消息到消息队列</li>
<li>消费者：从消息队列获取消息并处理消息</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653574849336.png" alt="1653574849336"></p>
<p>使用队列的好处在于 <strong>解耦：</strong>所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。</p>
<p>这种场景在我们秒杀中就变成了：我们下单之后，利用redis去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。</p>
<p>这里我们可以使用一些现成的mq，比如kafka，rabbitmq等等，但是呢，如果没有安装mq，我们也可以直接使用redis提供的mq方案，降低我们的部署和学习成本。</p>
<h3 id="Redis消息队列-基于List实现消息队列"><a href="#Redis消息队列-基于List实现消息队列" class="headerlink" title="Redis消息队列-基于List实现消息队列"></a>Redis消息队列-基于List实现消息队列</h3><p><strong>基于List结构模拟消息队列</strong></p>
<p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p>
<p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653575176451.png" alt="1653575176451"></p>
<p>基于List的消息队列有哪些优缺点？<br>优点：</p>
<ul>
<li>利用Redis存储，不受限于JVM内存上限</li>
<li>基于Redis的持久化机制，数据安全性有保证</li>
<li>可以满足消息有序性</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法避免消息丢失</li>
<li>只支持单消费者</li>
</ul>
<h3 id="Redis消息队列-基于PubSub的消息队列"><a href="#Redis消息队列-基于PubSub的消息队列" class="headerlink" title="Redis消息队列-基于PubSub的消息队列"></a>Redis消息队列-基于PubSub的消息队列</h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p>
<p> SUBSCRIBE channel [channel] ：订阅一个或多个频道<br> PUBLISH channel msg ：向一个频道发送消息<br> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653575506373.png" alt="1653575506373"></p>
<p>基于PubSub的消息队列有哪些优缺点？<br>优点：</p>
<ul>
<li>采用发布订阅模型，支持多生产、多消费</li>
</ul>
<p>缺点：</p>
<ul>
<li>不支持数据持久化</li>
<li>无法避免消息丢失</li>
<li>消息堆积有上限，超出时数据丢失</li>
</ul>
<h3 id="Redis消息队列-基于Stream的消息队列"><a href="#Redis消息队列-基于Stream的消息队列" class="headerlink" title="Redis消息队列-基于Stream的消息队列"></a>Redis消息队列-基于Stream的消息队列</h3><p>Stream 是 Redis 5.0引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p>
<p>发送消息的命令：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577301737.png" alt="1653577301737"></p>
<p>例如：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577349691.png" alt="1653577349691"></p>
<p>读取消息的方式之一：XREAD</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577445413.png" alt="1653577445413"></p>
<p>例如，使用XREAD读取第一个消息：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577643629.png" alt="1653577643629"></p>
<p>XREAD阻塞方式，读取最新的消息：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577659166.png" alt="1653577659166"></p>
<p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577689129.png" alt="1653577689129"></p>
<p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p>
<p>STREAM类型消息队列的XREAD命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>一个消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li>有消息漏读的风险</li>
</ul>
<h3 id="Redis消息队列-基于Stream的消息队列-消费者组"><a href="#Redis消息队列-基于Stream的消息队列-消费者组" class="headerlink" title="Redis消息队列-基于Stream的消息队列-消费者组"></a>Redis消息队列-基于Stream的消息队列-消费者组</h3><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577801668.png" alt="1653577801668"></p>
<p>创建消费者组：<br><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577984924.png" alt="1653577984924"><br>key：队列名称<br>groupName：消费者组名称<br>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息<br>MKSTREAM：队列不存在时自动创建队列<br>其它常见命令：</p>
<p> <strong>删除指定的消费者组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP DESTORY key groupName</span><br></pre></td></tr></table></figure>

<p> <strong>给指定的消费者组添加消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br></pre></td></tr></table></figure>

<p> <strong>删除消费者组中的指定消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP DELCONSUMER key groupname consumername</span><br></pre></td></tr></table></figure>

<p>从消费者组读取消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>group：消费组名称</li>
<li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li>
<li>count：本次查询的最大数量</li>
<li>BLOCK milliseconds：当没有消息时最长等待时间</li>
<li>NOACK：无需手动ACK，获取到消息后自动确认</li>
<li>STREAMS key：指定队列名称</li>
<li>ID：获取消息的起始ID：</li>
</ul>
<p>“&gt;”：从下一个未消费的消息开始<br>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span><br><span class="line">位于消费者组g1的消费者c1读取一条消息，没有消息最长阻塞等待2000ms，</span><br><span class="line">消息来源key为s1，从s1下一个未消费的消息开始</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XACK s1 g1 ID1 ID2 ID3</span><br><span class="line">消息来源为s1，使用g1把ID1 ID2 ID3消息确认，从pendinglist中移除消息</span><br></pre></td></tr></table></figure>



<p>消费者监听消息的基本思路：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653578211854.png" alt="1653578211854">STREAM类型消息队列的XREADGROUP命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>可以多消费者争抢消息，加快消费速度</li>
<li>可以阻塞读取</li>
<li>没有消息漏读的风险</li>
<li>有消息确认机制，保证消息至少被消费一次</li>
</ul>
<p>最后我们来个小对比</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653578560691.png" alt="1653578560691"></p>
<h3 id="基于Redis的Stream结构作为消息队列，实现异步秒杀下单"><a href="#基于Redis的Stream结构作为消息队列，实现异步秒杀下单" class="headerlink" title="基于Redis的Stream结构作为消息队列，实现异步秒杀下单"></a>基于Redis的Stream结构作为消息队列，实现异步秒杀下单</h3><p>需求：</p>
<ul>
<li>创建一个Stream类型的消息队列，名为stream.orders</li>
<li>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</li>
<li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单\</li>
</ul>
<p>修改lua表达式,新增3.6</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1656082824939.png" alt="1656082824939"></p>
<p>VoucherOrderServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                    StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.lastConsumed())</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有消息，继续下一次循环</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                <span class="comment">//处理异常消息</span></span><br><span class="line">                handlePendingList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                    StreamOffset.create(<span class="string">&quot;stream.orders&quot;</span>, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断订单信息是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果为null，说明没有异常消息，结束循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 解析数据</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; value = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 3.创建订单</span></span><br><span class="line">                createVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 4.确认消息 XACK</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理pendding订单异常&quot;</span>, e);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Redis消息队列—Stream结构总结"><a href="#Redis消息队列—Stream结构总结" class="headerlink" title="Redis消息队列—Stream结构总结"></a>Redis消息队列—Stream结构总结</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653577801668.png" alt="1653577801668"></p>
<p>STREAM类型消息队列的XREADGROUP命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>可阻塞读取</li>
<li>消息可分流：多个消费者争抢消息，加快处理速度</li>
<li>消息标示机制：确保没有消息被漏读</li>
<li>消息确认机制：获取消息后加入pending-list，处理完成要通过XACK从pending-list移除，实现消息回溯</li>
<li>保证消息至少被消费一次</li>
</ul>
<p>最后我们来个小对比</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653578560691.png" alt="1653578560691"></p>
<p>——秒杀 完——</p>
<h2 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h2><h3 id="达人探店-发布探店笔记"><a href="#达人探店-发布探店笔记" class="headerlink" title="达人探店-发布探店笔记"></a>达人探店-发布探店笔记</h3><p>发布探店笔记</p>
<p>探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个：<br>tb_blog：探店笔记表，包含笔记中的标题、文字、图片等<br>tb_blog_comments：其他用户对探店笔记的评价</p>
<p><strong>具体发布流程</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653578992639.png" alt="1653578992639"></p>
<p>上传接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;blog&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">uploadImage</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile image)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取原始文件名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line">            <span class="comment">// 生成新文件名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> createNewFileName(originalFilename);</span><br><span class="line">            <span class="comment">// 保存文件</span></span><br><span class="line">            image.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, fileName));</span><br><span class="line">            <span class="comment">// 返回结果</span></span><br><span class="line">            log.debug(<span class="string">&quot;文件上传成功，&#123;&#125;&quot;</span>, fileName);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件上传失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：同学们在操作时，需要修改SystemConstants.IMAGE_UPLOAD_DIR 自己图片所在的地址，在实际开发中图片一般会放在nginx上或者是云存储上。</p>
<p>BlogController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/blog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlogController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IBlogService blogService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(<span class="meta">@RequestBody</span> Blog blog)</span> &#123;</span><br><span class="line">        <span class="comment">//获取登录用户</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        blog.setUpdateTime(user.getId());</span><br><span class="line">        <span class="comment">//保存探店博文</span></span><br><span class="line">        blogService.saveBlog(blog);</span><br><span class="line">        <span class="comment">//返回id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="达人探店-查看探店笔记"><a href="#达人探店-查看探店笔记" class="headerlink" title="达人探店-查看探店笔记"></a>达人探店-查看探店笔记</h3><p>实现查看发布探店笔记的接口</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653579931626.png" alt="1653579931626"></p>
<p>实现代码：</p>
<p>BlogServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询blog</span></span><br><span class="line">    <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="keyword">if</span> (blog == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;笔记不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.查询blog有关的用户</span></span><br><span class="line">    queryBlogUser(blog);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="达人探店-点赞功能"><a href="#达人探店-点赞功能" class="headerlink" title="达人探店-点赞功能"></a>达人探店-点赞功能</h3><p>初始代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//修改点赞数量</span></span><br><span class="line">    blogService.update().setSql(<span class="string">&quot;liked = liked +1 &quot;</span>).eq(<span class="string">&quot;id&quot;</span>,id).update();</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题分析：这种方式会导致一个用户无限点赞，明显是不合理的</p>
<p>造成这个问题的原因是，我们现在的逻辑，发起请求只是给数据库+1，所以才会出现这个问题</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653581590453.png" alt="1653581590453"></p>
<p>完善点赞功能</p>
<p>需求：</p>
<ul>
<li>同一个用户只能点赞一次，再次点击则取消点赞</li>
<li>如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</li>
</ul>
<p>实现步骤：</p>
<ul>
<li>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</li>
<li>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1</li>
<li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</li>
<li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li>
</ul>
<p>为什么采用set集合：</p>
<p>因为我们的数据是不能重复的，当用户操作过之后，无论他怎么操作，都是</p>
<p>具体步骤：</p>
<p>1、在Blog 添加一个字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField(exist = false)</span></span><br><span class="line"><span class="keyword">private</span> Boolean isLike;</span><br></pre></td></tr></table></figure>

<p>2、修改代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">       <span class="comment">// 1.获取登录用户</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());</span><br><span class="line">       <span class="keyword">if</span>(BooleanUtil.isFalse(isMember))&#123;</span><br><span class="line">            <span class="comment">//3.如果未点赞，可以点赞</span></span><br><span class="line">           <span class="comment">//数据库点赞数+1</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">           <span class="comment">//保存用户到Redis的set集合</span></span><br><span class="line">           <span class="keyword">if</span>(isSuccess)&#123;</span><br><span class="line">               stringRedisTemplate.opsForSet().add(key,userId.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//4.如果已点赞，取消点赞</span></span><br><span class="line">           <span class="comment">//数据库点赞数-1</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">           <span class="comment">//把用户从Redis的set集合移除</span></span><br><span class="line">           <span class="keyword">if</span>(isSuccess)&#123;</span><br><span class="line">               stringRedisTemplate.opsForSet().remove(key,userId.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="达人探店-点赞排行榜"><a href="#达人探店-点赞排行榜" class="headerlink" title="达人探店-点赞排行榜"></a>达人探店-点赞排行榜</h3><p>在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的TOP5，形成点赞排行榜：</p>
<p>之前的点赞是放到set集合，但是set集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的set集合，就是咱们的sortedSet</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653805077118.png" alt="1653805077118"></p>
<p>我们接下来来对比一下这些集合的区别是什么</p>
<p>所有点赞的人，需要是唯一的，所以我们应当使用set或者是sortedSet</p>
<p>其次我们需要排序，就可以直接锁定使用sortedSet啦</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653805203758.png" alt="1653805203758"></p>
<p>修改代码</p>
<p>BlogServiceImpl</p>
<p>点赞逻辑代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">     <span class="comment">// 1.获取登录用户</span></span><br><span class="line">     <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">     <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">     <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">     <span class="keyword">if</span> (score == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 3.如果未点赞，可以点赞</span></span><br><span class="line">         <span class="comment">// 3.1.数据库点赞数 + 1</span></span><br><span class="line">         <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">         <span class="comment">// 3.2.保存用户到Redis的set集合  zadd key value score</span></span><br><span class="line">         <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">             stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 4.如果已点赞，取消点赞</span></span><br><span class="line">         <span class="comment">// 4.1.数据库点赞数 -1</span></span><br><span class="line">         <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">         <span class="comment">// 4.2.把用户从Redis的set集合移除</span></span><br><span class="line">         <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">             stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> Result.ok();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">isBlogLiked</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">     <span class="comment">// 1.获取登录用户</span></span><br><span class="line">     <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">     <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 用户未登录，无需查询是否点赞</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> user.getId();</span><br><span class="line">     <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;blog:liked:&quot;</span> + blog.getId();</span><br><span class="line">     <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">     blog.setIsLike(score != <span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>点赞列表查询列表</p>
<p>BlogController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogLikes(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MySQL自定义排序-ORDER-BY-FIELD"><a href="#MySQL自定义排序-ORDER-BY-FIELD" class="headerlink" title="MySQL自定义排序 ORDER BY FIELD"></a>MySQL自定义排序 ORDER BY FIELD</h4><p>MySQL查询结果如果不指定排序顺序，返回结果通常是不确定的，而点赞排行榜是按照用户的点赞时间先后顺序排序的，所以要显式指定特定的排序规则，</p>
<p>根据用户ids查询用户 WHERE id IN ( 5 , 1 )  结果默认是按照ids中元素的id大小升序排序的，我们要让ids的顺序保留到最后，使用ORDER BY FIELD </p>
<p>BlogService</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">    <span class="comment">// 1.查询top5的点赞用户 zrange key 0 4</span></span><br><span class="line">    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (top5 == <span class="literal">null</span> || top5.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.解析出其中的用户id</span></span><br><span class="line">    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    <span class="comment">// 3.根据用户id查询用户 WHERE id IN ( 5 , 1 ) ORDER BY FIELD(id, 5, 1)</span></span><br><span class="line">    List&lt;UserDTO&gt; userDTOS = userService.query()</span><br><span class="line">            .in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list()</span><br><span class="line">            .stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 4.返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h2><h3 id="好友关注-关注和取消关注"><a href="#好友关注-关注和取消关注" class="headerlink" title="好友关注-关注和取消关注"></a>好友关注-关注和取消关注</h3><p>针对用户的操作：可以对用户进行关注和取消关注功能。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653806140822.png" alt="1653806140822"></p>
<p>实现思路：</p>
<p>需求：基于该表数据结构，实现两个接口：</p>
<ul>
<li>关注和取关接口</li>
<li>判断是否关注的接口</li>
</ul>
<p>关注是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来标示：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653806253817.png" alt="1653806253817"></p>
<p>注意: 这里需要把主键修改为自增长，简化开发。</p>
<p>FollowController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关注</span></span><br><span class="line"><span class="meta">@PutMapping(&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long followUserId, <span class="meta">@PathVariable(&quot;isFollow&quot;)</span> Boolean isFollow)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> followService.follow(followUserId, isFollow);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取消关注</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long followUserId)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> followService.isFollow(followUserId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FollowService</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">取消关注service</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">isFollow</span><span class="params">(Long followUserId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">// 2.查询是否关注 select count(*) from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId).count();</span><br><span class="line">        <span class="comment">// 3.判断</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(count &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> 关注service</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFollow)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">        <span class="comment">// 1.判断到底是关注还是取关</span></span><br><span class="line">        <span class="keyword">if</span> (isFollow) &#123;</span><br><span class="line">            <span class="comment">// 2.关注，新增数据</span></span><br><span class="line">            <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">            follow.setUserId(userId);</span><br><span class="line">            follow.setFollowUserId(followUserId);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(follow);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">            remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;()</span><br><span class="line">                    .eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="好友关注-共同关注"><a href="#好友关注-共同关注" class="headerlink" title="好友关注-共同关注"></a>好友关注-共同关注</h3><p>想要去看共同关注的好友，需要首先进入到这个页面，这个页面会发起两个请求</p>
<p>1、去查询用户的详情</p>
<p>2、去查询用户的笔记</p>
<p>以上两个功能和共同关注没有什么关系，大家可以自行将笔记中的代码拷贝到idea中就可以实现这两个功能了，我们的重点在于共同关注功能。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653806706296.png" alt="1653806706296"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserController 根据id查询用户</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span>&#123;</span><br><span class="line">	<span class="comment">// 查询详情</span></span><br><span class="line">	<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line">	<span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> Result.ok();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">	<span class="comment">// 返回</span></span><br><span class="line">	<span class="keyword">return</span> Result.ok(userDTO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BlogController  根据id查询博主的探店笔记</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/of/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogByUserId</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params">		<span class="meta">@RequestParam(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">	<span class="comment">// 根据用户查询</span></span><br><span class="line">	Page&lt;Blog&gt; page = blogService.query()</span><br><span class="line">			.eq(<span class="string">&quot;user_id&quot;</span>, id).page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));</span><br><span class="line">	<span class="comment">// 获取当前页数据</span></span><br><span class="line">	List&lt;Blog&gt; records = page.getRecords();</span><br><span class="line">	<span class="keyword">return</span> Result.ok(records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们来看看共同关注如何实现：</p>
<p>需求：利用Redis中恰当的数据结构，实现共同关注功能。在博主个人页面展示出当前用户与博主的共同关注呢。</p>
<p>当然是使用我们之前学习过的set集合咯，在set集合中，有交集并集补集的api，我们可以把两人的关注的人分别放入到一个set集合中，然后再通过api去查看这两个set集合中的交集数据。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653806973212.png" alt="1653806973212"></p>
<p>我们先来改造当前的关注列表</p>
<p>改造原因是因为我们需要在用户关注了某位用户后，需要将数据放入到set集合中，方便后续进行共同关注，同时当取消关注时，也需要从set集合中进行删除</p>
<p>FollowServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFollow)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">// 1.判断到底是关注还是取关</span></span><br><span class="line">    <span class="keyword">if</span> (isFollow) &#123;</span><br><span class="line">        <span class="comment">// 2.关注，新增数据</span></span><br><span class="line">        <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">        follow.setUserId(userId);</span><br><span class="line">        follow.setFollowUserId(followUserId);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(follow);</span><br><span class="line">        <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">            <span class="comment">// 把关注用户的id，放入redis的set集合 sadd userId followerUserId</span></span><br><span class="line">            stringRedisTemplate.opsForSet().add(key, followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> remove(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Follow&gt;()</span><br><span class="line">                .eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;follow_user_id&quot;</span>, followUserId));</span><br><span class="line">        <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">            <span class="comment">// 把关注用户的id从Redis集合中移除</span></span><br><span class="line">            stringRedisTemplate.opsForSet().remove(key, followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体的关注代码：</strong></p>
<p>FollowServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">// 2.求交集</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + id;</span><br><span class="line">    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, key2);</span><br><span class="line">    <span class="keyword">if</span> (intersect == <span class="literal">null</span> || intersect.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 无交集</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.解析id集合</span></span><br><span class="line">    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 4.查询用户</span></span><br><span class="line">    List&lt;UserDTO&gt; users = userService.listByIds(ids)</span><br><span class="line">            .stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> Result.ok(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="好友关注-Feed流-实现"><a href="#好友关注-Feed流-实现" class="headerlink" title="好友关注-Feed流 实现"></a>好友关注-Feed流 实现</h3><p>当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p>
<p>对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653808641260.png" alt="1653808641260"></p>
<p>对于新型的Feed流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653808993693.png" alt="1653808993693"></p>
<p>Feed流的实现有两种模式：</p>
<p>Feed流产品有两种常见模式：<br>Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈</p>
<ul>
<li>优点：信息全面，不会有缺失。并且实现也相对简单</li>
<li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li>
</ul>
<p>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</p>
<ul>
<li>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</li>
<li>缺点：如果算法不精准，可能起到反作用<br>本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种：</li>
</ul>
<p>我们本次针对好友的操作，采用的就是Timeline的方式，只需要拿到我们关注用户的信息，然后按照时间排序即可</p>
<p>，因此采用Timeline的模式。该模式的实现方案有三种：</p>
<ul>
<li>拉模式</li>
<li>推模式</li>
<li>推拉结合</li>
</ul>
<p><strong>拉模式</strong>：也叫做读扩散</p>
<p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序</p>
<p>优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p>
<p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653809450816.png" alt="1653809450816"></p>
<p><strong>推模式</strong>：也叫做写扩散。</p>
<p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p>
<p>优点：时效快，不用临时拉取</p>
<p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653809875208.png" alt="1653809875208"></p>
<p><strong>推拉结合模式</strong>：也叫做读写混合，兼具推和拉两种模式的优点。</p>
<p>推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653812346852.png" alt="1653812346852"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241112191818612.png" alt="image-20241112191818612"></p>
<h3 id="好友关注-推送到粉丝收件箱"><a href="#好友关注-推送到粉丝收件箱" class="headerlink" title="好友关注-推送到粉丝收件箱"></a>好友关注-推送到粉丝收件箱</h3><p>需求：</p>
<ul>
<li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li>
<li>收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现</li>
<li>查询收件箱数据时，可以实现分页查询</li>
</ul>
<p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p>
<p>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</p>
<p>假设在t1 时刻，我们去读取第一页，此时page = 1 ，size = 5 ，那么我们拿到的就是10<del>6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page=2 ，size=5 ，那么此时读取到的第二页实际上是从6 开始，然后是6</del>2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653813047671.png" alt="1653813047671"></p>
<p>Feed流的滚动分页</p>
<p>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</p>
<p>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653813462834.png" alt="1653813462834"></p>
<p>核心的意思：就是我们在保存完探店笔记后，获得到当前笔记的粉丝，然后把数据推送到粉丝的redis中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取登录用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    blog.setUserId(user.getId());</span><br><span class="line">    <span class="comment">// 2.保存探店笔记</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> save(blog);</span><br><span class="line">    <span class="keyword">if</span>(!isSuccess)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;新增笔记失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.查询笔记作者的所有粉丝 select * from tb_follow where follow_user_id = ?</span></span><br><span class="line">    List&lt;Follow&gt; follows = followService.query().eq(<span class="string">&quot;follow_user_id&quot;</span>, user.getId()).list();</span><br><span class="line">    <span class="comment">// 4.推送笔记id给所有粉丝</span></span><br><span class="line">    <span class="keyword">for</span> (Follow follow : follows) &#123;</span><br><span class="line">        <span class="comment">// 4.1.获取粉丝id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> follow.getUserId();</span><br><span class="line">        <span class="comment">// 4.2.推送</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.返回id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="好友关注-实现分页查询收邮箱"><a href="#好友关注-实现分页查询收邮箱" class="headerlink" title="好友关注-实现分页查询收邮箱"></a>好友关注-实现分页查询收邮箱</h3><p>需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息：</p>
<p>具体操作如下：</p>
<p>1、每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件</p>
<p>2、我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据</p>
<p>综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。</p>
<p>这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653819821591.png" alt="1653819821591"></p>
<p>一、定义出来具体的返回值实体类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScrollResult</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;?&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Long minTime;</span><br><span class="line">    <span class="keyword">private</span> Integer offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlogController</p>
<p>注意：RequestParam 表示接受url地址栏传参的注解，当方法上参数的名称和url地址栏不相同时，可以通过RequestParam 来进行指定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/follow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(&quot;lastId&quot;)</span> Long max, <span class="meta">@RequestParam(value = &quot;offset&quot;, defaultValue = &quot;0&quot;)</span> Integer offset)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogOfFollow(max, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlogServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()</span><br><span class="line">        .reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 3.非空判断</span></span><br><span class="line">    <span class="keyword">if</span> (typedTuples == <span class="literal">null</span> || typedTuples.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.解析数据：blogId、minTime（时间戳）、offset</span></span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">    <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">os</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; <span class="comment">// 5 4 4 2 2</span></span><br><span class="line">        <span class="comment">// 4.1.获取id</span></span><br><span class="line">        ids.add(Long.valueOf(tuple.getValue()));</span><br><span class="line">        <span class="comment">// 4.2.获取分数(时间戳）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> tuple.getScore().longValue();</span><br><span class="line">        <span class="keyword">if</span>(time == minTime)&#123;</span><br><span class="line">            os++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            os = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	os = minTime == max ? os : os + offset;</span><br><span class="line">    <span class="comment">// 5.根据id查询blog</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    List&lt;Blog&gt; blogs = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">        <span class="comment">// 5.1.查询blog有关的用户</span></span><br><span class="line">        queryBlogUser(blog);</span><br><span class="line">        <span class="comment">// 5.2.查询blog是否被点赞</span></span><br><span class="line">        isBlogLiked(blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.封装并返回</span></span><br><span class="line">    <span class="type">ScrollResult</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">    r.setList(blogs);</span><br><span class="line">    r.setOffset(os);</span><br><span class="line">    r.setMinTime(minTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="附近商户—GEO"><a href="#附近商户—GEO" class="headerlink" title="附近商户—GEO"></a>附近商户—GEO</h2><h3 id="附近商户-GEO数据结构的基本用法"><a href="#附近商户-GEO数据结构的基本用法" class="headerlink" title="附近商户-GEO数据结构的基本用法"></a>附近商户-GEO数据结构的基本用法</h3><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p>
<ul>
<li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li>
<li>GEODIST：计算指定的两个点之间的距离并返回</li>
<li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li>
<li>GEOPOS：返回指定member的坐标</li>
<li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li>
<li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li>
<li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</li>
</ul>
<h3 id="附近商户-导入店铺数据到GEO"><a href="#附近商户-导入店铺数据到GEO" class="headerlink" title="附近商户-导入店铺数据到GEO"></a>附近商户-导入店铺数据到GEO</h3><p>具体场景说明：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653822036941.png" alt="1653822036941"></p>
<p>当我们点击美食之后，会出现一系列的商家，商家中可以按照多种排序方式，我们此时关注的是距离，这个地方就需要使用到我们的GEO，向后台传入当前app收集的地址(我们此处是写死的) ，以当前坐标作为圆心，同时绑定相同的店家类型type，以及分页信息，把这几个条件传入后台，后台查询出对应的数据再返回。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653822021827.png" alt="1653822021827"></p>
<p>我们要做的事情是：将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。</p>
<p>但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可</p>
<p>代码</p>
<p>HmDianPingApplicationTests</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">loadShopData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询店铺信息</span></span><br><span class="line">    List&lt;Shop&gt; list = shopService.list();</span><br><span class="line">    <span class="comment">// 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合</span></span><br><span class="line">    Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">    <span class="comment">// 3.分批完成写入Redis</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 3.1.获取类型id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        <span class="comment">// 3.2.获取同类型的店铺的集合</span></span><br><span class="line">        List&lt;Shop&gt; value = entry.getValue();</span><br><span class="line">        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(value.size());</span><br><span class="line">        <span class="comment">// 3.3.写入redis GEOADD key 经度 纬度 member</span></span><br><span class="line">        <span class="keyword">for</span> (Shop shop : value) &#123;</span><br><span class="line">            <span class="comment">// stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());</span></span><br><span class="line">            locations.add(<span class="keyword">new</span> <span class="title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(</span><br><span class="line">                    shop.getId().toString(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(), shop.getY())</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.opsForGeo().add(key, locations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="附近商户-实现附近商户—redis逻辑分页查询"><a href="#附近商户-实现附近商户—redis逻辑分页查询" class="headerlink" title="附近商户-实现附近商户—redis逻辑分页查询"></a>附近商户-实现附近商户—redis逻辑分页查询</h3><p>SpringDataRedis的版本并不支持Redis 6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的POM</p>
<p>第一步：导入pom</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>第二步：</p>
<p>ShopController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/type&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;typeId&quot;)</span> Integer typeId,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;x&quot;, required = false)</span> Double x,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;y&quot;, required = false)</span> Double y</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> shopService.queryShopByType(typeId, current, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ShopServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要根据坐标查询</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 不需要坐标查询，按数据库查询</span></span><br><span class="line">            Page&lt;Shop&gt; page = query()</span><br><span class="line">                    .eq(<span class="string">&quot;type_id&quot;</span>, typeId)</span><br><span class="line">                    .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));</span><br><span class="line">            <span class="comment">// 返回数据</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(page.getRecords());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.计算分页参数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> (current - <span class="number">1</span>) * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> current * SystemConstants.DEFAULT_PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询redis、按照距离排序、分页。结果：shopId、distance</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo() <span class="comment">// GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE</span></span><br><span class="line">                .search(</span><br><span class="line">                        key,</span><br><span class="line">                        GeoReference.fromCoordinate(x, y),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Distance</span>(<span class="number">5000</span>),</span><br><span class="line">                        RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">// 4.解析出id</span></span><br><span class="line">        <span class="keyword">if</span> (results == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();</span><br><span class="line">        <span class="keyword">if</span> (list.size() &lt;= from) &#123;</span><br><span class="line">            <span class="comment">// 没有下一页了，结束</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.1.截取 from ~ end的部分</span></span><br><span class="line">        List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());</span><br><span class="line">        Map&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(list.size());</span><br><span class="line">        list.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// 4.2.获取店铺id</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">shopIdStr</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">            ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">            <span class="comment">// 4.3.获取距离</span></span><br><span class="line">            <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> result.getDistance();</span><br><span class="line">            distanceMap.put(shopIdStr, distance);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 5.根据id查询Shop</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">        List&lt;Shop&gt; shops = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">        <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">            shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shops);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="用户签到—BitMap"><a href="#用户签到—BitMap" class="headerlink" title="用户签到—BitMap"></a>用户签到—BitMap</h2><h3 id="用户签到-BitMap功能演示"><a href="#用户签到-BitMap功能演示" class="headerlink" title="用户签到-BitMap功能演示"></a>用户签到-BitMap功能演示</h3><p>我们针对签到功能完全可以通过mysql来完成，比如说以下这张表</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653823145495.png" alt="1653823145495"></p>
<p>用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条</p>
<p>每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共22 字节的内存，一个月则最多需要600多字节</p>
<p>我们如何能够简化一点呢？其实可以考虑小时候一个挺常见的方案，就是小时候，咱们准备一张小小的卡片，你只要签到就打上一个勾，我最后判断你是否签到，其实只需要到小卡片上看一看就知道了</p>
<p>我们可以采用类似这样的方案来实现我们的签到需求。</p>
<p>我们按月来统计用户签到信息，签到记录为1，未签到则记录为0.</p>
<p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示</p>
<p>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653824498278.png" alt="1653824498278"></p>
<p>BitMap的操作命令有：</p>
<ul>
<li>SETBIT：向指定位置（offset）存入一个0或1</li>
<li>GETBIT ：获取指定位置（offset）的bit值</li>
<li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li>
<li>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li>
<li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li>
<li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li>
<li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li>
</ul>
<h4 id="1用户签到-实现签到功能"><a href="#1用户签到-实现签到功能" class="headerlink" title="1用户签到-实现签到功能"></a>1用户签到-实现签到功能</h4><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p>
<p>思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p>
<p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改bitMap。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653833970361.png" alt="1653833970361"></p>
<p><strong>代码</strong></p>
<p>UserController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> userService.sign();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.写入Redis SETBIT key offset 1</span></span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存储肯定是以字节为单位，因此后面会补0</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241111230319873.png" alt="image-20241111230319873"></p>
<h4 id="用户签到-签到统计"><a href="#用户签到-签到统计" class="headerlink" title="用户签到-签到统计"></a>用户签到-签到统计</h4><p><strong>问题1：</strong>什么叫做连续签到天数？<br>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653834455899.png" alt="1653834455899"></p>
<p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p>
<p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p>
<p>  BITFIELD key GET u[dayOfMonth] 0</p>
<p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p>
<p><strong>问题3：如何从后向前遍历每个bit位？</strong></p>
<p>注意：bit<mark>Map返回的数据是10进制<mark>，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</p>
<p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p>
<p>有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653835784444.png" alt="1653835784444"></p>
<p>代码</p>
<p><strong>UserController</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sign/count&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.signCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserServiceImpl</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span></span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">            key,</span><br><span class="line">            BitFieldSubCommands.create()</span><br><span class="line">                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 没有任何签到结果</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="literal">null</span> || num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.循环遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为0，说明未签到，结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不为0，说明已签到，计数器+1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="额外加餐-关于使用bitmap来解决缓存穿透的方案"><a href="#额外加餐-关于使用bitmap来解决缓存穿透的方案" class="headerlink" title="额外加餐-关于使用bitmap来解决缓存穿透的方案"></a>额外加餐-关于使用bitmap来解决缓存穿透的方案</h4><p>回顾<strong>缓存穿透</strong>：</p>
<p>发起了一个数据库不存在的，redis里边也不存在的数据，通常你可以把他看成一个攻击</p>
<p>解决方案：</p>
<ul>
<li><p>判断id&lt;0</p>
</li>
<li><p>如果数据库是空，那么就可以直接往redis里边把这个空数据缓存起来</p>
</li>
</ul>
<p>第一种解决方案：遇到的问题是如果用户访问的是id不存在的数据，则此时就无法生效</p>
<p>第二种解决方案：遇到的问题是：如果是不同的id那就可以防止下次过来直击数据</p>
<p>所以我们如何解决呢？</p>
<p>我们可以将数据库的数据，所对应的id写入到一个list集合中，当用户过来访问的时候，我们直接去判断list中是否包含当前的要查询的数据，如果说用户要查询的id数据并不在list集合中，则直接返回，如果list中包含对应查询的id数据，则说明不是一次缓存穿透数据，则直接放行。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653836416586.png" alt="1653836416586"></p>
<p>现在的问题是这个主键其实并没有那么短，而是很长的一个 主键</p>
<p>哪怕你单独去提取这个主键，但是在11年左右，淘宝的商品总量就已经超过10亿个</p>
<p>所以如果采用以上方案，这个list也会很大，所以我们可以使用bitmap来减少list的存储空间</p>
<p>我们可以把list数据抽象成一个非常大的bitmap，我们不再使用list，而是将db中的id数据利用哈希思想，比如：</p>
<p>id % bitmap.size  = 算出当前这个id对应应该落在bitmap的哪个索引上，然后将这个值从0变成1，然后当用户来查询数据时，此时已经没有了list，让用户用他查询的id去用相同的哈希算法， 算出来当前这个id应当落在bitmap的哪一位，然后判断这一位是0，还是1，如果是0则表明这一位上的数据一定不存在，  采用这种方式来处理，需要重点考虑一个事情，就是误差率，所谓的误差率就是指当发生哈希冲突的时候，产生的误差。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653836578970.png" alt="1653836578970"></p>
<h2 id="UV统计—HyperLogLog"><a href="#UV统计—HyperLogLog" class="headerlink" title="UV统计—HyperLogLog"></a>UV统计—HyperLogLog</h2><p>Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903785744056333#heading-0">HyperLogLog 算法的原理讲解以及 Redis 是如何应用它的聪明的你可能会马上想到，用 HashMap 这种数 - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/53416615">Redis源码中hyperloglog结构的实现原理是什么？ - 知乎 (zhihu.com)</a></p>
<p>首先我们搞懂两个概念：</p>
<ul>
<li>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li>
<li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li>
</ul>
<p>通常来说UV会比PV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值</p>
<p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</p>
<p>Redis中的HLL是基于string结构实现的，单个HLL的内存<strong>永远小于16kb</strong>，<strong>内存占用低</strong>的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653837988985.png" alt="1653837988985"></p>
<h3 id="UV统计-测试百万数据的统计"><a href="#UV统计-测试百万数据的统计" class="headerlink" title="UV统计-测试百万数据的统计"></a>UV统计-测试百万数据的统计</h3><p>测试思路：我们直接利用单元测试，向HyperLogLog中添加100万条数据，看看内存占用和统计效果如何</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653838053608.png" alt="1653838053608"></p>
<p>经过测试：我们会发生他的误差是在允许范围内，并且内存占用极小</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/06/redis-advanced/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/06/redis-advanced/" class="post-title-link" itemprop="url">Redis 分布式应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-06 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-06T00:00:00+08:00">2024-10-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 15:33:58" itemprop="dateModified" datetime="2025-04-27T15:33:58+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="——分布式缓存——"><a href="#——分布式缓存——" class="headerlink" title="——分布式缓存——"></a>——分布式缓存——</h1><p>– 基于Redis集群解决单机Redis存在的问题</p>
<p>单机的Redis存在四大问题：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725144240631.png" alt="image-20210725144240631"></p>
<h1 id="一、Redis持久化"><a href="#一、Redis持久化" class="headerlink" title="一、Redis持久化"></a>一、Redis持久化</h1><p>Redis有两种持久化方案：</p>
<ul>
<li>RDB持久化</li>
<li>AOF持久化</li>
</ul>
<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照（<mark>SNAPSHOT<mark>）。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p>
<p>执行时机</p>
<p>RDB持久化在四种情况下会执行：</p>
<ul>
<li>执行save命令</li>
<li>执行bgsave命令</li>
<li>Redis停机时</li>
<li>触发RDB条件时</li>
</ul>
<p><strong>1）save命令</strong></p>
<p>执行下面的命令，可以立即执行一次RDB：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725144536958.png" alt="image-20210725144536958"></p>
<p>save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</p>
<p><strong>2）bgsave命令</strong></p>
<p>下面的命令可以异步执行RDB：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725144725943.png" alt="image-20210725144725943"></p>
<p>这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</p>
<p><strong>3）停机时</strong></p>
<p>Redis停机时会执行一次save命令，实现RDB持久化。</p>
<p><strong>4）触发RDB条件</strong></p>
<p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 900秒内，如果至少有1个key发生变化，则自动执行bgsave ， 如果是save &quot;&quot; 则表示:禁用RDB</span></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000 </span></span><br></pre></td></tr></table></figure>

<p>RDB的其它配置也可以在redis.conf文件中设置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘不值钱</span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># RDB文件名称</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb  </span></span><br><span class="line"><span class="comment"># 文件保存的路径目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">./ </span></span><br></pre></td></tr></table></figure>

<h3 id="RDB-原理"><a href="#RDB-原理" class="headerlink" title="RDB 原理"></a>RDB 原理</h3><p>bgsave开始时会 <strong>fork</strong> 主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p>
<p>fork采用的是copy-on-write技术：写入时复制</p>
<ul>
<li>当主进程执行读操作时，访问共享内存；</li>
<li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725151319695.png" alt="image-20210725151319695"></p>
<p>如果在RDB过程中，修改了所有的数据，那么redis占用内存将直接<mark>翻倍<mark></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="RDB方式bgsave的基本流程？"><a href="#RDB方式bgsave的基本流程？" class="headerlink" title="RDB方式bgsave的基本流程？"></a>RDB方式bgsave的基本流程？</h4><ul>
<li>fork主进程得到一个子进程，共享内存空间</li>
<li>子进程读取内存数据并写入新的RDB文件</li>
<li>用新RDB文件替换旧的RDB文件</li>
</ul>
<h4 id="RDB会在什么时候执行？save-60-1000代表什么含义？"><a href="#RDB会在什么时候执行？save-60-1000代表什么含义？" class="headerlink" title="RDB会在什么时候执行？save 60 1000代表什么含义？"></a>RDB会在什么时候执行？save 60 1000代表什么含义？</h4><ul>
<li>默认是服务停止时</li>
<li>代表60秒内至少执行1000次修改则触发RDB</li>
</ul>
<h4 id="RDB的缺点？"><a href="#RDB的缺点？" class="headerlink" title="RDB的缺点？"></a>RDB的缺点？</h4><ul>
<li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li>
<li>fork子进程、压缩、写出RDB文件都比较耗时，仅仅修改save命令的第一个参数不会提高RDB执行的效率</li>
</ul>
<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><h3 id="AOF-原理"><a href="#AOF-原理" class="headerlink" title="AOF 原理"></a>AOF 原理</h3><p>AOF全称为<mark>Append Only File<mark>（追加文件）。Redis处理的<mark>每一个写命令<mark>都会记录在AOF文件，可以看做是命令日志文件。(binlog in MySQL)。AOF是执行命令之后写入，binlog是执行之前写入</p>
<ul>
<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>
<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>
<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>
<li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725151543640.png" alt="image-20210725151543640"></p>
<h3 id="AOF-配置"><a href="#AOF-配置" class="headerlink" title="AOF 配置"></a>AOF 配置</h3><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启AOF功能，默认是no</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># AOF文件的名称</span></span><br><span class="line"><span class="attr">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure>

<p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示每执行一次写命令，立即记录到AOF文件</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">always </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">everysec </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">no</span></span><br></pre></td></tr></table></figure>

<p>三种策略对比：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725151654046.png" alt="image-20210725151654046"></p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241117220311689.png" alt="image-20241117220311689" style="zoom: 50%;" />

<h3 id="AOF-步骤"><a href="#AOF-步骤" class="headerlink" title="AOF 步骤"></a>AOF 步骤</h3><p><strong>命令追加（append）</strong>：所有的写命令会追加到 AOF 缓冲区中。</p>
<p><strong>文件写入（write）</strong>：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用<code>write</code>函数（系统调用），<code>write</code>将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。写入系统内核缓冲区之后直接返回（仅仅是写到缓冲区），不会立即同步到硬盘。虽然提高了效率，但也带来了数据丢失的风险。同步硬盘操作通常依赖于系统调度机制，Linux 内核通常为 30s 同步一次，具体值取决于写出的数据量和 I/O 缓冲区的状态。</p>
<p><strong>文件同步（fsync）</strong>：AOF 缓冲区根据对应的持久化方式（ <code>fsync</code> 策略）向硬盘做同步操作。这一步需要调用 <code>fsync</code> 函数（系统调用）， <code>fsync</code> 针对单个文件操作，对其进行强制硬盘同步，<code>fsync</code> 将阻塞直到写入磁盘完成后返回，保证了数据持久化。强制刷新系统内核缓冲区（同步到到磁盘），确保写磁盘操作结束才会返回。</p>
<p><strong>文件重写（rewrite）</strong>：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</p>
<p><strong>重启加载（load）</strong>：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/aof-work-process.png"></p>
<p>从 Redis 7 开始，Redis 使用了 <strong>Multi Part AOF</strong> 机制。顾名思义，Multi Part AOF 就是将原来的单个 AOF 文件拆分成多个 AOF 文件。在 Multi Part AOF 中，AOF 文件被分为三种类型，分别为：</p>
<ul>
<li>BASE：表示基础 AOF 文件，它一般由子进程通过重写产生，该文件最多只有一个。</li>
<li>INCR：表示增量 AOF 文件，它一般会在 AOFRW 开始执行时被创建，该文件可能存在多个。</li>
<li>HISTORY：表示历史 AOF 文件，它由 BASE 和 INCR AOF 变化而来，每次 AOFRW 成功完成时，本次 AOFRW 之前对应的 BASE 和 INCR AOF 都将变为 HISTORY，HISTORY 类型的 AOF 会被 Redis 自动删除。</li>
</ul>
<h3 id="AOF-文件重写"><a href="#AOF-文件重写" class="headerlink" title="AOF 文件重写"></a>AOF 文件重写</h3><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行<code>bgrewriteaof</code>命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725151729118.png" alt="image-20210725151729118"></p>
<p>如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p>
<p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p>
<p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p>
<ol>
<li>增长百分比阈值</li>
<li>文件体积大小阈值</li>
</ol>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span></span><br><span class="line"><span class="attr">auto-aof-rewrite-percentage</span> <span class="string">100</span></span><br><span class="line"><span class="comment"># AOF文件体积最小多大以上才触发重写 </span></span><br><span class="line"><span class="attr">auto-aof-rewrite-min-size</span> <span class="string">64mb </span></span><br></pre></td></tr></table></figure>

<h3 id="AOF-校验机制了解吗？"><a href="#AOF-校验机制了解吗？" class="headerlink" title="AOF 校验机制了解吗？"></a><a href="#aof-%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97">AOF 校验机制了解吗？</a></h3><p>AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。这个机制的原理其实非常简单，就是通过使用一种叫做 <strong>校验和（checksum）</strong> 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。因此，Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和（计算的时候会把最后一行保存校验和的内容给忽略点），从而判断 AOF 文件是否完整。如果发现文件有问题，Redis 就会拒绝启动并提供相应的错误信息。AOF 校验机制十分简单有效，可以提高 Redis 数据的可靠性。</p>
<hr>
<p>著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：<a target="_blank" rel="noopener" href="https://javaguide.cn/database/redis/redis-persistence.html">https://javaguide.cn/database/redis/redis-persistence.html</a></p>
<h2 id="RDB与AOF对比"><a href="#RDB与AOF对比" class="headerlink" title="RDB与AOF对比"></a>RDB与AOF对比</h2><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p>
<ul>
<li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。</li>
<li>AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725151940515.png" alt="image-20210725151940515"></p>
<p>Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</p>
<p>Redis 7.0 版本之后，AOF 重写机制得到了优化改进。具体方法是采用 base（全量数据）+inc（增量数据）独立文件存储的方式，彻底解决内存和 IO 资源的浪费，同时也支持对历史 AOF 文件的保存管理，结合 AOF 文件中的时间信息还可以实现 PITR 按时间点恢复（阿里云企业版 Tair 已支持），这进一步增强了 Redis 的数据可靠性，满足用户数据回档等需求。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/RnoPPL7jiFSKkx3G4p57Pg">从Redis7.0发布看Redis的过去与未来 (qq.com)</a> </p>
<h1 id="二、Redis主从集群：应对高并发读"><a href="#二、Redis主从集群：应对高并发读" class="headerlink" title="二、Redis主从集群：应对高并发读"></a>二、Redis主从集群：应对高并发读</h1><p>Redis 通过 Replica/Slave 从节点机制 完成主从复制与读写分离</p>
<h2 id="搭建主从架构"><a href="#搭建主从架构" class="headerlink" title="搭建主从架构"></a>搭建主从架构</h2><p>主从复制：单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725152037611.png" alt="image-20210725152037611"></p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建三个文件夹，将redis.conf复制过去</span></span><br><span class="line"><span class="built_in">mkdir</span> 7001 7002 7003</span><br><span class="line"><span class="built_in">cp</span> redis-6.2.6/redis.conf 7001</span><br><span class="line"><span class="built_in">cp</span> redis-6.2.6/redis.conf 7002</span><br><span class="line"><span class="built_in">cp</span> redis-6.2.6/redis.conf 7003</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改redis.conf中的port、dir</span></span><br><span class="line">sed -i -e <span class="string">&#x27;s/6379/7001/g&#x27;</span> -e <span class="string">&#x27;s/dir .\//dir \/root\/redissetup\/7001\//g&#x27;</span> 7001/redis.conf</span><br><span class="line">sed -i -e <span class="string">&#x27;s/6379/7002/g&#x27;</span> -e <span class="string">&#x27;s/dir .\//dir \/root\/redissetup\/7002\//g&#x27;</span> 7002/redis.conf</span><br><span class="line">sed -i -e <span class="string">&#x27;s/6379/7003/g&#x27;</span> -e <span class="string">&#x27;s/dir .\//dir \/root\/redissetup\/7003\//g&#x27;</span> 7003/redis.conf</span><br><span class="line"><span class="comment"># 添加主从配置ip</span></span><br><span class="line">sed -i <span class="string">&#x27;1a replica-announce-ip localhost&#x27;</span> 7001/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;1a replica-announce-ip localhost&#x27;</span> 7002/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;1a replica-announce-ip localhost&#x27;</span> 7003/redis.conf</span><br><span class="line"><span class="comment"># 添加主从配置端口号 和 主节点的密码</span></span><br><span class="line">sed -i <span class="string">&#x27;1i slaveof 127.0.0.1 7001&#x27;</span> 7002/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;2i masterauth 123321&#x27;</span> 7002/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;1i slaveof 127.0.0.1 7001&#x27;</span> 7003/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;2i masterauth 123321&#x27;</span> 7003/redis.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动redis-server</span></span><br><span class="line">redis-server -p 7001/redis.conf</span><br><span class="line">redis-server -p 7002/redis.conf</span><br><span class="line">redis-server -p 7003/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动命令行</span></span><br><span class="line">redis-cli -p 7001</span><br><span class="line">redis-cli -p 7002</span><br><span class="line">redis-cli -p 7003</span><br><span class="line"></span><br><span class="line">INFO replication <span class="comment">#显示主从信息</span></span><br></pre></td></tr></table></figure>



<h2 id="主从数据同步原理"><a href="#主从数据同步原理" class="headerlink" title="主从数据同步原理"></a>主从数据同步原理</h2><h3 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h3><p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将master节点的所有数据都拷贝给slave节点，流程：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725152222497.png" alt="image-20210725152222497"></p>
<p>这里有一个问题，master如何得知slave是第一次来连接呢？？</p>
<p>有几个概念，可以作为判断依据：</p>
<ul>
<li><strong>Replication Id</strong>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid<mark>（表示主从关系）<mark> </li>
<li><strong>offset</strong>：偏移量，随着记录在repl_backlog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。<mark>（表示数据版本）<mark></li>
</ul>
<p>因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。</p>
<p>因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。</p>
<p>master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。</p>
<p>master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。</p>
<p>因此，<strong>master判断一个节点是否是第一次同步的依据，就是看replid是否一致</strong>。</p>
<p>如图：AOF + RDB</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725152700914.png" alt="image-20210725152700914"></p>
<p>完整流程描述：</p>
<ol>
<li><p>slave节点请求同步，发送replid + offset</p>
</li>
<li><p>master节点判断replid，发现不一致，则进行全量同步返回master的replid + offset</p>
<ul>
<li>master将完整内存数据生成RDB（bgsave）发送RDB到slave</li>
<li>slave清空本地数据，加载master的RDB</li>
<li>master将RDB期间的命令记录在repl_backlog，并持续将repl_backlog的命令发送给slave</li>
</ul>
</li>
<li><p>master节点判断replid，发现一致，并且offset较小</p>
<ul>
<li>去repl_backlog中取得offset之后的数据，将repl_backlog的命令发送给slave</li>
</ul>
</li>
<li><p>slave执行接收到的命令，保持与master之间的同步</p>
</li>
</ol>
<h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><p>全量同步需要先做RDB，然后将RDB文件通过网络传输给slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做<strong>增量同步</strong></p>
<p>什么是增量同步？就是只更新slave与master存在差异的部分数据。如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725153201086.png" alt="image-20210725153201086"></p>
<p>那么master怎么知道slave与自己的数据差异在哪里呢?</p>
<h3 id="repl-backlog原理"><a href="#repl-backlog原理" class="headerlink" title="repl_backlog原理"></a>repl_backlog原理</h3><p>master怎么知道slave与自己的数据差异在哪里呢?</p>
<p>这就要说到全量同步时的repl_backlog文件了。</p>
<p>这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖。</p>
<p>repl_backlog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725153359022.png" alt="image-20210725153359022"> </p>
<p>slave与master的offset之间的差异，就是slave需要增量拷贝的数据了。</p>
<p>随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725153524190.png" alt="image-20210725153524190"> </p>
<p>直到数组被填满：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725153715910.png" alt="image-20210725153715910"> </p>
<p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。</p>
<p>但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725153937031.png" alt="image-20210725153937031"> </p>
<p>slave : 5 master 110(10) 10-100错过的数据还在，错过了105-110(5-10)的数据</p>
<p>如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725154155984.png" alt="image-20210725154155984"> </p>
<p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725154216392.png" alt="image-20210725154216392"></p>
<h2 id="主从同步优化"><a href="#主从同步优化" class="headerlink" title="主从同步优化"></a>主从同步优化</h2><p>主从同步可以保证主从数据的一致性，非常重要。</p>
<p>可以从以下几个方面来优化Redis主从就集群：</p>
<ul>
<li><p>提高全量同步的性能</p>
<ul>
<li><p>在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。（磁盘慢，网络快）</p>
</li>
<li><p>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO（RDB 小）</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>适当提高repl_backlog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步(OFFSET_MAX)</li>
<li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力（减少压力）</li>
</ul>
<p>主从从架构图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725154405899.png" alt="image-20210725154405899"></p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><h3 id="简述全量同步和增量同步区别？"><a href="#简述全量同步和增量同步区别？" class="headerlink" title="简述全量同步和增量同步区别？"></a>简述全量同步和增量同步区别？</h3><ul>
<li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_backlog，逐个发送给slave。</li>
<li>增量同步：slave提交自己的offset到master，master获取repl_backlog中从offset之后的命令给slave</li>
</ul>
<h3 id="什么时候执行全量同步？"><a href="#什么时候执行全量同步？" class="headerlink" title="什么时候执行全量同步？"></a>什么时候执行全量同步？</h3><ul>
<li>slave节点第一次连接master节点时</li>
<li>slave节点断开时间太久，repl_backlog中的offset已经被覆盖时</li>
</ul>
<h3 id="什么时候执行增量同步？"><a href="#什么时候执行增量同步？" class="headerlink" title="什么时候执行增量同步？"></a>什么时候执行增量同步？</h3><ul>
<li>slave节点断开又恢复，并且在repl_backlog中能找到offset时</li>
</ul>
<h1 id="三、Redis哨兵集群：保证主从高可用性"><a href="#三、Redis哨兵集群：保证主从高可用性" class="headerlink" title="三、Redis哨兵集群：保证主从高可用性"></a>三、Redis哨兵集群：保证主从高可用性</h1><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。</p>
<h2 id="哨兵原理"><a href="#哨兵原理" class="headerlink" title="哨兵原理"></a>哨兵原理</h2><h3 id="集群结构和作用"><a href="#集群结构和作用" class="headerlink" title="集群结构和作用"></a>集群结构和作用</h3><p>哨兵的结构如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725154528072.png" alt="image-20210725154528072"></p>
<p>哨兵的作用如下：</p>
<ul>
<li><strong>监控</strong>：Sentinel 会不断检查您的master和slave是否按预期工作 </li>
<li><strong>自动故障恢复（转移）</strong>：如果master故障，Sentinel会<mark>将一个slave提升为master<mark>。当故障实例恢复后也以新的master为主</li>
<li><strong>通知</strong>：Sentinel充当Redis<mark>客户端的服务发现来源<mark>，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li>
</ul>
<h3 id="集群监控状态原理：心跳机制"><a href="#集群监控状态原理：心跳机制" class="headerlink" title="集群监控状态原理：心跳机制"></a>集群监控状态原理：心跳机制</h3><p>Sentinel基于<mark>心跳机制<mark>监测服务状态，每隔<mark>1秒<mark>向集群的每个实例<mark>发送ping命令<mark>：</p>
<p>•主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</p>
<p>•客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725154632354.png" alt="image-20210725154632354"></p>
<h3 id="集群故障恢复原理：选举机制"><a href="#集群故障恢复原理：选举机制" class="headerlink" title="集群故障恢复原理：选举机制"></a>集群故障恢复原理：选举机制</h3><p>一旦发现master故障，sentinel需要在slave中选择一个作为新的master，选择依据是这样的：</p>
<ul>
<li><strong>与master断开时间</strong>：首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</li>
<li><strong>优先级</strong>：然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</li>
<li><strong>offset</strong>：如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li>
<li><strong>运行id</strong>：最后是判断slave节点的运行id大小，越小优先级越高。每个 redis 节点启动时都有一个 40 字节随机字符串作为运行 id。</li>
</ul>
<p>当选出一个新的master后，该如何实现切换呢？</p>
<p>流程如下：</p>
<ul>
<li>sentinel给备选的slave1节点发送<code>slaveof no one</code>命令，让该节点成为master</li>
<li>sentinel给所有其它slave发送slaveof 127.0.0.1 7002(也就是slave1) 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</li>
<li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725154816841.png" alt="image-20210725154816841"></p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><h4 id="Sentinel的三个作用是什么？"><a href="#Sentinel的三个作用是什么？" class="headerlink" title="Sentinel的三个作用是什么？"></a>Sentinel的三个作用是什么？</h4><ul>
<li>监控</li>
<li>故障转移</li>
<li>通知</li>
</ul>
<h4 id="Sentinel如何判断一个redis实例是否健康？"><a href="#Sentinel如何判断一个redis实例是否健康？" class="headerlink" title="Sentinel如何判断一个redis实例是否健康？"></a>Sentinel如何判断一个redis实例是否健康？</h4><ul>
<li>每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线</li>
<li>如果大多数sentinel都认为实例主观下线，则判定服务下线</li>
</ul>
<h4 id="故障转移步骤有哪些？"><a href="#故障转移步骤有哪些？" class="headerlink" title="故障转移步骤有哪些？"></a>故障转移步骤有哪些？</h4><ul>
<li>首先选定一个slave作为新的master，执行slaveof no one</li>
<li>然后让所有节点(包括故障节点)都执行slaveof 新master</li>
<li>修改故障节点配置，添加slaveof 新master</li>
</ul>
<h2 id="搭建哨兵集群：master宕机案例"><a href="#搭建哨兵集群：master宕机案例" class="headerlink" title="搭建哨兵集群：master宕机案例"></a>搭建哨兵集群：master宕机案例</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119171035000.png" alt="image-20241119171035000"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119171850683.png" alt="image-20241119171850683"></p>
<p>从节点连不上主节点</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119172740595.png" alt="image-20241119172740595"></p>
<p>哨兵选举一个slave作为新的master</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119172833310.png" alt="image-20241119172833310"></p>
<p>被选中的slave变成master</p>
<h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。</p>
<p>下面，我们通过一个测试来实现RedisTemplate集成哨兵机制。</p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>在项目的pom文件中引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置Redis哨兵集群地址"><a href="#配置Redis哨兵集群地址" class="headerlink" title="配置Redis哨兵集群地址"></a>配置Redis哨兵集群地址</h3><p>然后在配置文件application.yml中指定redis的sentinel相关信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    sentinel:</span><br><span class="line">      master: mymaster</span><br><span class="line">      nodes:</span><br><span class="line">        - <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">27001</span><span class="comment">//哨兵一号</span></span><br><span class="line">        - <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">27002</span></span><br><span class="line">        - <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">27003</span></span><br></pre></td></tr></table></figure>

<p>哨兵的启动配置文件里已经有了主节点的一切信息，IP+PORT+quorum+name，只需要引入哨兵就能启用集群</p>
<h3 id="配置读写分离"><a href="#配置读写分离" class="headerlink" title="配置读写分离"></a>配置读写分离</h3><p>在项目的启动类中，添加一个新的bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="title function_">clientConfigurationBuilderCustomizer</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个bean中配置的就是读写策略，包括四种：</p>
<ul>
<li>MASTER：从主节点读取</li>
<li>MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica</li>
<li>REPLICA：从slave（replica）节点读取</li>
<li><mark>REPLICA _PREFERRED<mark>：优先从slave（replica）节点读取，所有的slave都不可用才读取master</li>
</ul>
<p>每个节点都会建立连接，读取时会按照读写分离的策略读。</p>
<h1 id="四、Redis分片集群：应对高并发写、海量数据存储"><a href="#四、Redis分片集群：应对高并发写、海量数据存储" class="headerlink" title="四、Redis分片集群：应对高并发写、海量数据存储"></a>四、Redis分片集群：应对高并发写、海量数据存储</h1><p>Redis Cluster 解决了哨兵机制的弊端：每个实例全量存储，木桶效应，提供动态的横向扩展，</p>
<h2 id="纵向-横向扩展"><a href="#纵向-横向扩展" class="headerlink" title="纵向/横向扩展"></a>纵向/横向扩展</h2><p>纵向也可以多节点，纵/横的标准是：是否所有节点的存储内容都一样</p>
<p>究竟选择scale-up（纵向）还是scale-out（横向）架构,主要考虑以下因素：</p>
<table>
<thead>
<tr>
<th align="center">成本</th>
<th align="left">Scale-up架构只有容量升级的成本，不会增加控制器或基础设施的开销。如果我们主要衡量每GB存储的单位价格，scale-up的扩展方式无疑更便宜一些</th>
</tr>
</thead>
<tbody><tr>
<td align="center">容量</td>
<td align="left">两种解决方案都可以满足容量需求，但scale-up架构也许会有些限制，主要取决于单个系统最大支持多少个磁盘数量和多大的容量</td>
</tr>
<tr>
<td align="center">性能</td>
<td align="left">Scale-out架构在性能上具有扩展潜力，在多个存储控制器下，IOPS处理能力和吞吐带宽都可以聚合。虽然节点之间的通信会引发延迟，但那是部署时的细节问题</td>
</tr>
<tr>
<td align="center">管理</td>
<td align="left">Scale-up架构本身就是以单一系统的方式来进行管理的。而Scale-out架构通常有聚合管理的能力，但每个厂商提供的产品可能会有所不同</td>
</tr>
<tr>
<td align="center">复杂性</td>
<td align="left">Scale-up架构的存储相对简单，而scale-out架构的系统会更复杂一些，毕竟每个节点都需要管理</td>
</tr>
<tr>
<td align="center">可用性</td>
<td align="left">多个节点可以提供更好的可用性，假使有一个部件故障或失效，系统也不至于整体宕机。这一点与具体的实施方案也有关系</td>
</tr>
</tbody></table>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119184050478.png" alt="Scale-UP 纵向扩展"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119184124945.png" alt="Scale-OUT 横向扩展"></p>
<h2 id="搭建分片集群"><a href="#搭建分片集群" class="headerlink" title="搭建分片集群"></a>搭建分片集群</h2><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p>
<ul>
<li><p><mark>海量数据存储问题<mark></p>
</li>
<li><p><mark>高并发写的问题<mark></p>
</li>
</ul>
<p>使用横向扩展分片集群可以解决上述问题，如图:</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725155747294.png" alt="分片集群"></p>
<p>分片集群特征：</p>
<ul>
<li><p>集群中有多个master，每个master保存不同数据</p>
</li>
<li><p>每个master都可以有多个slave节点（高可用）</p>
</li>
<li><p>slave 不对外提供读服务，主要用来保障 master 的高可用，做数据的热备份，当 master 出现故障的时候替代它。</p>
</li>
<li><p>master之间通过ping监测彼此健康状态（全员哨兵）</p>
</li>
<li><p>客户端请求可以访问集群任意节点，最终都会被自动路由转发到正确节点（自动路由）</p>
</li>
</ul>
<p>本质就是多个主从集群的互相监控，不需要另外sentinel的监控，不过此时的slave</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 开启集群功能</span></span><br><span class="line"><span class="attr">cluster-enabled</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># 集群的配置文件名称，不需要我们创建，由redis自己维护</span></span><br><span class="line"><span class="attr">cluster-config-file</span> <span class="string">/root/redissetup/6379/nodes.conf</span></span><br><span class="line"><span class="comment"># 节点心跳失败的超时时间</span></span><br><span class="line"><span class="attr">cluster-node-timeout</span> <span class="string">5000</span></span><br><span class="line"><span class="comment"># 持久化</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">/root/redissetup/6379</span></span><br><span class="line"></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># 主从ip地址</span></span><br><span class="line"><span class="attr">replica-announce-ip</span> <span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment"># 保护模式</span></span><br><span class="line"><span class="attr">protected-mode</span> <span class="string">no</span></span><br><span class="line"></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 日志记录</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">/root/redissetup/6379/run.log</span></span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t sed -i <span class="string">&#x27;s/6379/&#123;&#125;/g&#x27;</span> &#123;&#125;/redis.conf</span><br><span class="line"><span class="comment"># 编辑端口号</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-server &#123;&#125;/redis.conf</span><br><span class="line"><span class="comment"># 开启服务器实例</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas 1 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:8001 127.0.0.1:8002 127.0.0.1:8003</span><br><span class="line"><span class="comment"># 开启分片集群功能</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119193312708.png" alt="image-20241119193312708"></p>
<p>6/(1+1) = 3</p>
<p>！！！！！！！！</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119201022033.png" alt="image-20241119201022033"></p>
<p>启动一定加 -c</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119203336515.png" alt="image-20241119203336515"></p>
<p>查看节点状况</p>
<h2 id="散列插槽"><a href="#散列插槽" class="headerlink" title="散列插槽"></a>散列插槽</h2><h3 id="插槽原理"><a href="#插槽原理" class="headerlink" title="插槽原理"></a>插槽原理</h3><p>Redis Cluster 并没有使用一致性哈希，采用的是 哈希槽分区 ，每一个键值对都属于一个 hash slot（哈希槽） 。</p>
<p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725155820320.png" alt="image-20210725155820320"></p>
<p>数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p>
<ul>
<li><mark>key中包含”{}”，且“{}”中至少包含1个字符，“{}”中的部分是有效部分<mark> </li>
<li>key中不包含“{}”，整个key都是有效部分</li>
</ul>
<p>例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119201236259.png" alt="image-20241119201236259"> </p>
<p>如图，在7001这个节点执行set a 1时，对a做hash运算，对16384取余，得到的结果是15495，因此要存储到7003节点。</p>
<p>到了7003后，执行<code>get num</code>时，对num做hash运算，对16384取余，得到的结果是2765，因此需要切换到7001节点</p>
<p>当客户端发送命令请求的时候，需要</p>
<ul>
<li>先根据 key 找到的对应的哈希槽，</li>
<li>然后再查询哈希槽和节点的映射关系，即可找到目标节点。 </li>
</ul>
<h3 id="哈希槽数目为什么选择-16384？"><a href="#哈希槽数目为什么选择-16384？" class="headerlink" title="哈希槽数目为什么选择 16384？"></a>哈希槽数目为什么选择 16384？</h3><p><code>CRC16</code>算法产生的hash值有16bit，该算法可以产生2^16-=65536个值。换句话说，值是分布在0~65535之间。那作者在做<code>mod</code>运算的时候，为什么不<code>mod</code>65536，而选择<code>mod</code>16384？</p>
<p>哈希槽的数量选择 16384 而不是 65536 的主要原因：</p>
<ul>
<li>哈希槽太大会导致心跳包（包括slots信息）太大，消耗太多带宽； </li>
<li>哈希槽总数越少，对存储哈希槽信息的 bitmap 压缩效果越好； </li>
<li>Redis Cluster 的主节点通常不会扩展太多，16384 个哈希槽已经足够用了。</li>
</ul>
<p>一致性哈希理论上可以有2^32^个节点，实际上不会有那么多，</p>
<p>正常的心跳包会携带一个节点的完整配置，它会以幂等的方式更新旧的配置，这意味着心跳包会附 带当前节点的负责的哈希槽的信息。假设哈希槽采用 16384 ,则占空间 2k(16384/8)。假设哈希槽 采用 65536， 则占空间 8k(65536/8)，这是令人难以接受的内存占用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 省略部分字段</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 本节点负责的哈希槽信息,16384/8 个 char 数组，一共为16384bit</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> myslots[CLUSTER_SLOTS/<span class="number">8</span>];</span><br><span class="line">    <span class="comment">// 集群的状态</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> state;</span><br><span class="line">    <span class="comment">// 消息的内容</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">clusterMsgData</span> <span class="title">data</span>;</span></span><br><span class="line">&#125; clusterMsg;</span><br></pre></td></tr></table></figure>

<p>可以看到哈希槽是使用槽位数/8 使用一个char数组来表示，这里实际就是通过 bitmap 这种数据结构维护的哈希槽信息，每一个 bit 代表一个哈希槽，每个 bit 只能 存储 0/1 。如果该位为 1，表示这个哈希槽是属于这个节点。</p>
<p>虽说 Redis Cluster 可以扩展到 1000 个节点，但强烈不推荐这样做，应尽量避免集群中的节点过多。这 是因为 Redis Cluster 中的各个节点基于 Gossip 协议 来进行通信共享信息，当节点过多时，<strong>Gossip</strong> 协议的效率会显著下降，通信成本剧增。请注意，在小簇中，位图将很难压缩，因为当 N 很小时，位图将具有插槽/N 位设置，这是位设置的很大百分比。</p>
<h3 id="为什么不采用一致性哈希？"><a href="#为什么不采用一致性哈希？" class="headerlink" title="为什么不采用一致性哈希？"></a>为什么不采用一致性哈希？</h3><p>一致性哈希：为了防止节点和数据绑定，将整个哈希结果构造为一个2^32的域，服务器名称也在域中，根据key的哈希结果和服务器的位置关系判断应该访问哪个服务器。（狭义上）</p>
<p>为啥redis cluster 不设置 2的32次方个槽位呢？主要是考虑节点数在1000的规模左右，而使用 <strong>Gossip</strong> 去中心一致性协议，数据包不能太大，16K 个二进制位 2K字节已经很大了。</p>
<p>Redis 选择哈希插槽，是因为其设计目标（强一致性、高可用性）与哈希插槽的特性高度契合，而一致性哈希更适合对扩展性要求更高、允许最终一致性的场景（如缓存系统）。</p>
<ul>
<li><p>一致性hash 哈希环顺时针映射 优先考虑的是： 如何实现 最少的节点数据发生数据迁移。</p>
<p>一致性hash 哈希环上面，只有被干掉的节点顺时针方向最近的那一个节点涉及到数据迁移；其他间隔较远的节点，不涉及到数据迁移。迁移范围仅限环上相邻节点间的键。</p>
</li>
<li><p>redis cluster 哈希槽静态映射 优先考虑的是： 如何 实现数据的均匀。</p>
<p>槽位是逻辑单位，节点是物理单位，二者通过配置文件或集群协议关联。<strong>映射关系由集群元数据控制</strong>（如 Redis Cluster 的 Gossip 协议同步），客户端需缓存槽位分布表。</p>
<p>redis cluster 各个节点都会参与数据迁移，优先保证各个redis节点承担同样的访问压力。</p>
</li>
<li><p>同时，redis cluster 哈希槽静态映射还有一个优点，<mark>手动迁移<mark>。</p>
<p>redis cluster 可以自动分配，也可以根据节点的性能（比如Memory大小） 手动的调整slot的分配。</p>
</li>
</ul>
<h3 id="如何判断某个key应该在哪个实例？"><a href="#如何判断某个key应该在哪个实例？" class="headerlink" title="如何判断某个key应该在哪个实例？"></a>如何判断某个key应该在哪个实例？</h3><ul>
<li>将16384个插槽分配到不同的实例</li>
<li>根据key的有效部分计算哈希值，对16384取余</li>
<li>余数作为插槽，寻找插槽所在实例即可</li>
</ul>
<h3 id="如何将同一类数据固定的保存在同一个实例？"><a href="#如何将同一类数据固定的保存在同一个实例？" class="headerlink" title="如何将同一类数据固定的保存在同一个实例？"></a>如何将同一类数据固定的保存在同一个实例？</h3><p>不同节点之间的切换比较耗时，所以同类的key尽量存在同一个节点上面</p>
<ul>
<li>这一类数据使用相同的有效部分，例如key都以{typeId}为前缀</li>
</ul>
<p><mark>要清楚的一点：<mark>数据不存在hash插槽上，因此也不存在哈希冲突这一说，key映射到某个哈希插槽仅仅说明它属于XX节点，将来相同key也会去找相同的节点，仅此而已。</p>
<h2 id="集群伸缩：插槽迁移"><a href="#集群伸缩：插槽迁移" class="headerlink" title="集群伸缩：插槽迁移"></a>集群伸缩：插槽迁移</h2><p>redis-cli –cluster提供了很多操作集群的命令，可以通过下面方式查看：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725160138290.png" alt="image-20210725160138290"></p>
<p>比如，添加节点的命令：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725160448139.png" alt="image-20210725160448139"></p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>需求：向集群中添加一个新的master节点，并向其中存储 num = 10</p>
<ul>
<li>启动一个新的redis实例，端口为7004</li>
<li>添加7004到之前的集群，并作为一个master节点</li>
<li>给7004节点分配插槽，使得num这个key可以存储到7004实例</li>
</ul>
<p>这里需要两个新的功能：</p>
<ul>
<li>添加一个节点到集群中</li>
<li>将部分插槽分配到新插槽</li>
</ul>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><h4 id="创建新的redis实例"><a href="#创建新的redis实例" class="headerlink" title="创建新的redis实例"></a>创建新的redis实例</h4><p>创建一个文件夹：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> 7004</span><br></pre></td></tr></table></figure>

<p>拷贝配置文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> redis.conf /7004</span><br></pre></td></tr></table></figure>

<p>修改配置文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed /s/6379/7004/g 7004/redis.conf</span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server 7004/redis.conf</span><br></pre></td></tr></table></figure>



<h4 id="添加新节点到redis"><a href="#添加新节点到redis" class="headerlink" title="添加新节点到redis"></a>添加新节点到redis</h4><p>添加节点的语法如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725160448139.png" alt="image-20210725160448139"></p>
<p>执行命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node  127.0.0.1:7004 127.0.0.1:7001</span><br></pre></td></tr></table></figure>



<p>通过命令查看集群状态：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></table></figure>



<p>如图，7004加入了集群，并且默认是一个master节点：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161007099.png" alt="image-20210725161007099"></p>
<p>但是，可以看到7004节点的插槽数量为0，因此没有任何数据可以存储到7004上</p>
<h4 id="转移插槽"><a href="#转移插槽" class="headerlink" title="转移插槽"></a>转移插槽</h4><p>每个数据都有对应的插槽编号，可以根据编号查出数据</p>
<p>我们要将num存储到7004节点，因此需要先看看num的插槽是多少：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161241793.png" alt="image-20210725161241793"></p>
<p>如上图所示，num的插槽为2765.</p>
<p>我们可以将0~3000的插槽从7001转移到7004，命令格式如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161401925.png" alt="image-20210725161401925"></p>
<p>具体命令如下：</p>
<p>建立连接：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161506241.png" alt="image-20210725161506241"></p>
<p>得到下面的反馈：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161540841.png" alt="image-20210725161540841"></p>
<p>询问要移动多少个插槽，我们计划是3000个：新的问题来了：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161637152.png" alt="image-20210725161637152"></p>
<p>那个node来接收这些插槽？？显然是7004，那么7004节点的id是多少呢？</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161731738.png" alt="image-20210725161731738"></p>
<p>复制这个id，然后拷贝到刚才的控制台后：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725161817642.png" alt="image-20210725161817642"></p>
<p>这里询问，你的插槽是从哪里移动过来的？</p>
<ul>
<li>all：代表全部，也就是三个节点各转移一部分</li>
<li>具体的id：目标节点的id</li>
<li>done：没有了</li>
</ul>
<p>这里我们要从7001获取，因此填写7001的id：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725162030478.png" alt="image-20210725162030478"></p>
<p>填完后，点击done，这样插槽转移就准备好了：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725162101228.png" alt="image-20210725162101228"></p>
<p>确认要转移吗？输入yes：然后，通过命令查看结果：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725162145497.png" alt="image-20210725162145497"> </p>
<p>可以看到： </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725162224058.png" alt="image-20210725162224058"></p>
<p>目的达成。</p>
<h3 id="迁移流程：集群节点的数据结构"><a href="#迁移流程：集群节点的数据结构" class="headerlink" title="迁移流程：集群节点的数据结构"></a>迁移流程：集群节点的数据结构</h3><p>每个节点都有一个对应的clusterNode clusterState结构</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E6%97%A0%E6%A0%87%E9%A2%98.jpg"></p>
<p>存储的时候，会根据key计算哈希，这是key到哈希槽位的映射，</p>
<p>迁移的时候，如果遍历整个数据库，分别计算哈希，效率低下，因此节点自身用一个跳表slots_to_key维护槽位到key的映射，score是槽位号，member是key值    </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sulishihupan/p/14538864.html">Redis–集群Cluster（槽指派、重新分片） - 苏黎世湖畔 - 博客园 (cnblogs.com)</a> </p>
<p>假设将 <code>0-3000</code> 插槽从节点 A 迁移至节点 B：</p>
<ol>
<li>节点 A 标记为 <code>MIGRATING</code>，表示它即将释放这些插槽。节点 B 标记为 <code>IMPORTING</code>，表示它即将接管这些插槽。</li>
<li>通知所有节点，让客户端感知到这些插槽的迁移状态，确保客户端请求能够动态路由到正确的节点。</li>
</ol>
<h2 id="故障转移：全员哨兵"><a href="#故障转移：全员哨兵" class="headerlink" title="故障转移：全员哨兵"></a>故障转移：全员哨兵</h2><p>clusterState结构中，有一个nodes，指向其他节点，因此能够实现全员哨兵</p>
<p>有了 Redis Cluster 之后，不需要专门部署 Sentinel 集群服务了。Redis Cluster 相当于是内置了 Sentinel 机制，Redis Cluster 内部的各个 Redis 节点通过 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/463455831">Gossip 协议</a>互相探测健康状态，在故障时可 以自动切换。</p>
<p>集群初始状态是这样的：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210727161152065.png" alt="image-20210727161152065"></p>
<p>其中7001、7002、7003都是master，我们计划让7002宕机。</p>
<h3 id="自动故障转移"><a href="#自动故障转移" class="headerlink" title="自动故障转移"></a>自动故障转移</h3><p>当集群中有一个master宕机会发生什么呢？</p>
<p>直接停止一个redis实例，例如7002：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7002 shutdown</span><br></pre></td></tr></table></figure>

<p>1）首先是该实例与其它实例失去连接</p>
<p>2）然后是疑似宕机：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725162319490.png" alt="image-20210725162319490"></p>
<p>3）最后是确定下线，自动提升一个slave为新的master：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725162408979.png" alt="image-20210725162408979"></p>
<p>4）当7002再次启动，就会变为一个slave节点了：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210727160803386.png" alt="image-20210727160803386"></p>
<h3 id="手动故障转移"><a href="#手动故障转移" class="headerlink" title="手动故障转移"></a>手动故障转移</h3><p>利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210725162441407.png" alt="image-20210725162441407"></p>
<p>这种failover命令可以指定三种模式：</p>
<ul>
<li>缺省：默认的流程，如图1~6歩</li>
<li>force：省略了对offset的一致性校验</li>
<li>takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见</li>
</ul>
<p><strong>案例需求</strong>：在7002这个slave节点执行手动故障转移，重新夺回master地位</p>
<p>步骤如下：</p>
<p>1）利用redis-cli连接7002这个节点</p>
<p>2）执行cluster failover命令</p>
<p>如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210727160037766.png" alt="image-20210727160037766"></p>
<p>效果：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210727161152065.png" alt="image-20210727161152065"></p>
<h2 id="客户端访问分片集群"><a href="#客户端访问分片集群" class="headerlink" title="客户端访问分片集群"></a>客户端访问分片集群</h2><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：</p>
<p>1）引入redis的starter依赖</p>
<p>2）配置分片集群地址</p>
<p>3）配置读写分离</p>
<p>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">cluster:</span></span><br><span class="line">      <span class="attr">nodes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:7001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:7002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:7003</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8003</span></span><br></pre></td></tr></table></figure>

<h3 id="客户端访问时集群正在迁移数据"><a href="#客户端访问时集群正在迁移数据" class="headerlink" title="客户端访问时集群正在迁移数据"></a>客户端访问时集群正在迁移数据</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241119212106075.png" alt="image-20241119212106075"></p>
<h4 id="ASK"><a href="#ASK" class="headerlink" title="ASK"></a>ASK</h4><ol>
<li>客户端发送请求命令，如果请求的 key 对应的哈希槽还在当前节点，就直接响应客户端的请求。如果客户端请求的 key 对应的哈希槽当前正在迁移至新的节点，就会返回<code>-ASK</code> 重定向错误，告知客户端要将请求发送到哈希槽被迁移到的目标节点。</li>
<li>客户端收到<code>-ASK</code>重定向错误后，将会临时（一次性）重定向，自动向目标节点发送一条 ASKING 命令。也就是说，接收到 ASKING 命令的节点会强制执行一次请求，下次再来需要重新提前发送 ASKING 命令。</li>
<li>ASK 重定向并不会同步更新客户端缓存的哈希槽分配信息，也就是说，客户端对正在迁移的相同哈希槽的请求依然会发送到原节点而不是目标节点。</li>
</ol>
<h4 id="MOVED"><a href="#MOVED" class="headerlink" title="MOVED"></a>MOVED</h4><ol>
<li>当客户端请求的 key 对应的哈希槽迁移完成，就会返回 -MOVED 重定向错误，告知客户端当前哈希槽是由哪个节点负责，客户端向目标节点发送请求并更新缓存的哈希槽分配信息。</li>
</ol>
<h4 id="客户端缓存插槽与节点映射表"><a href="#客户端缓存插槽与节点映射表" class="headerlink" title="客户端缓存插槽与节点映射表"></a>客户端缓存插槽与节点映射表</h4><p>当 Redis 客户端连接到集群时，会通过 <code>CLUSTER SLOTS</code> 命令从 Redis 获取插槽与节点的对应关系。客户端将这张表缓存起来，用于后续操作中快速定位目标节点，而无需每次操作都向服务器查询。减少了每次请求都需要额外的网络交互来查询插槽分布，增加延迟。</p>
<p>缓存后，客户端可以直接根据键快速定位目标节点并发送请求。</p>
<h1 id="——多级缓存——"><a href="#——多级缓存——" class="headerlink" title="——多级缓存——"></a>——多级缓存——</h1><h1 id="一、什么是多级缓存"><a href="#一、什么是多级缓存" class="headerlink" title="一、什么是多级缓存"></a>一、什么是多级缓存</h1><p>传统的缓存策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821075259137.png" alt="image-20210821075259137"></p>
<p>存在下面的问题：</p>
<p>•请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈</p>
<p>•Redis缓存失效时，会对数据库产生冲击</p>
<p>多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能：</p>
<ul>
<li>浏览器访问静态资源时，优先读取浏览器本地缓存</li>
<li>访问非静态资源（ajax查询数据）时，访问服务端</li>
<li>请求到达Nginx后，优先读取Nginx本地缓存</li>
<li>如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）</li>
<li>如果Redis查询未命中，则查询Tomcat</li>
<li>请求进入Tomcat后，优先查询JVM进程缓存</li>
<li>如果JVM进程缓存未命中，则查询数据库</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821075558137.png" alt="image-20210821075558137"></p>
<p>在多级缓存架构中，Nginx内部需要编写本地缓存查询、Redis查询、Tomcat查询的业务逻辑，因此这样的nginx服务不再是一个<strong>反向代理服务器</strong>，而是一个编写<strong>业务的Web服务器了</strong>。</p>
<p>因此这样的业务Nginx服务也需要搭建集群来提高并发，再有专门的nginx服务来做反向代理，如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821080511581.png" alt="image-20210821080511581"></p>
<p>另外，我们的Tomcat服务将来也会部署为集群模式：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821080954947.png" alt="image-20210821080954947"></p>
<p>可见，多级缓存的关键有两个：</p>
<ul>
<li><p>一个是在nginx中编写业务，实现nginx本地缓存、Redis、Tomcat的查询</p>
</li>
<li><p>另一个就是在Tomcat中实现JVM进程缓存</p>
</li>
</ul>
<p>其中Nginx编程则会用到OpenResty框架结合Lua这样的语言。</p>
<h1 id="二、JVM进程缓存"><a href="#二、JVM进程缓存" class="headerlink" title="二、JVM进程缓存"></a>二、JVM进程缓存</h1><p>为了演示多级缓存的案例，我们先准备一个商品查询的业务。</p>
<h2 id="导入案例"><a href="#导入案例" class="headerlink" title="导入案例"></a>导入案例</h2><p>参考课前资料的：《案例导入说明.md》</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821081418456.png" alt="image-20210821081418456"> </p>
<h2 id="初识Caffeine"><a href="#初识Caffeine" class="headerlink" title="初识Caffeine"></a>初识Caffeine</h2><p>缓存在日常开发中启动至关重要的作用，由于是存储在内存中，数据的读取速度是非常快的，能大量减少对数据库的访问，减少数据库的压力。我们把缓存分为两类：</p>
<ul>
<li>分布式缓存，例如Redis：<ul>
<li>优点：存储容量更大、可靠性更好、可以在集群间共享</li>
<li>缺点：访问缓存有网络开销</li>
<li>场景：缓存数据量较大、可靠性要求较高、需要在集群间共享</li>
</ul>
</li>
<li>进程本地缓存，例如HashMap、GuavaCache：<ul>
<li>优点：读取本地内存，没有网络开销，速度更快</li>
<li>缺点：存储容量有限、可靠性较低、无法共享</li>
<li>场景：性能要求较高，缓存数据量较小</li>
</ul>
</li>
</ul>
<p>我们今天会利用Caffeine框架来实现JVM进程缓存。</p>
<p><strong>Caffeine</strong>是一个基于Java8开发的，提供了近乎最佳命中率的高性能的本地缓存库。目前Spring内部的缓存使用的就是Caffeine。GitHub地址：<a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine">https://github.com/ben-manes/caffeine</a></p>
<p>Caffeine的性能非常好，下图是官方给出的性能对比：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821081826399.png" alt="image-20210821081826399"></p>
<p>可以看到Caffeine的性能遥遥领先！</p>
<p>缓存使用的基本API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBasicOps</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 构建cache对象</span></span><br><span class="line">    Cache&lt;String, String&gt; cache = Caffeine.newBuilder().build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存数据</span></span><br><span class="line">    cache.put(<span class="string">&quot;gf&quot;</span>, <span class="string">&quot;迪丽热巴&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">gf</span> <span class="operator">=</span> cache.getIfPresent(<span class="string">&quot;gf&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;gf = &quot;</span> + gf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取数据，包含两个参数：</span></span><br><span class="line">    <span class="comment">// 参数一：缓存的key</span></span><br><span class="line">    <span class="comment">// 参数二：Lambda表达式，表达式参数就是缓存的key，方法体是查询数据库的逻辑</span></span><br><span class="line">    <span class="comment">// 优先根据key查询JVM缓存，如果未命中，则执行参数二的Lambda表达式</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">defaultGF</span> <span class="operator">=</span> cache.get(<span class="string">&quot;defaultGF&quot;</span>, key -&gt; &#123;</span><br><span class="line">        <span class="comment">// 根据key去数据库查询数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;柳岩&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;defaultGF = &quot;</span> + defaultGF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>Caffeine既然是缓存的一种，肯定需要有缓存的清除策略，不然的话内存总会有耗尽的时候。</p>
<p>Caffeine提供了三种缓存驱逐策略：</p>
<ul>
<li><p><strong>基于容量</strong>：设置缓存的数量上限</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建缓存对象</span></span><br><span class="line">Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">1</span>) <span class="comment">// 设置缓存大小上限为 1</span></span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>基于时间</strong>：设置缓存的有效时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建缓存对象</span></span><br><span class="line">Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    <span class="comment">// 设置缓存有效期为 10 秒，从最后一次写入开始计时 </span></span><br><span class="line">    .expireAfterWrite(Duration.ofSeconds(<span class="number">10</span>)) </span><br><span class="line">    .build();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong>基于引用</strong>：设置缓存为软引用或弱引用，利用GC来回收缓存数据。性能较差，不建议使用。</p>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>：在默认情况下，当一个缓存元素过期的时候，Caffeine不会自动立即将其清理和驱逐。而是在一次读或写操作后，或者在空闲时间完成对失效数据的驱逐。</p>
</blockquote>
<h2 id="实现JVM进程缓存"><a href="#实现JVM进程缓存" class="headerlink" title="实现JVM进程缓存"></a>实现JVM进程缓存</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>利用Caffeine实现下列需求：</p>
<ul>
<li>给根据id查询商品的业务添加缓存，缓存未命中时查询数据库</li>
<li>给根据id查询商品库存的业务添加缓存，缓存未命中时查询数据库</li>
<li>缓存初始大小为100</li>
<li>缓存上限为10000</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>首先，我们需要定义两个Caffeine的缓存对象，分别保存商品、库存的缓存数据。</p>
<p>在item-service的<code>com.heima.item.config</code>包下定义<code>CaffeineConfig</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Caffeine;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.ItemStock;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaffeineConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cache&lt;Long, Item&gt; <span class="title function_">itemCache</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Caffeine.newBuilder()</span><br><span class="line">                .initialCapacity(<span class="number">100</span>)</span><br><span class="line">                .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cache&lt;Long, ItemStock&gt; <span class="title function_">stockCache</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Caffeine.newBuilder()</span><br><span class="line">                .initialCapacity(<span class="number">100</span>)</span><br><span class="line">                .maximumSize(<span class="number">10_000</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后，修改item-service中的<code>com.heima.item.web</code>包下的ItemController类，添加缓存逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;item&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemService itemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemStockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;Long, Item&gt; itemCache;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;Long, ItemStock&gt; stockCache;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...其它略</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemCache.get(id, key -&gt; itemService.query()</span><br><span class="line">                .ne(<span class="string">&quot;status&quot;</span>, <span class="number">3</span>).eq(<span class="string">&quot;id&quot;</span>, key)</span><br><span class="line">                .one()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/stock/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ItemStock <span class="title function_">findStockById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stockCache.get(id, key -&gt; stockService.getById(key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="三、Lua语法入门"><a href="#三、Lua语法入门" class="headerlink" title="三、Lua语法入门"></a>三、Lua语法入门</h1><p>Nginx编程需要用到Lua语言，因此我们必须先入门Lua的基本语法。</p>
<h2 id="初识Lua"><a href="#初识Lua" class="headerlink" title="初识Lua"></a>初识Lua</h2><p>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。官网：<a target="_blank" rel="noopener" href="https://www.lua.org/">https://www.lua.org/</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821091437975.png" alt="image-20210821091437975"></p>
<p>Lua经常嵌入到C语言开发的程序中，例如游戏开发、游戏插件等。</p>
<p>Nginx本身也是C语言开发，因此也允许基于Lua做拓展。</p>
<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>CentOS7默认已经安装了Lua语言环境，所以可以直接运行Lua代码。</p>
<p>1）在Linux虚拟机的任意目录下，新建一个hello.lua文件</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821091621308.png" alt="image-20210821091621308"></p>
<p>2）添加下面的内容</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)  </span><br></pre></td></tr></table></figure>



<p>3）运行</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821091638140.png" alt="image-20210821091638140"></p>
<h2 id="变量和循环"><a href="#变量和循环" class="headerlink" title="变量和循环"></a>变量和循环</h2><p>学习任何语言必然离不开变量，而变量的声明必须先知道数据的类型。</p>
<h3 id="Lua的数据类型"><a href="#Lua的数据类型" class="headerlink" title="Lua的数据类型"></a>Lua的数据类型</h3><p>Lua中支持的常见数据类型包括：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821091835406.png" alt="image-20210821091835406"></p>
<p>另外，Lua提供了type()函数来判断一个变量的数据类型：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821091904332.png" alt="image-20210821091904332"></p>
<h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><p>Lua声明变量的时候无需指定数据类型，而是用local来声明变量为局部变量：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明字符串，可以用单引号或双引号，</span></span><br><span class="line"><span class="keyword">local</span> str = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">-- 字符串拼接可以使用 ..</span></span><br><span class="line"><span class="keyword">local</span> str2 = <span class="string">&#x27;hello&#x27;</span> .. <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="comment">-- 声明数字</span></span><br><span class="line"><span class="keyword">local</span> num = <span class="number">21</span></span><br><span class="line"><span class="comment">-- 声明布尔类型</span></span><br><span class="line"><span class="keyword">local</span> flag = <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<p>Lua中的table类型既可以作为数组，又可以作为Java中的map来使用。数组就是特殊的table，key是数组角标而已：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明数组 ，key为角标的 table</span></span><br><span class="line"><span class="keyword">local</span> arr = &#123;<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;lua&#x27;</span>&#125;</span><br><span class="line"><span class="comment">-- 声明table，类似java的map</span></span><br><span class="line"><span class="keyword">local</span> map =  &#123;name=<span class="string">&#x27;Jack&#x27;</span>, age=<span class="number">21</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Lua中的数组角标是从1开始，访问的时候与Java中类似：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 访问数组，lua数组的角标从1开始</span></span><br><span class="line"><span class="built_in">print</span>(arr[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>Lua中的table可以用key来访问：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 访问table</span></span><br><span class="line"><span class="built_in">print</span>(map[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(map.name)</span><br></pre></td></tr></table></figure>



<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>对于table，我们可以利用for循环来遍历。不过数组和普通table遍历略有差异。</p>
<p>遍历数组：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明数组 key为索引的 table</span></span><br><span class="line"><span class="keyword">local</span> arr = &#123;<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;lua&#x27;</span>&#125;</span><br><span class="line"><span class="comment">-- 遍历数组</span></span><br><span class="line"><span class="keyword">for</span> index,value <span class="keyword">in</span> <span class="built_in">ipairs</span>(arr) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(index, value) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>遍历普通table</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明map，也就是table</span></span><br><span class="line"><span class="keyword">local</span> map = &#123;name=<span class="string">&#x27;Jack&#x27;</span>, age=<span class="number">21</span>&#125;</span><br><span class="line"><span class="comment">-- 遍历table</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> <span class="built_in">pairs</span>(map) <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(key, value) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>







<h2 id="条件控制、函数"><a href="#条件控制、函数" class="headerlink" title="条件控制、函数"></a>条件控制、函数</h2><p>Lua中的条件控制和函数声明与Java类似。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>定义函数的语法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名<span class="params">( argument1, argument2..., argumentn)</span></span></span><br><span class="line">    <span class="comment">-- 函数体</span></span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>例如，定义一个函数，用来打印数组：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArr</span><span class="params">(arr)</span></span></span><br><span class="line">    <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">ipairs</span>(arr) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h3><p>类似Java的条件控制，例如if、else语法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 布尔表达式为 true 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="comment">--[ 布尔表达式为 false 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>与java不同，布尔表达式中的逻辑运算是基于英文单词：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821092657918.png" alt="image-20210821092657918"></p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>需求：自定义一个函数，可以打印table，当参数为nil时，打印错误信息</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArr</span><span class="params">(arr)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> arr <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;数组不能为空！&#x27;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">ipairs</span>(arr) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>





<h1 id="四、实现多级缓存"><a href="#四、实现多级缓存" class="headerlink" title="四、实现多级缓存"></a>四、实现多级缓存</h1><p>多级缓存的实现离不开Nginx编程，而Nginx编程又离不开OpenResty。</p>
<h2 id="安装OpenResty"><a href="#安装OpenResty" class="headerlink" title="安装OpenResty"></a>安装OpenResty</h2><p>OpenResty® 是一个基于 Nginx的高性能 Web 平台，用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。具备下列特点：</p>
<ul>
<li>具备Nginx的完整功能</li>
<li>基于Lua语言进行扩展，集成了大量精良的 Lua 库、第三方模块</li>
<li>允许使用Lua<strong>自定义业务逻辑</strong>、<strong>自定义库</strong></li>
</ul>
<p>官方网站： <a target="_blank" rel="noopener" href="https://openresty.org/cn/">https://openresty.org/cn/</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821092902946.png" alt="image-20210821092902946"></p>
<p>安装Lua可以参考课前资料提供的《安装OpenResty.md》：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821092941139.png" alt="image-20210821092941139"> </p>
<h2 id="OpenResty快速入门"><a href="#OpenResty快速入门" class="headerlink" title="OpenResty快速入门"></a>OpenResty快速入门</h2><p>我们希望达到的多级缓存架构如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/yeVDlwtfMx.png" alt="yeVDlwtfMx"></p>
<p>其中：</p>
<ul>
<li><p>windows上的nginx用来做反向代理服务，将前端的查询商品的ajax请求代理到OpenResty集群</p>
</li>
<li><p>OpenResty集群用来编写多级缓存业务</p>
</li>
</ul>
<h3 id="反向代理流程"><a href="#反向代理流程" class="headerlink" title="反向代理流程"></a>反向代理流程</h3><p>现在，商品详情页使用的是假的商品数据。不过在浏览器中，可以看到页面有发起ajax请求查询真实商品数据。</p>
<p>这个请求如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821093144700.png" alt="image-20210821093144700"></p>
<p>请求地址是localhost，端口是80，就被windows上安装的Nginx服务给接收到了。然后代理给了OpenResty集群：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821094447709.png" alt="image-20210821094447709"></p>
<p>我们需要在OpenResty中编写业务，查询商品数据并返回到浏览器。</p>
<p>但是这次，我们先在OpenResty接收请求，返回假的商品数据。</p>
<h3 id="OpenResty监听请求"><a href="#OpenResty监听请求" class="headerlink" title="OpenResty监听请求"></a>OpenResty监听请求</h3><p>OpenResty的很多功能都依赖于其目录下的Lua库，需要在nginx.conf中指定依赖库的目录，并导入依赖：</p>
<p>1）添加对OpenResty的Lua模块的加载</p>
<p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，在其中的http下面，添加下面代码：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#lua 模块</span></span><br><span class="line"><span class="attribute">lua_package_path</span> <span class="string">&quot;/usr/local/openresty/lualib/?.lua;;&quot;</span>;</span><br><span class="line"><span class="comment">#c模块     </span></span><br><span class="line"><span class="attribute">lua_package_cpath</span> <span class="string">&quot;/usr/local/openresty/lualib/?.so;;&quot;</span>;  </span><br></pre></td></tr></table></figure>



<p>2）监听/api/item路径</p>
<p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，在nginx.conf的server下面，添加对/api/item这个路径的监听：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span>  /api/item &#123;</span><br><span class="line">    <span class="comment"># 默认的响应类型</span></span><br><span class="line">    <span class="attribute">default_type</span> application/json;</span><br><span class="line">    <span class="comment"># 响应结果由lua/item.lua文件来决定</span></span><br><span class="line">    <span class="attribute">content_by_lua_file</span> lua/item.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个监听，就类似于SpringMVC中的<code>@GetMapping(&quot;/api/item&quot;)</code>做路径映射。</p>
<p>而<code>content_by_lua_file lua/item.lua</code>则相当于调用item.lua这个文件，执行其中的业务，把结果返回给用户。相当于java中调用service。</p>
<h3 id="编写item-lua"><a href="#编写item-lua" class="headerlink" title="编写item.lua"></a>编写item.lua</h3><p>1）在<code>/usr/loca/openresty/nginx</code>目录创建文件夹：lua</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821100755080.png" alt="image-20210821100755080"></p>
<p>2）在<code>/usr/loca/openresty/nginx/lua</code>文件夹下，新建文件：item.lua</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821100801756.png" alt="image-20210821100801756"></p>
<p>3）编写item.lua，返回假数据</p>
<p>item.lua中，利用ngx.say()函数返回数据到Response中</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(<span class="string">&#x27;&#123;&quot;id&quot;:10001,&quot;name&quot;:&quot;SALSA AIR&quot;,&quot;title&quot;:&quot;RIMOWA 21寸托运箱拉杆箱 SALSA AIR系列果绿色 820.70.36.4&quot;,&quot;price&quot;:17900,&quot;image&quot;:&quot;https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp&quot;,&quot;category&quot;:&quot;拉杆箱&quot;,&quot;brand&quot;:&quot;RIMOWA&quot;,&quot;spec&quot;:&quot;&quot;,&quot;status&quot;:1,&quot;createTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;updateTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;stock&quot;:2999,&quot;sold&quot;:31290&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>4）重新加载配置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>



<p>刷新商品页面：<a target="_blank" rel="noopener" href="http://localhost/item.html?id=1001%EF%BC%8C%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E6%95%88%E6%9E%9C%EF%BC%9A">http://localhost/item.html?id=1001，即可看到效果：</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821101217089.png" alt="image-20210821101217089"></p>
<h2 id="请求参数处理"><a href="#请求参数处理" class="headerlink" title="请求参数处理"></a>请求参数处理</h2><p>上一节中，我们在OpenResty接收前端请求，但是返回的是假数据。</p>
<p>要返回真实数据，必须根据前端传递来的商品id，查询商品信息才可以。</p>
<p>那么如何获取前端传递的商品参数呢？</p>
<h3 id="获取参数的API"><a href="#获取参数的API" class="headerlink" title="获取参数的API"></a>获取参数的API</h3><p>OpenResty中提供了一些API用来获取不同类型的前端请求参数：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821101433528.png" alt="image-20210821101433528"></p>
<h3 id="获取参数并返回"><a href="#获取参数并返回" class="headerlink" title="获取参数并返回"></a>获取参数并返回</h3><p>在前端发起的ajax请求如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821101721649.png" alt="image-20210821101721649"></p>
<p>可以看到商品id是以路径占位符方式传递的，因此可以利用正则表达式匹配的方式来获取ID</p>
<p>1）获取商品id</p>
<p>修改<code>/usr/loca/openresty/nginx/nginx.conf</code>文件中监听/api/item的代码，利用正则表达式获取ID：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ /api/item/(\d+)</span> &#123;</span><br><span class="line">    <span class="comment"># 默认的响应类型</span></span><br><span class="line">    <span class="attribute">default_type</span> application/json;</span><br><span class="line">    <span class="comment"># 响应结果由lua/item.lua文件来决定</span></span><br><span class="line">    <span class="attribute">content_by_lua_file</span> lua/item.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2）拼接ID并返回</p>
<p>修改<code>/usr/loca/openresty/nginx/lua/item.lua</code>文件，获取id并拼接到结果中返回：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取商品id</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 拼接并返回</span></span><br><span class="line">ngx.say(<span class="string">&#x27;&#123;&quot;id&quot;:&#x27;</span> .. id .. <span class="string">&#x27;,&quot;name&quot;:&quot;SALSA AIR&quot;,&quot;title&quot;:&quot;RIMOWA 21寸托运箱拉杆箱 SALSA AIR系列果绿色 820.70.36.4&quot;,&quot;price&quot;:17900,&quot;image&quot;:&quot;https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp&quot;,&quot;category&quot;:&quot;拉杆箱&quot;,&quot;brand&quot;:&quot;RIMOWA&quot;,&quot;spec&quot;:&quot;&quot;,&quot;status&quot;:1,&quot;createTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;updateTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;stock&quot;:2999,&quot;sold&quot;:31290&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>3）重新加载并测试</p>
<p>运行命令以重新加载OpenResty配置：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>



<p>刷新页面可以看到结果中已经带上了ID：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821102235467.png" alt="image-20210821102235467"> </p>
<h2 id="查询Tomcat"><a href="#查询Tomcat" class="headerlink" title="查询Tomcat"></a>查询Tomcat</h2><p>拿到商品ID后，本应去缓存中查询商品信息，不过目前我们还未建立nginx、redis缓存。因此，这里我们先根据商品id去tomcat查询商品信息。我们实现如图部分：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821102610167.png" alt="image-20210821102610167"></p>
<p>需要注意的是，我们的OpenResty是在虚拟机，Tomcat是在Windows电脑上。两者IP一定不要搞错了。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821102959829.png" alt="image-20210821102959829"></p>
<h3 id="发送http请求的API"><a href="#发送http请求的API" class="headerlink" title="发送http请求的API"></a>发送http请求的API</h3><p>nginx提供了内部API用以发送http请求：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> resp = ngx.location.capture(<span class="string">&quot;/path&quot;</span>,&#123;</span><br><span class="line">    method = ngx.HTTP_GET,   <span class="comment">-- 请求方式</span></span><br><span class="line">    args = &#123;a=<span class="number">1</span>,b=<span class="number">2</span>&#125;,  <span class="comment">-- get方式传参数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>返回的响应内容包括：</p>
<ul>
<li>resp.status：响应状态码</li>
<li>resp.header：响应头，是一个table</li>
<li>resp.body：响应体，就是响应数据</li>
</ul>
<p>注意：这里的path是路径，并不包含IP和端口。这个请求会被nginx内部的server监听并处理。</p>
<p>但是我们希望这个请求发送到Tomcat服务器，所以还需要编写一个server来对这个路径做反向代理：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /path &#123;</span><br><span class="line">    <span class="comment"># 这里是windows电脑的ip和Java服务端口，需要确保windows防火墙处于关闭状态</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.150.1:8081; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>原理如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821104149061.png" alt="image-20210821104149061"></p>
<h3 id="封装http工具"><a href="#封装http工具" class="headerlink" title="封装http工具"></a>封装http工具</h3><p>下面，我们封装一个发送Http请求的工具，基于ngx.location.capture来实现查询tomcat。</p>
<p>1）添加反向代理，到windows的Java服务</p>
<p>因为item-service中的接口都是/item开头，所以我们监听/item路径，代理到windows上的tomcat服务。</p>
<p>修改 <code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，添加一个location：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /item &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.150.1:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以后，只要我们调用<code>ngx.location.capture(&quot;/item&quot;)</code>，就一定能发送请求到windows的tomcat服务。</p>
<p>2）封装工具类</p>
<p>之前我们说过，OpenResty启动时会加载以下两个目录中的工具文件：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821104857413.png" alt="image-20210821104857413"></p>
<p>所以，自定义的http工具也需要放到这个目录下。</p>
<p>在<code>/usr/local/openresty/lualib</code>目录下，新建一个common.lua文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/local/openresty/lualib/common.lua</span><br></pre></td></tr></table></figure>

<p>内容如下:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 封装函数，发送http请求，并解析响应</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_http</span><span class="params">(path, params)</span></span></span><br><span class="line">    <span class="keyword">local</span> resp = ngx.location.capture(<span class="built_in">path</span>,&#123;</span><br><span class="line">        method = ngx.HTTP_GET,</span><br><span class="line">        args = params,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 记录错误信息，返回404</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;http请求查询失败, path: &quot;</span>, <span class="built_in">path</span> , <span class="string">&quot;, args: &quot;</span>, args)</span><br><span class="line">        ngx.<span class="built_in">exit</span>(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> resp.body</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 将方法导出</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;  </span><br><span class="line">    read_http = read_http</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure>



<p>这个工具将read_http函数封装到_M这个table类型的变量中，并且返回，这类似于导出。</p>
<p>使用的时候，可以利用<code>require(&#39;common&#39;)</code>来导入该函数库，这里的common是函数库的文件名。</p>
<p>3）实现商品查询</p>
<p>最后，我们修改<code>/usr/local/openresty/lua/item.lua</code>文件，利用刚刚封装的函数库实现对tomcat的查询：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 引入自定义common工具模块，返回值是common中返回的 _M</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&quot;common&quot;</span>)</span><br><span class="line"><span class="comment">-- 从 common中获取read_http这个函数</span></span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 根据id查询商品</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_http(<span class="string">&quot;/item/&quot;</span>.. id, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 根据id查询商品库存</span></span><br><span class="line"><span class="keyword">local</span> itemStockJSON = read_http(<span class="string">&quot;/item/stock/&quot;</span>.. id, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>



<p>这里查询到的结果是json字符串，并且包含商品、库存两个json字符串，页面最终需要的是把两个json拼接为一个json：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821110441222.png" alt="image-20210821110441222"></p>
<p>这就需要我们先把JSON变为lua的table，完成数据整合后，再转为JSON。</p>
<h3 id="CJSON工具类"><a href="#CJSON工具类" class="headerlink" title="CJSON工具类"></a>CJSON工具类</h3><p>OpenResty提供了一个cjson的模块用来处理JSON的序列化和反序列化。</p>
<p>官方地址： <a target="_blank" rel="noopener" href="https://github.com/openresty/lua-cjson/">https://github.com/openresty/lua-cjson/</a></p>
<p>1）引入cjson模块：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span> <span class="string">&quot;cjson&quot;</span></span><br></pre></td></tr></table></figure>



<p>2）序列化：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> obj = &#123;</span><br><span class="line">    name = <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    age = <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">-- 把 table 序列化为 json</span></span><br><span class="line"><span class="keyword">local</span> json = cjson.encode(obj)</span><br></pre></td></tr></table></figure>



<p>3）反序列化：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> json = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;jack&quot;, &quot;age&quot;: 21&#125;&#x27;</span></span><br><span class="line"><span class="comment">-- 反序列化 json为 table</span></span><br><span class="line"><span class="keyword">local</span> obj = cjson.decode(json);</span><br><span class="line"><span class="built_in">print</span>(obj.name)</span><br></pre></td></tr></table></figure>





<h3 id="实现Tomcat查询"><a href="#实现Tomcat查询" class="headerlink" title="实现Tomcat查询"></a>实现Tomcat查询</h3><p>下面，我们修改之前的item.lua中的业务，添加json处理功能：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入common函数库</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&#x27;common&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="comment">-- 导入cjson库</span></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">&#x27;cjson&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 根据id查询商品</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_http(<span class="string">&quot;/item/&quot;</span>.. id, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 根据id查询商品库存</span></span><br><span class="line"><span class="keyword">local</span> itemStockJSON = read_http(<span class="string">&quot;/item/stock/&quot;</span>.. id, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSON转化为lua的table</span></span><br><span class="line"><span class="keyword">local</span> item = cjson.decode(itemJSON)</span><br><span class="line"><span class="keyword">local</span> stock = cjson.decode(stockJSON)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 组合数据</span></span><br><span class="line">item.stock = stock.stock</span><br><span class="line">item.sold = stock.sold</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把item序列化为json 返回结果</span></span><br><span class="line">ngx.say(cjson.encode(item))</span><br></pre></td></tr></table></figure>



<h3 id="基于ID负载均衡"><a href="#基于ID负载均衡" class="headerlink" title="基于ID负载均衡"></a>基于ID负载均衡</h3><p>刚才的代码中，我们的tomcat是单机部署。而实际开发中，tomcat一定是集群模式：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821111023255.png" alt="image-20210821111023255"></p>
<p>因此，OpenResty需要对tomcat集群做负载均衡。</p>
<p>而默认的负载均衡规则是轮询模式，当我们查询/item/10001时：</p>
<ul>
<li>第一次会访问8081端口的tomcat服务，在该服务内部就形成了JVM进程缓存</li>
<li>第二次会访问8082端口的tomcat服务，该服务内部没有JVM缓存（因为JVM缓存无法共享），会查询数据库</li>
<li>…</li>
</ul>
<p>你看，因为轮询的原因，第一次查询8081形成的JVM缓存并未生效，直到下一次再次访问到8081时才可以生效，缓存命中率太低了。</p>
<p>怎么办？</p>
<p>如果能让同一个商品，每次查询时都访问同一个tomcat服务，那么JVM缓存就一定能生效了。</p>
<p>也就是说，我们需要根据商品id做负载均衡，而不是轮询。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>nginx提供了基于请求路径做负载均衡的算法：</p>
<p>nginx根据请求路径做hash运算，把得到的数值对tomcat服务的数量取余，余数是几，就访问第几个服务，实现负载均衡。</p>
<p>例如：</p>
<ul>
<li>我们的请求路径是 /item/10001</li>
<li>tomcat总数为2台（8081、8082）</li>
<li>对请求路径/item/1001做hash运算求余的结果为1</li>
<li>则访问第一个tomcat服务，也就是8081</li>
</ul>
<p>只要id不变，每次hash运算结果也不会变，那就可以保证同一个商品，一直访问同一个tomcat服务，确保JVM缓存生效。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，实现基于ID做负载均衡。</p>
<p>首先，定义tomcat集群，并设置基于路径做负载均衡：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> tomcat-cluster &#123;</span><br><span class="line">    <span class="attribute">hash</span> <span class="variable">$request_uri</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.150.1:8081</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.150.1:8082</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，修改对tomcat服务的反向代理，目标指向tomcat集群：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /item &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://tomcat-cluster;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新加载OpenResty</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>





<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>启动两台tomcat服务：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821112420464.png" alt="image-20210821112420464"></p>
<p>同时启动：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821112444482.png" alt="image-20210821112444482"> </p>
<p>清空日志后，再次访问页面，可以看到不同id的商品，访问到了不同的tomcat服务：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821112559965.png" alt="image-20210821112559965"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821112637430.png" alt="image-20210821112637430"></p>
<h2 id="Redis缓存预热"><a href="#Redis缓存预热" class="headerlink" title="Redis缓存预热"></a>Redis缓存预热</h2><p>Redis缓存会面临冷启动问题：</p>
<p><strong>冷启动</strong>：服务刚刚启动时，Redis中并没有缓存，如果所有商品数据都在第一次查询时添加缓存，可能会给数据库带来较大压力。</p>
<p><strong>缓存预热</strong>：在实际开发中，我们可以利用大数据统计用户访问的热点数据，在项目启动时将这些热点数据提前查询并保存到Redis中。</p>
<p>我们数据量较少，并且没有数据统计相关功能，目前可以在启动时将所有数据都放入缓存中。</p>
<p>1）利用Docker安装Redis</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 -d redis redis-server --appendonly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>



<p>2）在item-service服务中引入Redis依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>3）配置Redis地址</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>



<p>4）编写初始化类</p>
<p>缓存预热需要在项目启动时完成，并且必须是拿到RedisTemplate之后。</p>
<p>这里我们利用InitializingBean接口来实现，因为InitializingBean可以在对象被Spring创建并且成员变量全部注入后执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.ItemStock;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemService;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemStockService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisHandler</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemService itemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemStockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">MAPPER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 初始化缓存</span></span><br><span class="line">        <span class="comment">// 1.查询商品信息</span></span><br><span class="line">        List&lt;Item&gt; itemList = itemService.list();</span><br><span class="line">        <span class="comment">// 2.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (Item item : itemList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(item);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:id:&quot;</span> + item.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询商品库存信息</span></span><br><span class="line">        List&lt;ItemStock&gt; stockList = stockService.list();</span><br><span class="line">        <span class="comment">// 4.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (ItemStock stock : stockList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(stock);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:stock:id:&quot;</span> + stock.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="查询Redis缓存"><a href="#查询Redis缓存" class="headerlink" title="查询Redis缓存"></a>查询Redis缓存</h2><p>现在，Redis缓存已经准备就绪，我们可以再OpenResty中实现查询Redis的逻辑了。如下图红框所示：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821113340111.png" alt="image-20210821113340111"></p>
<p>当请求进入OpenResty之后：</p>
<ul>
<li>优先查询Redis缓存</li>
<li>如果Redis缓存未命中，再查询Tomcat</li>
</ul>
<h3 id="封装Redis工具"><a href="#封装Redis工具" class="headerlink" title="封装Redis工具"></a>封装Redis工具</h3><p>OpenResty提供了操作Redis的模块，我们只要引入该模块就能直接使用。但是为了方便，我们将Redis操作封装到之前的common.lua工具库中。</p>
<p>修改<code>/usr/local/openresty/lualib/common.lua</code>文件：</p>
<p>1）引入Redis模块，并初始化Redis对象</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入redis</span></span><br><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span>(<span class="string">&#x27;resty.redis&#x27;</span>)</span><br><span class="line"><span class="comment">-- 初始化redis</span></span><br><span class="line"><span class="keyword">local</span> red = redis:new()</span><br><span class="line">red:set_timeouts(<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>



<p>2）封装函数，用来释放Redis连接，其实是放入连接池</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 关闭redis连接的工具方法，其实是放入连接池</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">close_redis</span><span class="params">(red)</span></span></span><br><span class="line">    <span class="keyword">local</span> pool_max_idle_time = <span class="number">10000</span> <span class="comment">-- 连接的空闲时间，单位是毫秒</span></span><br><span class="line">    <span class="keyword">local</span> pool_size = <span class="number">100</span> <span class="comment">--连接池大小</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = red:set_keepalive(pool_max_idle_time, pool_size)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;放入redis连接池失败: &quot;</span>, err)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>3）封装函数，根据key查询Redis数据</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询redis的方法 ip和port是redis地址，key是查询的key</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_redis</span><span class="params">(ip, port, key)</span></span></span><br><span class="line">    <span class="comment">-- 获取一个连接</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = red:connect(ip, port)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;连接redis失败 : &quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 查询redis</span></span><br><span class="line">    <span class="keyword">local</span> resp, err = red:get(key)</span><br><span class="line">    <span class="comment">-- 查询失败处理</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis失败: &quot;</span>, err, <span class="string">&quot;, key = &quot;</span> , key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">--得到的数据为空处理</span></span><br><span class="line">    <span class="keyword">if</span> resp == ngx.null <span class="keyword">then</span></span><br><span class="line">        resp = <span class="literal">nil</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis数据为空, key = &quot;</span>, key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    close_redis(red)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>4）导出</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将方法导出</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;  </span><br><span class="line">    read_http = read_http,</span><br><span class="line">    read_redis = read_redis</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure>



<p>完整的common.lua：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入redis</span></span><br><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span>(<span class="string">&#x27;resty.redis&#x27;</span>)</span><br><span class="line"><span class="comment">-- 初始化redis</span></span><br><span class="line"><span class="keyword">local</span> red = redis:new()</span><br><span class="line">red:set_timeouts(<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭redis连接的工具方法，其实是放入连接池</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">close_redis</span><span class="params">(red)</span></span></span><br><span class="line">    <span class="keyword">local</span> pool_max_idle_time = <span class="number">10000</span> <span class="comment">-- 连接的空闲时间，单位是毫秒</span></span><br><span class="line">    <span class="keyword">local</span> pool_size = <span class="number">100</span> <span class="comment">--连接池大小</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = red:set_keepalive(pool_max_idle_time, pool_size)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;放入redis连接池失败: &quot;</span>, err)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询redis的方法 ip和port是redis地址，key是查询的key</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_redis</span><span class="params">(ip, port, key)</span></span></span><br><span class="line">    <span class="comment">-- 获取一个连接</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = red:connect(ip, port)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;连接redis失败 : &quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 查询redis</span></span><br><span class="line">    <span class="keyword">local</span> resp, err = red:get(key)</span><br><span class="line">    <span class="comment">-- 查询失败处理</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis失败: &quot;</span>, err, <span class="string">&quot;, key = &quot;</span> , key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">--得到的数据为空处理</span></span><br><span class="line">    <span class="keyword">if</span> resp == ngx.null <span class="keyword">then</span></span><br><span class="line">        resp = <span class="literal">nil</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;查询Redis数据为空, key = &quot;</span>, key)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    close_redis(red)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装函数，发送http请求，并解析响应</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_http</span><span class="params">(path, params)</span></span></span><br><span class="line">    <span class="keyword">local</span> resp = ngx.location.capture(<span class="built_in">path</span>,&#123;</span><br><span class="line">        method = ngx.HTTP_GET,</span><br><span class="line">        args = params,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 记录错误信息，返回404</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;http查询失败, path: &quot;</span>, <span class="built_in">path</span> , <span class="string">&quot;, args: &quot;</span>, args)</span><br><span class="line">        ngx.<span class="built_in">exit</span>(<span class="number">404</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> resp.body</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 将方法导出</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;  </span><br><span class="line">    read_http = read_http,</span><br><span class="line">    read_redis = read_redis</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure>





<h3 id="实现Redis查询"><a href="#实现Redis查询" class="headerlink" title="实现Redis查询"></a>实现Redis查询</h3><p>接下来，我们就可以去修改item.lua文件，实现对Redis的查询了。</p>
<p>查询逻辑是：</p>
<ul>
<li>根据id查询Redis</li>
<li>如果查询失败则继续查询Tomcat</li>
<li>将查询结果返回</li>
</ul>
<p>1）修改<code>/usr/local/openresty/lua/item.lua</code>文件，添加一个查询函数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入common函数库</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&#x27;common&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="keyword">local</span> read_redis = common.read_redis</span><br><span class="line"><span class="comment">-- 封装查询函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, path, params)</span></span></span><br><span class="line">    <span class="comment">-- 查询本地缓存</span></span><br><span class="line">    <span class="keyword">local</span> val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, key)</span><br><span class="line">    <span class="comment">-- 判断查询结果</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)</span><br><span class="line">        <span class="comment">-- redis查询失败，去查询http</span></span><br><span class="line">        val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>2）而后修改商品查询、库存查询的业务：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821114528954.png" alt="image-20210821114528954"></p>
<p>3）完整的item.lua代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入common函数库</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&#x27;common&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="keyword">local</span> read_redis = common.read_redis</span><br><span class="line"><span class="comment">-- 导入cjson库</span></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">&#x27;cjson&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装查询函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, path, params)</span></span></span><br><span class="line">    <span class="comment">-- 查询本地缓存</span></span><br><span class="line">    <span class="keyword">local</span> val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, key)</span><br><span class="line">    <span class="comment">-- 判断查询结果</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)</span><br><span class="line">        <span class="comment">-- redis查询失败，去查询http</span></span><br><span class="line">        val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询商品信息</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_data(<span class="string">&quot;item:id:&quot;</span> .. id,  <span class="string">&quot;/item/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 查询库存信息</span></span><br><span class="line"><span class="keyword">local</span> stockJSON = read_data(<span class="string">&quot;item:stock:id:&quot;</span> .. id, <span class="string">&quot;/item/stock/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSON转化为lua的table</span></span><br><span class="line"><span class="keyword">local</span> item = cjson.decode(itemJSON)</span><br><span class="line"><span class="keyword">local</span> stock = cjson.decode(stockJSON)</span><br><span class="line"><span class="comment">-- 组合数据</span></span><br><span class="line">item.stock = stock.stock</span><br><span class="line">item.sold = stock.sold</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把item序列化为json 返回结果</span></span><br><span class="line">ngx.say(cjson.encode(item))</span><br></pre></td></tr></table></figure>





<h2 id="Nginx本地缓存"><a href="#Nginx本地缓存" class="headerlink" title="Nginx本地缓存"></a>Nginx本地缓存</h2><p>现在，整个多级缓存中只差最后一环，也就是nginx的本地缓存了。如图：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821114742950.png" alt="image-20210821114742950"></p>
<h3 id="本地缓存API"><a href="#本地缓存API" class="headerlink" title="本地缓存API"></a>本地缓存API</h3><p>OpenResty为Nginx提供了<strong>shard dict</strong>的功能，可以在nginx的多个worker之间共享数据，实现缓存功能。</p>
<p>1）开启共享字典，在nginx.conf的http下添加配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 共享字典，也就是本地缓存，名称叫做：item_cache，大小150m</span></span><br><span class="line"><span class="attribute">lua_shared_dict</span> item_cache <span class="number">150m</span>; </span><br></pre></td></tr></table></figure>



<p>2）操作共享字典：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取本地缓存对象</span></span><br><span class="line"><span class="keyword">local</span> item_cache = ngx.shared.item_cache</span><br><span class="line"><span class="comment">-- 存储, 指定key、value、过期时间，单位s，默认为0代表永不过期</span></span><br><span class="line">item_cache:set(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">-- 读取</span></span><br><span class="line"><span class="keyword">local</span> val = item_cache:get(<span class="string">&#x27;key&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="实现本地缓存查询"><a href="#实现本地缓存查询" class="headerlink" title="实现本地缓存查询"></a>实现本地缓存查询</h3><p>1）修改<code>/usr/local/openresty/lua/item.lua</code>文件，修改read_data查询函数，添加本地缓存逻辑：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入共享词典，本地缓存</span></span><br><span class="line"><span class="keyword">local</span> item_cache = ngx.shared.item_cache</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装查询函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, expire, path, params)</span></span></span><br><span class="line">    <span class="comment">-- 查询本地缓存</span></span><br><span class="line">    <span class="keyword">local</span> val = item_cache:get(key)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;本地缓存查询失败，尝试查询Redis， key: &quot;</span>, key)</span><br><span class="line">        <span class="comment">-- 查询redis</span></span><br><span class="line">        val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, key)</span><br><span class="line">        <span class="comment">-- 判断查询结果</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">            ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)</span><br><span class="line">            <span class="comment">-- redis查询失败，去查询http</span></span><br><span class="line">            val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 查询成功，把数据写入本地缓存</span></span><br><span class="line">    item_cache:set(key, val, expire)</span><br><span class="line">    <span class="comment">-- 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>





<p>2）修改item.lua中查询商品和库存的业务，实现最新的read_data函数：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821115108528.png" alt="image-20210821115108528"></p>
<p>其实就是多了缓存时间参数，过期后nginx缓存会自动删除，下次访问即可更新缓存。</p>
<p>这里给商品基本信息设置超时时间为30分钟，库存为1分钟。</p>
<p>因为库存更新频率较高，如果缓存时间过长，可能与数据库差异较大。</p>
<p>3）完整的item.lua文件：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入common函数库</span></span><br><span class="line"><span class="keyword">local</span> common = <span class="built_in">require</span>(<span class="string">&#x27;common&#x27;</span>)</span><br><span class="line"><span class="keyword">local</span> read_http = common.read_http</span><br><span class="line"><span class="keyword">local</span> read_redis = common.read_redis</span><br><span class="line"><span class="comment">-- 导入cjson库</span></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span>(<span class="string">&#x27;cjson&#x27;</span>)</span><br><span class="line"><span class="comment">-- 导入共享词典，本地缓存</span></span><br><span class="line"><span class="keyword">local</span> item_cache = ngx.shared.item_cache</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装查询函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, expire, path, params)</span></span></span><br><span class="line">    <span class="comment">-- 查询本地缓存</span></span><br><span class="line">    <span class="keyword">local</span> val = item_cache:get(key)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;本地缓存查询失败，尝试查询Redis， key: &quot;</span>, key)</span><br><span class="line">        <span class="comment">-- 查询redis</span></span><br><span class="line">        val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, key)</span><br><span class="line">        <span class="comment">-- 判断查询结果</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">            ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)</span><br><span class="line">            <span class="comment">-- redis查询失败，去查询http</span></span><br><span class="line">            val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 查询成功，把数据写入本地缓存</span></span><br><span class="line">    item_cache:set(key, val, expire)</span><br><span class="line">    <span class="comment">-- 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取路径参数</span></span><br><span class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询商品信息</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_data(<span class="string">&quot;item:id:&quot;</span> .. id, <span class="number">1800</span>,  <span class="string">&quot;/item/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 查询库存信息</span></span><br><span class="line"><span class="keyword">local</span> stockJSON = read_data(<span class="string">&quot;item:stock:id:&quot;</span> .. id, <span class="number">60</span>, <span class="string">&quot;/item/stock/&quot;</span> .. id, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSON转化为lua的table</span></span><br><span class="line"><span class="keyword">local</span> item = cjson.decode(itemJSON)</span><br><span class="line"><span class="keyword">local</span> stock = cjson.decode(stockJSON)</span><br><span class="line"><span class="comment">-- 组合数据</span></span><br><span class="line">item.stock = stock.stock</span><br><span class="line">item.sold = stock.sold</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把item序列化为json 返回结果</span></span><br><span class="line">ngx.say(cjson.encode(item))</span><br></pre></td></tr></table></figure>





<h1 id="五、缓存同步"><a href="#五、缓存同步" class="headerlink" title="五、缓存同步"></a>五、缓存同步</h1><p>大多数情况下，浏览器查询到的都是缓存数据，如果缓存数据与数据库数据存在较大差异，可能会产生比较严重的后果。</p>
<p>所以我们必须保证数据库数据、缓存数据的一致性，这就是缓存与数据库的同步。</p>
<h2 id="数据同步策略"><a href="#数据同步策略" class="headerlink" title="数据同步策略"></a>数据同步策略</h2><p>缓存数据同步的常见方式有三种：</p>
<p><strong>设置有效期</strong>：给缓存设置有效期，到期后自动删除。再次查询时更新</p>
<ul>
<li>优势：简单、方便</li>
<li>缺点：时效性差，缓存过期之前可能不一致</li>
<li>场景：更新频率较低，时效性要求低的业务</li>
</ul>
<p><strong>同步双写</strong>：在修改数据库的同时，直接修改缓存</p>
<ul>
<li>优势：时效性强，缓存与数据库强一致</li>
<li>缺点：有代码侵入，耦合度高；</li>
<li>场景：对一致性、时效性要求较高的缓存数据</li>
</ul>
<p><strong>异步通知：</strong>修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据</p>
<ul>
<li>优势：低耦合，可以同时通知多个缓存服务</li>
<li>缺点：时效性一般，可能存在中间不一致状态</li>
<li>场景：时效性要求一般，有多个服务需要同步</li>
</ul>
<p>而异步实现又可以基于MQ或者Canal来实现：</p>
<p>1）基于MQ的异步通知：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821115552327.png" alt="image-20210821115552327"></p>
<p>解读：</p>
<ul>
<li>商品服务完成对数据的修改后，只需要发送一条消息到MQ中。</li>
<li>缓存服务监听MQ消息，然后完成对缓存的更新</li>
</ul>
<p>依然有少量的代码侵入。</p>
<p>2）基于Canal的通知</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821115719363.png" alt="image-20210821115719363"></p>
<p>解读：</p>
<ul>
<li>商品服务完成商品修改后，业务直接结束，没有任何代码侵入</li>
<li>Canal监听MySQL变化，当发现变化后，立即通知缓存服务</li>
<li>缓存服务接收到canal通知，更新缓存</li>
</ul>
<p>代码零侵入</p>
<h2 id="安装Canal"><a href="#安装Canal" class="headerlink" title="安装Canal"></a>安装Canal</h2><h3 id="认识Canal"><a href="#认识Canal" class="headerlink" title="认识Canal"></a>认识Canal</h3><p>**Canal [kə’næl]**，译意为水道/管道/沟渠，canal是阿里巴巴旗下的一款开源项目，基于Java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费。GitHub的地址：<a target="_blank" rel="noopener" href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></p>
<p>Canal是基于mysql的主从同步来实现的，MySQL主从同步的原理如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821115914748.png" alt="image-20210821115914748"></p>
<ul>
<li>1）MySQL master 将数据变更写入二进制日志( binary log），其中记录的数据叫做binary log events</li>
<li>2）MySQL slave 将 master 的 binary log events拷贝到它的中继日志(relay log)</li>
<li>3）MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据</li>
</ul>
<p>而Canal就是把自己伪装成MySQL的一个slave节点，从而监听master的binary log变化。再把得到的变化信息通知给Canal的客户端，进而完成对其它数据库的同步。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821115948395.png" alt="image-20210821115948395"></p>
<h3 id="安装Canal-1"><a href="#安装Canal-1" class="headerlink" title="安装Canal"></a>安装Canal</h3><p>安装和配置Canal参考课前资料文档：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821120017324.png" alt="image-20210821120017324"> </p>
<h2 id="监听Canal"><a href="#监听Canal" class="headerlink" title="监听Canal"></a>监听Canal</h2><p>Canal提供了各种语言的客户端，当Canal监听到binlog变化时，会通知Canal的客户端。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20210821120049024.png" alt="image-20210821120049024"></p>
<p>我们可以利用Canal提供的Java客户端，监听Canal通知消息。当收到变化的消息时，完成对缓存的更新。</p>
<p>不过这里我们会使用GitHub上的第三方开源的canal-starter客户端。地址：<a target="_blank" rel="noopener" href="https://github.com/NormanGyllenhaal/canal-client">https://github.com/NormanGyllenhaal/canal-client</a></p>
<p>与SpringBoot完美整合，自动装配，比官方客户端要简单好用很多。</p>
<h3 id="引入依赖："><a href="#引入依赖：" class="headerlink" title="引入依赖："></a>引入依赖：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.javatool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>canal-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="编写配置："><a href="#编写配置：" class="headerlink" title="编写配置："></a>编写配置：</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">canal:</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">heima</span> <span class="comment"># canal的集群名字，要与安装canal时设置的名称一致</span></span><br><span class="line">  <span class="attr">server:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:11111</span> <span class="comment"># canal服务地址</span></span><br></pre></td></tr></table></figure>



<h3 id="修改Item实体类"><a href="#修改Item实体类" class="headerlink" title="修改Item实体类"></a>修改Item实体类</h3><p>通过@Id、@Column、等注解完成Item与数据库表字段的映射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Transient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;tb_item&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;<span class="comment">//商品id</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//商品名称</span></span><br><span class="line">    <span class="keyword">private</span> String title;<span class="comment">//商品标题</span></span><br><span class="line">    <span class="keyword">private</span> Long price;<span class="comment">//价格（分）</span></span><br><span class="line">    <span class="keyword">private</span> String image;<span class="comment">//商品图片</span></span><br><span class="line">    <span class="keyword">private</span> String category;<span class="comment">//分类名称</span></span><br><span class="line">    <span class="keyword">private</span> String brand;<span class="comment">//品牌名称</span></span><br><span class="line">    <span class="keyword">private</span> String spec;<span class="comment">//规格</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;<span class="comment">//商品状态 1-正常，2-下架</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;<span class="comment">//创建时间</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;<span class="comment">//更新时间</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> Integer sold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="编写监听器"><a href="#编写监听器" class="headerlink" title="编写监听器"></a>编写监听器</h3><p>通过实现<code>EntryHandler&lt;T&gt;</code>接口编写监听器，监听Canal消息。注意两点：</p>
<ul>
<li>实现类通过<code>@CanalTable(&quot;tb_item&quot;)</code>指定监听的表信息</li>
<li>EntryHandler的泛型是与表对应的实体类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.canal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.config.RedisHandler;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.annotation.CanalTable;</span><br><span class="line"><span class="keyword">import</span> top.javatool.canal.client.handler.EntryHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CanalTable(&quot;tb_item&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemHandler</span> <span class="keyword">implements</span> <span class="title class_">EntryHandler</span>&lt;Item&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisHandler redisHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;Long, Item&gt; itemCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="comment">// 写数据到JVM进程缓存</span></span><br><span class="line">        itemCache.put(item.getId(), item);</span><br><span class="line">        <span class="comment">// 写数据到redis</span></span><br><span class="line">        redisHandler.saveItem(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Item before, Item after)</span> &#123;</span><br><span class="line">        <span class="comment">// 写数据到JVM进程缓存</span></span><br><span class="line">        itemCache.put(after.getId(), after);</span><br><span class="line">        <span class="comment">// 写数据到redis</span></span><br><span class="line">        redisHandler.saveItem(after);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="comment">// 删除数据到JVM进程缓存</span></span><br><span class="line">        itemCache.invalidate(item.getId());</span><br><span class="line">        <span class="comment">// 删除数据到redis</span></span><br><span class="line">        redisHandler.deleteItemById(item.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这里对Redis的操作都封装到了RedisHandler这个对象中，是我们之前做缓存预热时编写的一个类，内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.pojo.ItemStock;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemService;</span><br><span class="line"><span class="keyword">import</span> com.heima.item.service.IItemStockService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisHandler</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemService itemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IItemStockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">MAPPER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 初始化缓存</span></span><br><span class="line">        <span class="comment">// 1.查询商品信息</span></span><br><span class="line">        List&lt;Item&gt; itemList = itemService.list();</span><br><span class="line">        <span class="comment">// 2.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (Item item : itemList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(item);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:id:&quot;</span> + item.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.查询商品库存信息</span></span><br><span class="line">        List&lt;ItemStock&gt; stockList = stockService.list();</span><br><span class="line">        <span class="comment">// 4.放入缓存</span></span><br><span class="line">        <span class="keyword">for</span> (ItemStock stock : stockList) &#123;</span><br><span class="line">            <span class="comment">// 2.1.item序列化为JSON</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(stock);</span><br><span class="line">            <span class="comment">// 2.2.存入redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:stock:id:&quot;</span> + stock.getId(), json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveItem</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> MAPPER.writeValueAsString(item);</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;item:id:&quot;</span> + item.getId(), json);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteItemById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;item:id:&quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="——最佳实践——"><a href="#——最佳实践——" class="headerlink" title="——最佳实践——"></a>——最佳实践——</h1><p><strong>今日内容</strong></p>
<blockquote>
<ul>
<li>Redis键值设计</li>
<li>批处理优化</li>
<li>服务端优化</li>
<li>集群最佳实践</li>
</ul>
</blockquote>
<h1 id="一、Redis键值设计"><a href="#一、Redis键值设计" class="headerlink" title="一、Redis键值设计"></a>一、Redis键值设计</h1><h2 id="优雅的key结构"><a href="#优雅的key结构" class="headerlink" title="优雅的key结构"></a>优雅的key结构</h2><p>Redis的Key虽然可以自定义，但最好遵循下面的几个最佳实践约定：</p>
<ul>
<li>遵循基本格式：[业务名称]:[数据名]:[id]</li>
<li>长度不超过44字节</li>
<li>不包含特殊字符</li>
</ul>
<p>例如：我们的登录业务，保存用户信息，其key可以设计成如下格式：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521120213631.png" alt="image-20220521120213631"></p>
<p>这样设计的好处：</p>
<ul>
<li>可读性强</li>
<li>避免key冲突</li>
<li>方便管理</li>
<li>更节省内存： key是string类型，底层编码包含int、embstr和raw三种。embstr在小于44字节使用，采用连续内存空间，内存占用更小。当字节数大于44字节时，会转为raw模式存储，在raw模式下，内存空间不是连续的，而是采用一个指针指向了另外一段内存空间，在这段空间里存储SDS内容，这样空间不连续，访问的时候性能也就会收到影响，还有可能产生内存碎片</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521122320482.png" alt="image-20220521122320482"></p>
<h2 id="拒绝BigKey"><a href="#拒绝BigKey" class="headerlink" title="拒绝BigKey"></a>拒绝BigKey</h2><p>BigKey通常以Key的大小和Key中成员的数量来综合判定，例如：</p>
<ul>
<li>Key本身的数据量过大：一个String类型的Key，它的值为5 MB</li>
<li>Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个</li>
<li>Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1,000个但这些成员的Value（值）总大小为100 MB</li>
</ul>
<p>那么如何判断元素的大小呢？redis也给我们提供了命令</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521124650117.png" alt="image-20220521124650117"></p>
<p>推荐值：</p>
<ul>
<li>单个key的value小于10KB</li>
<li>对于集合类型的key，建议元素数量小于1000</li>
</ul>
<h3 id="BigKey的危害"><a href="#BigKey的危害" class="headerlink" title="BigKey的危害"></a>BigKey的危害</h3><ul>
<li>网络阻塞<ul>
<li>对BigKey执行读请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis实例，乃至所在物理机变慢</li>
</ul>
</li>
<li>数据倾斜<ul>
<li>BigKey所在的Redis实例内存使用率远超其他实例，无法使数据分片的内存资源达到均衡</li>
</ul>
</li>
<li>Redis阻塞<ul>
<li>对元素较多的hash、list、zset等做运算会耗时较旧，使主线程被阻塞</li>
</ul>
</li>
<li>CPU压力<ul>
<li>对BigKey的数据序列化和反序列化会导致CPU的使用率飙升，影响Redis实例和本机其它应用</li>
</ul>
</li>
</ul>
<h3 id="如何发现BigKey"><a href="#如何发现BigKey" class="headerlink" title="如何发现BigKey"></a>如何发现BigKey</h3><h4 id="redis-cli-–bigkeys"><a href="#redis-cli-–bigkeys" class="headerlink" title="redis-cli –bigkeys"></a>redis-cli –bigkeys</h4><p>利用redis-cli提供的–bigkeys参数，可以遍历分析所有key，并返回Key的整体统计信息与每个数据的Top1的big key</p>
<p>命令：<code>redis-cli -a 密码 --bigkeys</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521133359507.png" alt="image-20220521133359507"></p>
<h4 id="scan扫描"><a href="#scan扫描" class="headerlink" title="scan扫描"></a>scan扫描</h4><p>自己编程，利用scan扫描Redis中的所有key，利用strlen、hlen等命令判断key的长度（此处不建议使用MEMORY USAGE）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521133703245.png" alt="image-20220521133703245"></p>
<p>scan 命令调用完后每次会返回2个元素，第一个是下一次迭代的光标，第一次光标会设置为0，当最后一次scan 返回的光标等于0时，表示整个scan遍历结束了，第二个返回的是List，一个匹配的key的数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.heima.jedis.util.JedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="comment">// jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span></span><br><span class="line">        jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">        <span class="comment">// 2.设置密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.选择库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">STR_MAX_LEN</span> <span class="operator">=</span> <span class="number">10</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">HASH_MAX_LEN</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testScan</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 扫描并获取一部分key</span></span><br><span class="line">            ScanResult&lt;String&gt; result = jedis.scan(cursor);</span><br><span class="line">            <span class="comment">// 记录cursor</span></span><br><span class="line">            cursor = result.getCursor();</span><br><span class="line">            List&lt;String&gt; list = result.getResult();</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历</span></span><br><span class="line">            <span class="keyword">for</span> (String key : list) &#123;</span><br><span class="line">                <span class="comment">// 判断key的类型</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> jedis.type(key);</span><br><span class="line">                <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;string&quot;</span>:</span><br><span class="line">                        len = jedis.strlen(key);</span><br><span class="line">                        maxLen = STR_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;hash&quot;</span>:</span><br><span class="line">                        len = jedis.hlen(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;list&quot;</span>:</span><br><span class="line">                        len = jedis.llen(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;set&quot;</span>:</span><br><span class="line">                        len = jedis.scard(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;zset&quot;</span>:</span><br><span class="line">                        len = jedis.zcard(key);</span><br><span class="line">                        maxLen = HASH_MAX_LEN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (len &gt;= maxLen) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;Found big key : %s, type: %s, length or size: %d %n&quot;</span>, key, type, len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!cursor.equals(<span class="string">&quot;0&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三方工具"><a href="#第三方工具" class="headerlink" title="第三方工具"></a>第三方工具</h4><ul>
<li>利用第三方工具，如 Redis-Rdb-Tools 分析RDB快照文件，全面分析内存使用情况</li>
<li><a target="_blank" rel="noopener" href="https://github.com/sripathikrishnan/redis-rdb-tools">https://github.com/sripathikrishnan/redis-rdb-tools</a></li>
</ul>
<h4 id="网络监控"><a href="#网络监控" class="headerlink" title="网络监控"></a>网络监控</h4><ul>
<li>自定义工具，监控进出Redis的网络数据，超出预警值时主动告警</li>
<li>一般阿里云搭建的云服务器就有相关监控页面</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521140415785.png" alt="image-20220521140415785"></p>
<h3 id="如何删除BigKey"><a href="#如何删除BigKey" class="headerlink" title="如何删除BigKey"></a>如何删除BigKey</h3><p>BigKey内存占用较多，即便时删除这样的key也需要耗费很长时间，导致Redis主线程阻塞，引发一系列问题。</p>
<ul>
<li>redis 3.0 及以下版本<ul>
<li>如果是集合类型，则遍历BigKey的元素，先逐个删除子元素，最后删除BigKey</li>
</ul>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521140621204.png" alt="image-20220521140621204"></p>
<ul>
<li>Redis 4.0以后<ul>
<li>Redis在4.0后提供了异步删除的命令：unlink</li>
</ul>
</li>
</ul>
<h2 id="恰当的数据类型"><a href="#恰当的数据类型" class="headerlink" title="恰当的数据类型"></a>恰当的数据类型</h2><h3 id="存储一个User对象，我们有三种存储方式："><a href="#存储一个User对象，我们有三种存储方式：" class="headerlink" title="存储一个User对象，我们有三种存储方式："></a>存储一个User对象，我们有三种存储方式：</h3><h4 id="json字符串"><a href="#json字符串" class="headerlink" title="json字符串"></a>json字符串</h4><table>
<thead>
<tr>
<th align="center">user:1</th>
<th align="center">{“name”: “Jack”, “age”: 21}</th>
</tr>
</thead>
</table>
<p>优点：实现简单粗暴</p>
<p>缺点：数据耦合，不够灵活</p>
<h4 id="字段打散"><a href="#字段打散" class="headerlink" title="字段打散"></a>字段打散</h4><table>
<thead>
<tr>
<th align="center">user:1:name</th>
<th align="center">Jack</th>
</tr>
</thead>
<tbody><tr>
<td align="center">user:1:age</td>
<td align="center">21</td>
</tr>
</tbody></table>
<p>优点：可以灵活访问对象任意字段</p>
<p>缺点：占用空间大、没办法做统一控制</p>
<h4 id="hash（推荐）"><a href="#hash（推荐）" class="headerlink" title="hash（推荐）"></a>hash（推荐）</h4><table>
    <tr>
        <td rowspan="2">user:1</td>
        <td>name</td>
        <td>jack</td>
    </tr>
    <tr>
        <td>age</td>
        <td>21</td>
    </tr>
</table>



<p>优点：底层使用ziplist，空间占用小，可以灵活访问对象的任意字段</p>
<p>缺点：代码相对复杂</p>
<h3 id="假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？"><a href="#假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？" class="headerlink" title="假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？"></a>假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？</h3><table>
    <tr style="color:red">
        <td>key</td>
        <td>field</td>
        <td>value</td>
    </tr>
    <tr>
        <td rowspan="3">someKey</td>
        <td>id:0</td>
        <td>value0</td>
    </tr>
    <tr>
        <td>.....</td>
        <td>.....</td>
    </tr>
    <tr>
        <td>id:999999</td>
        <td>value999999</td>
    </tr>
</table>



<p>存在的问题：</p>
<ul>
<li>hash的entry数量超过500时，会使用哈希表而不是ZipList，内存占用较多<ul>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521142943350.png" alt="image-20220521142943350"></li>
</ul>
</li>
<li>可以通过hash-max-ziplist-entries配置entry上限。但是如果entry过多就会导致BigKey问题</li>
</ul>
<h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>拆分为string类型</p>
<table>
    <tr style="color:red">
        <td>key</td>
        <td>value</td>
    </tr>
    <tr>
        <td>id:0</td>
        <td>value0</td>
    </tr>
    <tr>
        <td>.....</td>
        <td>.....</td>
    </tr>
    <tr>
        <td>id:999999</td>
        <td>value999999</td>
    </tr>
</table>



<p>存在的问题：</p>
<ul>
<li>string结构底层没有太多内存优化，内存占用较多</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521143458010.png" alt="image-20220521143458010"></p>
<ul>
<li>想要批量获取这些数据比较麻烦</li>
</ul>
<h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>拆分为小的hash，将 id / 100 作为key， 将id % 100 作为field，这样每100个元素为一个Hash</p>
<table>
    <tr style="color:red">
        <td>key</td>
        <td>field</td>
        <td>value</td>
    </tr>
    <tr>
        <td rowspan="3">key:0</td>
        <td>id:00</td>
        <td>value0</td>
    </tr>
    <tr>
        <td>.....</td>
        <td>.....</td>
    </tr>
    <tr>
        <td>id:99</td>
        <td>value99</td>
    </tr>
    <tr>
        <td rowspan="3">key:1</td>
        <td>id:00</td>
        <td>value100</td>
    </tr>
    <tr>
        <td>.....</td>
        <td>.....</td>
    </tr>
    <tr>
        <td>id:99</td>
        <td>value199</td>
    </tr>
    <tr>
        <td colspan="3">....</td>
    </tr>
    <tr>
        <td rowspan="3">key:9999</td>
        <td>id:00</td>
        <td>value999900</td>
    </tr>
    <tr>
        <td>.....</td>
        <td>.....</td>
    </tr>
    <tr>
        <td>id:99</td>
        <td>value999999</td>
    </tr>
</table>



<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521144339377.png" alt="image-20220521144339377"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.heima.jedis.util.JedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Pipeline;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.ScanResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="comment">// jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span></span><br><span class="line">        jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">        <span class="comment">// 2.设置密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.选择库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSetBigKey</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">650</span>; i++) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;hello_&quot;</span> + i, <span class="string">&quot;world!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.hmset(<span class="string">&quot;m2&quot;</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testBigHash</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;key_&quot;</span> + i, <span class="string">&quot;value_&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.hmset(<span class="string">&quot;test:big:hash&quot;</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testBigString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            jedis.set(<span class="string">&quot;test:str:key_&quot;</span> + i, <span class="string">&quot;value_&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSmallHash</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hashSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(hashSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (i - <span class="number">1</span>) / hashSize;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> i % hashSize;</span><br><span class="line">            map.put(<span class="string">&quot;key_&quot;</span> + v, <span class="string">&quot;value_&quot;</span> + v);</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="number">0</span>) &#123;</span><br><span class="line">                jedis.hmset(<span class="string">&quot;test:small:hash_&quot;</span> + k, map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Key的最佳实践<ul>
<li>固定格式：[业务名]:[数据名]:[id]</li>
<li>足够简短：不超过44字节</li>
<li>不包含特殊字符</li>
</ul>
</li>
<li>Value的最佳实践：<ul>
<li>合理的拆分数据，拒绝BigKey</li>
<li>选择合适数据结构</li>
<li>Hash结构的entry数量不要超过1000</li>
<li>设置合理的超时时间</li>
</ul>
</li>
</ul>
<h1 id="二、批处理优化"><a href="#二、批处理优化" class="headerlink" title="二、批处理优化"></a>二、批处理优化</h1><h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><h3 id="我们的客户端与redis服务器是这样交互的"><a href="#我们的客户端与redis服务器是这样交互的" class="headerlink" title="我们的客户端与redis服务器是这样交互的"></a>我们的客户端与redis服务器是这样交互的</h3><p>单个命令的执行流程</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521151459880.png" alt="image-20220521151459880"></p>
<p>N条命令的执行流程</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521151524621.png" alt="image-20220521151524621"></p>
<p>redis处理指令是很快的，主要花费的时候在于网络传输。于是乎很容易想到将多条指令批量的传输给redis</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220521151902080.png" alt="image-20220521151902080"></p>
<h3 id="MSet"><a href="#MSet" class="headerlink" title="MSet"></a>MSet</h3><p>Redis提供了很多Mxxx这样的命令，可以实现批量插入数据，例如：</p>
<ul>
<li>mset</li>
<li>hmset</li>
</ul>
<p>利用mset批量插入10万条数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMxx</span><span class="params">()</span> &#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2000</span>];</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        j = (i % <span class="number">1000</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        arr[j] = <span class="string">&quot;test:key_&quot;</span> + i;</span><br><span class="line">        arr[j + <span class="number">1</span>] = <span class="string">&quot;value_&quot;</span> + i;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            jedis.mset(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time: &quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Pipeline-1"><a href="#Pipeline-1" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>MSET虽然可以批处理，但是却只能操作部分数据类型，因此如果有对复杂数据类型的批处理需要，建议使用Pipeline</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPipeline</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 放入命令到管道</span></span><br><span class="line">        pipeline.set(<span class="string">&quot;test:key_&quot;</span> + i, <span class="string">&quot;value_&quot;</span> + i);</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 每放入1000条命令，批量执行</span></span><br><span class="line">            pipeline.sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time: &quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集群下的批处理"><a href="#集群下的批处理" class="headerlink" title="集群下的批处理"></a>集群下的批处理</h2><p>如MSET或Pipeline这样的批处理需要在一次请求中携带多条命令，而此时如果Redis是一个集群，那批处理命令的多个key必须落在一个插槽中，否则就会导致执行失败。大家可以想一想这样的要求其实很难实现，因为我们在批处理时，可能一次要插入很多条数据，这些数据很有可能不会都落在相同的节点上，这就会导致报错了</p>
<p>这个时候，我们可以找到4种解决方案</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653126446641.png" alt="1653126446641"></p>
<p>第一种方案：串行执行，所以这种方式没有什么意义，当然，执行起来就很简单了，缺点就是耗时过久。</p>
<p>第二种方案：串行slot，简单来说，就是执行前，客户端先计算一下对应的key的slot，一样slot的key就放到一个组里边，不同的，就放到不同的组里边，然后对每个组执行pipeline的批处理，他就能串行执行各个组的命令，这种做法比第一种方法耗时要少，但是缺点呢，相对来说复杂一点，所以这种方案还需要优化一下</p>
<p>第三种方案：并行slot，相较于第二种方案，在分组完成后串行执行，第三种方案，就变成了并行执行各个命令，所以他的耗时就非常短，但是实现呢，也更加复杂。</p>
<p>第四种：hash_tag，redis计算key的slot的时候，其实是根据key的有效部分来计算的，通过这种方式就能一次处理所有的key，这种方式耗时最短，实现也简单，但是如果通过操作key的有效部分，那么就会导致所有的key都落在一个节点上，产生数据倾斜的问题，所以我们推荐使用第三种方式。</p>
<h3 id="串行化执行代码实践"><a href="#串行化执行代码实践" class="headerlink" title="串行化执行代码实践"></a>串行化执行代码实践</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisClusterTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JedisCluster jedisCluster;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        poolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">        HashSet&lt;HostAndPort&gt; nodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7001</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7002</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7003</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8001</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8002</span>));</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8003</span>));</span><br><span class="line">        jedisCluster = <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(nodes, poolConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testMSet</span><span class="params">()</span> &#123;</span><br><span class="line">        jedisCluster.mset(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>, <span class="string">&quot;sex&quot;</span>, <span class="string">&quot;male&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testMSet2</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;Male&quot;</span>);</span><br><span class="line">        <span class="comment">//对Map数据进行分组。根据相同的slot放在一个分组</span></span><br><span class="line">        <span class="comment">//key就是slot，value就是一个组</span></span><br><span class="line">        Map&lt;Integer, List&lt;Map.Entry&lt;String, String&gt;&gt;&gt; result = map.entrySet()</span><br><span class="line">                .stream()</span><br><span class="line">                .collect(Collectors.groupingBy(</span><br><span class="line">                        entry -&gt; ClusterSlotHashUtil.calculateSlot(entry.getKey()))</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">//串行的去执行mset的逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Map.Entry&lt;String, String&gt;&gt; list : result.values()) &#123;</span><br><span class="line">            String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[list.size() * <span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                j = i&lt;&lt;<span class="number">2</span>;</span><br><span class="line">                Map.Entry&lt;String, String&gt; e = list.get(<span class="number">0</span>);</span><br><span class="line">                arr[j] = e.getKey();</span><br><span class="line">                arr[j + <span class="number">1</span>] = e.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">            jedisCluster.mset(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedisCluster != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedisCluster.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring集群环境下批处理代码"><a href="#Spring集群环境下批处理代码" class="headerlink" title="Spring集群环境下批处理代码"></a>Spring集群环境下批处理代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">testMSetInCluster</span><span class="params">()</span> &#123;</span><br><span class="line">     Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">     map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;Female&quot;</span>);</span><br><span class="line">     stringRedisTemplate.opsForValue().multiSet(map);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     List&lt;String&gt; strings = stringRedisTemplate.opsForValue().multiGet(Arrays.asList(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;sex&quot;</span>));</span><br><span class="line">     strings.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>原理分析</strong></p>
<p>在RedisAdvancedClusterAsyncCommandsImpl 类中</p>
<p>首先根据slotHash算出来一个partitioned的map，map中的key就是slot，而他的value就是对应的对应相同slot的key对应的数据</p>
<p>通过 RedisFuture<String> mset = super.mset(op);进行异步的消息发送</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RedisFuture&lt;String&gt; <span class="title function_">mset</span><span class="params">(Map&lt;K, V&gt; map)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, List&lt;K&gt;&gt; partitioned = SlotHash.partition(codec, map.keySet());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (partitioned.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.mset(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, RedisFuture&lt;String&gt;&gt; executions = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, List&lt;K&gt;&gt; entry : partitioned.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;K, V&gt; op = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        entry.getValue().forEach(k -&gt; op.put(k, map.get(k)));</span><br><span class="line"></span><br><span class="line">        RedisFuture&lt;String&gt; mset = <span class="built_in">super</span>.mset(op);</span><br><span class="line">        executions.put(entry.getKey(), mset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MultiNodeExecution.firstOfAsync(executions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、服务器端优化"><a href="#三、服务器端优化" class="headerlink" title="三、服务器端优化"></a>三、服务器端优化</h1><h2 id="持久化配置"><a href="#持久化配置" class="headerlink" title="持久化配置"></a>持久化配置</h2><p>Redis的持久化虽然可以保证数据安全，但也会带来很多额外的开销，因此持久化请遵循下列建议：</p>
<ul>
<li>用来做缓存的Redis实例尽量不要开启持久化功能</li>
<li>建议关闭RDB持久化功能，使用AOF持久化</li>
<li>利用脚本定期在slave节点做RDB，实现数据备份</li>
<li>设置合理的rewrite阈值，避免频繁的bgrewrite</li>
<li>配置no-appendfsync-on-rewrite = yes，禁止在rewrite期间做aof，避免因AOF引起的阻塞</li>
<li>部署有关建议：<ul>
<li>Redis实例的物理机要预留足够内存，应对fork和rewrite</li>
<li>单个Redis实例内存上限不要太大，例如4G或8G。可以加快fork的速度、减少主从同步、数据迁移压力</li>
<li>不要与CPU密集型应用部署在一起</li>
<li>不要与高硬盘负载应用一起部署。例如：数据库、消息队列</li>
</ul>
</li>
</ul>
<h2 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h2><h3 id="什么是慢查询"><a href="#什么是慢查询" class="headerlink" title="什么是慢查询"></a>什么是慢查询</h3><p>并不是很慢的查询才是慢查询，而是：在Redis执行时耗时超过某个阈值的命令，称为慢查询。</p>
<p>慢查询的危害：由于Redis是单线程的，所以当客户端发出指令后，他们都会进入到redis底层的queue来执行，如果此时有一些慢查询的数据，就会导致大量请求阻塞，从而引起报错，所以我们需要解决慢查询问题。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653129590210.png" alt="1653129590210"></p>
<p>慢查询的阈值可以通过配置指定：</p>
<p>slowlog-log-slower-than：慢查询阈值，单位是微秒。默认是10000，建议1000</p>
<p>慢查询会被放入慢查询日志中，日志的长度有上限，可以通过配置指定：</p>
<p>slowlog-max-len：慢查询日志（本质是一个队列）的长度。默认是128，建议1000</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653130457771.png" alt="1653130457771"></p>
<p>修改这两个配置可以使用：config set命令：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653130475979.png" alt="1653130475979"></p>
<h3 id="如何查看慢查询"><a href="#如何查看慢查询" class="headerlink" title="如何查看慢查询"></a>如何查看慢查询</h3><p>知道了以上内容之后，那么咱们如何去查看慢查询日志列表呢：</p>
<ul>
<li>slowlog len：查询慢查询日志长度</li>
<li>slowlog get [n]：读取n条慢查询日志</li>
<li>slowlog reset：清空慢查询列表</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653130858066.png" alt="1653130858066"></p>
<h2 id="命令及安全配置"><a href="#命令及安全配置" class="headerlink" title="命令及安全配置"></a>命令及安全配置</h2><p> 安全可以说是服务器端一个非常重要的话题，如果安全出现了问题，那么一旦这个漏洞被一些坏人知道了之后，并且进行攻击，那么这就会给咱们的系统带来很多的损失，所以我们这节课就来解决这个问题。</p>
<p>Redis会绑定在0.0.0.0:6379，这样将会将Redis服务暴露到公网上，而Redis如果没有做身份认证，会出现严重的安全漏洞.<br>漏洞重现方式：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1039000">https://cloud.tencent.com/developer/article/1039000</a></p>
<p>为什么会出现不需要密码也能够登录呢，主要是Redis考虑到每次登录都比较麻烦，所以Redis就有一种ssh免秘钥登录的方式，生成一对公钥和私钥，私钥放在本地，公钥放在redis端，当我们登录时服务器，再登录时候，他会去解析公钥和私钥，如果没有问题，则不需要利用redis的登录也能访问，这种做法本身也很常见，但是这里有一个前提，前提就是公钥必须保存在服务器上，才行，但是Redis的漏洞在于在不登录的情况下，也能把秘钥送到Linux服务器，从而产生漏洞</p>
<p>漏洞出现的核心的原因有以下几点：</p>
<ul>
<li>Redis未设置密码</li>
<li>利用了Redis的config set命令动态修改Redis配置</li>
<li>使用了Root账号权限启动Redis</li>
</ul>
<p>所以：如何解决呢？我们可以采用如下几种方案</p>
<p>为了避免这样的漏洞，这里给出一些建议：</p>
<ul>
<li>Redis一定要设置密码</li>
<li>禁止线上使用下面命令：keys、flushall、flushdb、config set等命令。可以利用rename-command禁用。</li>
<li>bind：限制网卡，禁止外网网卡访问</li>
<li>开启防火墙</li>
<li>不要使用Root账户启动Redis</li>
<li>尽量不是有默认的端口</li>
</ul>
<h2 id="Redis内存划分和内存配置"><a href="#Redis内存划分和内存配置" class="headerlink" title="Redis内存划分和内存配置"></a>Redis内存划分和内存配置</h2><p>当Redis内存不足时，可能导致Key频繁被删除、响应时间变长、QPS不稳定等问题。当内存使用率达到90%以上时就需要我们警惕，并快速定位到内存占用的原因。</p>
<p><strong>有关碎片问题分析</strong></p>
<p>Redis底层分配并不是这个key有多大，他就会分配多大，而是有他自己的分配策略，比如8,16,20等等，假定当前key只需要10个字节，此时分配8肯定不够，那么他就会分配16个字节，多出来的6个字节就不能被使用，这就是我们常说的 碎片问题</p>
<p><strong>进程内存问题分析：</strong></p>
<p>这片内存，通常我们都可以忽略不计</p>
<p><strong>缓冲区内存问题分析：</strong></p>
<p>一般包括客户端缓冲区、AOF缓冲区、复制缓冲区等。客户端缓冲区又包括输入缓冲区和输出缓冲区两种。这部分内存占用波动较大，所以这片内存也是我们需要重点分析的内存问题。</p>
<table>
<thead>
<tr>
<th><strong>内存占用</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>数据内存</td>
<td>是Redis最主要的部分，存储Redis的键值信息。主要问题是BigKey问题、内存碎片问题</td>
</tr>
<tr>
<td>进程内存</td>
<td>Redis主进程本身运⾏肯定需要占⽤内存，如代码、常量池等等；这部分内存⼤约⼏兆，在⼤多数⽣产环境中与Redis数据占⽤的内存相⽐可以忽略。</td>
</tr>
<tr>
<td>缓冲区内存</td>
<td>一般包括客户端缓冲区、AOF缓冲区、复制缓冲区等。客户端缓冲区又包括输入缓冲区和输出缓冲区两种。这部分内存占用波动较大，不当使用BigKey，可能导致内存溢出。</td>
</tr>
</tbody></table>
<p>于是我们就需要通过一些命令，可以查看到Redis目前的内存分配状态：</p>
<ul>
<li>info memory：查看内存分配的情况</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653132073570.png" alt="1653132073570"></p>
<ul>
<li>memory xxx：查看key的主要占用情况</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653132098823.png" alt="1653132098823"></p>
<p>接下来我们看到了这些配置，最关键的缓存区内存如何定位和解决呢？</p>
<p>内存缓冲区常见的有三种：</p>
<ul>
<li>复制缓冲区：主从复制的repl_backlog_buf，如果太小可能导致频繁的全量复制，影响性能。通过replbacklog-size来设置，默认1mb</li>
<li>AOF缓冲区：AOF刷盘之前的缓存区域，AOF执行rewrite的缓冲区。无法设置容量上限</li>
<li>客户端缓冲区：分为输入缓冲区和输出缓冲区，输入缓冲区最大1G且不能设置。输出缓冲区可以设置</li>
</ul>
<p>以上复制缓冲区和AOF缓冲区 不会有问题，最关键就是客户端缓冲区的问题</p>
<p>客户端缓冲区：指的就是我们发送命令时，客户端用来缓存命令的一个缓冲区，也就是我们向redis输入数据的输入端缓冲区和redis向客户端返回数据的响应缓存区，输入缓冲区最大1G且不能设置，所以这一块我们根本不用担心，如果超过了这个空间，redis会直接断开，因为本来此时此刻就代表着redis处理不过来了，我们需要担心的就是输出端缓冲区</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653132410073.png" alt="1653132410073"></p>
<p>我们在使用redis过程中，处理大量的big value，那么会导致我们的输出结果过多，如果输出缓存区过大，会导致redis直接断开，而默认配置的情况下， 其实他是没有大小的，这就比较坑了，内存可能一下子被占满，会直接导致咱们的redis断开，所以解决方案有两个</p>
<p>1、设置一个大小</p>
<p>2、增加我们带宽的大小，避免我们出现大量数据从而直接超过了redis的承受能力</p>
<h2 id="集群优化-集群-or-主从"><a href="#集群优化-集群-or-主从" class="headerlink" title="集群优化 集群 or 主从"></a>集群优化 集群 or 主从</h2><p>集群虽然具备高可用特性，能实现自动故障恢复，但是如果使用不当，也会存在一些问题：</p>
<ul>
<li><p>集群完整性问题</p>
</li>
<li><p>集群带宽问题</p>
</li>
<li><p>数据倾斜问题</p>
</li>
<li><p>客户端性能问题</p>
</li>
<li><p>命令的集群兼容性问题</p>
</li>
<li><p>lua和事务问题</p>
</li>
<li><p><em>问题1、在Redis的默认配置中，如果发现任意一个插槽不可用，则整个集群都会停止对外服务：</em>* </p>
</li>
</ul>
<p>大家可以设想一下，如果有几个slot不能使用，那么此时整个集群都不能用了，我们在开发中，其实最重要的是可用性，所以需要把如下配置修改成no，即有slot不能使用时，我们的redis集群还是可以对外提供服务</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1653132740637.png" alt="1653132740637"></p>
<p><strong>问题2、集群带宽问题</strong></p>
<p>集群节点之间会不断的互相Ping来确定集群中其它节点的状态。每次Ping携带的信息至少包括：</p>
<ul>
<li>插槽信息</li>
<li>集群状态信息</li>
</ul>
<p>集群中节点越多，集群状态信息数据量也越大，10个节点的相关信息可能达到1kb，此时每次集群互通需要的带宽会非常高，这样会导致集群中大量的带宽都会被ping信息所占用，这是一个非常可怕的问题，所以我们需要去解决这样的问题</p>
<p><strong>解决途径：</strong></p>
<ul>
<li>避免大集群，集群节点数不要太多，最好少于1000，如果业务庞大，则建立多个集群。</li>
<li>避免在单个物理机中运行太多Redis实例</li>
<li>配置合适的cluster-node-timeout值</li>
</ul>
<p><strong>问题3、命令的集群兼容性问题</strong></p>
<p>有关这个问题咱们已经探讨过了，当我们使用批处理的命令时，redis要求我们的key必须落在相同的slot上，然后大量的key同时操作时，是无法完成的，所以客户端必须要对这样的数据进行处理，这些方案我们之前已经探讨过了，所以不再这个地方赘述了。</p>
<p><strong>问题4、lua和事务的问题</strong></p>
<p>lua和事务都是要保证原子性问题，如果你的key不在一个节点，那么是无法保证lua的执行和事务的特性的，所以在集群模式是没有办法执行lua和事务的</p>
<p><strong>那我们到底是集群还是主从</strong></p>
<p>单体Redis（主从Redis）已经能达到万级别的QPS，并且也具备很强的高可用特性。如果主从能满足业务需求的情况下，所以如果不是在万不得已的情况下，尽量不搭建Redis集群</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/04/MySQL%20%E8%BF%90%E7%BB%B4%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/04/MySQL%20%E8%BF%90%E7%BB%B4%E7%AF%87/" class="post-title-link" itemprop="url">MySQL 运维篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-04 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-04T00:00:00+08:00">2024-10-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 15:27:00" itemprop="dateModified" datetime="2025-04-27T15:27:00+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="运维篇"><a href="#运维篇" class="headerlink" title="运维篇"></a>运维篇</h1><h2 id="MySQL-客户端管理"><a href="#MySQL-客户端管理" class="headerlink" title="MySQL 客户端管理"></a>MySQL 客户端管理</h2><h3 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a>系统数据库</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018231950720-1730191893980-1.png" alt="image-20241018231950720"></p>
<h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018231940461-1730191893981-2.png" alt="image-20241018231940461"></p>
<p>import只能导入dump加-T参数导出的txt文本，source用来执行.sql文件</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>记录了当 mysqld 启动和停止时，以及<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%9C%8D%E5%8A%A1%E5%99%A8&spm=1001.2101.3001.7020">服务器</a>在运行过程中<strong>发生任何严重错误时的相关信息</strong>。当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。</p>
<p>该日志是默认开启的，默认存放目录 /var/log/，默认的日志文件名为 mysqld.log 。查看日志位置：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#先登录mysql</span><br><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p1234</span><br><span class="line"></span><br><span class="line">#通过此系统变量查看日志文件的位置</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_error%&#x27;</span>;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><p>记录 MySQL 上的所有<strong>变化</strong>并<strong>以二进制形式</strong>保存在磁盘上。包括所有的DDL和DML语句，但不包括DQL语句。主要用于<mark>主从复制<mark>、<mark>灾难时的数据库恢复<mark>。</p>
<p>binlog由server层的执行器生成，历史比redolog和undolog都早，和存储引擎没有关系。</p>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><h5 id="STATEMENT"><a href="#STATEMENT" class="headerlink" title="STATEMENT"></a>STATEMENT</h5><p>记录SQL语句，如果有动态函数会恢复不准确，这里就属于逻辑日志</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029171133144.png" alt="image-20241029171133144"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029191323110.png" alt="image-20241029191323110"></p>
<h5 id="ROW"><a href="#ROW" class="headerlink" title="ROW"></a>ROW</h5><p>记录行数据修改之前和之后的数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029171203288.png" alt="image-20241029171203288"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029191145845.png" alt="image-20241029191145845"></p>
<h5 id="MIXED"><a href="#MIXED" class="headerlink" title="MIXED"></a>MIXED</h5><h4 id="写入过程"><a href="#写入过程" class="headerlink" title="写入过程"></a>写入过程</h4><p>事务开始以后的执行过程都写到内存中的binlog cache，事务提交后会write写入 page cache，仍然在内存中，需要通过刷盘操作fsync才能持久化到磁盘。</p>
<ul>
<li><code>sync_binlog</code> = <code>1(default)</code> 表示每次提交事务都要在写入page cache的同时刷盘，性能较低但安全；</li>
<li><code>sync_binlog</code> = <code>0</code> 表示每次提交事务以后只写入page cache，刷盘时机交给系统确定，性能高但是不安全，会导致宕机以后page cache的binlog全部丢失；</li>
<li><code>sync_binlog</code> = <code>N</code> 表示累计N个事务才write，折中方案。 </li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029174232239.png" alt="image-20241029174232239"></p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><h5 id="手动删除"><a href="#手动删除" class="headerlink" title="手动删除"></a>手动删除</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/aa35434/article/details/133524177">MySql运维篇—008：日志：错误日志、二进制日志、查询日志、慢查询日志，主从复制：概述 虚拟机更改ip注意事项、原理、搭建步骤_mysql 错误日志-CSDN博客</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029191529628.png" alt="image-20241029191529628"></p>
<h5 id="自动删除"><a href="#自动删除" class="headerlink" title="自动删除"></a>自动删除</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029191602409.png" alt="image-20241029191602409"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029191632832.png" alt="image-20241029191632832"></p>
<h4 id="和其他日志的异同"><a href="#和其他日志的异同" class="headerlink" title="和其他日志的异同"></a>和其他日志的异同</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/pengweid/article/details/136887291">彻底讲透：MySQL中的三种日志（Undo Log、Redo Log和Binlog）_undolog日志类型-CSDN博客</a></p>
<h5 id="RedoLog-amp-BinLog"><a href="#RedoLog-amp-BinLog" class="headerlink" title="RedoLog &amp; BinLog"></a>RedoLog &amp; BinLog</h5><h6 id="持久化粒度不同"><a href="#持久化粒度不同" class="headerlink" title="持久化粒度不同"></a>持久化粒度不同</h6><ul>
<li>redolog让InnoDB有了事务崩溃恢复能力，保证了<strong>事务</strong>中的持久性，确保事务已经提交的修改能正确写入磁盘中。</li>
<li>binlog则是保证整个MySQL<strong>数据库</strong>集群架构的数据一致性。</li>
</ul>
<h6 id="写入时机不同—两阶段写入"><a href="#写入时机不同—两阶段写入" class="headerlink" title="写入时机不同—两阶段写入"></a>写入时机不同—两阶段写入</h6><ul>
<li>redolog在事务执行过程中可以不断写入，依赖于存储引擎：</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029174344508.png" alt="image-20241029174344508"></p>
<ul>
<li>binlog只有在事务提交时才写入，依赖于执行器（调用完存储引擎API）。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029175255030.png" alt="image-20241029175255030"></p>
<ul>
<li>这就导致虽然两个都能保证持久化能力，但两个是相对独立的，如果其中一个出现错误，就会出现数据不一致的情况，因此需要分阶段写入：将redolog的状态分成两个阶段：prepare和commit，在提交事务时，先写入binlog，再进行redolog commit。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029175500294.png" alt="image-20241029175500294"></p>
<ul>
<li>遇到事故时停机重启，根据redolog恢复数据，redolog处于commit阶段，表明binlog正常写入；redolog处于prepare阶段，binlog正常写入，这时也是完整的，也会提交；redolog处于prepare阶段，找不到对应binlog，此次更改作废。</li>
</ul>
<h6 id="顺序写入但方式不同"><a href="#顺序写入但方式不同" class="headerlink" title="顺序写入但方式不同"></a>顺序写入但方式不同</h6><ul>
<li>redolog是一个日志文件组循环写，当数据成功刷到磁盘就会擦除日志</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029173203896.png" alt="image-20241029173203896"></p>
<p>binlog一直追加写，写满一个文件就创建新文件继续写，保存的是全量日志。事务更改提交以后刷盘失败的恢复能用redolog，如果是整个数据库层级的操作，比如主从复制或者数据备份，就必须用全量日志binlog。</p>
<h5 id="UndoLog-amp-BinLog"><a href="#UndoLog-amp-BinLog" class="headerlink" title="UndoLog &amp; BinLog"></a>UndoLog &amp; BinLog</h5><h6 id="逻辑日志，粒度与方向不同"><a href="#逻辑日志，粒度与方向不同" class="headerlink" title="逻辑日志，粒度与方向不同"></a>逻辑日志，粒度与方向不同</h6><ul>
<li><p>UndoLog属于底层的InnoDB，记录反向操作，粒度更细，用于<strong>事务</strong>的回滚和MVCC（避免锁竞争，提高并发性能）</p>
</li>
<li><p>Binlog属于Server层的执行器，记录正向操作，用于<strong>数据库</strong>备份和复制</p>
</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>Undo Log和Redo Log是为了实现ACID特性中的A（原子性）、C（一致性）和D（持久性）。Undo Log保证了事务内部的一致性以及事务失败后的回滚能力；而Redo Log则是为了保证即使在意外情况下也能恢复已提交事务的更改。</li>
<li>Binlog的设计则更多地关注于高可用性、数据冗余以及分布式环境下的数据同步。它提供了跨节点间的数据复制功能，同时也为数据库管理员提供了审计跟踪和数据恢复手段。</li>
</ul>
<p>类比实际生活：</p>
<ul>
<li><p>首先，Undo Log这位“传令兵”，负责记录每一步操作的反向指令，一旦有差池，便能瞬间执行“撤退”命令，让事务回滚至初始状态，确保了原子性与一致性，就如同战场上的兵马未动粮草先行，进退有序。</p>
<p>其次，Redo Log这位“记事官”，专司记录每一次<strong>物理操作</strong>的详细步骤，即便遭遇突袭或断电，也能根据记录重新搭建战局，恢复已提交事务的影响，确保数据持久不灭，犹如战场上刀光剑影过后，总能找到重整旗鼓的依据。</p>
<p>最后，Binlog这位“信使”，肩负着跨营地同步信息的重要使命，无论主从服务器之间还是备份恢复之时，只需将它传递的信息忠实执行，就能保证所有营地的数据步调一致，仿佛军令如山，一呼百应，千里之外亦可响应无误。</p>
</li>
</ul>
<h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029191825721.png" alt="image-20241029191825721"></p>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>所有查询时间，扫描记录数超过阈值的SQL语句</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029191835513.png" alt="image-20241029191835513"></p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>主库出现问题，快速切换服务</li>
<li>读写分离降低主库压力</li>
<li>从库执行备份，避免主库被全局锁定</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029192549256.png" alt="image-20241029192549256"></p>
<p>从上图来看，复制分成三步:<br>1.Master 主库在事务提交时，会把数据变更记录（DDL.DML）在二进制日志文件 Binlog 中。</p>
<p>2.Slave 从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</p>
<p>3.Slave 从库重做中继日志中的事件，将改变反映它自己的数据</p>
<h2 id="读写分离-分库分表"><a href="#读写分离-分库分表" class="headerlink" title="读写分离 分库分表"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/high-performance/read-and-write-separation-and-library-subtable.html">读写分离 分库分表</a></h2><h2 id="冷热数据分离"><a href="#冷热数据分离" class="headerlink" title="冷热数据分离"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/high-performance/data-cold-hot-separation.html">冷热数据分离</a></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/03/distributed-lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/03/distributed-lock/" class="post-title-link" itemprop="url">分布式锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-03 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-03T00:00:00+08:00">2024-10-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 15:07:59" itemprop="dateModified" datetime="2025-04-27T15:07:59+08:00">2025-04-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>在应用开发中，特别是web工程开发，通常都是并发编程，不是多进程就是多线程。这种场景下极易出现线程并发性安全问题，此时不得不使用锁来解决问题。在多线程高并发场景下，为了保证资源的线程安全问题，jdk为我们提供了synchronized关键字和ReentrantLock可重入锁，但是它们只能保证一个工程内的线程安全。在分布式集群、微服务、云原生横行的当下，如何保证不同进程、不同服务、不同机器的线程安全问题，jdk并没有给我们提供既有的解决方案。此时，我们就必须借助于相关技术手动实现了。目前主流的实现有以下方式：</p>
<ol>
<li>基于mysql关系型实现</li>
<li>基于redis非关系型数据实现</li>
<li>基于zookeeper/etcd实现</li>
</ol>
<p>本课程将会全面深入、全程手撸代码式的讲解这三种分布式锁的实现。并深入源码讲解第三方分布式锁框架。</p>
<p>基础知识储备及技术要求： </p>
<p>​    开发工具：idea + jdk1.8<br>​    工程构建工具：maven<br>​    相关框架基础：SpringBoot SpringMVC Spring Mybatis（mybatis-plus） SpringData-Redis<br>​    数据库：mysql（InnoDB引擎 事务 锁机制） redis<br>​    负载均衡工具：nginx<br>​    压力测试工具：jmeter<br>​    其他：zookeeper lua脚本语言 JUC(java.util.concurrent相关背景知识) 微服务相关背景知识</p>
<h1 id="传统分布式锁"><a href="#传统分布式锁" class="headerlink" title="传统分布式锁"></a>传统分布式锁</h1><h2 id="从减库存聊起"><a href="#从减库存聊起" class="headerlink" title="从减库存聊起"></a>从减库存聊起</h2><p>多线程并发安全问题最典型的代表就是超卖现象</p>
<p>库存在并发量较大情况下很容易发生超卖现象，一旦发生超卖现象，就会出现多成交了订单而发不了货的情况。</p>
<p>场景：</p>
<p>​        商品S库存余量为5时，用户A和B同时来购买一个商品，此时查询库存数都为5，库存充足则开始减库存：</p>
<p>用户A：update db_stock set stock = stock - 1 where id = 1</p>
<p>用户B：update db_stock set stock = stock - 1 where id = 1</p>
<p>并发情况下，更新后的结果可能是4，而实际的最终库存量应该是3才对</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>建表语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `db_stock` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `product_code` varchar(255) DEFAULT NULL COMMENT &#x27;商品编号&#x27;,</span><br><span class="line">  `stock_code` varchar(255) DEFAULT NULL COMMENT &#x27;仓库编号&#x27;,</span><br><span class="line">  `count` int(11) DEFAULT NULL COMMENT &#x27;库存量&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p>表中数据如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606400425343.png" alt="1606400425343"></p>
<p>1001商品在001仓库有5000件库存。</p>
<p>创建分布式锁demo工程：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606393792456.png" alt="1606393792456"></p>
<p>创建好之后：</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606395123427.png" alt="1606395123427"></p>
<p>pom.xml如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.11.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>distributed-lock<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>distributed-lock<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>分布式锁demo工程<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.46<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>application.yml配置文件：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://172.16.116.100:3306/test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">172.16</span><span class="number">.116</span><span class="number">.100</span></span><br></pre></td></tr></table></figure>

<p>DistributedLockApplication启动类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.atguigu.distributedlock.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributedLockApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DistributedLockApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Stock实体类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@TableName(&quot;db_stock&quot;)</span><br><span class="line">public class Stock &#123;</span><br><span class="line"></span><br><span class="line">    @TableId</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    private String productCode;</span><br><span class="line"></span><br><span class="line">    private String stockCode;</span><br><span class="line"></span><br><span class="line">    private Integer count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StockMapper接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StockMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Stock&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="简单实现减库存"><a href="#简单实现减库存" class="headerlink" title="简单实现减库存"></a>简单实现减库存</h2><p>接下来咱们代码实操一下。</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606400144254.png" alt="1606400144254"></p>
<p>StockController：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;check/lock&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">checkAndLock</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.stockService.checkAndLock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;验库存并锁库存成功！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StockService：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StockMapper stockMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAndLock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先查询库存是否充足</span></span><br><span class="line">        <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="built_in">this</span>.stockMapper.selectById(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再减库存</span></span><br><span class="line">        <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            stock.setCount(stock.getCount() - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.stockMapper.updateById(stock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606400294689.png" alt="1606400294689"></p>
<p>查看数据库：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606400340594.png" alt="1606400340594"></p>
<p>在浏览器中一个一个访问时，每访问一次，库存量减1，没有任何问题。</p>
<h2 id="演示超卖现象"><a href="#演示超卖现象" class="headerlink" title="演示超卖现象"></a>演示超卖现象</h2><p>接下来咱们使用jmeter压力测试工具，高并发下压测一下，添加线程组：并发100循环50次，即5000次请求。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606442946203.png" alt="1606442946203"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606443124589.png" alt="1606443124589"></p>
<p>给线程组添加HTTP Request请求：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606443172072.png" alt="1606443172072"></p>
<p>填写测试接口路径如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606443276322.png" alt="1606443276322"></p>
<p>再选择你想要的测试报表，例如这里选择聚合报告：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606443541407.png" alt="1606443541407"></p>
<p>启动测试，查看压力测试报告：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220313204754310.png" alt="image-20220313204754310"></p>
<ul>
<li>Label          取样器别名，如果勾选<strong>Include group name</strong> ，则会添加线程组的名称作为前缀</li>
<li># Samples      取样器运行次数</li>
<li>Average       请求（事务）的平均响应时间</li>
<li>Median        中位数</li>
<li>90% Line       90%用户响应时间</li>
<li>95% Line       90%用户响应时间</li>
<li>99% Line       90%用户响应时间</li>
<li>Min           最小响应时间</li>
<li>Max           最大响应时间</li>
<li>Error          错误率</li>
<li>Throughput     吞吐率</li>
<li>Received KB/sec  每秒收到的千字节</li>
<li>Sent KB/sec      每秒收到的千字节</li>
</ul>
<p>测试结果：请求总数5000次，平均请求时间37ms，中位数（50%）请求是在36ms内完成的，错误率0%，每秒钟平均吞吐量2568.1次。</p>
<p>查看mysql数据库剩余库存数：还有4870</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606445079298.png" alt="1606445079298"></p>
<p>此时如果还有人来下单，就会出现超卖现象（别人购买成功，而无货可发）。</p>
<h2 id="jvm锁问题演示"><a href="#jvm锁问题演示" class="headerlink" title="jvm锁问题演示"></a>jvm锁问题演示</h2><h3 id="添加jvm锁"><a href="#添加jvm锁" class="headerlink" title="添加jvm锁"></a>添加jvm锁</h3><p>使用jvm锁（synchronized关键字或者ReetrantLock）试试：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606448306438.png" alt="1606448306438"></p>
<p>重启tomcat服务，再次使用jmeter压力测试，效果如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220313212150451.png" alt="image-20220313212150451"></p>
<p>查看mysql数据库：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606448616499.png" alt="1606448616499"></p>
<p>并没有发生超卖现象，完美解决。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>添加synchronized关键字之后，StockService就具备了对象锁，由于添加了独占的排他锁，同一时刻只有一个请求能够获取到锁，并减库存。此时，所有请求只会one-by-one执行下去，也就不会发生超卖现象。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606448189738.png" alt="1606448189738"></p>
<h2 id="多服务问题"><a href="#多服务问题" class="headerlink" title="多服务问题"></a>多服务问题</h2><p>使用jvm锁在单工程单服务情况下确实没有问题，但是在集群情况下会怎样？</p>
<p>接下启动多个服务并使用nginx负载均衡，结构如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606453095867.png" alt="1606453095867"></p>
<p>启动三个服务（端口号分别8000 8100 8200），如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606468851705.png" alt="1606468851705"></p>
<h3 id="安装配置nginx"><a href="#安装配置nginx" class="headerlink" title="安装配置nginx"></a>安装配置nginx</h3><p>基于安装nginx：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span></span><br><span class="line">docker pull nginx:latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建nginx对应资源、日志及配置目录</span></span><br><span class="line">mkdir -p /opt/nginx/logs /opt/nginx/conf /opt/nginx/html</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先在conf目录下创建nginx.conf文件，配置内容参照下方</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再运行容器</span></span><br><span class="line">docker run -d -p 80:80 --name nginx -v /opt/nginx/html:/usr/share/nginx/html -v /opt/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /opt/nginx/logs:/var/log/nginx nginx</span><br></pre></td></tr></table></figure>

<p>nginx.conf配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/<span class="literal">error</span>.log <span class="literal">warn</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#include /etc/nginx/conf.d/*.conf;</span></span><br><span class="line">	</span><br><span class="line">	<span class="section">upstream</span> distributed &#123;</span><br><span class="line">		<span class="attribute">server</span> <span class="number">172.16.116.1:8000</span>;</span><br><span class="line">		<span class="attribute">server</span> <span class="number">172.16.116.1:8100</span>;</span><br><span class="line">		<span class="attribute">server</span> <span class="number">172.16.116.1:8200</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="section">server</span> &#123;</span><br><span class="line">		<span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">172.16.116.100</span>;</span><br><span class="line">		<span class="section">location</span> / &#123;</span><br><span class="line">			<span class="attribute">proxy_pass</span> http://distributed;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在浏览器中测试：172.16.116.100是我的nginx服务器地址</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606467613477.png" alt="1606467613477"></p>
<p>经过测试，通过nginx访问服务一切正常。</p>
<h3 id="Jmeter压力测试"><a href="#Jmeter压力测试" class="headerlink" title="Jmeter压力测试"></a>Jmeter压力测试</h3><p>注意：先把数据库库存量还原到5000。</p>
<p>参照之前的测试用例，再创建一个新的测试组：参数给之前一样</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606467848874.png" alt="1606467848874"></p>
<p>配置nginx的地址及 服务的访问路径如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606467953589.png" alt="1606467953589"></p>
<p>测试结果：性能只是略有提升。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220313215233371.png" alt="image-20220313215233371"></p>
<p>数据库库存剩余量如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606469161544.png" alt="1606469161544"></p>
<p>又出现了并发问题，即出现了超卖现象。</p>
<h2 id="mysql锁演示"><a href="#mysql锁演示" class="headerlink" title="mysql锁演示"></a>mysql锁演示</h2><p>除了使用jvm锁之外，还可以使用数据锁：<strong>悲观锁</strong> 或者 <strong>乐观锁</strong></p>
<ol>
<li><p>一个sql：直接更新时判断，在更新中判断库存是否大于0 </p>
<p>update table set surplus = (surplus - buyQuantity) where id = 1 and (surplus - buyQuantity) &gt; 0 ;</p>
</li>
<li><p>悲观锁：在读取数据时锁住那几行，其他对这几行的更新需要等到悲观锁结束时才能继续 。</p>
<p>select … for update</p>
</li>
<li><p>乐观锁：读取数据时不锁，更新时检查是否数据已经被更新过，如果是则取消当前更新进行重试。</p>
<p>version 或者 时间戳（CAS思想）。</p>
</li>
</ol>
<h3 id="一个sql"><a href="#一个sql" class="headerlink" title="一个sql"></a>一个sql</h3><p>略。。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>在MySQL的InnoDB中，预设的Tansaction isolation level 为REPEATABLE READ（可重读）</p>
<p><strong>在SELECT 的读取锁定主要分为两种方式：</strong></p>
<ul>
<li>SELECT … LOCK IN SHARE MODE　（共享锁）</li>
<li>SELECT … FOR UPDATE                     （悲观锁）</li>
</ul>
<p>这两种方式在事务(Transaction) 进行当中SELECT 到同一个数据表时，都必须等待其它事务数据被提交(Commit)后才会执行。</p>
<p>而主要的不同在于LOCK IN SHARE MODE 在有一方事务要Update 同一个表单时很容易造成死锁。</p>
<p>简单的说，如果SELECT 后面若要UPDATE 同一个表单，最好使用SELECT … FOR UPDATE。</p>
<p><strong>代码实现</strong></p>
<p>改造StockService：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606487086837.png" alt="1606487086837"></p>
<p>在StockeMapper中定义selectStockForUpdate方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StockMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Stock&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Stock <span class="title function_">selectStockForUpdate</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在StockMapper.xml中定义对应的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.atguigu.distributedlock.mapper.StockMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStockForUpdate&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.distributedlock.pojo.Stock&quot;</span>&gt;</span></span><br><span class="line">        select * from db_stock where id = #&#123;id&#125; for update</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>压力测试</strong></p>
<p>注意：测试之前，需要把库存量改成5000。压测数据如下：比jvm性能高很多，比无锁要低将近1倍</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606487362848.png" alt="1606487362848"></p>
<p>mysql数据库存：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606487554822.png" alt="1606487554822"></p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则重试。那么我们如何实现乐观锁呢</p>
<p>使用数据版本（Version）记录机制实现，这是乐观锁最常用的实现 方式。一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录 的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新。</p>
<p>给db_stock表添加version字段：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606489307266.png" alt="1606489307266"></p>
<p>对应也需要给Stock实体类添加version属性。此处略。。。。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAndLock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先查询库存是否充足</span></span><br><span class="line">    <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="built_in">this</span>.stockMapper.selectById(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再减库存</span></span><br><span class="line">    <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 获取版本号</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">version</span> <span class="operator">=</span> stock.getVersion();</span><br><span class="line"></span><br><span class="line">        stock.setCount(stock.getCount() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 每次更新 版本号 + 1</span></span><br><span class="line">        stock.setVersion(stock.getVersion() + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 更新之前先判断是否是之前查询的那个版本，如果不是重试</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.stockMapper.update(stock, <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;Stock&gt;().eq(<span class="string">&quot;id&quot;</span>, stock.getId()).eq(<span class="string">&quot;version&quot;</span>, version)) == <span class="number">0</span>) &#123;</span><br><span class="line">            checkAndLock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启后使用jmeter压力测试工具结果如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606491642613.png" alt="1606491642613"></p>
<p>修改测试参数如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606491689743.png" alt="1606491689743"></p>
<p>测试结果如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606491754596.png" alt="1606491754596"></p>
<p>说明乐观锁在并发量越大的情况下，性能越低（因为需要大量的重试）；并发量越小，性能越高。</p>
<h3 id="mysql锁总结"><a href="#mysql锁总结" class="headerlink" title="mysql锁总结"></a>mysql锁总结</h3><p>性能：一个sql &gt; 悲观锁 &gt; jvm锁 &gt; 乐观锁</p>
<p>如果追求极致性能、业务场景简单并且不需要记录数据前后变化的情况下。</p>
<p>​        优先选择：一个sql</p>
<p>如果写并发量较低（多读），争抢不是很激烈的情况下优先选择：乐观锁</p>
<p>如果写并发量较高，一般会经常冲突，此时选择乐观锁的话，会导致业务代码不间断的重试。</p>
<p>​        优先选择：mysql悲观锁</p>
<p>不推荐jvm本地锁。</p>
<h2 id="redis乐观锁"><a href="#redis乐观锁" class="headerlink" title="redis乐观锁"></a>redis乐观锁</h2><p>利用redis监听 + 事务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">watch stock</span><br><span class="line">multi</span><br><span class="line">set stock 5000</span><br><span class="line">exec</span><br></pre></td></tr></table></figure>

<p>如果执行过程中stock的值没有被其他链接改变，则执行成功</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220428200109930.png" alt="image-20220428200109930"></p>
<p>如果执行过程中stock的值被改变，则执行失败效果如下：</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220428200244567.png" alt="image-20220428200244567"></p>
<p>具体代码实现，只需要改造对应的service方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">SessionCallback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">            operations.watch(<span class="string">&quot;stock&quot;</span>);</span><br><span class="line">            <span class="comment">// 1. 查询库存信息</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">stock</span> <span class="operator">=</span> operations.opsForValue().get(<span class="string">&quot;stock&quot;</span>);</span><br><span class="line">            <span class="comment">// 2. 判断库存是否充足</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">st</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; (st = Integer.parseInt(stock.toString())) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 3. 扣减库存</span></span><br><span class="line">                operations.multi();</span><br><span class="line">                operations.opsForValue().set(<span class="string">&quot;stock&quot;</span>, String.valueOf(--st));</span><br><span class="line">                <span class="type">List</span> <span class="variable">exec</span> <span class="operator">=</span> operations.exec();</span><br><span class="line">                <span class="keyword">if</span> (exec == <span class="literal">null</span> || exec.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    deduct();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> exec;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>借助于redis中的命令setnx(key, value)，key不存在就新增，存在就什么都不做。同时有多个客户端发送setnx命令，只有一个客户端可以成功，返回1（true）；其他的客户端返回0（false）。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606626611922.png" alt="1606626611922"></p>
<ol>
<li>多个客户端同时获取锁（setnx）</li>
<li>获取成功，执行业务逻辑，执行完成释放锁（del）</li>
<li>其他客户端等待重试</li>
</ol>
<p>改造StockService方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StockMapper stockMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁setnx</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">        <span class="comment">// 重试：递归调用</span></span><br><span class="line">        <span class="keyword">if</span> (!lock)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="built_in">this</span>.deduct();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1. 查询库存信息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">stock</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 判断库存是否充足</span></span><br><span class="line">                <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.length() != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">st</span> <span class="operator">=</span> Integer.valueOf(stock);</span><br><span class="line">                    <span class="keyword">if</span> (st &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 3.扣减库存</span></span><br><span class="line">                        redisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, String.valueOf(--st));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 解锁</span></span><br><span class="line">                <span class="built_in">this</span>.redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，加锁也可以使用循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁，获取锁失败重试</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>))&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">40</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="built_in">this</span>.redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用Jmeter压力测试如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606736612201.png" alt="1606736612201"></p>
<h2 id="防死锁"><a href="#防死锁" class="headerlink" title="防死锁"></a>防死锁</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606702476465.png" alt="1606702476465"></p>
<p>问题：setnx刚刚获取到锁，当前服务器宕机，导致del释放锁无法执行，进而导致锁无法锁无法释放（死锁）</p>
<p>解决：给锁设置过期时间，自动释放锁。</p>
<p>设置过期时间两种方式：</p>
<ol>
<li>通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放）</li>
<li>使用set指令设置过期时间：set key value ex 3 nx（既达到setnx的效果，又设置了过期时间）</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220504102416597.png" alt="image-20220504102416597"></p>
<p>压力测试肯定也没有问题。</p>
<h2 id="防误删"><a href="#防误删" class="headerlink" title="防误删"></a>防误删</h2><p>问题：可能会释放其他服务器的锁。</p>
<p>场景：如果业务逻辑的执行时间是7s。执行流程如下</p>
<ol>
<li><p>index1业务逻辑没执行完，3秒后锁被自动释放。</p>
</li>
<li><p>index2获取到锁，执行业务逻辑，3秒后锁被自动释放。</p>
</li>
<li><p>index3获取到锁，执行业务逻辑</p>
</li>
<li><p>index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。</p>
<p>最终等于没锁的情况。</p>
</li>
</ol>
<p>解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606707959639.png" alt="1606707959639"></p>
<p>实现如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220504102714512.png" alt="image-20220504102714512"></p>
<p>问题：删除操作缺乏原子性。</p>
<p>场景：</p>
<ol>
<li>index1执行删除时，查询到的lock值确实和uuid相等</li>
<li>index1执行删除前，lock刚好过期时间已到，被redis自动释放</li>
<li>index2获取了lock</li>
<li>index1执行删除，此时会把index2的lock删除</li>
</ol>
<p>解决方案：没有一个命令可以同时做到判断 + 删除，所有只能通过其他方式实现（<strong>LUA脚本</strong>）</p>
<h2 id="redis中的lua脚本"><a href="#redis中的lua脚本" class="headerlink" title="redis中的lua脚本"></a>redis中的lua脚本</h2><h3 id="现实问题"><a href="#现实问题" class="headerlink" title="现实问题"></a>现实问题</h3><p>redis采用单线程架构，可以保证单个命令的原子性，但是无法保证一组命令在高并发场景下的原子性。例如：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606711874388.png" alt="1606711874388"></p>
<p>在串行场景下：A和B的值肯定都是3</p>
<p>在并发场景下：A和B的值可能在0-6之间。</p>
<p>极限情况下1：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606712580214.png" alt="1606712580214"></p>
<p>则A的结果是0，B的结果是3</p>
<p>极限情况下2：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606712697401.png" alt="1606712697401"></p>
<p>则A和B的结果都是6</p>
<p>如果redis客户端通过lua脚本把3个命令一次性发送给redis服务器，那么这三个指令就不会被其他客户端指令打断。Redis 也保证脚本会以原子性(atomic)的方式执行： 当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。 这和使用 MULTI/ EXEC 包围的事务很类似。 </p>
<p>但是MULTI/ EXEC方法来使用事务功能，将一组命令打包执行，无法进行业务逻辑的操作。这期间有某一条命令执行报错（例如给字符串自增），其他的命令还是会执行，并不会回滚。</p>
<h3 id="lua介绍"><a href="#lua介绍" class="headerlink" title="lua介绍"></a>lua介绍</h3><p>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p>
<p><strong>设计目的</strong></p>
<p>​    其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p>
<p><strong>Lua 特性</strong></p>
<ul>
<li><strong>轻量级</strong>：它用标准C语言编写并以源代码形式开放，编译后仅仅一百余K，可以很方便的嵌入别的程序里。</li>
<li><strong>可扩展</strong>：Lua提供了非常易于使用的扩展接口和机制：由宿主语言(通常是C或C++)提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。</li>
<li>其它特性：<ul>
<li>支持面向过程(procedure-oriented)编程和函数式编程(functional programming)；</li>
<li>自动内存管理；只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象；</li>
<li>语言内置模式匹配；闭包(closure)；函数也可以看做一个值；提供多线程（协同进程，并非操作系统所支持的线程）支持；</li>
<li>通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。</li>
</ul>
</li>
</ul>
<h3 id="lua基本语法"><a href="#lua基本语法" class="headerlink" title="lua基本语法"></a>lua基本语法</h3><p>对lua脚本感兴趣的同学，请移步到官方教程或者《菜鸟教程》。这里仅以redis中可能会用到的部分语法作介绍。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span>               <span class="comment">-- 全局变量</span></span><br><span class="line"><span class="keyword">local</span> b = <span class="number">5</span>         <span class="comment">-- 局部变量， redis只支持局部变量</span></span><br><span class="line">a, b = <span class="number">10</span>, <span class="number">2</span>*x      <span class="comment">-- 等价于       a=10; b=2*x</span></span><br></pre></td></tr></table></figure>

<p>流程控制：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( 布尔表达式 <span class="number">1</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 在布尔表达式 1 为 true 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">elseif</span>( 布尔表达式 <span class="number">2</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 在布尔表达式 2 为 true 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">   <span class="comment">--[ 如果以上布尔表达式都不为 true 则执行该语句块 --]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="redis执行lua脚本-EVAL指令"><a href="#redis执行lua脚本-EVAL指令" class="headerlink" title="redis执行lua脚本 - EVAL指令"></a>redis执行lua脚本 - EVAL指令</h3><p>在redis中需要通过eval命令执行lua脚本。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EVAL script numkeys key [key ...] arg [arg ...]</span><br><span class="line">script：lua脚本字符串，这段Lua脚本不需要（也不应该）定义函数。</span><br><span class="line">numkeys：lua脚本中KEYS数组的大小</span><br><span class="line">key [key ...]：KEYS数组中的元素</span><br><span class="line">arg [arg ...]：ARGV数组中的元素</span><br></pre></td></tr></table></figure>

<p>案例1：基本案例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;return 10&quot; 0</span><br></pre></td></tr></table></figure>

<p>输出：(integer) 10</p>
<p>案例2：动态传参</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot; 5 10 20 30 40 50 60 70 80 90</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出：10 20 60 70</span></span><br><span class="line"></span><br><span class="line">EVAL &quot;if KEYS[1] &gt; ARGV[1] then return 1 else return 0 end&quot; 1 10 20</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出：0</span></span><br><span class="line"></span><br><span class="line">EVAL &quot;if KEYS[1] &gt; ARGV[1] then return 1 else return 0 end&quot; 1 20 10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出：1</span></span><br></pre></td></tr></table></figure>

<p>传入了两个参数10和20，KEYS的长度是1，所以KEYS中有一个元素10，剩余的一个20就是ARGV数组的元素。</p>
<p>redis.call()中的redis是redis中提供的lua脚本类库，仅在redis环境中可以使用该类库。</p>
<p>案例3：执行redis类库方法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set aaa 10  -- 设置一个aaa值为10</span><br><span class="line">EVAL &quot;return redis.call(&#x27;get&#x27;, &#x27;aaa&#x27;)&quot; 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过<span class="built_in">return</span>把call方法返回给redis客户端，打印：<span class="string">&quot;10&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>脚本里使用的所有键都应该由 KEYS 数组来传递。</strong>但并不是强制性的，代价是这样写出的脚本不能被 Redis 集群所兼容。</p>
<p>案例4：给redis类库方法动态传参</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[1])&quot; 1 bbb 20</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1600610957600.png" alt="1600610957600"></p>
<p>学到这里基本可以应付redis分布式锁所需要的脚本知识了。</p>
<p>案例5：pcall函数的使用（了解）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 当call() 在执行命令的过程中发生错误时，脚本会停止执行，并返回一个脚本错误，输出错误信息</span><br><span class="line">EVAL &quot;return redis.call(&#x27;sets&#x27;, KEYS[1], ARGV[1]), redis.call(&#x27;set&#x27;, KEYS[2], ARGV[2])&quot; 2 bbb ccc 20 30</span><br><span class="line">-- pcall函数不影响后续指令的执行</span><br><span class="line">EVAL &quot;return redis.pcall(&#x27;sets&#x27;, KEYS[1], ARGV[1]), redis.pcall(&#x27;set&#x27;, KEYS[2], ARGV[2])&quot; 2 bbb ccc 20 30</span><br></pre></td></tr></table></figure>

<p><strong>注意：set方法写成了sets</strong>，肯定会报错。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1600612707202.png" alt="1600612707202"></p>
<h2 id="使用lua保证删除原子性"><a href="#使用lua保证删除原子性" class="headerlink" title="使用lua保证删除原子性"></a>使用lua保证删除原子性</h2><p>删除LUA脚本：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span> <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]) <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="comment">// 加锁setnx</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, uuid, <span class="number">3</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        <span class="comment">// 重试：循环</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// this.redisTemplate.expire(&quot;lock&quot;, 3, TimeUnit.SECONDS);</span></span><br><span class="line">        <span class="comment">// 1. 查询库存信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">stock</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">st</span> <span class="operator">=</span> Integer.valueOf(stock);</span><br><span class="line">            <span class="keyword">if</span> (st &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 3.扣减库存</span></span><br><span class="line">                redisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, String.valueOf(--st));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 先判断是否自己的锁，再解锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] &quot;</span> +</span><br><span class="line">            <span class="string">&quot;then &quot;</span> +</span><br><span class="line">            <span class="string">&quot;   return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;else &quot;</span> +</span><br><span class="line">            <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">            <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(<span class="string">&quot;lock&quot;</span>), uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>压力测试，库存量也没有问题，截图略过。。。</p>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>由于上述加锁命令使用了 SETNX ，一旦键存在就无法再设置成功，这就导致后续同一线程内继续加锁，将会加锁失败。当一个线程执行一段代码成功获取锁之后，继续执行时，又遇到加锁的子任务代码，可重入性就保证线程能继续执行，而不可重入就是需要等待锁释放之后，再次获取锁成功，才能继续往下执行。</p>
<p>用一段 Java 代码解释可重入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// pass</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 X 线程在 a 方法获取锁之后，继续执行 b 方法，如果此时<strong>不可重入</strong>，线程就必须等待锁释放，再次争抢锁。</p>
<p>锁明明是被 X 线程拥有，却还需要等待自己释放锁，然后再去抢锁，这看起来就很奇怪，我释放我自己~</p>
<p>可重入性就可以解决这个尴尬的问题，当线程拥有锁之后，往后再遇到加锁方法，直接将加锁次数加 1，然后再执行方法逻辑。退出加锁方法之后，加锁次数再减 1，当加锁次数为 0 时，锁才被真正的释放。</p>
<p>可以看到可重入锁最大特性就是计数，计算加锁的次数。所以当可重入锁需要在分布式环境实现时，我们也就需要统计加锁次数。</p>
<p>解决方案：redis + Hash</p>
<h3 id="加锁脚本"><a href="#加锁脚本" class="headerlink" title="加锁脚本"></a>加锁脚本</h3><p>Redis 提供了 Hash （哈希表）这种可以存储键值对数据结构。所以我们可以使用 Redis Hash 存储的锁的重入次数，然后利用 lua 脚本判断逻辑。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span> <span class="keyword">or</span> redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]) == <span class="number">1</span>) </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>假设值为：KEYS:[lock], ARGV[uuid, expire]</p>
<p>如果锁不存在或者这是自己的锁，就通过hincrby（不存在就新增并加1，存在就加1）获取锁或者锁次数加1。</p>
<h3 id="解锁脚本"><a href="#解锁脚本" class="headerlink" title="解锁脚本"></a>解锁脚本</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 判断 hash set 可重入 key 的值是否等于 0</span></span><br><span class="line"><span class="comment">-- 如果为 nil 代表 自己的锁已不存在，在尝试解其他线程的锁，解锁失败</span></span><br><span class="line"><span class="comment">-- 如果为 0 代表 可重入次数被减 1</span></span><br><span class="line"><span class="comment">-- 如果为 1 代表 该可重入 key 解锁成功</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; </span><br><span class="line"><span class="keyword">elseif</span>(redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], <span class="number">-1</span>) &gt; <span class="number">0</span>) <span class="keyword">then</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>



<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>由于加解锁代码量相对较多，这里可以封装成一个工具类：</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220504095916188.png" alt="image-20220504095916188"></p>
<p>DistributedLockClient工厂类具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributedLockClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DistributedLockClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.uuid = UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DistributedRedisLock <span class="title function_">getRedisLock</span><span class="params">(String lockName)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DistributedRedisLock</span>(redisTemplate, lockName, uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DistributedRedisLock实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributedRedisLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">expire</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DistributedRedisLock</span><span class="params">(StringRedisTemplate redisTemplate, String lockName, String uuid)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.lockName = lockName;</span><br><span class="line">        <span class="built_in">this</span>.uuid = uuid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tryLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.tryLock(-<span class="number">1L</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (time != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.expire = unit.toSeconds(time);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;exists&#x27;, KEYS[1]) == 0 or redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return 1 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">this</span>.redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(lockName), getId(), String.valueOf(expire)))&#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return nil &quot;</span> +</span><br><span class="line">                <span class="string">&quot;elseif redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1) == 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="built_in">this</span>.redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Long.class), Arrays.asList(lockName), getId());</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>(<span class="string">&quot;this lock doesn&#x27;t belong to you!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给线程拼接唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getId</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uuid + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="使用及测试"><a href="#使用及测试" class="headerlink" title="使用及测试"></a>使用及测试</h3><p>在业务代码中使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DistributedRedisLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> <span class="built_in">this</span>.distributedLockClient.getRedisLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    redisLock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 查询库存信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">stock</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">st</span> <span class="operator">=</span> Integer.valueOf(stock);</span><br><span class="line">            <span class="keyword">if</span> (st &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 3.扣减库存</span></span><br><span class="line">                redisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, String.valueOf(--st));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        redisLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606747747780.png" alt="1606747747780"></p>
<p>测试可重入性：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220504101636357.png" alt="image-20220504101636357"></p>
<h2 id="自动续期"><a href="#自动续期" class="headerlink" title="自动续期"></a>自动续期</h2><p>lua脚本：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]) == <span class="number">1</span>) <span class="keyword">then</span> </span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>在RedisDistributeLock中添加renewExpire方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributedRedisLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">expire</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DistributedRedisLock</span><span class="params">(StringRedisTemplate redisTemplate, String lockName, String uuid)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.lockName = lockName;</span><br><span class="line">        <span class="built_in">this</span>.uuid = uuid + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tryLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.tryLock(-<span class="number">1L</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (time != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.expire = unit.toSeconds(time);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;exists&#x27;, KEYS[1]) == 0 or redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return 1 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">this</span>.redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(lockName), uuid, String.valueOf(expire)))&#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加锁成功，返回之前，开启定时器自动续期</span></span><br><span class="line">        <span class="built_in">this</span>.renewExpire();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return nil &quot;</span> +</span><br><span class="line">                <span class="string">&quot;elseif redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1) == 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="built_in">this</span>.redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Long.class), Arrays.asList(lockName), uuid);</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>(<span class="string">&quot;this lock doesn&#x27;t belong to you!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String getId()&#123;</span></span><br><span class="line">    <span class="comment">//     return this.uuid + &quot;:&quot; + Thread.currentThread().getId();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpire</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2]) &quot;</span> +</span><br><span class="line">                <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                <span class="string">&quot;   return 0 &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Timer</span>().schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(lockName), uuid, String.valueOf(expire))) &#123;</span><br><span class="line">                    renewExpire();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="built_in">this</span>.expire * <span class="number">1000</span> / <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在tryLock方法中使用：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220504100503780.png" alt="image-20220504100503780"></p>
<p>构造方法作如下修改：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220504100728343.png" alt="image-20220504100728343"></p>
<p>解锁方法作如下修改：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220504100850162.png" alt="image-20220504100850162"></p>
<h2 id="手写分步式锁小结"><a href="#手写分步式锁小结" class="headerlink" title="手写分步式锁小结"></a>手写分步式锁小结</h2><p>特征：</p>
<ol>
<li><p>独占排他：setnx</p>
</li>
<li><p>防死锁：</p>
<p>redis客户端程序获取到锁之后，立马宕机。给锁添加过期时间</p>
<p>不可重入：可重入</p>
</li>
<li><p>防误删：</p>
<p>先判断是否自己的锁才能删除</p>
</li>
<li><p>原子性：</p>
<p>加锁和过期时间之间：set k v ex 3 nx</p>
<p>判断和释放锁之间：lua脚本</p>
</li>
<li><p>可重入性：hash（key field value） + lua脚本 </p>
</li>
<li><p>自动续期：Timer定时器 + lua脚本</p>
</li>
<li><p>在集群情况下，导致锁机制失效：</p>
<ol>
<li>客户端程序10010，从主中获取锁</li>
<li>从还没来得及同步数据，主挂了</li>
<li>于是从升级为主</li>
<li>客户端程序10086就从新主中获取到锁，导致锁机制失效</li>
</ol>
</li>
</ol>
<p>锁操作：</p>
<p>加锁：</p>
<ol>
<li><p>setnx：独占排他   死锁、不可重入、原子性</p>
</li>
<li><p>set k v ex 30 nx：独占排他、死锁         不可重入 </p>
</li>
<li><p>hash + lua脚本：可重入锁</p>
<ol>
<li>判断锁是否被占用（exists），如果没有被占用则直接获取锁（hset/hincrby）并设置过期时间（expire）</li>
<li>如果锁被占用，则判断是否当前线程占用的（hexists），如果是则重入（hincrby）并重置过期时间（expire）</li>
<li>否则获取锁失败，将来代码中重试</li>
</ol>
</li>
<li><p>Timer定时器 + lua脚本：实现锁的自动续期</p>
<p>判断锁是否自己的锁（hexists == 1），如果是自己的锁则执行expire重置过期时间</p>
</li>
</ol>
<p>解锁 </p>
<ol>
<li>del：导致误删</li>
<li>先判断再删除同时保证原子性：lua脚本</li>
<li>hash + lua脚本：可重入 <pre><code>1. 判断当前线程的锁是否存在，不存在则返回nil，将来抛出异常
</code></pre>
<ol start="2">
<li>存在则直接减1（hincrby -1），判断减1后的值是否为0，为0则释放锁（del），并返回1</li>
<li>不为0，则返回0</li>
</ol>
</li>
</ol>
<p>重试：递归 循环 </p>
<h2 id="红锁算法"><a href="#红锁算法" class="headerlink" title="红锁算法"></a>红锁算法</h2><p>redis集群状态下的问题：</p>
<ol>
<li>客户端A从master获取到锁</li>
<li>在master将锁同步到slave之前，master宕掉了。</li>
<li>slave节点被晋级为master节点</li>
<li>客户端B取得了同一个资源被客户端A已经获取到的另外一个锁。</li>
</ol>
<p><strong>安全失效</strong>！</p>
<p>解决集群下锁失效，参照redis官方网站针对redlock文档：<a target="_blank" rel="noopener" href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a></p>
<p>在算法的分布式版本中，我们假设有N个Redis服务器。这些节点是完全独立的，因此我们不使用复制或任何其他隐式协调系统。<strong>前几节已经描述了如何在单个实例中安全地获取和释放锁，在分布式锁算法中，将使用相同的方法在单个实例中获取和释放锁。</strong>将N设置为5是一个合理的值，因此需要在不同的计算机或虚拟机上运行5个Redis主服务器，确保它们以独立的方式发生故障。</p>
<p>为了获取锁，客户端执行以下操作：</p>
<ol>
<li>客户端以毫秒为单位获取当前时间的时间戳，作为<strong>起始时间</strong>。</li>
<li>客户端尝试在所有N个实例中顺序使用相同的键名、相同的随机值来获取锁定。每个实例尝试获取锁都需要时间，客户端应该设置一个远小于总锁定时间的超时时间。例如，如果自动释放时间为10秒，则<strong>尝试获取锁的超时时间</strong>可能在5到50毫秒之间。这样可以防止客户端长时间与处于故障状态的Redis节点进行通信：如果某个实例不可用，尽快尝试与下一个实例进行通信。</li>
<li>客户端获取当前时间 减去在步骤1中获得的<strong>起始时间</strong>，来计算<strong>获取锁所花费的时间</strong>。当且仅当客户端能够在大多数实例（至少3个）中获取锁时，并且获取锁所花费的总时间小于锁有效时间，则认为已获取锁。</li>
<li>如果获取了锁，则将锁有效时间减去 <strong>获取锁所花费的时间</strong>，如步骤3中所计算。</li>
<li>如果客户端由于某种原因（无法锁定N / 2 + 1个实例或有效时间为负）而未能获得该锁，它将尝试解锁所有实例（即使没有锁定成功的实例）。</li>
</ol>
<p>每台计算机都有一个本地时钟，我们通常可以依靠不同的计算机来产生很小的时钟漂移。只有在拥有锁的客户端将在锁有效时间内（如步骤3中获得的）减去一段时间（仅几毫秒）的情况下终止工作，才能保证这一点。以补偿进程之间的时钟漂移</p>
<p>当客户端无法获取锁时，它应该在随机延迟后重试，以避免同时获取同一资源的多个客户端之间不同步（这可能会导致脑裂的情况：没人胜）。同样，客户端在大多数Redis实例中尝试获取锁的速度越快，出现裂脑情况（以及需要重试）的窗口就越小，因此理想情况下，客户端应尝试将SET命令发送到N个实例同时使用多路复用。</p>
<p>值得强调的是，对于未能获得大多数锁的客户端，尽快释放（部分）获得的锁有多么重要，这样就不必等待锁定期满才能再次获得锁（但是，如果发生了网络分区，并且客户端不再能够与Redis实例进行通信，则在等待密钥到期时需要付出可用性损失）。</p>
<h2 id="redisson中的分布式锁"><a href="#redisson中的分布式锁" class="headerlink" title="redisson中的分布式锁"></a>redisson中的分布式锁</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220501155501783.png" alt="image-20220501155501783"></p>
<p>​        Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish / Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1568176834908.png" alt="1568176834908"></p>
<p>官方文档地址：<a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki">https://github.com/redisson/redisson/wiki</a></p>
<h3 id="2-1-可重入锁（Reentrant-Lock）"><a href="#2-1-可重入锁（Reentrant-Lock）" class="headerlink" title="2.1 可重入锁（Reentrant Lock）"></a>2.1 可重入锁（Reentrant Lock）</h3><p>基于Redis的Redisson分布式可重入锁<code>RLock</code> Java对象实现了<code>java.util.concurrent.locks.Lock</code>接口。</p>
<p>大家都知道，如果负责储存这个分布式锁的Redisson节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情况的发生，Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。默认情况下，看门狗检查锁的超时时间是30秒钟，也可以通过修改<code>Config.lockWatchdogTimeout</code>来另行指定。</p>
<p><code>RLock</code>对象完全符合Java的Lock规范。也就是说只有拥有锁的进程才能解锁，其他进程解锁则会抛出<code>IllegalMonitorStateException</code>错误。</p>
<p>另外Redisson还通过加锁的方法提供了<code>leaseTime</code>的参数来指定加锁的时间。超过这个时间后锁便自动解开了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line"><span class="comment">// 最常见的使用方法</span></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁以后10秒钟自动解锁</span></span><br><span class="line"><span class="comment">// 无需调用unlock方法手动解锁</span></span><br><span class="line">lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> lock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">if</span> (res) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>添加配置</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">// 可以用&quot;rediss://&quot;来启用SSL连接</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://172.16.116.100:6379&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>代码中使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAndLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁，获取锁失败重试</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.redissonClient.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先查询库存是否充足</span></span><br><span class="line">    <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="built_in">this</span>.stockMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">// 再减库存</span></span><br><span class="line">    <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        stock.setCount(stock.getCount() - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.stockMapper.updateById(stock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>压力测试</li>
</ol>
<p>性能跟我们手写的区别不大。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606958454966.png" alt="1606958454966"></p>
<p>数据库也没有问题</p>
<h3 id="2-1-公平锁（Fair-Lock）"><a href="#2-1-公平锁（Fair-Lock）" class="headerlink" title="2.1 公平锁（Fair Lock）"></a>2.1 公平锁（Fair Lock）</h3><p>基于Redis的Redisson分布式可重入公平锁也是实现了<code>java.util.concurrent.locks.Lock</code>接口的一种<code>RLock</code>对象。同时还提供了<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockAsync.html">异步（Async）</a>、<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockReactive.html">反射式（Reactive）</a>和<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLockRx.html">RxJava2标准</a>的接口。它保证了当多个Redisson客户端线程同时请求加锁时，优先分配给先发出请求的线程。所有请求线程会在一个队列中排队，当某个线程出现宕机时，Redisson会等待5秒后继续下一个线程，也就是说如果前面有5个线程都处于等待状态，那么后面的线程会等待至少25秒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> redisson.getFairLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line"><span class="comment">// 最常见的使用方法</span></span><br><span class="line">fairLock.lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10秒钟以后自动解锁</span></span><br><span class="line"><span class="comment">// 无需调用unlock方法手动解锁</span></span><br><span class="line">fairLock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> fairLock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">fairLock.unlock();</span><br></pre></td></tr></table></figure>



<h3 id="2-1-联锁（MultiLock）"><a href="#2-1-联锁（MultiLock）" class="headerlink" title="2.1 联锁（MultiLock）"></a>2.1 联锁（MultiLock）</h3><p>基于Redis的Redisson分布式联锁<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/RedissonMultiLock.html"><code>RedissonMultiLock</code></a>对象可以将多个<code>RLock</code>对象关联为一个联锁，每个<code>RLock</code>对象实例可以来自于不同的Redisson实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock1</span> <span class="operator">=</span> redissonInstance1.getLock(<span class="string">&quot;lock1&quot;</span>);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock2</span> <span class="operator">=</span> redissonInstance2.getLock(<span class="string">&quot;lock2&quot;</span>);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock3</span> <span class="operator">=</span> redissonInstance3.getLock(<span class="string">&quot;lock3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">RedissonMultiLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonMultiLock</span>(lock1, lock2, lock3);</span><br><span class="line"><span class="comment">// 同时加锁：lock1 lock2 lock3</span></span><br><span class="line"><span class="comment">// 所有的锁都上锁成功才算成功。</span></span><br><span class="line">lock.lock();</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>



<h3 id="2-1-红锁（RedLock）"><a href="#2-1-红锁（RedLock）" class="headerlink" title="2.1 红锁（RedLock）"></a>2.1 红锁（RedLock）</h3><p>基于Redis的Redisson红锁<code>RedissonRedLock</code>对象实现了<a target="_blank" rel="noopener" href="http://redis.cn/topics/distlock.html">Redlock</a>介绍的加锁算法。该对象也可以用来将多个<code>RLock</code>对象关联为一个红锁，每个<code>RLock</code>对象实例可以来自于不同的Redisson实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock1</span> <span class="operator">=</span> redissonInstance1.getLock(<span class="string">&quot;lock1&quot;</span>);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock2</span> <span class="operator">=</span> redissonInstance2.getLock(<span class="string">&quot;lock2&quot;</span>);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock3</span> <span class="operator">=</span> redissonInstance3.getLock(<span class="string">&quot;lock3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">RedissonRedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonRedLock</span>(lock1, lock2, lock3);</span><br><span class="line"><span class="comment">// 同时加锁：lock1 lock2 lock3</span></span><br><span class="line"><span class="comment">// 红锁在大部分节点上加锁成功就算成功。</span></span><br><span class="line">lock.lock();</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>



<h3 id="2-1-读写锁（ReadWriteLock）"><a href="#2-1-读写锁（ReadWriteLock）" class="headerlink" title="2.1 读写锁（ReadWriteLock）"></a>2.1 读写锁（ReadWriteLock）</h3><p>基于Redis的Redisson分布式可重入读写锁<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.4.3/org/redisson/api/RReadWriteLock.html"><code>RReadWriteLock</code></a> Java对象实现了<code>java.util.concurrent.locks.ReadWriteLock</code>接口。其中读锁和写锁都继承了<a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8#81-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81reentrant-lock">RLock</a>接口。</p>
<p>分布式可重入读写锁允许同时有多个读锁和一个写锁处于加锁状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RReadWriteLock</span> <span class="variable">rwlock</span> <span class="operator">=</span> redisson.getReadWriteLock(<span class="string">&quot;anyRWLock&quot;</span>);</span><br><span class="line"><span class="comment">// 最常见的使用方法</span></span><br><span class="line">rwlock.readLock().lock();</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">rwlock.writeLock().lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10秒钟以后自动解锁</span></span><br><span class="line"><span class="comment">// 无需调用unlock方法手动解锁</span></span><br><span class="line">rwlock.readLock().lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">rwlock.writeLock().lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> rwlock.readLock().tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> rwlock.writeLock().tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>



<p>添加StockController方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;test/read&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRead</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> stockService.testRead();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;测试读&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;test/write&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testWrite</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> stockService.testWrite();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;测试写&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>添加StockService方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">testRead</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="built_in">this</span>.redissonClient.getReadWriteLock(<span class="string">&quot;rwLock&quot;</span>);</span><br><span class="line">    rwLock.readLock().lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;测试读锁。。。。&quot;</span>);</span><br><span class="line">    <span class="comment">// rwLock.readLock().unlock();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testWrite</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="built_in">this</span>.redissonClient.getReadWriteLock(<span class="string">&quot;rwLock&quot;</span>);</span><br><span class="line">    rwLock.writeLock().lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;测试写锁。。。。&quot;</span>);</span><br><span class="line">    <span class="comment">// rwLock.writeLock().unlock();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>打开开两个浏览器窗口测试：</p>
<ul>
<li>同时访问写：一个写完之后，等待一会儿（约10s），另一个写开始</li>
<li>同时访问读：不用等待</li>
<li>先写后读：读要等待（约10s）写完成</li>
<li>先读后写：写要等待（约10s）读完成</li>
</ul>
<h3 id="2-10-6-信号量（Semaphore）"><a href="#2-10-6-信号量（Semaphore）" class="headerlink" title="2.10.6. 信号量（Semaphore）"></a>2.10.6. 信号量（Semaphore）</h3><p>基于Redis的Redisson的分布式信号量（<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphore.html">Semaphore</a>）Java对象<code>RSemaphore</code>采用了与<code>java.util.concurrent.Semaphore</code>相似的接口和用法。同时还提供了<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphoreAsync.html">异步（Async）</a>、<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphoreReactive.html">反射式（Reactive）</a>和<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphoreRx.html">RxJava2标准</a>的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RSemaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> redisson.getSemaphore(<span class="string">&quot;semaphore&quot;</span>);</span><br><span class="line">semaphore.trySetPermits(<span class="number">3</span>);</span><br><span class="line">semaphore.acquire();</span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure>



<p>在StockController添加方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;test/semaphore&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testSemaphore</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stockService.testSemaphore();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;测试信号量&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在StockService添加方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSemaphore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RSemaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="built_in">this</span>.redissonClient.getSemaphore(<span class="string">&quot;semaphore&quot;</span>);</span><br><span class="line">    semaphore.trySetPermits(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        semaphore.acquire();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        semaphore.release();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>添加测试用例：并发10次，循环一次</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606961296212.png" alt="1606961296212"></p>
<p>控制台效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">控制台1：</span><br><span class="line">1606960790234</span><br><span class="line">1606960800337</span><br><span class="line">1606960800443</span><br><span class="line">1606960805248</span><br><span class="line"></span><br><span class="line">控制台2：</span><br><span class="line">1606960790328</span><br><span class="line">1606960795332</span><br><span class="line">1606960800245</span><br><span class="line"></span><br><span class="line">控制台3：</span><br><span class="line">1606960790433</span><br><span class="line">1606960795238</span><br><span class="line">1606960795437</span><br></pre></td></tr></table></figure>



<p>由此可知：</p>
<p>1606960790秒有3次请求进来：每个控制台各1次</p>
<p>1606960795秒有3次请求进来：控制台2有1次，控制台3有2次</p>
<p>1606960800秒有3次请求进来：控制台1有2次，控制台2有1次</p>
<p>1606960805秒有1次请求进来：控制台1有1次</p>
<h3 id="2-1-闭锁（CountDownLatch）"><a href="#2-1-闭锁（CountDownLatch）" class="headerlink" title="2.1 闭锁（CountDownLatch）"></a>2.1 闭锁（CountDownLatch）</h3><p>基于Redisson的Redisson分布式闭锁（<a target="_blank" rel="noopener" href="http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RCountDownLatch.html">CountDownLatch</a>）Java对象<code>RCountDownLatch</code>采用了与<code>java.util.concurrent.CountDownLatch</code>相似的接口和用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RCountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> redisson.getCountDownLatch(<span class="string">&quot;anyCountDownLatch&quot;</span>);</span><br><span class="line">latch.trySetCount(<span class="number">1</span>);</span><br><span class="line">latch.await();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其他线程或其他JVM里</span></span><br><span class="line"><span class="type">RCountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> redisson.getCountDownLatch(<span class="string">&quot;anyCountDownLatch&quot;</span>);</span><br><span class="line">latch.countDown();</span><br></pre></td></tr></table></figure>

<p>需要两个方法：一个等待，一个计数countDown</p>
<p>给StockController添加测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;test/latch&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testLatch</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stockService.testLatch();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;班长锁门。。。&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;test/countdown&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testCountDown</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stockService.testCountDown();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;出来了一位同学&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>给StockService添加测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLatch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RCountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="built_in">this</span>.redissonClient.getCountDownLatch(<span class="string">&quot;latch&quot;</span>);</span><br><span class="line">    latch.trySetCount(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        latch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCountDown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RCountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="built_in">this</span>.redissonClient.getCountDownLatch(<span class="string">&quot;latch&quot;</span>);</span><br><span class="line">    latch.trySetCount(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    latch.countDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>重启测试，打开两个页面：当第二个请求执行6次之后，第一个请求才会执行。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606962536746.png" alt="1606962536746"></p>
<h1 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h1><p>实现分布式锁目前有三种流行方案，分别为基于数据库、Redis、Zookeeper的方案。这里主要介绍基于zk怎么实现分布式锁。在实现分布式锁之前，先回顾zookeeper的相关知识点</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220622191952608.png" alt="image-20220622191952608"></p>
<h2 id="知识点回顾"><a href="#知识点回顾" class="headerlink" title="知识点回顾"></a>知识点回顾</h2><h3 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h3><p>安装：把zk安装包上传到/opt目录下，并切换到/opt目录下，执行以下指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf zookeeper-3.7.0-bin.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重命名</span></span><br><span class="line">mv apache-zookeeper-3.7.0-bin/ zookeeper</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开zookeeper根目录</span></span><br><span class="line">cd /opt/zookeeper</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个数据目录，备用</span></span><br><span class="line">mkdir data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开zk的配置目录</span></span><br><span class="line">cd /opt/zookeeper/conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">copy配置文件，zk启动时会加载zoo.cfg文件</span></span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑配置文件</span></span><br><span class="line">vim zoo.cfg</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改dataDir参数为之前创建的数据目录：/opt/zookeeper/data</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到bin目录</span></span><br><span class="line">cd /opt/zookeeper/bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span> </span><br><span class="line">./zkServer.sh start</span><br><span class="line">./zkServer.sh status # 查看启动状态</span><br><span class="line">./zkServer.sh stop # 停止</span><br><span class="line">./zkServer.sh restart # 重启</span><br><span class="line">./zkCli.sh # 查看zk客户端</span><br></pre></td></tr></table></figure>

<p>如下，说明启动成功：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220501175644704.png" alt="image-20220501175644704"></p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>Zookeeper提供一个多层级的节点命名空间（节点称为znode），每个节点都用一个以斜杠（/）分隔的路径表示，而且每个节点都有父节点（根节点除外），非常类似于文件系统。并且每个节点都是唯一的。</p>
<p>znode节点有四种类型：</p>
<ul>
<li><strong>PERSISTENT</strong>：永久节点。客户端与zookeeper断开连接后，该节点依旧存在</li>
<li><strong>EPHEMERAL</strong>：临时节点。客户端与zookeeper断开连接后，该节点被删除</li>
<li><strong>PERSISTENT_SEQUENTIAL</strong>：永久节点、序列化。客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</li>
<li><strong>EPHEMERAL_SEQUENTIAL</strong>：临时节点、序列化。客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</li>
</ul>
<p>创建这四种节点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] create /aa test  # 创建持久化节点</span><br><span class="line">Created /aa</span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] create -s /bb test  # 创建持久序列化节点</span><br><span class="line">Created /bb0000000001</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] create -e /cc test  # 创建临时节点</span><br><span class="line">Created /cc</span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] create -e -s /dd test  # 创建临时序列化节点</span><br><span class="line">Created /dd0000000003</span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /   # 查看某个节点下的子节点</span><br><span class="line">[aa, bb0000000001, cc, dd0000000003, zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] stat /  # 查看某个节点的状态</span><br><span class="line">cZxid = 0x0</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">pZxid = 0x5</span><br><span class="line">cversion = 3</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 5</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] get /aa  # 查看某个节点的内容</span><br><span class="line">test</span><br><span class="line">[zk: localhost:2181(CONNECTED) 11] delete /aa  # 删除某个节点</span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] ls /  # 再次查看</span><br><span class="line">[bb0000000001, cc, dd0000000003, zookeeper]</span><br></pre></td></tr></table></figure>



<p>事件监听：在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时，zookeeper会通知客户端。当前zookeeper针对节点的监听有如下四种事件：</p>
<ol>
<li><p>节点创建：stat -w /xx</p>
<p>当/xx节点创建时：NodeCreated</p>
</li>
<li><p>节点删除：stat -w /xx</p>
<p>当/xx节点删除时：NodeDeleted</p>
</li>
<li><p>节点数据修改：get -w /xx</p>
<p>当/xx节点数据发生变化时：NodeDataChanged</p>
</li>
<li><p>子节点变更：ls -w /xx</p>
<p>当/xx节点的子节点创建或者删除时：NodeChildChanged</p>
</li>
</ol>
<h3 id="java客户端"><a href="#java客户端" class="headerlink" title="java客户端"></a>java客户端</h3><p>ZooKeeper的java客户端有：原生客户端、ZkClient、Curator框架（类似于redisson，有很多功能性封装）。</p>
<ol>
<li>引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>常用api及其方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> KeeperException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取zookeeper链接</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">ZooKeeper</span> <span class="variable">zooKeeper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zooKeeper = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(<span class="string">&quot;172.16.116.100:2181&quot;</span>, <span class="number">30000</span>, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Event.KeeperState.SyncConnected.equals(event.getState()) </span><br><span class="line">                            &amp;&amp; Event.EventType.None.equals(event.getType())) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;获取链接成功。。。。。。&quot;</span> + event);</span><br><span class="line">                        countDownLatch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个节点，1-节点路径 2-节点内容 3-节点的访问权限 4-节点类型</span></span><br><span class="line">        <span class="comment">// OPEN_ACL_UNSAFE：任何人可以操作该节点</span></span><br><span class="line">        <span class="comment">// CREATOR_ALL_ACL：创建者拥有所有访问权限</span></span><br><span class="line">        <span class="comment">// READ_ACL_UNSAFE: 任何人都可以读取该节点</span></span><br><span class="line">        <span class="comment">// zooKeeper.create(&quot;/atguigu/aa&quot;, &quot;haha~~&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span></span><br><span class="line">        zooKeeper.create(<span class="string">&quot;/test&quot;</span>, <span class="string">&quot;haha~~&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">        <span class="comment">// zooKeeper.create(&quot;/atguigu/cc&quot;, &quot;haha~~&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);</span></span><br><span class="line">        <span class="comment">// zooKeeper.create(&quot;/atguigu/dd&quot;, &quot;haha~~&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span></span><br><span class="line">        <span class="comment">// zooKeeper.create(&quot;/atguigu/dd&quot;, &quot;haha~~&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span></span><br><span class="line">        <span class="comment">// zooKeeper.create(&quot;/atguigu/dd&quot;, &quot;haha~~&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断节点是否存在</span></span><br><span class="line">        <span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> zooKeeper.exists(<span class="string">&quot;/test&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (stat != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前节点存在！&quot;</span> + stat.getVersion());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前节点不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断节点是否存在，同时添加监听</span></span><br><span class="line">        zooKeeper.exists(<span class="string">&quot;/test&quot;</span>, event -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取一个节点的数据</span></span><br><span class="line">        <span class="type">byte</span>[] data = zooKeeper.getData(<span class="string">&quot;/atguigu/ss0000000001&quot;</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询一个节点的所有子节点</span></span><br><span class="line">        List&lt;String&gt; children = zooKeeper.getChildren(<span class="string">&quot;/test&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        System.out.println(children);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        zooKeeper.setData(<span class="string">&quot;/test&quot;</span>, <span class="string">&quot;wawa...&quot;</span>.getBytes(), stat.getVersion());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除一个节点</span></span><br><span class="line">        <span class="comment">//zooKeeper.delete(&quot;/test&quot;, -1);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (zooKeeper != <span class="literal">null</span>)&#123;</span><br><span class="line">            zooKeeper.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>分布式锁的步骤：</p>
<ol>
<li>获取锁：create一个节点</li>
<li>删除锁：delete一个节点</li>
<li>重试：没有获取到锁的请求重试</li>
</ol>
<p>参照redis分布式锁的特点：</p>
<ol>
<li>互斥 排他</li>
<li>防死锁：<ol>
<li>可自动释放锁（临时节点） ：获得锁之后客户端所在机器宕机了，客户端没有主动删除子节点；如果创建的是永久的节点，那么这个锁永远不会释放，导致死锁；由于创建的是临时节点，客户端宕机后，过了一定时间zookeeper没有收到客户端的心跳包判断会话失效，将临时节点删除从而释放锁。</li>
<li>可重入锁：借助于ThreadLocal</li>
</ol>
</li>
<li>防误删：宕机自动释放临时节点，不需要设置过期时间，也就不存在误删问题。</li>
<li>加锁/解锁要具备原子性</li>
<li>单点问题：使用Zookeeper可以有效的解决单点问题，ZK一般是集群部署的。</li>
<li>集群问题：zookeeper集群是强一致性的，只要集群中有半数以上的机器存活，就可以对外提供服务。</li>
</ol>
<h2 id="基本实现-1"><a href="#基本实现-1" class="headerlink" title="基本实现"></a>基本实现</h2><p>实现思路：</p>
<ol>
<li>多个请求同时添加一个相同的临时节点，只有一个可以添加成功。添加成功的获取到锁</li>
<li>执行业务逻辑</li>
<li>完成业务流程后，删除节点释放锁。</li>
</ol>
<p>由于zookeeper获取链接是一个耗时过程，这里可以在项目启动时，初始化链接，并且只初始化一次。借助于spring特性，代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">connectString</span> <span class="operator">=</span> <span class="string">&quot;172.16.116.100:2181&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROOT_PATH</span> <span class="operator">=</span> <span class="string">&quot;/distributed&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 连接zookeeper服务器</span></span><br><span class="line">            <span class="built_in">this</span>.zooKeeper = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(connectString, <span class="number">30000</span>, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;获取链接成功！！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建分布式锁根节点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.zooKeeper.exists(ROOT_PATH, <span class="literal">false</span>) == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.zooKeeper.create(ROOT_PATH, <span class="literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;获取链接失败！&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (zooKeeper != <span class="literal">null</span>)&#123;</span><br><span class="line">                zooKeeper.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化zk分布式锁对象方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ZkDistributedLock <span class="title function_">getZkDistributedLock</span><span class="params">(String lockName)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ZkDistributedLock</span>(zooKeeper, lockName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>zk分布式锁具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkDistributedLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROOT_PATH</span> <span class="operator">=</span> <span class="string">&quot;/distributed&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZkDistributedLock</span><span class="params">(ZooKeeper zooKeeper, String lockName)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.zooKeeper = zooKeeper;</span><br><span class="line">        <span class="built_in">this</span>.path = ROOT_PATH + <span class="string">&quot;/&quot;</span> + lockName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zooKeeper.create(path, <span class="literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 重试</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                lock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.zooKeeper.delete(path, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>改造StockService的checkAndLock方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ZkClient client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAndLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁，获取锁失败重试</span></span><br><span class="line">    <span class="type">ZkDistributedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.client.getZkDistributedLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先查询库存是否充足</span></span><br><span class="line">    <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="built_in">this</span>.stockMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">// 再减库存</span></span><br><span class="line">    <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        stock.setCount(stock.getCount() - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.stockMapper.updateById(stock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Jmeter压力测试：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1607046072239.png" alt="1607046072239"></p>
<p>性能一般，mysql数据库的库存余量为0（注意：所有测试之前都要先修改库存量为5000）</p>
<p>基本实现存在的问题：</p>
<ol>
<li>性能一般（比mysql分布式锁略好）</li>
<li>不可重入</li>
</ol>
<p>接下来首先来提高性能</p>
<h2 id="优化：性能优化"><a href="#优化：性能优化" class="headerlink" title="优化：性能优化"></a>优化：性能优化</h2><p>基本实现中由于无限自旋影响性能：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1607048160051.png" alt="1607048160051"></p>
<p>试想：每个请求要想正常的执行完成，最终都是要创建节点，如果能够避免争抢必然可以提高性能。</p>
<p>这里借助于zk的临时序列化节点，实现分布式锁：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1607048783043.png" alt="1607048783043"></p>
<h3 id="实现阻塞锁"><a href="#实现阻塞锁" class="headerlink" title="实现阻塞锁"></a>实现阻塞锁</h3><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkDistributedLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROOT_PATH</span> <span class="operator">=</span> <span class="string">&quot;/distributed&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZkDistributedLock</span><span class="params">(ZooKeeper zooKeeper, String lockName)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.zooKeeper = zooKeeper;</span><br><span class="line">            <span class="built_in">this</span>.path = zooKeeper.create(ROOT_PATH + <span class="string">&quot;/&quot;</span> + lockName + <span class="string">&quot;-&quot;</span>, <span class="literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">preNode</span> <span class="operator">=</span> getPreNode(path);</span><br><span class="line">        <span class="comment">// 如果该节点没有前一个节点，说明该节点时最小节点，放行执行业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(preNode))&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新检查。是否获取到锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.zooKeeper.delete(path, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定节点的前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getPreNode</span><span class="params">(String path)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的序列化号</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">curSerial</span> <span class="operator">=</span> Long.valueOf(StringUtils.substringAfterLast(path, <span class="string">&quot;-&quot;</span>));</span><br><span class="line">            <span class="comment">// 获取根路径下的所有序列化子节点</span></span><br><span class="line">            List&lt;String&gt; nodes = <span class="built_in">this</span>.zooKeeper.getChildren(ROOT_PATH, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判空</span></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(nodes))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取前一个节点</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">preNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (String node : nodes) &#123;</span><br><span class="line">                <span class="comment">// 获取每个节点的序列化号</span></span><br><span class="line">                <span class="type">Long</span> <span class="variable">serial</span> <span class="operator">=</span> Long.valueOf(StringUtils.substringAfterLast(node, <span class="string">&quot;-&quot;</span>));</span><br><span class="line">                <span class="keyword">if</span> (serial &lt; curSerial &amp;&amp; serial &gt; flag)&#123;</span><br><span class="line">                    flag = serial;</span><br><span class="line">                    preNode = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> preNode;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>主要修改了构造方法和lock方法：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1607051823582.png" alt="1607051823582"></p>
<p>并添加了getPreNode获取前置节点的方法。</p>
<p>测试结果如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1607051896117.png" alt="1607051896117"></p>
<p>性能反而更弱了。</p>
<p>原因：虽然不用反复争抢创建节点了，但是会自旋判断自己是最小的节点，这个判断逻辑反而更复杂更耗时。</p>
<p>解决方案：监听。</p>
<h3 id="监听实现阻塞锁"><a href="#监听实现阻塞锁" class="headerlink" title="监听实现阻塞锁"></a>监听实现阻塞锁</h3><p>对于这个算法有个极大的优化点：假如当前有1000个节点在等待锁，如果获得锁的客户端释放锁时，这1000个客户端都会被唤醒，这种情况称为“羊群效应”；在这种羊群效应中，zookeeper需要通知1000个客户端，这会阻塞其他的操作，最好的情况应该只唤醒新的最小节点对应的客户端。应该怎么做呢？在设置事件监听时，每个客户端应该对刚好在它之前的子节点设置事件监听，例如子节点列表为/locks/lock-0000000000、/locks/lock-0000000001、/locks/lock-0000000002，序号为1的客户端监听序号为0的子节点删除消息，序号为2的监听序号为1的子节点删除消息。</p>
<p>所以调整后的分布式锁算法流程如下：</p>
<ul>
<li>客户端连接zookeeper，并在/lock下创建临时的且有序的子节点，第一个客户端对应的子节点为/locks/lock-0000000000，第二个为/locks/lock-0000000001，以此类推；</li>
<li>客户端获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，<strong>否则监听刚好在自己之前一位的子节点删除消息</strong>，获得子节点变更通知后重复此步骤直至获得锁；</li>
<li>执行业务代码；</li>
<li>完成业务流程后，删除对应的子节点释放锁。</li>
</ul>
<p>改造ZkDistributedLock的lock方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">preNode</span> <span class="operator">=</span> getPreNode(path);</span><br><span class="line">        <span class="comment">// 如果该节点没有前一个节点，说明该节点时最小节点，放行执行业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(preNode))&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.zooKeeper.exists(ROOT_PATH + <span class="string">&quot;/&quot;</span> + preNode, <span class="keyword">new</span> <span class="title class_">Watcher</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 阻塞。。。。</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// 重新检查。是否获取到锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        lock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>压力测试效果如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1607052541669.png" alt="1607052541669"></p>
<p>由此可见性能提高不少，接近于redis的分布式锁</p>
<h2 id="优化：可重入锁"><a href="#优化：可重入锁" class="headerlink" title="优化：可重入锁"></a>优化：可重入锁</h2><p>引入ThreadLocal线程局部变量保证zk分布式锁的可重入性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZkDistributedLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROOT_PATH</span> <span class="operator">=</span> <span class="string">&quot;/distributed&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; THREAD_LOCAL = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZkDistributedLock</span><span class="params">(ZooKeeper zooKeeper, String lockName)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.zooKeeper = zooKeeper;</span><br><span class="line">            <span class="keyword">if</span> (THREAD_LOCAL.get() == <span class="literal">null</span> || THREAD_LOCAL.get() == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.path = zooKeeper.create(ROOT_PATH + <span class="string">&quot;/&quot;</span> + lockName + <span class="string">&quot;-&quot;</span>, <span class="literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">flag</span> <span class="operator">=</span> THREAD_LOCAL.get();</span><br><span class="line">        <span class="keyword">if</span> (flag != <span class="literal">null</span> &amp;&amp; flag &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            THREAD_LOCAL.set(flag + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">preNode</span> <span class="operator">=</span> getPreNode(path);</span><br><span class="line">            <span class="comment">// 如果该节点没有前一个节点，说明该节点时最小节点，放行执行业务逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(preNode))&#123;</span><br><span class="line">                THREAD_LOCAL.set(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.zooKeeper.exists(ROOT_PATH + <span class="string">&quot;/&quot;</span> + preNode, <span class="keyword">new</span> <span class="title class_">Watcher</span>()&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">                        countDownLatch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    THREAD_LOCAL.set(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 阻塞。。。。</span></span><br><span class="line">                countDownLatch.await();</span><br><span class="line">                THREAD_LOCAL.set(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">// 重新检查。是否获取到锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            lock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            THREAD_LOCAL.set(THREAD_LOCAL.get() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (THREAD_LOCAL.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.zooKeeper.delete(path, <span class="number">0</span>);</span><br><span class="line">                THREAD_LOCAL.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定节点的前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getPreNode</span><span class="params">(String path)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的序列化号</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">curSerial</span> <span class="operator">=</span> Long.valueOf(StringUtils.substringAfterLast(path, <span class="string">&quot;-&quot;</span>));</span><br><span class="line">            <span class="comment">// 获取根路径下的所有序列化子节点</span></span><br><span class="line">            List&lt;String&gt; nodes = <span class="built_in">this</span>.zooKeeper.getChildren(ROOT_PATH, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判空</span></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(nodes))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取前一个节点</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">preNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (String node : nodes) &#123;</span><br><span class="line">                <span class="comment">// 获取每个节点的序列化号</span></span><br><span class="line">                <span class="type">Long</span> <span class="variable">serial</span> <span class="operator">=</span> Long.valueOf(StringUtils.substringAfterLast(node, <span class="string">&quot;-&quot;</span>));</span><br><span class="line">                <span class="keyword">if</span> (serial &lt; curSerial &amp;&amp; serial &gt; flag)&#123;</span><br><span class="line">                    flag = serial;</span><br><span class="line">                    preNode = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> preNode;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="zk分布式锁小结"><a href="#zk分布式锁小结" class="headerlink" title="zk分布式锁小结"></a>zk分布式锁小结</h2><p>参照redis分布式锁的特点：</p>
<ol>
<li>互斥 排他：zk节点的不可重复性，以及序列化节点的有序性</li>
<li>防死锁：<ol>
<li>可自动释放锁：临时节点</li>
<li>可重入锁：借助于ThreadLocal</li>
</ol>
</li>
<li>防误删：临时节点</li>
<li>加锁/解锁要具备原子性</li>
<li>单点问题：使用Zookeeper可以有效的解决单点问题，ZK一般是集群部署的。</li>
<li>集群问题：zookeeper集群是强一致性的，只要集群中有半数以上的机器存活，就可以对外提供服务。</li>
<li>公平锁：有序性节点</li>
</ol>
<h2 id="Curator中的分布式锁"><a href="#Curator中的分布式锁" class="headerlink" title="Curator中的分布式锁"></a>Curator中的分布式锁</h2><p>Curator是netflix公司开源的一套zookeeper客户端，目前是Apache的顶级项目。与Zookeeper提供的原生客户端相比，Curator的抽象层次更高，简化了Zookeeper客户端的开发量。Curator解决了很多zookeeper客户端非常底层的细节开发工作，包括连接重连、反复注册wathcer和NodeExistsException 异常等。</p>
<p>通过查看官方文档，可以发现Curator主要解决了三类问题：</p>
<ul>
<li>封装ZooKeeper client与ZooKeeper server之间的连接处理</li>
<li>提供了一套Fluent风格的操作API</li>
<li>提供ZooKeeper各种应用场景(recipe， 比如：分布式锁服务、集群领导选举、共享计数器、缓存机制、分布式队列等)的抽象封装，这些实现都遵循了zk的最佳实践，并考虑了各种极端情况</li>
</ul>
<p>Curator由一系列的模块构成，对于一般开发者而言，常用的是curator-framework和curator-recipes：</p>
<ul>
<li>curator-framework：提供了常见的zk相关的底层操作</li>
<li>curator-recipes：提供了一些zk的典型使用场景的参考。本节重点关注的分布式锁就是该包提供的</li>
</ul>
<p>引入依赖：</p>
<p>最新版本的curator 4.3.0支持zookeeper 3.4.x和3.5，但是需要注意curator传递进来的依赖，需要和实际服务器端使用的版本相符，以我们目前使用的zookeeper 3.4.14为例。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加curator客户端配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CuratorConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CuratorFramework <span class="title function_">curatorFramework</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 重试策略，这里使用的是指数补偿重试策略，重试3次，初始重试间隔1000ms，每次重试之后重试间隔递增。</span></span><br><span class="line">        <span class="type">RetryPolicy</span> <span class="variable">retry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 初始化Curator客户端：指定链接信息 及 重试策略</span></span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;172.16.116.100:2181&quot;</span>, retry);</span><br><span class="line">        client.start(); <span class="comment">// 开始链接，如果不调用该方法，很多方法无法工作</span></span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="可重入锁InterProcessMutex"><a href="#可重入锁InterProcessMutex" class="headerlink" title="可重入锁InterProcessMutex"></a>可重入锁InterProcessMutex</h3><p>Reentrant和JDK的ReentrantLock类似， 意味着同一个客户端在拥有锁的同时，可以多次获取，不会被阻塞。它是由类<strong>InterProcessMutex</strong>来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessMutex</span><span class="params">(CuratorFramework client, String path)</span></span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 带超时时间的可重入锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquire</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span>;</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><p>改造service测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CuratorFramework curatorFramework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAndLock</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">InterProcessMutex</span> <span class="variable">mutex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(curatorFramework, <span class="string">&quot;/curator/lock&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        mutex.acquire();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先查询库存是否充足</span></span><br><span class="line">        <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="built_in">this</span>.stockMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">        <span class="comment">// 再减库存</span></span><br><span class="line">        <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            stock.setCount(stock.getCount() - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.stockMapper.updateById(stock);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// this.testSub(mutex);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        mutex.release();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSub</span><span class="params">(InterProcessMutex mutex)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mutex.acquire();</span><br><span class="line">    	System.out.println(<span class="string">&quot;测试可重入锁。。。。&quot;</span>);</span><br><span class="line">        mutex.release();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意：<strong>如想重入，则需要使用同一个InterProcessMutex对象。</strong></p>
<p>压力测试结果：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1607069431523.png" alt="1607069431523"></p>
<h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><h3 id="不可重入锁InterProcessSemaphoreMutex"><a href="#不可重入锁InterProcessSemaphoreMutex" class="headerlink" title="不可重入锁InterProcessSemaphoreMutex"></a>不可重入锁InterProcessSemaphoreMutex</h3><p>具体实现：InterProcessSemaphoreMutex。与InterProcessMutex调用方法类似，区别在于该锁是不可重入的，在同一个线程中不可重入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessSemaphoreMutex</span><span class="params">(CuratorFramework client, String path)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquire</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CuratorFramework curatorFramework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">InterProcessSemaphoreMutex</span> <span class="variable">mutex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessSemaphoreMutex</span>(curatorFramework, <span class="string">&quot;/curator/lock&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mutex.acquire();</span><br><span class="line">        <span class="comment">// 1. 查询库存信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">stock</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;stock&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">st</span> <span class="operator">=</span> Integer.valueOf(stock);</span><br><span class="line">            <span class="keyword">if</span> (st &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 3.扣减库存</span></span><br><span class="line">                redisTemplate.opsForValue().set(<span class="string">&quot;stock&quot;</span>, String.valueOf(--st));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mutex.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="可重入读写锁InterProcessReadWriteLock"><a href="#可重入读写锁InterProcessReadWriteLock" class="headerlink" title="可重入读写锁InterProcessReadWriteLock"></a>可重入读写锁InterProcessReadWriteLock</h3><p>类似JDK的ReentrantReadWriteLock。一个拥有写锁的线程可重入读锁，但是读锁却不能进入写锁。这也意味着写锁可以降级成读锁。从读锁升级成写锁是不成的。主要实现类InterProcessReadWriteLock：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessReadWriteLock</span><span class="params">(CuratorFramework client, String basePath)</span>;</span><br><span class="line"><span class="comment">// 获取读锁对象</span></span><br><span class="line">InterProcessMutex <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 获取写锁对象</span></span><br><span class="line">InterProcessMutex <span class="title function_">writeLock</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>写锁在释放之前会一直阻塞请求线程，而读锁不会</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZkReadLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InterProcessReadWriteLock</span> <span class="variable">rwlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessReadWriteLock</span>(curatorFramework, <span class="string">&quot;/curator/rwlock&quot;</span>);</span><br><span class="line">        rwlock.readLock().acquire(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// TODO：一顿读的操作。。。。</span></span><br><span class="line">        <span class="comment">//rwlock.readLock().unlock();</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZkWriteLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InterProcessReadWriteLock</span> <span class="variable">rwlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessReadWriteLock</span>(curatorFramework, <span class="string">&quot;/curator/rwlock&quot;</span>);</span><br><span class="line">        rwlock.writeLock().acquire(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// TODO：一顿写的操作。。。。</span></span><br><span class="line">        <span class="comment">//rwlock.writeLock().unlock();</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="联锁InterProcessMultiLock"><a href="#联锁InterProcessMultiLock" class="headerlink" title="联锁InterProcessMultiLock"></a>联锁InterProcessMultiLock</h3><p>Multi Shared Lock是一个锁的容器。当调用acquire， 所有的锁都会被acquire，如果请求失败，所有的锁都会被release。同样调用release时所有的锁都被release(失败被忽略)。基本上，它就是组锁的代表，在它上面的请求释放操作都会传递给它包含的所有的锁。实现类InterProcessMultiLock：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数需要包含的锁的集合，或者一组ZooKeeper的path</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessMultiLock</span><span class="params">(List&lt;InterProcessLock&gt; locks)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessMultiLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; paths)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquire</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<h3 id="信号量InterProcessSemaphoreV2"><a href="#信号量InterProcessSemaphoreV2" class="headerlink" title="信号量InterProcessSemaphoreV2"></a>信号量InterProcessSemaphoreV2</h3><p>一个计数的信号量类似JDK的Semaphore。JDK中Semaphore维护的一组许可(permits)，而Cubator中称之为租约(Lease)。注意，所有的实例必须使用相同的numberOfLeases值。调用acquire会返回一个租约对象。客户端必须在finally中close这些租约对象，否则这些租约会丢失掉。但是，如果客户端session由于某种原因比如crash丢掉， 那么这些客户端持有的租约会自动close， 这样其它客户端可以继续使用这些租约。主要实现类InterProcessSemaphoreV2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessSemaphoreV2</span><span class="params">(CuratorFramework client, String path, <span class="type">int</span> maxLeases)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意一次你可以请求多个租约，如果Semaphore当前的租约不够，则请求线程会被阻塞。</span></span><br><span class="line"><span class="comment">// 同时还提供了超时的重载方法</span></span><br><span class="line"><span class="keyword">public</span> Lease <span class="title function_">acquire</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> Collection&lt;Lease&gt; <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> qty)</span>;</span><br><span class="line"><span class="keyword">public</span> Lease <span class="title function_">acquire</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span>;</span><br><span class="line"><span class="keyword">public</span> Collection&lt;Lease&gt; <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> qty, <span class="type">long</span> time, TimeUnit unit)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 租约还可以通过下面的方式返还</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnAll</span><span class="params">(Collection&lt;Lease&gt; leases)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnLease</span><span class="params">(Lease lease)</span>;</span><br></pre></td></tr></table></figure>



<p>案例代码：</p>
<p>StockController中添加方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;test/semaphore&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testSemaphore</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stockService.testSemaphore();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello Semaphore&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StockService中添加方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSemaphore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置资源量 限流的线程数</span></span><br><span class="line">    <span class="type">InterProcessSemaphoreV2</span> <span class="variable">semaphoreV2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessSemaphoreV2</span>(curatorFramework, <span class="string">&quot;/locks/semaphore&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Lease</span> <span class="variable">acquire</span> <span class="operator">=</span> semaphoreV2.acquire();<span class="comment">// 获取资源，获取资源成功的线程可以继续处理业务操作。否则会被阻塞住</span></span><br><span class="line">        <span class="built_in">this</span>.redisTemplate.opsForList().rightPush(<span class="string">&quot;log&quot;</span>, <span class="string">&quot;10010获取了资源，开始处理业务逻辑。&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span> + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>));</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate.opsForList().rightPush(<span class="string">&quot;log&quot;</span>, <span class="string">&quot;10010处理完业务逻辑，释放资源=====================&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        semaphoreV2.returnLease(acquire); <span class="comment">// 手动释放资源，后续请求线程就可以获取该资源</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="栅栏barrier"><a href="#栅栏barrier" class="headerlink" title="栅栏barrier"></a>栅栏barrier</h3><ol>
<li><p><strong>DistributedBarrier</strong>构造函数中barrierPath参数用来确定一个栅栏，只要barrierPath参数相同(路径相同)就是同一个栅栏。通常情况下栅栏的使用如下：</p>
<ol>
<li>主client设置一个栅栏</li>
<li>其他客户端就会调用waitOnBarrier()等待栅栏移除，程序处理线程阻塞</li>
<li>主client移除栅栏，其他客户端的处理程序就会同时继续运行。</li>
</ol>
<p>DistributedBarrier类的主要方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setBarrier() - 设置栅栏</span><br><span class="line">waitOnBarrier() - 等待栅栏移除</span><br><span class="line">removeBarrier() - 移除栅栏</span><br></pre></td></tr></table></figure></li>
<li><p>DistributedDoubleBarrier双栅栏，允许客户端在计算的开始和结束时同步。当足够的进程加入到双栅栏时，进程开始计算，当计算完成时，离开栅栏。DistributedDoubleBarrier实现了双栅栏的功能。构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client - the client</span></span><br><span class="line"><span class="comment">// barrierPath - path to use</span></span><br><span class="line"><span class="comment">// memberQty - the number of members in the barrier</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DistributedDoubleBarrier</span><span class="params">(CuratorFramework client, String barrierPath, <span class="type">int</span> memberQty)</span>;</span><br><span class="line"></span><br><span class="line">enter()、enter(<span class="type">long</span> maxWait, TimeUnit unit) - 等待同时进入栅栏</span><br><span class="line">leave()、leave(<span class="type">long</span> maxWait, TimeUnit unit) - 等待同时离开栅栏</span><br></pre></td></tr></table></figure>

<p>memberQty是成员数量，当enter方法被调用时，成员被阻塞，直到所有的成员都调用了enter。当leave方法被调用时，它也阻塞调用线程，直到所有的成员都调用了leave。</p>
<p>注意：参数memberQty的值只是一个阈值，而不是一个限制值。当等待栅栏的数量大于或等于这个值栅栏就会打开！</p>
<p>与栅栏(DistributedBarrier)一样,双栅栏的barrierPath参数也是用来确定是否是同一个栅栏的，双栅栏的使用情况如下：</p>
<ol>
<li>从多个客户端在同一个路径上创建双栅栏(DistributedDoubleBarrier),然后调用enter()方法，等待栅栏数量达到memberQty时就可以进入栅栏。</li>
<li>栅栏数量达到memberQty，多个客户端同时停止阻塞继续运行，直到执行leave()方法，等待memberQty个数量的栅栏同时阻塞到leave()方法中。</li>
<li>memberQty个数量的栅栏同时阻塞到leave()方法中，多个客户端的leave()方法停止阻塞，继续运行。</li>
</ol>
</li>
</ol>
<h3 id="共享计数器"><a href="#共享计数器" class="headerlink" title="共享计数器"></a>共享计数器</h3><p>利用ZooKeeper可以实现一个集群共享的计数器。只要使用相同的path就可以得到最新的计数器值， 这是由ZooKeeper的一致性保证的。Curator有两个计数器， 一个是用int来计数，一个用long来计数。</p>
<h4 id="SharedCount"><a href="#SharedCount" class="headerlink" title="SharedCount"></a>SharedCount</h4><p>共享计数器SharedCount相关方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SharedCount</span><span class="params">(CuratorFramework client, String path, <span class="type">int</span> seedValue)</span>;</span><br><span class="line"><span class="comment">// 获取共享计数的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 设置共享计数的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">(<span class="type">int</span> newCount)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="comment">// 当版本号没有变化时，才会更新共享变量的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span>  <span class="title function_">trySetCount</span><span class="params">(VersionedValue&lt;Integer&gt; previous, <span class="type">int</span> newCount)</span>;</span><br><span class="line"><span class="comment">// 通过监听器监听共享计数的变化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(SharedCountListener listener)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(<span class="keyword">final</span> SharedCountListener listener, Executor executor)</span>;</span><br><span class="line"><span class="comment">// 共享计数在使用之前必须开启</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="comment">// 关闭共享计数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>使用案例：</p>
<p>StockController：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;test/zk/share/count&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testZkShareCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stockService.testZkShareCount();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello shareData&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StockService：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZkShareCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 第三个参数是共享计数的初始值</span></span><br><span class="line">        <span class="type">SharedCount</span> <span class="variable">sharedCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedCount</span>(curatorFramework, <span class="string">&quot;/curator/count&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 启动共享计数器</span></span><br><span class="line">        sharedCount.start();</span><br><span class="line">        <span class="comment">// 获取共享计数的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> sharedCount.getCount();</span><br><span class="line">        <span class="comment">// 修改共享计数的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>);</span><br><span class="line">        sharedCount.setCount(random);</span><br><span class="line">        System.out.println(<span class="string">&quot;我获取了共享计数的初始值：&quot;</span> + count + <span class="string">&quot;，并把计数器的值改为：&quot;</span> + random);</span><br><span class="line">        sharedCount.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="DistributedAtomicNumber"><a href="#DistributedAtomicNumber" class="headerlink" title="DistributedAtomicNumber"></a>DistributedAtomicNumber</h4><p>DistributedAtomicNumber接口是分布式原子数值类型的抽象，定义了分布式原子数值类型需要提供的方法。</p>
<p>DistributedAtomicNumber接口有两个实现：<code>DistributedAtomicLong</code> 和 <code>DistributedAtomicInteger</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20220711225708066.png" alt="image-20220711225708066"></p>
<p>这两个实现将各种原子操作的执行委托给了<code>DistributedAtomicValue</code>，所以这两种实现是类似的，只不过表示的数值类型不同而已。这里以<code>DistributedAtomicLong</code> 为例进行演示</p>
<p>DistributedAtomicLong除了计数的范围比SharedCount大了之外，比SharedCount更简单易用。它首先尝试使用乐观锁的方式设置计数器， 如果不成功(比如期间计数器已经被其它client更新了)， 它使用InterProcessMutex方式来更新计数值。此计数器有一系列的操作：</p>
<ul>
<li>get(): 获取当前值</li>
<li>increment()：加一</li>
<li>decrement(): 减一</li>
<li>add()：增加特定的值</li>
<li>subtract(): 减去特定的值</li>
<li>trySet(): 尝试设置计数值</li>
<li>forceSet(): 强制设置计数值</li>
</ul>
<p>你必须检查返回结果的succeeded()， 它代表此操作是否成功。如果操作成功， preValue()代表操作前的值， postValue()代表操作后的值。</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>不管是jvm锁还是mysql锁，为了保证线程的并发安全，都提供了悲观独占排他锁。所以<strong>独占排他</strong>也是分布式锁的基本要求。</p>
<p>可以利用唯一键索引不能重复插入的特点实现。设计表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tb_lock` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `lock_name` varchar(50) NOT NULL COMMENT &#x27;锁名&#x27;,</span><br><span class="line">  `class_name` varchar(100) DEFAULT NULL COMMENT &#x27;类名&#x27;,</span><br><span class="line">  `method_name` varchar(50) DEFAULT NULL COMMENT &#x27;方法名&#x27;,</span><br><span class="line">  `server_name` varchar(50) DEFAULT NULL COMMENT &#x27;服务器ip&#x27;,</span><br><span class="line">  `thread_name` varchar(50) DEFAULT NULL COMMENT &#x27;线程名&#x27;,</span><br><span class="line">  `create_time` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;获取锁时间&#x27;,</span><br><span class="line">  `desc` varchar(100) DEFAULT NULL COMMENT &#x27;描述&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `idx_unique` (`lock_name`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1332899824461455363 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p>Lock实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@TableName(&quot;tb_lock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String lockName;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> String serverName;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LockMapper接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LockMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Lock&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>synchronized关键字和ReetrantLock锁都是独占排他锁，即多个线程争抢一个资源时，同一时刻只有一个线程可以抢占该资源，其他线程只能阻塞等待，直到占有资源的线程释放该资源。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606620944823.png" alt="1606620944823"></p>
<ol>
<li>线程同时获取锁（insert）</li>
<li>获取成功，执行业务逻辑，执行完成释放锁（delete）</li>
<li>其他线程等待重试</li>
</ol>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><p>改造StockService：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StockMapper stockMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LockMapper lockMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库分布式锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAndLock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock</span>(<span class="literal">null</span>, <span class="string">&quot;lock&quot;</span>, <span class="built_in">this</span>.getClass().getName(), <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.lockMapper.insert(lock);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">// 获取锁失败，则重试</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="built_in">this</span>.checkAndLock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先查询库存是否充足</span></span><br><span class="line">        <span class="type">Stock</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="built_in">this</span>.stockMapper.selectById(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再减库存</span></span><br><span class="line">        <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            stock.setCount(stock.getCount() - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.stockMapper.updateById(stock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        <span class="built_in">this</span>.lockMapper.deleteById(lock.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>加锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock</span>(<span class="literal">null</span>, <span class="string">&quot;lock&quot;</span>, <span class="built_in">this</span>.getClass().getName(), <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lockMapper.insert(lock);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">// 获取锁失败，则重试</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        <span class="built_in">this</span>.checkAndLock();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="built_in">this</span>.lockMapper.deleteById(lock.getId());</span><br></pre></td></tr></table></figure>



<p>使用Jmeter压力测试结果：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1606625971086.png" alt="1606625971086"></p>
<p>可以看到性能感人。mysql数据库库存余量为0，可以保证线程安全。</p>
<h2 id="缺陷及解决方案"><a href="#缺陷及解决方案" class="headerlink" title="缺陷及解决方案"></a>缺陷及解决方案</h2><p><strong>缺点</strong>：</p>
<ol>
<li><p>这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</p>
<p>解决方案：给 锁数据库 搭建主备</p>
</li>
<li><p>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</p>
<p>解决方案：只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</p>
</li>
<li><p>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</p>
<p>解决方案：记录获取锁的主机信息和线程信息，如果相同线程要获取锁，直接重入。</p>
</li>
<li><p>受制于数据库性能，并发能力有限。</p>
<p>解决方案：无法解决。</p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实现的复杂性或者难度角度：Zookeeper &gt; redis &gt; 数据库</p>
<p>实际性能角度：redis &gt; Zookeeper &gt; 数据库</p>
<p>可靠性角度：Zookeeper &gt; redis = 数据库</p>
<p>这三种方式都不是尽善尽美，我们可以根据实际业务情况选择最适合的方案：</p>
<p>如果追求极致性能可以选择：reds方案</p>
<p>如果追求可靠性可以选择：zk</p>
<p>常见锁分类：</p>
<blockquote>
<p><strong>悲观锁</strong>：具有强烈的独占和排他特性，在整个数据处理过程中，将数据处于锁定状态。适合于写比较多，会阻塞读操作。<br><strong>乐观锁</strong>：采取了更加宽松的加锁机制，大多是基于数据版本（ Version ）及时间戳来实现。。适合于读比较多，不会阻塞读</p>
</blockquote>
<blockquote>
<p><strong>独占锁、互斥锁、排他锁</strong>：保证在任一时刻，只能被一个线程独占排他持有。synchronized、ReentrantLock<br><strong>共享锁</strong>：可同时被多个线程共享持有。CountDownLatch到计数器、Semaphore信号量</p>
</blockquote>
<blockquote>
<p><strong>可重入锁</strong>：又名递归锁。同一个线程在外层方法获取锁的时候，在进入内层方法时会自动获取锁。<br><strong>不可重入锁</strong>：例如早期的synchronized</p>
</blockquote>
<blockquote>
<p><strong>公平锁</strong>：有优先级的锁，先来先得，谁先申请锁就先获取到锁<br><strong>非公平锁</strong>：无优先级的锁，后来者也有机会先获取到锁</p>
</blockquote>
<blockquote>
<p><strong>自旋锁</strong>：当线程尝试获取锁失败时（锁已经被其它线程占用了），无限循环重试尝试获取锁<br><strong>阻塞锁</strong>：当线程尝试获取锁失败时，线程进入阻塞状态，直到接收信号后被唤醒。在竞争激烈情况下，性能较高</p>
</blockquote>
<blockquote>
<p><strong>读锁</strong>：共享锁<br><strong>写锁</strong>：独占排他锁</p>
</blockquote>
<blockquote>
<p><strong>偏向锁</strong>：一直被一个线程所访问，那么该线程会自动获取锁<br><strong>轻量级锁</strong>（CAS）：当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。<br><strong>重量级锁</strong>：当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候（10次），还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。<br>以上其实是synchronized的锁升级过程</p>
</blockquote>
<p>​    </p>
<blockquote>
<p><strong>表级锁</strong>：对整张表加锁，加锁快开销小，不会出现死锁，但并发度低，会增加锁冲突的概率<br><strong>行级锁</strong>：是mysql粒度最小的锁，只针对操作行，可大大减少锁冲突概率，并发度高，但加锁慢，开销大，会出现死锁</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/03/%E5%BA%8F%E5%88%97%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/03/%E5%BA%8F%E5%88%97%E5%8C%96/" class="post-title-link" itemprop="url">序列化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-03 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-03T00:00:00+08:00">2024-10-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 15:16:20" itemprop="dateModified" datetime="2025-04-27T15:16:20+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html">序列化和反序列化 - 美团技术团队</a> </p>
<p>序列化乍眼一看似乎是多此一举，比如你在内存中创建了一个Person对象，你把内存中那块表示Person二进制数据原封不动地抠出来放到磁盘中，下次再原封不动地读入内存重构出Person对象不就行了吗，何必要进行序列化呢？</p>
<p>但事实并非那么简单，因为内存中的数据可能是<strong>非连续</strong>的。你所创建的Person对象可能有一个Name成员变量，它可能仅仅是一个指向另一片内存某块连续字符数组的<strong>指针</strong>。现实往往会更复杂，一个成员变量指针往往又指向其他的指针，使得一个简单的对象可能分布在你内存多个零散区域。而序列化，就是把这个对象的数据一层层连根拔起，将其打平成一块<strong>连续</strong>的数据。</p>
<p>我们知道一个对象往往包含很多信息，其成员可能有flaot, string, integer, 也可能是指向另一个对象的指针。比如JSON通过把以上的数据全部<strong>压平</strong>成字符串来进行传输，通过<strong>嵌套的字符串来替换原对象中的内存指针</strong>，来将不连续的数据重建为连续的数据。如果你说，我的对象不包含任何的引用变量或者指针，在内存中就是连续存储的。比如</p>
<p>Class Simple { int a=1; int b= 2} 或者 struct Simple {double a = 1.0;double b = 2.0;}</p>
<p>我还需要进行序列化吗？当然不必要，你可以把它这一块内存直接原封不动地丢进磁盘或网络，然后原封不动地取出来。这种情况极大降低<strong>时间</strong>消耗（几乎不花时间）也降低<strong>空间</strong>消耗（字符串存储效率往往低于二进制）。但是<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=318442694&content_type=Answer&match_order=8&q=%E5%BA%8F%E5%88%97%E5%8C%96&zhida_source=entity">序列化</a>依然有很多好处：</p>
<ul>
<li>如果序列化成字符串，可以手动对传输的数据进行<strong>修改</strong>或者<strong>校验</strong></li>
<li>如果序列化成字符串，机器用自己的方式解析字符串，避免**<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=318442694&content_type=Answer&match_order=1&q=%E5%A4%A7%E5%B0%8F%E7%AB%AF&zhida_source=entity">大小端</a>**不一致带来的冲突</li>
<li>即使是不序列化成字符串，其他一些独特的二进制序列化方式极大地缩小空间，比如一个长度为8的boolean的数组（原本需要8个byte)，可以压缩成一个<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=318442694&content_type=Answer&match_order=2&q=byte&zhida_source=entity">byte</a>再传输（每一个bit为一个boolean).</li>
</ul>
<h2 id="序列化组件"><a href="#序列化组件" class="headerlink" title="序列化组件"></a>序列化组件</h2><p>单方面的只把对象转成字节数组还不行，因为没有规则的字节数组我们是没办法把对象的本来面目还原回来的，所以我们必须在把对象转成字节数组的时候就制定一种规则（序列化），那么我们从IO流里面读出数据的时候再以这种规则把对象还原回来（反序列化）。</p>
<p>OSI七层协议模型中表示层（Presentation Layer）的主要功能是把应用层的对象转换成一段连续的二进制串，或者反过来，把二进制串转换成应用层的对象–这两个功能就是序列化和反序列化。</p>
<ul>
<li><strong>IDL</strong>（Interface description language）文件：参与通讯的各方需要对通讯的内容需要做相关的约定（Specifications）。为了建立一个与语言和平台无关的约定，这个约定需要采用与具体开发语言、平台无关的语言来进行描述。这种语言被称为接口描述语言（IDL），采用IDL撰写的协议约定称之为IDL文件。</li>
<li><strong>IDL Compiler</strong>：IDL文件中约定的内容为了在各语言和平台可见，需要有一个编译器，将IDL文件转换成各语言对应的动态库。</li>
<li><strong>Stub/Skeleton Lib</strong>：负责序列化和反序列化的工作代码。Stub是一段部署在分布式系统客户端的代码，一方面接收应用层的参数，并对其序列化后通过底层协议栈发送到服务端，另一方面接收服务端序列化后的结果数据，反序列化后交给客户端应用层；Skeleton部署在服务端，其功能与Stub相反，从传输层接收序列化参数，反序列化后交给服务端应用层，并将应用层的执行结果序列化后最终传送给客户端Stub。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BC%89%E5%85%A5%E5%99%A8">加载器 - 维基百科，自由的百科全书</a> </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%87%BD%E5%BC%8F%E5%BA%AB">函数库 - 维基百科，自由的百科全书</a></p>
<p><strong>动态库</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        func(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//func.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input i = %d\n&quot;</span>,i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello main.c func.c <span class="comment"># 静态链接</span></span><br><span class="line">./hello <span class="comment"># 运行可执行文件</span></span><br><span class="line">gcc -shared -o libfunc.so func.o  <span class="comment"># 生成动态库</span></span><br><span class="line">gcc -o my_program main.o -L. -lfunc  <span class="comment"># 动态链接</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=.:<span class="variable">$LD_LIBRARY_PATH</span>  <span class="comment"># 设置共享库路径</span></span><br><span class="line">./hello <span class="comment"># 运行可执行文件</span></span><br></pre></td></tr></table></figure>

<p>编译器在预处理阶段将include的头文件插入到源文件，然后编译成目标代码，后缀名.o 就是object, 也就相当于windows下编译的obj文件，该文件能被cpu直接执行的二进制代码。由编译器生成，具体的生成方法取决于不同的开发环境。</p>
<p><em><strong>链接</strong></em>：当我们的程序模块调用a另一个模块中b的函数（foo()）或变量时，在编译的阶段编译器并不知道函数foo的地址，所以暂时把调用foo的指令的目标地址搁置，等待最后链接的时候由连接器去将这些指令的目标地址修正。把目标文件和库一起链接成可执行文件。将.o文件与其他库文件进行静态链接就生成可执行文件，也就是把多个.o文件连接成一个可执行<a target="_blank" rel="noopener" href="https://blog.csdn.net/vividonly/article/details/6399530">ELF文件</a>了</p>
<p>由于业务越来越复杂，导致程序的体积也越来越大，在多进程的操作系统中，可能同时存在成百上千各应用同时运行。每个应用中都会使用到<code>printf</code>、<code>scanf</code>、<code>strlen</code>等基础函数，链接的时候就需要把printf.o这个编译器内置的目标代码链接到hello.o中</p>
<p>那么不同的程序中一定会包含它们的指令部分。这就导致这些程序在磁盘保存时，都有这些基础函数的副本。运行时，也会将这些副本加载到对应进程的虚拟空间内存中去。这就导致了<strong>浪费磁盘和内存</strong>。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/29687bbe2bd05e8a45b046612cb765bf.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">序列化组件</th>
<th align="left">数据库组件</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">IDL</td>
<td align="left">DDL</td>
<td align="left">用于建表或者模型的语言</td>
</tr>
<tr>
<td align="left">DL file</td>
<td align="left">DB Schema</td>
<td align="left">表创建文件或模型文件</td>
</tr>
<tr>
<td align="left">Stub/Skeleton lib</td>
<td align="left">O/R mapping</td>
<td align="left">将class和Table或者数据模型进行映射</td>
</tr>
</tbody></table>
<p>IDL用于描述对象的结构，IDL编译器用于将IDL描述语言转化成</p>
<ul>
<li><strong>Client/Server</strong>：指的是应用层程序代码，他们面对的是IDL所生存的特定语言的class或struct。</li>
<li><strong>底层协议栈和互联网</strong>：序列化之后的数据通过底层的传输层、网络层、链路层以及物理层协议转换成数字信号在互联网中传递。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/a9bee91c.jpg"></p>
<p>序列化只是一种拆装组装对象的规则，那么这种规则肯定也可能有多种多样，比如现在常见的序列化方式有：</p>
<p><strong>JDK</strong>（非跨语言）、<strong>JSON</strong>、<strong>XML</strong>、<strong>Hessian</strong>、<strong>Kryo</strong>（不支持跨语言）、<strong>Thrift</strong>、<strong>Protobuf</strong>、<strong>FST</strong>（非跨语言）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String postcode;</span><br><span class="line">    <span class="keyword">private</span> String street;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer userid;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Address&gt; address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Java-Serializable"><a href="#Java-Serializable" class="headerlink" title="Java Serializable"></a>Java Serializable</h2><p>当创建了⼀个对象后，只要你需要它，它就可以⼀直存在；但是如果程序 退出，这个对象就不存在了。</p>
<p>虽然这乍看起来说得通，但在某些情况下， 如果程序不再运⾏，⽽对象仍然能够存在并且保留相关信息，会对我们⾮ 常有⽤。也就是说，在下次启动程序时，<strong>包含上次程序运⾏时信息</strong>的对象 还会在那⾥。我们可以通过将信息写⼊⽂件或数据库来实现此效果，但本着⼀切皆对象的宗旨，如果能将对象声明为持久性的，然后让编程语⾔⾃ 动为你处理所有的细节，会⽅便很多。</p>
<p>Java的对象序列化（object serialization）机制会接受实现了 <code>Serializable</code> 接⼝的任意对象，并将其转换成⼀个字节序列，便于以后 重新⽣成原始对象。它甚⾄可以通过⽹络⼯作，这意味着序列化机制会⾃ 动消除操作系统之间的差异。也就是说，你可以在Windows机器上创建⼀个对象、将其序列化，然后通过⽹络发送到UNIX机器上，它会在那⾥被正 确重建。你不需要担⼼不同机器上的数据表⽰、字节顺序或任何其他细节。 </p>
<p>对象序列化可以实现轻量级持久化（lightweight persistence）。持久化意味着对象存活于程序调⽤之间，其⽣命周期不是由程序是否在执⾏决 定的。通过获取⼀个可序列化的对象并将其写⼊磁盘，然后在重新调⽤程 序时恢复该对象，这样就产⽣了持久化的效果。之所以称其为“轻量级”， 是因为你不能使⽤某个“持久化”关键字定义⼀个对象，并让编程语⾔替你 处理⼀切细节。相反，你必须在程序中显式地序列化和反序列化对象。如 果需要更严格的持久化机制，请考虑使⽤像Hibernate这样的⼯具。 在语⾔中添加对象序列化，主要是为了⽀持两个功能。</p>
<ul>
<li>⾸先，Java的远程⽅法调⽤（remote method invocation, RMI）可以让存在于远程机器 上的对象表现得像存在本地机器上⼀样。当把消息发送给远程对象时，需 要对象序列化来传输参数和返回值。 </li>
<li>其次，JavaBeans也需要对象序列化（在撰写本书时，JavaBeans被认为 是⼀项失败的技术）。当使⽤Bean时，⼀般会在设计时配置其状态信息。 这个状态信息必须存储起来，然后在程序启动时恢复，对象序列化就被⽤ 来执⾏此任务。</li>
</ul>
<p>对象序列化⾥⼀个特别出彩的地⽅是，它不仅保存了对象的镜像，⽽且会 <strong>跟踪该对象包含的所有引⽤并保存</strong>这些引⽤对象的镜像，然后跟踪每个对象所包含的全部引⽤，以此类推。这有时称为单个对象可以连接到的“对象 ⽹络”，包括成员对象以及存储了对象引⽤的数组。如果你必须维护⾃⼰的 对象序列化⽅案，那么遍历所有这些链接的维护代码可能会极为复杂。不过，Java的对象序列化似乎完美地实现了这个⽬标。毫⽆疑问，它使⽤了 ⼀种遍历对象⽹络的优化算法。</p>
<p><strong>Serializable</strong>：</p>
<ul>
<li>实现<code>Serializable</code>接口的目的是为类可持久化，比如在网络传输或本地存储，为系统的分布和异构部署提供先决条件。若没有序列化，现在我们所熟悉的远程调用，对象数据库都不可能存在。</li>
<li>序列化⼀个对象很简单，只要对象实现了<code>Serializable</code>接⼝就可以。 <code>Serializable</code>是⼀个标签接⼝，没有⽅法。当序列化被添加到语⾔中 时，标准库⾥的许多类被更改以便可序列化，包括所有基本类型的包装 类、所有容器类，等等。甚⾄Class对象也是可以序列化的。</li>
<li>序列化对象的持久化需要一个<code>ObjectOutputStream</code>的字节流<code>writeObject()</code>，反序列化需要<code>ObjectInputStream</code>的<code>readObject()</code>，返回的是一个<code>Object</code>，因此需要强转类型。</li>
<li>反序列化后得到的对象确实包含了原始对象中的所有链接。 注意，在反序列化<code>Serializable</code>对象的过程中，我们没有调⽤任何构造 器，连⽆参构造器也没有调⽤。整个对象的数据都是从<code>InputStream</code>⾥恢复的。</li>
</ul>
<p><strong>Externalizable</strong>：</p>
<ul>
<li><p>所有正常的默认构造⾏为都会发⽣（包括在字段定义处的初始化），之后<code>readExternal()</code>被调⽤。请注意这⼀点，特别是所有默认的构造总是会发⽣，这样才能在<code>Externalizable</code>对象中产⽣正确的⾏为</p>
</li>
<li><p>一言以蔽之，不会存储具体的值，只会存储对象的骨架。在⽆参数构造器中没有初始化。这意味着，如果你没有在<code>readExternal()</code>中初始化s和i，那么s就 是null且i是零（对象的存储在其创建的第⼀步被擦除为零）。</p>
</li>
<li><p>因此，为了使序列化正常，不仅需要在<code>writeExternal()</code>⽅法⾥写⼊对象的重要数据（序列化机制不会默认为<code>Externalizable</code>对象写⼊任何成 员对象），⽽且需要在<code>readExternal()</code>⽅法中恢复该数据。起初这可能有点令⼈困惑，因为<code>Externalizable</code>对象的默认构造⾏为有可能使它看起来像存在某种⾃动存储和恢复⾏为，⽽这实际上是没有的。</p>
</li>
</ul>
<p><strong>static</strong>：</p>
<p>凡是被static修饰的字段是不会被序列化的因为序列化保存的是对象的状态而非类的状态，所以会忽略static静态域。</p>
<p><strong>transient</strong>: </p>
<ul>
<li>防⽌对象的敏感部分被序列化的⼀种⽅法是将你的类实现为 <code>Externalizable</code>，如前所⽰。这样就不会⾃动序列化任何内容了，你可以仅显式地序列化<code>writeExternal()</code>中的必要部分。 但是，如果你正在使⽤<code>Serializable</code>对象，则所有序列化都会⾃动发⽣。</li>
<li>为了控制这⼀点，可以使⽤<code>transient</code>关键字逐个字段地关闭序列化，它表⽰“不要费⼼保存或恢复这个字段——我会处理它的”。date和username是普通字段（不是<code>transient</code>的），因此会⾃动序列化。然⽽password是<code>transient</code>的，所以不会被存储到磁盘，序列化机制也不会尝试恢复它。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logon</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> `<span class="keyword">transient</span>` String password;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Logon</span><span class="params">(String name, String pwd)</span> &#123;</span><br><span class="line">        username = name;</span><br><span class="line">        password = pwd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当对象被恢复时，password字段为null。注意， toString()使⽤重载的+运算符组装了⼀个字符串对象，⽽其中的null 引⽤被⾃动转换成了字符串”null”。 你还可以看到date字段被存储到磁盘并从磁盘恢复，⽽不是重新⽣成。 Externalizable对象默认不存储⾃⾝的任何字段，因此<code>transient</code>关键字仅适⽤于Serializable对象。</li>
</ul>
<p><strong>serialVersionUID</strong>: </p>
<ul>
<li><p>在进行反序列化时，JVM会把传来的字节流中的<code>serialVersionUID</code>于本地相应实体类的<code>serialVersionUID</code>进行比较。如果相同说明可以反序列化，否则会出现反序列化版本不一致的异常<code>InvalidCastException</code></p>
</li>
<li><p>具体过程是这样的：序列化操作时会把系统当前类的<code>serialVersionUID</code>写入到序列化文件中，当反序列化时系统会自动检测文件中的<code>serialVersionUID</code>，判断它是否与当前类中的<code>serialVersionUID</code>一致。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014750606/article/details/80040130">java类中serialVersionUID的作用_seriaversionid 1l-CSDN博客</a> </p>
<ul>
<li><p>当实现<code>java.io.Serializable</code>接口中没有显示的定义<code>serialVersionUID</code>变量的时候，Java序列化机制会根据Class自动生成一个<code>serialVersionUID</code>作序列化版本比较用，这种情况下，如果class文件(类名,方法等)没有发生变化(增加空格，换行，增加注释等等)，就算再编译多次，<code>serialVersionUID</code>也不会变化的。</p>
</li>
<li><p>如果我们不希望通过编译来强制划分软件版本，即实现序列化接口的实体能够兼容先前版本，就需要显示的定义一个<code>serialVersionUID</code>，类型为<code>long</code>的变量。不修改这个变量值的序列化实体，都可以相互进行序列化和反序列化。</p>
</li>
<li><p>还强烈建议使用 <code>private</code> 修饰符显示声明<code> serialVersionUID</code>（如果可能），原因是这种声明仅应用于直接声明类 – <code>serialVersionUID</code> 字段作为继承成员没有用处。数组类不能声明一个明确的 <code>serialVersionUID</code>，因此它们总是具有默认的计算值，但是数组类没有匹配 <code>serialVersionUID</code> 值的要求。</p>
</li>
</ul>
<p><strong>序列化与继承</strong>：</p>
<p>序列化是以正向递归的形式进行的，如果父类实现了序列化那么其子类都将被序列化；子类实现了序列化而父类没实现序列化，那么只有子类的属性会进行序列化，而父类的属性是不会进行序列化的。</p>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>对象序列化的⼀个重要限制是，它仅适⽤于Java平台：只有Java程序可以 反序列化此类对象。⼀个更具互操作性的解决⽅案是将数据转换为XML格式，这使得它可以被各种平台和语⾔使⽤。 由于XML的流⾏，使⽤它编程有很多令⼈困惑的选项，包括与JDK⼀起分 发的javax.xml.*库。我选择使⽤Elliotte Rusty Harold的开源XOM库 （可从XOM⽹站下载并查看其⽂档），因为在使⽤Java⽣成并修改XML的 各种⽅式中，它似乎是最简单、最直接的。此外，XOM还强调了XML的正 确性。 例如，假设有⼀个包含名字和姓⽒的APerson对象，你希望将其序列化为 XML。下⾯的APerson类有⼀个getXML()⽅法，它使⽤XOM将APerson 的数据抽取并转换为XML的Element对象，还有⼀个接受Element对象的 构造器，可以提取相应的APerson数据（注意XML⽰例在它⾃⼰的⼦⽬录 中）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;xsd:complexType name=&#x27;Address&#x27;&gt;</span><br><span class="line">     &lt;xsd:attribute name=&#x27;city&#x27; type=&#x27;xsd:string&#x27; /&gt;</span><br><span class="line">     &lt;xsd:attribute name=&#x27;postcode&#x27; type=&#x27;xsd:string&#x27; /&gt;</span><br><span class="line">     &lt;xsd:attribute name=&#x27;street&#x27; type=&#x27;xsd:string&#x27; /&gt;</span><br><span class="line">&lt;/xsd:complexType&gt;</span><br><span class="line">&lt;xsd:complexType name=&#x27;UserInfo&#x27;&gt;</span><br><span class="line">     &lt;xsd:sequence&gt;</span><br><span class="line">     &lt;xsd:element name=&#x27;address&#x27; type=&#x27;tns:Address&#x27;/&gt;</span><br><span class="line">     &lt;xsd:element name=&#x27;address1&#x27; type=&#x27;tns:Address&#x27;/&gt; </span><br><span class="line">     &lt;/xsd:sequence&gt;</span><br><span class="line">     &lt;xsd:attribute name=&#x27;userid&#x27; type=&#x27;xsd:int&#x27; /&gt;</span><br><span class="line">     &lt;xsd:attribute name=&#x27;name&#x27; type=&#x27;xsd:string&#x27; /&gt; </span><br><span class="line">&lt;/xsd:complexType&gt;</span><br></pre></td></tr></table></figure>

<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;userid&quot;</span>:<span class="number">1</span>,</span><br><span class="line"> <span class="string">&quot;name&quot;</span>:<span class="string">&quot;messi&quot;</span>,</span><br><span class="line"> <span class="string">&quot;address&quot;</span>:</span><br><span class="line"> [</span><br><span class="line">     &#123;<span class="string">&quot;city&quot;</span>:<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;postcode&quot;</span>:<span class="string">&quot;1000000&quot;</span>,<span class="string">&quot;street&quot;</span>:<span class="string">&quot;wangjingdonglu&quot;</span>&#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Kryo"><a href="#Kryo" class="headerlink" title="Kryo"></a>Kryo</h2><p>Kryo是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</p>
<p>另外，Kryo 已经是一种非常成熟的序列化实现了，已经在Twitter、Groupon、Yahoo以及多个著名开源项目（如Hive、Storm）中广泛的使用。</p>
<p><a href="https://link.zhihu.com/?target=https://github.com/Snailclimb/guide-rpc-framework">guide-rpc-framework</a> 就是使用的 kyro 进行序列化，序列化和反序列化相关的代码如下：</p>
<p><img src="https://picx.zhimg.com/80/v2-c2d640eded6b96090704a79eaf2298ad_1440w.webp?source=1def8aca" alt="img"></p>
<p>Github 地址：<a href="https://link.zhihu.com/?target=https://github.com/EsotericSoftware/kryo">https://github.com/EsotericSoftware/kryo</a> 。</p>
<h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><p>Protobuf出自于Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=471921064&content_type=Answer&match_order=1&q=%E5%BA%8F%E5%88%97%E5%8C%96%E4%BB%A3%E7%A0%81&zhida_source=entity">序列化代码</a>。这样虽然不然灵活，但是，另一方面导致protobuf没有序列化漏洞的风险。</p>
<blockquote>
<p>Protobuf包含序列化格式的定义、各种语言的库以及一个IDL编译器。正常情况下你需要定义proto文件，然后使用IDL编译器编译成你需要的语言</p>
</blockquote>
<p>一个简单的 proto 文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">message Address</span><br><span class="line">&#123;</span><br><span class="line">	required string city=1;</span><br><span class="line">    	optional string postcode=2;</span><br><span class="line">    	optional string street=3;</span><br><span class="line">&#125;</span><br><span class="line">message UserInfo</span><br><span class="line">&#123;</span><br><span class="line">	required string userid=1;</span><br><span class="line">	required string name=2;</span><br><span class="line">	repeated Address address=3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pica.zhimg.com/80/v2-35121b76c4b3f29797ade34ad321ddd8_1440w.webp?source=1def8aca" alt="img"></p>
<p>Github地址：<a href="https://link.zhihu.com/?target=https://github.com/protocolbuffers/protobuf">https://github.com/protocolbuffers/protobuf</a>。</p>
<h2 id="ProtoStuff"><a href="#ProtoStuff" class="headerlink" title="ProtoStuff"></a>ProtoStuff</h2><p>由于Protobuf的易用性，它的哥哥 Protostuff 诞生了。</p>
<p>protostuff 基于Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。</p>
<p>Gihub地址：<a href="https://link.zhihu.com/?target=https://github.com/protostuff/protostuff">https://github.com/protostuff/protostuff</a>。</p>
<h2 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h2><p>hessian 是一个轻量级的,自定义描述的二进制RPC协议。hessian是一个比较老的序列化实现了，并且同样也是跨语言的。</p>
<p><img src="https://pic1.zhimg.com/80/v2-2d1938219e4ee344b331583866a6dc82_1440w.webp?source=1def8aca" alt="img"></p>
<p>以上描述的五种序列化和反序列化协议都各自具有相应的特点，适用于不同的场景：</p>
<p>1、对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP协议是一个值得考虑的方案。</p>
<p>2、基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选。对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON也是非常不错的选择。</p>
<p>3、对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发成本。</p>
<p>4、当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro之间具有一定的竞争关系。</p>
<p>5、对于T级别的数据的持久化应用场景，Protobuf和Avro是首要选择。如果持久化后的数据存储在Hadoop子项目里，Avro会是更好的选择。</p>
<p>6、由于Avro的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro是更好的选择。</p>
<p>7、对于持久层非Hadoop项目，以静态类型语言为主的应用场景，Protobuf会更符合静态类型语言工程师的开发习惯。</p>
<p>8、如果需要提供一个完整的RPC解决方案，Thrift是一个好的选择。</p>
<p>9、如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，Protobuf可以优先考虑。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>Web开发</strong>（特别是前后端通信）：JSON占主导地位。</li>
<li><strong>高性能需求</strong>：Protobuf和Thrift是更优的选择。</li>
<li><strong>大数据处理</strong>：Avro和MessagePack可能是合适的选择。</li>
<li><strong>复杂文档结构</strong>：XML仍然是标准选择。</li>
</ul>
<p>不同场景下的需求，决定了选择哪种序列化方法。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/02/MySQL%20%E8%BF%9B%E9%98%B6%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/02/MySQL%20%E8%BF%9B%E9%98%B6%E7%AF%87/" class="post-title-link" itemprop="url">MySQL 进阶篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-02 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-02T00:00:00+08:00">2024-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 15:14:39" itemprop="dateModified" datetime="2025-04-27T15:14:39+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p>度数：一个节点上面最大的指针数</p>
<p>度数为5，最多5个指针，4个key</p>
<p>当一个节点上面key数超过4，中间节点向上分裂，其余两段分成两个节点，连到上面</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008185901845-1728392950452-1.png" alt="image-20241008185901845"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008185828031-1728392950452-2.png" alt="image-20241008185828031"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008185947095-1728392950452-4.png" alt="image-20241008185947095"></p>
<h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>只有叶子节点存储数据。非叶子节点只有索引的作用</p>
<p>中间节点向上分裂，并且中间节点保留在叶子节点，其余两段分成两个节点连到上面，节点与节点之间通过链表进行连接</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008191613613-1728392950452-3.png" alt="image-20241008191613613"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008191730054-1728392950453-5.png" alt="image-20241008191730054"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008191755751-1728392950453-7.png" alt="image-20241008191755751"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008191802276-1728392950454-9.png" alt="image-20241008191802276"></p>
<p>两个索引中间的指针指向的节点位于这两个索引之间</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008192952009-1728392950453-6.png" alt="image-20241008192952009"></p>
<p>MySQL优化B+Tree<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241008193116742-1728392950453-8.png" alt="image-20241008193116742"></p>
<p>段-区-页-行</p>
<h4 id="B-Tree-vs-B-Tree"><a href="#B-Tree-vs-B-Tree" class="headerlink" title="B+Tree vs. B-Tree"></a>B+Tree vs. B-Tree</h4><ul>
<li>都比二叉树层级更少，搜索效率高</li>
<li>B+树因为只有叶子节点能够存储数据，所以非叶子节点能够储存的key和指针数量更多，key和指针数量增多，指向的节点数目也会更多，相同数据量的情况下，需要的层数就比较少，节点数目少了，磁盘IO减少</li>
<li>B树 因为一个节点中存储的指针数目少，所以一个节点只能指向很少的一个节点，相同数据量下需要更多的节点储存指针，层级较深</li>
<li>B+树搜索效率很稳定（数据全在叶子节点上）相比Hash索引，支持了范围匹配和排序操作</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><strong>聚集索引</strong>（key是主键or唯一键or自动隐式生成的rowid）通常键的值以升序排列 底部存储一整行的数据（对应的键值）</p>
<p><strong>二级索引</strong> 通常键的值以字典序排列 底部存储行号（聚集索引的键值 也就是主键值）</p>
<p>select * from tb_user where name = ‘Arm’;</p>
<p>查询时先根据<strong>二级索引</strong>找到对应的行的索引key（主键/唯一键/rowid），然后再根据聚集索引拿到行数据（回<strong>表查询</strong>）</p>
<p>主键查询不需要回表.</p>
<p>InnoDB主键索引的B+树高度：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241011162420695.png" alt="image-20241011162420695"></p>
<p>根据一页数据的大小能够得出一页中能储存几个指针，树高度为2，指向1171个节点，1171个节点一共有1171*16行数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241011162503825.png" alt="image-20241011162503825"></p>
<p>create index on</p>
<p>show index from</p>
<p>drop index on</p>
<h3 id="SQL优化-性能指标"><a href="#SQL优化-性能指标" class="headerlink" title="SQL优化 性能指标"></a>SQL优化 性能指标</h3><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>可以设置 <code>long_query_time</code> 参数，定义什么算作“慢查询”。</p>
<p>输出到文件或者表中</p>
<h4 id="profiles"><a href="#profiles" class="headerlink" title="profiles"></a>profiles</h4><p>通过启用 <code>PROFILE</code>，可以获取查询的执行时间和资源消耗，包括 CPU 使用、锁等待、IO 等信息。</p>
<h4 id="explain-语句-执行计划"><a href="#explain-语句-执行计划" class="headerlink" title="explain +语句 执行计划"></a>explain +语句 执行计划</h4><ul>
<li>const：主键或者唯一索引查询</li>
<li>ref：非唯一索引查询</li>
<li>index，all 性能差</li>
</ul>
<h3 id="索引使用规则"><a href="#索引使用规则" class="headerlink" title="索引使用规则"></a>索引使用规则</h3><h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><ol>
<li><strong>联合索引</strong>：跳过某个，后边的全部失效，使用&gt;=否则后边的失效</li>
<li><strong>函数</strong>：不要对索引的字段用字符串，否则失效</li>
<li><strong>字符串要括起来</strong>：否则失效</li>
<li><strong>模糊</strong>：前面不能模糊，否则失效</li>
<li><strong>OR</strong>：其中一个没索引，剩下的都失效</li>
<li><strong>数据库自行判断：</strong>如果走全表查询比走索引还快，优化器会直接走全表索引</li>
</ol>
<h4 id="覆盖查询（联合索引）"><a href="#覆盖查询（联合索引）" class="headerlink" title="覆盖查询（联合索引）"></a>覆盖查询（联合索引）</h4><p>覆盖查询，联合索引查到了对应的键，也能查到对应的主键值，只查这几列不需要回表，如果多查其他的列就需要到聚集索引处回表查询，性能较慢</p>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>搜索文本时对一些长字符数据没有必要把他们全部都创建索引，而只是截取一部分</p>
<p>算出他们的选择性数据，方法：对email截取不同的长度，去重count再除以总数count</p>
<p>前缀索引，查询字符串先截取前缀，根据前缀进行辅助查询，查到主键id就回表查询拿到整行数据，拿到整行数据以后再进行核实，看字段后半部分是否匹配。一定需要回表查询</p>
<h4 id="单列or联合索引"><a href="#单列or联合索引" class="headerlink" title="单列or联合索引"></a>单列or联合索引</h4><p>or 其中一个没有索引，肯定全都不走索引</p>
<p>都有索引，但是全是单列查询，则只会选择其中一个效率最高进行查询</p>
<p>所以多条件的查询用联合索引，减少回表</p>
<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><ul>
<li>什么样的表要建立索引：数据量超过百万，且查询很频繁</li>
<li>哪些字段建立索引：where group by order by  并且尽量是唯一的，区分度要高</li>
<li>尽量使用联合索引，联合索引很多时候能够覆盖索引，避免回表查询</li>
<li>控制索引数量</li>
<li>如果索引列不能存null，要用非空约束字段</li>
</ul>
<h2 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h2><h3 id="SQL-优化-插入"><a href="#SQL-优化-插入" class="headerlink" title="SQL 优化 - 插入"></a>SQL 优化 - 插入</h3><ol>
<li>一条insert插入多条（insert）<ol>
<li>手动控制事务（事务较为耗费资源）</li>
<li>主键顺序插入</li>
</ol>
</li>
<li>load</li>
</ol>
<h3 id="SQL-优化-主键"><a href="#SQL-优化-主键" class="headerlink" title="SQL 优化 - 主键"></a>SQL 优化 - 主键</h3><ol>
<li>主键顺序插入</li>
<li>主键自增</li>
<li>主键长度尽量小一些，不要用uuid或者身份证号</li>
<li>避免在业务操作时修改主键</li>
</ol>
<h3 id="SQL-优化-order-by"><a href="#SQL-优化-order-by" class="headerlink" title="SQL 优化 - order by"></a>SQL 优化 - order by</h3><ol>
<li>多个条件，使用联合索引，最左前缀</li>
<li>一升一降，需要额外创建独立的索引</li>
<li>覆盖查询，不然仍回表</li>
<li>增大sort_buffer_size(256k default)（不可避免使用filesort时，大数据量）</li>
</ol>
<h3 id="SQL-优化-group-by"><a href="#SQL-优化-group-by" class="headerlink" title="SQL 优化 - group by"></a>SQL 优化 - group by</h3><ol>
<li>多个条件，使用联合索引，最左前缀，需要都出现</li>
<li>肯定是覆盖查询，不然报错</li>
</ol>
<h3 id="SQL-优化-limit"><a href="#SQL-优化-limit" class="headerlink" title="SQL 优化 - limit"></a>SQL 优化 - limit</h3><ol>
<li>覆盖索引加子查询，先覆盖查询主键，根据返回的数据进行select *  </li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241015190857506.png" alt="image-20241015190857506"></p>
<p>不支持in后加limit，就可以联合两张表查询，只返回满足id相同条件的数据</p>
<ol>
<li><strong>延迟关联 (INNER JOIN)</strong>: 使用 <code>INNER JOIN</code> 将分页操作转移到主键索引上，减少回表次数。相比子查询，延迟关联的性能更优，适合大数据量的分页查询。</li>
<li><strong>覆盖索引</strong>: 通过索引直接获取所需字段，避免回表操作，减少 IO 开销，适合查询特定字段的场景。但当结果集较大时，MySQL 可能会选择全表扫描。</li>
</ol>
<h3 id="SQL-优化-count-优化"><a href="#SQL-优化-count-优化" class="headerlink" title="SQL 优化 - count 优化"></a>SQL 优化 - count 优化</h3><ul>
<li><p>MyISAM：可以直接读取</p>
</li>
<li><p>InnoDB：只能逐行读取，只能借助Redis等</p>
</li>
</ul>
<ul>
<li><p>count(字段)会判断是否为非空，如果没有非空约束，会把每一行的字段值都取出来，服务器判断是否为null，不为null计数累加。如果有非空约束，不用判断null直接累加。如果是主键，直接累加</p>
</li>
<li><p>count(1) count(*) 都是遍历整张表但是不取值，按照行进行累加</p>
</li>
</ul>
<h3 id="SQL-优化-update-优化"><a href="#SQL-优化-update-优化" class="headerlink" title="SQL 优化 - update 优化"></a>SQL 优化 - update 优化</h3><p>update利用了索引，行锁</p>
<p>如果没有利用索引，就要加表锁，因为行锁是根据索引加的，而且索引不能失效</p>
<h2 id="视图、存储过程、触发器"><a href="#视图、存储过程、触发器" class="headerlink" title="视图、存储过程、触发器"></a>视图、存储过程、触发器</h2><p>视图就是给子查询起了个名字，然后作为对象存储到数据库中</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>整个数据库的锁，用于全库备份</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>释放：事务提交</p>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>特点：手动开关</p>
<h5 id="S-共享读锁"><a href="#S-共享读锁" class="headerlink" title="S 共享读锁"></a>S 共享读锁</h5><p>​    所有事务都能读，但都不能写</p>
<h5 id="X-独占写锁"><a href="#X-独占写锁" class="headerlink" title="X 独占写锁"></a>X 独占写锁</h5><p>​    只有当前事务能读写，其他事务都不能读写 </p>
<h4 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h4><p>特点：自动</p>
<p>执行DML, DQL语句会自动加共享SHARED READ/WRITE锁，</p>
<p>执行DDL语句会自动加EXCLUSIVE锁，与上述的锁不兼容。</p>
<p><strong>锁的兼容性</strong>指的是不同类型的锁在同一数据对象（如表或行）上是否可以同时存在的特性，即两个或多个事务能否同时持有某种锁类型，而不会发生冲突或阻塞。</p>
<p>一个事务进行读操作，自动给表加上了共享读锁，另一个事务要改变表结构，此时这个事务想加上独占写的元数据锁，但是因为互相不兼容，所以只能阻塞等待直到另一个事务提交</p>
<h4 id="意向锁-解决行锁表锁冲突"><a href="#意向锁-解决行锁表锁冲突" class="headerlink" title="意向锁 解决行锁表锁冲突"></a>意向锁 解决行锁表锁冲突</h4><p>某个事务DML加行锁，另一个事务来加表锁的时候，要逐行扫描是否有行锁才能加上，性能较低。</p>
<p>因此引入了意向锁，DML加行锁同时对表加了意向写锁(IX)，另一个事务想加表锁，但是IX和常规的表锁不兼容，所以会阻塞等待。</p>
<p><strong>Intention Lock</strong></p>
<h5 id="IX"><a href="#IX" class="headerlink" title="IX"></a><u>IX</u></h5><ul>
<li><code>insert</code>、<code>update</code>、<code>delete </code>(DML自动添加)</li>
<li><code>select...for update</code> (表示查询加行级排他锁)</li>
</ul>
<h5 id="IS"><a href="#IS" class="headerlink" title="IS"></a><u>IS</u></h5><ul>
<li><code>select ... lock in share mode</code>(表示查询加行级共享锁)</li>
</ul>
<p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>IX：加行锁的同时会自动加IX</p>
<p>IS：DQL后边加<code>Lock in share mode</code>表示手动加了IS</p>
<h4 id="表锁兼容性矩阵"><a href="#表锁兼容性矩阵" class="headerlink" title="表锁兼容性矩阵"></a>表锁兼容性矩阵</h4><table>
<thead>
<tr>
<th></th>
<th>共享锁 (S)</th>
<th>独占锁 (X)</th>
<th>意向共享锁 (IS)</th>
<th>意向独占锁 (IX)</th>
</tr>
</thead>
<tbody><tr>
<td>S</td>
<td>O</td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>IS</td>
<td>O</td>
<td>X</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>IX</td>
<td>X</td>
<td>X</td>
<td>O</td>
<td>O</td>
</tr>
</tbody></table>
<h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>InnoDB存储引擎，并发度高</p>
<p>行级锁是针对索引对行加的锁，事务提交后会释放</p>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017194645333.png" alt="image-20241017194645333"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017194802298.png" alt="image-20241017194802298"></p>
<p>DML自动加行级排他锁，自动加表级意向排他锁(IX)</p>
<p>DQL+<code>for update</code> 加行级排他锁，自动加IX</p>
<p>DQL+<code>lock in share mode</code> 加共享锁，自动加IS</p>
<p>IX 和 IS 就是行锁在表级锁中的一种呈现形式</p>
<ul>
<li><p>默认可重复读(RR)，使用 Next-Key 锁 进行搜索和索引扫描，防止幻读。</p>
</li>
<li><p>针对唯一索引进行检索，对已存在的记录等值匹配，自动优化为行锁（详见下文）</p>
<ul>
<li><p>当你执行以下查询时：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email <span class="operator">=</span> <span class="string">&#x27;example@example.com&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>数据库会使用唯一索引快速找到这条记录。</li>
<li>然后，它会在找到的记录上加上行锁，确保其他事务无法修改或删除该行，直到当前事务提交。</li>
<li>由于只锁定了这一行，而不是整个表，其他事务仍然可以并发读取或修改表中的其他记录。</li>
</ul>
</li>
</ul>
</li>
<li><p><u>行锁是针对索引</u>加的，<strong>如果定位数据时不使用索引，</strong>如果此时加锁(除了普通的select查询都会加)那么会对表中所有记录都加上锁，此时<strong>升级为表锁</strong> </p>
</li>
</ul>
<p>由于锁的兼容性，行锁会影响另一个事务的DML以及加后缀的DQL。同时也会影响普通的DQL，除非使用RU隔离级别，否则另一个事务的普通DQL也会阻塞</p>
<h4 id="间隙、临键锁"><a href="#间隙、临键锁" class="headerlink" title="间隙、临键锁"></a>间隙、临键锁</h4><p>InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p>
<ul>
<li><strong>记录锁（Record Lock）</strong>：也被称为记录锁，属于单个行记录上的锁。</li>
<li><strong>间隙锁（Gap Lock）</strong>：锁定一个记录之前的范围，不包括记录本身。防止其他事务<strong>插入</strong>间隙，间隙锁之间可以共存</li>
<li><strong>临键锁（Next-Key Lock）</strong>：Record Lock + Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>
</ul>
<p>在 InnoDB 默认的隔离级别 <strong>REPEATABLE-READ</strong> 下，行锁默认使用的是 <strong>Next-Key Lock</strong>。但是，如果操作的索引是唯一索引或主键的等值查询，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock 或 Gap Lock。</p>
<p><strong>省流</strong>：</p>
<ul>
<li><p>查找过程中访问到的才会被加锁，遍历停止时访问的那个不符合条件的行也要加锁，默认加NextKeyLock。</p>
</li>
<li><p><strong>唯一索引的等值查询</strong>，存在加RecordLock，不存在加右边界的GapLock</p>
</li>
<li><p><strong>唯一索引的范围查询</strong> 或者 <strong>普通索引的查询</strong> 这些查询包含向右遍历，如果出现<strong>唯一索引的等值查询</strong>，加对应的RecordLock，其他被遍历到的都是Next-keyLock，出现正无穷加正无穷的Next-KeyLock</p>
</li>
<li><p>特别地，对于 <strong>唯一索引的范围查询</strong> 或者 <strong>普通索引等值查询</strong> ，遍历停止时访问的那个不符合条件的行，这一行的NextKeyLock会退化为GapLock</p>
</li>
</ul>
<h3 id="行级锁-加锁范围验证"><a href="#行级锁-加锁范围验证" class="headerlink" title="行级锁 加锁范围验证"></a>行级锁 加锁范围验证</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017215201503.png" alt="image-20241017215201503"></p>
<p>X 对应 默认的 Next-key Lock</p>
<p>X, REC_NOT_GAP 对应 Record Lock</p>
<p>X, GAP 对应 Gap Lock </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_t_a <span class="keyword">on</span> t(a);</span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> INDEX_NAME, LOCK_MODE,LOCK_STATUS,LOCK_DATA <span class="keyword">from</span> performance_schema.data_locks;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;  <span class="comment">-- 主键等值查询 存在</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">9</span> <span class="keyword">for</span> <span class="keyword">update</span>;   <span class="comment">-- 主键等值查询 不存在</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">15</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">-- 主键范围查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;   <span class="comment">-- 普通索引等值查询</span></span><br></pre></td></tr></table></figure>



<h4 id="主键等值查询-——-数据存在"><a href="#主键等值查询-——-数据存在" class="headerlink" title="主键等值查询 —— 数据存在"></a>主键等值查询 —— 数据存在</h4><p>查询 id = 10 REC_NOT_GAP</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017223439818.png" alt="image-20241017223439818"></p>
<p>对主键等值加锁，且值存在，临键锁退化为Record，锁住10这条记录</p>
<h4 id="主键等值查询-——-数据不存在"><a href="#主键等值查询-——-数据不存在" class="headerlink" title="主键等值查询 —— 数据不存在"></a>主键等值查询 —— 数据不存在</h4><p>查询 id = 9 GAP</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017223354241.png" alt="image-20241017223354241"></p>
<p>对主键等值加锁，值不存在，临键锁退化为Gap，锁住了10之前的间隙</p>
<h4 id="主键范围查询"><a href="#主键范围查询" class="headerlink" title="主键范围查询"></a>主键范围查询</h4><ol>
<li>查找id&gt;=10 有10,11,12,15,20满足条件</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017224916640.png" alt="image-20241017224916640"></p>
<p>10是等值查询，会退化成Record，其他都是NextKey，还有一个正无穷的NextKey</p>
<ol start="2">
<li>查找id在[10,15) 之间 </li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017230538715.png" alt="image-20241017230538715"></p>
<p>10是等值查询，退化Record，其他都是临键，查到15的时候不符合, 15退化为Gap</p>
<h4 id="普通索引等值查询"><a href="#普通索引等值查询" class="headerlink" title="普通索引等值查询"></a>普通索引等值查询</h4><p>查询 a = 10 一共三条符合的记录 id = 10,11,12 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017222539070.png" alt="image-20241017222539070"></p>
<ul>
<li>对于idx_t_a这个索引，加了四把锁，其中符合条件的3行都是nextKey(也就是默认的行锁)，检索到第一个不符合条件的行 （15,15）nextKey退化成GAP间隙</li>
<li>对于主键，所有的nextKey都退化成Record Lock</li>
</ul>
<p>不存在：查询 a = 9 只有Gap</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241017235509444.png" alt="image-20241017235509444"></p>
<h4 id="普通索引范围查询"><a href="#普通索引范围查询" class="headerlink" title="普通索引范围查询"></a>普通索引范围查询</h4><p>查询 a &gt;= 10</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018000157308.png" alt="image-20241018000157308"></p>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/Mindmap.png" alt="MindMap"></p>
<h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><p>在事务开始前和结束后，数据库的状态必须一致。InnoDB 在事务提交时会检查所有约束（如外键、唯一性约束），确保数据的完整性和<strong>一致性</strong>。</p>
<h4 id="RedoLog-持久性"><a href="#RedoLog-持久性" class="headerlink" title="RedoLog - 持久性"></a>RedoLog - 持久性</h4><ul>
<li>产生：更新数据之后，事务提交之时</li>
<li>销毁：数据成功刷新到磁盘之时</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241029174344508-1730195209915-1.png" alt="image-20241029174344508"></p>
<ul>
<li><p>BufferPool中的脏页会定期刷新到磁盘中，如果写入磁盘失败，则会导致事务提交了，磁盘中的数据却没改变。</p>
</li>
<li><p>BufferPool首先把当次事务的<u>修改存入</u>RedoLogBuffer，RedoLogBuffer会刷新到磁盘中的RedoLogFile，然后过一段时间会将BP中的脏页刷新到磁盘中，如果写入失败，可以通过磁盘中的RedoLogFile恢复数据。</p>
</li>
</ul>
<p><strong>为什么不直接刷新到磁盘中</strong>？因为磁盘随机IO太慢，而日志文件是顺序IO，快得多（Write-Ahead Logging）先写日志，再刷新，并且WAL能够防止还没有刷盘就崩溃的情况。</p>
<p>重做日志记录的是数据页的具体变化<u>（物理修改）</u>，而不是 SQL 语句或逻辑操作，例如页的写入、删除或更新。这种方式确保了在崩溃恢复时，能够准确地重放这些操作，从而恢复数据到一致的状态。物理修改在执行时通常更高效。</p>
<p><mark>物理日志<mark></p>
<h4 id="UndoLog-原子性"><a href="#UndoLog-原子性" class="headerlink" title="UndoLog - 原子性"></a>UndoLog - 原子性</h4><ul>
<li>产生：事务执行具体SQL语句时</li>
<li>销毁：事务未提交时可以用于回滚，事务提交以后也不会立即删除，<strong>用于MVCC</strong> </li>
</ul>
<ul>
<li><mark>逻辑日志<mark>，是具体的SQL语句（反向）</li>
<li>事务Rollback时会从UndoLog读取逻辑语句并执行</li>
</ul>
<ul>
<li>存储在 表空间的 rollback segment 段中</li>
</ul>
<p>表空间TableSpaces-&gt;段Segment-&gt;区Extent-&gt;页Page-&gt;行Row</p>
<h3 id="MVCC-隔离性"><a href="#MVCC-隔离性" class="headerlink" title="MVCC - 隔离性"></a>MVCC - 隔离性</h3><p><strong>M</strong>ulti<strong>V</strong>ersion <strong>C</strong>oncurrency <strong>C</strong>ontrol</p>
<h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>读取数据的当前版本（最新版本），读取时要加锁</p>
<h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>读取的是记录数据的可见版本，不加锁</p>
<ul>
<li>Read Committed：每次select都生成一个快照读</li>
<li>Repeatable Read：开启事务以后的首个select才是快照读</li>
<li>Serializable：快照读退化为当前读</li>
</ul>
<p>MySQL用MVCC实现了一致性非锁定读，读操作只读该事务开始前的数据库的快照，也就是快照读（与当前读相对）</p>
<p>事务隔离级别越低，对应的锁就越少，MySQL用MVCC减少了高并发情况下锁的数量，也就是说默认的RR对性能没有影响</p>
<h4 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h4><p>TRX_ID 最后一次事务ID</p>
<p>ROLL_PTR 指向undolog</p>
<p>ROW_ID 如果没有主键会对每一行生成rowID</p>
<h4 id="利用-UndoLog"><a href="#利用-UndoLog" class="headerlink" title="利用 UndoLog"></a>利用 UndoLog</h4><h5 id="生成UndoLog"><a href="#生成UndoLog" class="headerlink" title="生成UndoLog"></a>生成UndoLog</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018150130329.png" alt="image-20241018150130329"></p>
<h5 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h5><p>事务对记录进行修改，会在Undolog生成对应的undo备份，事务对同一条记录进行修改，会在Undolog中生成一条版本链，链表尾部是最早的旧版本，链表头部是最新的旧版本，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018151050435.png" alt="image-20241018151050435"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018151107149.png" alt="image-20241018151107149"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018151128340.png" alt="image-20241018151128340"></p>
<h4 id="ReadView-amp-数据可见性算法"><a href="#ReadView-amp-数据可见性算法" class="headerlink" title="ReadView &amp; 数据可见性算法"></a>ReadView &amp; 数据可见性算法</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018161558601.png" alt="image-20241018161558601"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/trans_visible-ekj9bMvL.png" alt="trans_visible"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018205730125.png" alt="image-20241018205730125"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018161738996.png" alt="image-20241018161738996"></p>
<h4 id="RC-amp-RR-解决并发事务引发的问题"><a href="#RC-amp-RR-解决并发事务引发的问题" class="headerlink" title="RC &amp; RR 解决并发事务引发的问题"></a>RC &amp; RR 解决并发事务引发的问题</h4><p><mark><u>1. MVCC 通过 ReadView 的数据可见性算法 只会读取其他事务已提交的信息，完全避免了脏读</u><mark> </p>
<p><strong>RC</strong>：避免脏读（读已提交）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018155530221.png" alt="image-20241018155530221"></p>
<p><code>mIDs</code>包含活跃事务，<code>maxID</code>当前最大事务ID+1，<code>minID</code>最小活跃事务ID，<code>trxID</code>当前所浏览版本所属的事务ID</p>
<ol>
<li><code>trxID</code> =<code> create_trxID</code>  自己改的的肯定能读</li>
<li><code>trxID </code>&gt;= <code>maxID</code> 说明事务在快照创建之后才修改的，数据没有参考价值，不能读。</li>
<li><code>trxID </code>&lt;<code>maxID</code>说明事务在快照创建之前修改的，有参考价值，不在活跃列表中的就是已提交了</li>
<li><code>trxID</code> &lt; <code>minID</code>  肯定不在活跃列表，读<strong>已提交</strong>。</li>
<li><code>trxID</code>∈[<code>minID</code>,<code>maxID</code>) 说明事务在快照创建之前修改的，但不知道提交了没有。<ul>
<li>在<code>mIDs</code>中，说明还活跃着没有提交，不能读    </li>
<li>不在<code>mIDs</code>中，说明<strong>已提交</strong></li>
</ul>
</li>
<li><code>mIDs</code>为空，可读</li>
</ol>
<p><code>Read View</code>在SQL执行结束后自动销毁，下次生成新的</p>
<p><mark><a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html#mvcc-%E8%A7%A3%E5%86%B3%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%97%AE%E9%A2%98">2. MVCC 通过设置同一事务复用 ReadView 完全避免了不可重复读问题 </a><mark> </p>
<p><strong>RR</strong>：注意——RR是可以读已提交的，RR是用来解决不可重复读的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241018155805136.png" alt="image-20241018155805136"></p>
<p>同一个事务的<code>Read View</code>相同，后开启的事务修改肯定不会去读，只会按照同一个<code>Read View</code>读版本链</p>
<ul>
<li>事务5第一次读，事务3修改了但还没提交，最后选择事务2的版本，生成的<code>Read View</code>不会马上销毁</li>
<li>事务5第二次读，复用之前的<code>Read View</code>，最重要的是记录了<strong>活跃事务列表</strong> <code>mIds</code>，即使事务3提交了，</li>
</ul>
<p><u><mark>3. MVCC 如何解决幻读问题？<mark></u> </p>
<ol>
<li>执行普通select语句，MVCC会使用快照读。RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”。</li>
<li>对于当前读，通过设置Next-Key Lock，将间隙也锁住，阻塞其他事务插入数据，防止插入，幻读也就不会出现。</li>
</ol>
<p>没法防止的幻读：</p>
<p>事务A第一次查询id=5没查到，事务B此时插入了id=5并提交了，事务A为了维持可重复读第二次依然查不到5，但是此时事务A插入5会失败，update id = 5会成功，试图select for update也会成功，好像出现了幻觉，只能改变隔离模式为 Serializable </p>
<p>MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生，</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/01/Starter%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/01/Starter%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">自定义 starter</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-01T00:00:00+08:00">2024-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 13:06:00" itemprop="dateModified" datetime="2025-04-27T13:06:00+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><mark>在 Spring Boot 生态中，“Starter” 本质上就是一组依赖的“捆绑包”，它的目标是让使用方 <strong>一行依赖</strong> 就把启动一个完整的 Spring Boot 应用所需的所有东西都拉过来。</mark> </p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/10/01/Starter%E7%9A%84%E5%AE%9E%E7%8E%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/01/se-java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/01/se-java/" class="post-title-link" itemprop="url">Java SE</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-01T00:00:00+08:00">2024-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 14:58:30" itemprop="dateModified" datetime="2025-04-27T14:58:30+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="面向对象、基本语法"><a href="#面向对象、基本语法" class="headerlink" title="面向对象、基本语法"></a>面向对象、基本语法</h1><p>一个java文件内只能有1个public class 且public class名字需与文件名相同</p>
<p>生成类文件的名字=class名，几个类几个名字</p>
<p>运行的时候是按照类运行的，因此一个java文件里不同的类可以有不同的main</p>
<h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><p>在刷算法题时，Java 的常用包可以帮助你解决各种问题。以下是一些常见的包：</p>
<ol>
<li><p><strong>基础包</strong>（默认无需导入，属于 <code>java.lang</code>，直接使用）：</p>
<ul>
<li><code>java.lang</code>：包含基础类如 <code>String</code>, <code>Math</code>, <code>Integer</code>, <code>System</code>，它们是自动导入的，不需要显式导入。</li>
</ul>
</li>
<li><p><strong>集合框架</strong>：</p>
<ul>
<li><code>java.util.*</code>：包括大多数数据结构和集合类，常用于算法题：<ul>
<li><code>ArrayList</code>, <code>LinkedList</code>：动态数组和链表。</li>
<li><code>HashMap</code>, <code>TreeMap</code>, <code>LinkedHashMap</code>：哈希表和有序映射。</li>
<li><code>HashSet</code>, <code>TreeSet</code>：哈希集合和有序集合。</li>
<li><code>PriorityQueue</code>：优先队列（常用于堆排序、最小堆、最大堆）。</li>
<li><code>Stack</code>：栈结构。</li>
<li><code>Deque</code>, <code>ArrayDeque</code>：双端队列。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>并发包</strong>：</p>
<ul>
<li><code>java.util.concurrent.*</code>：多线程工具和并发数据结构。</li>
</ul>
</li>
<li><p><strong>数学计算</strong>：</p>
<ul>
<li><code>java.math.BigInteger</code> 和 <code>java.math.BigDecimal</code>：用于处理大整数和高精度小数。</li>
<li><code>java.util.Random</code>：生成随机数。</li>
</ul>
</li>
<li><p><strong>输入输出</strong>（用于处理大规模输入输出）：</p>
<ul>
<li><code>java.io.*</code>：包括 <code>BufferedReader</code>、<code>InputStreamReader</code> 等，常用于高效输入读取。</li>
<li><code>java.util.Scanner</code>：常用于简单的控制台输入。</li>
</ul>
</li>
<li><p><strong>时间处理</strong>：</p>
<ul>
<li><code>java.time.*</code>：处理日期和时间类（如果题目涉及日期计算）。</li>
</ul>
</li>
</ol>
<h3 id="常用导入："><a href="#常用导入：" class="headerlink" title="常用导入："></a>常用导入：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">// 通用集合框架</span></span><br><span class="line"><span class="keyword">import</span> java.math.*;  <span class="comment">// 高精度数学计算</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;    <span class="comment">// 文件、输入输出</span></span><br></pre></td></tr></table></figure>

<p>这些包涵盖了绝大多数算法题目需要的工具和数据结构。如果你有特定类型的题目或需求，也可以进一步讨论合适的导入包。</p>
<h2 id="基本数据类型-2024-9-9"><a href="#基本数据类型-2024-9-9" class="headerlink" title="基本数据类型 2024.9.9"></a>基本数据类型 2024.9.9</h2><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><p>char <strong>2</strong> byte</p>
<p>路径 \\ 转义字符</p>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>0x hex 、 0 oct    byte short int long </p>
<p>整数全部是int型，数字超出int范围后面要加L <code>long number = 666666666666L  </code></p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>4e3 ⇔ 4000 这是一个浮点数 默认为double </p>
<p>float 32  double 64 </p>
<p>浮点数全部是double型，数字如果是float型后边必须要加上f</p>
<p>double类型不能给float类型赋值。 char 型可以兼容整型，也可以看成16位整型</p>
<table>
<thead>
<tr>
<th align="left"><strong>数据类型</strong></th>
<th align="left"><strong>默认值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">0L</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">0.0f</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">0.0d</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">‘\u0000’</td>
</tr>
<tr>
<td align="left">String (or any object)</td>
<td align="left">null</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">false</td>
</tr>
</tbody></table>
<h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><ul>
<li><p>隐式(自动) 基本数据类型中除了boolean其他都兼容</p>
<ul>
<li>byte, short, char -&gt;int-&gt;long-&gt;float-&gt;double</li>
<li>byte+short 在表达式中参与运算自动提升为int 小类型自动转换成大类型</li>
<li></li>
</ul>
</li>
<li><p>强制转换</p>
<ul>
<li><p>小数转换成整数，保留整数部分 <code>double a = 1.2 </code> <code>int b = (int) a</code>  </p>
</li>
<li><p>四舍五入</p>
<ul>
<li>```java<br>double pi = Math.PI;<br>pi = pi * 10000 + 0.5;<br>pi = (int)pi;<br>pi = pi / 10000;<br>double pi_2 = Math.PI;<br>long i = Math.round(pi_2 * 10000);<br>pi_2 = i / 10000.0;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 运算符</span><br><span class="line"></span><br><span class="line">- 比较运算符 H **instanceof** Human H是否属于Human类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- **位运算符** （整数） &gt;&gt;&gt; </span><br><span class="line"></span><br><span class="line">- **自增自减**  i++ 的值等于i      ++i的值等于i+1</span><br><span class="line"></span><br><span class="line">- **取模** 值只跟被模数有关 </span><br><span class="line"></span><br><span class="line">- **扩展赋值运算符**：包含强制类型转换</span><br><span class="line"></span><br><span class="line">- **逻辑运算符** </span><br><span class="line"></span><br><span class="line">  - &amp;&amp; 第一个false 不会判断 优先级较高</span><br><span class="line"></span><br><span class="line">  - ||  第一个true不会判断剩下的</span><br><span class="line">  - ^ 异或 相同false 不同true</span><br><span class="line"></span><br><span class="line">## API from JDK</span><br><span class="line"></span><br><span class="line">### Switch语句简化</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">int day = 3;</span><br><span class="line">String dayName = switch (day) &#123;</span><br><span class="line">    case 1 -&gt; &quot;Monday&quot;;</span><br><span class="line">    case 2 -&gt; &quot;Tuesday&quot;;</span><br><span class="line">    case 3 -&gt; &quot;Wednesday&quot;;</span><br><span class="line">    case 4 -&gt; &quot;Thursday&quot;;</span><br><span class="line">    case 5 -&gt; &quot;Friday&quot;;</span><br><span class="line">    case 6 -&gt; &quot;Saturday&quot;;</span><br><span class="line">    case 7 -&gt; &quot;Sunday&quot;;</span><br><span class="line">    default -&gt; throw new IllegalArgumentException(&quot;Invalid day: &quot; + day);</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(dayName); // 输出: Wednesday</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>JDK12开始引入的写法，可以避免贯穿效应，并能直接在后面执行一个语句或者返回一个值</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;asd&quot;</span> <span class="comment">//常量池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(字符数组、字节数组)<span class="comment">//一般的堆</span></span><br></pre></td></tr></table></figure>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><code>str.toCharArray()</code>  返回一个字符数组</p>
<p><code>str.charAt(2)</code>   返回str[2]的字符</p>
<p><code>str1.equals(str2)</code> s1与s2是否相同</p>
<p><code>str1.equalsIgnoreCase(str2)</code> s1与s2是否相同 <strong>忽略大小写</strong> </p>
<p><code>str.substring(0,8)</code> 字符串截断</p>
<p><code>str.replace(x,y)</code> 将x替换成y</p>
<p><code>str.contains(&quot;Java&quot;)</code> 是否包含Java</p>
<p><code>str.startsWith(&quot;A&quot;)</code> 是否以A开头</p>
<p><code>str.split(&#39;,&#39;)</code> Split with PERIOD ‘,’</p>
<p><code>int compareToIgnoreCase(String str)</code> 按照字典顺序比较两个字符串，忽略大小写</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><p>用str = “aaa” 的方式，会把字符串存在<strong>字符常量池</strong>，内容相同只存储一份</p>
</li>
<li><p>用str = new String(“aaa”)的方式，每一次都new一个新对象存在堆中</p>
</li>
<li><p><strong>String是不可变对象</strong>，不可变性（Immutability）的含义 </p>
</li>
<li><p>只要对String进行操作，就要<u>创建新的字符串对象</u>，而非修改原有字符串。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">str = str + <span class="string">&quot; World&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>str + &quot; World&quot;</code> 实际上创建了一个新的 <code>String</code> 对象，包含 “Hello World”，而原来的 <code>&quot;Hello&quot;</code> 对象仍然存在于内存中，并没有被修改。<code>str</code> 变量此时指向了这个新的对象。为什么 <code>String</code> 是不可变的？</p>
<ol>
<li><p><strong>安全性（Security）</strong>：不可变的对象可以避免在多个线程之间共享数据时的并发问题。由于 <code>String</code> 的值不会被改变，因此可以安全地在多个地方或多个线程中使用，而不必担心被其他代码修改。</p>
</li>
<li><p><strong>性能优化（String Pool）</strong>：Java 中有一个叫做 <strong>字符串常量池（String Pool）</strong> 的机制，当你创建一个 <code>String</code> 对象时，如果该字符串值已经存在于常量池中，那么不会重新创建对象，而是复用已有的对象。不可变性确保了这个机制的有效性，因为相同的 <code>String</code> 实例永远不会被修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>s1</code> 和 <code>s2</code> 实际上引用了常量池中的同一个 <code>String</code> 对象。</p>
<p><strong>3.  哈希值缓存</strong>：由于 <code>String</code> 对象不可变，它的哈希值只需要计算一次，可以缓存下来以提高哈希表操作的效率（如在 <code>HashMap</code> 中用作键）。如果 <code>String</code> 是可变的，那么它的哈希值也会随之变化，影响哈希表的正确性。 </p>
</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240910180312621.png" alt="image-20240910180312621"></p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>大小可变的 <strong>容器</strong>，auto extension </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240910193135775.png" alt="image-20240910193135775"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>add 方法可重载 <code>add(Object o);</code> </p>
<p>注意 remove 方法会让整体左移，元素对应的索引会变化，会影响遍历的索引</p>
<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>)  <span class="comment">//0-9</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>,<span class="number">31</span>)  <span class="comment">// [10,31) 不包含31</span></span><br></pre></td></tr></table></figure>

<h3 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> sc.nextInt();</span><br></pre></td></tr></table></figure>

<h2 id="数组-2024-9-10"><a href="#数组-2024-9-10" class="headerlink" title="数组 2024.9.10"></a>数组 2024.9.10</h2><h3 id="静态数组"><a href="#静态数组" class="headerlink" title="静态数组"></a>静态数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] data1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] data2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">//简化写法</span></span><br></pre></td></tr></table></figure>

<p>引用数据类型 引用相当于是对象的地址</p>
<h3 id="动态数组（非动态长度）"><a href="#动态数组（非动态长度）" class="headerlink" title="动态数组（非动态长度）"></a>动态数组（非动态长度）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] data1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p><code>double 0.0</code> <code>int 0 </code> <code>boolean false </code> <code>String null</code> (<u>引用数据类型</u>) </p>
<p>new一个对象，就会在堆上创建空间，然后将空间的地址传给栈中的引用</p>
<h3 id="引用数据类型做参数"><a href="#引用数据类型做参数" class="headerlink" title="引用数据类型做参数"></a>引用数据类型做参数</h3><p>引用相当于封装好的指针，只能指向对象，可以通过它对<strong>对象</strong>进行操作，引用数据类型做参数，实际上是一个引用的拷贝，通过它可以操作对象，但是不能通过修改它来让真实的引用指向一个新的对象。修改对象就行了，没事修改人家引用干啥呢！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Personnel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modifyPerson</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        person = <span class="keyword">new</span> <span class="title class_">Person</span>();  <span class="comment">// 修改引用，指向新的对象  不可以</span></span><br><span class="line">        person.name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.name = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        modifyPerson(p);</span><br><span class="line">        System.out.println(p);  <span class="comment">// 仍然输出 &quot;Bob&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java的参数都是值传递，也就是副本传递。main 中 p的值始终不变， 进入modify方法之后，一开始person也是p的值，但是无法通过更改person的指向 来 更改p的指向</p>
<h3 id="方法的重载："><a href="#方法的重载：" class="headerlink" title="方法的重载："></a><strong>方法的重载</strong>：</h3><p>必须要有不同的<strong>参数列表</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">function</span><span class="params">(String... args)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">function</span><span class="params">(String [] args)</span>;</span><br></pre></td></tr></table></figure>

<p>这两种方法是等价的</p>
<h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><ul>
<li><p>类名大写</p>
</li>
<li><p>不用赋初值</p>
</li>
<li><p>xx.java 中只能有一个public class 且名字必须叫xx 可以有多个class</p>
</li>
<li><p>对象失去引用，将成为垃圾无法被操作</p>
</li>
<li><p>this 用在<strong>方法内</strong> 用于拿到当前的对象 调用方法的时候this会自动接收当前对象的引用(防止对象的成员变量和方法内部的变量名称相同产生冲突)</p>
</li>
</ul>
<h3 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h3><p>构造函数，可重载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">double</span> score)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建对象的同时完成初始化赋值</li>
<li>不写构造函数会自动生成无参构造</li>
<li>如果定义了有参构造，<strong>不会自动生成</strong>无参构造了</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>合理隐藏，合理暴露，考虑安全性</p>
<p>public(any)&gt;protected(继承类)&gt;friendly(同一package的类)&gt;private(只有当前类才有资格访问)</p>
<h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><ul>
<li>变量私有，方法公开（get set 右键快捷生成）</li>
<li>必有公开的无参构造</li>
<li><strong>实体类</strong>负责数据存取，处理数据交给<strong>业务类</strong>来完成</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentOperator</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Student student;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">StudentOperator</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.student = student;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JavaBean-vs-POJO"><a href="#JavaBean-vs-POJO" class="headerlink" title="JavaBean vs. POJO"></a>JavaBean vs. POJO</h3><p>JavaBean 和 POJO 的区别主要在于它们的用途和规范化程度：</p>
<ol>
<li><p><strong>JavaBean</strong>：</p>
<ul>
<li><strong>定义</strong>：JavaBean 是一种特殊的 Java 类，通常遵循严格的规范。它主要用于开发可复用的组件，尤其是在 Java EE 应用程序中，JavaBean 被广泛用于数据传输对象（DTO）、表单数据和企业级应用中。</li>
<li><strong>规范</strong>：<ul>
<li>必须有一个<strong>无参构造函数</strong>。</li>
<li>所有的属性（成员变量）必须是<strong>私有的</strong>（<code>private</code>），并通过<strong>getter</strong> 和 <strong>setter</strong> 方法进行访问。</li>
<li>必须实现 <strong>Serializable</strong> 接口（可选，但常见）。</li>
</ul>
</li>
<li><strong>应用场景</strong>：JavaBean 常用于 Java EE（例如 JSP、Servlet）中与视图层交互的数据封装，也可用于一些持久层框架如 Hibernate 和 Spring。</li>
</ul>
</li>
<li><p>**POJO (Plain Old Java Object)**：</p>
<ul>
<li><strong>定义</strong>：POJO 是一个普通的 Java 对象，没有任何特殊的要求或规范。它是最普通的 Java 类，通常只用来封装数据，避免依赖特定的框架或库。</li>
<li><strong>规范</strong>：没有严格的要求，可以有构造函数、任意修饰符的属性，甚至没有 getter 和 setter 方法。</li>
<li><strong>应用场景</strong>：POJO 被广泛用于各种场景中，特别是作为轻量级的数据承载类。它不依赖于任何框架的 API，目的是使代码更加简洁和易于维护。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：</p>
<ul>
<li><strong>JavaBean</strong> 是一种受规范约束的 POJO，适合组件开发和框架集成。</li>
<li><strong>POJO</strong> 是一个没有任何限制或依赖的 Java 类，更加灵活自由。</li>
</ul>
<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>局部变量：方法内 一般在栈中</p>
<p>成员变量：一般在类的声明中表现</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240910144323152.png" alt="image-20240910144323152"></p>
<p>out</p>
<h2 id="OOP-Advanced-2024-9-11"><a href="#OOP-Advanced-2024-9-11" class="headerlink" title="OOP Advanced 2024.9.11"></a>OOP Advanced 2024.9.11</h2><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><h4 id="修饰成员变量：类变量"><a href="#修饰成员变量：类变量" class="headerlink" title="修饰成员变量：类变量"></a>修饰成员变量：类变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> String name;<span class="comment">//所有类共享 （类变量）</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接通过类名访问：<code>Student.name = &quot;袁华&quot;</code> 只有一份 </p>
<ul>
<li>应用场景：某个数据只要一份（记住自己创建了多少个用户对象了）希望能够被共享、修改</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911105822932.png" alt="image-20240911105822932"></p>
<h4 id="类方法：属于类的方法"><a href="#类方法：属于类的方法" class="headerlink" title="类方法：属于类的方法"></a>类方法：属于类的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printHelloworld</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line">Student.printHelloworld();</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911110754007.png" alt="image-20240911110754007"></p>
<ul>
<li>应用场景：工具类 提高代码复 用率</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911111331657.png" alt="image-20240911111331657"></p>
<h4 id="其他注意"><a href="#其他注意" class="headerlink" title="其他注意"></a>其他注意</h4><ul>
<li>static 方法 可以直接访问 static 成员变量 ，<u>不能访</u>问实例变量，不能有<strong>this</strong> </li>
<li>实例 方法 可以直接访问 static 成员变量和实例变量、方法，可以有<strong>this</strong> </li>
</ul>
<h5 id="应用：静态代码块-实例代码块"><a href="#应用：静态代码块-实例代码块" class="headerlink" title="应用：静态代码块 实例代码块"></a>应用：<strong>静态代码块 实例代码块</strong></h5><p>静态代码块：<mark>类加载的同时<mark>会加载静态代码块但只有一次，适用于静态变量的初始化</p>
<p>实例代码块：<mark>创建对象的时候<mark>执行，并在构造器<mark>之前<mark>执行，适用于非静态变量的初始化</p>
<h4 id="设计模式：单例"><a href="#设计模式：单例" class="headerlink" title="设计模式：单例"></a>设计模式：单例</h4><ul>
<li><p>一个类有且只有一个对象，创建对象之前就自己有了11:112311</p>
</li>
<li><p>私有构造器</p>
</li>
<li><p>```java<br>private static A a = new A();//自有，记住一个对象<br>private A(){}//<br>public static A getObject(){</p>
<pre><code>return a;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ![image-20240911114322070](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911114322070.png) 上图为拿到一个**对象** **以后**才开始创建对象</span><br><span class="line"></span><br><span class="line">### 继承 extends </span><br><span class="line"></span><br><span class="line">关键字：extends`public class B extends A` B能继承A的非私有成员和方法</span><br><span class="line"></span><br><span class="line">#### 子类的访问</span><br><span class="line"></span><br><span class="line">- 子类不能直接访问父类的私有成员，但是他们**仍然存在于子类对象中**，父类的私有成员子类用get set方法可以完成访问或修改 /  (或者用父类的构造器)</span><br><span class="line">- 父亲的私人物品儿子不能直接动，但是儿子能通过父亲认可的方法接触</span><br><span class="line">- 子类方法中同名变量\方法的处理：优先调用方法中声明 的变量，**this**可以调用子类在方法外声明的，**super**可以调用父类声明的</span><br><span class="line"></span><br><span class="line">![image-20240911115852654](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911115852654.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| 修饰符    | 本类 | 同一包的其他类(包括同一包的子类) | 其他包的子类 | 其他包的其他类 |</span><br><span class="line">| --------- | ---- | -------------------------------- | ------------ | -------------- |</span><br><span class="line">| private   | OK   | **NO**                           | **NO**       | **NO**         |</span><br><span class="line">| 缺省      | OK   | OK                               | **NO**       | **NO**         |</span><br><span class="line">| protected | OK   | OK                               | OK           | **NO**         |</span><br><span class="line">| public    | OK   | OK                               | OK           | OK             |</span><br><span class="line"></span><br><span class="line">- 注意这些都是在对应的类 **内部** 才起作用 </span><br><span class="line">- java 单继承 ， 多层继承 ， 不支持多继承</span><br><span class="line"></span><br><span class="line">- 所有类默认继承自`Object`类</span><br><span class="line"></span><br><span class="line">#### 子类的方法重写</span><br><span class="line"></span><br><span class="line">- 子类将父类的方法保持参数列表相同进行重写</span><br><span class="line"></span><br><span class="line">- 用`@Override` 注解</span><br><span class="line">- 子类的访问权限必须大于父类</span><br><span class="line">- `private` 和 `static` 不能重写 </span><br><span class="line">- 应用：println(A) 默认调用的是`A.toString()` 这是一个Object类的函数，返回地址信息，如果在A类重写toString函数就能改变,可以使用右键快捷生成toString函数</span><br><span class="line"></span><br><span class="line">#### 子类的&lt;u&gt;构造器&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">- 调用子类的构造器之前，自动调用父类的无参构造，默认存在`super()` </span><br><span class="line"></span><br><span class="line">- 如果父类没有无参构造（有了有参构造），子类的构造器无法调用`super()` 就会报错，所以要在子类的构造器中手动调用 `super(name)`有参构造 </span><br><span class="line"></span><br><span class="line">- 原因：子类中虽然不能直接操作父类的private成员，但是同样也是要有这些成员的，而且要避免一直调用父类的get set方法，那么子类构造时就要用**父类的构造器** 对父类的private成员进行初始化，再回来把对象里包含子类这部分数据赋值。</span><br><span class="line"></span><br><span class="line">- 有参构造的重载：本来有三个参数，如果只接受两个参数，对其余的一个参数进行缺省设定，`this()` 就能调用本类的无参构造</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  public Student(String name, int age)&#123;</span><br><span class="line">  	this(name, age, &quot;heima&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  public Student(String name, int age, String schoolName)&#123;</span><br><span class="line">  	super(name, age);</span><br><span class="line">  	this.schoolName = schoolName;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>this()和super()不能同时出现在构造器中，都必须放在第一行</p>
</li>
</ul>
<h3 id="多态-polymorphism"><a href="#多态-polymorphism" class="headerlink" title="多态 polymorphism"></a>多态 polymorphism</h3><ul>
<li><p><strong>对象多态</strong>：父类的引用类型变量 可以指向子类的对象</p>
</li>
<li><p><strong>行为多态</strong>：子类中和父类<strong>同名(重写)的方法</strong>，在多态调用时采用子类的方法(new的是Teacher的无参构造)</p>
</li>
<li><p>编译看的是左边引用的类型，但是实际运行起来看的是右边的构造函数，但是多态 <strong>不包括</strong> 成员变量 Person p = new Student() </p>
</li>
<li><p>右边对象是解耦合的，比如前面用的是Student后边想换成Person可以直接换掉</p>
</li>
<li><p>用父类的引用形参能接受一切子类的对象</p>
<ul>
<li>多态下不能使用子类的 <strong>独有功能</strong>  <ul>
<li>Method1 父类中定义一个抽象方法</li>
<li>Method2 instanceof判定ifelse</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="多态的类型转换"><a href="#多态的类型转换" class="headerlink" title="多态的类型转换"></a><strong>多态的类型转换</strong></h4><p><strong>auto</strong> : <code>People p = new Teacher();</code> 小的自动转成大的</p>
<p><strong>force</strong>: <code>Teacher t = (Teacher)p;</code>大的必须强制才能转成小的 </p>
<p>编译阶段有继承或者实现关系就不会报错，但是运行会报<code>ClassCastException</code></p>
<p>Teacher有<code>teach() </code>Student 有<code>test()</code> ， 一个父类的引用person是无法调用他们的，必须类型转换</p>
<ul>
<li><p>但是如果p实际上是Student类，是无法强制转换成Teacher类的，引出 <code>instanceof</code> 运算符，结果是一个boolean类型的变量。</p>
</li>
<li><p>用父类的引用形参接受子类的对象，p instanceof Teacher = true 那么调用Teacher的独有功能，否则调用Student的独有功能</p>
</li>
</ul>
<h3 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h3><p>final 加在class上 类不能被继承， final加在方法上不能被重写，加在变量上 变量必须且仅能赋值一次   </p>
<p>static final 修饰的成员变量 String SCHOOL_NAME = “HEIMA” 相当于是 <strong>常量</strong></p>
<p>常量和直接用字面量性能一样</p>
<h3 id="抽象类-abstract-关键字"><a href="#抽象类-abstract-关键字" class="headerlink" title="抽象类 abstract 关键字"></a>抽象类 abstract 关键字</h3><ul>
<li><strong>抽象方法</strong> 只有方法签名，不能有具体的方法实现</li>
<li><strong>不能创建对象</strong> 只能作为父类让子类继承</li>
<li>如果一个类从抽象父类继承而来，除非重写完所有上一代的抽象方法，否则这个类也必须是抽象类</li>
<li>更好支持多态，父类知道子类都要做某个行为，但每个子类做的情况又不一样，父类就定义抽象方法，交给子类重写实现</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911172104015.png" alt="image-20240911172104015"></li>
</ul>
<h4 id="设计模式：模版方法"><a href="#设计模式：模版方法" class="headerlink" title="设计模式：模版方法"></a>设计模式：模版方法</h4><p>解决了什么问题：两个类的方法有大量的重复代码，仅仅有部分不同。</p>
<p>老师和学生都要写同一片作文，开头结尾相同，正文部分不一样，A B都需要<code>write()</code>且大量重复，抽象父类Father可以在<code>write()</code>写好重复的部分，插入抽象方法<code>body()</code>  并且父类的<code>write()</code>可以加<code>final</code>关键字，保证不被继承</p>
<h3 id="接口-interface-关键字"><a href="#接口-interface-关键字" class="headerlink" title="接口 interface 关键字"></a>接口 interface 关键字</h3><p>实现类 实现 接口  重写所有抽象方法</p>
<ul>
<li><p>方法 默认 <code>public</code> <code>abstract</code> </p>
</li>
<li><p>变量 默认 <code>public</code> <code> static</code> <code>final</code>（常量）</p>
</li>
<li><p>接口 不能 实例化，不能被类继承，可被类实现，可被接口继承</p>
</li>
<li><p>弥补单继承，可实现多接口(类似多继承)，一个类可以拥有更多的 能力(某专业方面的能力)</p>
</li>
<li><p>面向接口编程，业务实现的切换灵活，解耦，AB都实现了接口Driver Driver某一天想换人，直接new B就可以，AB都实现了drive方法。你是司机，你就必须会开车，这样的话想换司机只需要换人就可以，不需要额外增加方法 <code>Driver driver = new A();</code> <code>Driver driver = new B();</code> </p>
</li>
<li><p>同一个功能的多套方案：建立一个接口，用接口的抽象方法表示要实现的功能，然后分别做多个接口的实现类，把抽象方法具体化</p>
</li>
<li><p>JDK 8 new:  均非抽象方法，</p>
<ul>
<li>默认方法 default 接口 <strong>实现类的对象</strong> 才可以调用 用public修饰</li>
<li>私有方法 private 只有在接口 <strong>内部</strong> 才能访问</li>
<li>静态方法 static   只能通过 <strong>接口名调用</strong> 用public修饰 </li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911221630071.png" alt="image-20240911221630071"></li>
</ul>
<p>外部软件包访问本包接口，需要将接口设置为public</p>
</li>
</ul>
<h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><table>
<thead>
<tr>
<th align="left">区别点</th>
<th align="left">重载方法(同一个类)</th>
<th align="left">重写方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">参数列表</td>
<td align="left">必须修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">返回类型</td>
<td align="left">可以修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">异常</td>
<td align="left">可以修改</td>
<td align="left">可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td align="left">访问</td>
<td align="left">可以修改</td>
<td align="left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
</tbody></table>
<h3 id="内部类-9-12"><a href="#内部类-9-12" class="headerlink" title="内部类 9.12"></a>内部类 9.12</h3><ul>
<li><p>创建内部类对象：<code>Outer.Inner in = new Outer().new Inner();</code> 外部类.内部类</p>
<ul>
<li>内部类的方法访问内部类的成员变量 <code>this</code></li>
<li>Outer.this 返回外部类对象</li>
</ul>
</li>
<li><p>JDK16开始 可以定义内部类的静态成员</p>
</li>
<li><p>静态内部类：<code>public static class</code></p>
<ul>
<li><code>Outer.Inner in = new Outer.Inner();</code> </li>
<li>不需要创建外部对象就能获得内部类</li>
<li>可以访问外部类的静态成员</li>
</ul>
</li>
</ul>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><ul>
<li>本质上是一个子类，会立即创建出一个子类对象出来</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.cry();</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Animal这个抽象类不能实例化，在后面加一个大括号，然后在其中实现抽象方法，这样就创建了一个子类对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Swimming</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swimming</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Swim!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">    go(s1); <span class="comment">//输出 Swim！</span></span><br><span class="line">    go(<span class="keyword">new</span> <span class="title class_">Swimming</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Swim!2nd&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;)<span class="comment">//输出Swim！2nd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(Swimming s)</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;Go!&quot;</span>);</span><br><span class="line">	s.swim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Swimming</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>应用：快速创建子类对象，用于（interface）实现类对象作形参的情况 一般是被动去用</li>
<li>JFrame API: <code>button.addActionListener(ActionListener act)</code> <code>ActionListener</code> is an interface</li>
</ul>
<h3 id="枚举-enum-关键字"><a href="#枚举-enum-关键字" class="headerlink" title="枚举 enum 关键字"></a>枚举 enum 关键字</h3><ul>
<li><p> 特殊的class ，私有的构造器，只能创建固定数量的实例(对象)</p>
</li>
<li><p>如果有抽象方法，对象必须实现方法</p>
</li>
<li><p>遍历 for-each语句 没有索引，不能修改元素</p>
<ul>
<li>```java<br>for (int number: numbers){<pre><code>System.out.prinln(number);
</code></pre>
}<br>for (String name : names) {<pre><code>        System.out.println(name);
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ![image-20240912125835772](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912125835772.png)</span><br><span class="line"></span><br><span class="line">枚举变量实际是常对象，用public static final 修饰，创建了X,Y,Z三个常对象，调用的是无参的构造器，也可以自己写有参构造器， </span><br><span class="line"></span><br><span class="line">![image-20240912130046257](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912130046257.png)</span><br><span class="line"></span><br><span class="line">#### 设计模式：单例</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public enum C&#123;X;&#125;//单例</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="信息标注"><a href="#信息标注" class="headerlink" title="信息标注"></a>信息标注</h4><p>常量输入的信息不受约束，用枚举做信息标注更好</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912131648801.png" alt="image-20240912131648801"></p>
<p>枚举做形参，方法内直接写出对应的枚举即可</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul>
<li><p>相当于是类做参数</p>
</li>
<li><p><code>ArrayList</code> 没有指出泛型，默认是<code>Object</code>对象</p>
</li>
<li><p><code>ArrayList&lt;String&gt;</code> 只能接受<code>String</code>类型的数据</p>
</li>
<li><p><code>ArrayList&lt;T extends Animal&gt;</code> 只能接受<code>Animal</code>子类</p>
</li>
<li><p><code>ArrayList&lt;T implements Driver&gt;</code> 只能接受<code>Driver</code>实现类</p>
</li>
<li><p>把数据类型作为参数传递给类型变量，相当于缺省，然后对类的成员进行赋值</p>
</li>
<li><p><em>使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组(<code>Object[] arr</code>)排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。</em> </p>
</li>
<li><p>```java<br>public interface Data<T>{</p>
<pre><code>void add(T t);
ArrayList&lt;T&gt; getByName(String name);
</code></pre>
<p>}<br>class Teacher implements Data<Teacher>{</p>
<pre><code>@Override
void add(Teacher teacher)&#123;&#125;
@Override
ArrayList&lt;Teacher&gt; getByName(String name)&#123;
    return null;
&#125;
</code></pre>
<p>}<br>}//泛型接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 泛型方法 用`&lt;E&gt;`修饰，表明方法中存在缺省**类型** class E，可能在参数列表中，也可能在返回值中，也可能在具体的实现中 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static &lt; E &gt; void printArray( E[] inputArray )&#123;</span><br><span class="line">      // 输出数组元素            </span><br><span class="line">    for ( E element : inputArray )&#123;     </span><br><span class="line">            System.out.printf( &quot;%s &quot;, element );</span><br><span class="line">    &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912141719516.png" alt="image-20240912141719516"></p>
<ul>
<li><p>定义的时候在返回值前加泛型，单纯使用可以在ArrayList加通配符</p>
<ul>
<li><code>public static &lt;T&gt; void go (ArrayList&lt;T&gt; cars)</code> </li>
<li><code>public static void go (ArrayList&lt;?&gt; cars)</code> </li>
<li><code>&lt;?&gt;</code>表示能接收一切类型的ArrayList </li>
<li><code>&lt;? extends Car&gt;</code>表示能接收Car以及Car子类的ArrayList，也叫上限</li>
<li><code>&lt;? super Car&gt;</code>表示能接收Car以及Car父类的ArrayList ，也叫下限</li>
</ul>
</li>
<li><p><strong>泛型擦除：</strong> 编译阶段工作，class字节码文件中并不存在泛型，都是将 Object 对象 强转为 E 类型</p>
</li>
<li><p>泛型<strong>不支持基本数据类型</strong>，Integer Double 类型解决</p>
</li>
</ul>
<h2 id="API-from-JDK-2024-9-12"><a href="#API-from-JDK-2024-9-12" class="headerlink" title="API from JDK 2024.9.12"></a>API from JDK 2024.9.12</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><ul>
<li><p>Java Object 类是所有类的父类，也就是说 Java 的所有类都继承了 Object，<strong>子类可以使用 Object 的所有方法</strong>。</p>
</li>
<li><p>Object 类位于 java.lang 包中，编译时会自动导入，我们创建一个类时，如果没有明确继承一个父类，那么它就会自动继承 Object，成为 Object 的子类。</p>
</li>
<li><p><code>toString() 返回字符串形式</code> 可重写,以返回对象的内容</p>
</li>
<li><p><code>equals(Object o) 返回boolean </code>   判断对象是否相等 默认比较 <strong>地址</strong> 可重写成 比较两个的内容是否一样</p>
<ul>
<li>先判断地址是否一样</li>
<li>再判断是不是null/是不是同一个类</li>
<li>再判断变量是否相等 <code>return this.age == student.age &amp;&amp; Objects.equals(this.name,student.name)</code>  </li>
</ul>
</li>
<li><p><code>protected o clone()</code> 复制一个完全相同的Object对象，内容相同，属于<strong>浅拷贝</strong> 调用子类方法需要强转 。我们用的类跟Object源文件不在一个包下，所以子类要用<code>clone()</code>必须要重写，通过子类<code>super</code>间接调用父类Object的<code>clone()</code>。并且子类必须是接口<code>Cloneable</code>的实现类.</p>
</li>
<li><p>浅拷贝：<strong>对象中包含的其他对象</strong>，依然指向同一个对象(相当于直接把对象的地址也复制过去了) </p>
</li>
<li><p>深拷贝：浅拷贝+对象中包含的对象单独浅拷贝<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912230730643.png" alt="image-20240912230730643"></p>
</li>
<li><p>```java<br>protected Object clone() throws CloneNotSupportedException {</p>
<pre><code>    Animal a = (Animal)super.clone();
    a.arr = a.arr.clone();//数组内部没有其他的对象，
    return o;
&#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Objects</span><br><span class="line"></span><br><span class="line">- ![image-20240912233304677](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912233304677.png)</span><br><span class="line"></span><br><span class="line">- equals方法是为了避免空指针异常，s1.equals()，s1 = null 会报NullPointerException</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  public static boolean equals(Object a, Object b)&#123;</span><br><span class="line">  	return (a==b)||(a != null &amp;&amp; a.equals(b))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>int -&gt; Integer      char -&gt;Character</p>
<p>泛型和集合不支持基本数据类型，用包装类替代，有自动装箱和自动拆箱机制</p>
<ul>
<li><code>Integer.toString()</code> 将Integer对象转换成字符串 i.toString();</li>
<li><code>Integer.toString(int i)</code> 将23这个数字转换成字符串 静态方法 <ul>
<li>arr[i] + “” 数字+空串也可以转换成字符串</li>
</ul>
</li>
<li><code>Double.parseDouble(String str)</code> 将str转换成 double 静态方法</li>
<li><code>Double.valueOf(String str)</code> 将str转换成 double 静态方法</li>
<li>println 能加则加，不能加就一起输出</li>
</ul>
<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913000059749.png" alt="image-20240913000059749"></p>
<ul>
<li>StringBuilder重写了toString()  </li>
<li>append返回对象本身，可以链式调用，s.append(1).append(2).append(“!23213”);</li>
<li>reverse、length</li>
<li>操作字符串建议使用StringBuilder 是可变对象 效率更高</li>
<li>线程不安全。</li>
</ul>
<h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><ul>
<li>线程安全</li>
</ul>
<h3 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h3><ul>
<li>格式化拼接，方便快捷</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913001740989.png" alt="image-20240913001740989"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getArr</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123; <span class="comment">//返回数组</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            sb.append(arr[i]);</span><br><span class="line">            <span class="keyword">if</span>(i!=arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getArr</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123; <span class="comment">//返回数组</span></span><br><span class="line">        <span class="type">StringJoiner</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;,&quot;</span>,<span class="string">&quot;[&quot;</span>,<span class="string">&quot;]&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            sj.add(arr[i]+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">return</span> sj.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Math-2024-9-13"><a href="#Math-2024-9-13" class="headerlink" title="Math 2024.9.13"></a>Math 2024.9.13</h3><p>工具类，静态方法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913134448095.png" alt="image-20240913134448095"></p>
<p>abs ceil floor round</p>
<h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p>工具类 静态方法</p>
<p><code>System.exit(0) </code> 人为停机</p>
<p><code>System.currentTimeMillis()</code> 返回毫秒值 统计程序时间</p>
<h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><ul>
<li>java程序所在的运行环境</li>
<li><strong>单例类</strong> 构造器私有，声明一个public static final</li>
<li>exit exec</li>
</ul>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><ul>
<li><p><code>public BigDecimal(String val)</code>构造器 将double转成String类型然后付给BigDecimal</p>
</li>
<li><p><code>public static BigDecimal valueOf(double val)</code> 直接接一个double，据此创建一个BigDecimal对象（推荐）</p>
</li>
<li><p>divide(另一个BD对象，精确位数，舍入模式)</p>
<ul>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913140854393.png" alt="image-20240913140854393"></p>
</li>
<li><table>
<thead>
<tr>
<th>UP</th>
<th>DOWN</th>
<th>CEILING</th>
<th>FLOOR</th>
<th>HALF_UP</th>
<th>HALF_DOWN</th>
</tr>
</thead>
<tbody><tr>
<td>远离0方向</td>
<td>接近0方向</td>
<td>向上取整</td>
<td>向下取整</td>
<td>四舍五入</td>
<td>五舍六入</td>
</tr>
</tbody></table>
</li>
<li><p>HALF_EVEN 若（<strong>舍入位大于</strong>5）或者（<strong>舍入位等于</strong>5<strong>且前一位为奇数</strong>），则对舍入部分的前一位数字加1；若（<strong>舍入位小于</strong>5）或者（<strong>舍入位等于</strong>5且前一位为偶数），则直接舍弃。</p>
</li>
</ul>
</li>
<li><p>转成<code>double d =  bigdecimal.doubleValue()</code></p>
</li>
</ul>
<h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913164633885.png" alt="image-20240913164633885"></p>
<h5 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h5><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><ul>
<li><p><code>toString([] arr)</code> 返回一个数组字符串，每个元素调用<code>toString()</code>转换成字符串，用<code>[,,,]</code>拼接成一个总字符串</p>
</li>
<li><p> <code>copyOfRange([] arr, from, to)</code> 返回值为数组， 内容为arr中索引 <strong>[from, to)</strong> 的部分</p>
</li>
<li><p><code>copyOf([] arr, int newlength)</code> 返回值为数组，内容为arr的内容，长度为newlength，不够的用0补齐，索引超出的截断</p>
</li>
<li><p><code>setAll</code>  第二个参数是接口<code>IntToDoubleFunction</code>的实现对象，重写了<code>applyAsDouble(int value)</code>方法，value是数组的索引，返回对数组中内容进行操作的结果，图中是将数组内容乘以0.8。这个对象传进来以后，对数组进行遍历，都用<code>applyAsDouble</code>的方法进行操作。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913170741004.png" alt="image-20240913170741004"></p>
</li>
<li><p><code>sort([] arr)</code> 对arr升序排序(默认升序)</p>
</li>
<li><p><code>asList()</code>:只能加<strong>引用类型</strong>，基本数据类型需要改成包装类，并且返回的<code>List</code>是不能运用<code>add remove clear</code>方法的，这个<code>list</code>是<code>AbstractList</code>的子类，如果要访问<code>utils</code>只能将返回的这个<code>List</code>添加到<code>new ArrayList&lt;&gt;()</code>作为有参构造</p>
</li>
</ul>
<h4 id="对象数组如何排序？-Comparable-Comparator-—匿名内部类实现函数式接口"><a href="#对象数组如何排序？-Comparable-Comparator-—匿名内部类实现函数式接口" class="headerlink" title="对象数组如何排序？ Comparable Comparator —匿名内部类实现函数式接口"></a>对象数组如何排序？ Comparable Comparator —匿名内部类实现函数式接口</h4><p><strong>自己指定比较规则</strong> </p>
<ul>
<li><p>方法1：对象类实现<code>Comparable&lt;E&gt;</code>这个泛型接口，类中重写<code>int compareTo(E e)</code> 方法，将E改为自己的对象类型。</p>
<ul>
<li>约定，左边大于右边 return 正整数，小于 return 负整数，等于 return 0;（升序排序）</li>
<li><code>return this.age - o.age</code>  注意返回值是int double可以调用<code>Double.compare(o1.height, o2.height)</code></li>
<li>调用<code>Arrays.sort(students)</code>即可</li>
</ul>
</li>
<li><p>方法2：实现<code>Comparator</code>这个泛型接口，运用</p>
<ul>
<li><p>sort有一个重载函数，第一个参数是对象数组<code>T[] arr</code>，第二个参数是<code>Comparator&lt;? super T&gt; comparator</code></p>
</li>
<li><p>泛型接口做参数用匿名内部类实现，类中重写<code>int compare(T o1,T o2)</code>方法，同时注意返回的是int</p>
</li>
<li><p>```java<br>Arrays.sort(students, new Comparator<Students>(){</p>
<pre><code>@Override
public int compare(Student o1, Student o2)&#123;
    return Double.compare(o1.height,o2.height);//升序
&#125;
</code></pre>
<p>})</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ArrayList有自己的sort方法，实现同Comparator，可以免去泛型的指定</span><br><span class="line"></span><br><span class="line">#### **Lambda 表达式—简化匿名内部类**</span><br><span class="line"></span><br><span class="line">- 简化匿名内部类的写法，并且只能简化函数式接口(只有一个抽象方法的接口)，表示该接口的一个实现</span><br><span class="line"></span><br><span class="line">- @FunctionalInterface</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  Swimming s = new Swimming()&#123;</span><br><span class="line">  	@Override</span><br><span class="line">      public void swim(String name)&#123;</span><br><span class="line">  		System.out.println(name + &quot;is a swimmer~&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Swimming s = (name) -&gt; &#123;</span><br><span class="line">          System.out.println(name + &quot;is a swimmer~&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913220402634.png" alt="image-20240913220402634"></p>
</li>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913220414015.png" alt="image-20240913220414015"></p>
</li>
<li><p>参数类型可省略不写，无参数也要空括号</p>
</li>
<li><p>如果只有一个参数，参数列表的括号可以省略不写</p>
</li>
<li><p>如果实现的抽象方法只有一行代码，可以省略大括号，同时也要省略<code>;</code>，若这一行是<code>return</code>语句，return也不能写</p>
</li>
<li><p>```java<br>Arrays.sort(students, new Comparator<Student>(){<br>   @Override</p>
<pre><code>public int compare(Student o1, Student o2)&#123;
    return Double.compare(o1.age(),o2.age());
&#125;
</code></pre>
<p>});<br>Arrays.sort(students, (Student o1,Student o2)-&gt;{</p>
<pre><code>return Double.compare(o1.age(),o2.age());
</code></pre>
<p>});<br>Arrays.sort(students, (o1,o2)-&gt;{return Double.compare(o1.age(),o2.age());});<br>Arrays.sort(students, (o1,o2)-&gt;Double.compare(o1.age(),o2.age());</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">#### 方法引用</span><br><span class="line"></span><br><span class="line">[秒懂Java之方法引用（method reference）详解-CSDN博客](https://blog.csdn.net/ShuSheng0007/article/details/107562812)</span><br><span class="line"></span><br><span class="line">Lambda的简化 对于参数列表和返回值相同的情况</span><br><span class="line"></span><br><span class="line">##### 类的静态方法引用/类的实例方法引用（对象本身并不作为参数）</span><br><span class="line"></span><br><span class="line">- 静态方法引用: 调用静态方法，不需要实例，前缀是类名</span><br><span class="line"></span><br><span class="line">- 实例方法引用: 调用已经存在的对象的实例方法，对象本身并不是参数，方法引用前缀是具体的对象</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  interface Comparator&lt;E&gt;&#123;</span><br><span class="line">  	public int compare(E o1, E o2);</span><br><span class="line">  &#125;</span><br><span class="line">  class CompareByData&#123;</span><br><span class="line">  	public static int compareByAge(Student o1, Student o2)&#123;</span><br><span class="line">  		return Double.compare(o1.getAge(),o2.getAge());</span><br><span class="line">  	&#125;</span><br><span class="line">      public int compareByAgeDesc(Student o1, Student o2)&#123;</span><br><span class="line">  		return Double.compare(o2.getAge(),o1.getAge());</span><br><span class="line">  	&#125;</span><br><span class="line">      public int compareBy</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  Arrays.sort(students, (o1,o2)-&gt;CompareByData.compareByAge(o1,o2));//lambda</span><br><span class="line">  Arrays.sort(students, CompareByData::compareByAge);//静态方法引用</span><br><span class="line">  </span><br><span class="line">  CompareByData com = new CompareByData();</span><br><span class="line">  Arrays.sort(students, (o1,o2)-&gt;com.compareByAgeDesc(o1,o2));//lambda</span><br><span class="line">  Arrays.sort(students, com::compareByAgeDesc);//实例方法引用,com并不是参数</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="类的实例方法引用-对象本身作为参数"><a href="#类的实例方法引用-对象本身作为参数" class="headerlink" title="类的实例方法引用(对象本身作为参数)"></a>类的实例方法引用(对象本身作为参数)</h5><ul>
<li><p>调用实例方法，对象本身作为参数传进来，方法引用前缀为类名</p>
</li>
<li><p>```java<br>Arrays.sort(names, (String o1,String o2)-&gt;o1.compareToIgnoreCase(o2));<br>Arrays.sort(names, String::compareToIgnoreCase);//compareToIgnoreCase本身是String的一个实例方法</p>
<p>lqw.lt((User o1)-&gt;o1.getAge());<br>lqw.lt(User::getAge, 10);//getAge是User的一个实例方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 传入的对象o1是实例方法的调用者，其余的参数都是这个方法的参数</span><br><span class="line"></span><br><span class="line">##### 构造器引用</span><br><span class="line"></span><br><span class="line">- Lambda表达式如果只是在创建一个对象</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  private Student getStudent(String name, int age, BiFunction&lt;String, Integer, Student&gt; biFunction) &#123;</span><br><span class="line">      return biFunction.apply(name, age);</span><br><span class="line">  &#125;</span><br><span class="line">  BiFunction&lt;String, Integer, Student&gt; s1 = new BiFunction&lt;String, Integer, Student&gt;() &#123;</span><br><span class="line">          @Override</span><br><span class="line">  a        public Student apply(String name, Integer age) &#123;</span><br><span class="line">              return new Student(name, age);</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">      </span><br><span class="line">  	//lambda表达式</span><br><span class="line">      BiFunction&lt;String, Integer, Student&gt; s2 = (name, age) -&gt; new Student(name, age);</span><br><span class="line">      </span><br><span class="line">  	//对应的方法引用</span><br><span class="line">      BiFunction&lt;String, Integer, Student&gt; s3 = Student::new;</span><br><span class="line">      </span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="方法引用-Lambda作为参数，可以在前面加上实现的函数式接口形参名，增强可读性"><a href="#方法引用-Lambda作为参数，可以在前面加上实现的函数式接口形参名，增强可读性" class="headerlink" title="方法引用/Lambda作为参数，可以在前面加上实现的函数式接口形参名，增强可读性"></a>方法引用/Lambda作为参数，可以在前面加上实现的函数式接口形参名，增强可读性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(names, (Comparator&lt;? <span class="built_in">super</span> String&gt;) String::compareToIgnoreCase);</span><br><span class="line">Arrays.sort(names, String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure>



<h2 id="Regex-正则表达式"><a href="#Regex-正则表达式" class="headerlink" title="Regex 正则表达式"></a>Regex 正则表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">qqCode</span> <span class="operator">=</span> <span class="string">&quot;12812415&quot;</span>;</span><br><span class="line">System.out.println(qqCode.matches(<span class="string">&quot;[1-9]\\d&#123;5-19&#125;&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="Exception-异常处理"><a href="#Exception-异常处理" class="headerlink" title="Exception 异常处理"></a>Exception 异常处理</h2><p><code>Error</code>属于严重异常</p>
<p>运行时异常<code>RuntimeException</code></p>
<p>编译时异常，不解决是无法运行的</p>
<h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240914213155516.png" alt="image-20240914213155516"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行时异常</span></span><br><span class="line"><span class="comment">//自定义异常对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeIllegalRuntimeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalRuntimeException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalRuntimeException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(....) &#123;...&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeIllegalRuntimeException</span>(<span class="string">&quot;Your age is illegal!&quot;</span>);</span><br><span class="line">    &#125;<span class="comment">//抛出一个异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        saveAge(<span class="number">123</span>);<span class="comment">//函数执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)&#123;<span class="comment">//catch 用来接受可能抛出的异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译时异常 强烈提醒检查</span></span><br><span class="line"><span class="comment">//自定义异常对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeIllegalException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveAge</span><span class="params">(<span class="type">int</span> age)</span> <span class="keyword">throws</span> AgeIllegalException&#123;<span class="comment">//接收方法内部可能抛出的异常</span></span><br><span class="line">    <span class="keyword">if</span>(....) &#123;...&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeIllegalException</span>(<span class="string">&quot;Your age is illegal!&quot;</span>);<span class="comment">//一开始会报错,throws抛出</span></span><br><span class="line">    &#125;<span class="comment">//抛出一个异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        saveAge(<span class="number">183</span>);<span class="comment">//函数执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)&#123;<span class="comment">//catch 用来接受可能抛出的异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><code>throws</code>:用于方法的声明当方法内部抛出指定类型的异常时，该异常会被传递给<strong>调用该方法的代码</strong>，并在该代码中处理异常</p>
<p><code>try-catch</code>:试图接收并处理异常</p>
<p><code>throw</code>:用于在当前方法中抛出一个异常，当代码执行到某个条件下无法继续正常执行时，可以使用 <strong>throw</strong> 关键字抛出异常，以告知调用者当前代码的执行状态</p>
<ul>
<li>底层异常往外抛,最外层接受并记录,响应给用户</li>
<li>最外层接收,并在底层尝试修复<ul>
<li><code>sc.nextDouble()</code>接收一个<code>double</code>类型,如果乱输aafads就会在运行时自动抛出错误给外层</li>
<li>只需要将外层调用的<code>try-catch</code>块用<code>while(true)</code>围起来即可</li>
</ul>
</li>
</ul>
<h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><h2 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h2><h3 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h3><p>file&amp;directory</p>
<ul>
<li><code>File(String pathname)</code>:有参构造, <code>pathname</code>路径分隔符<code> / \\ File.separator</code> <ul>
<li>绝对路径</li>
<li>相对路径：默认起始位置是工程目录<code>(模块)file-io-app\\src\\itheima.txt</code></li>
</ul>
</li>
<li><code>f1.length()</code>:返回文件,文件夹大小 字节数 文件夹是存储文件夹内部的一些文件信息</li>
<li><code>f3.exists()</code>:是否存在</li>
<li><code>f3.isFile()</code>:是否是文件</li>
<li><code>f3.isDirectory()</code>:是否是文件夹</li>
<li><code>f3.getName()</code>:获取文件名称，包含后缀</li>
<li><code>f3.lastModified()</code>:返回long 最后修改的时间</li>
<li><code>f1.getPath()</code>获取创建对象时输入的路径</li>
<li><code>f1.getAbsolutePath()</code>获取文件的绝对路径</li>
</ul>
<ul>
<li><code>f1.createNewFile()</code>:不存在才创建，存在就创建失败，返回<code>false</code>  没找到路径会报错</li>
<li><code>f1.mkdir()</code>:不存在才创建，存在就创建失败，返回<code>false</code> 只能创建一级目录</li>
<li><code>f1.mkdirs()</code>:可以创建多级目录，返回结果</li>
<li><code>f1.delete()</code>:删除文件、空文件夹，返回结果</li>
</ul>
<ul>
<li><code>f1.list()</code>:当前<strong>文件夹</strong>内的<strong>一级文件名称</strong>返回<code>String[]</code> 也包含文件夹</li>
<li><code>f1.listFiles()</code>:返回当前<strong>文件夹</strong>内的<strong>一级文件对象</strong>，返回文件对象数组<code>File[]</code>，也包含文件夹<ul>
<li>文件、路径不存在、无权限访问的文件夹 <code>return null</code></li>
<li>空文件夹返回长度为0的File数组</li>
<li>隐藏文件也显示</li>
</ul>
</li>
<li><code>renameTo(new File(file.getParent(), newName))</code> 改名，file是目录下子文件,<code>substring(from,to)</code>是截取<code>[from,to)</code>,<code>substring(from)</code>是截取<code>[from,最后]</code></li>
</ul>
<h4 id="文件搜索、非空文件夹删除"><a href="#文件搜索、非空文件夹删除" class="headerlink" title="文件搜索、非空文件夹删除"></a>文件搜索、非空文件夹删除</h4><p>递归，数学问题最好写出表达式</p>
<p>eg 猴子一天吃一半还要再吃一个，10天剩余1个。前9天各自吃了多少？</p>
<p>$f(x)$代表第x天的桃子数量，题干可得出$f(x)/2+1 = f(x+1), f(10)=1$ 直接写递归函数即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNumberOfPeach</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">10</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*getNumberOfPeach(n+<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="C:\Users\Lenovo\IdeaProjects\MyFirstProject\src\com\it\IOtest\FileTestDemo.java">文件搜索、非空文件夹删除</a> </p>
<p><a href="C:\Users\Lenovo\IdeaProjects\MyFirstProject\src\com\it\IOtest\RecursiveDemo.java">递归练习</a> </p>
<h3 id="字符集（前置）"><a href="#字符集（前置）" class="headerlink" title="字符集（前置）"></a>字符集（前置）</h3><p>ASCII: 首位是0，使用1个字节存储英文数字</p>
<p>GBK: 1个中文字符编码成2个字节，兼容ASCII，并且对汉字规定第一个字节的第一位必须是1，与ASCII字符做区分</p>
<p>Unicode: </p>
<ul>
<li><p>UTF-32 4个字节表示一个字符</p>
</li>
<li><p>UTF-8 </p>
<ul>
<li>可变长编码方案 可以有1B 2B 3B 4B 四种长度 </li>
<li>兼容ASCII，汉字字符占3B</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916165638204.png" alt="image-20240916165638204"></li>
</ul>
</li>
<li><p>Encode Decode Identical</p>
</li>
<li><p>String提供了一些API，为字符串提供了编码和解码操作，以字节数组的形式<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916170250587.png" alt="image-20240916170250587"></p>
</li>
</ul>
<h3 id="IO流-字节流-amp-字符流"><a href="#IO流-字节流-amp-字符流" class="headerlink" title="IO流:字节流&amp;字符流"></a>IO流:字节流&amp;字符流</h3><ul>
<li><code>InputStream</code>:字节输入流:以内存为基准，来自磁盘文件/网络中的数据以字节的形式读入到内存中去的流</li>
<li><code>OutputStream</code>:字节输出流:以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流</li>
<li><code>Reader</code>:字符输入流:以内存为基准，来自磁盘文件/网络中的数据以字符的形式读入到内存中去的流，</li>
<li><code>Writer</code>:字符输出流:以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916171717591.png" alt="image-20240916171717591"></p>
<h4 id="FileInputStream-字节流"><a href="#FileInputStream-字节流" class="headerlink" title="FileInputStream 字节流"></a>FileInputStream 字节流</h4><ul>
<li>从文件一个字节一个字节地读取数据到内存中</li>
<li><code>InputStream is = new FileInputStream(&quot;........&quot;)</code></li>
<li><code>FileInputStream(String name)</code>:打开实际文件的连接创建文件字节输入流，也可用<code>File file</code>做形参，<code>String</code>重载会自动帮你转成file对象。</li>
<li>一次读取一个 <code>int read()</code> 读取一个字节并返回，无数据返回-1 <ul>
<li>改进：循环<code>(b=is.read())!=-1</code></li>
<li>调用系统硬件资源，性能较差</li>
<li>一次读一个，无法解决非ASCII的乱码</li>
<li>流使用系统资源，使用完记得关闭！<code>is.close()</code></li>
</ul>
</li>
<li>一次读取多个 <code>int read(byte[] buffer)</code> 用<code>buffer</code>字节数组装字节，字节数组的长度代表每次读取的字节数，返回每次读取的字节数（<code>buffer</code>可能会装不满）无数据返回-1<ul>
<li><code>buffer</code>字节数组要转换成字符串，转成<code>String</code>可以设定转的部分，<code>String(buffer, 0, len)</code>确保如实把<strong>这次</strong>读到的内容转为字符串 <code>len</code>为<code>read</code>的返回值 </li>
<li>性能得到了提升，汉字仍然乱码，会强行截断汉字</li>
</ul>
</li>
<li>一次读取全部<ul>
<li><code>int read(byte[] buffer)</code>buffer大小和文件的大小字节数相同</li>
<li><code>byte[] readAllBytes()</code> <code>is.readAllBytes()</code> </li>
<li>文件过大会导致内存溢出，字节数组过大，所以字节流不适合读文本，更适合做数据转移，比如文件复制</li>
</ul>
</li>
</ul>
<h4 id="FileOutputStream-字节流"><a href="#FileOutputStream-字节流" class="headerlink" title="FileOutputStream 字节流"></a>FileOutputStream 字节流</h4><ul>
<li>从内存一个字节一个字节地输出到文件中，目标文件自动生成</li>
<li><code>OutputStream os = new FileOutputStream(&quot;........&quot;)</code> 写文件（覆盖）</li>
<li><code>OutputStream os = new FileOutputStream(&quot;........&quot;, true)</code> 写文件（追加）<ul>
<li>换行：<code>&quot;\r\n&quot;</code> 将其转换成<code>bytes[]</code> 再<code>write</code></li>
</ul>
</li>
<li><code>os.write(int b)</code>把b写入文件 还是以字节形式</li>
<li><code>os.write(byte[] b)</code>把字节数组b写入文件</li>
<li><code>os.write(byte[] b,int off,int len)</code>把b写入文件, <code>off</code>表示起始的字节数组索引，<code>len</code>表示要写入的字节长度，3个汉字一共9字节</li>
</ul>
<h5 id="case-文件复制"><a href="#case-文件复制" class="headerlink" title="case: 文件复制"></a>case: 文件复制</h5><p>总结：字节流适合拷贝一切文件，因为一切文件的内容都是以字节形式存储的，一字不漏地转移所有字节，就不会出现问题</p>
<h4 id="释放资源的方式"><a href="#释放资源的方式" class="headerlink" title="释放资源的方式"></a>释放资源的方式</h4><p>原来：中间出现异常，就无法释放资源（关闭字节流）</p>
<h5 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论try是否正常执行，一定执行finally，除非JVM终止<code>System.exit(0)</code></p>
<p>finally可以无视<code>return</code>语句 一定执行一次，如果finally是return，原函数接受的就一定是finally里边的值，所以最好不要在finally里面return</p>
<p>在程序执行完成后进行资源的释放操作，finally不能访问try块里面的内容</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916200213214.png" alt="image-20240916200213214">先在try块外定义流，然后try块内对流进行操作，finally块内关闭流，关闭流因为系统不知道之前是否开流会报错，用try catch块包围起来即可<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916200719319.png" alt="image-20240916200719319"></p>
<p><strong>臃肿</strong></p>
<h5 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>（</span><br><span class="line">	<span class="comment">//资源的定义;</span></span><br><span class="line">	<span class="comment">//资源的定义;</span></span><br><span class="line">）&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能放置资源对象, 资源都会实现AutoClosable接口，资源放进去会自动调用close方法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916201402673.png" alt="image-20240916201402673"></p>
<h4 id="FileReader-字符流"><a href="#FileReader-字符流" class="headerlink" title="FileReader 字符流"></a>FileReader 字符流</h4><ul>
<li>把文件数据以字符形式读到内存中去</li>
<li>构造器与<code>FileInputStream</code>类似 <code>Reader fr = new FileReader(String filename)</code></li>
<li><code>int read() </code>每次读取一个字符并返回</li>
<li><code>int read(char[] buffer) </code>每次读取多个字符并返回，返回此次读取字符的个数</li>
</ul>
<h4 id="FileWriter-字符流"><a href="#FileWriter-字符流" class="headerlink" title="FileWriter 字符流"></a>FileWriter 字符流</h4><ul>
<li>把字符数据写到文件中去,目标文件自动生成</li>
<li>构造器与<code>FileOutputStream</code>类似 <code>Writer fw = new FileWriter(String filename)</code>可以参数后加true表示追加</li>
<li><code>void write(int c)</code>写一个字符出去</li>
<li><code>void write(String str)</code>写一个字符串出去</li>
<li><code>void write(String str,int pos,int len)</code> 写字符串从<code>pos</code>开始长度为<code>len</code></li>
<li><code>void write(char[] buffer)</code>写一个字符数组</li>
<li><code>void write(char[] buffer,int pos,int len)</code>写字符数组从<code>pos</code>开始长度为<code>len</code></li>
<li>注意事项<ul>
<li>字符输出流写出数据以后，必须刷新流或者关闭流（包含刷新）才能生效。<code>flush() close()</code> 因为对文件操作比较耗费系统资源，所以都是先从管道写到缓冲区，写完之后一次性写到文件中去。</li>
</ul>
</li>
</ul>
<h3 id="IO流-缓冲流"><a href="#IO流-缓冲流" class="headerlink" title="IO流:缓冲流"></a>IO流:缓冲流</h3><p>对原始流进行包装，提高原始流读写数据的性能</p>
<h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><p>开辟缓冲区，不用一次一次写 <strong>8KB缓冲池</strong> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916231524970.png" alt="image-20240916231524970"></p>
<p>减少调用系统资源的次数</p>
<p><code>InputStream bis = new BufferedInputStream(InputStream is)</code></p>
<p><code>OutputStream bos = new BufferedOutputStream(OutputStream os)</code></p>
<p>方法和原始类一样，性能有所提高，有参构造可以自定义缓冲区大小，默认8192</p>
<h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h4><p>自带8K的字符缓冲池</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916232037970.png" alt="image-20240916232037970"></p>
<p><code>BufferedReader br = new BufferedReader(Reader r)</code> </p>
<p>不使用多态写法：新增了独有的功能</p>
<p>新增功能 <code>String readLine()</code> 读一整行，直到换行符，返回这行的内容，没有返回<code>null</code></p>
<p><code>BufferedWriter bw = new BufferedWriter(Writer r)</code> </p>
<p>新增功能：<code>void newLine()</code>换行</p>
<h3 id="原始-amp-缓冲流对比"><a href="#原始-amp-缓冲流对比" class="headerlink" title="原始&amp;缓冲流对比"></a>原始&amp;缓冲流对比</h3><ul>
<li>低级字节流一个一个字节的赋值，慢的简直让人无法忍受，直接淘汰! X</li>
<li>低级字节流一个一个字节数组的形式复制，速度较慢! </li>
<li>缓冲流按照一个一个字节的形式复制，速度较慢 X</li>
<li>缓冲流按照一个一个字节数组的形式复制，速度极快，推荐使用!</li>
<li>性能与字节数组的大小强相关，32MB最大，用空间换时间</li>
<li>与缓冲区的大小也有关</li>
</ul>
<p>并行&amp;多线程 异步IO 内存映射技术 减少系统调用 不要一个字节一个字节地输入</p>
<h3 id="字符转换流"><a href="#字符转换流" class="headerlink" title="字符转换流"></a>字符转换流</h3><h4 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h4><p><code>Reader isr = new InputStreamReader(InputStream is, String charset)</code> 把<strong>原始<mark>字节流<mark>is</strong>按照charset设定转换成对应字符输入流</p>
<p>新的字符输入流可以继续用<code>BufferedReader</code>包装</p>
<h4 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h4><p>控制写出去的字符集编码</p>
<ul>
<li><code>str.getBytes(&quot;GBK&quot;)</code></li>
<li>字符输出转换流</li>
</ul>
<h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p>PrintStream：是<strong>字节输出流</strong>的实现类</p>
<p>PrintWriter：是<strong>字符输出流</strong>的实现类 内部包装缓冲流</p>
<p><strong>方便高效</strong>，所见即所得</p>
<p>构造器：</p>
<ul>
<li><code>PrintStream(OutputStream os/File file/String filename)</code> 直接链接+包装原始流</li>
<li><code>PrintStream(String filename, Charset charset)</code> <code>Charset.forName(&quot;GBK&quot;)</code>能返回GBK的Charset</li>
<li><code>PrintStream(OutputStream os, boolean autoFlush, String charset)</code> 字符集可有可无</li>
<li><strong><code>ps.println()</code>:打印一行东西</strong></li>
<li><code>ps.write()</code>写int字节 字节数组 字节数组的一部分</li>
</ul>
<p>自身没有追加功能，只能包装<code>true输出流</code>:</p>
<p><code>PrintStream ps = PrintStream(new FileOutputStream(filename,true))</code> </p>
<p><code>PrintWriter pw = PrintWriter(new FileWriter(filename,true))</code>  </p>
<h4 id="拓展：Redirecting-PrintStream-PrintWriter"><a href="#拓展：Redirecting-PrintStream-PrintWriter" class="headerlink" title="拓展：Redirecting PrintStream/PrintWriter"></a>拓展：Redirecting PrintStream/PrintWriter</h4><p><code>System.out.println()</code> out实际上就是一个打印流，是指向控制台的</p>
<p><code>System.setOut(PrintStream ps)</code> 把系统的out设定到指定的打印流ps中</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917153902713.png" alt="image-20240917153902713"></p>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p><code>DataInputStream</code>:字节输入流的实现</p>
<p>构造器：包装低级的字节输入流 </p>
<p><code>dos.writeInt(int a)</code> 写出去a，包括数据类型</p>
<p><code>dis.readUTF()</code> 读进来字符串并返回 UTF-8</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917154727844.png" alt="image-20240917154727844"></p>
<h3 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h3><p><a href="..%5CSerialization.md">序列化</a> </p>
<p> 字节流实现类<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917154853819.png" alt="image-20240917154853819"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917154908066.png" alt="image-20240917154908066"></p>
<p><strong>First Step</strong> 创建对象字节输出流 包装原始字节输出流:</p>
<p><code>ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream)</code></p>
<p><strong>Second Step</strong> 调用 writeObject(具体对象)方法 </p>
<p>对象的类要**<code>implements</code> <code>Serializable</code>** 接口！</p>
<p><strong>Third Step</strong> 创建对象字节输入流 包装原始字节输入流</p>
<p><code>ObjectInputStream ois = new ObjectInputStream(new FileInputStream)</code> </p>
<h4 id="拓展：对象中某些变量不想参与序列化"><a href="#拓展：对象中某些变量不想参与序列化" class="headerlink" title="拓展：对象中某些变量不想参与序列化"></a>拓展：对象中某些变量不想参与序列化</h4><p><code>private </code> <code>transient</code> <code> String password;</code> transient关键字</p>
<h4 id="拓展：一次序列化多个对象"><a href="#拓展：一次序列化多个对象" class="headerlink" title="拓展：一次序列化多个对象"></a>拓展：一次序列化多个对象</h4><p>将对象存入ArrayList中，对ArrayList进行序列化</p>
<h3 id="IO框架"><a href="#IO框架" class="headerlink" title="IO框架"></a>IO框架</h3><p>框架：把编写好的类和接口编译成class形式，压缩成.jar结尾的文件发行</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917162151321.png" alt="image-20240917162151321"></p>
<h2 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h2><p>存储有关系的数据作为系统的配置文件</p>
<h3 id="properties-属性文件"><a href="#properties-属性文件" class="headerlink" title=".properties 属性文件"></a>.properties 属性文件</h3><ul>
<li>存储键值对数据</li>
<li>键不重复</li>
</ul>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917163605651.png" alt="image-20240917163605651"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建属性对象，加载文件内容</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filename));</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建字符串集合，接收属性对象返回的键集合</span></span><br><span class="line">Set&lt;String&gt; keys = properties.stringPropertyNames();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历键集合，通过属性对象和键找到value</span></span><br><span class="line"><span class="keyword">for</span>(String key : keys)&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(key);</span><br><span class="line">	properties.forEach((k,v)-&gt;System.out.println(k + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917164532330.png" alt="image-20240917164532330"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.setProperty(<span class="string">&quot;asd&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;dfg&quot;</span>,<span class="string">&quot;213&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;hjk&quot;</span>,<span class="string">&quot;321&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">comments</span> <span class="operator">=</span> <span class="string">&quot;I have saved many users!!!&quot;</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">properties.store(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filename), comments);</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>



<h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><p>E<strong>X</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage</p>
<p>根标签 只有一个</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917170133400.png" alt="image-20240917170133400"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917170306289.png" alt="image-20240917170306289"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917170346202.png" alt="image-20240917170346202"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917170514649.png" alt="image-20240917170514649"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917185127560.png" alt="image-20240917185127560"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917185753893.png" alt="image-20240917185753893">好</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul>
<li>系统执行信息方便记录到指定的位置（控制台，文件，数据库）</li>
<li>随时用开关控制日志启停，不需要修改源代码</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917191534986.png" alt="image-20240917191534986"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917191744756.png" alt="image-20240917191744756"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917192232262.png" alt="image-20240917192232262"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917192328808.png" alt="image-20240917192328808"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917192715641.png" alt="image-20240917192715641"></p>
<p><code>&lt;pattern&gt; &lt;/pattern&gt;</code> 日志格式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917192956963.png" alt="image-20240917192956963"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917193034517.png" alt="image-20240917193034517"></p>
<p>文件拆分规则，保证每个不超过1MB，过去的压缩成1MB的gz文件</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917193427486.png" alt="image-20240917193427486"></p>
<p>控制日志输出情况</p>
<p>日志级别 trace&lt; <strong>debug</strong> &lt; info &lt; warn &lt; error </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917193721056.png" alt="image-20240917193721056"></p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><ul>
<li><code>java.net.*</code></li>
</ul>
<p>CS BS架构</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918155511067-1726751033487-55.png" alt="image-20240918155511067"></p>
<h2 id="网络通信基本概念"><a href="#网络通信基本概念" class="headerlink" title="网络通信基本概念"></a>网络通信基本概念</h2><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>设备在网络的地址，唯一标识</p>
<p><strong>IPv4:</strong> 32bit 点分十进制表示法    <strong>IPv6:</strong> 128bit 冒号分16进制表示法</p>
<p><strong>域名</strong>代表IP，<strong>DNS服务器</strong>会记录域名的真实IP</p>
<p><strong>公网IP</strong>：链接互联网 <strong>内网IP</strong>：局域网，内部使用</p>
<p>**<code>localhost = 127.0.0.1</code>**：代表本机IP，只会寻找当前所在的主机</p>
<p><strong><code>ping IP地址</code></strong> </p>
<h4 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h4><p>常用方法：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918160540846-1726751033487-56.png" alt="image-20240918160540846"></p>
<p><code>getByName()</code>: 根据主机名 返回IP地址对象</p>
<p><code>isReachable(int ms)</code> 相当于ping命令</p>
<h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><p>端口，应用程序在设备的地址，唯一标识</p>
<p>16bit 0-65535</p>
<p>0-1023: 预定义占用，周知端口</p>
<p>1024-49151: 注册端口</p>
<p>49152-65535: 动态分配</p>
<p>同一设备不能有两个程序的端口号一样</p>
<h3 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a>protocol</h3><p>协议，应用程序之间进行通信的规则</p>
<p>OSI 网络参考模型</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918161423219-1726751033487-57.png" alt="image-20240918161423219"></p>
<p>TCP/IP 事实上的国际标准</p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p><strong>U</strong>ser <strong>D</strong>atagram <strong>P</strong>rotocol</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918161816467-1726751033487-58.png" alt="image-20240918161816467"></p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p><strong>T</strong>ransmission <strong>C</strong>ontrol <strong>P</strong>rotocol</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918161923650-1726751033487-59.png" alt="image-20240918161923650"></p>
<h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h4><p>第一次握手：客户端发消息，服务器收到消息，服务器知道客户端发消息没问题。</p>
<p>第二次握手：服务端发消息，客户端收到消息，客户端知道服务端收消息没问题，发消息也没问题。</p>
<p>第三次握手：客户端根据上一次握手的内容再次发出确认信息，服务器端收到信息，说明客户端收消息没问题。</p>
<p>全双工：双方都要确认对方同时具备收发信息的能力</p>
<p>不可靠信道上实现可靠的传输</p>
<p><strong>B 收到了 A 发来的消息，B 因此判断 A 具备发送能力</strong>：</p>
<ul>
<li>这个理解是正确的。当 B 收到 A 发送的 <code>SYN</code> 报文时，B 可以判断 A 具有发送消息的能力。A 通过发送 <code>SYN</code> 表示自己希望建立连接，并告诉 B 自己的初始序列号。</li>
<li>但需要注意的是，B 仅能判断 A 能发送数据，尚无法确定 A 能正确接收 B 发送的消息（即 A 的接收能力）。</li>
</ul>
<p><strong>A 收到了 B 发回的消息，A 判断 B 具备收发信息能力</strong>：</p>
<ul>
<li><strong>发送能力</strong>：正确。当 A 收到 B 发回的 <code>SYN-ACK</code> 消息后，A 可以确认 B 具备发送能力，因为 B 能够发送 <code>SYN-ACK</code> 报文。</li>
<li><strong>接收能力</strong>：A 也可以推断 B 具备接收能力，因为 B 不仅发送了 <code>SYN-ACK</code>，还包含了对 A 的 <code>SYN</code> 的确认（<code>ACK</code>），说明 B 成功接收了 A 的 <code>SYN</code> 报文。</li>
<li>因此，通过 B 的 <code>SYN-ACK</code> 报文，A 可以确认 B 既能够发送，也能够接收消息。</li>
</ul>
<p><strong>B 收到了 A 发回的信息，B 因此判断 A 具备接收能力，连接建立</strong>：</p>
<ul>
<li>这个理解也基本正确。当 B 收到 A 的 <code>ACK</code> 报文后，B 可以确认 A 的接收能力，因为 A 收到了 B 的 <code>SYN-ACK</code> 并发回了 <code>ACK</code>。如果 A 无法接收数据，就无法正确回应 B 的 <code>SYN-ACK</code> 报文。</li>
<li>至此，B 确定 A 既能发送也能接收，双方通信能力都得到确认，连接可以正式建立。</li>
</ul>
<ul>
<li>在 TCP 三次握手过程中，双方都通过序列号和确认号来确认彼此的发送和接收能力，确保连接是双向可靠的。</li>
<li>三次握手的过程确保了双方的<strong>发送能力</strong>和<strong>接收能力</strong>都正常，连接才会被建立。</li>
<li>你对各个步骤的理解是对的，只需要记住，每一步都不仅仅是确认对方的发送能力，还需要通过确认号和响应确认对方的接收能力。</li>
</ul>
<h4 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h4><ol>
<li>客户端发完数据，发出断连请求</li>
<li>服务器还没处理完最后的数据，先发一个消息，让客户端稍等</li>
<li>处理完数据后，服务器再发一个消息确认断开连接</li>
<li>客户端正式断开连接</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918213236026-1726751033487-61.png" alt="image-20240918213236026"></p>
<h2 id="Java-UDP"><a href="#Java-UDP" class="headerlink" title="Java UDP"></a><a href="jetbrains://idea/navigate/reference?project=MyFirstProject&fqn=com.it.netTest.UDP.Client">Java UDP</a></h2><ul>
<li><code>java.net.DatagramSocket</code> <code>java.net.DatagramPacket</code> </li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918213602137-1726751033487-60.png" alt="image-20240918213602137"></li>
<li>创建DS对象，创建DP对象用于封装数据，DP对象里有字节数组，字节数组长度，目标IP,目标端口，客户端调用send方法发送数据包。</li>
<li>创建DS对象(端口号)，创建DP对象用于接收数据，DP对象里的数组长度64KB，然后服务段调用receive方法接收数据包。数据包调用getLength方法获取实际接收数据包的大小，以便正确输出数据包内数组的内容。</li>
<li>getAddress()可以拿到客户端IP地址</li>
<li>getPort()可以拿到客户端端口</li>
</ul>
<h2 id="Java-TCP"><a href="#Java-TCP" class="headerlink" title="Java TCP"></a><a href="jetbrains://idea/navigate/reference?project=MyFirstProject&path=com/JavaSE/netTest/tcp/Server.java">Java TCP</a></h2><p><code>java.net.Socket</code> <code>java.net.ServerSocket</code></p>
<p>服务端和客户端通过<code>socket</code>对象之间建立的管道进行通信，数据通过管道也就是流进行传输，而UDP是通过发送单个<code>datagram</code>数据报的形式，不需要建立联系，不需要建立稳定的管道</p>
<ul>
<li><p>客户端：    </p>
<ul>
<li>创建<code>Socket sk = new Socket(hostname, port)</code> 数据目的地的端口号</li>
<li><code>OutputStream os = sk.getOutputStream();</code> 把<code>socket</code>的流拿到</li>
<li><code>DataOutputStream dos = new DataOutputStream(os)</code> 对原始的流进行包装</li>
<li><code>dos.writeUTF(&quot;String sth&quot;)</code> </li>
<li>关闭<code>dos</code> 关闭<code>socket</code> </li>
</ul>
</li>
<li><p>服务端</p>
<ul>
<li>创建 <code>ServerSocket ss = new ServerSocket( port)</code> 注册端口，跟客户端里面的端口一样</li>
<li><code>Socket socket = ss.accept()</code> 等待客户端发来socket连接请求，端到端，这两个socket内容其实是一样的。</li>
<li><code>DataInputStream dis = new DataInputStream(socket.getInputStream());</code>用数据流包装原始的输入流</li>
<li><code>dis.readUTF().sout</code></li>
</ul>
</li>
</ul>
<p>支持一发一收 多发多收，因为只能是一个socket对应一个socket，是端到端的，要实现跟其他socket的通信只能断开连接，所以引入多线程，接到socket就开一个新线程，继续监听socket，用while循环实现。</p>
<p>要实现群聊，服务器可以用一个集合储存socket，如果某个socket收到了消息，就遍历集合发给所有socket（同客户端的发送代码）客户端建立socket对象之后，在while循环内部出不来，要监听</p>
<p>BrowserServer架构 Server要提供的内容必须符合HTTP规范</p>
<h1 id="单元测试框架"><a href="#单元测试框架" class="headerlink" title="单元测试框架"></a>单元测试框架</h1><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240919211712463.png" alt="image-20240919211712463"></p>
<p>检测抛出异常</p>
<h2 id="断言机制"><a href="#断言机制" class="headerlink" title="断言机制"></a>断言机制</h2><p>Assert.assertEquals() bug提示 <strong>期望值</strong> 实际值 </p>
<h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>可以一键进行所有测试，一键自动化测试</p>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>@Test 测试方法</p>
<p>@Before(BeforeEach) 每个测试前要跑的方法</p>
<p>@BeforeClass(All) 修饰静态方法，所有测试方法之前，最先 这两个是初始化</p>
<p>@After(AfterEach) 每个测试执行完要跑的方法</p>
<p>@AfterClass(All) 修饰静态方法，所有测试方法之后，最后 这两个是释放资源</p>
<p>如果是每一个测试方法都需要一个独立的资源，就用before</p>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="annotation"><a href="#annotation" class="headerlink" title="annotation"></a>annotation</h2><p>让其他程序根据注解来决定怎么执行该程序</p>
<p><code>@Override</code>:让IDE判断方法是否重写成功 </p>
<p><code>@Test</code>: 让测试框架知道这个是测试方法</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest1&#123;</span><br><span class="line">    String <span class="title function_">aaa</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">bbb</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">    String[] ccc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//value 属于特殊属性，可以只写值</span></span><br><span class="line"><span class="comment">//有 default 可以不用赋值</span></span><br><span class="line"><span class="comment">//没 default 必须赋值，带变量名和等号</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyTest1</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">aaa</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">bbb</span><span class="params">()</span>&#123;<span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">true</span>;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String[] ccc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质是接口，都继承了Annotation接口</p>
<p><code>@MyTest1(aaa=&quot;123&quot;,bbb=false, ccc=&#123;&quot;str&quot;,&quot;asd&quot;&#125;)</code> 是一个实现类对象</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>修饰注解的注解, 在自定义注解的上面 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240919214219300.png" alt="image-20240919214219300"></p>
<h2 id="解析注解"><a href="#解析注解" class="headerlink" title="解析注解"></a>解析注解</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240919214508991.png" alt="image-20240919214508991"></p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>模拟框架 解析注解，然后执行 模拟<a href="jetbrains://idea/navigate/reference?project=MyFirstProject&fqn=org.JavaSE.AdvancedTest.Annotation.JUnitSimulator">JUnitSimulator(Toolbox 引用)</a>识别并执行有特定注解的方法</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>加载类，允许用编程的方式，解剖类中的各种成分（万物皆对象）</p>
<p>比如ide中创建一个对象，对象引用后加一个点就能显示可以调用的方法，说明这个类实现的方法已经提前加载好了</p>
<h2 id="加载方法"><a href="#加载方法" class="headerlink" title="加载方法"></a>加载方法</h2><ol>
<li><p>加载类，获取 <code>Class</code> 对象</p>
<ul>
<li><code>Class c = 类名.class</code> </li>
<li><code>Class.forName(全名)</code>  </li>
<li><code>Class c = 对象.getClass()</code> </li>
<li><code>getName() 全名带包名 getSimpleName() 简名</code></li>
<li><code>getMethod() getConstructor() getField()</code> </li>
</ul>
</li>
<li><p>获取类的构造器 <code>Constructor</code> 对象，主调是 <code>Class 对象</code></p>
<ul>
<li><code>getConstructors</code> 只有 public <strong>返回数组</strong></li>
<li><code>getDeclaredConstructors</code> 存在就能拿到</li>
<li><code>getConstructor(形参的类型对象)</code> 只有public 拿一个</li>
<li><code>getDeclaredConstructor(形参的类型对象)</code> 存在就能拿到 拿1个</li>
</ul>
<ul>
<li>下面的主调是构造器对象</li>
<li><code>getParameterCount</code>几个参数</li>
<li><code>newInstance(...参数)</code> 返回<code>object</code> 强转为对象，如果私有构造器会报错</li>
<li><code>setAccessible(true)</code> 暴力反射，禁止检查访问权限</li>
</ul>
</li>
<li><p>获取类的成员变量 <code>Field</code> 对象</p>
<ul>
<li><code>getFields</code> <code>getDeclaredFields</code> </li>
<li><code>getField(name)</code> <code>getDeclaredField(name)</code></li>
<li>下面主调是<code>Field</code>对象</li>
<li><code>set(对象, 值)</code> <code>get(对象)</code> 赋值 取值</li>
<li><code>setAccessible</code> 暴力反射</li>
</ul>
</li>
<li><p>获取类的成员方法 <code>Method</code> 对象</p>
<ul>
<li><code>getMethods</code> <code>getDeclaredMethods</code></li>
<li><code>getMethod(name, String.class, int.class) </code>返回值</li>
<li>下面主调是<code>method</code></li>
<li><code>getName getParameterConut getReturnType</code></li>
<li><code>invoke(对象, 参数)</code> 返回object 强转为返回值类型</li>
<li><code>setAccesible</code></li>
</ul>
</li>
</ol>
<h2 id="作用、应用场景"><a href="#作用、应用场景" class="headerlink" title="作用、应用场景"></a>作用、应用场景</h2><ul>
<li>得到类的全部成分</li>
<li>破坏封装性</li>
<li>做框架</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920001226903.png" alt="image-20240920001226903"></p>
<p>接收任意对象，接到对象，用反射获取class对象，获取全部成员变量，遍历他们，把他们的属性写出到文件中</p>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>框架的核心技术，一个类有很多方法，需要加载资源，而代理可以代替类执行这些操作。</p>
<p>Spring AOP技术使用了JDK动态代理和CGLIB动态代理两种方式，在不改变原始方法的前提下对功能进行增强。</p>
<h2 id="JDK-动态代理——反射"><a href="#JDK-动态代理——反射" class="headerlink" title="JDK 动态代理——反射"></a>JDK 动态代理——反射</h2><ul>
<li>JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求<strong>代理对象和目标对象实现同样的接口</strong>（兄弟两个拜把子模式），目标对象和代理对象是平等地位的。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920112517946.jpg" alt="image-20240920112517946"></p>
<p>对于一个UserServiceImpl，要生成它的代理对象，为了能创建一个跟UserServiceImpl拥有同名方法的代理Proxy，<mark>这个类必须实现一个接口UserService，并且拥有Impl的全部方法<mark>，然后把Impl传给生成代理的方法。</p>
<p>接口能将原来的实现对象的方 法抽象化（或者部分抽象） 方便代理进行重写，代理重写完具体的执行逻辑，返回的还是这个接口的实现对象，相当于是把原来的实现对象包装了一下，完美地把对象的职责转移到了代理身上，业务对象。减少代码冗余和多余的资源调用</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023232822938.png" alt="image-20241023232822938"></p>
<h2 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h2><p>通过<strong>继承被代理的目标类</strong>（认干爹模式）实现代理，所以不需要目标类实现接口。</p>
<p><strong>CGLIB 通过动态生成一个需要被代理类的子类（即被代理类作为父类），该子类重写被代理类的所有不是 final 修饰的方法，并在子类中采用方法拦截的技术拦截父类所有的方法调用，进而织入横切逻辑，</strong> 目标对象是代理对象的父类。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1_3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">导入CGLIB依赖坐标</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023232711967.png" alt="image-20241023232711967"></p>
<h1 id="Hutool-Usage"><a href="#Hutool-Usage" class="headerlink" title="Hutool Usage"></a>Hutool Usage</h1><h2 id="BeanUtil"><a href="#BeanUtil" class="headerlink" title="BeanUtil"></a>BeanUtil</h2><h3 id="bean和Map转换"><a href="#bean和Map转换" class="headerlink" title="bean和Map转换"></a>bean和Map转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt;BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">                 CopyOptions.create().setFieldValueEditor((fieldName,fieldValue)-&gt;fieldValue.toString()));</span><br><span class="line"></span><br><span class="line">BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(),<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h2 id="JSONUtil"><a href="#JSONUtil" class="headerlink" title="JSONUtil"></a>JSONUtil</h2><h3 id="JSON和对象互转"><a href="#JSON和对象互转" class="headerlink" title="JSON和对象互转"></a>JSON和对象互转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(shop);</span><br><span class="line"></span><br><span class="line">shop = JSONUtil.toBean(jsonStr,Shop.class);</span><br></pre></td></tr></table></figure>

<h3 id="JSON和数组互转"><a href="#JSON和数组互转" class="headerlink" title="JSON和数组互转"></a>JSON和数组互转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonArrayStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(list);</span><br><span class="line"></span><br><span class="line"><span class="type">JSONArray</span> <span class="variable">jsonArray</span> <span class="operator">=</span> JSONUtil.parseArray(jsonArrayStr);</span><br><span class="line">shopTypeList = JSONUtil.toList(jsonArray, ShopType.class);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/30/MySQL%20%E5%9F%BA%E7%A1%80%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/30/MySQL%20%E5%9F%BA%E7%A1%80%E7%AF%87/" class="post-title-link" itemprop="url">MySQL 基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-30 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-30T00:00:00+08:00">2024-09-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 15:09:48" itemprop="dateModified" datetime="2025-04-27T15:09:48+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>DB</strong>: organized data</p>
<p><strong>DBMS</strong>: manage system</p>
<p><strong>RDBMS</strong>: SQLite PostgreSQL MySQL Oracle Microsoft SQL Server (relational)</p>
<p><strong>SQL</strong>: programming language</p>
<p><strong>数据模型</strong>：管理系统：数据库：表：数据</p>
<p><strong>RDBMS</strong>: 表结构格式统一</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920142153024.png" alt="image-20240920142153024"></p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923202742353.png" alt="image-20240923202742353"></p>
<p>auto_increment 从零开始自动增长 (列是数字的类型，并且是UNIQUE约束)</p>
<p> 这一列不指定id，或者id赋值null 不影响自增</p>
<h3 id="非空，唯一，主键，默认，检查约束"><a href="#非空，唯一，主键，默认，检查约束" class="headerlink" title="非空，唯一，主键，默认，检查约束"></a>非空，唯一，主键，默认，检查约束</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923220639875.png" alt="image-20240923220639875"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923220734860.png" alt="image-20240923220734860"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923220750052.png" alt="image-20240923220750052"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923220711866.png" alt="image-20240923220711866"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005154832392.png" alt="image-20241005154832392"></p>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>数据一致性 完整性</p>
<p>外键：连接两个表的数据</p>
<ul>
<li>（<strong>constraint</strong> foreKeyCons）<strong>foreign key</strong>(dept_id) <strong>references</strong> dept(id) 建表时</li>
<li>给当前表中的dept_id列定义了一个 名为 foreKeyCons 的外键约束，外键引用dept表的id列，dept_id就是外键</li>
<li>dept就是主表，必须存在，并且id是主键</li>
<li>因为有外键约束，所以不能直接删除主表的内容，</li>
</ul>
<p>建表以后对外键的操作：添加和删除。外键属于表的属性</p>
<ul>
<li><strong>alter table</strong> emp <strong>drop foreign key</strong> foreKeyCons</li>
<li><strong>alter table</strong> emp <strong>add constraint</strong> foreKeyCons <strong>foreign key</strong>(dept_id) <strong>references</strong> dept(id)</li>
</ul>
<h4 id="外键的删除、更新行为"><a href="#外键的删除、更新行为" class="headerlink" title="外键的删除、更新行为"></a>外键的删除、更新行为</h4><p>on update 更新   on delete 删除</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005155438576.png" alt="image-20241005155438576"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005155543394.png" alt="image-20241005155543394"></p>
<p>NOACTION RESTRICT 默认</p>
<p>CASCADE 主表变了，子表跟着变，主表删了，子表跟着没</p>
<p><strong>ON DELETE</strong> SET NULL 主表删了，子表把对应的值设为null，只支持删除操作，并且要求外键可以为null</p>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923224354382.png" alt="image-20240923224354382"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923224409160.png" alt="image-20240923224409160"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923224759437.png" alt="image-20240923224759437"></p>
<p>1-M 多的一方建立外键，少的一方作为主表，连接起来</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923225452261.png" alt="image-20240923225452261"></p>
<p>M-N 一起连到一张中间表，中间表做从表，建立外键，连到两张表的主键上</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923225514320.png" alt="image-20240923225514320"></p>
<p>一个商品可能属于不同订单，一个订单也可能有不同商品，所以用类似坐标的方式</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>管理DML语句，InnoDB引擎才支持事务</p>
<p>MySQL默认设置事务自动提交，也就是执行完自动COMMIT.</p>
<p>如果要显式开启事务要SET AUTOCOMMIT = 0;（以后的事务都需要手动提交）</p>
<p>或者 START Transaction /  BEGIN （临时开启一条事务）</p>
<p>COMMIT 提交事务 如果没有问题就提交</p>
<p>ROLLBACK 回滚事务 出现异常就要回滚事务到BEGIN处，即更改前</p>
<h3 id="四大特征-acid"><a href="#四大特征-acid" class="headerlink" title="四大特征 acid"></a>四大特征 acid</h3><p>一致性依赖于应用层，开发者。</p>
<p><strong>A</strong>tomic <strong>C</strong>onsistency <strong>I</strong>solation <strong>D</strong>urability</p>
<p>最小操作单位，不可分割；</p>
<p>完成时必须让所有数据都前后一致，由开发者指定，比如转账，金钱总额不能变化；</p>
<p>多个事务是互相隔离的，排除其他事务对本事务的影响（解决并发问题）；</p>
<p>事务对数据库的修改是持久的；</p>
<p>一什么是隔离性？</p>
<p>隔离性是数据库事务的四个基本属性之一，即 <strong>ACID</strong> 特性中的 “I”（Isolation）。隔离性保证了一个事务在未完成之前，它的操作对其他事务是不可见的，或者说部分可见（取决于隔离级别）。这样可以防止因并发执行而导致的数据问题。</p>
<h3 id="高并发下可能遇到的问题："><a href="#高并发下可能遇到的问题：" class="headerlink" title="高并发下可能遇到的问题："></a>高并发下可能遇到的问题：</h3><ol>
<li><p><strong>脏读</strong>（Dirty Read）：一个事务读取了另一个事务<strong>开始了但未提交</strong>的数据。如果另一个事务回滚或者提交，这些数据将无效，导致第一个事务读取了错误数据。</p>
<ol>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005213034469.png" alt="image-20241005213034469"></li>
</ol>
</li>
<li><p><strong>不可重复读</strong>（Non-repeatable Read）：在同一个事务中，前后两次读取相同的数据时，数据值发生了变化，因为另一个事务在两次读取之间<strong>修改并提交了该数据</strong>。</p>
<ol>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005213018573.png" alt="image-20241005213018573"></li>
</ol>
</li>
<li><p><strong>幻读</strong>（Phantom Read）：一个事务内，连续两次执行相同的查询（select）时，再次进行查询的时候真实的数据集已经发生了变化，但是A却查询不出来这种变化，因此产生了幻读。</p>
<ol>
<li>如果已经解决了12，将会发现：第一次查询没有结果，随后另一个事务插入数据并进行了提交，试图插入数据，会报错，提示不能有重复的主键，但是在第二次查询仍然没有结果，读不到别人已经提交的数据（repeatable read）但是别人提交的数据还在影响。</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005214729161.png" alt="image-20241005214729161"></li>
</ol>
</li>
</ol>
<h3 id="通过隔离性解决高并发问题："><a href="#通过隔离性解决高并发问题：" class="headerlink" title="通过隔离性解决高并发问题："></a>通过隔离性解决高并发问题：</h3><p>数据库系统通常提供多种<strong>事务隔离级别</strong>，每个级别可以解决一部分或全部并发问题。这些隔离级别定义了事务之间可见性规则，数据库可以根据应用场景选择适当的隔离级别来权衡性能与数据一致性。</p>
<p><code>select @@transaction_isolation</code> 查看当前的隔离级别</p>
<p><code>set session transaction isolation level read uncommitted</code>设置当前会话的隔离级别，</p>
<h3 id="SQL-标准定义的四种隔离级别"><a href="#SQL-标准定义的四种隔离级别" class="headerlink" title="SQL 标准定义的四种隔离级别"></a>SQL 标准定义的四种隔离级别</h3><ol>
<li><strong>读未提交（Read Uncommitted）</strong>：<ul>
<li><strong>脏读</strong>、<strong>不可重复读</strong> 和 <strong>幻读</strong> 都可能发生。</li>
<li>最低的隔离级别，事务可以读取未提交的数据。</li>
<li>使用场景：极高并发要求且对数据一致性要求不高的场景。</li>
</ul>
</li>
<li><strong>读已提交（Read Committed）</strong>：Oracle 默认<ul>
<li>解决脏读问题，但仍然可能出现不可重复读和幻读。</li>
<li>一个事务只能读取已提交的数据，保证不会读取到未提交的修改。</li>
<li>使用场景：大多数数据库系统的默认隔离级别，较好的性能和数据一致性的平衡。</li>
</ul>
</li>
<li><strong>可重复读（Repeatable Read）</strong>：MySQL 默认<ul>
<li>解决脏读和不可重复读问题，但幻读仍然可能发生。</li>
<li>在同一事务中，事务两次读取相同的数据，保证两次读取的结果一定相同。不会读取其他事务已经提交的数据，但是仍然无法避免其他事务的影响（比如重复插入相同主键失败但是查不到这条主键的数据）</li>
<li>使用场景：需要保证数据一致性、避免更新数据不一致的场景。</li>
<li>普通的select快照读不会受到其他事务update、insert的影响，但是自己执行update时会进行当前读，会把其他事务update、insert的数据更新成自己的版本号，下一次读取就会读到了。</li>
<li>幻读：尽管B事务在A事务还未结束的时候，增加了表中的数据，但是为了维护可重复读，A事务中不管怎么查询，是查询不到新增的数据的。但是对于真实的表而言，表中的数据是的的确确增加了，所以插入重复的主键会报错。</li>
</ul>
</li>
<li><strong>串行化（Serializable）</strong>：<ul>
<li>解决脏读、不可重复读和幻读问题。</li>
<li>最高的隔离级别，所有事务串行执行，完全避免并发导致的数据问题。要等先开始的事务执行完提交或者回滚，后开始的事务才能开始执行，完全放弃并发性。</li>
<li>使用场景：极端数据一致性要求的场景，但代价是性能较低，容易出现锁等待甚至死锁。</li>
</ul>
</li>
</ol>
<h3 id="隔离性和并发控制的关系"><a href="#隔离性和并发控制的关系" class="headerlink" title="隔离性和并发控制的关系"></a>隔离性和并发控制的关系</h3><ul>
<li><strong>锁机制</strong>：隔离性通常通过锁机制（例如行锁、表锁）实现。在高隔离级别下（如可串行化），数据库会使用更严格的锁定策略，确保其他事务在未提交前不能读取或修改被锁定的数据。</li>
<li>**多版本并发控制 (MVCC)**：有些数据库（如 PostgreSQL、MySQL 的 InnoDB 存储引擎）采用了多版本并发控制，允许在较高隔离级别下提高性能。MVCC 通过保存数据的多个版本，允许读取操作无需阻塞写入操作，从而在高并发下仍然能够提供一致的数据读取。</li>
</ul>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="通用语法"><a href="#通用语法" class="headerlink" title="通用语法"></a>通用语法</h3><ul>
<li>可以多行书写，分号结尾</li>
<li>可用空格和缩进增强可读性</li>
<li>MySQL的SQL语句不区分大小写，关键字建议大写</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>DDL definition 定义数据库对象(表、db，字段)</p>
<p>DML manipulation 操作数据，增删改</p>
<p>DQL query 查询</p>
<p>DCL control 创建用户，控制访问权限</p>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>control 控制数据库访问权限和管理数据库用户</p>
<h4 id="DCL-用户管理"><a href="#DCL-用户管理" class="headerlink" title="DCL-用户管理"></a>DCL-用户管理</h4><p>use mysql;</p>
<p>select * from user;</p>
<ul>
<li><p>创建用户 <strong>create user</strong> ‘itcast‘<strong>@</strong>‘localhost’ <strong>identified by</strong> ‘123456’ 密码123456用户名itcast 主机localhost</p>
</li>
<li><p>创建用户 <strong>create user</strong> ‘heima‘<strong>@</strong>‘%’ <strong>identified by</strong> ‘123456’ 密码123456用户名heima  任意主机均可访问</p>
</li>
<li><p>改密码 alter user ‘heima‘<strong>@</strong>‘%’ <strong>identified with</strong> mysql_native_password by ‘1234’ 改成1234</p>
</li>
<li><p>drop user ‘heima‘<strong>@</strong>‘%’  删除用户</p>
</li>
</ul>
<h4 id="DCL-控制权限"><a href="#DCL-控制权限" class="headerlink" title="DCL - 控制权限"></a>DCL - 控制权限</h4><ul>
<li>查询有什么权限：SHOW GRANTS FOR 用户@主机</li>
<li>授予用户权限：grant all on 数据库名.表名 to 用户@主机</li>
<li>撤销用户权限：revoke all on 数据库名.表名 from 用户@主机</li>
</ul>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><h4 id="数据库操作-database"><a href="#数据库操作-database" class="headerlink" title="数据库操作-database"></a>数据库操作-database</h4><ul>
<li><code>SHOW DATABASES;</code> 查询所有数据库（展示）</li>
<li><code>SELECT DATABASE();</code> 查询当前数据库（展示）</li>
<li><code>CREATE DATABASE if not exists name;</code>如果不存在则创建一个名为 name 的数据库，后面可以加<code>default charset + 字符集</code> <code>COLLATE 排序规则</code></li>
<li><code>DROP DATABASE IF EXISTS;</code> 如果存在则删除</li>
<li><code>USE name;</code> 使用名为name的数据库</li>
</ul>
<h4 id="表操作-查询-table"><a href="#表操作-查询-table" class="headerlink" title="表操作-查询 table"></a>表操作-查询 table</h4><ul>
<li><code>SHOW TABLES; </code> </li>
<li><code>DESC 表名;</code> 查询表结构</li>
<li><code>SHOW CREATE TABLE 表名;</code> 查询建表时候的信息</li>
</ul>
<h4 id="表操作-创建-table"><a href="#表操作-创建-table" class="headerlink" title="表操作-创建 table"></a>表操作-创建 table</h4><ul>
<li><p>```sql<br>use itcast;<br>create table tb_user(</p>
<pre><code>id int comment &#39;编号&#39;,
name varchar(50) comment &#39;姓名&#39;,
age int comment &#39;年龄&#39;,
gender varchar(1) comment &#39;性别&#39;
) comment &#39;用户表&#39;;
</code></pre>
<p>desc tb_user;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 表操作- 数据类型</span><br><span class="line"></span><br><span class="line">##### 数值类型：</span><br><span class="line"></span><br><span class="line">TINYINT-byte   SMALLINT-short MEDIUMINT-3 bytes INT/INTEGER-int </span><br><span class="line"></span><br><span class="line">BIGINT-long  FLOAT DOUBLE DECIMAL </span><br><span class="line"></span><br><span class="line">TINYINT UNSIGNED(0-255) 无符号的tinyint</span><br><span class="line"></span><br><span class="line">DOUBLE(4,1)4代表总位数 1代表小数部分的位数 </span><br><span class="line"></span><br><span class="line">##### 字符串类型：</span><br><span class="line"></span><br><span class="line">![image-20240920183842122](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920183842122.png)</span><br><span class="line"></span><br><span class="line">|          | char(10)     | varchar(10) |</span><br><span class="line">| -------- | ------------ | ----------- |</span><br><span class="line">| 最小长度 | 10           | 0           |</span><br><span class="line">| 最大长度 | 10           | 10          |</span><br><span class="line">| eg       | 性别、手机号 | 用户名      |</span><br><span class="line"></span><br><span class="line">##### 日期类型</span><br><span class="line"></span><br><span class="line">![image-20240920184425055](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920184425055.png)</span><br><span class="line"></span><br><span class="line">![image-20240926153912988](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926153912988.png)</span><br><span class="line"></span><br><span class="line">![image-20240926153925471](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926153925471.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 表操作-修改表属性</span><br><span class="line"></span><br><span class="line">**alter table** employee **add** nickname varchar(20) [comment] [约束]; **添加属性**</span><br><span class="line"></span><br><span class="line">**alter table** employee **modify** nickname char(20); **修改数据类型**</span><br><span class="line"></span><br><span class="line">**alter table** employee **change** nickname idCard char(18) [comment] [约束]; **改名字+数据类型** </span><br><span class="line"></span><br><span class="line">**alter table** employee **drop** nickname; **删除** </span><br><span class="line"></span><br><span class="line">**alter table** employee **rename to** emp; **改表名**  </span><br><span class="line"></span><br><span class="line">#### 表操作-删除</span><br><span class="line"></span><br><span class="line">**drop table** [if exists] 表名;   **删除整个表**</span><br><span class="line"></span><br><span class="line">**truncate table** 表名; **删除数据不删表结构**</span><br><span class="line"></span><br><span class="line">#### MySQL GUI</span><br><span class="line"></span><br><span class="line">SQLyog Navicat DataGrip</span><br><span class="line"></span><br><span class="line">### DML</span><br><span class="line"></span><br><span class="line">INSERT UPDATE DELETE </span><br><span class="line"></span><br><span class="line">#### 添加数据</span><br><span class="line"></span><br><span class="line">**insert into** 表名(属性1，属性2....) **values**（v1,v2...）指定属性</span><br><span class="line"></span><br><span class="line">**insert into** 表名 **values**（v1,v2...）所有</span><br><span class="line"></span><br><span class="line">字段和值一一对应，字符串和日期在单引号中</span><br><span class="line"></span><br><span class="line">**多条数据**: **values**</span><br><span class="line"></span><br><span class="line">​		（v1,v2...）,</span><br><span class="line"></span><br><span class="line">​		(v1,v2....) 不同条数据用逗号隔开</span><br><span class="line"></span><br><span class="line">#### 修改数据</span><br><span class="line"></span><br><span class="line">**update** employee **set** name = &#x27;itheima&#x27; **where** id=1;</span><br><span class="line"></span><br><span class="line">#### 删除数据</span><br><span class="line"></span><br><span class="line">**delete from** 表名 [where 条件] 无条件会删除整张表格的数据</span><br><span class="line"></span><br><span class="line">### DQL</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line"></span><br><span class="line">#### 基本查询</span><br><span class="line"></span><br><span class="line">##### 查询多个字段 </span><br><span class="line"></span><br><span class="line">**select** 字段1，字段2........ **from** 表名</span><br><span class="line"></span><br><span class="line">**select * from** 表名       通配符</span><br><span class="line"></span><br><span class="line">##### 设置别名</span><br><span class="line"></span><br><span class="line">**select** 字段1[**as** 别名1]，字段2[**as** 别名2].... **from** 表名 as可省略</span><br><span class="line"></span><br><span class="line">##### 去重</span><br><span class="line"></span><br><span class="line"> **select distinct** ........</span><br><span class="line"></span><br><span class="line">#### 条件查询 WHERE</span><br><span class="line"></span><br><span class="line">![image-20240920211218098](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920211218098.png)</span><br><span class="line"></span><br><span class="line">**select * from** employ where age **in**(12,45,43);</span><br><span class="line"></span><br><span class="line">**select * from** employ where name **like &#x27;__&#x27;**; 名字是两个字符  模糊查询 模糊匹配</span><br><span class="line"></span><br><span class="line">##### sql 模糊查询</span><br><span class="line"></span><br><span class="line">通配符：</span><br><span class="line"></span><br><span class="line">- %: %网% 查询含有网字的数据</span><br><span class="line"></span><br><span class="line">  ​     %网    查询以网字结尾的数据</span><br><span class="line"></span><br><span class="line">  ​      %网%车    查询含有 网 和 车的数据 有先后顺序</span><br><span class="line"></span><br><span class="line">- _ :   网_ 网开头 长度为2个字</span><br><span class="line"></span><br><span class="line">  ​	_ _ 网 长度为3个字 最后一个字是网</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">between and </span><br><span class="line"></span><br><span class="line">in </span><br><span class="line"></span><br><span class="line">is null </span><br><span class="line"></span><br><span class="line">#### 聚合函数 </span><br><span class="line"></span><br><span class="line">![image-20240920212134476](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920212134476.png)</span><br><span class="line"></span><br><span class="line">count(*)所有行 count(age)age非空的行数</span><br><span class="line"></span><br><span class="line">作用在列数据，**null不参与运算~**</span><br><span class="line"></span><br><span class="line">select count(age) from emp where workAddress = &#x27;西安&#x27;; </span><br><span class="line"></span><br><span class="line">位于select关键字之后 可以加where条件</span><br><span class="line"></span><br><span class="line">#### 分组查询 GROUP BY &amp; HAVING</span><br><span class="line"></span><br><span class="line">group by xxx 将具有相同xxx值的行归为一组，每一组执行聚合count  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**select** gender, count(*) **from** emp **&lt;u&gt;group by&lt;/u&gt;** gender;  计算行的数量，并按照gender分组</span><br><span class="line"></span><br><span class="line">- where 分组之前过滤 </span><br><span class="line">- **having** 对分组之后的结果进行过滤</span><br><span class="line">- where 不能对聚合函数判断， having可以，要判断聚合函数就要分完组</span><br><span class="line">- 执行顺序：where&gt;聚合函数&gt;having</span><br><span class="line">- 先用where筛选个体，然后分组，再对组内执行聚合函数，执行的结果可以再用having筛选</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 排序查询 ORDER BY</span><br><span class="line"></span><br><span class="line">ASC:ascending 默认</span><br><span class="line"></span><br><span class="line">DESC:descending</span><br><span class="line"></span><br><span class="line">- 语句的最后，添加 **order by** age **asc**;</span><br><span class="line">- **order by** age **desc** , entryDate; 先按照age降序，如果age相同在按照entryDate升序</span><br><span class="line"></span><br><span class="line">#### 分页查询 LIMIT</span><br><span class="line"></span><br><span class="line">查询xx页码</span><br><span class="line"></span><br><span class="line">LIMIT 起始索引，查询记录数</span><br><span class="line"></span><br><span class="line">每页是20条，第一页的起始数据是0，第二页的20</span><br><span class="line"></span><br><span class="line">limit 0,5 第一页，一页5条记录</span><br><span class="line"></span><br><span class="line">**limit** 5 **offset** 0 第一页 limit 5 offset 20 第五页</span><br><span class="line"></span><br><span class="line">#### 执行顺序</span><br><span class="line"></span><br><span class="line">先执行from 再用where过滤，然后用group by和having指定分组以及过滤，然后执行字段的select，接着是排序，最后分页</span><br><span class="line"></span><br><span class="line">在字段名，表名后加别名，看是否报错，验证上述顺序</span><br><span class="line"></span><br><span class="line">### [多表查询](C:\Users\Lenovo\OneDrive\本学期\数据库原理\多表查询练习.md)</span><br><span class="line"></span><br><span class="line">#### 表关系</span><br><span class="line"></span><br><span class="line">多对多：同一个学生可以选择多门课程，同一个课程也可以被多名学生选择，如果要描述他们之间的关系，添加一张中间表，里面的外键分别对应两张表的主键。</span><br><span class="line"></span><br><span class="line">一对多：多的一方建立外键，关联到少的主键。</span><br><span class="line"></span><br><span class="line">一对一：任意一方建立外键（UNIQUE），关联到另外的主键。</span><br><span class="line"></span><br><span class="line">![image-20241005161911780](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005161911780.png)</span><br><span class="line"></span><br><span class="line">#### 链接查询 JOIN</span><br><span class="line"></span><br><span class="line">##### 消除笛卡尔积</span><br><span class="line"></span><br><span class="line">![image-20241005162327168](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005162327168.png)</span><br><span class="line"></span><br><span class="line">##### 内连接</span><br><span class="line"></span><br><span class="line">只查询A和B相交的部分</span><br><span class="line"></span><br><span class="line">**select** *e*.name,*e*.gender,*d*.dname **from** *emp e*,*dept d* ... **where**    条件 (隐式) </span><br><span class="line"></span><br><span class="line">**select** * **from** *emp* **join** *dept* on     条件（显式）</span><br><span class="line"></span><br><span class="line">##### 外连接</span><br><span class="line"></span><br><span class="line">![image-20241005163112728](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005163112728.png)</span><br><span class="line"></span><br><span class="line">e.* emp的全部数据 </span><br><span class="line"></span><br><span class="line">from *A* left join B 查询*A* ∪ (A∩B)</span><br><span class="line"></span><br><span class="line">from *A* right join B 查询*B* ∪ (A∩B)</span><br><span class="line"></span><br><span class="line">##### 自链接</span><br><span class="line"></span><br><span class="line">一定要起别名</span><br><span class="line"></span><br><span class="line">![image-20241005163553452](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005163553452.png)</span><br><span class="line"></span><br><span class="line">没有必要专门搞一张领导表出来，如果要实现需求就要把一张表分成两张看，a的经理id等于b的id</span><br><span class="line"></span><br><span class="line">![image-20241005163805094](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005163805094.png)</span><br><span class="line"></span><br><span class="line">##### 外键？连接查询？</span><br><span class="line"></span><br><span class="line">在多表查询中，**连接查询**（JOIN）并不强制要求外键的存在。外键的作用是维护表之间的**参照完整性**，确保一张表中的某些值对应另一张表中的有效值。但在进行连接查询时，只要有可以用于关联两个表的字段（如主键和某个相应的列），就可以进行查询，而不需要一定设置外键。</span><br><span class="line"></span><br><span class="line">#### 联合查询</span><br><span class="line"></span><br><span class="line">把两条单表查询结果联合起来，字段数量必须一致</span><br><span class="line"></span><br><span class="line">UNION：自动根据主键去重</span><br><span class="line"></span><br><span class="line">UNION ALL: 不去重</span><br><span class="line"></span><br><span class="line">#### 子查询 按返回值分类</span><br><span class="line"></span><br><span class="line">##### **单行单列**：只返回一个**值** </span><br><span class="line"></span><br><span class="line">- ![image-20241005165024271](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005165024271.png)</span><br><span class="line"></span><br><span class="line">##### **单行多列**：返回的是一行数据</span><br><span class="line"></span><br><span class="line">- ![image-20241005S171121759](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005171121759.png)![image-20241005171132602](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005171132602.png)</span><br><span class="line"></span><br><span class="line">- 第一步返回的是**一行两列**的数据（salary，managerid），第二步的条件可以用where (salary, managerid) = 第一行的结果</span><br><span class="line"></span><br><span class="line">- &lt;a href=&quot;#extension&quot;&gt;多行多列扩展&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### **多行单列**：子查询返回的是多行单列的数据</span><br><span class="line"></span><br><span class="line">也就是同一个字段的值的集合，用括号括起来，最后查询可以如下操作符（操作对象是同一字段的值的集合）</span><br><span class="line"></span><br><span class="line">- in **等于**集合内部的某一个值</span><br><span class="line"></span><br><span class="line">- any/some **大于** any 只需大于最小值 小于any只需小于最大值**相当于存在量词∃** </span><br><span class="line">- all **相当于全称量词∀**</span><br><span class="line"></span><br><span class="line">- ![image-20241005165513314](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005165513314.png)</span><br><span class="line">- ![image-20241005165204726](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005165204726.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### **多行多列**： 虚拟表</span><br><span class="line"></span><br><span class="line">子查询返回的是多行多列数据，也就是虚拟表，从这张虚拟表中再和其他表进行连接查询。</span><br><span class="line"></span><br><span class="line">- **虚拟表**: 查询入职日期 在2011-11-11之后的员工信息和部门信息：先查入职在2011-11-11之后的员工信息，根据这些信息（虚拟表,也叫临时表）和部门表 连接查询</span><br><span class="line"></span><br><span class="line">  - ```sql</span><br><span class="line">    SELECT * FROM (select * from emp where join_date&gt;&#x27;2011-11-11&#x27;)e JOIN dept on e.dep_id = dept.id</span><br></pre></td></tr></table></figure></li>
<li><p><span id="extension"><strong>也可以作为单行多列的扩展</strong></span> in 关键字</p>
<ul>
<li>查询第一步返回的是<strong>多行多列</strong>的数据（salary，managerid），第二步的条件可以用where (salary, managerid) in 第一行的结果</li>
</ul>
</li>
</ul>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>可以直接被另一段程序调用的程序或代码——-常见MySQL内置函数</p>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>concat substring TRIM upper </p>
<p>LPAD(STR, 6, ‘0’) 左对齐，6位补0</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005154345722.png" alt="image-20241005154345722"></p>
<h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><p>ceil floor round rand（0-1随机数）mod</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005154156390.png" alt="image-20241005154156390"></p>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>date_add now curdate curtime datediff</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005154146380.png" alt="image-20241005154146380"></p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005153559225.png" alt="image-20241005153559225"></p>
<p><code>if(expr, caseTrue, caseFalse) expr = true</code> 返回caseTrue</p>
<p><code>ifnull(v1,v2)</code> v1=null 返回v2 空字符串不是null，null必须是什么都没有，v1不为null，则返回v1</p>
<p>case when</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005153230584.png" alt="image-20241005153230584"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005153515232.png" alt="image-20241005153515232"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default/">1</a><span class="page-number current">2</span><a class="page-number" href="/default/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/default/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">碎梦</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/scatteredream" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
