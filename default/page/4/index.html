<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Arvo:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scatteredream.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="scatteredream&#39;s blog">
<meta property="og:url" content="http://scatteredream.github.io/default/page/4/index.html">
<meta property="og:site_name" content="scatteredream&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="碎梦">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://scatteredream.github.io/default/page/4/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default/page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>scatteredream's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">scatteredream's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">碎梦</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">168</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/01/Starter%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/01/Starter%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">自定义 starter</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-01T00:00:00+08:00">2024-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 13:06:00" itemprop="dateModified" datetime="2025-04-27T13:06:00+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><mark>在 Spring Boot 生态中，“Starter” 本质上就是一组依赖的“捆绑包”，它的目标是让使用方 <strong>一行依赖</strong> 就把启动一个完整的 Spring Boot 应用所需的所有东西都拉过来。</mark> </p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/10/01/Starter%E7%9A%84%E5%AE%9E%E7%8E%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/10/01/se-java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/01/se-java/" class="post-title-link" itemprop="url">Java SE</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-01T00:00:00+08:00">2024-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 16:11:17" itemprop="dateModified" datetime="2025-04-27T16:11:17+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="面向对象、基本语法"><a href="#面向对象、基本语法" class="headerlink" title="面向对象、基本语法"></a>面向对象、基本语法</h1><p>一个java文件内只能有1个public class 且public class名字需与文件名相同</p>
<p>生成类文件的名字=class名，几个类几个名字</p>
<p>运行的时候是按照类运行的，因此一个java文件里不同的类可以有不同的main</p>
<h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><p>在刷算法题时，Java 的常用包可以帮助你解决各种问题。以下是一些常见的包：</p>
<ol>
<li><p><strong>基础包</strong>（默认无需导入，属于 <code>java.lang</code>，直接使用）：</p>
<ul>
<li><code>java.lang</code>：包含基础类如 <code>String</code>, <code>Math</code>, <code>Integer</code>, <code>System</code>，它们是自动导入的，不需要显式导入。</li>
</ul>
</li>
<li><p><strong>集合框架</strong>：</p>
<ul>
<li><code>java.util.*</code>：包括大多数数据结构和集合类，常用于算法题：<ul>
<li><code>ArrayList</code>, <code>LinkedList</code>：动态数组和链表。</li>
<li><code>HashMap</code>, <code>TreeMap</code>, <code>LinkedHashMap</code>：哈希表和有序映射。</li>
<li><code>HashSet</code>, <code>TreeSet</code>：哈希集合和有序集合。</li>
<li><code>PriorityQueue</code>：优先队列（常用于堆排序、最小堆、最大堆）。</li>
<li><code>Stack</code>：栈结构。</li>
<li><code>Deque</code>, <code>ArrayDeque</code>：双端队列。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>并发包</strong>：</p>
<ul>
<li><code>java.util.concurrent.*</code>：多线程工具和并发数据结构。</li>
</ul>
</li>
<li><p><strong>数学计算</strong>：</p>
<ul>
<li><code>java.math.BigInteger</code> 和 <code>java.math.BigDecimal</code>：用于处理大整数和高精度小数。</li>
<li><code>java.util.Random</code>：生成随机数。</li>
</ul>
</li>
<li><p><strong>输入输出</strong>（用于处理大规模输入输出）：</p>
<ul>
<li><code>java.io.*</code>：包括 <code>BufferedReader</code>、<code>InputStreamReader</code> 等，常用于高效输入读取。</li>
<li><code>java.util.Scanner</code>：常用于简单的控制台输入。</li>
</ul>
</li>
<li><p><strong>时间处理</strong>：</p>
<ul>
<li><code>java.time.*</code>：处理日期和时间类（如果题目涉及日期计算）。</li>
</ul>
</li>
</ol>
<h3 id="常用导入："><a href="#常用导入：" class="headerlink" title="常用导入："></a>常用导入：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">// 通用集合框架</span></span><br><span class="line"><span class="keyword">import</span> java.math.*;  <span class="comment">// 高精度数学计算</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;    <span class="comment">// 文件、输入输出</span></span><br></pre></td></tr></table></figure>

<p>这些包涵盖了绝大多数算法题目需要的工具和数据结构。如果你有特定类型的题目或需求，也可以进一步讨论合适的导入包。</p>
<h2 id="基本数据类型-2024-9-9"><a href="#基本数据类型-2024-9-9" class="headerlink" title="基本数据类型 2024.9.9"></a>基本数据类型 2024.9.9</h2><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><p>char <strong>2</strong> byte</p>
<p>路径 \\ 转义字符</p>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>0x hex 、 0 oct    byte short int long </p>
<p>整数全部是int型，数字超出int范围后面要加L <code>long number = 666666666666L  </code></p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>4e3 ⇔ 4000 这是一个浮点数 默认为double </p>
<p>float 32  double 64 </p>
<p>浮点数全部是double型，数字如果是float型后边必须要加上f</p>
<p>double类型不能给float类型赋值。 char 型可以兼容整型，也可以看成16位整型</p>
<table>
<thead>
<tr>
<th align="left"><strong>数据类型</strong></th>
<th align="left"><strong>默认值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">0L</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">0.0f</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">0.0d</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">‘\u0000’</td>
</tr>
<tr>
<td align="left">String (or any object)</td>
<td align="left">null</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">false</td>
</tr>
</tbody></table>
<h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><ul>
<li><p>隐式(自动) 基本数据类型中除了boolean其他都兼容</p>
<ul>
<li>byte, short, char -&gt;int-&gt;long-&gt;float-&gt;double</li>
<li>byte+short 在表达式中参与运算自动提升为int 小类型自动转换成大类型</li>
<li></li>
</ul>
</li>
<li><p>强制转换</p>
<ul>
<li><p>小数转换成整数，保留整数部分 <code>double a = 1.2 </code> <code>int b = (int) a</code>  </p>
</li>
<li><p>四舍五入</p>
</li>
</ul>
</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> Math.PI;</span><br><span class="line">pi = pi * <span class="number">10000</span> + <span class="number">0.5</span>;</span><br><span class="line">pi = (<span class="type">int</span>)pi;</span><br><span class="line">pi = pi / <span class="number">10000</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">pi_2</span> <span class="operator">=</span> Math.PI;</span><br><span class="line"><span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> Math.round(pi_2 * <span class="number">10000</span>);</span><br><span class="line">pi_2 = i / <span class="number">10000.0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li>比较运算符 H <strong>instanceof</strong> Human H是否属于Human类型</li>
</ul>
<ul>
<li><p><strong>位运算符</strong> （整数） &gt;&gt;&gt; </p>
</li>
<li><p><strong>自增自减</strong>  i++ 的值等于i      ++i的值等于i+1</p>
</li>
<li><p><strong>取模</strong> 值只跟被模数有关 </p>
</li>
<li><p><strong>扩展赋值运算符</strong>：包含强制类型转换</p>
</li>
<li><p><strong>逻辑运算符</strong> </p>
<ul>
<li><p>&amp;&amp; 第一个false 不会判断 优先级较高</p>
</li>
<li><p>||  第一个true不会判断剩下的</p>
</li>
<li><p>^ 异或 相同false 不同true</p>
</li>
</ul>
</li>
</ul>
<h2 id="API-from-JDK"><a href="#API-from-JDK" class="headerlink" title="API from JDK"></a>API from JDK</h2><h3 id="Switch语句简化"><a href="#Switch语句简化" class="headerlink" title="Switch语句简化"></a>Switch语句简化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">dayName</span> <span class="operator">=</span> <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> -&gt; <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> -&gt; <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span> -&gt; <span class="string">&quot;Wednesday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span> -&gt; <span class="string">&quot;Thursday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span> -&gt; <span class="string">&quot;Friday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span> -&gt; <span class="string">&quot;Saturday&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span> -&gt; <span class="string">&quot;Sunday&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid day: &quot;</span> + day);</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(dayName); <span class="comment">// 输出: Wednesday</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JDK12开始引入的写法，可以避免贯穿效应，并能直接在后面执行一个语句或者返回一个值</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;asd&quot;</span> <span class="comment">//常量池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(字符数组、字节数组)<span class="comment">//一般的堆</span></span><br></pre></td></tr></table></figure>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><code>str.toCharArray()</code>  返回一个字符数组</p>
<p><code>str.charAt(2)</code>   返回str[2]的字符</p>
<p><code>str1.equals(str2)</code> s1与s2是否相同</p>
<p><code>str1.equalsIgnoreCase(str2)</code> s1与s2是否相同 <strong>忽略大小写</strong> </p>
<p><code>str.substring(0,8)</code> 字符串截断</p>
<p><code>str.replace(x,y)</code> 将x替换成y</p>
<p><code>str.contains(&quot;Java&quot;)</code> 是否包含Java</p>
<p><code>str.startsWith(&quot;A&quot;)</code> 是否以A开头</p>
<p><code>str.split(&#39;,&#39;)</code> Split with PERIOD ‘,’</p>
<p><code>int compareToIgnoreCase(String str)</code> 按照字典顺序比较两个字符串，忽略大小写</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><p>用str = “aaa” 的方式，会把字符串存在<strong>字符常量池</strong>，内容相同只存储一份</p>
</li>
<li><p>用str = new String(“aaa”)的方式，每一次都new一个新对象存在堆中</p>
</li>
<li><p><strong>String是不可变对象</strong>，不可变性（Immutability）的含义 </p>
</li>
<li><p>只要对String进行操作，就要<u>创建新的字符串对象</u>，而非修改原有字符串。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">str = str + <span class="string">&quot; World&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>str + &quot; World&quot;</code> 实际上创建了一个新的 <code>String</code> 对象，包含 “Hello World”，而原来的 <code>&quot;Hello&quot;</code> 对象仍然存在于内存中，并没有被修改。<code>str</code> 变量此时指向了这个新的对象。为什么 <code>String</code> 是不可变的？</p>
<ol>
<li><p><strong>安全性（Security）</strong>：不可变的对象可以避免在多个线程之间共享数据时的并发问题。由于 <code>String</code> 的值不会被改变，因此可以安全地在多个地方或多个线程中使用，而不必担心被其他代码修改。</p>
</li>
<li><p><strong>性能优化（String Pool）</strong>：Java 中有一个叫做 <strong>字符串常量池（String Pool）</strong> 的机制，当你创建一个 <code>String</code> 对象时，如果该字符串值已经存在于常量池中，那么不会重新创建对象，而是复用已有的对象。不可变性确保了这个机制的有效性，因为相同的 <code>String</code> 实例永远不会被修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>s1</code> 和 <code>s2</code> 实际上引用了常量池中的同一个 <code>String</code> 对象。</p>
<p><strong>3.  哈希值缓存</strong>：由于 <code>String</code> 对象不可变，它的哈希值只需要计算一次，可以缓存下来以提高哈希表操作的效率（如在 <code>HashMap</code> 中用作键）。如果 <code>String</code> 是可变的，那么它的哈希值也会随之变化，影响哈希表的正确性。 </p>
</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240910180312621.png" alt="image-20240910180312621"></p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>大小可变的 <strong>容器</strong>，auto extension </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240910193135775.png" alt="image-20240910193135775"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>add 方法可重载 <code>add(Object o);</code> </p>
<p>注意 remove 方法会让整体左移，元素对应的索引会变化，会影响遍历的索引</p>
<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>)  <span class="comment">//0-9</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>,<span class="number">31</span>)  <span class="comment">// [10,31) 不包含31</span></span><br></pre></td></tr></table></figure>

<h3 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> sc.nextInt();</span><br></pre></td></tr></table></figure>

<h2 id="数组-2024-9-10"><a href="#数组-2024-9-10" class="headerlink" title="数组 2024.9.10"></a>数组 2024.9.10</h2><h3 id="静态数组"><a href="#静态数组" class="headerlink" title="静态数组"></a>静态数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] data1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] data2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">//简化写法</span></span><br></pre></td></tr></table></figure>

<p>引用数据类型 引用相当于是对象的地址</p>
<h3 id="动态数组（非动态长度）"><a href="#动态数组（非动态长度）" class="headerlink" title="动态数组（非动态长度）"></a>动态数组（非动态长度）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] data1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p><code>double 0.0</code> <code>int 0 </code> <code>boolean false </code> <code>String null</code> (<u>引用数据类型</u>) </p>
<p>new一个对象，就会在堆上创建空间，然后将空间的地址传给栈中的引用</p>
<h3 id="引用数据类型做参数"><a href="#引用数据类型做参数" class="headerlink" title="引用数据类型做参数"></a>引用数据类型做参数</h3><p>引用相当于封装好的指针，只能指向对象，可以通过它对<strong>对象</strong>进行操作，引用数据类型做参数，实际上是一个引用的拷贝，通过它可以操作对象，但是不能通过修改它来让真实的引用指向一个新的对象。修改对象就行了，没事修改人家引用干啥呢！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Personnel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modifyPerson</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        person = <span class="keyword">new</span> <span class="title class_">Person</span>();  <span class="comment">// 修改引用，指向新的对象  不可以</span></span><br><span class="line">        person.name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.name = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        modifyPerson(p);</span><br><span class="line">        System.out.println(p);  <span class="comment">// 仍然输出 &quot;Bob&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java的参数都是值传递，也就是副本传递。main 中 p的值始终不变， 进入modify方法之后，一开始person也是p的值，但是无法通过更改person的指向 来 更改p的指向</p>
<h3 id="方法的重载："><a href="#方法的重载：" class="headerlink" title="方法的重载："></a><strong>方法的重载</strong>：</h3><p>必须要有不同的<strong>参数列表</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">function</span><span class="params">(String... args)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">function</span><span class="params">(String [] args)</span>;</span><br></pre></td></tr></table></figure>

<p>这两种方法是等价的</p>
<h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><ul>
<li><p>类名大写</p>
</li>
<li><p>不用赋初值</p>
</li>
<li><p>xx.java 中只能有一个public class 且名字必须叫xx 可以有多个class</p>
</li>
<li><p>对象失去引用，将成为垃圾无法被操作</p>
</li>
<li><p>this 用在<strong>方法内</strong> 用于拿到当前的对象 调用方法的时候this会自动接收当前对象的引用(防止对象的成员变量和方法内部的变量名称相同产生冲突)</p>
</li>
</ul>
<h3 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h3><p>构造函数，可重载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">double</span> score)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建对象的同时完成初始化赋值</li>
<li>不写构造函数会自动生成无参构造</li>
<li>如果定义了有参构造，<strong>不会自动生成</strong>无参构造了</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>合理隐藏，合理暴露，考虑安全性</p>
<p>public(any)&gt;protected(继承类)&gt;friendly(同一package的类)&gt;private(只有当前类才有资格访问)</p>
<h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><ul>
<li>变量私有，方法公开（get set 右键快捷生成）</li>
<li>必有公开的无参构造</li>
<li><strong>实体类</strong>负责数据存取，处理数据交给<strong>业务类</strong>来完成</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentOperator</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Student student;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">StudentOperator</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.student = student;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JavaBean-vs-POJO"><a href="#JavaBean-vs-POJO" class="headerlink" title="JavaBean vs. POJO"></a>JavaBean vs. POJO</h3><p>JavaBean 和 POJO 的区别主要在于它们的用途和规范化程度：</p>
<ol>
<li><p><strong>JavaBean</strong>：</p>
<ul>
<li><strong>定义</strong>：JavaBean 是一种特殊的 Java 类，通常遵循严格的规范。它主要用于开发可复用的组件，尤其是在 Java EE 应用程序中，JavaBean 被广泛用于数据传输对象（DTO）、表单数据和企业级应用中。</li>
<li><strong>规范</strong>：<ul>
<li>必须有一个<strong>无参构造函数</strong>。</li>
<li>所有的属性（成员变量）必须是<strong>私有的</strong>（<code>private</code>），并通过<strong>getter</strong> 和 <strong>setter</strong> 方法进行访问。</li>
<li>必须实现 <strong>Serializable</strong> 接口（可选，但常见）。</li>
</ul>
</li>
<li><strong>应用场景</strong>：JavaBean 常用于 Java EE（例如 JSP、Servlet）中与视图层交互的数据封装，也可用于一些持久层框架如 Hibernate 和 Spring。</li>
</ul>
</li>
<li><p>**POJO (Plain Old Java Object)**：</p>
<ul>
<li><strong>定义</strong>：POJO 是一个普通的 Java 对象，没有任何特殊的要求或规范。它是最普通的 Java 类，通常只用来封装数据，避免依赖特定的框架或库。</li>
<li><strong>规范</strong>：没有严格的要求，可以有构造函数、任意修饰符的属性，甚至没有 getter 和 setter 方法。</li>
<li><strong>应用场景</strong>：POJO 被广泛用于各种场景中，特别是作为轻量级的数据承载类。它不依赖于任何框架的 API，目的是使代码更加简洁和易于维护。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：</p>
<ul>
<li><strong>JavaBean</strong> 是一种受规范约束的 POJO，适合组件开发和框架集成。</li>
<li><strong>POJO</strong> 是一个没有任何限制或依赖的 Java 类，更加灵活自由。</li>
</ul>
<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>局部变量：方法内 一般在栈中</p>
<p>成员变量：一般在类的声明中表现</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240910144323152.png" alt="image-20240910144323152"></p>
<p>out</p>
<h2 id="OOP-Advanced-2024-9-11"><a href="#OOP-Advanced-2024-9-11" class="headerlink" title="OOP Advanced 2024.9.11"></a>OOP Advanced 2024.9.11</h2><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><h4 id="修饰成员变量：类变量"><a href="#修饰成员变量：类变量" class="headerlink" title="修饰成员变量：类变量"></a>修饰成员变量：类变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> String name;<span class="comment">//所有类共享 （类变量）</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接通过类名访问：<code>Student.name = &quot;袁华&quot;</code> 只有一份 </p>
<ul>
<li>应用场景：某个数据只要一份（记住自己创建了多少个用户对象了）希望能够被共享、修改</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911105822932.png" alt="image-20240911105822932"></p>
<h4 id="类方法：属于类的方法"><a href="#类方法：属于类的方法" class="headerlink" title="类方法：属于类的方法"></a>类方法：属于类的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printHelloworld</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line">Student.printHelloworld();</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911110754007.png" alt="image-20240911110754007"></p>
<ul>
<li>应用场景：工具类 提高代码复 用率</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911111331657.png" alt="image-20240911111331657"></p>
<h4 id="其他注意"><a href="#其他注意" class="headerlink" title="其他注意"></a>其他注意</h4><ul>
<li>static 方法 可以直接访问 static 成员变量 ，<u>不能访</u>问实例变量，不能有<strong>this</strong> </li>
<li>实例 方法 可以直接访问 static 成员变量和实例变量、方法，可以有<strong>this</strong> </li>
</ul>
<h5 id="应用：静态代码块-实例代码块"><a href="#应用：静态代码块-实例代码块" class="headerlink" title="应用：静态代码块 实例代码块"></a>应用：<strong>静态代码块 实例代码块</strong></h5><p>静态代码块：<mark>类加载的同时<mark>会加载静态代码块但只有一次，适用于静态变量的初始化</p>
<p>实例代码块：<mark>创建对象的时候<mark>执行，并在构造器<mark>之前<mark>执行，适用于非静态变量的初始化</p>
<h4 id="设计模式：单例"><a href="#设计模式：单例" class="headerlink" title="设计模式：单例"></a>设计模式：单例</h4><ul>
<li><p>一个类有且只有一个对象，创建对象之前就自己有了11:112311</p>
</li>
<li><p>私有构造器</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();<span class="comment">//自有，记住一个对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">A</span><span class="params">()</span>&#123;&#125;<span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title function_">getObject</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911114322070.png" alt="image-20240911114322070"> 上图为拿到一个<strong>对象</strong> <strong>以后</strong>才开始创建对象</p>
<h3 id="继承-extends"><a href="#继承-extends" class="headerlink" title="继承 extends"></a>继承 extends</h3><p>关键字：extends<code>public class B extends A</code> B能继承A的非私有成员和方法</p>
<h4 id="子类的访问"><a href="#子类的访问" class="headerlink" title="子类的访问"></a>子类的访问</h4><ul>
<li>子类不能直接访问父类的私有成员，但是他们<strong>仍然存在于子类对象中</strong>，父类的私有成员子类用get set方法可以完成访问或修改 /  (或者用父类的构造器)</li>
<li>父亲的私人物品儿子不能直接动，但是儿子能通过父亲认可的方法接触</li>
<li>子类方法中同名变量\方法的处理：优先调用方法中声明 的变量，<strong>this</strong>可以调用子类在方法外声明的，<strong>super</strong>可以调用父类声明的</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911115852654.png" alt="image-20240911115852654"></p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>本类</th>
<th>同一包的其他类(包括同一包的子类)</th>
<th>其他包的子类</th>
<th>其他包的其他类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>OK</td>
<td><strong>NO</strong></td>
<td><strong>NO</strong></td>
<td><strong>NO</strong></td>
</tr>
<tr>
<td>缺省</td>
<td>OK</td>
<td>OK</td>
<td><strong>NO</strong></td>
<td><strong>NO</strong></td>
</tr>
<tr>
<td>protected</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td><strong>NO</strong></td>
</tr>
<tr>
<td>public</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
<td>OK</td>
</tr>
</tbody></table>
<ul>
<li><p>注意这些都是在对应的类 <strong>内部</strong> 才起作用 </p>
</li>
<li><p>java 单继承 ， 多层继承 ， 不支持多继承</p>
</li>
<li><p>所有类默认继承自<code>Object</code>类</p>
</li>
</ul>
<h4 id="子类的方法重写"><a href="#子类的方法重写" class="headerlink" title="子类的方法重写"></a>子类的方法重写</h4><ul>
<li><p>子类将父类的方法保持参数列表相同进行重写</p>
</li>
<li><p>用<code>@Override</code> 注解</p>
</li>
<li><p>子类的访问权限必须大于父类</p>
</li>
<li><p><code>private</code> 和 <code>static</code> 不能重写 </p>
</li>
<li><p>应用：println(A) 默认调用的是<code>A.toString()</code> 这是一个Object类的函数，返回地址信息，如果在A类重写toString函数就能改变,可以使用右键快捷生成toString函数</p>
</li>
</ul>
<h4 id="子类的构造器"><a href="#子类的构造器" class="headerlink" title="子类的构造器"></a>子类的<u>构造器</u></h4><ul>
<li><p>调用子类的构造器之前，自动调用父类的无参构造，默认存在<code>super()</code> </p>
</li>
<li><p>如果父类没有无参构造（有了有参构造），子类的构造器无法调用<code>super()</code> 就会报错，所以要在子类的构造器中手动调用 <code>super(name)</code>有参构造 </p>
</li>
<li><p>原因：子类中虽然不能直接操作父类的private成员，但是同样也是要有这些成员的，而且要避免一直调用父类的get set方法，那么子类构造时就要用<strong>父类的构造器</strong> 对父类的private成员进行初始化，再回来把对象里包含子类这部分数据赋值。</p>
</li>
<li><p>有参构造的重载：本来有三个参数，如果只接受两个参数，对其余的一个参数进行缺省设定，<code>this()</code> 就能调用本类的无参构造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>(name, age, <span class="string">&quot;heima&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String schoolName)</span>&#123;</span><br><span class="line">	<span class="built_in">super</span>(name, age);</span><br><span class="line">	<span class="built_in">this</span>.schoolName = schoolName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>this()和super()不能同时出现在构造器中，都必须放在第一行</p>
</li>
</ul>
<h3 id="多态-polymorphism"><a href="#多态-polymorphism" class="headerlink" title="多态 polymorphism"></a>多态 polymorphism</h3><ul>
<li><p><strong>对象多态</strong>：父类的引用类型变量 可以指向子类的对象</p>
</li>
<li><p><strong>行为多态</strong>：子类中和父类<strong>同名(重写)的方法</strong>，在多态调用时采用子类的方法(new的是Teacher的无参构造)</p>
</li>
<li><p>编译看的是左边引用的类型，但是实际运行起来看的是右边的构造函数，但是多态 <strong>不包括</strong> 成员变量 Person p = new Student() </p>
</li>
<li><p>右边对象是解耦合的，比如前面用的是Student后边想换成Person可以直接换掉</p>
</li>
<li><p>用父类的引用形参能接受一切子类的对象</p>
<ul>
<li>多态下不能使用子类的 <strong>独有功能</strong>  <ul>
<li>Method1 父类中定义一个抽象方法</li>
<li>Method2 instanceof判定ifelse</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="多态的类型转换"><a href="#多态的类型转换" class="headerlink" title="多态的类型转换"></a><strong>多态的类型转换</strong></h4><p><strong>auto</strong> : <code>People p = new Teacher();</code> 小的自动转成大的</p>
<p><strong>force</strong>: <code>Teacher t = (Teacher)p;</code>大的必须强制才能转成小的 </p>
<p>编译阶段有继承或者实现关系就不会报错，但是运行会报<code>ClassCastException</code></p>
<p>Teacher有<code>teach() </code>Student 有<code>test()</code> ， 一个父类的引用person是无法调用他们的，必须类型转换</p>
<ul>
<li><p>但是如果p实际上是Student类，是无法强制转换成Teacher类的，引出 <code>instanceof</code> 运算符，结果是一个boolean类型的变量。</p>
</li>
<li><p>用父类的引用形参接受子类的对象，p instanceof Teacher = true 那么调用Teacher的独有功能，否则调用Student的独有功能</p>
</li>
</ul>
<h3 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h3><p>final 加在class上 类不能被继承， final加在方法上不能被重写，加在变量上 变量必须且仅能赋值一次   </p>
<p>static final 修饰的成员变量 String SCHOOL_NAME = “HEIMA” 相当于是 <strong>常量</strong></p>
<p>常量和直接用字面量性能一样</p>
<h3 id="抽象类-abstract-关键字"><a href="#抽象类-abstract-关键字" class="headerlink" title="抽象类 abstract 关键字"></a>抽象类 abstract 关键字</h3><ul>
<li><strong>抽象方法</strong> 只有方法签名，不能有具体的方法实现</li>
<li><strong>不能创建对象</strong> 只能作为父类让子类继承</li>
<li>如果一个类从抽象父类继承而来，除非重写完所有上一代的抽象方法，否则这个类也必须是抽象类</li>
<li>更好支持多态，父类知道子类都要做某个行为，但每个子类做的情况又不一样，父类就定义抽象方法，交给子类重写实现</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911172104015.png" alt="image-20240911172104015"></li>
</ul>
<h4 id="设计模式：模版方法"><a href="#设计模式：模版方法" class="headerlink" title="设计模式：模版方法"></a>设计模式：模版方法</h4><p>解决了什么问题：两个类的方法有大量的重复代码，仅仅有部分不同。</p>
<p>老师和学生都要写同一片作文，开头结尾相同，正文部分不一样，A B都需要<code>write()</code>且大量重复，抽象父类Father可以在<code>write()</code>写好重复的部分，插入抽象方法<code>body()</code>  并且父类的<code>write()</code>可以加<code>final</code>关键字，保证不被继承</p>
<h3 id="接口-interface-关键字"><a href="#接口-interface-关键字" class="headerlink" title="接口 interface 关键字"></a>接口 interface 关键字</h3><p>实现类 实现 接口  重写所有抽象方法</p>
<ul>
<li><p>方法 默认 <code>public</code> <code>abstract</code> </p>
</li>
<li><p>变量 默认 <code>public</code> <code> static</code> <code>final</code>（常量）</p>
</li>
<li><p>接口 不能 实例化，不能被类继承，可被类实现，可被接口继承</p>
</li>
<li><p>弥补单继承，可实现多接口(类似多继承)，一个类可以拥有更多的 能力(某专业方面的能力)</p>
</li>
<li><p>面向接口编程，业务实现的切换灵活，解耦，AB都实现了接口Driver Driver某一天想换人，直接new B就可以，AB都实现了drive方法。你是司机，你就必须会开车，这样的话想换司机只需要换人就可以，不需要额外增加方法 <code>Driver driver = new A();</code> <code>Driver driver = new B();</code> </p>
</li>
<li><p>同一个功能的多套方案：建立一个接口，用接口的抽象方法表示要实现的功能，然后分别做多个接口的实现类，把抽象方法具体化</p>
</li>
<li><p>JDK 8 new:  均非抽象方法，</p>
<ul>
<li>默认方法 default 接口 <strong>实现类的对象</strong> 才可以调用 用public修饰</li>
<li>私有方法 private 只有在接口 <strong>内部</strong> 才能访问</li>
<li>静态方法 static   只能通过 <strong>接口名调用</strong> 用public修饰 </li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240911221630071.png" alt="image-20240911221630071"></li>
</ul>
<p>外部软件包访问本包接口，需要将接口设置为public</p>
</li>
</ul>
<h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><table>
<thead>
<tr>
<th align="left">区别点</th>
<th align="left">重载方法(同一个类)</th>
<th align="left">重写方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">参数列表</td>
<td align="left">必须修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">返回类型</td>
<td align="left">可以修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">异常</td>
<td align="left">可以修改</td>
<td align="left">可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td align="left">访问</td>
<td align="left">可以修改</td>
<td align="left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
</tbody></table>
<h3 id="内部类-9-12"><a href="#内部类-9-12" class="headerlink" title="内部类 9.12"></a>内部类 9.12</h3><ul>
<li><p>创建内部类对象：<code>Outer.Inner in = new Outer().new Inner();</code> 外部类.内部类</p>
<ul>
<li>内部类的方法访问内部类的成员变量 <code>this</code></li>
<li>Outer.this 返回外部类对象</li>
</ul>
</li>
<li><p>JDK16开始 可以定义内部类的静态成员</p>
</li>
<li><p>静态内部类：<code>public static class</code></p>
<ul>
<li><code>Outer.Inner in = new Outer.Inner();</code> </li>
<li>不需要创建外部对象就能获得内部类</li>
<li>可以访问外部类的静态成员</li>
</ul>
</li>
</ul>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><ul>
<li>本质上是一个子类，会立即创建出一个子类对象出来</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.cry();</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Animal这个抽象类不能实例化，在后面加一个大括号，然后在其中实现抽象方法，这样就创建了一个子类对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Swimming</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swimming</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Swim!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">    go(s1); <span class="comment">//输出 Swim！</span></span><br><span class="line">    go(<span class="keyword">new</span> <span class="title class_">Swimming</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Swim!2nd&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;)<span class="comment">//输出Swim！2nd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(Swimming s)</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;Go!&quot;</span>);</span><br><span class="line">	s.swim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Swimming</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>应用：快速创建子类对象，用于（interface）实现类对象作形参的情况 一般是被动去用</li>
<li>JFrame API: <code>button.addActionListener(ActionListener act)</code> <code>ActionListener</code> is an interface</li>
</ul>
<h3 id="枚举-enum-关键字"><a href="#枚举-enum-关键字" class="headerlink" title="枚举 enum 关键字"></a>枚举 enum 关键字</h3><ul>
<li><p> 特殊的class ，私有的构造器，只能创建固定数量的实例(对象)</p>
</li>
<li><p>如果有抽象方法，对象必须实现方法</p>
</li>
<li><p>遍历 for-each语句 没有索引，不能修改元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> number: numbers)&#123;</span><br><span class="line">	System.out.prinln(number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912125835772.png" alt="image-20240912125835772"></p>
</li>
</ul>
<p>枚举变量实际是常对象，用public static final 修饰，创建了X,Y,Z三个常对象，调用的是无参的构造器，也可以自己写有参构造器， </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912130046257.png" alt="image-20240912130046257"></p>
<h4 id="设计模式：单例-1"><a href="#设计模式：单例-1" class="headerlink" title="设计模式：单例"></a>设计模式：单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">C</span>&#123;X;&#125;<span class="comment">//单例</span></span><br></pre></td></tr></table></figure>

<h4 id="信息标注"><a href="#信息标注" class="headerlink" title="信息标注"></a>信息标注</h4><p>常量输入的信息不受约束，用枚举做信息标注更好</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912131648801.png" alt="image-20240912131648801"></p>
<p>枚举做形参，方法内直接写出对应的枚举即可</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul>
<li><p>相当于是类做参数</p>
</li>
<li><p><code>ArrayList</code> 没有指出泛型，默认是<code>Object</code>对象</p>
</li>
<li><p><code>ArrayList&lt;String&gt;</code> 只能接受<code>String</code>类型的数据</p>
</li>
<li><p><code>ArrayList&lt;T extends Animal&gt;</code> 只能接受<code>Animal</code>子类</p>
</li>
<li><p><code>ArrayList&lt;T implements Driver&gt;</code> 只能接受<code>Driver</code>实现类</p>
</li>
<li><p>把数据类型作为参数传递给类型变量，相当于缺省，然后对类的成员进行赋值</p>
</li>
<li><p><em>使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组(<code>Object[] arr</code>)排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。</em> </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Data</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span>;</span><br><span class="line">	ArrayList&lt;T&gt; <span class="title function_">getByName</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">Data</span>&lt;Teacher&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Teacher teacher)</span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    ArrayList&lt;Teacher&gt; <span class="title function_">getByName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//泛型接口</span></span><br></pre></td></tr></table></figure>

<ul>
<li>泛型方法 用<code>&lt;E&gt;</code>修饰，表明方法中存在缺省<strong>类型</strong> class E，可能在参数列表中，也可能在返回值中，也可能在具体的实现中 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span>&#123;</span><br><span class="line">      <span class="comment">// 输出数组元素            </span></span><br><span class="line">    <span class="keyword">for</span> ( E element : inputArray )&#123;     </span><br><span class="line">            System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">    &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912141719516.png" alt="image-20240912141719516"></p>
<ul>
<li><p>定义的时候在返回值前加泛型，单纯使用可以在ArrayList加通配符</p>
<ul>
<li><code>public static &lt;T&gt; void go (ArrayList&lt;T&gt; cars)</code> </li>
<li><code>public static void go (ArrayList&lt;?&gt; cars)</code> </li>
<li><code>&lt;?&gt;</code>表示能接收一切类型的ArrayList </li>
<li><code>&lt;? extends Car&gt;</code>表示能接收Car以及Car子类的ArrayList，也叫上限</li>
<li><code>&lt;? super Car&gt;</code>表示能接收Car以及Car父类的ArrayList ，也叫下限</li>
</ul>
</li>
<li><p><strong>泛型擦除：</strong> 编译阶段工作，class字节码文件中并不存在泛型，都是将 Object 对象 强转为 E 类型</p>
</li>
<li><p>泛型<strong>不支持基本数据类型</strong>，Integer Double 类型解决</p>
</li>
</ul>
<h2 id="API-from-JDK-2024-9-12"><a href="#API-from-JDK-2024-9-12" class="headerlink" title="API from JDK 2024.9.12"></a>API from JDK 2024.9.12</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><ul>
<li><p>Java Object 类是所有类的父类，也就是说 Java 的所有类都继承了 Object，<strong>子类可以使用 Object 的所有方法</strong>。</p>
</li>
<li><p>Object 类位于 java.lang 包中，编译时会自动导入，我们创建一个类时，如果没有明确继承一个父类，那么它就会自动继承 Object，成为 Object 的子类。</p>
</li>
<li><p><code>toString() 返回字符串形式</code> 可重写,以返回对象的内容</p>
</li>
<li><p><code>equals(Object o) 返回boolean </code>   判断对象是否相等 默认比较 <strong>地址</strong> 可重写成 比较两个的内容是否一样</p>
<ul>
<li>先判断地址是否一样</li>
<li>再判断是不是null/是不是同一个类</li>
<li>再判断变量是否相等 <code>return this.age == student.age &amp;&amp; Objects.equals(this.name,student.name)</code>  </li>
</ul>
</li>
<li><p><code>protected o clone()</code> 复制一个完全相同的Object对象，内容相同，属于<strong>浅拷贝</strong> 调用子类方法需要强转 。我们用的类跟Object源文件不在一个包下，所以子类要用<code>clone()</code>必须要重写，通过子类<code>super</code>间接调用父类Object的<code>clone()</code>。并且子类必须是接口<code>Cloneable</code>的实现类.</p>
</li>
<li><p>浅拷贝：<strong>对象中包含的其他对象</strong>，依然指向同一个对象(相当于直接把对象的地址也复制过去了) </p>
</li>
<li><p>深拷贝：浅拷贝+对象中包含的对象单独浅拷贝<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912230730643.png" alt="image-20240912230730643"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> (Animal)<span class="built_in">super</span>.clone();</span><br><span class="line">        a.arr = a.arr.clone();<span class="comment">//数组内部没有其他的对象，</span></span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h3><ul>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240912233304677.png" alt="image-20240912233304677"></p>
</li>
<li><p>equals方法是为了避免空指针异常，s1.equals()，s1 = null 会报NullPointerException</p>
</li>
<li><p>```<br>public static boolean equals(Object a, Object b){</p>
<pre><code>return (a==b)||(a != null &amp;&amp; a.equals(b))
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 包装类 </span><br><span class="line"></span><br><span class="line">int -&gt; Integer      char -&gt;Character</span><br><span class="line"></span><br><span class="line">泛型和集合不支持基本数据类型，用包装类替代，有自动装箱和自动拆箱机制</span><br><span class="line"></span><br><span class="line">- `Integer.toString()` 将Integer对象转换成字符串 i.toString();</span><br><span class="line">- `Integer.toString(int i)` 将23这个数字转换成字符串 静态方法 </span><br><span class="line">  - arr[i] + &quot;&quot; 数字+空串也可以转换成字符串</span><br><span class="line">- `Double.parseDouble(String str)` 将str转换成 double 静态方法</span><br><span class="line">- `Double.valueOf(String str)` 将str转换成 double 静态方法</span><br><span class="line">- println 能加则加，不能加就一起输出</span><br><span class="line"></span><br><span class="line">### StringBuilder</span><br><span class="line"></span><br><span class="line">![image-20240913000059749](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913000059749.png)</span><br><span class="line"></span><br><span class="line">- StringBuilder重写了toString()  </span><br><span class="line">- append返回对象本身，可以链式调用，s.append(1).append(2).append(&quot;!23213&quot;);</span><br><span class="line">- reverse、length</span><br><span class="line">- 操作字符串建议使用StringBuilder 是可变对象 效率更高</span><br><span class="line">- 线程不安全。</span><br><span class="line"></span><br><span class="line">### StringBuffer</span><br><span class="line"></span><br><span class="line">- 线程安全</span><br><span class="line"></span><br><span class="line">### StringJoiner</span><br><span class="line"></span><br><span class="line">- 格式化拼接，方便快捷</span><br><span class="line"></span><br><span class="line">![image-20240913001740989](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913001740989.png)</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static String getArr(int[] arr)&#123; //返回数组</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        sb.append(&quot;[&quot;);</span><br><span class="line">        for(int i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">            sb.append(arr[i]);</span><br><span class="line">            if(i!=arr.length-1)&#123;</span><br><span class="line">                sb.append(&quot;,&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(&quot;]&quot;);</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">public static String getArr(int[] arr)&#123; //返回数组</span><br><span class="line">        StringJoiner sj = new StringJoiner(&quot;,&quot;,&quot;[&quot;,&quot;]&quot;);</span><br><span class="line">		for(int i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">            sj.add(arr[i]+&quot;&quot;);</span><br><span class="line">        &#125;       </span><br><span class="line">        return sj.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Math-2024-9-13"><a href="#Math-2024-9-13" class="headerlink" title="Math 2024.9.13"></a>Math 2024.9.13</h3><p>工具类，静态方法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913134448095.png" alt="image-20240913134448095"></p>
<p>abs ceil floor round</p>
<h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p>工具类 静态方法</p>
<p><code>System.exit(0) </code> 人为停机</p>
<p><code>System.currentTimeMillis()</code> 返回毫秒值 统计程序时间</p>
<h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><ul>
<li>java程序所在的运行环境</li>
<li><strong>单例类</strong> 构造器私有，声明一个public static final</li>
<li>exit exec</li>
</ul>
<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><ul>
<li><p><code>public BigDecimal(String val)</code>构造器 将double转成String类型然后付给BigDecimal</p>
</li>
<li><p><code>public static BigDecimal valueOf(double val)</code> 直接接一个double，据此创建一个BigDecimal对象（推荐）</p>
</li>
<li><p>divide(另一个BD对象，精确位数，舍入模式)</p>
<ul>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913140854393.png" alt="image-20240913140854393"></p>
</li>
<li><table>
<thead>
<tr>
<th>UP</th>
<th>DOWN</th>
<th>CEILING</th>
<th>FLOOR</th>
<th>HALF_UP</th>
<th>HALF_DOWN</th>
</tr>
</thead>
<tbody><tr>
<td>远离0方向</td>
<td>接近0方向</td>
<td>向上取整</td>
<td>向下取整</td>
<td>四舍五入</td>
<td>五舍六入</td>
</tr>
</tbody></table>
</li>
<li><p>HALF_EVEN 若（<strong>舍入位大于</strong>5）或者（<strong>舍入位等于</strong>5<strong>且前一位为奇数</strong>），则对舍入部分的前一位数字加1；若（<strong>舍入位小于</strong>5）或者（<strong>舍入位等于</strong>5且前一位为偶数），则直接舍弃。</p>
</li>
</ul>
</li>
<li><p>转成<code>double d =  bigdecimal.doubleValue()</code></p>
</li>
</ul>
<h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913164633885.png" alt="image-20240913164633885"></p>
<h5 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h5><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><ul>
<li><p><code>toString([] arr)</code> 返回一个数组字符串，每个元素调用<code>toString()</code>转换成字符串，用<code>[,,,]</code>拼接成一个总字符串</p>
</li>
<li><p> <code>copyOfRange([] arr, from, to)</code> 返回值为数组， 内容为arr中索引 <strong>[from, to)</strong> 的部分</p>
</li>
<li><p><code>copyOf([] arr, int newlength)</code> 返回值为数组，内容为arr的内容，长度为newlength，不够的用0补齐，索引超出的截断</p>
</li>
<li><p><code>setAll</code>  第二个参数是接口<code>IntToDoubleFunction</code>的实现对象，重写了<code>applyAsDouble(int value)</code>方法，value是数组的索引，返回对数组中内容进行操作的结果，图中是将数组内容乘以0.8。这个对象传进来以后，对数组进行遍历，都用<code>applyAsDouble</code>的方法进行操作。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913170741004.png" alt="image-20240913170741004"></p>
</li>
<li><p><code>sort([] arr)</code> 对arr升序排序(默认升序)</p>
</li>
<li><p><code>asList()</code>:只能加<strong>引用类型</strong>，基本数据类型需要改成包装类，并且返回的<code>List</code>是不能运用<code>add remove clear</code>方法的，这个<code>list</code>是<code>AbstractList</code>的子类，如果要访问<code>utils</code>只能将返回的这个<code>List</code>添加到<code>new ArrayList&lt;&gt;()</code>作为有参构造</p>
</li>
</ul>
<h4 id="对象数组如何排序？-Comparable-Comparator-—匿名内部类实现函数式接口"><a href="#对象数组如何排序？-Comparable-Comparator-—匿名内部类实现函数式接口" class="headerlink" title="对象数组如何排序？ Comparable Comparator —匿名内部类实现函数式接口"></a>对象数组如何排序？ Comparable Comparator —匿名内部类实现函数式接口</h4><p><strong>自己指定比较规则</strong> </p>
<ul>
<li><p>方法1：对象类实现<code>Comparable&lt;E&gt;</code>这个泛型接口，类中重写<code>int compareTo(E e)</code> 方法，将E改为自己的对象类型。</p>
<ul>
<li>约定，左边大于右边 return 正整数，小于 return 负整数，等于 return 0;（升序排序）</li>
<li><code>return this.age - o.age</code>  注意返回值是int double可以调用<code>Double.compare(o1.height, o2.height)</code></li>
<li>调用<code>Arrays.sort(students)</code>即可</li>
</ul>
</li>
<li><p>方法2：实现<code>Comparator</code>这个泛型接口，运用</p>
<ul>
<li><p>sort有一个重载函数，第一个参数是对象数组<code>T[] arr</code>，第二个参数是<code>Comparator&lt;? super T&gt; comparator</code></p>
</li>
<li><p>泛型接口做参数用匿名内部类实现，类中重写<code>int compare(T o1,T o2)</code>方法，同时注意返回的是int</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Students&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(o1.height,o2.height);<span class="comment">//升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>ArrayList有自己的sort方法，实现同Comparator，可以免去泛型的指定</li>
</ul>
<h4 id="Lambda-表达式—简化匿名内部类"><a href="#Lambda-表达式—简化匿名内部类" class="headerlink" title="Lambda 表达式—简化匿名内部类"></a><strong>Lambda 表达式—简化匿名内部类</strong></h4><ul>
<li>简化匿名内部类的写法，并且只能简化函数式接口(只有一个抽象方法的接口)，表示该接口的一个实现</li>
<li>@FunctionalInterface</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Swimming</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swimming</span>()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		System.out.println(name + <span class="string">&quot;is a swimmer~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Swimming</span> <span class="variable">s</span> <span class="operator">=</span> (name) -&gt; &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;is a swimmer~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913220402634.png" alt="image-20240913220402634"></p>
</li>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240913220414015.png" alt="image-20240913220414015"></p>
</li>
<li><p>参数类型可省略不写，无参数也要空括号</p>
</li>
<li><p>如果只有一个参数，参数列表的括号可以省略不写</p>
</li>
<li><p>如果实现的抽象方法只有一行代码，可以省略大括号，同时也要省略<code>;</code>，若这一行是<code>return</code>语句，return也不能写</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(o1.age(),o2.age());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Arrays.sort(students, (Student o1,Student o2)-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> Double.compare(o1.age(),o2.age());</span><br><span class="line">&#125;);</span><br><span class="line">Arrays.sort(students, (o1,o2)-&gt;&#123;<span class="keyword">return</span> Double.compare(o1.age(),o2.age());&#125;);</span><br><span class="line">Arrays.sort(students, (o1,o2)-&gt;Double.compare(o1.age(),o2.age());</span><br></pre></td></tr></table></figure>

<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ShuSheng0007/article/details/107562812">秒懂Java之方法引用（method reference）详解-CSDN博客</a></p>
<p>Lambda的简化 对于参数列表和返回值相同的情况</p>
<h5 id="类的静态方法引用-类的实例方法引用（对象本身并不作为参数）"><a href="#类的静态方法引用-类的实例方法引用（对象本身并不作为参数）" class="headerlink" title="类的静态方法引用/类的实例方法引用（对象本身并不作为参数）"></a>类的静态方法引用/类的实例方法引用（对象本身并不作为参数）</h5><ul>
<li><p>静态方法引用: 调用静态方法，不需要实例，前缀是类名</p>
</li>
<li><p>实例方法引用: 调用已经存在的对象的实例方法，对象本身并不是参数，方法引用前缀是具体的对象</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;E&gt;&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(E o1, E o2)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompareByData</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compareByAge</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Double.compare(o1.getAge(),o2.getAge());</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareByAgeDesc</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Double.compare(o2.getAge(),o1.getAge());</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> compareBy</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(students, (o1,o2)-&gt;CompareByData.compareByAge(o1,o2));<span class="comment">//lambda</span></span><br><span class="line">Arrays.sort(students, CompareByData::compareByAge);<span class="comment">//静态方法引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">CompareByData</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompareByData</span>();</span><br><span class="line">Arrays.sort(students, (o1,o2)-&gt;com.compareByAgeDesc(o1,o2));<span class="comment">//lambda</span></span><br><span class="line">Arrays.sort(students, com::compareByAgeDesc);<span class="comment">//实例方法引用,com并不是参数</span></span><br></pre></td></tr></table></figure>

<h5 id="类的实例方法引用-对象本身作为参数"><a href="#类的实例方法引用-对象本身作为参数" class="headerlink" title="类的实例方法引用(对象本身作为参数)"></a>类的实例方法引用(对象本身作为参数)</h5><ul>
<li>调用实例方法，对象本身作为参数传进来，方法引用前缀为类名</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(names, (String o1,String o2)-&gt;o1.compareToIgnoreCase(o2));</span><br><span class="line">Arrays.sort(names, String::compareToIgnoreCase);<span class="comment">//compareToIgnoreCase本身是String的一个实例方法</span></span><br><span class="line">    </span><br><span class="line">lqw.lt((User o1)-&gt;o1.getAge());</span><br><span class="line">lqw.lt(User::getAge, <span class="number">10</span>);<span class="comment">//getAge是User的一个实例方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>传入的对象o1是实例方法的调用者，其余的参数都是这个方法的参数</li>
</ul>
<h5 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h5><ul>
<li>Lambda表达式如果只是在创建一个对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Student <span class="title function_">getStudent</span><span class="params">(String name, <span class="type">int</span> age, BiFunction&lt;String, Integer, Student&gt; biFunction)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> biFunction.apply(name, age);</span><br><span class="line">&#125;</span><br><span class="line">BiFunction&lt;String, Integer, Student&gt; s1 = <span class="keyword">new</span> <span class="title class_">BiFunction</span>&lt;String, Integer, Student&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Student <span class="title function_">apply</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>(name, age);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//lambda表达式</span></span><br><span class="line">    BiFunction&lt;String, Integer, Student&gt; s2 = (name, age) -&gt; <span class="keyword">new</span> <span class="title class_">Student</span>(name, age);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//对应的方法引用</span></span><br><span class="line">    BiFunction&lt;String, Integer, Student&gt; s3 = Student::<span class="keyword">new</span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h5 id="方法引用-Lambda作为参数，可以在前面加上实现的函数式接口形参名，增强可读性"><a href="#方法引用-Lambda作为参数，可以在前面加上实现的函数式接口形参名，增强可读性" class="headerlink" title="方法引用/Lambda作为参数，可以在前面加上实现的函数式接口形参名，增强可读性"></a>方法引用/Lambda作为参数，可以在前面加上实现的函数式接口形参名，增强可读性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(names, (Comparator&lt;? <span class="built_in">super</span> String&gt;) String::compareToIgnoreCase);</span><br><span class="line">Arrays.sort(names, String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure>



<h2 id="Regex-正则表达式"><a href="#Regex-正则表达式" class="headerlink" title="Regex 正则表达式"></a>Regex 正则表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">qqCode</span> <span class="operator">=</span> <span class="string">&quot;12812415&quot;</span>;</span><br><span class="line">System.out.println(qqCode.matches(<span class="string">&quot;[1-9]\\d&#123;5-19&#125;&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="Exception-异常处理"><a href="#Exception-异常处理" class="headerlink" title="Exception 异常处理"></a>Exception 异常处理</h2><p><code>Error</code>属于严重异常</p>
<p>运行时异常<code>RuntimeException</code></p>
<p>编译时异常，不解决是无法运行的</p>
<h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240914213155516.png" alt="image-20240914213155516"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行时异常</span></span><br><span class="line"><span class="comment">//自定义异常对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeIllegalRuntimeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalRuntimeException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalRuntimeException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(....) &#123;...&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeIllegalRuntimeException</span>(<span class="string">&quot;Your age is illegal!&quot;</span>);</span><br><span class="line">    &#125;<span class="comment">//抛出一个异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        saveAge(<span class="number">123</span>);<span class="comment">//函数执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)&#123;<span class="comment">//catch 用来接受可能抛出的异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译时异常 强烈提醒检查</span></span><br><span class="line"><span class="comment">//自定义异常对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeIllegalException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveAge</span><span class="params">(<span class="type">int</span> age)</span> <span class="keyword">throws</span> AgeIllegalException&#123;<span class="comment">//接收方法内部可能抛出的异常</span></span><br><span class="line">    <span class="keyword">if</span>(....) &#123;...&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeIllegalException</span>(<span class="string">&quot;Your age is illegal!&quot;</span>);<span class="comment">//一开始会报错,throws抛出</span></span><br><span class="line">    &#125;<span class="comment">//抛出一个异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        saveAge(<span class="number">183</span>);<span class="comment">//函数执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)&#123;<span class="comment">//catch 用来接受可能抛出的异常</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><code>throws</code>:用于方法的声明当方法内部抛出指定类型的异常时，该异常会被传递给<strong>调用该方法的代码</strong>，并在该代码中处理异常</p>
<p><code>try-catch</code>:试图接收并处理异常</p>
<p><code>throw</code>:用于在当前方法中抛出一个异常，当代码执行到某个条件下无法继续正常执行时，可以使用 <strong>throw</strong> 关键字抛出异常，以告知调用者当前代码的执行状态</p>
<ul>
<li>底层异常往外抛,最外层接受并记录,响应给用户</li>
<li>最外层接收,并在底层尝试修复<ul>
<li><code>sc.nextDouble()</code>接收一个<code>double</code>类型,如果乱输aafads就会在运行时自动抛出错误给外层</li>
<li>只需要将外层调用的<code>try-catch</code>块用<code>while(true)</code>围起来即可</li>
</ul>
</li>
</ul>
<h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><h2 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h2><h3 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h3><p>file&amp;directory</p>
<ul>
<li><code>File(String pathname)</code>:有参构造, <code>pathname</code>路径分隔符<code> / \\ File.separator</code> <ul>
<li>绝对路径</li>
<li>相对路径：默认起始位置是工程目录<code>(模块)file-io-app\\src\\itheima.txt</code></li>
</ul>
</li>
<li><code>f1.length()</code>:返回文件,文件夹大小 字节数 文件夹是存储文件夹内部的一些文件信息</li>
<li><code>f3.exists()</code>:是否存在</li>
<li><code>f3.isFile()</code>:是否是文件</li>
<li><code>f3.isDirectory()</code>:是否是文件夹</li>
<li><code>f3.getName()</code>:获取文件名称，包含后缀</li>
<li><code>f3.lastModified()</code>:返回long 最后修改的时间</li>
<li><code>f1.getPath()</code>获取创建对象时输入的路径</li>
<li><code>f1.getAbsolutePath()</code>获取文件的绝对路径</li>
</ul>
<ul>
<li><code>f1.createNewFile()</code>:不存在才创建，存在就创建失败，返回<code>false</code>  没找到路径会报错</li>
<li><code>f1.mkdir()</code>:不存在才创建，存在就创建失败，返回<code>false</code> 只能创建一级目录</li>
<li><code>f1.mkdirs()</code>:可以创建多级目录，返回结果</li>
<li><code>f1.delete()</code>:删除文件、空文件夹，返回结果</li>
</ul>
<ul>
<li><code>f1.list()</code>:当前<strong>文件夹</strong>内的<strong>一级文件名称</strong>返回<code>String[]</code> 也包含文件夹</li>
<li><code>f1.listFiles()</code>:返回当前<strong>文件夹</strong>内的<strong>一级文件对象</strong>，返回文件对象数组<code>File[]</code>，也包含文件夹<ul>
<li>文件、路径不存在、无权限访问的文件夹 <code>return null</code></li>
<li>空文件夹返回长度为0的File数组</li>
<li>隐藏文件也显示</li>
</ul>
</li>
<li><code>renameTo(new File(file.getParent(), newName))</code> 改名，file是目录下子文件,<code>substring(from,to)</code>是截取<code>[from,to)</code>,<code>substring(from)</code>是截取<code>[from,最后]</code></li>
</ul>
<h4 id="文件搜索、非空文件夹删除"><a href="#文件搜索、非空文件夹删除" class="headerlink" title="文件搜索、非空文件夹删除"></a>文件搜索、非空文件夹删除</h4><p>递归，数学问题最好写出表达式</p>
<p>eg 猴子一天吃一半还要再吃一个，10天剩余1个。前9天各自吃了多少？</p>
<p>$f(x)$代表第x天的桃子数量，题干可得出$f(x)/2+1 = f(x+1), f(10)=1$ 直接写递归函数即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNumberOfPeach</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">10</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*getNumberOfPeach(n+<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="C:\Users\Lenovo\IdeaProjects\MyFirstProject\src\com\it\IOtest\FileTestDemo.java">文件搜索、非空文件夹删除</a> </p>
<p><a href="C:\Users\Lenovo\IdeaProjects\MyFirstProject\src\com\it\IOtest\RecursiveDemo.java">递归练习</a> </p>
<h3 id="字符集（前置）"><a href="#字符集（前置）" class="headerlink" title="字符集（前置）"></a>字符集（前置）</h3><p>ASCII: 首位是0，使用1个字节存储英文数字</p>
<p>GBK: 1个中文字符编码成2个字节，兼容ASCII，并且对汉字规定第一个字节的第一位必须是1，与ASCII字符做区分</p>
<p>Unicode: </p>
<ul>
<li><p>UTF-32 4个字节表示一个字符</p>
</li>
<li><p>UTF-8 </p>
<ul>
<li>可变长编码方案 可以有1B 2B 3B 4B 四种长度 </li>
<li>兼容ASCII，汉字字符占3B</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916165638204.png" alt="image-20240916165638204"></li>
</ul>
</li>
<li><p>Encode Decode Identical</p>
</li>
<li><p>String提供了一些API，为字符串提供了编码和解码操作，以字节数组的形式<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916170250587.png" alt="image-20240916170250587"></p>
</li>
</ul>
<h3 id="IO流-字节流-amp-字符流"><a href="#IO流-字节流-amp-字符流" class="headerlink" title="IO流:字节流&amp;字符流"></a>IO流:字节流&amp;字符流</h3><ul>
<li><code>InputStream</code>:字节输入流:以内存为基准，来自磁盘文件/网络中的数据以字节的形式读入到内存中去的流</li>
<li><code>OutputStream</code>:字节输出流:以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流</li>
<li><code>Reader</code>:字符输入流:以内存为基准，来自磁盘文件/网络中的数据以字符的形式读入到内存中去的流，</li>
<li><code>Writer</code>:字符输出流:以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916171717591.png" alt="image-20240916171717591"></p>
<h4 id="FileInputStream-字节流"><a href="#FileInputStream-字节流" class="headerlink" title="FileInputStream 字节流"></a>FileInputStream 字节流</h4><ul>
<li>从文件一个字节一个字节地读取数据到内存中</li>
<li><code>InputStream is = new FileInputStream(&quot;........&quot;)</code></li>
<li><code>FileInputStream(String name)</code>:打开实际文件的连接创建文件字节输入流，也可用<code>File file</code>做形参，<code>String</code>重载会自动帮你转成file对象。</li>
<li>一次读取一个 <code>int read()</code> 读取一个字节并返回，无数据返回-1 <ul>
<li>改进：循环<code>(b=is.read())!=-1</code></li>
<li>调用系统硬件资源，性能较差</li>
<li>一次读一个，无法解决非ASCII的乱码</li>
<li>流使用系统资源，使用完记得关闭！<code>is.close()</code></li>
</ul>
</li>
<li>一次读取多个 <code>int read(byte[] buffer)</code> 用<code>buffer</code>字节数组装字节，字节数组的长度代表每次读取的字节数，返回每次读取的字节数（<code>buffer</code>可能会装不满）无数据返回-1<ul>
<li><code>buffer</code>字节数组要转换成字符串，转成<code>String</code>可以设定转的部分，<code>String(buffer, 0, len)</code>确保如实把<strong>这次</strong>读到的内容转为字符串 <code>len</code>为<code>read</code>的返回值 </li>
<li>性能得到了提升，汉字仍然乱码，会强行截断汉字</li>
</ul>
</li>
<li>一次读取全部<ul>
<li><code>int read(byte[] buffer)</code>buffer大小和文件的大小字节数相同</li>
<li><code>byte[] readAllBytes()</code> <code>is.readAllBytes()</code> </li>
<li>文件过大会导致内存溢出，字节数组过大，所以字节流不适合读文本，更适合做数据转移，比如文件复制</li>
</ul>
</li>
</ul>
<h4 id="FileOutputStream-字节流"><a href="#FileOutputStream-字节流" class="headerlink" title="FileOutputStream 字节流"></a>FileOutputStream 字节流</h4><ul>
<li>从内存一个字节一个字节地输出到文件中，目标文件自动生成</li>
<li><code>OutputStream os = new FileOutputStream(&quot;........&quot;)</code> 写文件（覆盖）</li>
<li><code>OutputStream os = new FileOutputStream(&quot;........&quot;, true)</code> 写文件（追加）<ul>
<li>换行：<code>&quot;\r\n&quot;</code> 将其转换成<code>bytes[]</code> 再<code>write</code></li>
</ul>
</li>
<li><code>os.write(int b)</code>把b写入文件 还是以字节形式</li>
<li><code>os.write(byte[] b)</code>把字节数组b写入文件</li>
<li><code>os.write(byte[] b,int off,int len)</code>把b写入文件, <code>off</code>表示起始的字节数组索引，<code>len</code>表示要写入的字节长度，3个汉字一共9字节</li>
</ul>
<h5 id="case-文件复制"><a href="#case-文件复制" class="headerlink" title="case: 文件复制"></a>case: 文件复制</h5><p>总结：字节流适合拷贝一切文件，因为一切文件的内容都是以字节形式存储的，一字不漏地转移所有字节，就不会出现问题</p>
<h4 id="释放资源的方式"><a href="#释放资源的方式" class="headerlink" title="释放资源的方式"></a>释放资源的方式</h4><p>原来：中间出现异常，就无法释放资源（关闭字节流）</p>
<h5 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论try是否正常执行，一定执行finally，除非JVM终止<code>System.exit(0)</code></p>
<p>finally可以无视<code>return</code>语句 一定执行一次，如果finally是return，原函数接受的就一定是finally里边的值，所以最好不要在finally里面return</p>
<p>在程序执行完成后进行资源的释放操作，finally不能访问try块里面的内容</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916200213214.png" alt="image-20240916200213214">先在try块外定义流，然后try块内对流进行操作，finally块内关闭流，关闭流因为系统不知道之前是否开流会报错，用try catch块包围起来即可<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916200719319.png" alt="image-20240916200719319"></p>
<p><strong>臃肿</strong></p>
<h5 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>（</span><br><span class="line">	<span class="comment">//资源的定义;</span></span><br><span class="line">	<span class="comment">//资源的定义;</span></span><br><span class="line">）&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能放置资源对象, 资源都会实现AutoClosable接口，资源放进去会自动调用close方法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916201402673.png" alt="image-20240916201402673"></p>
<h4 id="FileReader-字符流"><a href="#FileReader-字符流" class="headerlink" title="FileReader 字符流"></a>FileReader 字符流</h4><ul>
<li>把文件数据以字符形式读到内存中去</li>
<li>构造器与<code>FileInputStream</code>类似 <code>Reader fr = new FileReader(String filename)</code></li>
<li><code>int read() </code>每次读取一个字符并返回</li>
<li><code>int read(char[] buffer) </code>每次读取多个字符并返回，返回此次读取字符的个数</li>
</ul>
<h4 id="FileWriter-字符流"><a href="#FileWriter-字符流" class="headerlink" title="FileWriter 字符流"></a>FileWriter 字符流</h4><ul>
<li>把字符数据写到文件中去,目标文件自动生成</li>
<li>构造器与<code>FileOutputStream</code>类似 <code>Writer fw = new FileWriter(String filename)</code>可以参数后加true表示追加</li>
<li><code>void write(int c)</code>写一个字符出去</li>
<li><code>void write(String str)</code>写一个字符串出去</li>
<li><code>void write(String str,int pos,int len)</code> 写字符串从<code>pos</code>开始长度为<code>len</code></li>
<li><code>void write(char[] buffer)</code>写一个字符数组</li>
<li><code>void write(char[] buffer,int pos,int len)</code>写字符数组从<code>pos</code>开始长度为<code>len</code></li>
<li>注意事项<ul>
<li>字符输出流写出数据以后，必须刷新流或者关闭流（包含刷新）才能生效。<code>flush() close()</code> 因为对文件操作比较耗费系统资源，所以都是先从管道写到缓冲区，写完之后一次性写到文件中去。</li>
</ul>
</li>
</ul>
<h3 id="IO流-缓冲流"><a href="#IO流-缓冲流" class="headerlink" title="IO流:缓冲流"></a>IO流:缓冲流</h3><p>对原始流进行包装，提高原始流读写数据的性能</p>
<h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><p>开辟缓冲区，不用一次一次写 <strong>8KB缓冲池</strong> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916231524970.png" alt="image-20240916231524970"></p>
<p>减少调用系统资源的次数</p>
<p><code>InputStream bis = new BufferedInputStream(InputStream is)</code></p>
<p><code>OutputStream bos = new BufferedOutputStream(OutputStream os)</code></p>
<p>方法和原始类一样，性能有所提高，有参构造可以自定义缓冲区大小，默认8192</p>
<h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h4><p>自带8K的字符缓冲池</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240916232037970.png" alt="image-20240916232037970"></p>
<p><code>BufferedReader br = new BufferedReader(Reader r)</code> </p>
<p>不使用多态写法：新增了独有的功能</p>
<p>新增功能 <code>String readLine()</code> 读一整行，直到换行符，返回这行的内容，没有返回<code>null</code></p>
<p><code>BufferedWriter bw = new BufferedWriter(Writer r)</code> </p>
<p>新增功能：<code>void newLine()</code>换行</p>
<h3 id="原始-amp-缓冲流对比"><a href="#原始-amp-缓冲流对比" class="headerlink" title="原始&amp;缓冲流对比"></a>原始&amp;缓冲流对比</h3><ul>
<li>低级字节流一个一个字节的赋值，慢的简直让人无法忍受，直接淘汰! X</li>
<li>低级字节流一个一个字节数组的形式复制，速度较慢! </li>
<li>缓冲流按照一个一个字节的形式复制，速度较慢 X</li>
<li>缓冲流按照一个一个字节数组的形式复制，速度极快，推荐使用!</li>
<li>性能与字节数组的大小强相关，32MB最大，用空间换时间</li>
<li>与缓冲区的大小也有关</li>
</ul>
<p>并行&amp;多线程 异步IO 内存映射技术 减少系统调用 不要一个字节一个字节地输入</p>
<h3 id="字符转换流"><a href="#字符转换流" class="headerlink" title="字符转换流"></a>字符转换流</h3><h4 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h4><p><code>Reader isr = new InputStreamReader(InputStream is, String charset)</code> 把<strong>原始<mark>字节流<mark>is</strong>按照charset设定转换成对应字符输入流</p>
<p>新的字符输入流可以继续用<code>BufferedReader</code>包装</p>
<h4 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h4><p>控制写出去的字符集编码</p>
<ul>
<li><code>str.getBytes(&quot;GBK&quot;)</code></li>
<li>字符输出转换流</li>
</ul>
<h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p>PrintStream：是<strong>字节输出流</strong>的实现类</p>
<p>PrintWriter：是<strong>字符输出流</strong>的实现类 内部包装缓冲流</p>
<p><strong>方便高效</strong>，所见即所得</p>
<p>构造器：</p>
<ul>
<li><code>PrintStream(OutputStream os/File file/String filename)</code> 直接链接+包装原始流</li>
<li><code>PrintStream(String filename, Charset charset)</code> <code>Charset.forName(&quot;GBK&quot;)</code>能返回GBK的Charset</li>
<li><code>PrintStream(OutputStream os, boolean autoFlush, String charset)</code> 字符集可有可无</li>
<li><strong><code>ps.println()</code>:打印一行东西</strong></li>
<li><code>ps.write()</code>写int字节 字节数组 字节数组的一部分</li>
</ul>
<p>自身没有追加功能，只能包装<code>true输出流</code>:</p>
<p><code>PrintStream ps = PrintStream(new FileOutputStream(filename,true))</code> </p>
<p><code>PrintWriter pw = PrintWriter(new FileWriter(filename,true))</code>  </p>
<h4 id="拓展：Redirecting-PrintStream-PrintWriter"><a href="#拓展：Redirecting-PrintStream-PrintWriter" class="headerlink" title="拓展：Redirecting PrintStream/PrintWriter"></a>拓展：Redirecting PrintStream/PrintWriter</h4><p><code>System.out.println()</code> out实际上就是一个打印流，是指向控制台的</p>
<p><code>System.setOut(PrintStream ps)</code> 把系统的out设定到指定的打印流ps中</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917153902713.png" alt="image-20240917153902713"></p>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p><code>DataInputStream</code>:字节输入流的实现</p>
<p>构造器：包装低级的字节输入流 </p>
<p><code>dos.writeInt(int a)</code> 写出去a，包括数据类型</p>
<p><code>dis.readUTF()</code> 读进来字符串并返回 UTF-8</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917154727844.png" alt="image-20240917154727844"></p>
<h3 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h3><p><a href="..%5CSerialization.md">序列化</a> </p>
<p> 字节流实现类<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917154853819.png" alt="image-20240917154853819"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917154908066.png" alt="image-20240917154908066"></p>
<p><strong>First Step</strong> 创建对象字节输出流 包装原始字节输出流:</p>
<p><code>ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream)</code></p>
<p><strong>Second Step</strong> 调用 writeObject(具体对象)方法 </p>
<p>对象的类要**<code>implements</code> <code>Serializable</code>** 接口！</p>
<p><strong>Third Step</strong> 创建对象字节输入流 包装原始字节输入流</p>
<p><code>ObjectInputStream ois = new ObjectInputStream(new FileInputStream)</code> </p>
<h4 id="拓展：对象中某些变量不想参与序列化"><a href="#拓展：对象中某些变量不想参与序列化" class="headerlink" title="拓展：对象中某些变量不想参与序列化"></a>拓展：对象中某些变量不想参与序列化</h4><p><code>private </code> <code>transient</code> <code> String password;</code> transient关键字</p>
<h4 id="拓展：一次序列化多个对象"><a href="#拓展：一次序列化多个对象" class="headerlink" title="拓展：一次序列化多个对象"></a>拓展：一次序列化多个对象</h4><p>将对象存入ArrayList中，对ArrayList进行序列化</p>
<h3 id="IO框架"><a href="#IO框架" class="headerlink" title="IO框架"></a>IO框架</h3><p>框架：把编写好的类和接口编译成class形式，压缩成.jar结尾的文件发行</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917162151321.png" alt="image-20240917162151321"></p>
<h2 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h2><p>存储有关系的数据作为系统的配置文件</p>
<h3 id="properties-属性文件"><a href="#properties-属性文件" class="headerlink" title=".properties 属性文件"></a>.properties 属性文件</h3><ul>
<li>存储键值对数据</li>
<li>键不重复</li>
</ul>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917163605651.png" alt="image-20240917163605651"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建属性对象，加载文件内容</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filename));</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建字符串集合，接收属性对象返回的键集合</span></span><br><span class="line">Set&lt;String&gt; keys = properties.stringPropertyNames();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历键集合，通过属性对象和键找到value</span></span><br><span class="line"><span class="keyword">for</span>(String key : keys)&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(key);</span><br><span class="line">	properties.forEach((k,v)-&gt;System.out.println(k + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917164532330.png" alt="image-20240917164532330"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.setProperty(<span class="string">&quot;asd&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;dfg&quot;</span>,<span class="string">&quot;213&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;hjk&quot;</span>,<span class="string">&quot;321&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">comments</span> <span class="operator">=</span> <span class="string">&quot;I have saved many users!!!&quot;</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">properties.store(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filename), comments);</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>



<h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><p>E<strong>X</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage</p>
<p>根标签 只有一个</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917170133400.png" alt="image-20240917170133400"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917170306289.png" alt="image-20240917170306289"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917170346202.png" alt="image-20240917170346202"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917170514649.png" alt="image-20240917170514649"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917185127560.png" alt="image-20240917185127560"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917185753893.png" alt="image-20240917185753893">好</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul>
<li>系统执行信息方便记录到指定的位置（控制台，文件，数据库）</li>
<li>随时用开关控制日志启停，不需要修改源代码</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917191534986.png" alt="image-20240917191534986"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917191744756.png" alt="image-20240917191744756"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917192232262.png" alt="image-20240917192232262"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917192328808.png" alt="image-20240917192328808"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917192715641.png" alt="image-20240917192715641"></p>
<p><code>&lt;pattern&gt; &lt;/pattern&gt;</code> 日志格式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917192956963.png" alt="image-20240917192956963"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917193034517.png" alt="image-20240917193034517"></p>
<p>文件拆分规则，保证每个不超过1MB，过去的压缩成1MB的gz文件</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917193427486.png" alt="image-20240917193427486"></p>
<p>控制日志输出情况</p>
<p>日志级别 trace&lt; <strong>debug</strong> &lt; info &lt; warn &lt; error </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240917193721056.png" alt="image-20240917193721056"></p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><ul>
<li><code>java.net.*</code></li>
</ul>
<p>CS BS架构</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918155511067-1726751033487-55.png" alt="image-20240918155511067"></p>
<h2 id="网络通信基本概念"><a href="#网络通信基本概念" class="headerlink" title="网络通信基本概念"></a>网络通信基本概念</h2><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>设备在网络的地址，唯一标识</p>
<p><strong>IPv4:</strong> 32bit 点分十进制表示法    <strong>IPv6:</strong> 128bit 冒号分16进制表示法</p>
<p><strong>域名</strong>代表IP，<strong>DNS服务器</strong>会记录域名的真实IP</p>
<p><strong>公网IP</strong>：链接互联网 <strong>内网IP</strong>：局域网，内部使用</p>
<p>**<code>localhost = 127.0.0.1</code>**：代表本机IP，只会寻找当前所在的主机</p>
<p><strong><code>ping IP地址</code></strong> </p>
<h4 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h4><p>常用方法：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918160540846-1726751033487-56.png" alt="image-20240918160540846"></p>
<p><code>getByName()</code>: 根据主机名 返回IP地址对象</p>
<p><code>isReachable(int ms)</code> 相当于ping命令</p>
<h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><p>端口，应用程序在设备的地址，唯一标识</p>
<p>16bit 0-65535</p>
<p>0-1023: 预定义占用，周知端口</p>
<p>1024-49151: 注册端口</p>
<p>49152-65535: 动态分配</p>
<p>同一设备不能有两个程序的端口号一样</p>
<h3 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a>protocol</h3><p>协议，应用程序之间进行通信的规则</p>
<p>OSI 网络参考模型</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918161423219-1726751033487-57.png" alt="image-20240918161423219"></p>
<p>TCP/IP 事实上的国际标准</p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p><strong>U</strong>ser <strong>D</strong>atagram <strong>P</strong>rotocol</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918161816467-1726751033487-58.png" alt="image-20240918161816467"></p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p><strong>T</strong>ransmission <strong>C</strong>ontrol <strong>P</strong>rotocol</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918161923650-1726751033487-59.png" alt="image-20240918161923650"></p>
<h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h4><p>第一次握手：客户端发消息，服务器收到消息，服务器知道客户端发消息没问题。</p>
<p>第二次握手：服务端发消息，客户端收到消息，客户端知道服务端收消息没问题，发消息也没问题。</p>
<p>第三次握手：客户端根据上一次握手的内容再次发出确认信息，服务器端收到信息，说明客户端收消息没问题。</p>
<p>全双工：双方都要确认对方同时具备收发信息的能力</p>
<p>不可靠信道上实现可靠的传输</p>
<p><strong>B 收到了 A 发来的消息，B 因此判断 A 具备发送能力</strong>：</p>
<ul>
<li>这个理解是正确的。当 B 收到 A 发送的 <code>SYN</code> 报文时，B 可以判断 A 具有发送消息的能力。A 通过发送 <code>SYN</code> 表示自己希望建立连接，并告诉 B 自己的初始序列号。</li>
<li>但需要注意的是，B 仅能判断 A 能发送数据，尚无法确定 A 能正确接收 B 发送的消息（即 A 的接收能力）。</li>
</ul>
<p><strong>A 收到了 B 发回的消息，A 判断 B 具备收发信息能力</strong>：</p>
<ul>
<li><strong>发送能力</strong>：正确。当 A 收到 B 发回的 <code>SYN-ACK</code> 消息后，A 可以确认 B 具备发送能力，因为 B 能够发送 <code>SYN-ACK</code> 报文。</li>
<li><strong>接收能力</strong>：A 也可以推断 B 具备接收能力，因为 B 不仅发送了 <code>SYN-ACK</code>，还包含了对 A 的 <code>SYN</code> 的确认（<code>ACK</code>），说明 B 成功接收了 A 的 <code>SYN</code> 报文。</li>
<li>因此，通过 B 的 <code>SYN-ACK</code> 报文，A 可以确认 B 既能够发送，也能够接收消息。</li>
</ul>
<p><strong>B 收到了 A 发回的信息，B 因此判断 A 具备接收能力，连接建立</strong>：</p>
<ul>
<li>这个理解也基本正确。当 B 收到 A 的 <code>ACK</code> 报文后，B 可以确认 A 的接收能力，因为 A 收到了 B 的 <code>SYN-ACK</code> 并发回了 <code>ACK</code>。如果 A 无法接收数据，就无法正确回应 B 的 <code>SYN-ACK</code> 报文。</li>
<li>至此，B 确定 A 既能发送也能接收，双方通信能力都得到确认，连接可以正式建立。</li>
</ul>
<ul>
<li>在 TCP 三次握手过程中，双方都通过序列号和确认号来确认彼此的发送和接收能力，确保连接是双向可靠的。</li>
<li>三次握手的过程确保了双方的<strong>发送能力</strong>和<strong>接收能力</strong>都正常，连接才会被建立。</li>
<li>你对各个步骤的理解是对的，只需要记住，每一步都不仅仅是确认对方的发送能力，还需要通过确认号和响应确认对方的接收能力。</li>
</ul>
<h4 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h4><ol>
<li>客户端发完数据，发出断连请求</li>
<li>服务器还没处理完最后的数据，先发一个消息，让客户端稍等</li>
<li>处理完数据后，服务器再发一个消息确认断开连接</li>
<li>客户端正式断开连接</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918213236026-1726751033487-61.png" alt="image-20240918213236026"></p>
<h2 id="Java-UDP"><a href="#Java-UDP" class="headerlink" title="Java UDP"></a><a href="jetbrains://idea/navigate/reference?project=MyFirstProject&fqn=com.it.netTest.UDP.Client">Java UDP</a></h2><ul>
<li><code>java.net.DatagramSocket</code> <code>java.net.DatagramPacket</code> </li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240918213602137-1726751033487-60.png" alt="image-20240918213602137"></li>
<li>创建DS对象，创建DP对象用于封装数据，DP对象里有字节数组，字节数组长度，目标IP,目标端口，客户端调用send方法发送数据包。</li>
<li>创建DS对象(端口号)，创建DP对象用于接收数据，DP对象里的数组长度64KB，然后服务段调用receive方法接收数据包。数据包调用getLength方法获取实际接收数据包的大小，以便正确输出数据包内数组的内容。</li>
<li>getAddress()可以拿到客户端IP地址</li>
<li>getPort()可以拿到客户端端口</li>
</ul>
<h2 id="Java-TCP"><a href="#Java-TCP" class="headerlink" title="Java TCP"></a><a href="jetbrains://idea/navigate/reference?project=MyFirstProject&path=com/JavaSE/netTest/tcp/Server.java">Java TCP</a></h2><p><code>java.net.Socket</code> <code>java.net.ServerSocket</code></p>
<p>服务端和客户端通过<code>socket</code>对象之间建立的管道进行通信，数据通过管道也就是流进行传输，而UDP是通过发送单个<code>datagram</code>数据报的形式，不需要建立联系，不需要建立稳定的管道</p>
<ul>
<li><p>客户端：    </p>
<ul>
<li>创建<code>Socket sk = new Socket(hostname, port)</code> 数据目的地的端口号</li>
<li><code>OutputStream os = sk.getOutputStream();</code> 把<code>socket</code>的流拿到</li>
<li><code>DataOutputStream dos = new DataOutputStream(os)</code> 对原始的流进行包装</li>
<li><code>dos.writeUTF(&quot;String sth&quot;)</code> </li>
<li>关闭<code>dos</code> 关闭<code>socket</code> </li>
</ul>
</li>
<li><p>服务端</p>
<ul>
<li>创建 <code>ServerSocket ss = new ServerSocket( port)</code> 注册端口，跟客户端里面的端口一样</li>
<li><code>Socket socket = ss.accept()</code> 等待客户端发来socket连接请求，端到端，这两个socket内容其实是一样的。</li>
<li><code>DataInputStream dis = new DataInputStream(socket.getInputStream());</code>用数据流包装原始的输入流</li>
<li><code>dis.readUTF().sout</code></li>
</ul>
</li>
</ul>
<p>支持一发一收 多发多收，因为只能是一个socket对应一个socket，是端到端的，要实现跟其他socket的通信只能断开连接，所以引入多线程，接到socket就开一个新线程，继续监听socket，用while循环实现。</p>
<p>要实现群聊，服务器可以用一个集合储存socket，如果某个socket收到了消息，就遍历集合发给所有socket（同客户端的发送代码）客户端建立socket对象之后，在while循环内部出不来，要监听</p>
<p>BrowserServer架构 Server要提供的内容必须符合HTTP规范</p>
<h1 id="单元测试框架"><a href="#单元测试框架" class="headerlink" title="单元测试框架"></a>单元测试框架</h1><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240919211712463.png" alt="image-20240919211712463"></p>
<p>检测抛出异常</p>
<h2 id="断言机制"><a href="#断言机制" class="headerlink" title="断言机制"></a>断言机制</h2><p>Assert.assertEquals() bug提示 <strong>期望值</strong> 实际值 </p>
<h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>可以一键进行所有测试，一键自动化测试</p>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>@Test 测试方法</p>
<p>@Before(BeforeEach) 每个测试前要跑的方法</p>
<p>@BeforeClass(All) 修饰静态方法，所有测试方法之前，最先 这两个是初始化</p>
<p>@After(AfterEach) 每个测试执行完要跑的方法</p>
<p>@AfterClass(All) 修饰静态方法，所有测试方法之后，最后 这两个是释放资源</p>
<p>如果是每一个测试方法都需要一个独立的资源，就用before</p>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="annotation"><a href="#annotation" class="headerlink" title="annotation"></a>annotation</h2><p>让其他程序根据注解来决定怎么执行该程序</p>
<p><code>@Override</code>:让IDE判断方法是否重写成功 </p>
<p><code>@Test</code>: 让测试框架知道这个是测试方法</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest1&#123;</span><br><span class="line">    String <span class="title function_">aaa</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">bbb</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">    String[] ccc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//value 属于特殊属性，可以只写值</span></span><br><span class="line"><span class="comment">//有 default 可以不用赋值</span></span><br><span class="line"><span class="comment">//没 default 必须赋值，带变量名和等号</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyTest1</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">aaa</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">bbb</span><span class="params">()</span>&#123;<span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">true</span>;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String[] ccc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质是接口，都继承了Annotation接口</p>
<p><code>@MyTest1(aaa=&quot;123&quot;,bbb=false, ccc=&#123;&quot;str&quot;,&quot;asd&quot;&#125;)</code> 是一个实现类对象</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>修饰注解的注解, 在自定义注解的上面 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240919214219300.png" alt="image-20240919214219300"></p>
<h2 id="解析注解"><a href="#解析注解" class="headerlink" title="解析注解"></a>解析注解</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240919214508991.png" alt="image-20240919214508991"></p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>模拟框架 解析注解，然后执行 模拟<a href="jetbrains://idea/navigate/reference?project=MyFirstProject&fqn=org.JavaSE.AdvancedTest.Annotation.JUnitSimulator">JUnitSimulator(Toolbox 引用)</a>识别并执行有特定注解的方法</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>加载类，允许用编程的方式，解剖类中的各种成分（万物皆对象）</p>
<p>比如ide中创建一个对象，对象引用后加一个点就能显示可以调用的方法，说明这个类实现的方法已经提前加载好了</p>
<h2 id="加载方法"><a href="#加载方法" class="headerlink" title="加载方法"></a>加载方法</h2><ol>
<li><p>加载类，获取 <code>Class</code> 对象</p>
<ul>
<li><code>Class c = 类名.class</code> </li>
<li><code>Class.forName(全名)</code>  </li>
<li><code>Class c = 对象.getClass()</code> </li>
<li><code>getName() 全名带包名 getSimpleName() 简名</code></li>
<li><code>getMethod() getConstructor() getField()</code> </li>
</ul>
</li>
<li><p>获取类的构造器 <code>Constructor</code> 对象，主调是 <code>Class 对象</code></p>
<ul>
<li><code>getConstructors</code> 只有 public <strong>返回数组</strong></li>
<li><code>getDeclaredConstructors</code> 存在就能拿到</li>
<li><code>getConstructor(形参的类型对象)</code> 只有public 拿一个</li>
<li><code>getDeclaredConstructor(形参的类型对象)</code> 存在就能拿到 拿1个</li>
</ul>
<ul>
<li>下面的主调是构造器对象</li>
<li><code>getParameterCount</code>几个参数</li>
<li><code>newInstance(...参数)</code> 返回<code>object</code> 强转为对象，如果私有构造器会报错</li>
<li><code>setAccessible(true)</code> 暴力反射，禁止检查访问权限</li>
</ul>
</li>
<li><p>获取类的成员变量 <code>Field</code> 对象</p>
<ul>
<li><code>getFields</code> <code>getDeclaredFields</code> </li>
<li><code>getField(name)</code> <code>getDeclaredField(name)</code></li>
<li>下面主调是<code>Field</code>对象</li>
<li><code>set(对象, 值)</code> <code>get(对象)</code> 赋值 取值</li>
<li><code>setAccessible</code> 暴力反射</li>
</ul>
</li>
<li><p>获取类的成员方法 <code>Method</code> 对象</p>
<ul>
<li><code>getMethods</code> <code>getDeclaredMethods</code></li>
<li><code>getMethod(name, String.class, int.class) </code>返回值</li>
<li>下面主调是<code>method</code></li>
<li><code>getName getParameterConut getReturnType</code></li>
<li><code>invoke(对象, 参数)</code> 返回object 强转为返回值类型</li>
<li><code>setAccesible</code></li>
</ul>
</li>
</ol>
<h2 id="作用、应用场景"><a href="#作用、应用场景" class="headerlink" title="作用、应用场景"></a>作用、应用场景</h2><ul>
<li>得到类的全部成分</li>
<li>破坏封装性</li>
<li>做框架</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920001226903.png" alt="image-20240920001226903"></p>
<p>接收任意对象，接到对象，用反射获取class对象，获取全部成员变量，遍历他们，把他们的属性写出到文件中</p>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>框架的核心技术，一个类有很多方法，需要加载资源，而代理可以代替类执行这些操作。</p>
<p>Spring AOP技术使用了JDK动态代理和CGLIB动态代理两种方式，在不改变原始方法的前提下对功能进行增强。</p>
<h2 id="JDK-动态代理——反射"><a href="#JDK-动态代理——反射" class="headerlink" title="JDK 动态代理——反射"></a>JDK 动态代理——反射</h2><ul>
<li>JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求<strong>代理对象和目标对象实现同样的接口</strong>（兄弟两个拜把子模式），目标对象和代理对象是平等地位的。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920112517946.jpg" alt="image-20240920112517946"></p>
<p>对于一个UserServiceImpl，要生成它的代理对象，为了能创建一个跟UserServiceImpl拥有同名方法的代理Proxy，<mark>这个类必须实现一个接口UserService，并且拥有Impl的全部方法<mark>，然后把Impl传给生成代理的方法。</p>
<p>接口能将原来的实现对象的方 法抽象化（或者部分抽象） 方便代理进行重写，代理重写完具体的执行逻辑，返回的还是这个接口的实现对象，相当于是把原来的实现对象包装了一下，完美地把对象的职责转移到了代理身上，业务对象。减少代码冗余和多余的资源调用</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023232822938.png" alt="image-20241023232822938"></p>
<h2 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h2><p>通过<strong>继承被代理的目标类</strong>（认干爹模式）实现代理，所以不需要目标类实现接口。</p>
<p><strong>CGLIB 通过动态生成一个需要被代理类的子类（即被代理类作为父类），该子类重写被代理类的所有不是 final 修饰的方法，并在子类中采用方法拦截的技术拦截父类所有的方法调用，进而织入横切逻辑，</strong> 目标对象是代理对象的父类。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib-nodeps<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023232711967.png" alt="image-20241023232711967"></p>
<h1 id="Hutool-Usage"><a href="#Hutool-Usage" class="headerlink" title="Hutool Usage"></a>Hutool Usage</h1><h2 id="BeanUtil"><a href="#BeanUtil" class="headerlink" title="BeanUtil"></a>BeanUtil</h2><h3 id="bean和Map转换"><a href="#bean和Map转换" class="headerlink" title="bean和Map转换"></a>bean和Map转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt;BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">                 CopyOptions.create().setFieldValueEditor((fieldName,fieldValue)-&gt;fieldValue.toString()));</span><br><span class="line"></span><br><span class="line">BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(),<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h2 id="JSONUtil"><a href="#JSONUtil" class="headerlink" title="JSONUtil"></a>JSONUtil</h2><h3 id="JSON和对象互转"><a href="#JSON和对象互转" class="headerlink" title="JSON和对象互转"></a>JSON和对象互转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(shop);</span><br><span class="line"></span><br><span class="line">shop = JSONUtil.toBean(jsonStr,Shop.class);</span><br></pre></td></tr></table></figure>

<h3 id="JSON和数组互转"><a href="#JSON和数组互转" class="headerlink" title="JSON和数组互转"></a>JSON和数组互转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonArrayStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(list);</span><br><span class="line"></span><br><span class="line"><span class="type">JSONArray</span> <span class="variable">jsonArray</span> <span class="operator">=</span> JSONUtil.parseArray(jsonArrayStr);</span><br><span class="line">shopTypeList = JSONUtil.toList(jsonArray, ShopType.class);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/30/MySQL%20%E5%9F%BA%E7%A1%80%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/30/MySQL%20%E5%9F%BA%E7%A1%80%E7%AF%87/" class="post-title-link" itemprop="url">MySQL 基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-30 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-30T00:00:00+08:00">2024-09-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 15:54:42" itemprop="dateModified" datetime="2025-04-27T15:54:42+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>DB</strong>: organized data</p>
<p><strong>DBMS</strong>: manage system</p>
<p><strong>RDBMS</strong>: SQLite PostgreSQL MySQL Oracle Microsoft SQL Server (relational)</p>
<p><strong>SQL</strong>: programming language</p>
<p><strong>数据模型</strong>：管理系统：数据库：表：数据</p>
<p><strong>RDBMS</strong>: 表结构格式统一</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920142153024.png" alt="image-20240920142153024"></p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923202742353.png" alt="image-20240923202742353"></p>
<p>auto_increment 从零开始自动增长 (列是数字的类型，并且是UNIQUE约束)</p>
<p> 这一列不指定id，或者id赋值null 不影响自增</p>
<h3 id="非空，唯一，主键，默认，检查约束"><a href="#非空，唯一，主键，默认，检查约束" class="headerlink" title="非空，唯一，主键，默认，检查约束"></a>非空，唯一，主键，默认，检查约束</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923220639875.png" alt="image-20240923220639875"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923220734860.png" alt="image-20240923220734860"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923220750052.png" alt="image-20240923220750052"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923220711866.png" alt="image-20240923220711866"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005154832392.png" alt="image-20241005154832392"></p>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>数据一致性 完整性</p>
<p>外键：连接两个表的数据</p>
<ul>
<li>（<strong>constraint</strong> foreKeyCons）<strong>foreign key</strong>(dept_id) <strong>references</strong> dept(id) 建表时</li>
<li>给当前表中的dept_id列定义了一个 名为 foreKeyCons 的外键约束，外键引用dept表的id列，dept_id就是外键</li>
<li>dept就是主表，必须存在，并且id是主键</li>
<li>因为有外键约束，所以不能直接删除主表的内容，</li>
</ul>
<p>建表以后对外键的操作：添加和删除。外键属于表的属性</p>
<ul>
<li><strong>alter table</strong> emp <strong>drop foreign key</strong> foreKeyCons</li>
<li><strong>alter table</strong> emp <strong>add constraint</strong> foreKeyCons <strong>foreign key</strong>(dept_id) <strong>references</strong> dept(id)</li>
</ul>
<h4 id="外键的删除、更新行为"><a href="#外键的删除、更新行为" class="headerlink" title="外键的删除、更新行为"></a>外键的删除、更新行为</h4><p>on update 更新   on delete 删除</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005155438576.png" alt="image-20241005155438576"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005155543394.png" alt="image-20241005155543394"></p>
<p>NOACTION RESTRICT 默认</p>
<p>CASCADE 主表变了，子表跟着变，主表删了，子表跟着没</p>
<p><strong>ON DELETE</strong> SET NULL 主表删了，子表把对应的值设为null，只支持删除操作，并且要求外键可以为null</p>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923224354382.png" alt="image-20240923224354382"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923224409160.png" alt="image-20240923224409160"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923224759437.png" alt="image-20240923224759437"></p>
<p>1-M 多的一方建立外键，少的一方作为主表，连接起来</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923225452261.png" alt="image-20240923225452261"></p>
<p>M-N 一起连到一张中间表，中间表做从表，建立外键，连到两张表的主键上</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923225514320.png" alt="image-20240923225514320"></p>
<p>一个商品可能属于不同订单，一个订单也可能有不同商品，所以用类似坐标的方式</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>管理DML语句，InnoDB引擎才支持事务</p>
<p>MySQL默认设置事务自动提交，也就是执行完自动COMMIT.</p>
<p>如果要显式开启事务要SET AUTOCOMMIT = 0;（以后的事务都需要手动提交）</p>
<p>或者 START Transaction /  BEGIN （临时开启一条事务）</p>
<p>COMMIT 提交事务 如果没有问题就提交</p>
<p>ROLLBACK 回滚事务 出现异常就要回滚事务到BEGIN处，即更改前</p>
<h3 id="四大特征-acid"><a href="#四大特征-acid" class="headerlink" title="四大特征 acid"></a>四大特征 acid</h3><p>一致性依赖于应用层，开发者。</p>
<p><strong>A</strong>tomic <strong>C</strong>onsistency <strong>I</strong>solation <strong>D</strong>urability</p>
<p>最小操作单位，不可分割；</p>
<p>完成时必须让所有数据都前后一致，由开发者指定，比如转账，金钱总额不能变化；</p>
<p>多个事务是互相隔离的，排除其他事务对本事务的影响（解决并发问题）；</p>
<p>事务对数据库的修改是持久的；</p>
<p>一什么是隔离性？</p>
<p>隔离性是数据库事务的四个基本属性之一，即 <strong>ACID</strong> 特性中的 “I”（Isolation）。隔离性保证了一个事务在未完成之前，它的操作对其他事务是不可见的，或者说部分可见（取决于隔离级别）。这样可以防止因并发执行而导致的数据问题。</p>
<h3 id="高并发下可能遇到的问题："><a href="#高并发下可能遇到的问题：" class="headerlink" title="高并发下可能遇到的问题："></a>高并发下可能遇到的问题：</h3><ol>
<li><p><strong>脏读</strong>（Dirty Read）：一个事务读取了另一个事务<strong>开始了但未提交</strong>的数据。如果另一个事务回滚或者提交，这些数据将无效，导致第一个事务读取了错误数据。</p>
<ol>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005213034469.png" alt="image-20241005213034469"></li>
</ol>
</li>
<li><p><strong>不可重复读</strong>（Non-repeatable Read）：在同一个事务中，前后两次读取相同的数据时，数据值发生了变化，因为另一个事务在两次读取之间<strong>修改并提交了该数据</strong>。</p>
<ol>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005213018573.png" alt="image-20241005213018573"></li>
</ol>
</li>
<li><p><strong>幻读</strong>（Phantom Read）：一个事务内，连续两次执行相同的查询（select）时，再次进行查询的时候真实的数据集已经发生了变化，但是A却查询不出来这种变化，因此产生了幻读。</p>
<ol>
<li>如果已经解决了12，将会发现：第一次查询没有结果，随后另一个事务插入数据并进行了提交，试图插入数据，会报错，提示不能有重复的主键，但是在第二次查询仍然没有结果，读不到别人已经提交的数据（repeatable read）但是别人提交的数据还在影响。</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005214729161.png" alt="image-20241005214729161"></li>
</ol>
</li>
</ol>
<h3 id="通过隔离性解决高并发问题："><a href="#通过隔离性解决高并发问题：" class="headerlink" title="通过隔离性解决高并发问题："></a>通过隔离性解决高并发问题：</h3><p>数据库系统通常提供多种<strong>事务隔离级别</strong>，每个级别可以解决一部分或全部并发问题。这些隔离级别定义了事务之间可见性规则，数据库可以根据应用场景选择适当的隔离级别来权衡性能与数据一致性。</p>
<p><code>select @@transaction_isolation</code> 查看当前的隔离级别</p>
<p><code>set session transaction isolation level read uncommitted</code>设置当前会话的隔离级别，</p>
<h3 id="SQL-标准定义的四种隔离级别"><a href="#SQL-标准定义的四种隔离级别" class="headerlink" title="SQL 标准定义的四种隔离级别"></a>SQL 标准定义的四种隔离级别</h3><ol>
<li><strong>读未提交（Read Uncommitted）</strong>：<ul>
<li><strong>脏读</strong>、<strong>不可重复读</strong> 和 <strong>幻读</strong> 都可能发生。</li>
<li>最低的隔离级别，事务可以读取未提交的数据。</li>
<li>使用场景：极高并发要求且对数据一致性要求不高的场景。</li>
</ul>
</li>
<li><strong>读已提交（Read Committed）</strong>：Oracle 默认<ul>
<li>解决脏读问题，但仍然可能出现不可重复读和幻读。</li>
<li>一个事务只能读取已提交的数据，保证不会读取到未提交的修改。</li>
<li>使用场景：大多数数据库系统的默认隔离级别，较好的性能和数据一致性的平衡。</li>
</ul>
</li>
<li><strong>可重复读（Repeatable Read）</strong>：MySQL 默认<ul>
<li>解决脏读和不可重复读问题，但幻读仍然可能发生。</li>
<li>在同一事务中，事务两次读取相同的数据，保证两次读取的结果一定相同。不会读取其他事务已经提交的数据，但是仍然无法避免其他事务的影响（比如重复插入相同主键失败但是查不到这条主键的数据）</li>
<li>使用场景：需要保证数据一致性、避免更新数据不一致的场景。</li>
<li>普通的select快照读不会受到其他事务update、insert的影响，但是自己执行update时会进行当前读，会把其他事务update、insert的数据更新成自己的版本号，下一次读取就会读到了。</li>
<li>幻读：尽管B事务在A事务还未结束的时候，增加了表中的数据，但是为了维护可重复读，A事务中不管怎么查询，是查询不到新增的数据的。但是对于真实的表而言，表中的数据是的的确确增加了，所以插入重复的主键会报错。</li>
</ul>
</li>
<li><strong>串行化（Serializable）</strong>：<ul>
<li>解决脏读、不可重复读和幻读问题。</li>
<li>最高的隔离级别，所有事务串行执行，完全避免并发导致的数据问题。要等先开始的事务执行完提交或者回滚，后开始的事务才能开始执行，完全放弃并发性。</li>
<li>使用场景：极端数据一致性要求的场景，但代价是性能较低，容易出现锁等待甚至死锁。</li>
</ul>
</li>
</ol>
<h3 id="隔离性和并发控制的关系"><a href="#隔离性和并发控制的关系" class="headerlink" title="隔离性和并发控制的关系"></a>隔离性和并发控制的关系</h3><ul>
<li><strong>锁机制</strong>：隔离性通常通过锁机制（例如行锁、表锁）实现。在高隔离级别下（如可串行化），数据库会使用更严格的锁定策略，确保其他事务在未提交前不能读取或修改被锁定的数据。</li>
<li>**多版本并发控制 (MVCC)**：有些数据库（如 PostgreSQL、MySQL 的 InnoDB 存储引擎）采用了多版本并发控制，允许在较高隔离级别下提高性能。MVCC 通过保存数据的多个版本，允许读取操作无需阻塞写入操作，从而在高并发下仍然能够提供一致的数据读取。</li>
</ul>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="通用语法"><a href="#通用语法" class="headerlink" title="通用语法"></a>通用语法</h3><ul>
<li>可以多行书写，分号结尾</li>
<li>可用空格和缩进增强可读性</li>
<li>MySQL的SQL语句不区分大小写，关键字建议大写</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>DDL definition 定义数据库对象(表、db，字段)</p>
<p>DML manipulation 操作数据，增删改</p>
<p>DQL query 查询</p>
<p>DCL control 创建用户，控制访问权限</p>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>control 控制数据库访问权限和管理数据库用户</p>
<h4 id="DCL-用户管理"><a href="#DCL-用户管理" class="headerlink" title="DCL-用户管理"></a>DCL-用户管理</h4><p>use mysql;</p>
<p>select * from user;</p>
<ul>
<li><p>创建用户 <strong>create user</strong> ‘itcast‘<strong>@</strong>‘localhost’ <strong>identified by</strong> ‘123456’ 密码123456用户名itcast 主机localhost</p>
</li>
<li><p>创建用户 <strong>create user</strong> ‘heima‘<strong>@</strong>‘%’ <strong>identified by</strong> ‘123456’ 密码123456用户名heima  任意主机均可访问</p>
</li>
<li><p>改密码 alter user ‘heima‘<strong>@</strong>‘%’ <strong>identified with</strong> mysql_native_password by ‘1234’ 改成1234</p>
</li>
<li><p>drop user ‘heima‘<strong>@</strong>‘%’  删除用户</p>
</li>
</ul>
<h4 id="DCL-控制权限"><a href="#DCL-控制权限" class="headerlink" title="DCL - 控制权限"></a>DCL - 控制权限</h4><ul>
<li>查询有什么权限：SHOW GRANTS FOR 用户@主机</li>
<li>授予用户权限：grant all on 数据库名.表名 to 用户@主机</li>
<li>撤销用户权限：revoke all on 数据库名.表名 from 用户@主机</li>
</ul>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><h4 id="数据库操作-database"><a href="#数据库操作-database" class="headerlink" title="数据库操作-database"></a>数据库操作-database</h4><ul>
<li><code>SHOW DATABASES;</code> 查询所有数据库（展示）</li>
<li><code>SELECT DATABASE();</code> 查询当前数据库（展示）</li>
<li><code>CREATE DATABASE if not exists name;</code>如果不存在则创建一个名为 name 的数据库，后面可以加<code>default charset + 字符集</code> <code>COLLATE 排序规则</code></li>
<li><code>DROP DATABASE IF EXISTS;</code> 如果存在则删除</li>
<li><code>USE name;</code> 使用名为name的数据库</li>
</ul>
<h4 id="表操作-查询-table"><a href="#表操作-查询-table" class="headerlink" title="表操作-查询 table"></a>表操作-查询 table</h4><ul>
<li><code>SHOW TABLES; </code> </li>
<li><code>DESC 表名;</code> 查询表结构</li>
<li><code>SHOW CREATE TABLE 表名;</code> 查询建表时候的信息</li>
</ul>
<h4 id="表操作-创建-table"><a href="#表操作-创建-table" class="headerlink" title="表操作-创建 table"></a>表操作-创建 table</h4><ul>
<li><p>```sql<br>use itcast;<br>create table tb_user(</p>
<pre><code>id int comment &#39;编号&#39;,
name varchar(50) comment &#39;姓名&#39;,
age int comment &#39;年龄&#39;,
gender varchar(1) comment &#39;性别&#39;
) comment &#39;用户表&#39;;
</code></pre>
<p>desc tb_user;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 表操作- 数据类型</span><br><span class="line"></span><br><span class="line">##### 数值类型：</span><br><span class="line"></span><br><span class="line">TINYINT-byte   SMALLINT-short MEDIUMINT-3 bytes INT/INTEGER-int </span><br><span class="line"></span><br><span class="line">BIGINT-long  FLOAT DOUBLE DECIMAL </span><br><span class="line"></span><br><span class="line">TINYINT UNSIGNED(0-255) 无符号的tinyint</span><br><span class="line"></span><br><span class="line">DOUBLE(4,1)4代表总位数 1代表小数部分的位数 </span><br><span class="line"></span><br><span class="line">##### 字符串类型：</span><br><span class="line"></span><br><span class="line">![image-20240920183842122](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920183842122.png)</span><br><span class="line"></span><br><span class="line">|          | char(10)     | varchar(10) |</span><br><span class="line">| -------- | ------------ | ----------- |</span><br><span class="line">| 最小长度 | 10           | 0           |</span><br><span class="line">| 最大长度 | 10           | 10          |</span><br><span class="line">| eg       | 性别、手机号 | 用户名      |</span><br><span class="line"></span><br><span class="line">##### 日期类型</span><br><span class="line"></span><br><span class="line">![image-20240920184425055](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920184425055.png)</span><br><span class="line"></span><br><span class="line">![image-20240926153912988](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926153912988.png)</span><br><span class="line"></span><br><span class="line">![image-20240926153925471](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926153925471.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 表操作-修改表属性</span><br><span class="line"></span><br><span class="line">**alter table** employee **add** nickname varchar(20) [comment] [约束]; **添加属性**</span><br><span class="line"></span><br><span class="line">**alter table** employee **modify** nickname char(20); **修改数据类型**</span><br><span class="line"></span><br><span class="line">**alter table** employee **change** nickname idCard char(18) [comment] [约束]; **改名字+数据类型** </span><br><span class="line"></span><br><span class="line">**alter table** employee **drop** nickname; **删除** </span><br><span class="line"></span><br><span class="line">**alter table** employee **rename to** emp; **改表名**  </span><br><span class="line"></span><br><span class="line">#### 表操作-删除</span><br><span class="line"></span><br><span class="line">**drop table** [if exists] 表名;   **删除整个表**</span><br><span class="line"></span><br><span class="line">**truncate table** 表名; **删除数据不删表结构**</span><br><span class="line"></span><br><span class="line">#### MySQL GUI</span><br><span class="line"></span><br><span class="line">SQLyog Navicat DataGrip</span><br><span class="line"></span><br><span class="line">### DML</span><br><span class="line"></span><br><span class="line">INSERT UPDATE DELETE </span><br><span class="line"></span><br><span class="line">#### 添加数据</span><br><span class="line"></span><br><span class="line">**insert into** 表名(属性1，属性2....) **values**（v1,v2...）指定属性</span><br><span class="line"></span><br><span class="line">**insert into** 表名 **values**（v1,v2...）所有</span><br><span class="line"></span><br><span class="line">字段和值一一对应，字符串和日期在单引号中</span><br><span class="line"></span><br><span class="line">**多条数据**: **values**</span><br><span class="line"></span><br><span class="line">​		（v1,v2...）,</span><br><span class="line"></span><br><span class="line">​		(v1,v2....) 不同条数据用逗号隔开</span><br><span class="line"></span><br><span class="line">#### 修改数据</span><br><span class="line"></span><br><span class="line">**update** employee **set** name = &#x27;itheima&#x27; **where** id=1;</span><br><span class="line"></span><br><span class="line">#### 删除数据</span><br><span class="line"></span><br><span class="line">**delete from** 表名 [where 条件] 无条件会删除整张表格的数据</span><br><span class="line"></span><br><span class="line">### DQL</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line"></span><br><span class="line">#### 基本查询</span><br><span class="line"></span><br><span class="line">##### 查询多个字段 </span><br><span class="line"></span><br><span class="line">**select** 字段1，字段2........ **from** 表名</span><br><span class="line"></span><br><span class="line">**select * from** 表名       通配符</span><br><span class="line"></span><br><span class="line">##### 设置别名</span><br><span class="line"></span><br><span class="line">**select** 字段1[**as** 别名1]，字段2[**as** 别名2].... **from** 表名 as可省略</span><br><span class="line"></span><br><span class="line">##### 去重</span><br><span class="line"></span><br><span class="line"> **select distinct** ........</span><br><span class="line"></span><br><span class="line">#### 条件查询 WHERE</span><br><span class="line"></span><br><span class="line">![image-20240920211218098](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920211218098.png)</span><br><span class="line"></span><br><span class="line">**select * from** employ where age **in**(12,45,43);</span><br><span class="line"></span><br><span class="line">**select * from** employ where name **like &#x27;__&#x27;**; 名字是两个字符  模糊查询 模糊匹配</span><br><span class="line"></span><br><span class="line">##### sql 模糊查询</span><br><span class="line"></span><br><span class="line">通配符：</span><br><span class="line"></span><br><span class="line">- %: %网% 查询含有网字的数据</span><br><span class="line"></span><br><span class="line">  ​     %网    查询以网字结尾的数据</span><br><span class="line"></span><br><span class="line">  ​      %网%车    查询含有 网 和 车的数据 有先后顺序</span><br><span class="line"></span><br><span class="line">- _ :   网_ 网开头 长度为2个字</span><br><span class="line"></span><br><span class="line">  ​	_ _ 网 长度为3个字 最后一个字是网</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">between and </span><br><span class="line"></span><br><span class="line">in </span><br><span class="line"></span><br><span class="line">is null </span><br><span class="line"></span><br><span class="line">#### 聚合函数 </span><br><span class="line"></span><br><span class="line">![image-20240920212134476](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920212134476.png)</span><br><span class="line"></span><br><span class="line">count(*)所有行 count(age)age非空的行数</span><br><span class="line"></span><br><span class="line">作用在列数据，**null不参与运算~**</span><br><span class="line"></span><br><span class="line">select count(age) from emp where workAddress = &#x27;西安&#x27;; </span><br><span class="line"></span><br><span class="line">位于select关键字之后 可以加where条件</span><br><span class="line"></span><br><span class="line">#### 分组查询 GROUP BY &amp; HAVING</span><br><span class="line"></span><br><span class="line">group by xxx 将具有相同xxx值的行归为一组，每一组执行聚合count  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**select** gender, count(*) **from** emp **&lt;u&gt;group by&lt;/u&gt;** gender;  计算行的数量，并按照gender分组</span><br><span class="line"></span><br><span class="line">- where 分组之前过滤 </span><br><span class="line">- **having** 对分组之后的结果进行过滤</span><br><span class="line">- where 不能对聚合函数判断， having可以，要判断聚合函数就要分完组</span><br><span class="line">- 执行顺序：where&gt;聚合函数&gt;having</span><br><span class="line">- 先用where筛选个体，然后分组，再对组内执行聚合函数，执行的结果可以再用having筛选</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 排序查询 ORDER BY</span><br><span class="line"></span><br><span class="line">ASC:ascending 默认</span><br><span class="line"></span><br><span class="line">DESC:descending</span><br><span class="line"></span><br><span class="line">- 语句的最后，添加 **order by** age **asc**;</span><br><span class="line">- **order by** age **desc** , entryDate; 先按照age降序，如果age相同在按照entryDate升序</span><br><span class="line"></span><br><span class="line">#### 分页查询 LIMIT</span><br><span class="line"></span><br><span class="line">查询xx页码</span><br><span class="line"></span><br><span class="line">LIMIT 起始索引，查询记录数</span><br><span class="line"></span><br><span class="line">每页是20条，第一页的起始数据是0，第二页的20</span><br><span class="line"></span><br><span class="line">limit 0,5 第一页，一页5条记录</span><br><span class="line"></span><br><span class="line">**limit** 5 **offset** 0 第一页 limit 5 offset 20 第五页</span><br><span class="line"></span><br><span class="line">#### 执行顺序</span><br><span class="line"></span><br><span class="line">先执行from 再用where过滤，然后用group by和having指定分组以及过滤，然后执行字段的select，接着是排序，最后分页</span><br><span class="line"></span><br><span class="line">在字段名，表名后加别名，看是否报错，验证上述顺序</span><br><span class="line"></span><br><span class="line">### [多表查询](C:\Users\Lenovo\OneDrive\本学期\数据库原理\多表查询练习.md)</span><br><span class="line"></span><br><span class="line">#### 表关系</span><br><span class="line"></span><br><span class="line">多对多：同一个学生可以选择多门课程，同一个课程也可以被多名学生选择，如果要描述他们之间的关系，添加一张中间表，里面的外键分别对应两张表的主键。</span><br><span class="line"></span><br><span class="line">一对多：多的一方建立外键，关联到少的主键。</span><br><span class="line"></span><br><span class="line">一对一：任意一方建立外键（UNIQUE），关联到另外的主键。</span><br><span class="line"></span><br><span class="line">![image-20241005161911780](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005161911780.png)</span><br><span class="line"></span><br><span class="line">#### 链接查询 JOIN</span><br><span class="line"></span><br><span class="line">##### 消除笛卡尔积</span><br><span class="line"></span><br><span class="line">![image-20241005162327168](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005162327168.png)</span><br><span class="line"></span><br><span class="line">##### 内连接</span><br><span class="line"></span><br><span class="line">只查询A和B相交的部分</span><br><span class="line"></span><br><span class="line">**select** *e*.name,*e*.gender,*d*.dname **from** *emp e*,*dept d* ... **where**    条件 (隐式) </span><br><span class="line"></span><br><span class="line">**select** * **from** *emp* **join** *dept* on     条件（显式）</span><br><span class="line"></span><br><span class="line">##### 外连接</span><br><span class="line"></span><br><span class="line">![image-20241005163112728](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005163112728.png)</span><br><span class="line"></span><br><span class="line">e.* emp的全部数据 </span><br><span class="line"></span><br><span class="line">from *A* left join B 查询*A* ∪ (A∩B)</span><br><span class="line"></span><br><span class="line">from *A* right join B 查询*B* ∪ (A∩B)</span><br><span class="line"></span><br><span class="line">##### 自链接</span><br><span class="line"></span><br><span class="line">一定要起别名</span><br><span class="line"></span><br><span class="line">![image-20241005163553452](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005163553452.png)</span><br><span class="line"></span><br><span class="line">没有必要专门搞一张领导表出来，如果要实现需求就要把一张表分成两张看，a的经理id等于b的id</span><br><span class="line"></span><br><span class="line">![image-20241005163805094](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005163805094.png)</span><br><span class="line"></span><br><span class="line">##### 外键？连接查询？</span><br><span class="line"></span><br><span class="line">在多表查询中，**连接查询**（JOIN）并不强制要求外键的存在。外键的作用是维护表之间的**参照完整性**，确保一张表中的某些值对应另一张表中的有效值。但在进行连接查询时，只要有可以用于关联两个表的字段（如主键和某个相应的列），就可以进行查询，而不需要一定设置外键。</span><br><span class="line"></span><br><span class="line">#### 联合查询</span><br><span class="line"></span><br><span class="line">把两条单表查询结果联合起来，字段数量必须一致</span><br><span class="line"></span><br><span class="line">UNION：自动根据主键去重</span><br><span class="line"></span><br><span class="line">UNION ALL: 不去重</span><br><span class="line"></span><br><span class="line">#### 子查询 按返回值分类</span><br><span class="line"></span><br><span class="line">##### **单行单列**：只返回一个**值** </span><br><span class="line"></span><br><span class="line">- ![image-20241005165024271](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005165024271.png)</span><br><span class="line"></span><br><span class="line">##### **单行多列**：返回的是一行数据</span><br><span class="line"></span><br><span class="line">- ![image-20241005S171121759](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005171121759.png)![image-20241005171132602](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005171132602.png)</span><br><span class="line"></span><br><span class="line">- 第一步返回的是**一行两列**的数据（salary，managerid），第二步的条件可以用where (salary, managerid) = 第一行的结果</span><br><span class="line"></span><br><span class="line">- &lt;a href=&quot;#extension&quot;&gt;多行多列扩展&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### **多行单列**：子查询返回的是多行单列的数据</span><br><span class="line"></span><br><span class="line">也就是同一个字段的值的集合，用括号括起来，最后查询可以如下操作符（操作对象是同一字段的值的集合）</span><br><span class="line"></span><br><span class="line">- in **等于**集合内部的某一个值</span><br><span class="line"></span><br><span class="line">- any/some **大于** any 只需大于最小值 小于any只需小于最大值**相当于存在量词∃** </span><br><span class="line">- all **相当于全称量词∀**</span><br><span class="line"></span><br><span class="line">- ![image-20241005165513314](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005165513314.png)</span><br><span class="line">- ![image-20241005165204726](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005165204726.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### **多行多列**： 虚拟表</span><br><span class="line"></span><br><span class="line">子查询返回的是多行多列数据，也就是虚拟表，从这张虚拟表中再和其他表进行连接查询。</span><br><span class="line"></span><br><span class="line">- **虚拟表**: 查询入职日期 在2011-11-11之后的员工信息和部门信息：先查入职在2011-11-11之后的员工信息，根据这些信息（虚拟表,也叫临时表）和部门表 连接查询</span><br><span class="line"></span><br><span class="line">  - ```sql</span><br><span class="line">    SELECT * FROM (select * from emp where join_date&gt;&#x27;2011-11-11&#x27;)e JOIN dept on e.dep_id = dept.id</span><br></pre></td></tr></table></figure></li>
<li><p><span id="extension"><strong>也可以作为单行多列的扩展</strong></span> in 关键字</p>
<ul>
<li>查询第一步返回的是<strong>多行多列</strong>的数据（salary，managerid），第二步的条件可以用where (salary, managerid) in 第一行的结果</li>
</ul>
</li>
</ul>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>可以直接被另一段程序调用的程序或代码——-常见MySQL内置函数</p>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>concat substring TRIM upper </p>
<p>LPAD(STR, 6, ‘0’) 左对齐，6位补0</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005154345722.png" alt="image-20241005154345722"></p>
<h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><p>ceil floor round rand（0-1随机数）mod</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005154156390.png" alt="image-20241005154156390"></p>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>date_add now curdate curtime datediff</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005154146380.png" alt="image-20241005154146380"></p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005153559225.png" alt="image-20241005153559225"></p>
<p><code>if(expr, caseTrue, caseFalse) expr = true</code> 返回caseTrue</p>
<p><code>ifnull(v1,v2)</code> v1=null 返回v2 空字符串不是null，null必须是什么都没有，v1不为null，则返回v1</p>
<p>case when</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005153230584.png" alt="image-20241005153230584"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005153515232.png" alt="image-20241005153515232"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">单例模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-20T00:00:00+08:00">2024-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 13:10:52" itemprop="dateModified" datetime="2025-04-27T13:10:52+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h1><h2 id="饿汉"><a href="#饿汉" class="headerlink" title="饿汉"></a>饿汉</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;<span class="keyword">return</span> instance;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程安全，但是可能造成资源的浪费</p>
<h2 id="懒汉-双重校验锁-DCL"><a href="#懒汉-双重校验锁-DCL" class="headerlink" title="懒汉 双重校验锁 DCL"></a><u><strong>懒汉 双重校验锁 DCL</strong></u></h2><ol>
<li>懒汉（延迟初始化） 要素：无参构造私有，进行判断<strong>「线程不安全」</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>原来的实现容易出现线程安全问题，改进：<code>getInstance()</code>变成 <code>synchronized</code> 方法。<ul>
<li><p><strong>锁范围太大</strong>：性能差，同步开销大。正常的执行路径不需要同步，只需要在创建实例的时候进行锁定即可。</p>
<ul>
<li><p>锁对象的选择：<strong>两个不相关的方法不要使用同一把锁</strong>。<strong>并且要注意不能出现死锁互相等待</strong>。</p>
</li>
<li><p>class：适用于保护静态变量或者类级别的共享资源，如果是为了保护某个对象的状态，就应该使用this。</p>
</li>
<li><p>this可能的问题：这边在内部使用this调用task.dosth()，另一边一个完全无关的业务使用 task做锁。</p>
</li>
<li><p>死锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Friend</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Friend</span><span class="params">(String name)</span> &#123;<span class="built_in">this</span>.name = name;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bow</span><span class="params">(Friend other)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; 正在向 &quot;</span> + other.name + <span class="string">&quot; 鞠躬&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟执行延迟</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            other.bowBack(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bowBack</span><span class="params">(Friend other)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; 正在回礼 &quot;</span> + other.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 死锁：a和b同时向对方bow，先都锁住了自己，bowBack的时候就会造成互相等待</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>未二次判空</strong>：线程 A 通过了条件判断，获取了锁，开始创建实例，就在同时，线程B也通过判断等待锁释放，在线程 A 出来之后线程B又进去创建了一次。</p>
</li>
<li><p><strong>指令重排序</strong>：Java 允许指令重排序，创建对象可以分为 1. 分配内存地址 2. 在这块内存地址创建对象 3. 将 对象的引用 instance 指向这块地址。如果2 3的顺序颠倒，线程 A 进去之后在完全创建对象之前就将 instance 置为 非null，线程B就会以为别人已经创建好了，直接返回 instance 引用，线程B拿到以后就开始使用，其中就会随机发生空指针或者状态异常等其他难以复现调试的bug。引入 volatile，表示这个变量不允许指令重排，且线程对它的写入会立刻对其他线程可见。避免发生拿到错误对象的情况</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance; <span class="comment">// 1. 禁止指令重排序</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton.class)&#123;<span class="comment">// 2. 锁的范围缩小</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;<span class="comment">// 3. 二次判空</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适用场景：</p>
<ul>
<li><strong>单例模式</strong>：延迟初始化全局唯一的对象。</li>
<li><strong>高并发资源初始化</strong>：如数据库连接池、线程池等。</li>
<li><strong>框架中的扩展点加载</strong>：如 Dubbo 的 <code>ExtensionLoader</code> 按需加载扩展类。</li>
</ul>
<h2 id="双重校验锁-与类解耦"><a href="#双重校验锁-与类解耦" class="headerlink" title="双重校验锁 (与类解耦)"></a><u>双重校验锁 (与类解耦)</u></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> T instance;</span><br><span class="line">    <span class="keyword">private</span> Supplier&lt;T&gt; supplier;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Holder</span><span class="params">(Supplier&lt;T&gt; supplier)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.supplier = supplier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = supplier.get();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变种</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> T instance;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span>&#123;</span><br><span class="line">        instance = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">// 在外部实现</span></span><br></pre></td></tr></table></figure>



<h2 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举 enum"></a><u><strong>枚举 enum</strong></u></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>天然线程安全，并且能够防止反射攻击</p>
<h2 id="Holder-静态内部类-（利用类加载机制）"><a href="#Holder-静态内部类-（利用类加载机制）" class="headerlink" title="Holder 静态内部类 （利用类加载机制）"></a><u><strong>Holder 静态内部类 （利用类加载机制）</strong></u></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Holder 在 Singleton 加载时并不会被加载，只有第一次调用 <code>getInstance()</code> 才会加载 Holder，然后创建单例。</p>
<h2 id="CAS-自旋"><a href="#CAS-自旋" class="headerlink" title="CAS 自旋"></a>CAS 自旋</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReference&lt;Singleton&gt; instance = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Singleton</span> <span class="variable">current</span> <span class="operator">=</span> instance.get();</span><br><span class="line">            <span class="keyword">if</span> (current != <span class="literal">null</span>) <span class="keyword">return</span> current;</span><br><span class="line">            current = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">if</span> (instance.compareAndSet(<span class="literal">null</span>, current)) &#123; <span class="comment">// 期望值为 null，设置值为 current</span></span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>无锁，非阻塞，线程安全。实现较为复杂，追求极致性能才考虑</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/13/classfile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/13/classfile/" class="post-title-link" itemprop="url">ClassFile</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-13 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-13T00:00:00+08:00">2024-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 10:57:48" itemprop="dateModified" datetime="2025-04-27T10:57:48+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ClassFile-字节码"><a href="#ClassFile-字节码" class="headerlink" title="ClassFile 字节码"></a>ClassFile 字节码</h1><p>Java 字节码是 Java 编译器将 Java 源代码编译成的 <strong>中间表示格式</strong>，它运行在 <strong>Java 虚拟机（JVM）</strong> 上。Java 字节码文件的扩展名为 <code>.class</code>，可以通过 <code>javap -c</code> 命令查看其内容。</p>
<p>任何一个Class文件都对应着唯一的一个类或接口的定义信息[1]，但是反过来说，类或 接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。本章中， 笔者只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”，实际上它完全不 需要以磁盘文件的形式存在。</p>
<p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文 件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数 据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[2]的方式分割 成若干个8个字节进行存储。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/09/13/classfile/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/11/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/11/JVM/" class="post-title-link" itemprop="url">JVM 介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-11 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-11T00:00:00+08:00">2024-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 11:25:06" itemprop="dateModified" datetime="2025-04-27T11:25:06+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JVM-是虚拟机吗？"><a href="#JVM-是虚拟机吗？" class="headerlink" title="JVM 是虚拟机吗？"></a>JVM 是虚拟机吗？</h1><h2 id="JVM-是什么？"><a href="#JVM-是什么？" class="headerlink" title="JVM 是什么？"></a>JVM 是什么？</h2><p><strong>Java Virtual Machine (JVM)</strong> 是 Java 平台的核心组件，它是一个**<mark>程序运行环境<mark>**，专门用来执行 Java 字节码（Bytecode）</p>
<p><strong>主要功能：</strong></p>
<ol>
<li><strong>跨平台支持</strong>：JVM 实现了 Java 的 “Write Once, Run Anywhere” 特性，使 Java 程序能够在不同操作系统上运行。</li>
<li>字节码解释和编译：JVM 将 Java 编译器生成的字节码（平台无关）转换为平台相关的机器代码，并执行。</li>
<li>内存管理：提供垃圾回收机制 (Garbage Collection, GC)。</li>
<li>安全性：内置安全检查机制，确保 Java 程序在受控环境中运行，防止恶意代码执行。</li>
</ol>
<h2 id="Hypervisor-VMM-是什么"><a href="#Hypervisor-VMM-是什么" class="headerlink" title="Hypervisor/VMM 是什么?"></a>Hypervisor/VMM 是什么?</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2560px-Hyperviseur.svg.png" alt="undefined"></p>
<p>Hypervisor 是一种一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件。也可叫做虚拟机监视器，即 VMM（ virtual machine monitor ）。</p>
<ul>
<li>当服务器启动并执行 Hypervisor 时，它会加载所有虚拟机客户端的操作系统同时会分配给每一台虚拟机适量的内存，CPU，网络和磁盘。它允许多个操作系统（称为<strong>Guest OS</strong>）在同一台物理机器（称为<strong>Host</strong>）上同时运行，每个操作系统被隔离在独立的虚拟机中。</li>
<li>Hypervisor 负责资源分配，如 CPU、内存和存储，协调着这些硬件资源的访问，而且在各个虚拟机之间施加防护，处理虚拟机之间的通信和安全隔离。</li>
</ul>
<h2 id="JVM-与-Hypervisor-VMM-的对比"><a href="#JVM-与-Hypervisor-VMM-的对比" class="headerlink" title="JVM 与 Hypervisor/VMM 的对比"></a>JVM 与 Hypervisor/VMM 的对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>JVM</th>
<th>Hypervisor/VMM</th>
</tr>
</thead>
<tbody><tr>
<td><strong>用途</strong></td>
<td>运行 Java 程序的虚拟环境</td>
<td>管理和运行多个虚拟机，每个虚拟机可运行不同操作系统</td>
</tr>
<tr>
<td><strong>虚拟化层级</strong></td>
<td>应用程序级虚拟化（针对 Java 字节码）</td>
<td>操作系统级虚拟化（针对硬件资源）</td>
</tr>
<tr>
<td><strong>管理对象</strong></td>
<td><strong>Java 字节码执行环境</strong></td>
<td>虚拟机管理和<strong>硬件资源虚拟化</strong></td>
</tr>
<tr>
<td><strong>依赖性</strong></td>
<td>必须安装在操作系统上，依赖操作系统环境</td>
<td>Type 1 可以直接运行在硬件上，Type 2 依赖操作系统</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>程序之间隔离性较弱，依赖 JVM 的安全机制</td>
<td>每个虚拟机互相独立，硬件级别隔离</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td>Oracle HotSpot VM、OpenJDK JVM</td>
<td>VMware ESXi、VirtualBox、KVM、Hyper-V</td>
</tr>
</tbody></table>
<ol>
<li>在 VMware ESXi 上创建一个虚拟机；</li>
<li>在虚拟机内部运行一个 Guest OS，比如 Linux；</li>
<li>在 Linux 中安装 Java 环境并运行 JVM。</li>
</ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/09/11/JVM/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/09/web-frontend/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/09/web-frontend/" class="post-title-link" itemprop="url">Web 前端</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-09 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-09T00:00:00+08:00">2024-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 13:58:40" itemprop="dateModified" datetime="2025-04-27T13:58:40+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web-development/" itemprop="url" rel="index"><span itemprop="name">web development</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p><strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage </p>
<p>结构：HTML</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/html/html-tutorial.html">HTML 教程 | 菜鸟教程 (runoob.com)</a> </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTML">HTML - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">HTML（超文本标记语言） | MDN (mozilla.org)</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926154402465.png" alt="image-20240926154402465"></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="基础标签"><a href="#基础标签" class="headerlink" title="基础标签"></a>基础标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926165557803.png" alt="image-20240926165557803"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926170603004.png" alt="image-20240926170603004"></p>
<h3 id="图片，音视频标签"><a href="#图片，音视频标签" class="headerlink" title="图片，音视频标签"></a>图片，音视频标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926170628097.png" alt="image-20240926170628097"></p>
<p>height weight 有 px 和百分比两种写法 src路径</p>
<p>URL 统一资源定位符 ../ 代表上一级目录 </p>
<h3 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926171504599.png" alt="image-20240926171504599"></p>
<p>a href=”url” </p>
<h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926171804215.png" alt="image-20240926171804215"></p>
<h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926171833199.png" alt="image-20240926171833199"></p>
<p>边框宽度+空白区间宽度</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926172249995.png" alt="image-20240926172249995"></p>
<h3 id="布局标签"><a href="#布局标签" class="headerlink" title="布局标签"></a>布局标签</h3><div></div>


<p>div块级标签，占一整行</p>
<p>span 只占据自己的空间</p>
<h3 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926193335810.png" alt="image-20240926193335810"></p>
<p>提交表单：方式get/post </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926193711640.png" alt="image-20240926193711640"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926194217797.png" alt="image-20240926194217797"></p>
<p><strong>点击框外文本就能让框处于被选中的状态</strong>：</p>
<p>如果要随着表单一起提交，就要起一个name</p>
<p>用<strong>label</strong>标签把用户名包裹起来，给输入框起一个唯一的id, label for “id” </p>
<p><strong>radio</strong>：单选按钮，让其name相同达到互斥效果，给他赋值value让服务器接收到有效信息</p>
<p>hidden 修改商品信息，id隐藏在表单里面,提交表单会上传</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928193146331.png" alt="image-20240928193146331"></p>
<p>submit reset button 如果要指定按钮名字 value</p>
<select>
    <option>123</option>
     <option>4567</option>
</select>


<p>textarea cols支持的列数 rows支持的行数</p>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>表现：CSS</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/css/css-tutorial.html">CSS 教程 | 菜鸟教程 (runoob.com)</a> </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CSS">CSS - 维基百科，自由的百科全书 (wikipedia.org) </a> </p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS：层叠样式表 | MDN (mozilla.org)</a></p>
<h2 id="导入HTML"><a href="#导入HTML" class="headerlink" title="导入HTML"></a>导入HTML</h2><p>在head标签中导入</p>
<p>内联，内部，外部</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926201958367.png" alt="image-20240926201958367"></p>
<p><code>&lt;link href=&quot;css路径&quot; rel=&quot;stylesheet&quot;&gt;</code></p>
<h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926202419738.png" alt="image-20240926202419738"></p>
<p>name唯一 class不唯一</p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>行为：javascript</p>
<p>什么是JS？</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/js/js-tutorial.html">JavaScript 教程 | 菜鸟教程 (runoob.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript">JavaScript——动态客户端脚本语言 - 学习 Web 开发 | MDN (mozilla.org)</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926202813408.png" alt="image-20240926202813408"></p>
<p>改变HTML 交互性</p>
<p>引入方式：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929131050714.png" alt="image-20240929131050714"></p>
<p>内部脚本,一般放在body下面</p>
<p>外部脚本, 不支持自闭合</p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul>
<li>区分大小写，分号可有可无</li>
<li>单行，多行注释</li>
<li>大括号表示代码块</li>
</ul>
<h3 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h3><ul>
<li>(window.)alert()弹出警告</li>
<li>document.write() 写入HTML页面</li>
<li>console.log() 写入浏览器控制台</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>var是变量，弱类型语言，可以存放不同类型的值</p>
<p>作用域：全局变量而且可以重复声明定义</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929132314244.png" alt="image-20240929132314244"></p>
<p>let 作用域只在代码块之内 局部变量 不可重复定义</p>
<p>const 常量</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929132717037.png" alt="image-20240929132717037"></p>
<p>number boolean string 空（null）默认初始值（undefined）</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929132954368.png" alt="image-20240929132954368"></p>
<p>全等于(===) 类型不一样返回false，更加严格</p>
<p>等于（==）判断类型是否一样，如果不一样则转换类型，然后才比较值</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>转为number：</p>
<ul>
<li>string<ul>
<li><code>var str = &quot;20&quot;   parseInt(str)</code></li>
<li>字面值转为数字，如果字面值不是数字，转为NaN</li>
</ul>
</li>
<li>boolean <ul>
<li>true-&gt;1 false-&gt;0</li>
</ul>
</li>
</ul>
<p>转成boolean</p>
<ul>
<li>number： 0和NaN转为false</li>
<li>string：空字符串转为false</li>
<li>null&amp;undefined：转为false</li>
</ul>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>if  switch  while  do while  </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929135023368.png" alt="image-20240929135023368"></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>关键字：function</li>
<li>返回值类型：不需要，直接return</li>
<li>参数列表：不用写参数类型</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929135258270.png" alt="image-20240929135258270"></p>
<p>实际调用可以有很多实参，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929135611640.png" alt="image-20240929135611640"></p>
<p>add(1,2) = 3</p>
<p>add(1)  = NaN</p>
<h2 id="JavaScript-对象"><a href="#JavaScript-对象" class="headerlink" title="JavaScript 对象"></a>JavaScript 对象</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">//访问数组</span></span><br><span class="line">arr1[<span class="number">1</span>]=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>与java不同，js的数组是集合，变长，变类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变长</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr3[<span class="number">5</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//索引为5的元素被赋值为10, 中间空出来的是undefined</span></span><br><span class="line"><span class="comment">//变类型</span></span><br><span class="line">arr3[<span class="number">10</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>长度：length</p>
<p>增：push(10) 加入值为10的元素</p>
<p>删：splice(0,3)从索引0开始，删除3个元素</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>length:长度</p>
<p>trim(): 去除字符串两端的空白字符</p>
<p>charAt(i):返回指定位置的字符</p>
<p>indexOf(c) 返回字符第一次出现的索引</p>
<h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;ZS&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">23</span>,</span><br><span class="line">    <span class="attr">eat</span>:<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;eat&quot;</span>+a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">eat</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>浏览器对象模型</p>
<p>Navigator Screen</p>
<h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><ul>
<li>窗口对象，使用window获取</li>
<li><code>alert()</code> 警告</li>
<li><code>confirm(&quot;对话框内容&quot;)</code> 确认/取消对话框<ul>
<li>有返回值，返回的是一个boolean</li>
</ul>
</li>
<li><code>setInterval(function,ms)</code> 定时器，循环执行function</li>
<li><code>setTimeout(function,ms)</code> 倒计时，只有一次</li>
</ul>
<p>根据变化的数字，产生固定个数的值，取模</p>
<h5 id="history"><a href="#history" class="headerlink" title="history"></a>history</h5><ul>
<li><p>通过window调取，window可省略</p>
</li>
<li><p><code>history.back()</code>加载前一个URL</p>
</li>
<li><p><code>history.forward()</code>加载下一个URL</p>
</li>
</ul>
<h5 id="location"><a href="#location" class="headerlink" title="location"></a>location</h5><ul>
<li>通过window调取，可省略</li>
<li><code>location.href</code> 设置当前的URL，可以实现跳转</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929143103867.png" alt="image-20240929143103867"></p>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>文档对象模型 W3C指定的XML HTML的规则</p>
<p>查文档</p>
<h4 id="document"><a href="#document" class="headerlink" title="document"></a>document</h4><h5 id="获取Element"><a href="#获取Element" class="headerlink" title="获取Element"></a>获取Element</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929143507450.png" alt="image-20240929143507450"></p>
<ul>
<li>id: 每个元素唯一的id</li>
<li>tagName: 标签名</li>
<li>class: 同类的，一个元素可以有多个类，一个类可以有多个元素</li>
<li>name: 用于radio checkbox 和 form表单 提交将输入的值发送</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;submit.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">value</span>=<span class="string">&quot;apple&quot;</span>&gt;</span> Apple</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">value</span>=<span class="string">&quot;banana&quot;</span>&gt;</span> Banana</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">value</span>=<span class="string">&quot;orange&quot;</span>&gt;</span> Orange</span><br></pre></td></tr></table></figure>

<h5 id="element通用方法"><a href="#element通用方法" class="headerlink" title="element通用方法"></a>element通用方法</h5><ul>
<li><p>element.<strong>style</strong> 获取style标签</p>
<ul>
<li>element.style.color = “red” 设置元素的style中 color属性为red</li>
<li></li>
</ul>
</li>
<li><p>element.<strong>innerHTML</strong> 改变两个标签内部的文本内容</p>
</li>
</ul>
<p>checkbox.<strong>checked</strong>=true 复选框设置为勾选  </p>
<h2 id="事件监听-EventListener"><a href="#事件监听-EventListener" class="headerlink" title="事件监听 EventListener"></a>事件监听 EventListener</h2><p>事件：发生在HTML元素上的事件，比如按钮被电击，鼠标移到元素之上，按下键盘按键</p>
<p>监听：侦测到事件，执行某些代码</p>
<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><h4 id="HTML标签的属性绑定"><a href="#HTML标签的属性绑定" class="headerlink" title="HTML标签的属性绑定"></a>HTML标签的属性绑定</h4><p>耦合度太高</p>
<h4 id="DOM元素属性绑定"><a href="#DOM元素属性绑定" class="headerlink" title="DOM元素属性绑定"></a>DOM元素属性绑定</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929145651893.png" alt="image-20240929145651893"></p>
<p>属性和函数绑定</p>
<h3 id="常见的事件"><a href="#常见的事件" class="headerlink" title="常见的事件"></a>常见的事件</h3><p><code>onblur</code>: 失去焦点</p>
<p><code>onfocus</code>: 获得焦点</p>
<p><code>onchange</code>:文本改变</p>
<p><code>onkeydown</code>: 按键</p>
<p><code>onmouseover</code>: 鼠标移动到指定对象上</p>
<p><code>onmouseout</code>：鼠标离开指定对象</p>
<p><code>onsubmit</code>: 表单验证，绑定的函数要有返回值，如果返回true则表单会被提交</p>
<p>核心宗旨：把一些交互逻辑更多地放到浏览器这边，减少服务端的压力</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929152143546.png" alt="image-20240929152143546"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929153455050.png" alt="image-20240929153455050"></p>
<p>绑定函数和事件</p>
<h1 id="Regex"><a href="#Regex" class="headerlink" title="Regex"></a>Regex</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/regexp/regexp-tutorial.html">正则表达式 – 教程 | 菜鸟教程 (runoob.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://regex101.com/">regex101: build, test, and debug regex</a> </p>
<p><strong>正则表达式（Regular Expression, regex）</strong>是一种用来描述和匹配字符串模式的工具，其原理基于形式语言和自动机理论。以下是正则表达式的主要原理和工作机制：</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ol>
<li><strong>字符匹配</strong>：正则表达式中的普通字符（如 <code>a</code>, <code>b</code>, <code>1</code>, <code>2</code>）直接匹配自身。例如，正则表达式 <code>abc</code> 将匹配字符串 “abc”。</li>
<li><strong>元字符和转义</strong>：元字符（如 <code>.</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>|</code>、<code>()</code>、<code>[]</code>、<code>&#123;&#125;</code>）有特殊含义。若要匹配这些字符本身，需要使用转义字符 <code>\</code>。例如，<code>\.</code> 匹配字符 <code>.</code>。</li>
<li><strong>字符类</strong>：使用方括号 <code>[]</code> 定义字符类，可以匹配其中任意一个字符。例如，<code>[abc]</code> 匹配 <code>a</code>、<code>b</code> 或 <code>c</code>。</li>
<li><strong>预定义字符类</strong>：常见的预定义字符类包括 <code>\d</code>（数字），<code>\w</code>（字母、数字或下划线），<code>\s</code>（空白字符），等价于 <code>[0-9]</code>、<code>[a-zA-Z0-9_]</code>、<code>[ \t\n\r\f\v]</code>。</li>
<li><strong>量词</strong>：量词用来指定匹配次数。例如，<code>*</code>（0 次或多次），<code>+</code>（1 次或多次），<code>?</code>（0 次或 1 次），<code>&#123;n&#125;</code>（恰好 n 次），<code>&#123;n,&#125;</code>（至少 n 次），<code>&#123;n,m&#125;</code>（n 到 m 次）。</li>
<li><strong>边界匹配</strong>：边界匹配符包括 <code>^</code>（行首），<code>$</code>（行尾），<code>\b</code>（单词边界），<code>\B</code>（非单词边界）。</li>
<li><strong>分组和捕获</strong>：使用圆括号 <code>()</code> 将正则表达式的一部分进行分组，可以进行捕获以便后续引用。例如，<code>(\d&#123;3&#125;)-(\d&#123;3&#125;)</code> 匹配 “123-456” 并捕获 “123” 和 “456”。</li>
<li><strong>选择和替代</strong>：使用管道符 <code>|</code> 表示选择，匹配左边或右边的表达式。例如，<code>a|b</code> 匹配 <code>a</code> 或 <code>b</code>。</li>
</ol>
<h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><ol>
<li><strong>编译</strong>：正则表达式首先被编译成一种内部表示形式。这个编译过程将解析正则表达式字符串，并将其转换为一个有限状态自动机（Finite State Machine, FSM）。</li>
<li><strong>匹配过程</strong>：<ul>
<li><strong>DFA（确定性有限自动机）</strong>：DFA 每个状态都有确定的转换，即每一个输入字符都会导致状态的唯一确定转换。DFA 的匹配过程效率高，但状态数可能较多。</li>
<li><strong>NFA（非确定性有限自动机）</strong>：NFA 允许从一个状态可以有多条转换边，匹配过程可能需要回溯。NFA 的构建比较简单，但匹配过程效率可能较低。</li>
</ul>
</li>
<li><strong>引擎</strong>：<ul>
<li><strong>NFA 引擎</strong>：基于回溯算法，尝试每一种可能的路径，直到找到匹配或失败。大多数现代正则表达式引擎（如 Perl、Python、JavaScript 等）使用 NFA 引擎。</li>
<li><strong>DFA 引擎</strong>：不使用回溯，直接通过状态转换进行匹配，通常速度较快，但实现较为复杂且内存消耗较大。</li>
</ul>
</li>
</ol>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li><strong>字符串查找和替换</strong>：在文本编辑器、IDE 等工具中，通过正则表达式进行复杂的搜索和替换操作。</li>
<li><strong>数据验证</strong>：验证输入数据的格式，如邮箱地址、电话号码等。</li>
<li><strong>文本处理</strong>：如日志解析、数据抽取等。</li>
</ul>
<p>通过对正则表达式的理解和应用，可以高效地进行字符串处理和模式匹配，极大地提高文本处理的灵活性和效率。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929153836955-1727921863704-1.png" alt="image-20240929153836955"></p>
<p>JS 正则表达式对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;^\\w&#123;6,12&#125;$&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^\w&#123;6,12&#125;$/</span></span><br><span class="line"></span><br><span class="line">regex.<span class="title function_">test</span>(str) <span class="comment">//正则表达式</span></span><br></pre></td></tr></table></figure>



<ul>
<li><code>\d</code>: 数字</li>
<li><code>\D</code>: 除了数字以外的字符</li>
<li><code>\s</code>:空白字符</li>
<li><code>\w</code>:字母+下划线+数字</li>
<li><code>[ ]</code>匹配单个字符 字符集合</li>
<li><code>[^1-3A-Z]</code>匹配一个除了1-3和大写字母的字符</li>
<li>尖角^只有在方框内部才是取反的意思。在外部表示匹配开头，<code>^abc</code>表示作为开头的abc，<code>BCD$</code>就是作为结尾的BCD<ul>
<li>匹配总共需要三个参数：要处理的字符串，匹配模式和正则表达式本身，可以看出处理的文本本身就是一个字符串。</li>
<li>如果没有多行匹配，^和$只会作用于<strong>整个文本</strong>的开头和结尾</li>
<li>multiline模式会匹配每一行</li>
</ul>
</li>
<li><code>/...../g</code>表示不要搜索一次就返回，去掉只显示第一个匹配的</li>
<li><code>/...../m</code>表示多行匹配</li>
<li><code>/...../i</code>表示忽略大小写</li>
<li><code>\b</code>:表示单词边界 <code>\bin</code>表示in在单词开头 <code>in\b</code>表示in在单词末尾</li>
<li><code>\B</code>:表示单词内部 <code>\Bin\B</code>表示in在单词中间 <code>\Bin</code>表示匹配前面有东西的in</li>
<li><code>.$</code>表示属于结尾的任意字符</li>
<li><code>\.$</code>表示属于结尾的点号</li>
</ul>
<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><ul>
<li><code>at+</code> atttt atttt 加号表示a t(重复一次或者多次)</li>
<li><code>at*</code> atttt atttt 星号表示a t(重复0次或者多次)</li>
<li><code>at?</code> at a 问号表示零次或者一次</li>
<li><code>at&#123;3,5&#125;</code> attt 表示t重复了3到5次</li>
<li><code>at&#123;3,&#125;</code> attt 表示t重复了3次以上 </li>
</ul>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul>
<li><code>(at)&#123;3&#125;</code> at整体重复了3次</li>
<li><code>(P|p)iece</code> Piece和piece</li>
<li><code>(d&#123;4&#125;)[-/_.](d&#123;1,2&#125;)[-/_.](d&#123;1,2&#125;)</code> 匹配年月日并且分成三组$1$2$3分别代表123组可以使用替换</li>
<li>如果不想分其中一个组<code>?:</code>表示仅代表一个整体不参与分组</li>
</ul>
<p>在 Java 的正则表达式中，如果你想忽略大小写匹配，可以使用以下几种方法：</p>
<h2 id="Java中忽略大小写的使用"><a href="#Java中忽略大小写的使用" class="headerlink" title="Java中忽略大小写的使用"></a>Java中忽略大小写的使用</h2><h3 id="使用-Pattern-CASE-INSENSITIVE-标志"><a href="#使用-Pattern-CASE-INSENSITIVE-标志" class="headerlink" title="使用 Pattern.CASE_INSENSITIVE 标志"></a>使用 <code>Pattern.CASE_INSENSITIVE</code> 标志</h3><p>通过调用 <code>Pattern.compile</code> 方法并传递 <code>Pattern.CASE_INSENSITIVE</code> 标志，可以忽略大小写。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译正则表达式时指定忽略大小写</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex, Pattern.CASE_INSENSITIVE);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(text);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-i-内联标志"><a href="#使用-i-内联标志" class="headerlink" title="使用 (?i) 内联标志"></a>使用 <code>(?i)</code> 内联标志</h3><p>在正则表达式的开头加上 <code>(?i)</code> 也可以忽略大小写。这是内联标志，不需要使用 <code>Pattern.compile</code>。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;(?i)hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (text.matches(regex)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>Pattern.CASE_INSENSITIVE</code></strong> 标志是在编译正则表达式时通过代码设置忽略大小写。</li>
<li><strong><code>(?i)</code></strong> 是在正则表达式内部直接指定忽略大小写，简单方便。</li>
</ul>
<h1 id="AJAX-JSON-个人笔记-Java-Web-服务端-pdf"><a href="#AJAX-JSON-个人笔记-Java-Web-服务端-pdf" class="headerlink" title="[AJAX, JSON](./个人笔记/Java Web 服务端.pdf)"></a>[AJAX, JSON](./个人笔记/Java Web 服务端.pdf)</h1><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/">Vue.js - 渐进式 JavaScript 框架 | Vue.js (vuejs.org)</a></p>
<h2 id="优点、原理"><a href="#优点、原理" class="headerlink" title="优点、原理"></a>优点、原理</h2><ul>
<li>免除DOM操作，简化书写</li>
<li>基于MVVM思想，双向绑定数据，使view能够绑定model的数据，而不是model变了</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929223353641.png" alt="image-20240929223353641"></p>
<p>model: plain JavaScript Objects     view: 模板</p>
<p>model，也就是数据，通过vue实例绑定到view上，model一更新，view上也会立即更新，</p>
<p>view，模板，通过vue实例的domListener，监听发生的dom事件，比如输入，通过listener将model处的数据实时更新。</p>
<p>数据全存在vm上，view能看到vm所有的数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929231110532.png" alt="image-20240929231110532"></p>
<p>在之前的JSON案例中，填写表单时，表单数据是model，<strong>在提交的时候</strong>，还要用<strong>繁琐的dom操作</strong>获取输入框中的值再赋给model。vue能在输入的时候就赋值给对象，如果从服务器接收到数据也能实时更新。</p>
<h2 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h2><p><a href=".%5C%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%5CHTML%5Cindex.html">index.html</a></p>
<p><strong>Vue3</strong> </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hello-vue&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>//div元素 唯一id为hello-vue 归属于demo类</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span>//v-model双向绑定,这个view中的值是多少, vue实例中数据就是多少</span><br><span class="line">&#123;&#123; message &#125;&#125;//插值表达式。这是 Vue.js 的模板语法，用于将 Vue 实例中的数据绑定到页面上。</span><br><span class="line">			 //vue实例中的数据变化时,这里也跟着变化。</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">HelloVueApp</span>=&#123; <span class="comment">//此处创建了一个自定义JS对象</span></span></span><br><span class="line"><span class="language-javascript">	<span class="title function_">data</span>(<span class="params"></span>)&#123;<span class="comment">//data是一个无参的函数,返回值是一个对象，里面包含了model数据</span></span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">message</span>: <span class="string">&#x27;Hello,Vue!&#x27;</span><span class="comment">//数据初值是Hello,Vue!字符串</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">	&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">HelloVueApp</span>).<span class="title function_">mount</span>(<span class="string">&quot;#hello-vue&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="comment">//Vue.createApp() 方法用于创建一个 Vue 应用实例，参数是一个包含组件选项的对象（这里是 HelloVueApp）。</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//.mount(&#x27;#hello-vue&#x27;) 方法将 Vue 应用实例挂载到页面中具有 id=&quot;hello-vue&quot; 的 DOM 元素上。</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令是带有前缀 <strong>v-</strong> 的特殊属性，用于在模板中表达逻辑。</p>
<p><strong>v-bind</strong>: 动态绑定一个或多个特性，或一个组件 prop。将 Vue 实例的数据绑定到 HTML 元素的属性上</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>简写：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-if</strong>: 条件渲染。根据表达式的值来条件性地渲染元素或组件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;seen&quot;</span>&gt;</span>Now you see me<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-for</strong>: 列表渲染。 用于根据数组或对象的属性值来循环渲染元素或组件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.text &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">//v-for=迭代对象 相当于增强for循环 </span><br><span class="line">//key帮助 Vue 在渲染列表时识别每个元素的唯一性。</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">HelloVueApp</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">items</span>: [ <span class="comment">//items数组包含多个匿名对象，这些匿名对象id和text两个属性</span></span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;Item 1&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&#x27;Item 2&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">text</span>: <span class="string">&#x27;Item 3&#x27;</span> &#125;</span></span><br><span class="line"><span class="language-javascript">      ]</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">HelloVueApp</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-model</strong>: 实现表单数据双向绑定：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;edit me&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-on</strong>: 事件监听器。 用于在 HTML 元素上绑定事件监听器，使其能够触发 Vue 实例中的方法或函数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>简写：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-show</strong>: 用于根据表达式的值来条件性地显示或隐藏元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hello-vue&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;showMessage = !showMessage&quot;</span>&gt;</span>显示/隐藏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">&quot;showMessage&quot;</span>&gt;</span>Hello Vue!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">HelloVueApp</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">showMessage</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">HelloVueApp</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#hello-vue&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>v-on指令能够监听事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">v-<span class="attr">on</span>:click=<span class="string">&quot;methodName&quot;</span></span><br><span class="line">@click=<span class="string">&quot;methodName&quot;</span></span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;counter += 1&quot;</span>&gt;</span>增加 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> app = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">counter</span>: <span class="number">0</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(app).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="案例简化-JavaScript中的this指针与回调函数"><a href="#案例简化-JavaScript中的this指针与回调函数" class="headerlink" title="案例简化-JavaScript中的this指针与回调函数"></a>案例简化-JavaScript中的this指针与回调函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//script</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">VueApp</span> = &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="attr">brands</span>:[]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">        axios.<span class="title function_">get</span>(<span class="string">&quot;http://localhost:8080/selectAllServlet&quot;</span>)</span><br><span class="line">         .<span class="title function_">then</span>(<span class="function">(<span class="params">resp</span>)=&gt;</span>&#123;<span class="variable language_">this</span>.<span class="property">brands</span> = resp.<span class="property">data</span>;&#125;);</span><br><span class="line">        <span class="comment">//brands是集合,用v-for遍历</span></span><br><span class="line">        <span class="comment">//回调函数是作为参数传递给另一个函数的函数，目的是在特定事件或条件发生时被调用。它通常用于异步操作、事件处理和在特定时机执行代码。箭头函数不会根据调用者创建this，只会寻找域中含有的this指针，mounted的this就是Vue实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">    	<span class="attr">show</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&quot;clicked&quot;</span>);<span class="comment">//跟提交的按钮绑定</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">createVueApp</span>(<span class="title class_">VueApp</span>).<span class="title function_">mount</span>(#app)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href=".%5C%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%5CHTML%5CanoymousThis.html">JavaScript中的this指针</a> 另外一种是在mounted中先定义一个var _this = this，这样_this 一定指代的是Vue实例</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>单个复选框：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checked&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>多个复选框：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;runoob&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Runoob&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;runoob&quot;</span>&gt;</span>Runoob<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;google&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Google&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;google&quot;</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;taobao&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Taobao&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;taobao&quot;</span>&gt;</span>taobao<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>选择的值为: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> app = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      checked : <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">checkedNames</span>: []</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(app).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h1><p><a target="_blank" rel="noopener" href="https://element.eleme.cn/#/zh-CN">Element - 网站快速成型工具</a></p>
<p>Vue组件库，可以快速构建网页</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930212139910.png" alt="image-20240930212139910"></p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930224145033.png" alt="image-20240930224145033"></p>
<h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930224317166.png" alt="image-20240930224317166"></p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930224538591.png" alt="image-20240930224538591"></p>
<p>对话框+表单</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/05/web-backend/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/05/web-backend/" class="post-title-link" itemprop="url">Web 后端 Java</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-05 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-05T00:00:00+08:00">2024-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 14:13:09" itemprop="dateModified" datetime="2025-04-27T14:13:09+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web-development/" itemprop="url" rel="index"><span itemprop="name">web development</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p><strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol </p>
<p>TCPIP协议四层架构的最上层 规定了服务器和浏览器之间传输数据的规则</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP">HTTP | MDN (mozilla.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">超文本传输协议 - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>基于TCP，面向连接，安全</li>
<li>基于请求-响应模型：1Request 1Response</li>
<li>HTTP是无状态协议，对事务处理没有记忆能力，每次RR都是独立的<ul>
<li>多次请求之间不能共享数据，java用会话技术（cookie session）解决这个问题</li>
<li>优点：速度快</li>
</ul>
</li>
</ul>
<h2 id="请求数据格式"><a href="#请求数据格式" class="headerlink" title="请求数据格式"></a><a href="#request">请求数据格式</a></h2><p><strong>请求行</strong>：第一行，<code>GET</code>(请求方式) 后面的<code>/</code>表示请求资源的路径，HTTP/1.1表示协议版本</p>
<p><strong>请求头</strong>：第二行开始 key: value形式</p>
<p><strong>请求体</strong>：POST请求的最后一部分，存放请求参数</p>
<p>GET请求参数在请求行中，没有请求体，参数大小有限制(URL长度限制) POST请求的参数在请求体中，参数大小无限制</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926220614547.png" alt="image-20240926220614547"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926221417729.png" alt="image-20240926221417729"></p>
<p><strong>Host</strong>: 请求的主机名</p>
<p><strong>User-Agent</strong>: 浏览器版本</p>
<p><strong>Accept</strong>: 浏览器能接受的资源类型，如text/* image/* */* </p>
<p><strong>Accept-Language</strong>: 浏览器的偏好语言</p>
<p><strong>Accept-Encoding</strong>: 浏览器支持的压缩类型</p>
<h2 id="响应数据格式"><a href="#响应数据格式" class="headerlink" title="响应数据格式"></a>响应数据格式</h2><p><strong>响应行</strong>：响应数据的第一行，HTTP/1.1表示协议版本，下一个是响应状态码，OK表示状态码描述</p>
<p><strong>响应头</strong>：keyvalue</p>
<p><strong>响应体</strong>：最后一部分，存放响应数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926221630980.png" alt="image-20240926221630980"></p>
<p><strong>Content-Type</strong>：响应内容类型，比如text/html image/jpeg</p>
<p><strong>Content-Length</strong>：响应内容长度（bytes）</p>
<p><strong>Content-Encoding</strong>：响应压缩算法 gzip等</p>
<p><strong>Cache-Control</strong>: 指示客户端如何缓存，例如max-age=300 表示最多缓存300s</p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926222005460.png" alt="image-20240926222005460"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926222320894.png" alt="image-20240926222320894"></p>
<p>200 OK 404资源不存在 500 服务器异常</p>
<p>Java程序中，如果直接用自带的javawebsocketAPI 代码会变得异常繁琐，要注意请求和响应的格式要求，因此要用web服务器软件进行开发—-Tomcat</p>
<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>Apache Tomcat web服务器是一个应用程序，封装http协议，不用对协议进行直接操作。类似的还有jetty，weblogic，ibm webSphere，部署web项目到服务器中</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61596145">JavaEE的13种核心技术规范： - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://tomcat.apache.org/">Apache Tomcat® - Welcome!</a> </p>
<h2 id="创建Web项目"><a href="#创建Web项目" class="headerlink" title="创建Web项目"></a>创建Web项目</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927151450747.png" alt="image-20240927151450747"></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Web-&gt;META-INF()</span><br><span class="line">     WEB-INF -&gt;classes(java文件夹和resources文件夹合并)</span><br><span class="line">     	     -&gt;lib(依赖jar包)</span><br><span class="line">             -&gt;web.xml(web项目的配置文件)</span><br><span class="line">     webapp中除了WEB-INF的其他文件</span><br></pre></td></tr></table></figure>



<p>using 骨架</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927151529348.png" alt="image-20240927151529348"></p>
<p>packaging 默认jar 改成web项目用的war </p>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>动态资源web开发技术</p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927162801770.png" alt="image-20240927162801770"></p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927163054997.png" alt="image-20240927163054997"></p>
<p>servlet对象，service方法由web服务器tomcat创建</p>
<p>WebServlet继承了Servlet接口</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927174147654.png" alt="image-20240927174147654"></p>
<ol>
<li>默认情况 servlet对象第一次被访问就被创建，通过改变loadOnStartup参数可以改变优先级</li>
<li>容器（tomcat）通过init方法初始化对象，只需要调用一次</li>
<li>每次请求servlet 容器都会调用servlet的service方法</li>
</ol>
<h2 id="Servlet-接口"><a href="#Servlet-接口" class="headerlink" title="Servlet 接口"></a>Servlet 接口</h2><p>定义了五个抽象方法：</p>
<ol>
<li><p><code>init(ServletConfig conf)</code>：默认情况下，servlet第一次被访问，容器创建servlet对象时，会调用init，只调用一次。改变WebServlet注解的参数loadOnStartup，可以控制在创建服务器的时候就创建servlet对象。</p>
</li>
<li><p><code>service(ServletRequest req,ServletResponse res)</code>: 每一次访问servlet就调用一次</p>
</li>
<li><p><code>destroy()</code>: 内存释放、服务器关闭时调用，只有一次</p>
</li>
<li><p><code>ServletConfig getServletConfig()</code>: servletconfig是容器调用init方法传进来的参数,可以在demo类中声明一个config成员变量，在init中赋值，然后在getConfig方法中返回</p>
</li>
<li><p><code>String getServletInfo() </code>: copyright information</p>
</li>
</ol>
<h2 id="Servlet-体系"><a href="#Servlet-体系" class="headerlink" title="Servlet 体系"></a>Servlet 体系</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927180225035.png" alt="image-20240927180225035"></p>
<p>Http doGet doPost</p>
<p>根据请求方式的不同分别处理，因为get的参数在请求行中，post的参数在请求体中。</p>
<p>httpservlet是servlet的实现类，实际上把service方法重写，接收请求参数req，如果req中是get方式，就执行doGet，如果是post就执行doPost  子类只需要重写doGetdoPost方法即可</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927181319844.png" alt="image-20240927181319844"></p>
<p>源码分析：原来的service方法重载，参数变成httpservletrequest和httpservletresponse ，原版的请求参数传进来，强制转换成httpservletrequest，然后吊用自己写好的重载service方法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927181753064.png" alt="image-20240927181753064"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927181825881.png" alt="image-20240927181825881"></p>
<h2 id="urlPattern"><a href="#urlPattern" class="headerlink" title="urlPattern"></a>urlPattern</h2><h3 id="一个servlet可以配置多个访问路径"><a href="#一个servlet可以配置多个访问路径" class="headerlink" title="一个servlet可以配置多个访问路径"></a>一个servlet可以配置多个访问路径</h3><p>urlPatterns = {“”,””}</p>
<h3 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927183113407.png" alt="image-20240927183113407"></p>
<ol>
<li>精确匹配 （优先级比目录匹配高）</li>
<li>目录匹配，通配符</li>
<li>扩展名匹配，<code>*.do</code> <code>aaa.do bbb.do</code>都可以访问，注意不能有斜杠</li>
<li>任意匹配，<code>/</code>优先级低于<code>/*</code><ul>
<li>/是tomcat默认生成的一个servlet，启动以后自动创建，是用来访问静态资源的</li>
<li>很危险，不要用</li>
</ul>
</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927183710215.png" alt="image-20240927183710215"></p>
<h3 id="web-xml配置"><a href="#web-xml配置" class="headerlink" title="web.xml配置"></a>web.xml配置</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927183912074.png" alt="image-20240927183912074"></p>
<h1 id="Request-amp-Response"><a href="#Request-amp-Response" class="headerlink" title="Request&amp;Response"></a>Request&amp;Response</h1><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927184223066.png" alt="image-20240927184223066"></p>
<p>request 获取请求数据</p>
<p>response 设置响应时的数据</p>
<p>request中含有用户输入的参数，response可以根据这个参数设置响应的数据，这样就完成了和用户交互的基本过程</p>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><h3 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927184637027.png" alt="image-20240927184637027"></p>
<p>ServletRequest和HttpServletRequest都是接口，不能实例化，定义了一些抽象方法作为规范。</p>
<p>我们的 servlet 重写了 service()方法的方法体，浏览器访问时，tomcat就要调用servlet的service方法。tomcat作为servlet容器，<strong>要解析请求报文，将其封装成req对象</strong>，送到servlet的service方法处作为参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是tomcat的程序</span></span><br><span class="line"><span class="comment">//tomcat做的是解析报文封装请求的操作，具体如何利用请求做出什么样的响应，则是开发者的工作</span></span><br><span class="line"><span class="type">MyServlet</span> <span class="variable">myServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyServlet</span>();</span><br><span class="line">myServlet.init()<span class="comment">//开发者重写</span></span><br><span class="line">myServlet.service(req,res)<span class="comment">//开发者重写</span></span><br></pre></td></tr></table></figure>

<p>所以Tomcat对接口进行了实现，查J2EE API</p>
<h3 id="获取请求数据"><a href="#获取请求数据" class="headerlink" title="获取请求数据"></a>获取请求数据</h3><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927192106826.png" alt="image-20240927192106826"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927192310996.png" alt="image-20240927192310996"></p>
<h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927192340229.png" alt="image-20240927192340229"></p>
<p>getHeader根据name来获取对应的信息</p>
<p>getHeader(“User-Agent”) 输出Mozilla/5.0 Chrome/91.0.4472.106</p>
<h4 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927192426370.png" alt="image-20240927192426370"></p>
<p>统一获取请求参数的方式？从而统一doGet和doPost方法内的代码</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927195026912.png" alt="image-20240927195026912"></p>
<p>getParameterMap 获取参数map 结构如上</p>
<p>getParameter 根据名称获取参数值</p>
<p>getParameterValues 根据名称获取参数值</p>
<h4 id="获取参数中文乱码"><a href="#获取参数中文乱码" class="headerlink" title="获取参数中文乱码"></a>获取参数中文乱码</h4><h5 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h5><p>设置输入流的字符集</p>
<p>底层是获取字符输入流BufferReader，所以<code>setCharacterEncoding(&quot;UTF-8&quot;)</code></p>
<h5 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h5><p>底层是字符串形式</p>
<p>浏览器发出请求的时候，会把中文字符转成URL编码，tomcat需要进行URL解码</p>
<h5 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h5><p>字符串按照编码方式转为二进制，每个字节转换为两个十六进制数，在前面加上%                                            </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240927214608765.png" alt="image-20240927214608765"></p>
<p>Tomcat底层将URL编码 解码为ISO-8859-1</p>
<h3 id="Forward-请求转发"><a href="#Forward-请求转发" class="headerlink" title="Forward 请求转发"></a>Forward 请求转发</h3><p>服务器内部资源跳转方式，转发的资源之间共享数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928140710653.png" alt="image-20240928140710653"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928140736371.png" alt="image-20240928140736371"></p>
<p>请求内部有参数（map形式），来源URL等信息</p>
<ul>
<li><code>setAttribute(String name, Object o)</code>把数据o 存到request域中，以key为键    </li>
<li><code>removeAttribute(String name)</code> 根据key删除键值对</li>
<li><code>Object getAttribute(String name)</code>根据key获取数据</li>
</ul>
<ul>
<li>地址栏路径不发生变化；</li>
<li>只能转发到服务器内部的资源；</li>
<li>浏览器发送一次请求，多个资源共享request数据</li>
<li>高效率</li>
</ul>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928142749615.png" alt="image-20240928142749615"></p>
<h3 id="设置响应数据"><a href="#设置响应数据" class="headerlink" title="设置响应数据"></a>设置响应数据</h3><ol>
<li>响应行：设置状态码</li>
<li>响应头：设置键值对</li>
<li>响应体：通过输出流输出数据</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928142944677.png" alt="image-20240928142944677"></p>
<h3 id="Redirect-重定向"><a href="#Redirect-重定向" class="headerlink" title="Redirect 重定向"></a>Redirect 重定向</h3><p>资源跳转方式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928143039892.png" alt="image-20240928143039892"></p>
<p>状态码 <strong>302</strong> 响应头：location: 虚拟目录/demo6</p>
<p><code>sendRedirect(String url)</code>发送重定向响应</p>
<p><code>setStatus(302)</code> </p>
<p><code>setHeader(&quot;location&quot;,&quot;https://www.google.com&quot;)</code> </p>
<p><code>setHeader(&quot;Content-type&quot;,&quot;text/html&quot;)</code> </p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>地址栏路径发生变化；</li>
<li>转发任意资源；</li>
<li>浏览器发送两次请求，不能在多个资源用request共享数据</li>
<li>效率低</li>
</ul>
<h4 id="路径问题-动态获取虚拟目录"><a href="#路径问题-动态获取虚拟目录" class="headerlink" title="路径问题 动态获取虚拟目录"></a>路径问题 动态获取虚拟目录</h4><p>如果浏览器使用，需要加虚拟目录</p>
<p>服务端使用就不需要加了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928145151848.png" alt="image-20240928145151848"></p>
<p>虚拟目录可以动态变化，所以尽量减少硬编码，减少耦合性</p>
<p>可以用<code>request</code>的<code>getContextPath()</code> 获取虚拟目录</p>
<h3 id="设置响应数据-1"><a href="#设置响应数据-1" class="headerlink" title="设置响应数据"></a>设置响应数据</h3><h4 id="字符数据"><a href="#字符数据" class="headerlink" title="字符数据"></a>字符数据</h4><p><code>getWriter().write(String s) </code>写入数据到资源中</p>
<p><code>setContentType(&quot;text/html;charset=utf-8&quot;)</code>   </p>
<p>细节：不用关闭流</p>
<p>乱码可以用响应头设置编码，tomcat8不乱码</p>
<h4 id="字节数据"><a href="#字节数据" class="headerlink" title="字节数据"></a>字节数据</h4><p>ServletOutputStream = request.getOutputStream()</p>
<h2 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h2><p>用来创建与数据库的连接会话,只需要一个即可，所以运用单例的设计模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryUtils</span>&#123;</span><br><span class="line">    SqlSessionFactory factory;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">    SqlSessionFactory <span class="title function_">getSqlSessionFactory</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h2 id="入门-1"><a href="#入门-1" class="headerlink" title="入门"></a>入门</h2><p>Java Server Pages 静态的页面嵌入动态的代码 简化开发</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928175143005.png" alt="image-20240928175143005"></p>
<p>JSP本质是servlet，把写标签等繁琐的工作交给jsp技术</p>
<h3 id="JSP脚本"><a href="#JSP脚本" class="headerlink" title="JSP脚本"></a>JSP脚本</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928175642020.png" alt="image-20240928175642020"></p>
<ol>
<li><p>service方法是访问到这个资源的时候调用</p>
</li>
<li><p>out.print() 是printWriter 调用的</p>
</li>
<li><p>被生成的jsp类直接包含</p>
</li>
</ol>
<p>截断java代码，中间插入html标签是可以的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928180319108.png" alt="image-20240928180319108"></p>
<p>出现HTML标签的地方可以理解为java程序代替你输入这些标签，最简单的字面意义上的代替功能，因此截断也没什么关系</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928180738621.png" alt="image-20240928180738621"></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928180843640.png" alt="image-20240928180843640"></p>
<h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928181558853.png" alt="image-20240928181558853"></p>
<h2 id="JSTL-标签库"><a href="#JSTL-标签库" class="headerlink" title="JSTL 标签库"></a>JSTL 标签库</h2><p><mark><strong>#{}</strong><mark></p>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928182101658.png" alt="image-20240928182101658"></p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928182210315.png" alt="image-20240928182210315"></p>
<p>brand.id 不是访问成员变量，是要调用get方法</p>
<p>自动调用getId()</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928182800258.png" alt="image-20240928182800258"></p>
<p>varStatus 计数器</p>
<p>status.count是计数从1开始，status.index是从1开始</p>
<h4 id="普通for循环"><a href="#普通for循环" class="headerlink" title="普通for循环"></a>普通for循环</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928183033816.png" alt="image-20240928183033816"></p>
<p>Java虚拟机负责存储变量信息，jsp只负责展示与变量相关的信息，因此不用重启服务器，</p>
<h2 id="Servlet-JSP开发"><a href="#Servlet-JSP开发" class="headerlink" title="Servlet+JSP开发"></a>Servlet+JSP开发</h2><p><strong>业务逻辑层</strong>本质上是对dao层的封装，包括创建session，创建mapper，mapper调用dao方法，事务等。</p>
<p>每个servlet都是资源，浏览器能够通过网址或者表单的形式发出请求，servlet根据request的参数进行一系列业务逻辑操作，将返回的结果转发给jsp页面。</p>
<p>jsp本质也是一个servlet，将请求中的参数打印出来的同时还能生成html标签，浏览器就能通过html标签解析出网页。</p>
<p>在修改页面改了一个数据，提交表单到updateServlet，updateServlet进行业务操作，完成后，把包含参数的请求转发到 浏览所有数据 的showAll.jsp页面，jsp本质是servlet，负责打印标签和数据。</p>
<h1 id="MVC-设计模式"><a href="#MVC-设计模式" class="headerlink" title="MVC 设计模式"></a>MVC 设计模式</h1><p><strong>Model</strong>：接受Controller发出的指令，与数据库交互，增删改查，返回数据给Controller</p>
<p><strong>View</strong>：接受Controller发出的数据（Model给的）渲染页面，返回HTML页面给Controller</p>
<p><strong>Controller</strong>：接受客户端的数据请求，返回给客户端HTML页面，同时与model和view交流，充当Model和View之间的桥梁。</p>
<p>Model和View之间一个是处理数据，一个是呈现数据，二者可以专注于各自的事情</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240919202449018-1727923726251-1.png" alt="image-20240919202449018"></p>
<p>Servlet controller </p>
<p>JSP View </p>
<p>JavaBean Model </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928183538077-1727923726251-2.png" alt="image-20240928183538077"></p>
<p>三层架构</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928183903472-1727923726251-3.png" alt="image-20240928183903472"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928183924963-1727923726251-4.png" alt="image-20240928183924963"></p>
<h1 id="Cookie-amp-Session-amp-JWT"><a href="#Cookie-amp-Session-amp-JWT" class="headerlink" title="Cookie&amp;Session&amp;JWT"></a>Cookie&amp;Session&amp;JWT</h1><h2 id="会话跟踪技术"><a href="#会话跟踪技术" class="headerlink" title="会话跟踪技术"></a>会话跟踪技术</h2><p>浏览器打开一个网站就是会话建立的过程，其中可以<strong>包含多次请求和响应</strong>，服务段需要区分不同的会话，判断多次请求是否来自统一浏览器，以便在同一次会话的<strong>多次请求之间，共享数据。</strong></p>
<p><strong>HTTP协议是无状态</strong>的，为了最佳的请求响应效率，牺牲了存储记忆数据的功能，每次请求都被视作新的请求，因此要跟踪回话实现会话内数据共享。</p>
<p>本质是将数据存储在一端</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928201532521.png" alt="image-20240928201532521"></p>
<p>客户端：<strong>Cookie</strong> </p>
<p>服务端：<strong>Session</strong> </p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>客户端的会话技术，保存数据到客户端，每次请求都携带cookie数据进行访问。客户端的记忆</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928202227465.png" alt="image-20240928202227465"></p>
<p>响应的时候setcookie，请求的时候带着cookie</p>
<h3 id="发送cookie"><a href="#发送cookie" class="headerlink" title="发送cookie"></a>发送cookie</h3><p>创建Cookie，设置键值对</p>
<p>response调用addCookie方法发送cookie</p>
<h3 id="获取cookie"><a href="#获取cookie" class="headerlink" title="获取cookie"></a>获取cookie</h3><p>request对象调用getCookies 接收cookies</p>
<p>for循环遍历，getName和getValue</p>
<h2 id="cookie的原理"><a href="#cookie的原理" class="headerlink" title="cookie的原理"></a>cookie的原理</h2><p><strong>基于HTTP协议</strong></p>
<p>响应的时候，做好cookie传回去，<strong>响应头</strong>setCookie:username=zs</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928204006874.png" alt="image-20240928204006874"></p>
<p>浏览器再次请求的时候，<strong>请求头</strong>中cookie:username=zs</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928204020606.png" alt="image-20240928204020606"></p>
<h3 id="cookie使用细节"><a href="#cookie使用细节" class="headerlink" title="cookie使用细节"></a>cookie使用细节</h3><h4 id="存活时间"><a href="#存活时间" class="headerlink" title="存活时间"></a>存活时间</h4><p><strong>默认</strong>存储在浏览器内存中，关闭浏览器会释放内存，销毁cookie</p>
<p>setMaxAge(int seconds) 正数：写入浏览器硬盘，到时间自动删除；负数：写入内存，自动销毁；零：删除对应cookie</p>
<p>30天内免登录</p>
<p>cookie是键值对 </p>
<h4 id="cookie存储中文"><a href="#cookie存储中文" class="headerlink" title="cookie存储中文"></a>cookie存储中文</h4><p>可以把字符串用URL编码</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928205018701.png" alt="image-20240928205018701"></p>
<p>服务端的记忆功能</p>
<p>request.getSession();</p>
<p>set Attribute 存到session域中</p>
<p>get Attribute</p>
<p>session是键值对集合，存储在服务器</p>
<p><strong>Session基于Cookie实现</strong> </p>
<p>如何保证多个浏览器不是同一个session？发送一个sessionID的cookie，作为唯一标识，浏览器请求的时候会带着cookie。响应的时候创建一个session，把浏览器唯一对应的session对象id作为cookie发过去，再次请求的时候带着sessionid作为cookie就能找到对应的session对象去存储</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928210309806.png" alt="image-20240928210309806"></p>
<p>识别sessionid如果已经创建过了就不再创建</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928210431476.png" alt="image-20240928210431476"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928210448553.png" alt="image-20240928210448553"></p>
<h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><h4 id="session-钝化、活化"><a href="#session-钝化、活化" class="headerlink" title="session 钝化、活化"></a>session 钝化、活化</h4><p>钝化：服务器正常关闭，tomcat自动把session存到硬盘</p>
<p>活化：服务器开启，从session文件读取</p>
<p>浏览器关闭后中断会话，session不是同一个</p>
<h4 id="session-销毁"><a href="#session-销毁" class="headerlink" title="session 销毁"></a>session 销毁</h4><ul>
<li>自动销毁web.xml sessionconfig 时间默认为30分钟</li>
<li>手动销毁：登出</li>
</ul>
<h2 id="Cookie-vs-Session"><a href="#Cookie-vs-Session" class="headerlink" title="Cookie vs. Session"></a>Cookie vs. Session</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928220229036.png" alt="image-20240928220229036"></p>
<p>安全性，长期存储</p>
<p>cookie保证用户在未登录情况下的身份识别</p>
<p>session存储用户登录以后的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928225946421.png" alt="image-20240928225946421"></p>
<h3 id="登录系统DEMO"><a href="#登录系统DEMO" class="headerlink" title="登录系统DEMO:"></a>登录系统DEMO:</h3><p>login.jsp页面</p>
<p>登录成功存储用户信息，并且要重定向到另一个brand.jsp页面，两次会话共享信息，考虑安全性，session</p>
<p>登录失败，转发回登录页面，把错误 信息加进request域中，jsp登录页面显示的是错误信息</p>
<p>记住用户登录信息：登录成功并且勾选了复选框（发送复选框的value参数，Object.equals或是”1”.equals（remember））创建username和password的cookie并发送到浏览器。修改login.jsp：拿到请求中的cookies，分别把响应的数据填到页面的username和password中。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928223745507.png" alt="image-20240928223745507"></p>
<h3 id="用户注册DEMO"><a href="#用户注册DEMO" class="headerlink" title="用户注册DEMO:"></a>用户注册DEMO:</h3><p>reg.jsp </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928223916558.png" alt="image-20240928223916558"></p>
<p>if(布尔表达式){</p>
<p>}</p>
<p>return 布尔表达式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928231442349.png" alt="image-20240928231442349"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928231455396.png" alt="image-20240928231455396"></p>
<p>展示验证码：servlet输出的验证码作为img src显示在HTML静态页面上，写js脚本把点击事件设置成重新请求一次，每次请求的路径不同 (?号后面加时间)，防止浏览器缓存</p>
<p>生成验证码和提交注册表单一共需要两次请求，是不同的servlet在处理，所以服务器要在生成的时候将验证码存到session中，提交注册表单的时候再次从session中访问数据看是否一致。存到cookie中会直接被抓取然后攻击，失去了验证码的功能</p>
<p>if else if直接return就不用else了</p>
<p>checkcodeServlet 生成code，输出到自己的输出流中  </p>
<h2 id="Token-Json-Web-Token"><a href="#Token-Json-Web-Token" class="headerlink" title="Token(Json Web Token)"></a>Token(<u>J</u>son <u>W</u>eb <u>T</u>oken)</h2><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/995894#comment">JWT详细讲解(保姆级教程)-阿里云开发者社区 (aliyun.com)</a></p>
<h3 id="token-cookie-session"><a href="#token-cookie-session" class="headerlink" title="token cookie session"></a>token cookie session</h3><h4 id="Cookie-1"><a href="#Cookie-1" class="headerlink" title="Cookie"></a>Cookie</h4><p>本质是键值对，客户端发起请求，服务端响应会把包含着用户信息的set-cookie 加入响应头，客户端收到set-cookie，下次发送请求，请求头中会带着包含相同内容的cookie，服务端只需要根据cookie响应对应用户的资源。</p>
<p>局限：数据直接存放在浏览器端内存，安全性差，</p>
<p>优化：把set-cookie内容除了正常的cookie内容再加一段报文鉴别码，使用服务器自己的私钥进行签名，</p>
<p>优点：存储期限长</p>
<h4 id="Session-1"><a href="#Session-1" class="headerlink" title="Session"></a>Session</h4><p>以cookie为基础，本质是一个对象，每个session可以通过唯一的sessionID进行访问，客户端发起请求，服务端会把包含着sessionID信息的set-cookie响应给客户端，客户端下次发送请求，请求头中会带着包含着sessionID信息的cookie，服务端根据sessionID找到对应的session，响应对应用户的资源</p>
<p>优点：数据完全存储在服务端内存，安全性很高，</p>
<p>缺点：</p>
<p>最重要的是，session只支持单体服务器，session拷贝效率低，</p>
<p>默认不支持跨域名，但是不同域名可能是会共享用户信息的，</p>
<p>因此在集群部署，分布式应用，前后端分离的背景下，session已经不再适用</p>
<h4 id="JsonWebToken"><a href="#JsonWebToken" class="headerlink" title="JsonWebToken"></a>JsonWebToken</h4><p>base64: 将原来的字符串二进制化，然后重新分成每6位一组，6位对应有64个索引，分别对应0-9和所有大小写英文字母</p>
<p>用户信息保存在浏览器端内存，本质就是一条加密字符串。</p>
<h5 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h5><p>RSA—单向陷门函数：加密数字5，公钥是7,33 ，<strong>5</strong>^7^ mod 33 = <mark>14<mark>，解密使用公钥，x^7^ mod 33 = <mark>14<mark> 的数字有无数个，也就无法推算出具体的x，只能穷举。如果有了私钥3,33，<mark>14<mark>^3^ mod 33 = <strong>5</strong> 很容易就能算出原数字5</p>
<p>加密和解密都用同一种算法，但不是逆向。</p>
<p><strong>签名算法：</strong> </p>
<p>HS256：$A+H(A,K)$ 签发和验证都使用同一个密钥，只适用于单体应用。H表示密钥拼接在报文后进行哈希。S表示SHA256</p>
<p>RS256, ES256：$A+D(H(A))$ 签发用私钥，验证用公钥，适合分布式架构，安全性更高。R,E分别表示RSA与ECDSA，S表示SHA256。</p>
<h5 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h5><p>header(base64-encoded).payload(base64-encoded).signature(HMACSHA256-encoded)</p>
<ul>
<li>header 用于定义token类型以及加密算法（非对称），用base64编码，相当于明文</li>
<li>payload 用于装载要传输的用户数据，用base64编码，相当于明文<ul>
<li>附加一些预定义声明</li>
<li>iss: 签发者issuer</li>
<li>sub: jwt所面向的用户subject</li>
<li>aud: 接收jwt的一方audience</li>
<li>iat: jwt的签发时间 issued at</li>
<li>exp: jwt的过期时间，必须大于签发时间  expire</li>
<li>nbf: 定义在什么时间之前，该jwt都是不可用的. not valid before</li>
<li>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击 jwtid</li>
</ul>
</li>
</ul>
<p><code>注意:对于已签名的Token，这些信息虽然受到保护，不会被篡改，但任何人都可以阅读。除非加密，否则不要将机密信息放在 JWT 的有效负载或头元素中。</code> </p>
<ul>
<li>signature = HS256…(header(base64)+payload(base64)+secret)私钥 ，用header指定的算法进行加密，鉴权核心</li>
</ul>
<p>用户请求通过鉴权成功，<strong>服务端通过私钥签发JWT字符串</strong>，通过响应返回给用户，用户后续请求会在请求头中添加一个authorization:token的键值对。</p>
<p>再次请求，鉴权成功，然后将JWT根据secret进行解密，验证此JWT是否有效。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241030152447734.png" alt="image-20241030152447734"></p>
<p>假如其他人偶然间拿到了JWT，然后篡改JWT，服务器拿私钥解密JWT，会发现信息被篡改。</p>
<h1 id="Filter-amp-Listener"><a href="#Filter-amp-Listener" class="headerlink" title="Filter&amp;Listener"></a>Filter&amp;Listener</h1><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>拦截资源请求</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928234937677.png" alt="image-20240928234937677"></p>
<h3 id="入门-2"><a href="#入门-2" class="headerlink" title="入门"></a>入门</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928235049041.png" alt="image-20240928235049041"></p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929000311150.png" alt="image-20240929000311150"></p>
<p>先访问完资源，然后执行放行后的逻辑</p>
<p>放行前对request进行处理，放行后对response进行处理</p>
<h3 id="使用细节-1"><a href="#使用细节-1" class="headerlink" title="使用细节"></a>使用细节</h3><h4 id="拦截路径"><a href="#拦截路径" class="headerlink" title="拦截路径"></a>拦截路径</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929000603427.png" alt="image-20240929000603427"></p>
<p>拦截的是具体的资源，不是说filter访问哪个路径</p>
<h4 id="Filter链"><a href="#Filter链" class="headerlink" title="Filter链"></a>Filter链</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929000822547.png" alt="image-20240929000822547"></p>
<p>执行顺序：类名字符串自然排序</p>
<h4 id="案例：登录验证才可以访问"><a href="#案例：登录验证才可以访问" class="headerlink" title="案例：登录验证才可以访问"></a>案例：登录验证才可以访问</h4><p>第一次请求，没有登录，跳转到登录页面</p>
<p>filter要看是否登录，登录成功就把username pswd存到客户端session中，下一次请求的时候就验证session是否有值，没有值就继续</p>
<p>从服务端获取用户的session，session存储登录密码，如果session</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929011626311.png" alt="image-20240929011626311"></p>
<p>针对某个资源设置filter，第一次访问被拒绝，<strong>转发</strong>到login页面，此时网址不会变化，就会把这个资源的网址缓存成login页面的样式，login成功以后如果再次访问这个资源，会展示login页面，只有刷新一下才能解决这个问题</p>
<h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929121700747.png" alt="image-20240929121700747"></p>
<h1 id="HTML-CSS-JavaScript-Java-Web-前端-md"><a href="#HTML-CSS-JavaScript-Java-Web-前端-md" class="headerlink" title="[HTML+CSS+JavaScript](.\Java Web 前端.md)"></a>[HTML+CSS+JavaScript](.\Java Web 前端.md)</h1><h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a><span id=ajax>AJAX</span></h1><p>异步JS和XML <strong>A</strong>synchronous <strong>J</strong>avaScript <strong>A</strong>nd <strong>X</strong>ML </p>
<p><strong>AJAX作用1：与服务器交换数据，前后端分离</strong></p>
<ul>
<li>Servlet+JSP开发：HTML是静态的，要想展示动态的数据必须要让servlet根据请求中的参数来手动打印页面（JSP），服务端负担较重</li>
<li>AJAX+HTML: 替换JSP页面 ，AJAX给服务器<strong>发送请求</strong>，<strong>获取服务器响应</strong>的数据，展示给浏览器</li>
</ul>
<p><strong>AJAX作用2：异步交互</strong></p>
<p>不刷新<strong>整个页</strong>面也能与服务器交换数据，更新部分网页，如搜索联想，用户名是否可用校验</p>
<p>用户名按照一定的规则：直接本地编写js脚本即可，如果用户名不能和已有的重复，还应该发送请求，接收服务器响应回来的结果（数据库中是否重名）</p>
<h2 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929161209624.png" alt="image-20240929161209624"></p>
<p>异步操作使 用户可以在等待响应的同时继续与页面互动，这使得应用程序更具响应性</p>
<p>不用刷新整个页面，只跟服务器请求需要的数据，而不是整个页面，AJAX可以减少服务器的负担和网络流量，提高响应速度。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929161455819.png" alt="image-20240929161455819"></p>
<p>URL 全路径，前后端完全分离</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929161832460.png" alt="image-20240929161832460"></p>
<h2 id="异步请求案例"><a href="#异步请求案例" class="headerlink" title="异步请求案例"></a><span id="request">异步请求案例</span></h2><p>现在有这样一个需求，在浏览器填完了一个用户名，要把用户名发送到服务器的某个servlet，servlet根据用户名查询是否重复，并把数据传回到浏览器。</p>
<p>首先应该让失焦事件绑定函数，函数中要查询用户名。</p>
<p>设置 提示重复字句的style属性为不可见（正常情况下不可见）ajax根据传回的数据为true or false，改变 提示重复字句的style属性，如果是，则设置可见，如果否，则设置不可见。</p>
<p>具体流程？可以通过以下步骤：</p>
<h2 id="前端发送请求"><a href="#前端发送请求" class="headerlink" title="前端发送请求"></a>前端发送请求</h2><p>使用 JavaScript（比如 <code>XMLHttpRequest</code> 或 Fetch API）发送请求：</p>
<ul>
<li><strong>GET 方法</strong>（URL 参数字符串）：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>).<span class="property">value</span>;</span><br><span class="line">xhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://example.com/checkUsername?username=&quot;</span> + <span class="built_in">encodeURIComponent</span>(username));</span><br><span class="line">xhttp.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>POST 方法</strong>（请求体）：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>).<span class="property">value</span>;</span><br><span class="line">xhttp.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;http://example.com/checkUsername&quot;</span>);</span><br><span class="line">xhttp.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">xhttp.<span class="title function_">send</span>(<span class="string">&quot;username=&quot;</span> + <span class="built_in">encodeURIComponent</span>(username));</span><br></pre></td></tr></table></figure>

<h3 id="服务器端处理"><a href="#服务器端处理" class="headerlink" title="服务器端处理"></a>服务器端处理</h3><p>在 Servlet 中处理请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="comment">// 查询数据库检查用户名是否重复</span></span><br><span class="line">    <span class="comment">// 返回结果到浏览器</span></span><br><span class="line">    response.setPatameter...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    doGet(request,response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h3><ul>
<li><strong>GET</strong>：参数通过 URL 传递，适合获取数据，但不适合传递敏感信息，因为 URL 可见，且请求长度有限。</li>
<li><strong>POST</strong>：参数通过请求体传递，适合发送大量数据或敏感信息。</li>
</ul>
<p>要探究本质，就要解析他们的**<mark>报文<mark>**  </p>
<p>GET：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /search?query=java&amp;page=2 HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>POST：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /search HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">?query=java&amp;page=2 </span><br></pre></td></tr></table></figure>

<p>这些都是一个个字符串而已，发送的时候设置URL和参数本质上都是拼字符串，然后把整段报文发给服务。Servlet 接收请求，解析报文，拿到参数，仅此而已。填写表单的时候也一样，form标签的action属性就是要发送请求的目标，输入参数，提交的时候，就相当于填写好了目标URL，既然目标确定了。浏览器会解析内容，写好报文，发送给目标，那么浏览器是如何确定要发送给谁呢？浏览器确定请求的目标地址（即请求的 URL）是通过 URL 来实现的。以下是这一过程的基本步骤：以GET请求为例：</p>
<h3 id="目标URL的填写"><a href="#目标URL的填写" class="headerlink" title="目标URL的填写"></a>目标URL的填写</h3><p>用户在浏览器中提交表单（例如，点击“提交”按钮），这会触发一个请求。表单的 <code>action</code> 属性指定了要发送请求的 URL。浏览器会将表单数据编码为查询字符串，并附加到 <code>action</code> URL 后面作为要访问的目标。</p>
<h3 id="解析-URL"><a href="#解析-URL" class="headerlink" title="解析 URL"></a>解析 URL</h3><p>浏览器解析这个 URL，分解成几个部分：</p>
<ul>
<li><strong>协议</strong>：<code>http</code></li>
<li><strong>主机名</strong>：<code>www.example.com</code></li>
<li><strong>路径</strong>：<code>/search</code></li>
<li><strong>查询字符串</strong>：<code>?query=java</code></li>
</ul>
<h3 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h3><p>浏览器会通过 DNS（域名系统）将主机名转换为相应的 IP 地址，以便找到目标服务器。例如，<code>www.example.com</code> 可能会被解析为 <code>192.0.2.1</code>。</p>
<h3 id="建立-TCP-连接"><a href="#建立-TCP-连接" class="headerlink" title="建立 TCP 连接"></a>建立 TCP 连接</h3><p>浏览器与目标服务器建立 TCP 连接，通常使用 HTTP 端口（默认为 80，HTTPS 为 443）。</p>
<h3 id="构造请求报文"><a href="#构造请求报文" class="headerlink" title="构造请求报文"></a>构造请求报文</h3><p>一旦连接建立，浏览器会根据表单数据构造 HTTP 请求报文，包括请求行、请求头和请求体。</p>
<h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>浏览器通过已建立的 TCP 连接，将构造好的请求报文发送到服务器的指定 IP 地址。</p>
<h3 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h3><p>服务器接收到请求后，会根据请求的路径和参数来处理请求，最终返回相应的响应数据。</p>
<p>发出请求实际上就是浏览器访问目标URL</p>
<p>表单：action就是目标URL，如果是get请求，浏览器会将目标url加上参数。随后解析url，得出目标IP，根据这些参数生成请求报文发送到目标IP。</p>
<h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>axios是对js 的封装</p>
<p><a target="_blank" rel="noopener" href="https://www.axios-http.cn/">Axios中文文档 | Axios中文网 (axios-http.cn)</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929192249373.png" alt="image-20240929192249373"></p>
<p>method url data</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929192732304.png" alt="image-20240929192732304"></p>
<p>链式编程</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(url).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">resp</span>)&#123;</span><br><span class="line">    <span class="comment">//具体用响应干什么？</span></span><br><span class="line">&#125;)</span><br><span class="line">axios.<span class="title function_">post</span>(url,data).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">resp</span>)&#123;</span><br><span class="line">    <span class="comment">//具体用响应干什么？</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>resp：</p>
<p>①data :实际响应回来的数据</p>
<p>②headers :响应头信息</p>
<p>③status :响应状态码</p>
<p>④statusText:响应状态信息</p>
<p>特色：自动将data对象序列化为json字符串，再自动将响应数据中的json转回js自定义对象</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929210844535.png" alt="image-20240929210844535"></p>
<p>解构赋值：then({data}) 只取resp的data字段</p>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p><strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation js对象表示法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929194822398.png" alt="image-20240929194822398"></p>
<p>字段名要用双引号括起来，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">    <span class="string">&quot;key1&quot;</span>:value1,</span><br><span class="line">    <span class="string">&quot;key2&quot;</span>:value2</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//json.key1 访问value1</span></span><br><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">    <span class="attr">key1</span>:value1,</span><br><span class="line">    <span class="attr">key2</span>:value2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这两个对象的主要区别在于属性名的引号使用。在第一个对象中，所有属性名都用双引号包围，而在第二个对象中，属性名没有引号。根据 JavaScript 的语法，属性名可以不加引号（如果是有效的标识符），但如果包含特殊字符或空格，就需要加引号。功能上，它们是等价的。</p>
<p>axios发送自定义对象会自动转成json的形式</p>
<h2 id="JSON数据和Java对象转换"><a href="#JSON数据和Java对象转换" class="headerlink" title="JSON数据和Java对象转换"></a>JSON数据和Java对象转换</h2><p>Fastjson 高性能JSON库。</p>
<p>导入fastjson坐标</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line"><span class="comment">//对象tostring</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> JSON.parseObject(user, User.class);</span><br><span class="line"><span class="comment">//解析出对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/json;charset=utf-8&quot;</span>);</span><br><span class="line">response.getWriter().write(jsonString)</span><br></pre></td></tr></table></figure>

<h2 id="案例：增删改查"><a href="#案例：增删改查" class="headerlink" title="案例：增删改查"></a>案例：增删改查</h2><p><strong>查询</strong>：把axios发送请求接收响应数据并打印数据的过程 封装成一个函数，跟onload（brandSelect页面加载完成）绑定。</p>
<p>axios+html 接收servlet响应，打印表格</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929200621197.png" alt="image-20240929200621197"></p>
<p>axios这边接收到json，也就是resp.data 是对象的集合，所以用for循环遍历，由于是打印，所以可以用id锚定表格的标签，每遍历一次就累加字符串一次，最后一起写入表格标签的innerHTML中。</p>
<p><strong>新增品牌</strong>：</p>
<p>表单提交的操作是一个同步请求，同步请求是直接发送参数字段，而且需要重新加载页面才能生效，利用不上js的异步高效性，所以提交按钮应该设置成普通button，进行异步操作</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929203719660.png" alt="image-20240929203719660"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929204058611.png" alt="image-20240929204058611"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929204235548.png" alt="image-20240929204235548"></p>
<p>获取表单数据，字符串直接赋值，复选框的结果用checked表示，因为这是两个复选框，名字都叫status，所以返回的是一个元素数组，对这个数组进行便利，被选中的就把自己的value赋给对象。</p>
<p>axios发送自定义对象会自动转成json的形式，直接把封装好的自定义对象添加到axios的data参数中即可</p>
<p>函数绑定提交按钮的onclick事件，设定js函数把表单填入的内容封装成json对象（即为前面的操作），发送ajax请求给addServlet。</p>
<p><strong>addServlet</strong>处，<u>getParameter不能接收json数据</u>，所以应该用<u>getReader.readLine读取字符串</u>，然后把json字符串转成pojo对象，执行添加操作，返回操作成功与否，作为响应数据发出。</p>
<p>axios接收响应数据，如果操作成功，就跳转到第一步做出来的加载html页面中</p>
<p>增删改用post 查用get </p>
<h1 id="Vue-Servlet-开发"><a href="#Vue-Servlet-开发" class="headerlink" title="Vue+Servlet 开发"></a>Vue+Servlet 开发</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul>
<li><strong>Vue</strong>：前端的JS骨架，model view双向绑定，渲染网页</li>
<li><strong>axios</strong>：AJAX请求发送</li>
<li><strong>Element</strong> <strong>UI</strong>：CSS组件库，基于Vue</li>
</ul>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ul>
<li><strong>Web层</strong>：Servlet调用Service层的方法查询，结果转为JSON，响应JSON数据发给客户端</li>
<li><strong>Service层</strong>：BrandService定义selectAll方法，获取sqlSession对象，调用BrandMapper执行SQL语句</li>
<li><strong>DAO层</strong>：BrandMapper定义selectAll方法，方法体为MyBatis执行某条具体的SQL语句</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002150928236.png" alt="image-20241002150928236"></p>
<h2 id="服务端优化"><a href="#服务端优化" class="headerlink" title="服务端优化"></a>服务端优化</h2><h3 id="Service-优化"><a href="#Service-优化" class="headerlink" title="Service 优化"></a>Service 优化</h3><h4 id="Service-接口定义"><a href="#Service-接口定义" class="headerlink" title="Service 接口定义"></a>Service 接口定义</h4><ul>
<li>定义 <strong>BrandService</strong> 接口：定义一些业务的抽象方法，实现类中实现业务方法，在servlet中创建好业务实现对象，这样就解除了service层和servlet层的耦合性</li>
</ul>
<h4 id="ServiceImpl-接口实现"><a href="#ServiceImpl-接口实现" class="headerlink" title="ServiceImpl 接口实现"></a>ServiceImpl 接口实现</h4><ul>
<li>在实现类中，先创建好唯一的的factory工厂，然后在方法中开启sqlSession，执行SQL语句</li>
</ul>
<h4 id="优化结果"><a href="#优化结果" class="headerlink" title="优化结果"></a>优化结果</h4><ul>
<li><strong>UserService:</strong></li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164617150.png" alt="image-20241002164617150"></li>
<li><strong>UserServiceImpl:</strong></li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164523529.png" alt="image-20241002164523529"></li>
</ul>
<h3 id="Servlet-优化"><a href="#Servlet-优化" class="headerlink" title="Servlet 优化"></a>Servlet 优化</h3><h4 id="业务实现类的创建"><a href="#业务实现类的创建" class="headerlink" title="业务实现类的创建"></a>业务实现类的创建</h4><p>为了增强项目的组织度，会进行业务整合，在BrandServlet中，创建一个BrandService的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BrandServlet</span>&#123;</span><br><span class="line">	<span class="type">BrandService</span> <span class="variable">brandService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrandServiceImpl1</span>();</span><br><span class="line">    <span class="comment">//调用service的方法</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="业务功能整合"><a href="#业务功能整合" class="headerlink" title="业务功能整合"></a>业务功能整合</h4><p>一个实体类的一个功能就要新创建一个Servlet，不易管理，要把一个实体类的所有功能都放在一个servlet中。（BrandServlet，UserServlet）通过/brand/*   /user/*来访问上述两个servlet。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002135939524.png" alt="image-20241002135939524"></p>
<ul>
<li>如图，原先<code>HttpServlet</code>的<code>service</code>方法根据请求的方式（<code>getMethod</code>）进行方法的分发（<code>doGe</code>t或<code>doPost</code>）</li>
<li>现在要根据请求的路径来进行方法的分发，因此<code>BrandServlet</code>不能直接继承<code>HttpServlet</code>，要创建一个<code>BaseServlet</code>继承<code>HttpServlet</code>，重写其<code>service</code>方法，根据路径分发方法。同理<code>UserServlet</code>也直接继承<code>Base</code></li>
<li>获取到请求路径的最后一部分（最后一个<code>/</code>之后的内容）就是请求的方法名</li>
<li>方法名称有了还要找<code>对应servlet</code>的字节码文件，<code>baseServlet</code>没有<code>@WebServlet</code>注解，也就不会直接访问了，到时候被访问的应该是<code>BrandServlet</code>和<code>UserServlet</code>这两个子类，子类继承父类的<code>service</code>方法，所以<code>service</code>方法中的<code>this.getClass</code>就能理所应当地拿到子类的字节码文件。</li>
<li>因为<code>BrandServlet</code>和<code>UserServlet </code>都是要先执行<code>service(req,resp)</code>方法，接收<code>request</code>参数和<code>response</code>参数，如果要执行具体的<code>selectAll</code>业务方法，就要在反射调用方法的时候把参数加上，同时在<code>子类servlet</code>中，业务方法接受的参数全部统一成<code>req</code>和<code>resp</code>。</li>
</ul>
<p>如此一来，就能实现：</p>
<ol>
<li>访问<code>/brand/selectAll</code>路径，</li>
<li>调用重写过后的<code>service(HttpServletRequest req,HttpServletResponse resp)</code> 能获取方法名和字节码文件</li>
<li>根据方法名和参数类型（<code>methodName, HttpServletRequest req.class, HttpServletResponse.class</code>）获取Method对象，</li>
<li><code>method.invoke(this, req, resp)</code>，实现业务整合</li>
</ol>
<h4 id="优化结果-1"><a href="#优化结果-1" class="headerlink" title="优化结果"></a>优化结果</h4><ul>
<li><strong>BaseServlet:</strong></li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164451103.png" alt="image-20241002164451103"></li>
<li><strong>UserServlet:</strong> </li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164355800.png" alt="image-20241002164355800"></li>
</ul>
<h3 id="优化后的后端结构"><a href="#优化后的后端结构" class="headerlink" title="优化后的后端结构"></a>优化后的后端结构</h3><p>后端的DAO, Service, Web层分开 各司其职，减少了耦合度</p>
<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002164240142.png" alt="image-20241002164240142" style="zoom: 50%;" />



<h2 id="其他细节"><a href="#其他细节" class="headerlink" title=" 其他细节 "></a><span id="mybatis"> 其他细节 </span></h2><h3 id="MyBatis-模糊查询"><a href="#MyBatis-模糊查询" class="headerlink" title="MyBatis 模糊查询"></a>MyBatis 模糊查询</h3><h4 id="39-password-39-不行？-39-password-39-行？"><a href="#39-password-39-不行？-39-password-39-行？" class="headerlink" title="&#39;%#{password}%&#39;不行？&#39;%${password}%&#39;行？"></a><code>&#39;%#&#123;password&#125;%&#39;</code>不行？<code>&#39;%$&#123;password&#125;%&#39;</code>行？</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002225509824.png" alt="image-20241002225509824"></p>
<p>${password}就是最简单的文本替换，直接拼接字符串，也不会类型转换（输入参数<code>that</code>会直接拼接成<code>and password like that</code> 很显然少了引号）连SQL都无法注入<code>&#39; OR &#39;1&#39; = &#39;1</code> <code>and password like &#39; OR &#39;1&#39; = &#39;1</code> （语法错误）自然，模糊匹配就变成<code>&#39;%that%&#39;</code>了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002230031380.png" alt="image-20241002230031380"></p>
<p>预编译占位符#{password}会把整个password转换成字符串，输入参数<code>&#39; OR &#39;1&#39; = &#39;1</code>会帮你转义成<code>\&#39; OR \&#39;1\&#39; = \&#39;1</code> 还会贴心地给两边加上引号<code>and password like &#39;\&#39; OR \&#39;1\&#39; = \&#39;1&#39;</code></p>
<p>因此，#{password}本身就自带引号，模糊匹配会解析成<code>&#39;%&#39;that&#39;%&#39;</code> 完全的语法错误。</p>
<h4 id="应该怎么用"><a href="#应该怎么用" class="headerlink" title="应该怎么用"></a>应该怎么用</h4><p>既然返回的是带引号的字符串，可以用拼接字符串函数，也可以用空格把这三个字符串分开</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002231938685.png" alt="image-20241002231938685"></p>
<h3 id="MyBatis-分页查询"><a href="#MyBatis-分页查询" class="headerlink" title="MyBatis 分页查询"></a>MyBatis 分页查询</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241002234502508.png" alt="image-20241002234502508"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003001119464.png" alt="image-20241003001119464"></p>
<h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><p>分页查询要两个参数，这一页从哪一行开始和每页显示的条数</p>
<p>前端传递给后台 当前页码和每页显示条数，(当前页码-1)*每行显示条数就是这一页开始的一行</p>
<p>PageBean封装 总条数 和 这一页的查询结果List&lt;User&gt; </p>
<p>list用于显示，总条数返回给前端</p>
<h4 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h4><p>前端刷新表格的操作：发出自己的两个属性，收到PageBean中的rows和totalCount</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003003901994.png" alt="image-20241003003901994"></p>
<p>前端点击页码的操作，设置自身的两个属性，同时刷新表格</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003004044018.png" alt="image-20241003004044018"></p>
<h3 id="插入重复的键——事务回滚"><a href="#插入重复的键——事务回滚" class="headerlink" title="插入重复的键——事务回滚"></a>插入重复的键——事务回滚</h3><p>username是unique 且 not null 的，所以不能重复，在提交表单的时候，如果输入重复数据，就会导致事务提交失败，这是就会出现异常，<strong>如果出现异常不处理</strong>，会一直导致故障。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003005454880.png" alt="image-20241003005454880"></p>
<p>使用try catch 如果出现异常，就调用rollback，同时return false，响应</p>
<p>前端收到响应，会根据结果弹出提示，成功或者失败</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003005659475.png" alt="image-20241003005659475"></p>
<h3 id="优化后的前端结构"><a href="#优化后的前端结构" class="headerlink" title="优化后的前端结构"></a>优化后的前端结构</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003004606856.png" alt="image-20241003004606856"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241003004711700.png" alt="image-20241003004711700"></p>
<p>加入了表格loading动画，刷新按钮，以及删除和插入的结果提示</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/08/31/mp+lombok/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/31/mp+lombok/" class="post-title-link" itemprop="url">MyBatis-Plus</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-31 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-31T00:00:00+08:00">2024-08-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 15:47:45" itemprop="dateModified" datetime="2025-04-27T15:47:45+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web-development/" itemprop="url" rel="index"><span itemprop="name">web development</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>大家在日常开发中应该能发现，单表的CRUD功能代码重复度很高，也没有什么难度。而这部分代码量往往比较大，开发起来比较费时。</p>
<p>因此，目前企业中都会使用一些组件来简化或省略单表的CRUD开发工作。目前在国内使用较多的一个组件就是MybatisPlus.</p>
<p>当然，MybatisPlus不仅仅可以简化单表操作，而且还对Mybatis的功能有很多的增强。可以让我们的开发更加的简单，高效。</p>
<p>通过今天的学习，我们要达成下面的目标：</p>
<ul>
<li>能利用MybatisPlus实现基本的CRUD</li>
<li>会使用条件构建造器构建查询和更新语句</li>
<li>会使用MybatisPlus中的常用注解</li>
<li>会使用MybatisPlus处理枚举、JSON类型字段</li>
<li>会使用MybatisPlus实现分页</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://b11et3un53m.feishu.cn/wiki/PsyawI04ei2FQykqfcPcmd7Dnsc">day01-MybatisPlus - 飞书云文档</a> </p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/08/31/mp+lombok/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/08/15/Spring%20SpringMVC%20SpringBoot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/15/Spring%20SpringMVC%20SpringBoot/" class="post-title-link" itemprop="url">Spring</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-15 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-15T00:00:00+08:00">2024-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 16:12:46" itemprop="dateModified" datetime="2025-04-27T16:12:46+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h1><p>IoC: Inverse of Control 原先调用服务或者DAO的需要自行new出来对象，硬编码，耦合程度高，Spring的Container能够接管对象的创建工作（实际上就是管理Bean） 并且能够根据对象Bean之间的关系进行依赖注入，创建A对象的同时会把B对象创建起来，也就是DI(Dependency Injection)</p>
<p>管理方式：配置文件xml            IoC容器的获取：Spring提供接口</p>
<p>把业务接口的实现类交给Spring管理，遇到接口类，Spring就会自动去找Bean中是否有接口的实现类。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020194848409.png" alt="image-20241020194848409"></p>
<p>BookDao是接口，实现类为BookDaoImpl，Impl交给Spring管理</p>
<p>DI：依赖注入，依赖用方法传参的方式传入</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019114405108.png" alt="image-20241019114405108"></p>
<p>property name 是成员变量的名字</p>
<p>ref 是要引用的bean id/name</p>
<h2 id="IoC-配置"><a href="#IoC-配置" class="headerlink" title="IoC 配置"></a>IoC 配置</h2><h3 id="bean-管理"><a href="#bean-管理" class="headerlink" title="bean 管理"></a>bean 管理</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019222443537.png" alt="image-20241019222443537"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019115106810.png" alt="image-20241019115106810"></p>
<h4 id="name-别名"><a href="#name-别名" class="headerlink" title="name 别名"></a>name 别名</h4><p><u>ATTRIBUTE</u></p>
<p>bean <strong>name</strong> = “s1 s2 s3”  alias</p>
<p><strong>ref</strong>可以使用name也可以使用id</p>
<p>getBean </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019144037398.png" alt="image-20241019144037398"></p>
<h4 id="scope-作用范围"><a href="#scope-作用范围" class="headerlink" title="scope 作用范围"></a>scope 作用范围</h4><p><u>ATTRIBUTE</u></p>
<p>Spring默认创建<strong>单例</strong>bean，scope=”singleton” prototype为多例。</p>
<ul>
<li>适合复用的才作为bean交给IoC容器管理<ul>
<li>表现层，业务层，DAO层，工具层</li>
</ul>
</li>
<li>不适合复用的对象<ul>
<li>封装的实体域对象</li>
</ul>
</li>
</ul>
<h4 id="bean-创建方式"><a href="#bean-创建方式" class="headerlink" title="bean 创建方式"></a>bean 创建方式</h4><h5 id="使用构造方法"><a href="#使用构造方法" class="headerlink" title="使用构造方法"></a><mark>使用构造方法<mark></h5><p>无参构造器，如果使用构造器进行依赖注入，则走的是有参构造</p>
<h5 id="使用静态工厂实例化Bean"><a href="#使用静态工厂实例化Bean" class="headerlink" title="使用静态工厂实例化Bean"></a>使用静态工厂实例化Bean</h5><ul>
<li>工厂的静态方法factoryMethod(return new Bean)，不造工厂，调用工厂的<strong>静态</strong>方法造Bean <u>ATTRIBUTE</u>: factory-method</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019160109618.png" alt="image-20241019160109618"></p>
<h5 id="使用实例工厂实例化Bean"><a href="#使用实例工厂实例化Bean" class="headerlink" title="使用实例工厂实例化Bean"></a>使用实例工厂实例化Bean</h5><ul>
<li>先造工厂bean再调用工厂的<strong>实例</strong>方法(return newBean) 造bean</li>
</ul>
<h5 id="FactoryBean-实例工厂bean"><a href="#FactoryBean-实例工厂bean" class="headerlink" title="FactoryBean 实例工厂bean"></a><mark>FactoryBean 实例工厂bean<mark></h5><ul>
<li><p>第三方自定义工厂Bean类实现FactoryBean接口，重写方法<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019160946566.png" alt="image-20241019160946566"></p>
<ul>
<li>getObject 工厂类的returnNewBean方法</li>
<li>getObjectType return Bean.class bean的 字节码</li>
<li>isSingleton 单例</li>
</ul>
</li>
<li><p>xml 配置<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019161457148.png" alt="image-20241019161457148">    </p>
</li>
<li><p>主要用于第三方框架和Spring框架对接，他们创建的对象要配置一些参数，这时就需要一个FactoryBean，工厂bean会提供set对象参数的方法，返回的就是配好参的对象，可以省去手动配参的麻烦</p>
</li>
</ul>
<h4 id="bean-生命周期"><a href="#bean-生命周期" class="headerlink" title="bean 生命周期"></a>bean 生命周期</h4><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/reference/core/beans/factory-nature.html#beans-factory-lifecycle-initializingbean">Customizing the Nature of a Bean :: Spring Framework</a> </p>
<h5 id="init-method-初始化"><a href="#init-method-初始化" class="headerlink" title="init-method 初始化"></a>init-method 初始化</h5><p><u>ATTRIBUTE</u> 方法名</p>
<h5 id="destroy-method-销毁"><a href="#destroy-method-销毁" class="headerlink" title="destroy-method 销毁"></a>destroy-method 销毁</h5><p><u>ATTRIBUTE</u> 方法名</p>
<p>销毁方式1: 容器关闭 <code>ctx.close()</code> appctx这个类没有关闭功能，换一个annotationConfigAppctx才有</p>
<p>销毁方式2: 注册关闭钩子<code>ctx.registerShutdownHook()</code></p>
<h5 id="自定义实体类实现接口"><a href="#自定义实体类实现接口" class="headerlink" title="自定义实体类实现接口"></a>自定义实体类实现接口</h5><p><code>DisposableBean</code> <code>InitializingBean</code> </p>
<p>分别重写destory() afterPropertiesSet()</p>
<p>属性设置就是在属性注入(调用setter)之后调用的方法</p>
<h5 id="生命周期示意图"><a href="#生命周期示意图" class="headerlink" title="生命周期示意图"></a>生命周期示意图</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019163321664.png" alt="image-20241019163321664"></p>
<h3 id="DI-依赖注入"><a href="#DI-依赖注入" class="headerlink" title="DI 依赖注入"></a>DI 依赖注入</h3><p><strong>注入</strong> ⇔ <strong>给bean的属性赋值</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019222530413.png" alt="image-20241019222530413"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019163720566.png" alt="image-20241019163720566"></p>
<p>注入多个bean，填写多个property</p>
<h4 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h4><h5 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a><mark>setter注入<mark></h5><ol>
<li>setter 引用其他的bean property ref = 其他bean的名称 <u>ATTRIBUTE</u></li>
<li>setter 注入基本数据类型和简单值 property value = 值  <u>ATTRIBUTE</u></li>
<li>property name实际上是根据setter方法 setUserDao 去掉set首字母小写 userDao得到的</li>
<li>先无参构造创建bean，再用setter注入依赖</li>
</ol>
<h5 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h5><p>针对有参构造器，必须显式声明有参构造器</p>
<p> <u>ATTRIBUTE</u> <code>&lt;constructor-arg name&gt;</code></p>
<ol>
<li><p> 引用其他bean name是构造器形参名，<strong>耦合度高</strong>，参数先后顺序固定不能变<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019173838816.png" alt="image-20241019173838816"></p>
</li>
<li><p> 基本数据类型和简单值<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019174107702.png" alt="image-20241019174107702"></p>
</li>
<li><p>耦合度高解决方案：<strong>参数适配</strong></p>
<ul>
<li><p><code>&lt;constructor-arg name&gt;</code>改成type，解决参数名的高耦合，但是type相同的参数会混淆</p>
</li>
<li><p>改成index，index表示参数的位置</p>
</li>
</ul>
</li>
<li><p> 直接有参构造创建bean，可以没有无参构造</p>
</li>
</ol>
<h4 id="方式选择"><a href="#方式选择" class="headerlink" title="方式选择"></a>方式选择</h4><ul>
<li><strong>强制依赖</strong>使用构造器进行，使用setter注入有概率不进行注入导致NullPointerException</li>
<li><strong>可选依赖</strong>使用setter注入进行，灵活性强</li>
<li>Spring框架倡导使用构造器,第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨</li>
<li>如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入</li>
<li>实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</li>
<li><u>自己开发的模块推荐使用setter注入</u></li>
</ul>
<h4 id="依赖自动装配-autowire"><a href="#依赖自动装配-autowire" class="headerlink" title="依赖自动装配 autowire"></a>依赖自动装配 <span id="autowire">autowire</span></h4><p>只适用于引用类型</p>
<p><u>ATTRIBUTE</u> </p>
<p>不去手动指定，在容器的bean中自动匹配适合的bean。依赖于有参构造或者setter</p>
<h5 id="byType-依赖setter"><a href="#byType-依赖setter" class="headerlink" title="byType (依赖setter)"></a><mark>byType<mark> (依赖setter)</h5><p><code>bean属性的type</code> 要去匹配 <code>容器中bean的class</code></p>
<p>保证相同class的bean唯一 推荐</p>
<h5 id="byName-依赖setter"><a href="#byName-依赖setter" class="headerlink" title="byName (依赖setter)"></a>byName (依赖setter)</h5><p><code>bean属性的name</code> 要去匹配 <code>容器中bean的id</code></p>
<p>保证必须要有指定名称的bean  耦合度高，不推荐</p>
<h5 id="constructor-依赖有参构造器"><a href="#constructor-依赖有参构造器" class="headerlink" title="constructor(依赖有参构造器)"></a>constructor(依赖有参构造器)</h5><h5 id="default"><a href="#default" class="headerlink" title="default"></a>default</h5><p>如果&lt;beans&gt;指定了autowire 此bean跟随beans</p>
<h5 id="no"><a href="#no" class="headerlink" title="no"></a>no</h5><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li><p>只能自动装配引用类型（IoC容器不会去管理简单类型）包装类bean根本没法写</p>
</li>
<li><p>优先级 &lt; 手动装配</p>
</li>
</ul>
<h4 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h4><p>集合要注入内容，而不是注一个空壳</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myArray&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>5<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">value</span>&gt;</span>this<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>that<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>where<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mySet&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">value</span>&gt;</span>this<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>that<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>where<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;A&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;B&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;C&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myProperties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;A&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;B&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;C&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="管理第三方Bean"><a href="#管理第三方Bean" class="headerlink" title="管理第三方Bean"></a>管理第三方Bean</h3><p>别人写的对象，创建bean，类型是什么？你要配哪些参数？</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019191451764.png" alt="image-20241019191451764"></p>
<h4 id="加载-properties-XML-Namespace-JDBC-MyBatis-XML-Maven-md"><a href="#加载-properties-XML-Namespace-JDBC-MyBatis-XML-Maven-md" class="headerlink" title="加载.properties ([XML Namespace](.\JDBC MyBatis XML Maven.md))"></a>加载.properties ([XML Namespace](.\JDBC MyBatis XML Maven.md))</h4><p>创建context命名空间</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019192317628.png" alt="image-20241019192317628"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019220634669.png" alt="image-20241019220634669"></p>
<p>classpath:*.properties 当前模块下所有的配置文件</p>
<h3 id="容器-ctx"><a href="#容器-ctx" class="headerlink" title="容器 ctx"></a>容器 ctx</h3><h4 id="创建容器方式"><a href="#创建容器方式" class="headerlink" title="创建容器方式"></a>创建容器方式</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019221415451.png" alt="image-20241019221415451"></p>
<h4 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019221407031.png" alt="image-20241019221407031"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019221914707.png" alt="image-20241019221914707"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019222158026.png" alt="image-20241019222158026"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019221938964.png" alt="image-20241019221938964"></p>
<p>立即加载（饿汉），lazy-init 延迟加载 (懒汉)</p>
<h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><h3 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h3><h4 id="定义bean-Component"><a href="#定义bean-Component" class="headerlink" title="定义bean@Component"></a><mark>定义bean@Component<mark></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019223116345.png" alt="image-20241019223116345"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019223156078.png" alt="image-20241019223156078"></p>
<p>加上对应的bean的id ，不加就要加载字节码class</p>
<h4 id="纯注解开发-Configuration-ComponetScan"><a href="#纯注解开发-Configuration-ComponetScan" class="headerlink" title="纯注解开发@Configuration  @ComponetScan"></a><mark>纯注解开发@Configuration  @ComponetScan<mark></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019224153002.png" alt="image-20241019224153002"></p>
<p>获取ctx: <code>ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class)</code> </p>
<p>默认xml配置文件只给了beans的命名空间，context还得另外自己加，纯注解开发需要定义一个SpringConfig类，常用的配置都有，不用手动去加命名空间</p>
<p>XML out!</p>
<h3 id="2-bean管理"><a href="#2-bean管理" class="headerlink" title="2. bean管理"></a>2. bean管理</h3><h4 id="作用范围-Scope"><a href="#作用范围-Scope" class="headerlink" title="作用范围 @Scope"></a>作用范围 @Scope</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019225307356.png" alt="image-20241019225307356"></p>
<h4 id="生命周期-PostConstruct-PreDestroy"><a href="#生命周期-PostConstruct-PreDestroy" class="headerlink" title="生命周期 @PostConstruct @PreDestroy"></a>生命周期 @PostConstruct @PreDestroy</h4><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2426419">探究Spring Boot中@PostConstruct注解的使用场景-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1588212">Spring 框架中 @PostConstruct 注解详解-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241019225254913.png" alt="image-20241019225254913"></p>
<p>Instantiate(Constructor)&gt; @Autowired &gt; @PostConstruct</p>
<p>依赖注入完成，被显式调用之前</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/reference/core/beans/annotation-config/postconstruct-and-predestroy-annotations.html">Using @PostConstruct and @PreDestroy :: Spring Framework</a></p>
<h3 id="DI-自动装配"><a href="#DI-自动装配" class="headerlink" title="DI 自动装配"></a>DI 自动装配</h3><h4 id="自动装配-Autowired（引用类型）"><a href="#自动装配-Autowired（引用类型）" class="headerlink" title="自动装配@Autowired（引用类型）"></a><mark>自动装配@Autowired（引用类型）<mark></h4><p>在需要注入依赖的<strong>一个</strong>属性</p>
<p>与配置文件<a href="#autowire">autowire Attribute of Bean</a>不同，注解Autowired不依赖于setter和有参构造器，直接暴力反射访问private属性，创建对象并注入依赖。 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020011345128.png" alt="image-20241020011345128"></p>
<h5 id="按名称匹配-Qualifier"><a href="#按名称匹配-Qualifier" class="headerlink" title="按名称匹配@Qualifier"></a>按名称匹配@Qualifier</h5><p>autowired默认按类型装 配，同一类型多个实现，用Qualifier指定具体bean名称，<em>不加Qualifier就按一定规则选择</em> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020011356460.png" alt="image-20241020011356460"></p>
<h5 id="先名称匹配，再按照类型匹配-Resource"><a href="#先名称匹配，再按照类型匹配-Resource" class="headerlink" title="先名称匹配，再按照类型匹配@Resource"></a>先名称匹配，再按照类型匹配@Resource</h5><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1003903">面试突击78：@Autowired 和 @Resource 有什么区别？-阿里云开发者社区 (aliyun.com)</a> </p>
<ul>
<li><strong>@Autowired 先根据类型（byType）查找，如果存在多个（Bean）再根据名称（byName）进行查找；</strong></li>
<li><strong>@Resource 先根据名称（byName）查找，如果（根据名称）查找不到，再根据类型（byType）进行查找。</strong> </li>
</ul>
<p>注意下方的<a href="#bean">Bean注解</a></p>
<p><strong>@Autowired 支持属性注入、构造方法注入和 Setter 注入，而 @Resource 只支持属性注入和 Setter 注入</strong> </p>
<p>@Autowired 来自 Spring 框架，而 @Resource 来自于（Java）JSR-250；</p>
<p>@Autowired 只支持设置 1 个参数，而 @Resource 支持设置 7 个参数；</p>
<p>@Autowired 既支持构造方法注入，又支持属性注入和 Setter 注入，而 @Resource 只支持属性注入和 Setter 注入；</p>
<h4 id="简单类型注入依赖-Value"><a href="#简单类型注入依赖-Value" class="headerlink" title="简单类型注入依赖@Value"></a>简单类型注入依赖@Value</h4><p>需要注入的属性上 写value</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020011954765.png" alt="image-20241020011954765"></p>
<h4 id="导入配置文件-PropertySource"><a href="#导入配置文件-PropertySource" class="headerlink" title="导入配置文件@PropertySource"></a>导入配置文件@PropertySource</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020011844984.png" alt="image-20241020011844984"></p>
<h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a><mark>循环依赖<mark></h4><p>Spring循环依赖指的是两个或多个Bean之间相互依赖，形成一个环状依赖的情况。简单来说，就是A依赖B，B依赖C，C依赖A，这样就形成了一个循环依赖的环。</p>
<p>Spring循环依赖通常会导致Bean无法正确地被实例化，从而导致应用程序无法正常启动或者出现异常。因此，Spring循环依赖是一种需要尽量避免的情况。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/633066ae3fcb2fcc117ab142dd90d3da-1730639875106-2.png"></p>
<h5 id="使用构造函数注入"><a href="#使用构造函数注入" class="headerlink" title="使用构造函数注入"></a>使用构造函数注入</h5><p>构造函数注入是一种相对保险的方式，因为在实例化Bean时，Spring会检查是否存在循环依赖，并在发现循环依赖时抛出异常，避免死循环。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用-Lazy注解"><a href="#使用-Lazy注解" class="headerlink" title="使用@Lazy注解"></a>使用@Lazy注解</h5><p>@Lazy注解可以延迟Bean的实例化，从而避免循环依赖的问题。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用setter方法注入"><a href="#使用setter方法注入" class="headerlink" title="使用setter方法注入"></a>使用setter方法注入</h5><p>使用setter方法注入也可以解决循环依赖的问题，但要注意可能出现的空指针异常。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">(B b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(A a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="管理第三方Bean-1"><a href="#管理第三方Bean-1" class="headerlink" title="管理第三方Bean"></a>管理第三方Bean</h3><h4 id="Config配置类中bean的创建-Bean"><a href="#Config配置类中bean的创建-Bean" class="headerlink" title="Config配置类中bean的创建@Bean"></a><span id="bean"><mark>Config配置类中bean的创建@Bean<mark></span></h4><p>与@Component不同 这个是方法级别的注解，方法返回的对象将由Spring容器管理</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020012511399.png" alt="image-20241020012511399"></p>
<h5 id="Bean声明的Bean名称？"><a href="#Bean声明的Bean名称？" class="headerlink" title="@Bean声明的Bean名称？"></a>@Bean声明的Bean名称？</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/w1014074794/article/details/106768607">spring boot中通过注解@Bean声明的bean的名称是什么？_springboot 声明bean的名称-CSDN博客</a></p>
<h6 id="不指定name属性，bean名称为方法名"><a href="#不指定name属性，bean名称为方法名" class="headerlink" title="不指定name属性，bean名称为方法名"></a>不指定name属性，bean名称为方法名</h6><h6 id="指定name属性，bean名称为name"><a href="#指定name属性，bean名称为name" class="headerlink" title="指定name属性，bean名称为name"></a>指定name属性，bean名称为name</h6><h5 id="导入其他Config类到核心配置-Import"><a href="#导入其他Config类到核心配置-Import" class="headerlink" title="导入其他Config类到核心配置@Import"></a>导入其他Config类到核心配置@Import</h5><p>不建议直接把其他的配置写到SpringConfig里面，分出去然后import</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020012755726.png" alt="image-20241020012755726"></p>
<h4 id="DI-依赖注入-1"><a href="#DI-依赖注入-1" class="headerlink" title="DI 依赖注入"></a>DI 依赖注入</h4><p><span id="thirdpartydi">最简单的方法：自己new个对象出来，手动配参数，丢给spring</span> (其实xml就是把手动配参的过程从业务代码中解耦出来)</p>
<h5 id="简单类型依赖注入：成员变量-Value"><a href="#简单类型依赖注入：成员变量-Value" class="headerlink" title="简单类型依赖注入：成员变量@Value"></a>简单类型依赖注入：成员变量@Value</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020013246624.png" alt="image-20241020013246624"></p>
<h5 id="引用类型依赖注入：方法形参"><a href="#引用类型依赖注入：方法形参" class="headerlink" title="引用类型依赖注入：方法形参"></a><mark>引用类型依赖注入：方法形参<mark></h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020013406409.png" alt="image-20241020013406409"></p>
<h3 id="XML-vs-Annotation"><a href="#XML-vs-Annotation" class="headerlink" title="XML vs. Annotation"></a>XML vs. Annotation</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020013703651.png" alt="image-20241020013703651"></p>
<h2 id="整合第三方框架实战"><a href="#整合第三方框架实战" class="headerlink" title="整合第三方框架实战"></a>整合第三方框架实战</h2><h3 id="Spring-amp-MyBatis"><a href="#Spring-amp-MyBatis" class="headerlink" title="Spring &amp; MyBatis"></a>Spring &amp; MyBatis</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_64737877/article/details/122608987">使用纯注解方式Spring整合MyBatis_spring整合mybatis基于注解-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/SerikaOnoe/article/details/90639135">Spring整合Mybatis(注解方式完整过程，摒弃MyBatis配置文件)_springboot启动去除mybatis-CSDN博客</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020123544343.png" alt="image-20241020123544343"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020123756444.png" alt="image-20241020123756444"></p>
<p>dao是session用动态代理造出来的，不同业务的内部实现有区别。session也不会一直复用，根源在sqlSessionFactory。</p>
<p>还有一个就是mapper映射，这个跟ssf没什么关系。</p>
<h4 id="MyBatisConfig-SqlSessionFactoryBean"><a href="#MyBatisConfig-SqlSessionFactoryBean" class="headerlink" title="MyBatisConfig - SqlSessionFactoryBean"></a>MyBatisConfig - SqlSessionFactoryBean</h4><p>导入mybatis-spring spring-jdbc，mybatis实现了Spring规定的FactoryBean接口，专门用来造sqlSessionFactory对象。</p>
<p>回顾spring创建对象的方法，一种是<a href="#thirdpartydi">使用构造</a>器直接得到对象，另一种就是使用factoryBean&lt;E&gt;得到对象E，定义一个造E的工厂Bean，这样spring就知道类型E创对象需要用工厂Bean的方式。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020130218463.png" alt="image-20241020130218463"></p>
<p>factorybean中提供了很多设置E参数的方法，最终返回的是一个设置好参数的E，思想还是一样的，只不过套了一层工厂的皮，封装进去很多固定的参数set方法，一般这个E需要xml进行配置(跟真正的业务代码解耦)，工厂Bean就取代了xml，直接给你返回一个配置好的对象。</p>
<p>需要传参就直接在写上方法参数即可，spring自动匹配</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020145504890.png" alt="image-20241020145504890"></p>
<h4 id="MyBatisConfig-MapperScannerConfigurer"><a href="#MyBatisConfig-MapperScannerConfigurer" class="headerlink" title="MyBatisConfig - MapperScannerConfigurer"></a>MyBatisConfig - MapperScannerConfigurer</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020145526730.png" alt="image-20241020145526730"></p>
<p>DAO没有实现类了，在原始接口上加Component、Repository给ioc容器标识一下，不标也行。</p>
<p>这个mapperScannerConfigurer是mybatis和spring集成的部分，扫描指定mapper所在的包，mapper生成代理对象，通过factoryBean方式交给Spring容器，所以重点不是让spring知道dao的实现类在哪，重点是要让mybatis知道mapper位置</p>
<h4 id="JdbcConfig-创建DataSource的Bean交给Spring管理"><a href="#JdbcConfig-创建DataSource的Bean交给Spring管理" class="headerlink" title="JdbcConfig - 创建DataSource的Bean交给Spring管理"></a>JdbcConfig - 创建DataSource的Bean交给Spring管理</h4><h3 id="Spring-amp-JUnit"><a href="#Spring-amp-JUnit" class="headerlink" title="Spring &amp; JUnit"></a>Spring &amp; JUnit</h3><p>导入spring-test 在Test<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020191443245.png" alt="image-20241020191443245"></p>
<p>在test.java中测试。</p>
<h4 id="RunWith-ContextConfiguration"><a href="#RunWith-ContextConfiguration" class="headerlink" title="@RunWith @ContextConfiguration"></a>@RunWith @ContextConfiguration</h4><h4 id="Autowired-Test"><a href="#Autowired-Test" class="headerlink" title="@Autowired @Test"></a>@Autowired @Test</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020145826024.png" alt="image-20241020145826024"></p>
<p>需要引用类型参数直接autowired注入即可，一般是业务类做测试</p>
<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><h2 id="AOP的含义"><a href="#AOP的含义" class="headerlink" title="AOP的含义"></a>AOP的含义</h2><p>AOP 面向切面编程 <strong>不惊动原始设计</strong>的情况下增强功能</p>
<p>Spring理念：无侵入式增强功能</p>
<ul>
<li>所有原始方法-&gt;连接点(joint point) 在SpringAOP中如此<ul>
<li>save update delete select</li>
</ul>
</li>
<li>需要追加功能的方法-&gt;切入点(pointcut)<ul>
<li>save update delete </li>
</ul>
</li>
<li>具备的共性功能-&gt;通知 (advice)<ul>
<li>method1   method2</li>
</ul>
</li>
<li>通知和切入点产生关系-&gt;切面 (aspect) <ul>
<li>save update delete追加method</li>
</ul>
</li>
<li>功能的集合-&gt;通知类</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020152910091.png" alt="image-20241020152910091"></p>
<p>连接点包含切入点</p>
<h2 id="Spring中进行AOP编程"><a href="#Spring中进行AOP编程" class="headerlink" title="Spring中进行AOP编程"></a>Spring中进行AOP编程</h2><h3 id="导入坐标"><a href="#导入坐标" class="headerlink" title="导入坐标"></a>导入坐标</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020154236445.png" alt="image-20241020154236445"></p>
<h3 id="MyAdvice"><a href="#MyAdvice" class="headerlink" title="MyAdvice"></a><mark>MyAdvice<mark></h3><h4 id="定义通知"><a href="#定义通知" class="headerlink" title="定义通知"></a>定义通知</h4><h4 id="定义切入点-Pointcut"><a href="#定义切入点-Pointcut" class="headerlink" title="定义切入点 @Pointcut"></a>定义切入点 @Pointcut</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020154309848.png" alt="image-20241020154309848"></p>
<p><code>private</code> <code>void</code> <code>空参</code> </p>
<h4 id="绑定通知与切入点"><a href="#绑定通知与切入点" class="headerlink" title="绑定通知与切入点"></a>绑定通知与切入点</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020154407660.png" alt="image-20241020154407660"></p>
<h4 id="Spring接管此类-Component"><a href="#Spring接管此类-Component" class="headerlink" title="Spring接管此类 @Component"></a>Spring接管此类 @Component</h4><h4 id="定义AOP-Aspect"><a href="#定义AOP-Aspect" class="headerlink" title="定义AOP @Aspect"></a>定义AOP @Aspect</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020154529656.png" alt="image-20241020154529656"></p>
<h3 id="SpringConfig-EnableAspectAutoProxy"><a href="#SpringConfig-EnableAspectAutoProxy" class="headerlink" title="SpringConfig @EnableAspectAutoProxy"></a><mark>SpringConfig @EnableAspectAutoProxy<mark></h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020154505110-1729410361899-4.png" alt="image-20241020154505110"></p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020155857766.png" alt="image-20241020155857766"></p>
<p>**基于<mark>动态代理<mark>**：</p>
<ul>
<li><p>匹配失败，new原始对象；</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020160228368.png" alt="image-20241020160228368"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020160243146.png" alt="image-20241020160243146"></p>
</li>
<li><p>匹配成功，new出来的是原始对象的代理对象；</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020160302140.png" alt="image-20241020160302140"></p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020160341452.png" alt="image-20241020160341452"></p>
</li>
</ul>
<p><strong>用获取到的bean执行方法</strong>：如果是代理的bean，根据通知和切入点进行方法执行。</p>
<h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3><p>切入点：要对其进行增强的方法</p>
<p>切入点表达式：对切入点的描述方式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020161523488.png" alt="image-20241020161523488"></p>
<p>execution(<code>public</code> <code>User</code> <code>com.itheima.service.UserService.findById</code>(<code>int</code>))</p>
<p>public exception 可省略</p>
<p>参数必须有</p>
<h4 id="通配符使用"><a href="#通配符使用" class="headerlink" title="通配符使用"></a>通配符使用</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020161833474.png" alt="image-20241020161833474"></p>
<ul>
<li>..和*的区别 *用于精准匹配到某个位置</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020163432072.png" alt="image-20241020163432072"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.itheima.dao.impl.BookDaoImpl.update())&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.impl.BookDaoImpl.update(*))&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(void com.*.*.*.update())&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* *..*(..))&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* *..*e(..))&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(void com..*())&quot;)</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.itheima.*.*Service.find*(..))&quot;)</span></span><br><span class="line"><span class="comment">//执行com.itheima包下的任意包下的名称以Service结尾的类或接口中的save方法，参数任意，返回值任意</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h3><h4 id="前置-Before"><a href="#前置-Before" class="headerlink" title="前置@Before"></a>前置@Before</h4><h4 id="后置-After"><a href="#后置-After" class="headerlink" title="后置@After"></a>后置@After</h4><h4 id="环绕-Around"><a href="#环绕-Around" class="headerlink" title="环绕@Around"></a><strong><u><mark>环绕@Around<mark></u></strong></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020170038080.png" alt="image-20241020170038080"></p>
<ul>
<li><p>ProceedingJoinPoint</p>
</li>
<li><p>原始方法在环绕方法中执行，用<code>pjp.proceed()</code>执行原始方法，<mark>不出现就能隔离原始方法，（权限校验）<mark></p>
</li>
<li><p>pjp能接原始方法的返回值，类型为Object，强转后可以在给他返回去，思想和动态代理里的案例比较像：利用反射invoke调用可以拿到返回值，<strong>注意修改通知方法的返回值为Object。</strong>没返回值也可以</p>
</li>
<li><p>强制抛Throwable </p>
</li>
</ul>
<h4 id="得到返回值之后-AfterReturning"><a href="#得到返回值之后-AfterReturning" class="headerlink" title="得到返回值之后@AfterReturning"></a>得到返回值之后@AfterReturning</h4><p>和after区别：after只要方法结束即可，不管是得到返回值正常结束还是抛异常。AfterReturning需要得到返回值正常结束才能</p>
<h4 id="抛出异常之后-AfterThrowing"><a href="#抛出异常之后-AfterThrowing" class="headerlink" title="抛出异常之后@AfterThrowing"></a>抛出异常之后@AfterThrowing</h4><h3 id="案例：JUnit-测量业务层接口执行效率"><a href="#案例：JUnit-测量业务层接口执行效率" class="headerlink" title="案例：JUnit 测量业务层接口执行效率"></a>案例：JUnit 测量业务层接口执行效率</h3><p>JUnit 测试服务类就private服务出来，<code>@Autowired</code> </p>
<p>下面写test具体方法。详见JUnit单元测试篇(Java SE)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020171154617.png" alt="image-20241020171154617"></p>
<p>获取方法签名 (执行信息) <code>getSignature()</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020171252962.png" alt="image-20241020171252962"></p>
<h3 id="通知获取数据"><a href="#通知获取数据" class="headerlink" title="通知获取数据"></a>通知获取数据</h3><h4 id="JoinPoint-amp-ProceedingJoinPoint"><a href="#JoinPoint-amp-ProceedingJoinPoint" class="headerlink" title="JoinPoint &amp; ProceedingJoinPoint"></a>JoinPoint &amp; ProceedingJoinPoint</h4><p><strong>作为通知的参数</strong>，如果出现，必须在第一个参数的位置上,PJP是JP的子类</p>
<p><code>Object[] getArgs()</code>: 获取原始方法的参数</p>
<p><code> Object proceed()</code> :环绕 PJP专用，调用原始方法同时返回这个方法的返回值</p>
<h4 id="AOP获取原始方法调用参数"><a href="#AOP获取原始方法调用参数" class="headerlink" title="AOP获取原始方法调用参数"></a><mark>AOP获取原始方法调用参数<mark></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020173959692.png" alt="image-20241020173959692"></p>
<p>这样可以对原始参数进行处理，可以增加程序健壮性。</p>
<p><code>Object proceed(Object[] args)</code> 可以把处理以后的参数传给原始方法。</p>
<h5 id="案例：网盘提取码去空格"><a href="#案例：网盘提取码去空格" class="headerlink" title="案例：网盘提取码去空格"></a>案例：网盘提取码去空格</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020180157823.png" alt="image-20241020180157823"></p>
<p>args本身是Object数组，拿进来需要转成字符串toString getArgs 然后遍历参数数组，对每个字符串参数trim，再把处理以后的传给proceed</p>
<h4 id="AOP获取返回值"><a href="#AOP获取返回值" class="headerlink" title="AOP获取返回值"></a>AOP获取返回值</h4><ol>
<li>环绕 pjp proceed </li>
<li>AfterReturning 注解的returning要和形参名字相同</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020175037570.png" alt="image-20241020175037570"></p>
<h4 id="AOP接收异常"><a href="#AOP接收异常" class="headerlink" title="AOP接收异常"></a>AOP接收异常</h4><ol>
<li><p>环绕 不要往出抛Throwable 内部try-catch</p>
</li>
<li><p>AfterThrowing 注解的throwing和形参名字相同</p>
</li>
</ol>
<p>![image-20241020174307577](<a target="_blank" rel="noopener" href="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/屏幕截图</a> 2024-10-20 174257.jpg)</p>
<h3 id="环绕通知模拟其他四种通知"><a href="#环绕通知模拟其他四种通知" class="headerlink" title="环绕通知模拟其他四种通知"></a>环绕通知模拟其他四种通知</h3><table>
<thead>
<tr>
<th>前置</th>
<th>最后调用proceed</th>
</tr>
</thead>
<tbody><tr>
<td>后置</td>
<td>try catch finally 在finally里写</td>
</tr>
<tr>
<td>AfterReturning</td>
<td>Object接住proceed的返回值</td>
</tr>
<tr>
<td>AfterThrowing</td>
<td>不要往出抛Throwable，try catch Throwable</td>
</tr>
</tbody></table>
<h2 id="AOP编程思想—this调用实例方法失效"><a href="#AOP编程思想—this调用实例方法失效" class="headerlink" title="AOP编程思想—this调用实例方法失效"></a>AOP编程思想—this调用实例方法失效</h2><p>AOP的核心，是从调用对象的方法时生成代理对象—PROXY，this指向真正的目标对象—TARGET</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IService</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">zoo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IService</span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">		System.println(<span class="string">&quot;fooStart...&quot;</span>);</span><br><span class="line">		zoo();<span class="comment">//this指针调用实例方法</span></span><br><span class="line">		System.println(<span class="string">&quot;fooFinish...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Transactional</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">zoo</span><span class="params">()</span>&#123;</span><br><span class="line">		save(a);<span class="comment">//假设是将a保存到数据库</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">		save(b);<span class="comment">//假设是将b保存到数据库</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IService service;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        service.foo();<span class="comment">//从外部调用内部的事务方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事务的实现基于spring aop，如果直接用this，则会使用target对象进行方法调用，</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/reference/core/aop/proxying.html#aop-understanding-aop-proxies">Proxying Mechanisms :: Spring Framework</a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/tx-decl-explained.html#page-title">Understanding the Spring Framework’s Declarative Transaction Implementation :: Spring Framework</a> </p>
<p>如果是在类内部开启的事务，就需要CGLIB动态代理，实现的基础是方法拦截器，环绕通知，</p>
<h3 id="直接调用方法"><a href="#直接调用方法" class="headerlink" title="直接调用方法"></a>直接调用方法</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241104161707487.png" alt="image-20241104161707487"></p>
<h3 id="通过代理调用方法"><a href="#通过代理调用方法" class="headerlink" title="通过代理调用方法"></a>通过代理调用方法</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241104161648309.png" alt="image-20241104161648309"></p>
<p>也就是说，如果要让代理生效，首先就是要获取代理对象，而通过@Transactional注解的方法<code>zoo()</code>，如果从外部调用，只要获得了代理对象的引用，事务功能就是生效的，因此直接在main中只要获取了代理对象的引用调用service.zoo()方法是没有问题的。</p>
<p>而在目标对象内部，this就是目标对象本身，肯定不会走代理，因此如果实在</p>
<h3 id="解决方案—在类的内部获取代理对象"><a href="#解决方案—在类的内部获取代理对象" class="headerlink" title="解决方案—在类的内部获取代理对象"></a>解决方案—在类的内部获取代理对象</h3><h4 id="AopContext-currentProxy"><a href="#AopContext-currentProxy" class="headerlink" title="AopContext.currentProxy()"></a>AopContext.currentProxy()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (UserHolder.getUser()) &#123;</span><br><span class="line">    <span class="comment">//开启事务需要获取当前的代理对象</span></span><br><span class="line">    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService)AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Autowired-注入服务对象本身"><a href="#Autowired-注入服务对象本身" class="headerlink" title="@Autowired 注入服务对象本身"></a>@Autowired 注入服务对象本身</h4><p>获取service对象即可，这样就能在类内部的上下文中获取proxy代理都象的引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ServiceImpl service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (UserHolder.getUser()) &#123;</span><br><span class="line">    <span class="comment">//开启事务需要获取当前的代理对象</span></span><br><span class="line">    <span class="keyword">return</span> service.createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以新开一个Impl2类，把方法移植进去，注入Impl2对象，思路一样</span></span><br></pre></td></tr></table></figure>



<h2 id="AOP：动态代理对象的生成时机"><a href="#AOP：动态代理对象的生成时机" class="headerlink" title="AOP：动态代理对象的生成时机"></a>AOP：动态代理对象的生成时机</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xzb5566/article/details/141639614">【spring系列】spring的AOP是在哪个阶段创建的动态代理对象，spring bean的生命周期中在什么阶段创建的aop动态代理对象，很多人会说第一种，其实还有一种情况也会进行aop_spring的aop代理对象什么时候创建-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2154184">关于Spring的两三事：代理对象的生成时机-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><strong>1） Bean的实例化</strong>：首先，Spring容器会实例化Bean。</p>
<p><strong>2）Bean的属性填充</strong>：然后，为Bean填充依赖注入的属性。</p>
<p><strong>3）Bean的初始化：</strong></p>
<ul>
<li><strong>初始化前（postProcessBeforeInitialization）</strong>：在这一阶段，Spring会调用所有BeanPostProcessor的postProcessBeforeInitialization方法。但此时，代理对象可能还未被创建，因为还需要进一步判断该Bean是否需要被代理。</li>
<li><strong>初始化</strong>：接着，执行Bean的初始化方法（如@PostConstruct注解的方法或实现了InitializingBean接口的afterPropertiesSet方法）。</li>
<li><strong>初始化后（postProcessAfterInitialization）</strong>：在Bean初始化完成后，Spring会调用所有BeanPostProcessor的postProcessAfterInitialization方法。这通常是**创建动态代理对象的时机(AOP)**，因为此时Bean已经完全初始化并准备使用，而且代理对象可以在这一阶段被创建并替换掉原始的Bean实例。</li>
</ul>
<p><strong>4）代理对象的创建：</strong> </p>
<ul>
<li>在postProcessAfterInitialization方法中，Spring会检查该Bean是否需要被代理（通常基于是否存在对应的Advisor或Aspect）。</li>
<li>如果需要，Spring会根据Bean的类型（是否实现了接口）选择合适的代理方式（JDK动态代理或CGLIB代理）来创建代理对象。</li>
<li>代理对象会封装原始Bean，并在方法调用时插入增强的逻辑（如前置通知、后置通知等）。</li>
</ul>
<p><strong>5）Bean的交付</strong>：最后，将创建好的代理对象（如果需要的话）或原始Bean实例交付给客户端使用。</p>
<p>因此，<strong>Spring AOP的动态代理对象主要是在Bean的初始化后的postProcessAfterInitialization阶段创建的</strong>。这一过程确保了代理对象能够封装并增强原始Bean的方法调用，同时保持了Bean的生命周期和依赖注入的完整性。</p>
<h1 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h1><p>事务用于业务层或者Dao层</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wang489687009/article/details/129259394">【Spring事务三千问】Spring的事务管理与MyBatis事务管理结合的原理_spring transaction和mybatis的整合 原理-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/358657396">【spring源码深度解析】：spring是如何利用@Transactional注解实现数据库事务的？把握住事务的基本用法你就懂了 - 知乎 (zhihu.com)</a></p>
<h2 id="事务管理整合"><a href="#事务管理整合" class="headerlink" title="事务管理整合"></a>事务管理整合</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jddreams/p/14024754.html">图解Java JDBC和JPA的区别 - 快乐随行 - 博客园 (cnblogs.com)</a></p>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ul>
<li>InnoDB存储引擎支持事务（SQL语句）</li>
</ul>
<h3 id="原生JDBC"><a href="#原生JDBC" class="headerlink" title="原生JDBC"></a>原生JDBC</h3><ul>
<li> 注册驱动，</li>
<li> 获取Connection，</li>
<li> 建立Statement执行SQL语句，Connection可以管理事务（本质是执行SQL语句）</li>
</ul>
<h3 id="DataSource数据源"><a href="#DataSource数据源" class="headerlink" title="DataSource数据源"></a>DataSource数据源</h3><ul>
<li>主要用来获取并管理，调度Connection</li>
</ul>
<h3 id="原生-MyBatis-ORM"><a href="#原生-MyBatis-ORM" class="headerlink" title="原生 MyBatis (ORM)"></a>原生 MyBatis (ORM)</h3><ul>
<li><p>可以调用外部数据源获取Connection，也可以使用原生JDBC来获取，最终这些Connection可以呗SqlSession获取到。</p>
</li>
<li><p>SqlSession同样能管理事务，底层是基于Transaction(也是mybatis的一个类)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">affected_rows</span> <span class="operator">=</span> session.insert(<span class="string">&quot;com.kvn.mapper.UserMapper.insert&quot;</span>, user);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 捕获到异常，将操作回滚</span></span><br><span class="line">    session.rollback();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正常执行，提交事务</span></span><br><span class="line">session.commit();</span><br><span class="line">session.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Spring联合MyBatis事务管理"><a href="#Spring联合MyBatis事务管理" class="headerlink" title="Spring联合MyBatis事务管理"></a>Spring联合MyBatis事务管理</h3><p><code>SpringManagedTransaction</code> 打通了 MyBatis 的事务管理、连接管理 和 spring-tx 的 事务管理、连接管理，使得 MyBatis 与 Spring 可以使用统一的方式来管理连接的生命周期 和 事务处理。</p>
<ol start="0">
<li><p>原生的MyBatis 使用的是JdbcTransaction实现类</p>
</li>
<li><p>在一个非 <code>@Transactional</code> 标记的方法中执行 sql 命令，则事务的管理会通过 <code>SpringManagedTransaction</code> 来执行。</p>
</li>
<li><p>在一个 <code>@Transactional</code> 标记的事务方法中执行 sql 命令，则 <code>SpringManagedTransaction</code> 的 <code>commit()/rollback()</code> 方法不会执行任何动作，而事务的管理会走 Spring AOP 事务管理，即通过 <code>org.springframework.transaction.interceptor.TransactionInterceptor</code> 来进行拦截处理。</p>
</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020215834772.png" alt="image-20241020215834772"></p>
<ol start="3">
<li>SqlSessionInterceptor 保证了 MyBatis 的 SqlSession 在执行 sql 时使用的连接与 Spring 事务管理操作使用的连接是<u>同一个</u>连接。具体就是通过 Spring 的事务同步器 <code>TransactionSynchronizationManager</code> 来保证的。</li>
<li>SpringManagedTransaction 中连接的获取是从 Spring 管理的 DataSource 中获取的，这样，数据库连接池也就和 spring 整合在一起了。</li>
</ol>
<h2 id="多线程事务"><a href="#多线程事务" class="headerlink" title="多线程事务"></a>多线程事务</h2><h3 id="javax-sql-Connection"><a href="#javax-sql-Connection" class="headerlink" title="javax.sql.Connection"></a>javax.sql.Connection</h3><p>简单地来说，建立<code>Connection</code>连接，会消耗数据库系统的如下资源：</p>
<table>
<thead>
<tr>
<th align="center">资源</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">线程数</td>
<td align="center">线程越多，线程的上下文切换会越频繁，会影响其处理能力</td>
</tr>
<tr>
<td align="center">创建Connection的开销</td>
<td align="center">由于Connection负责和数据库之间的通信，在创建环节会做大量的初始化 ，创建过程所需时间和内存资源上都有一定的开销</td>
</tr>
<tr>
<td align="center">内存资源</td>
<td align="center">为了维护Connection对象会消耗一定的内存</td>
</tr>
<tr>
<td align="center">锁占用</td>
<td align="center">在高并发模式下，不同的Connection可能会操作相同的表数据，就会存在锁的情况，数据库为了维护这种锁会有不少的内存开销</td>
</tr>
</tbody></table>
<p>事务的执行依赖于JDBC-connection，connection的建立基于tcp连接，需要耗费很多资源，所以在多线程并发的情况下，connection数目远少于thread数，需要尽可能考虑connection的共用和复用。</p>
<p>connection可以显式开启和关闭事务，遵循事务的ACID原则，因此虽然共用connection，但是同一时间同一connection只能有同一个事务正在执行，也就是串行执行，否则会造成事务紊乱。</p>
<p>一个最佳实践：<strong>当线程需要做数据库操作时，才会真正请求获取JDBC数据库连接,线程使用完了之后，立即释放，被释放的JDBC数据库连接等待下次分配使用</strong></p>
<p>最简单的方式就是把事务执行的代码块用connection锁对象锁住：事务执行完以后释放（但不销毁）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(connection)&#123;</span><br><span class="line">    <span class="comment">//tx......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程如何获取锁对象？为了保证一个线程所有dao操作都是用的同一个connection，使用threadLocal存放属于线程自己的connection，如果是直接从连接池获得的话，多个 DAO 就用到了多个Connection，不能完成一个事务。而连接池负责提供缓存和提供connection</p>
<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/luanlouis/article/details/37671851">《深入理解mybatis原理》 Mybatis数据源与连接池_mybatis 连接池-CSDN博客</a></p>
<p>原生的JDBC会让connection的close()方法执行数据库连接的释放与销毁，为了保证不更改原生的功能，我们可以使用代理对象，让其close方法不会真正执行，而是回收到数据库连接池中。</p>
<p>使用数据库连接池，通常都是得到一个javax.sql.DataSource[接口]的实例对象，它里面包含了Connection，并且数据库连接池工具类（比如C3P0、JNDI、DBCP等）重新定义了getConnection、closeConnection等方法，所以每次得到的Connection，几乎都不是新建立的连接（而是已经建立好并放到缓存里面的连接），调用closeConnection方法，也不是真正的关闭连接（一般都是起到一个标识作用，标识当前连接已经使用完毕，归还给连接池，让这个连接处于待分配状态）【PS：所以说：使用数据库连接池时，还是要显式的调用数据库连接池API提供的关闭连接的方法】。</p>
<p>至于为什么要用ThreadLocal呢?这个和连接池无关,我认为更多的是和程序本身相关,为了更清楚的说明,我举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">servlet中获取一个连接.首先,servlet是线程安全的吗?</span><br><span class="line"></span><br><span class="line">     class MyServlet extends HttpServlet&#123;</span><br><span class="line">         private Connection conn;</span><br><span class="line">     &#125;</span><br><span class="line">     ok,遗憾的告诉你,这个conn并不是安全的,所有请求这个servlet的连接,使用的都是一个Connection,这个就是致命的了.多个人使用同一个连接,算上延迟啥的,天知道数据会成什么样.</span><br><span class="line">     因此我们要保证Connection对每个请求都是唯一的.这个时候就可以用到ThreadLocal了,保证每个线程都有自己的连接.</span><br><span class="line">     改为 private ThreadLocal&lt;Connection&gt; ct = new ThreadLocal&lt;Connnection&gt;();</span><br><span class="line">     然后从连接池获取Connection,set到ct中,再get就行了,至于得到的是哪个Connection就是连接池的问题了,你也管不到.</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal?"></a>ThreadLocal?</h3><p>就是为每一个使用该变量的线程都提供一个变量值的副本，是每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲</p>
<h2 id="开启步骤"><a href="#开启步骤" class="headerlink" title="开启步骤"></a>开启步骤</h2><h3 id="业务层-接口-为业务方法打开事务-Transactional"><a href="#业务层-接口-为业务方法打开事务-Transactional" class="headerlink" title="业务层**接口**为业务方法打开事务@Transactional"></a>业务层**<mark>接口<mark>**为业务方法打开事务@Transactional</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020204651727.png" alt="image-20241020204651727"></p>
<ul>
<li><p>@Transactional是方法级别或者类级别的注解，可以<strong>开在整个接口上</strong>，也可以开在单个方法上</p>
</li>
<li><p>接口能够提高复用性，降低耦合</p>
</li>
</ul>
<h3 id="JdbcConfig创建事务管理器Bean-Bean"><a href="#JdbcConfig创建事务管理器Bean-Bean" class="headerlink" title="JdbcConfig创建事务管理器Bean@Bean"></a>JdbcConfig创建事务管理器Bean@Bean</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020204933459.png" alt="image-20241020204933459"></p>
<p>PlatformTransactionManager是Spring规定的，DataSourceTransactionManager可以动，根据具体的技术选择</p>
<p>要注意，事务管理器的datasource和mybatis用的datasource必须是同一个，不然</p>
<h3 id="SpringConfig打开事务-EnableTransactionManagement"><a href="#SpringConfig打开事务-EnableTransactionManagement" class="headerlink" title="SpringConfig打开事务@EnableTransactionManagement"></a>SpringConfig打开事务@EnableTransactionManagement</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020205233232.png" alt="image-20241020205233232"></p>
<h2 id="事务角色"><a href="#事务角色" class="headerlink" title="事务角色"></a>事务角色</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020205625500.png" alt="image-20241020205625500"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020205648701.png" alt="image-20241020205648701"></p>
<h2 id="事务配置"><a href="#事务配置" class="headerlink" title="事务配置"></a>事务配置</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020222103484.png" alt="image-20241020222103484"></p>
<p>有些异常不会触发回滚，需要手动设置一下rollbackFor</p>
<h3 id="追加日志"><a href="#追加日志" class="headerlink" title="追加日志"></a>追加日志</h3><p>try finally结构，finally 记日志功能必定触发</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020222628555.png" alt="image-20241020222628555"></p>
<h3 id="事务传播行为控制"><a href="#事务传播行为控制" class="headerlink" title="事务传播行为控制"></a>事务传播行为控制</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013341344#item-2-2">(1) java - Spring事务传播行为详解 - 个人文章 - SegmentFault 思否</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241020222917510.png" alt="image-20241020222917510"></p>
<p>transfer、AccountDao中所有的数据层方法、日志记录的业务方法都加了Transacitonal注解。</p>
<ul>
<li>transfer作为方法的调用者，是事务的管理员。</li>
<li>其他作为被调用者，是事务的协调员。</li>
<li>如果默认设置Required，管理员开事务，协调员都会加入</li>
</ul>
<p><code>@Transactional(propagation = Propagation.REQUIRES_NEW)</code></p>
<p>开启事务：<code>@Transactional</code></p>
<p>管理员肯定要开启事务，管理员默认是<code>REQUIRED</code>一般不用改，某一个协调员要单开另外一个事务，那么就可以把这个协调员的事务传播机制改成<code>REQUIRES_NEW</code> </p>
<h4 id="Propagation-REQUIRED"><a href="#Propagation-REQUIRED" class="headerlink" title="Propagation.REQUIRED"></a>Propagation.REQUIRED</h4><p><strong>外围方法未开启事务的情况下<code>Propagation.REQUIRED</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</strong> </p>
<p><strong>在外围方法开启事务的情况下<code>Propagation.REQUIRED</code>修饰的内部方法会加入到外围方法的事务中，所有<code>Propagation.REQUIRED</code>修饰的内部方法和外围方法均属于同一事务，只要一个方法回滚，整个事务均回滚。</strong></p>
<h4 id="Propagation-REQUIRES-NEW"><a href="#Propagation-REQUIRES-NEW" class="headerlink" title="Propagation.REQUIRES_NEW"></a>Propagation.REQUIRES_NEW</h4><p><strong>外围方法未开启事务的情况下<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</strong> </p>
<p><strong>在外围方法开启事务的情况下<code>Propagation.REQUIRES_NEW</code>修饰的内部方法依然会单独开启独立事务，且与外部方法事务也独立，内部方法之间、内部方法和外部方法事务均相互独立，互不干扰。</strong></p>
<h2 id="事务失效"><a href="#事务失效" class="headerlink" title="事务失效"></a>事务失效</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hanjiaqian/article/details/120501741">spring 事务失效的 12 种场景_spring 截获duplicatekeyexception 不抛异常-CSDN博客</a></p>
<ul>
<li>访问权限，private,default无法生效</li>
<li>方法用final或static修饰，代理对象无法重写</li>
<li>多线程调用事务方法，两个线程获取的不是同一个连接</li>
<li>数据库或表不支持事务（MySQL的MyISAM不支持事务）</li>
<li>未开启事务或未将类纳入Spring管理<code>@Transactional</code> <code>@Service</code> </li>
</ul>
<h3 id="方法自调用"><a href="#方法自调用" class="headerlink" title="方法自调用"></a><span id="selfinvoke">方法自调用</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        updateStatus(userModel);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateStatus</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">        doSameThing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到在事务方法 add 中，直接调用事务方法 updateStatus。从前面介绍的内容可以知道，updateStatus 方法拥有事务的能力是因为 spring aop 生成代理对象proxy，但是这种方法直接调用了 this 对象的方法，所以 updateStatus 方法不会生成事务。</p>
<p>由此可见，在同一个类中的方法直接内部调用，会导致事务失效。</p>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><p>Java实现MVC模型的web框架，灵活性强，主要进行<strong>表现层开发</strong> Controller。</p>
<h3 id="导坐标"><a href="#导坐标" class="headerlink" title="导坐标"></a>导坐标</h3><h3 id="bean创建-Controller"><a href="#bean创建-Controller" class="headerlink" title="bean创建@Controller"></a>bean创建@Controller</h3><h4 id="方法级别注解-请求映射-RequestMapping"><a href="#方法级别注解-请求映射-RequestMapping" class="headerlink" title="方法级别注解 请求映射 @RequestMapping"></a>方法级别注解 请求映射 @RequestMapping</h4><h4 id="方法级别注解-设置响应-ResponseBody"><a href="#方法级别注解-设置响应-ResponseBody" class="headerlink" title="方法级别注解 设置响应 @ResponseBody"></a>方法级别注解 设置响应 @ResponseBody</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021161644841.png" alt="image-20241021161644841"></p>
<p>都是方法级别注解    </p>
<h3 id="创建SpringMvcConfig-Configuration-ComponentScan"><a href="#创建SpringMvcConfig-Configuration-ComponentScan" class="headerlink" title="创建SpringMvcConfig@Configuration@ComponentScan"></a>创建SpringMvcConfig@Configuration@ComponentScan</h3><p>扫描到controller</p>
<h3 id="创建servlet容器Config"><a href="#创建servlet容器Config" class="headerlink" title="创建servlet容器Config"></a>创建servlet容器Config</h3><p>ServletContainerInitConfig继承AbstractDispatcherServeltInitializer类重写对应方法。都是一次性</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021161341011.png" alt="image-20241021161341011"></p>
<ul>
<li><code>getServletMappings</code> 表示接管URL的那个部分的映射</li>
<li><code>createRootApplicationContext</code> 创建Spring Framework容器并指定配置    </li>
<li><code>createServletApplicationContext</code> 创建web容器并指定配置</li>
<li>web容器 <strong>servlet容器</strong></li>
</ul>
<h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021162133487.png" alt="image-20241021162133487"></p>
<h3 id="bean加载-ComponentScan-Filter"><a href="#bean加载-ComponentScan-Filter" class="headerlink" title="bean加载@ComponentScan.Filter"></a>bean加载@ComponentScan.Filter</h3><p><u>Spring避免加载springmvc的controller</u></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021162700082.png" alt="image-20241021162700082"></p>
<p>导包：mybatis自动代理会返回dao接口的实现对象，可以不写，但是其他技术不一定是这样，所以为了通用性还是应该导dao</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021164147565.png" alt="image-20241021164147565"></p>
<p>SpringConfig扫描排除含有Controller注解的类：<strong>Filter</strong> 可以更细粒度地加载bean</p>
<p>exclude排除</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021164311077.png" alt="image-20241021164311077"></p>
<p>加了configuration的类，spring都会将其作为配置类，里面如果有componentScan，就会扫上。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021164930504.png" alt="image-20241021164930504"></p>
<p>创建容器设定配置再去返回容器，简化过程只需要指定类的字节码即可</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021165128160.png" alt="image-20241021165128160"></p>
<h2 id="配置Controller"><a href="#配置Controller" class="headerlink" title="配置Controller"></a>配置Controller</h2><h3 id="请求Request相关"><a href="#请求Request相关" class="headerlink" title="请求Request相关"></a>请求Request相关</h3><h4 id="请求映射路径-RequestMapping"><a href="#请求映射路径-RequestMapping" class="headerlink" title="请求映射路径@RequestMapping"></a>请求映射路径@RequestMapping</h4><p>对于不同的controller可能会优相同方法，这时会有冲突问题，解决办法是在controller**<mark>类<mark><strong>上加一个@RequestMapping，要和</strong><mark>方法<mark>**的@RequestMapping注解结合一下。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021172423291.png" alt="image-20241021172423291"></p>
<h4 id="名称匹配-指定请求参数名-RequestParam"><a href="#名称匹配-指定请求参数名-RequestParam" class="headerlink" title="名称匹配 指定请求参数名@RequestParam"></a>名称匹配 指定<mark>请求参数<mark>名@RequestParam</h4><p>用于接收GET请求中URL的查询参数，也可以接收POST请求的参数（表单）</p>
<blockquote>
<p>You can use the <code>@RequestParam</code> annotation to bind Servlet request parameters (that is, query parameters or form data) to a method argument in a controller.</p>
</blockquote>
<p>与mybatis类似，对于外部传进来的请求参数用map封装，因此**@RequestParam接收的是key-value形式的参数<strong>，</strong>发送get请求**只会处理URL中的参数，忽略请求体中的数据</p>
<p><strong>发送post请求</strong>时，<mark>表单数据在请求体中<mark>，不过仍然是username=root这样键值对的形式存在，如果URL里有请求参数，服务端收到以后会一并加到map中，打印出来，即使方法里的参数只是一个String也能打印出来</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021220731172.png" alt="image-20241021220731172"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021220755961.png" alt="image-20241021220755961" style="zoom:150%;" /></p>
<p>@RequestParam XXX xxx 表示查询参数用XXX类型接</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43606226/article/details/106545024">SpringMvc--@RequestBody和@RequestParam注解以及不加注解接收参数的区别_不写接收参数的注解,默认使用什么的-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_12393361/5021343">解决mybatis不加@Param报错 org.apache.ibatis.binding.BindingException_51CTO博客_mybatis @Param</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zeng1994/p/9110632.html">记一次SpringMVC碰到的坑 - zeng1994 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as513385/article/details/93512699">关于SpringMvc使用时,不加@RequestParam注解,根据方法形参名也可以获取请求值的分析_spring 请求体不写注解-CSDN博客</a></p>
<p>和 <strong>MyBatis</strong> 一样，使用反射机制获取参数名称，JDK8以后 java.lang.reflect.Parameter 中能够获取参数相关信息，框架就是利用这个机制，不加RequestParam获取参数信息。不然就只有arg0 arg1这种形式。</p>
<ul>
<li>required参数 是否为必传参数，默认必传</li>
<li>defaultValue 参数默认值</li>
</ul>
<h4 id="传递多种类型的请求参数"><a href="#传递多种类型的请求参数" class="headerlink" title="传递多种类型的请求参数"></a>传递多种类型的<mark>请求参数<mark></h4><p>与mybatis类似</p>
<ul>
<li><p>pojo：直接使用pojo内部的字段名称</p>
</li>
<li><p>嵌套pojo：address.字段名称</p>
</li>
<li><p>数组：直接接收字符串数组即可，请求的参数名就是数组的形参名，会把数组当成一个独立的参数</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021192646729.png" alt="image-20241021192646729"></p>
</li>
<li><p>集合类型：加RequestParam注解。 因为集合属于<strong>引用类型</strong>，spring会把它当成pojo处理（造pojo然后根据字段名注入依赖），不加param注解，spring就不会像数组一样把他当成一个独立的参数。</p>
</li>
</ul>
<h5 id="传JSON-EnableWebMvc"><a href="#传JSON-EnableWebMvc" class="headerlink" title="传JSON @EnableWebMvc"></a>传JSON @<mark>EnableWebMvc<mark></h5><p>导坐标 webMvc</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021193842326.png" alt="image-20241021193842326"></p>
<h6 id="参数在请求体里-RequestBody"><a href="#参数在请求体里-RequestBody" class="headerlink" title="参数在请求体里@RequestBody"></a>参数在请求体里@RequestBody</h6><p>@RequestBody XXX xxx 表示请求体中的数据用XXX类型接</p>
<p>RequestBody请求体中的数据通常是以JSON、XML等格式发送的，可以将请求体中的数据自动绑定到指定的Java对象上。</p>
<ol>
<li>参数写在请求体里，用List接收json数组</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021194047781.png" alt="image-20241021194047781"></p>
<ol start="2">
<li>用Pojo类接单个pojo对象json</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021194303198.png" alt="image-20241021194303198"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021194445000.png" alt="image-20241021194445000"></p>
<ol start="3">
<li>用List<pojo>接收多个pojo对象的json，</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021194340592.png" alt="image-20241021194340592"></p>
<p>一个请求，只有一个RequestBody；一个请求，可以有多个RequestParam。</p>
<p><strong>Body vs Param:</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021222507281.png" alt="image-20241021222507281"></p>
<h5 id="日期参数格式化-DateTimeFormat-pattern-”yyyy-MM-dd”"><a href="#日期参数格式化-DateTimeFormat-pattern-”yyyy-MM-dd”" class="headerlink" title="日期参数格式化@DateTimeFormat(pattern=”yyyy-MM-dd”)"></a>日期参数格式化@DateTimeFormat(pattern=”yyyy-MM-dd”)</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021223057976.png" alt="image-20241021223057976"></p>
<p>默认yyyy/MM/dd 其他形式不认识，需要自己手动指明formatPattern</p>
<h5 id="Converter接口-将字符串参数转换成Java类型"><a href="#Converter接口-将字符串参数转换成Java类型" class="headerlink" title="Converter接口-将字符串参数转换成Java类型"></a>Converter接口-将字符串参数转换成Java类型</h5><p>请求里面的参数都是以字符串形式发来的，converter要根据形参类型，把字符串转成对应类型提供给方法，这就是为什么前面能把字符串12按照需求转换成int 12</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021223621200.png" alt="image-20241021223621200"></p>
<p>@EnableWebMvc</p>
<h3 id="响应Response相关"><a href="#响应Response相关" class="headerlink" title="响应Response相关"></a>响应Response相关</h3><h4 id="响应页面（跳转页面）"><a href="#响应页面（跳转页面）" class="headerlink" title="响应页面（跳转页面）"></a>响应页面（跳转页面）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toPage&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toJumpPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接在方法里 return “page.jsp” </p>
<p>Spring默认认为Controller的方法返回的就是一个页面</p>
<h4 id="响应文本数据-ResponseBody"><a href="#响应文本数据-ResponseBody" class="headerlink" title="响应文本数据@ResponseBody"></a>响应文本数据@ResponseBody</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021225227708.png" alt="image-20241021225227708"></p>
<p>如果直接return一个字符串Spring会认为这个字符串是一个网页，响应分为响应行响应头和响应体，响应头里是放状态码之类的，只能在响应体里返回数据，加@ResponseBody注解表示返回值就是响应体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toText&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toText</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//表示返回 page.jsp 这个字符串</span></span><br></pre></td></tr></table></figure>

<h4 id="响应POJO对象-JSON形式"><a href="#响应POJO对象-JSON形式" class="headerlink" title="响应POJO对象(JSON形式)"></a>响应POJO对象(JSON形式)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toJsonPOJO&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">toJsonPOJO</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;返回json对象数据&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">15</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接返回user即可，jackson帮我们做的</p>
<h5 id="响应POJO对象集合（JSON数组）"><a href="#响应POJO对象集合（JSON数组）" class="headerlink" title="响应POJO对象集合（JSON数组）"></a>响应POJO对象集合（JSON数组）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toJsonList&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">toJsonList</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;返回json集合数据&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user1.setName(<span class="string">&quot;传智播客&quot;</span>);</span><br><span class="line">    user1.setAge(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user2.setName(<span class="string">&quot;黑马程序员&quot;</span>);</span><br><span class="line">    user2.setAge(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">    userList.add(user1);</span><br><span class="line">    userList.add(user2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="HttpMessageConverter接口"><a href="#HttpMessageConverter接口" class="headerlink" title="HttpMessageConverter接口"></a>HttpMessageConverter接口</h5><p>POJO转JSON字符串</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021225843796.png" alt="image-20241021225843796"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021225823024.png" alt="image-20241021225823024"></p>
<h3 id="REST-风格"><a href="#REST-风格" class="headerlink" title="REST 风格"></a>REST 风格</h3><p><strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021230252993.png" alt="image-20241021230252993"></p>
<p>根据请求的方式区分 GET POST PUT DELETE</p>
<p>同一URL，请求方式不同，调用的方法也不同</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021230150675.png" alt="image-20241021230150675"></p>
<p>RESTful：用REST风格访问资源</p>
<h4 id="RequestMapping-加-method-参数"><a href="#RequestMapping-加-method-参数" class="headerlink" title="@RequestMapping 加 method 参数"></a>@RequestMapping 加 method 参数</h4><p><code>@RequestMapping(value = &quot;/users/&#123;id&#125;&quot; ,method = RequestMethod.DELETE)</code> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021231918974.png" alt="image-20241021231918974"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021231836548.png" alt="image-20241021231836548"></p>
<h5 id="URL占位符传参-PathVariable"><a href="#URL占位符传参-PathVariable" class="headerlink" title="URL占位符传参 @PathVariable"></a>URL占位符传参 <mark>@PathVariable<mark></h5><p>value=”/users/{id}”  URL中的{id}和用@PathVariable修饰的方法参数id是一致的</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021231846312.png" alt="image-20241021231846312"></p>
<h5 id="RequestBody-RequestParam-PathVariable"><a href="#RequestBody-RequestParam-PathVariable" class="headerlink" title="@RequestBody@RequestParam@PathVariable"></a>@RequestBody@RequestParam@PathVariable</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021232010983.png" alt="image-20241021232010983"></p>
<h4 id="RESTful-快速开发"><a href="#RESTful-快速开发" class="headerlink" title="RESTful 快速开发"></a><mark>RESTful 快速开发<mark></h4><h5 id="类级别注解-RequestMapping"><a href="#类级别注解-RequestMapping" class="headerlink" title="类级别注解 @RequestMapping"></a>类级别注解 @RequestMapping</h5><p>省去所有user前缀，写一次就好。</p>
<h5 id="类级别注解-RestController"><a href="#类级别注解-RestController" class="headerlink" title="类级别注解 @RestController"></a>类级别注解 @RestController</h5><p>类级别的@RequestBody，表示所有类的返回值都是请求体的数据，既然@Controller和RequestBody都要写，合而为一即可</p>
<h5 id="方法级别注解-PostMapping"><a href="#方法级别注解-PostMapping" class="headerlink" title="方法级别注解 @PostMapping"></a>方法级别注解 @PostMapping</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot; ,method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/&#123;id&#125;&quot;)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021232955549.png" alt="image-20241021232955549"></p>
<h4 id="RESTful-页面交互案例"><a href="#RESTful-页面交互案例" class="headerlink" title="RESTful 页面交互案例"></a>RESTful 页面交互案例</h4><p>RestController PostMapping GetMapping DeleteMapping PutMapping </p>
<p>方法参数RequestBody</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021235556399.png" alt="image-20241021235556399"></p>
<h5 id="Config-类-SpringMvcSupport-放行静态页面访问"><a href="#Config-类-SpringMvcSupport-放行静态页面访问" class="headerlink" title="Config 类 SpringMvcSupport 放行静态页面访问"></a>Config 类 SpringMvcSupport 放行静态页面访问</h5><p>@Configuration</p>
<p>默认SpringMvcConfig接管/后所有东西，通过ResourceHandlerRegistry 设置SpringMVC如何处理对静态资源的访问 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021235616215.png" alt="image-20241021235616215"></p>
<h5 id="前端ajax"><a href="#前端ajax" class="headerlink" title="前端ajax"></a>前端ajax</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241021235623670.png" alt="image-20241021235623670"></p>
<h2 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h2><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><h3 id="整合Config包"><a href="#整合Config包" class="headerlink" title="整合Config包"></a>整合Config包</h3><h4 id="SpringConfig"><a href="#SpringConfig" class="headerlink" title="SpringConfig"></a>SpringConfig</h4><p><code>Configuration</code> <code>ComponentScan</code> <code>Import</code></p>
<h5 id="MyBatisConfig-amp-JdbcConfig"><a href="#MyBatisConfig-amp-JdbcConfig" class="headerlink" title="MyBatisConfig &amp; JdbcConfig"></a>MyBatisConfig &amp; JdbcConfig</h5><p>JdbcConfig：数据源 DataSource Bean</p>
<p>MyBatisConfig：sqlSessionFactoryBean</p>
<p><code>Bean</code> <code>jdbc.properties</code> </p>
<h4 id="SpringMvcConfig"><a href="#SpringMvcConfig" class="headerlink" title="SpringMvcConfig"></a>SpringMvcConfig</h4><p><code>Configuration</code> <code>ComponentScan</code> <code>EnableWebMvc</code></p>
<h5 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h5><p>rootApplicationContext和webApplicationContext</p>
<h3 id="编写后端模块"><a href="#编写后端模块" class="headerlink" title="编写后端模块"></a>编写后端模块</h3><h4 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h4><p>实体类，User</p>
<h4 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h4><p>MyBatis Mapper自动代理，写接口，写方法结合注解</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022135643205.png" alt="image-20241022135643205"></p>
<p>占位符对应参数的名称，这里映射实体类中的字段信息     </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022135845990.png" alt="image-20241022135845990"></p>
<h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>BookDao@Autowired</p>
<p>dao接口加repository注解（可加可不加）</p>
<h4 id="RestController"><a href="#RestController" class="headerlink" title="RestController"></a>RestController</h4><p>参数在url中：PathVariable</p>
<p>参数在请求体：RequestBody</p>
<h4 id="JUnit-测试-Service"><a href="#JUnit-测试-Service" class="headerlink" title="JUnit 测试 Service"></a>JUnit 测试 Service</h4><h4 id="Postman-测试-Controller"><a href="#Postman-测试-Controller" class="headerlink" title="Postman 测试 Controller"></a>Postman 测试 Controller</h4><h4 id="Spring-事务激活"><a href="#Spring-事务激活" class="headerlink" title="Spring 事务激活"></a>Spring 事务激活</h4><p><code>JdbcConfig</code> 里 加PlatformTransactionManager Bean, 接dataSource参数</p>
<p><code>Service</code>接口添加@Transactional</p>
<h3 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h3><h4 id="表现层数据封装模型-设置统一的返回结果集Result"><a href="#表现层数据封装模型-设置统一的返回结果集Result" class="headerlink" title="表现层数据封装模型 - 设置统一的返回结果集Result"></a>表现层数据封装模型 - 设置统一的返回结果集Result</h4><p>实际开发过程中前后端<mark>约定<mark></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">//下方提供若干构造方法,有参无参</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code,Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code, Object data, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....getter setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022152253512-1729581786093-1.png" alt="image-20241022152253512"></p>
<h5 id="Result-data"><a href="#Result-data" class="headerlink" title="Result.data"></a>Result.data</h5><p>业务方法不同返回数据格式也不同，可能是true false这样的text，也可能是json数据，还可能是json数组，约定将数据封装到<mark>data<mark>字段中</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022144637267.png" alt="image-20241022144637267"></p>
<h5 id="Result-code"><a href="#Result-code" class="headerlink" title="Result.code"></a>Result.code</h5><p>不同业务方法可能会返回相同的内容，返回一个true可能对应新增，修改，删除的业务方法，加一个识别码<mark>code<mark>字段区分 ，可以约定尾数是0表示失败，尾数是1表示成功：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022145108783.png" alt="image-20241022145108783"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SAVE_OK</span> <span class="operator">=</span> <span class="number">20011</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DELETE_OK</span> <span class="operator">=</span> <span class="number">20021</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">UPDATE_OK</span> <span class="operator">=</span> <span class="number">20031</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">GET_OK</span> <span class="operator">=</span> <span class="number">20041</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SAVE_ERR</span> <span class="operator">=</span> <span class="number">20010</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DELETE_ERR</span> <span class="operator">=</span> <span class="number">20020</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">UPDATE_ERR</span> <span class="operator">=</span> <span class="number">20030</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">GET_ERR</span> <span class="operator">=</span> <span class="number">20040</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里Result的构造器识别的是Integer code</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Enum枚举：CodeEnum是一个类，类内部有一字段code(Integer)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022152238169.png" alt="image-20241022152238169"></p>
<h5 id="Result-message"><a href="#Result-message" class="headerlink" title="Result.message"></a>Result.message</h5><p>一些业务方法，本来应该返回json，没查到只能返回null，不能直接把null展示给用户看，展示的是message信息</p>
<h5 id="Controller-返回值统一设定为-Result"><a href="#Controller-返回值统一设定为-Result" class="headerlink" title="Controller 返回值统一设定为 Result"></a>Controller 返回值统一设定为 Result</h5><p>将返回值封装到Result中，data</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Book&gt; bookList = bookService.getAll();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> bookList != <span class="literal">null</span> ? Code.GET_OK : Code.GET_ERR;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> bookList != <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;数据查询失败，请重试！&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(code,bookList,msg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//data字段是否为null？</span></span><br></pre></td></tr></table></figure>

<h4 id="返回数据格式统一-异常处理器-RestControllerAdvice"><a href="#返回数据格式统一-异常处理器-RestControllerAdvice" class="headerlink" title="返回数据格式统一 - 异常处理器@RestControllerAdvice"></a>返回数据格式统一 - 异常处理器<mark>@RestControllerAdvice<mark></h4><ul>
<li><p><mark>类级别注解<mark></p>
</li>
<li><p>后端抛出的异常如果不处理，就会抛到前端页面，不美观，并且不会返回任何数据，导致<mark>数据不统一<mark> </p>
</li>
<li><p>要让WebMvcConfig扫到这个Advice类</p>
</li>
</ul>
<h5 id="常见异常诱因"><a href="#常见异常诱因" class="headerlink" title="常见异常诱因"></a>常见异常诱因</h5><ul>
<li><strong>框架内部抛出的异常</strong>:因使用不合规导致</li>
<li><strong>数据层抛出的异常</strong>:因外部服务器故障导致(例如:服务器访问超时)</li>
<li><strong>业务层抛出的异常</strong>:因业务逻辑书写错误导致(例如:遍历业务书写操作，导致索引异常等)</li>
<li><strong>表现层抛出的异常</strong>:因数据收集、校验等规则导致(例如:不匹配的数据类型间导致异常)</li>
<li><strong>工具类抛出的异常</strong>:因工具类书写不严谨不够健壮导致(例如:必要释放的连接长期未释放等)</li>
</ul>
<p><u>处理方法</u>：全部抛到表现层Controller —— AOP 编程，<strong>用最少量的代码实现最强大的功能</strong>，快速统一地处理异常 </p>
<h5 id="方法级别注解-处理具体类别的异常-ExceptionHandler"><a href="#方法级别注解-处理具体类别的异常-ExceptionHandler" class="headerlink" title="方法级别注解 处理具体类别的异常@ExceptionHandler"></a>方法级别注解 处理具体类别的异常<mark>@ExceptionHandler<mark></h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022153703868.png" alt="image-20241022153703868"></p>
<p>处理异常返回的结果也要封装成Result</p>
<h3 id="项目异常处理方案-捕获异常并返回Result"><a href="#项目异常处理方案-捕获异常并返回Result" class="headerlink" title="项目异常处理方案 (捕获异常并返回Result)"></a>项目异常处理方案 (捕获异常并返回Result)</h3><h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><ul>
<li><strong>业务异常 BusinessException</strong> 可预期<ul>
<li>发送对应消息，提醒用户规范操作</li>
</ul>
</li>
<li><strong>系统异常 SystemException</strong> <ul>
<li>发送固定消息，安抚用户</li>
<li>发送特定消息给运维，提醒维护</li>
<li>记录日志</li>
</ul>
</li>
<li><strong>其他异常 Exception</strong><ul>
<li>发送固定消息，安抚用户</li>
<li>发送特定消息给开发，提醒维护（纳入预期范围）</li>
<li>记录日志</li>
</ul>
</li>
</ul>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022154704744.png" alt="image-20241022154704744"></p>
<h5 id="继承RuntimeException"><a href="#继承RuntimeException" class="headerlink" title="继承RuntimeException"></a>继承RuntimeException</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022155606802.png" alt="image-20241022155606802"></p>
<p>加一个code属性（getter setter），重写RuntimeException的方法。异常构造的时候需要用到这些构造器，包装返回数据要用到code和message</p>
<p>建议放在源根的exception包下面</p>
<h5 id="异常代码扩充"><a href="#异常代码扩充" class="headerlink" title="异常代码扩充"></a>异常代码扩充</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022160311854.png" alt="image-20241022160311854"></p>
<h5 id="触发异常"><a href="#触发异常" class="headerlink" title="触发异常"></a>触发异常</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022160332391.png" alt="image-20241022160332391"></p>
<h5 id="拦截并处理异常-返回Result"><a href="#拦截并处理异常-返回Result" class="headerlink" title="拦截并处理异常 返回Result"></a>拦截并处理异常 返回Result</h5><p>在RestControllerAdvice下方的类中处理对应类型的异常，将异常继续封装成Result返回</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022160546843.png" alt="image-20241022160546843"></p>
<h3 id="放行静态资源配置"><a href="#放行静态资源配置" class="headerlink" title="放行静态资源配置"></a>放行静态资源配置</h3><h4 id="SpringMvcSupport（Config类）"><a href="#SpringMvcSupport（Config类）" class="headerlink" title="SpringMvcSupport（Config类）"></a>SpringMvcSupport（Config类）</h4><p>加Configuration注解，继承WebMvcConfigurationSupport类，重写resourceHandler方法</p>
<h4 id="Config包详解"><a href="#Config包详解" class="headerlink" title="Config包详解"></a><mark>Config包详解<mark></h4><h5 id="ServletContainersInitializerConfig-Servlet容器配置类"><a href="#ServletContainersInitializerConfig-Servlet容器配置类" class="headerlink" title="ServletContainersInitializerConfig (Servlet容器配置类)"></a>ServletContainersInitializerConfig (Servlet容器配置类)</h5><p>用来构建ServletContext，继承自 AbstractDispatcherServletInitializer，Spring MVC是建立在 DispatcherServlet 基础之上的，每一个请求最先访问的都是它，负责转发每一个Request请求，所以是必不可少的。</p>
<p>先以 <mark>Abstract<u>DispatcherServlet</u>Initializer<mark> 为例介绍这个加载Config类的职责 具体介绍在<a href="#webappinit">下方</a></p>
<h6 id="a-createRootApplicationContext"><a href="#a-createRootApplicationContext" class="headerlink" title="a. createRootApplicationContext"></a>a. createRootApplicationContext</h6><p>需要加载Spring IoC容器的配置类(SpringConfig)，返回配置好的 <a href="#wac">Root WAC</a> </p>
<h6 id="b-createServletApplicationContext"><a href="#b-createServletApplicationContext" class="headerlink" title="b.createServletApplicationContext"></a>b.createServletApplicationContext</h6><p>需要加载WebMvc容器的配置类(SpringMvcConfig) 返回配置好的 <a href="#swac">Servlet WAC</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022205635235.png" alt="image-20241022205635235"></p>
<h6 id="c-getServletMappings"><a href="#c-getServletMappings" class="headerlink" title="c.getServletMappings"></a>c.getServletMappings</h6><p>配置由此DispatcherServlet接管的URL映射路径</p>
<h5 id="SpringConfig-Configuration"><a href="#SpringConfig-Configuration" class="headerlink" title="SpringConfig(@Configuration)"></a>SpringConfig(@Configuration)</h5><p><u>对应applicationContext.xml</u>，配置 <a href="#wac">Root WAC</a>  </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zzjlxy-225223/p/12611093.html">applicationContext.xml及spring-servlet.xml详解 - 长木木弓 - 博客园 (cnblogs.com)</a>  </p>
<p>注解开发用来替代传统的XML配置文件，因此可以透过xml与注解的映射关系来了解，<code>@Configuration</code>用来替代<code>&lt;beans&gt;</code> <code>&lt;/beans&gt;</code> 在应用启动时，Spring 会自动扫描并加载所有带有 <code>@Configuration</code> 注解的类，根据<code>@ComponentScan</code>扫描要加入的<code>@Component</code>(代替<code>&lt;bean&gt;</code> <code>&lt;/bean&gt;</code>)，最终创建出对应的容器(Context) </p>
<h6 id="Import-MyBatisConfig-class-JdbcConfig-class"><a href="#Import-MyBatisConfig-class-JdbcConfig-class" class="headerlink" title="@Import({MyBatisConfig.class,JdbcConfig.class})"></a>@Import({MyBatisConfig.class,JdbcConfig.class})</h6><p><code>MyBatisConfig</code> 和 <code>JdbcConfig</code>中方法级别注解<code>@Bean</code>用来替代 <code>&lt;bean&gt;</code> <code>&lt;/bean&gt;</code> 标签（表示方法返回的对象当成Bean/Component交给Spring容器管理）虽然没有加<code>Configuration</code>注解，但是会由<code>SpringConfig</code> <code>@Import</code>，导入的还是SpringConfig配置的容器，属于 <a href="#wac">Root WAC</a> </p>
<h5 id="SpringMvcConfig-Configuration-EnableWebMvc"><a href="#SpringMvcConfig-Configuration-EnableWebMvc" class="headerlink" title="SpringMvcConfig(@Configuration @EnableWebMvc)"></a>SpringMvcConfig(@Configuration @EnableWebMvc)</h5><p><u>对应spring-servlet.xml</u>，配置 <a href="#swac">Servlet WAC</a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/EnableWebMvc.html">@EnableWebMvc (Spring Framework 6.1.14 API)</a> </p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurationSupport.html">WebMvcConfigurationSupport (Spring Framework 6.1.14 API)</a>  (WMCS)</p>
<ul>
<li><p><code>@EnableWebMvc</code> 会通过导入 <code>WMCS</code> 完成 Spring MVC 默认配置的添加，<strong>只有一个类能拥有此注解</strong> </p>
</li>
<li><p>不写 <code>@EnableWebMvc</code> 直接继承 WMCS 也可以实现相同效果</p>
</li>
<li><p>自定义具体某项WebMvc配置：<code>extends WebMvcConfigurer</code> 允许多个WebMvcConfigurer存在，但是具有一定侵入性</p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023210351697.png" alt="image-20241023210351697"></p>
<ul>
<li>主要Config：<code>@EnableWebMvc</code> + 继承 <code>WebMvcConfigurer</code> 重写方法 + <code>@ComponentScan</code> 其他Config类</li>
<li>次要Config：继承 <code>WebMvcConfigurer</code>重写方法+@Configuration确保被主要Config扫描到</li>
<li>没有暴露高级设置，如果需要高级设置 需要第二种方式直接继承 WMCS 来做更高级别的配置，此时要移除@Enable注解</li>
</ul>
<h6 id="SpringMvcSupport-Configuration"><a href="#SpringMvcSupport-Configuration" class="headerlink" title="SpringMvcSupport(@Configuration)"></a>SpringMvcSupport(@Configuration)</h6><p><u>对应springMvcContext.xml</u>，配置 <a href="#swac">Servlet WAC</a> </p>
<ul>
<li>继承WMCS，完成对SpringMVC的默认配置，重写resourceHandler方法，实现在默认配置基础上的自定义。</li>
<li>案例中的SMS是配置类，用于配置容器，被SMC扫config包扫到了，此时SMS这里的自定义配置会覆盖SMC的Enable注解</li>
</ul>
<h3 id="前端逻辑"><a href="#前端逻辑" class="headerlink" title="前端逻辑"></a>前端逻辑</h3><p>查询： get请求</p>
<p>保存/添加：post请求</p>
<p>新增要弹出表单，添加成功要关闭表单并<strong>清空表单数据</strong>，不论成功与否finallyGetAll回显 ，按照识别码判别成功与否</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023190220059.png" alt="image-20241023190220059"></p>
<p>修改：put请求</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023191646261.png" alt="image-20241023191646261"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023191751771.png" alt="image-20241023191751771"></p>
<p>删除：delete请求</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023191526268.png" alt="image-20241023191526268"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023191952545.png" alt="image-20241023191952545"></p>
<h3 id="容器之间的嵌套关系-概念解释-源码解析"><a href="#容器之间的嵌套关系-概念解释-源码解析" class="headerlink" title="容器之间的嵌套关系 + 概念解释 (源码解析)"></a>容器之间的嵌套关系 + 概念解释 (源码解析)</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022175254007-1729595662475-3.png" alt="image-20241022175254007"></p>
<h4 id="WebApplicationContext-WAC"><a href="#WebApplicationContext-WAC" class="headerlink" title="WebApplicationContext(WAC)"></a><span id="wac">WebApplicationContext(WAC)</span></h4><ul>
<li>ApplicationContext(AC) 表示整个 Spring 应用的上下文。WAC是普通AC的扩展，它具有Web应用程序所需的一些额外功能，比如可以<u>get</u>ServletContext或者<u>set</u>ServletContext</li>
<li><code>Root WAC</code>在应用启动时首先被加载，并且作为父上下文，供表示层使用，主要负责管理服务层（Service）、数据访问层（DAO）、中间件配置等非 Web 层（表示层）的 Bean</li>
</ul>
<h4 id="Servlet-WebApplicationContext-Servlet-WAC"><a href="#Servlet-WebApplicationContext-Servlet-WAC" class="headerlink" title="Servlet WebApplicationContext(Servlet WAC)"></a><span id="swac">Servlet WebApplicationContext(Servlet WAC)</span></h4><ul>
<li><code>Servlet WAC</code> 是 <code>Root WAC</code> 的<strong>子上下文</strong>，专门用于处理表示层的 Bean 和配置。比如控制器（<code>Controller</code>）、视图解析器、拦截器(<code>Interceptor</code>)等</li>
<li>每个 <code>DispatcherServlet</code> 实例会有一个独立的 <code>Servlet WAC</code> </li>
</ul>
<h5 id="Parent-amp-Child-ApplicatitonContext"><a href="#Parent-amp-Child-ApplicatitonContext" class="headerlink" title="Parent &amp; Child ApplicatitonContext"></a>Parent &amp; Child ApplicatitonContext</h5><p>Root WAC 作为 所有 Servlet WAC 的 Parent，DispatherServlet在创建属于自己的ServletContext的getAttribute方法来判断是否存在Root WebApplicationContext。如果存在，则将其设置为自己的parent。这就是父子上下文(父子容器)的概念，getParentBeanFactory。</p>
<p>对于作用范围而言，在DispatcherServlet中可以引用由ContextLoaderListener所创建的RootWAC中的内容，而反过来不行。当Spring在执行ApplicationContext的getBean时，如果在自己context中找不到对应的bean，则会在父ApplicationContext中去找。这也解释了为什么我们可以在DispatcherServlet中获取到RootWAC中的bean。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023154504980.png" alt="image-20241023154504980"></p>
<h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><ul>
<li>Servlet容器（Tomcat）在启动一个web应用时，根据web.xml 会为整个应用创建一个<mark>唯一<mark>的ServletContext(SC)对象，应用内部所有的Servlet共享同一个SC。</li>
<li>ServletContext是Servlet与Servlet容器（Tomcat）之间直接通信的接口。</li>
<li>容器中的Servlet可以通过它来访问容器中的各种资源</li>
<li>ServletContext跟XML一样，由Attributes组成，要访问资源就要通过字符串name访问，可以通过<code>void setAttribute(name, object) </code>来将ServletContext与你的object绑定，<code>Object getAttribute(name)</code>可以得到object</li>
<li><code>Enumeration&lt;String&gt; getInitParameterNames()</code> 获取所有 <code>&lt;context-param/&gt;</code> 参数的名称 字符串枚举</li>
<li><code> String getInitParameter(name)</code> 根据name获取指定的 <code>&lt;context-param/&gt;</code> 参数值</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023013135254.png" alt="image-20241023013135254"></p>
<h5 id="Root-WAC-Servlet-WAC-ServletContext之间的关系"><a href="#Root-WAC-Servlet-WAC-ServletContext之间的关系" class="headerlink" title="Root WAC, Servlet WAC, ServletContext之间的关系"></a>Root WAC, Servlet WAC, ServletContext之间的关系</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241022230909096.png" alt="image-20241022230909096"></p>
<ul>
<li><p>Root WebApplicationContext存储key为<code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>，可以通过此Key访问Root WAC。</p>
</li>
<li><p>WebApplicationContextUtis工具类提供了从ServletContext获取RootWAC的方法：</p>
<ul>
<li><code>WebApplicationContextUtils.getWebApplicationContext(ServletContext sc)</code></li>
</ul>
</li>
<li><p>WAC提供了获取ServletContext的抽象方法 <code>getServletContext()</code> </p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E6%97%A0%E6%A0%87%E9%A2%98-1729654361571-5.png" alt="context"></p>
<h5 id="web-xml-配置-ServletContext"><a href="#web-xml-配置-ServletContext" class="headerlink" title="web.xml 配置 ServletContext"></a>web.xml 配置 ServletContext</h5><p>Tomcat创建web应用时，会构建ServletContext对象，根据web.xml中的配置把如下参数都存到ServletContext对象中，注册Listener，Servlet等</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line">    &lt;!—ServletContext自有的init 参数--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span>  </span><br><span class="line">        &lt;!—创建Root WAC所需要的配置文件路径--&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span>  </span><br><span class="line">  	</span><br><span class="line">    &lt;!—注册ContextLoaderListener--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line">    &lt;!—注册DispatcherServlet ServletConfig--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span> </span><br><span class="line">        &lt;!—init Servlet所需参数--&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">            &lt;!—创建Servlet WAC所需参数--&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/spring-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line">        &lt;!—指定某个servlet的URL映射路径--&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="ContextLoaderListener-创建-Root-WAC"><a href="#ContextLoaderListener-创建-Root-WAC" class="headerlink" title="ContextLoaderListener - 创建 Root WAC"></a>ContextLoader<mark>Listener<mark> - 创建 Root WAC</h4><ul>
<li><p>本质就是一个Listener，因此需要在web.xml中注册</p>
</li>
<li><p>实现了ServletContextListener接口，EventListener-&gt;ServletContextListener</p>
</li>
<li><p>继承了ContextLoader类，见名知意，是用来加载WAC的，有一个WAC参数context，所有方法都是围绕加工这个context字段进行的</p>
</li>
</ul>
<h5 id="WebApplicationContext-initWAC-ServletContext-sc"><a href="#WebApplicationContext-initWAC-ServletContext-sc" class="headerlink" title="WebApplicationContext initWAC(ServletContext sc)"></a>WebApplicationContext initWAC(ServletContext sc)</h5><p>ContextLoaer 接收一个ServletContext参数sc，调用initWAC方法返回加载好的WAC对象this.context</p>
<p>打印在服务器日志上 <code>servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);</code></p>
<p>中间调用<code>createWAC(ServletContext sc)</code>返回一个ConfigurableWAC对象，将其<strong>parentContext设置为sc</strong>，</p>
<p>再把这个CWAC和sc传给<code>configureAndRefreshWAC(CWAC cwac,ServletContext sc)</code>方法进行配置（ServletContext是根据web.xml构建的，根据key: contextConfigLocation找到RootWAC的配置文件<code>applicationContext.xml</code>）</p>
<p>之后在sc中创建一个Attribute，使得能通过ServletContext对这个Root WAC进行访问（键值对形式）</p>
<p><code>setAttribute(</code> <code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>, <code>this.context)</code></p>
<p>最终返回 <code>this.context</code> 作为 Root WAC</p>
<h5 id="WebApplicationContext-contextInitialized-ServletContextEvent-sce"><a href="#WebApplicationContext-contextInitialized-ServletContextEvent-sce" class="headerlink" title="WebApplicationContext contextInitialized(ServletContextEvent sce)"></a>WebApplicationContext contextInitialized(ServletContextEvent sce)</h5><p>ContextLoaderListener 能监听Web应用启动或关闭的事件（会修改ServletContext中的参数），触发contextInitializaed/contextDestroyed，创建或销毁Root WAC。</p>
<h4 id="DispatcherServlet-创建-Servlet-WAC"><a href="#DispatcherServlet-创建-Servlet-WAC" class="headerlink" title="DispatcherServlet - 创建 Servlet WAC"></a>Dispatcher<mark>Servlet<mark> - 创建 Servlet WAC</h4><ul>
<li><p>本质就是一个Servlet，所以需要在web.xml中注册，继承自HttpServlet-&gt;HttpServletBean-&gt;FrameworkServlet</p>
</li>
<li><p>Spring MVC 的核心前端控制器，用于处理所有进入的 HTTP 请求。将请求分发给适当的处理器（控制器 Controller），并在处理后将响应返回给客户端。</p>
</li>
<li><p>每一个 <code>DispatcherServlet</code> 都拥有自己的 <a href="#swac">Servlet WebApplicationContext</a>，管理与 Web 层(表现层)相关的 Bean，如控制器、视图解析器、拦截器等。</p>
</li>
<li><p>HttpServletBean有一个final的init()<strong>[Servlet的入口方法]</strong>  其中会调用抽象方法initServletBean()</p>
</li>
<li><p>FrameServlet实现了initServletBean(): <strong>[生成Servlet WAC，设置parent和ServletContext]</strong> 最后会调用initStrategies</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">var10000</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line"><span class="type">String</span> <span class="variable">var10001</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getSimpleName();</span><br><span class="line">var10000.log(<span class="string">&quot;Initializing Spring &quot;</span> + var10001 + <span class="string">&quot; &#x27;&quot;</span> + <span class="built_in">this</span>.getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"><span class="comment">//记录日志</span></span><br></pre></td></tr></table></figure>

<ul>
<li>同样的，途中也会调用自己的initWAC方法：<ul>
<li>调用WACUtils工具类，获得自己所在的ServletContext的<strong>Root WAC</strong> </li>
<li>将自己的WAC转换成CWAC，如果存在RootWAC，则将其设置为自己的parent</li>
<li>然后configureAndRefreshWAC(cwac)：设置ServletContext为sc，从其中ServletConfig中获取 <code>&lt;init-param&gt;</code> 参数的值</li>
</ul>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023013013442.png" alt="image-20241023013013442"></p>
<ul>
<li>最后根据自己的ServletConfig获取到ServletContext，根据自己的名称设置自己的Servlet WAC在ServletContext中的Key</li>
</ul>
</li>
<li><p>DispatcherServlet实现了initStrategies [生成各个功能组件，异常处理器，视图处理，请求映射]</p>
</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/mvc-context-hierarchy.png" alt="mvc-context-hierarchy"></p>
<p>这两个context都是在ServletContext中，属于dispatcherServlet的上下文是servletWAC，找不到的话就去rootWAC中找</p>
<h4 id="替代web-xml，以Java形式配置ServletContext——WebApplicationInitializer"><a href="#替代web-xml，以Java形式配置ServletContext——WebApplicationInitializer" class="headerlink" title="替代web.xml，以Java形式配置ServletContext——WebApplicationInitializer"></a><span id="webappinit">替代web.xml，以Java形式配置ServletContext——WebApplicationInitializer</span></h4><p>![屏幕截图 2024-10-23 133904](<a target="_blank" rel="noopener" href="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/屏幕截图</a> 2024-10-23 133904.png)</p>
<h5 id="ServletContainerInitializer"><a href="#ServletContainerInitializer" class="headerlink" title="ServletContainerInitializer"></a>ServletContainerInitializer</h5><p>之前，web容器（Tomcat）会根据WEB-INF下的web.xml初始化ServletContext</p>
<p>Java EE Servlet 规范定义了这个接口，web容器（Tomcat）启动时根据这个初始化器做一些组件内的初始化工作。 </p>
<p><strong>SpringServletContainerInitializer</strong> 是Spring 对其的实现，其onStartup方法会调用 <strong><a href="#webappinit">WebApplicationInitializer</a></strong> 的onStartup(<strong>ServletContext sc</strong>)初始化Web应用</p>
<h4 id="SpringMVC-Web应用启动流程"><a href="#SpringMVC-Web应用启动流程" class="headerlink" title="SpringMVC Web应用启动流程"></a>SpringMVC Web应用启动流程</h4><ul>
<li>Tomcat 读取web.xml中 <code>&lt;context-param&gt;</code> <code>&lt;listener&gt;</code>  然后创建一个全局共享的ServletContext</li>
<li>Tomcat 将<code>&lt;context-param&gt;</code> <code>&lt;listener&gt;</code>转化为键值对，存到ServletContext </li>
<li>Tomcat 加载Listener实例，实施监听，Listener必须实现<u>ServletContext</u>Listener接口（比如ContextLoaderListener）</li>
<li><strong>Web项目继续启动中</strong>，触发Listener中的contextInitialized(ServletContexEvent event)，根据ServletContext中 <code>&lt;context-param&gt;</code> 部分创建父容器，configClass是类的形式，configLocation是xml配置文件的形式</li>
<li>创建完父容器，如果有<code>&lt;filter&gt;</code>会创建filter，然后读取 <code>&lt;servlet&gt;</code> 用于注册DispatcherServlet（这块流程建议从init方法一步步往下看，流程还是很清晰的），因为DispatcherServlet实质是一个Servlet，所以会先执行它的init方法。这个init()方法在<strong>HttpServletBean</strong>这个类中实现，其主要工作是做一些初始化工作，将我们在web.xml中配置的参数设置到ServletContext的ServletConfig中，然后再触发<strong>FrameworkServlet</strong>的initServletBean()方法；<ul>
<li><strong>FrameworkServlet</strong>主要作用是初始化Spring子容器，设置其父容器，并将其放入ServletContext中；</li>
<li><strong>FrameworkServlet</strong>在调用initServletBean()的过程中同时会触发<strong>DispatcherServlet</strong>的onRefresh()方法，这个方法会初始化Spring MVC的各个功能组件。比如异常处理器、视图处理器、请求映射处理等</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/54chensongxia/p/12522804.html">Spring MVC启动流程</a> </p>
<h5 id="100-code-based"><a href="#100-code-based" class="headerlink" title="100% code-based"></a>100% code-based</h5><p>用Java类的形式配置ServletContext，有一些细微差异，Spring这边实现了ServletContainerInitializer接口，注册组件的工作就交给了WebApplicationInitializer：</p>
<p>先根据指定的rootWacConfig配置类（SpringConfig）创建出父容器，父容器作为参数进行Listener的有参构造，最后以<mark>add<mark>Listener的方式注册到ServletContext中。</p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023193138396.png" alt="image-20241023193138396"></p>
<h4 id="Interceptor-vs-Filter"><a href="#Interceptor-vs-Filter" class="headerlink" title="Interceptor vs Filter"></a>Interceptor vs Filter</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023193414214.png" alt="image-20241023193414214"></p>
<p>filter在一定是在访问servlet之前，interceptor只能在servlet中， <mark>before Controller<mark></p>
<h3 id="功能类"><a href="#功能类" class="headerlink" title="功能类"></a>功能类</h3><p>控制表现层：controller下新建interceptor包，新建一个Interceptor类 <strong>extends HandlerInterceptor</strong> </p>
<p>注意preHandle返回值和@Component</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023210048371.png" alt="image-20241023210048371"></p>
<h4 id="SpringMvcSupport"><a href="#SpringMvcSupport" class="headerlink" title="SpringMvcSupport"></a>SpringMvcSupport</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023205518460.png" alt="image-20241023205518460"></p>
<p>addInterceptors 自动注入自定义拦截器</p>
<p>addPathPatterns 加的不是前缀，<mark>是严格的URL匹配<mark>，配/books就拦截对/books发的请求，/books/100就拦截不了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023205715345.png" alt="image-20241023205715345"></p>
<p><mark>preHandle<mark>，yourService，postHandle，afterCompletion 顺序</p>
<h4 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023210636045.png" alt="image-20241023210636045"></p>
<h4 id="简化开发"><a href="#简化开发" class="headerlink" title="简化开发"></a>简化开发</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023210528299.png" alt="image-20241023210528299"></p>
<p>已经和Spring接口绑定，侵入性强。</p>
<h3 id="拦截方法参数配置"><a href="#拦截方法参数配置" class="headerlink" title="拦截方法参数配置"></a>拦截方法参数配置</h3><h4 id="boolean-preHandle-req-resp-handler"><a href="#boolean-preHandle-req-resp-handler" class="headerlink" title="boolean preHandle(req,resp,handler)"></a>boolean preHandle(req,resp,<mark>handler<mark>)</h4><p>req和resp是servlet的响应和请求，handler实际上是HandlerMethod，通过getMethod能拿到执行的业务方法的对象（反射）</p>
<h4 id="void-postHandle-req-resp-handler-modelAndView"><a href="#void-postHandle-req-resp-handler-modelAndView" class="headerlink" title="void postHandle(req,resp,handler,modelAndView)"></a>void postHandle(req,resp,<mark>handler<mark>,modelAndView)</h4><p>页面跳转相关。</p>
<h4 id="void-afterCompletion-req-resp-handler-exception"><a href="#void-afterCompletion-req-resp-handler-exception" class="headerlink" title="void afterCompletion(req,resp,handler,exception)"></a>void afterCompletion(req,resp,<mark>handler<mark>,exception)</h4><p>能拿到原始业务方法执行过程中的异常</p>
<h3 id="拦截链顺序"><a href="#拦截链顺序" class="headerlink" title="拦截链顺序"></a>拦截链顺序</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023211911820.png" alt="image-20241023211911820"></p>
<p>拦截顺序，和注册顺序有关系</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023212439810.png" alt="image-20241023212439810"></p>
<p>如果某个pre返回false，post全部跳过，倒序执行，从最近一个pre返回true的拦截器开始执行afterCompletion</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241023212527269.png" alt="image-20241023212527269"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/penriver/article/details/118571991">万字详解 GoF 23 种设计模式（多图、思维导图、模式对比），让你一文全面理解-CSDN博客</a></p>
<h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><h2 id="入门案例——Web项目"><a href="#入门案例——Web项目" class="headerlink" title="入门案例——Web项目"></a>入门案例——Web项目</h2><h3 id="创建boot模块"><a href="#创建boot模块" class="headerlink" title="创建boot模块"></a>创建boot模块</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dream_ready/article/details/134639886">idea创建不了spring2.X版本，无法使用JDK8，最低支持JDK17 ， 如何用idea创建spring2.X版本，使用JDK8解决方案_spring3不支持jdk8-CSDN博客</a></p>
<p>SpringBoot2停止维护，SpringBoot3最低Java17</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025190302057.png" alt="image-20241025190302057"></p>
<h3 id="写控制器类"><a href="#写控制器类" class="headerlink" title="写控制器类"></a>写控制器类</h3><p>把controller类写好</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025194037167.png" alt="image-20241025194037167"></p>
<h3 id="启动app"><a href="#启动app" class="headerlink" title="启动app"></a>启动app</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025194052846.png" alt="image-20241025194052846"></p>
<h2 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h2><h3 id="打包—jar"><a href="#打包—jar" class="headerlink" title="打包—jar"></a>打包—jar</h3><p><code>package</code> 之前 <code>clean</code> 全部设置为UTF-8参数</p>
<h3 id="命令行启动-java-jar"><a href="#命令行启动-java-jar" class="headerlink" title="命令行启动 java -jar"></a>命令行启动 java -jar</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025194844475.png" alt="image-20241025194844475"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025194925821.png" alt="image-20241025194925821"></p>
<p>jar执行要有入口类，boot打包需要插件才能生成可执行的入口类</p>
<h2 id="简述boot"><a href="#简述boot" class="headerlink" title="简述boot"></a>简述boot</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025195226537.png" alt="image-20241025195226537"></p>
<h3 id="starter-起步依赖"><a href="#starter-起步依赖" class="headerlink" title="starter 起步依赖"></a>starter 起步依赖</h3><h3 id="starter-parent-依赖管理"><a href="#starter-parent-依赖管理" class="headerlink" title="starter-parent 依赖管理"></a>starter-parent 依赖管理</h3><p>starter-parent：定义了无数jar包的版本管理和依赖管理，减少依赖冲突。只写GA 不写V</p>
<h3 id="dependencies-辅助功能"><a href="#dependencies-辅助功能" class="headerlink" title="dependencies-辅助功能"></a>dependencies-辅助功能</h3><p>每一个dependency（以web包为例）把真正需要用到的jar包声明，去找parent要即可</p>
<p>spring-boot-starter-web: </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025201404198.png" alt="image-20241025201404198"></p>
<p>spring-boot-dependencies: </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025201443556.png" alt="image-20241025201443556"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025201805886.png" alt="image-20241025201805886"></p>
<h3 id="替换starter的某个依赖"><a href="#替换starter的某个依赖" class="headerlink" title="替换starter的某个依赖"></a>替换starter的某个依赖</h3><p>依赖排除exclusion，换技术</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025202142653.png" alt="image-20241025202142653"></p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="resources目录下配置文件加载优先级"><a href="#resources目录下配置文件加载优先级" class="headerlink" title="resources目录下配置文件加载优先级"></a>resources目录下配置文件加载优先级</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025204356892.png" alt="image-20241025204356892"></p>
<p>properties&gt;<mark>yml<mark>&gt;yaml</p>
<h3 id="自动提示功能消失—引入配置文件到boot模块中"><a href="#自动提示功能消失—引入配置文件到boot模块中" class="headerlink" title="自动提示功能消失—引入配置文件到boot模块中"></a>自动提示功能消失—引入配置文件到boot模块中</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025204437530.png" alt="image-20241025204437530"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025204503008.png" alt="image-20241025204503008"></p>
<p>debug&gt;info&gt;warn</p>
<h3 id="YAML—-YAML-Ain’t-Markup-Language"><a href="#YAML—-YAML-Ain’t-Markup-Language" class="headerlink" title="YAML—(YAML Ain’t Markup Language)"></a>YAML—(YAML Ain’t Markup Language)</h3><h4 id="YAML-简介"><a href="#YAML-简介" class="headerlink" title="YAML 简介"></a>YAML 简介</h4><p>Jamel  Camel</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025204800590.png" alt="image-20241025204800590"></p>
<h4 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025204945594.png" alt="image-20241025204945594"></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空格数量不限，只要前面格数一样就是同一级，不允许使用tab缩进</span></span><br><span class="line"><span class="attr">enterprise:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">John</span></span><br><span class="line"> <span class="attr">likes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Java</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Python</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">C++</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025205033642.png" alt="image-20241025205033642"></p>
<h3 id="以Java方式读取yaml配置文件"><a href="#以Java方式读取yaml配置文件" class="headerlink" title="以Java方式读取yaml配置文件"></a>以Java方式读取yaml配置文件</h3><h4 id="读取单个数据—定义成员变量-Value-enterprise-subject"><a href="#读取单个数据—定义成员变量-Value-enterprise-subject" class="headerlink" title="读取单个数据—定义成员变量@Value(${enterprise.subject)"></a>读取单个数据—定义成员变量@Value(${enterprise.subject)</h4><p>自动赋值</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025205805383.png" alt="image-20241025205805383"></p>
<h4 id="读取全部数据—Environment对象"><a href="#读取全部数据—Environment对象" class="headerlink" title="读取全部数据—Environment对象"></a>读取全部数据—Environment对象</h4><p>定义一个Environment，自动装配，将配置中的属性全部遍历:</p>
<p><code>environment.getProperty(&quot;name&quot;)</code></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025210024893.png" alt="image-20241025210024893"></p>
<h4 id="自定义对象封装指定数据-Component-ConfigurationProperties-prefix-enterprise"><a href="#自定义对象封装指定数据-Component-ConfigurationProperties-prefix-enterprise" class="headerlink" title="自定义对象封装指定数据@Component@ConfigurationProperties(prefix = enterprise)"></a><strong>自定义对象封装指定数据</strong>@Component@ConfigurationProperties(prefix = enterprise)</h4><p>可以拿到需要的某个属性的信息(prefix)</p>
<p>在控制器中定义成员变量自动装配，常用</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025210946272.png" alt="image-20241025210710013"></p>
<h5 id="自定义对象封装数据警告"><a href="#自定义对象封装数据警告" class="headerlink" title="自定义对象封装数据警告"></a>自定义对象封装数据警告</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025211036999.png" alt="image-20241025211036999"></p>
<h3 id="多环境开发"><a href="#多环境开发" class="headerlink" title="多环境开发"></a>多环境开发</h3><h4 id="生产环境设定"><a href="#生产环境设定" class="headerlink" title="生产环境设定"></a>生产环境设定</h4><p><strong>独立生产环境设定</strong>：</p>
<p><code>spring.profiles</code> <strong>boot2</strong></p>
<p><code>spring.config.activate.on-profile</code> <strong>boot3</strong></p>
<p><code>---</code> 三条横线分割配置</p>
<p><code>spring.profiles.active</code> 设置激活的环境</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025214421983.png" alt="image-20241025214421983"></p>
<h4 id="带参数启动boot"><a href="#带参数启动boot" class="headerlink" title="带参数启动boot"></a>带参数启动boot</h4><h5 id="命令行参数临时修改配置内容"><a href="#命令行参数临时修改配置内容" class="headerlink" title="命令行参数临时修改配置内容"></a>命令行参数临时修改配置内容</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改启动环境为test</span></span><br><span class="line">java -jar boot_1.0_SNAPSHOT.jar --spring.profiles.active=<span class="built_in">test</span></span><br><span class="line"><span class="comment"># 修改服务器端口号为88</span></span><br><span class="line">java -jar boot_1.0_SNAPSHOT.jar --server.port=88</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="参数加载优先级"><a href="#参数加载优先级" class="headerlink" title="参数加载优先级"></a>参数加载优先级</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241025215406246.png" alt="image-20241025215406246"></p>
<h4 id="maven-amp-boot开发环境兼容—加载配置文件"><a href="#maven-amp-boot开发环境兼容—加载配置文件" class="headerlink" title="maven&amp;boot开发环境兼容—加载配置文件"></a>maven&amp;boot开发环境兼容—加载配置文件</h4><p>maven和boot都设置了多环境，但是打包工作是maven负责，所以maven应该占主导</p>
<p>手动配置resources插件，覆盖parent设定</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hcgk/p/17600908.html">maven-resources-plugin详解 - 红尘过客2022 - 博客园 (cnblogs.com)</a></p>
<h5 id="lt-resources-gt-lt-filtering-gt"><a href="#lt-resources-gt-lt-filtering-gt" class="headerlink" title="&lt;resources&gt; (&lt;filtering&gt;)"></a><code>&lt;resources&gt;</code> (<code>&lt;filtering&gt;</code>)</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026013908079.png" alt="image-20241026013908079"></p>
<p><code>&lt;resources&gt;</code>标签其实就是<code>maven-resources-plugin</code>的<code>&lt;resources&gt;</code>配置，主要用来配置资源目录的。普通项目没有<code>parent</code>，默认继承<code>父pom.xml</code>: </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026024547372.png" alt="image-20241026024547372"></p>
<p>可以看到<code>resources</code>默认就是项目下的<code>src/main/resources</code>，但是没开过滤<code>filtering</code>，所以之前maven课程中，<u>在配置文件中引入占位符还得重写一遍resources标签。</u></p>
<p>而boot模块默认继承的starter-parent默认的<code>resources</code>标签是开了过滤的，而且资源明确<code>包括application.yml</code>这种配置文件，所以即使子项目里不用手动复写<code>resources</code>也能匹配到占位符：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026025346547.png" alt="image-20241026025346547"></p>
<h5 id="maven-resources-plugin-lt-useDefaultDelimeters-gt"><a href="#maven-resources-plugin-lt-useDefaultDelimeters-gt" class="headerlink" title="maven-resources-plugin (&lt;useDefaultDelimeters&gt; )"></a><code>maven-resources-plugin</code> (<code>&lt;useDefaultDelimeters&gt;</code> )</h5><p><code>&lt;useDefaultDelimeters&gt;</code> 支持使用<code>$&#123;&#125;或@</code>过滤资源 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026021624316.png" alt="image-20241026021624316"></p>
<p>boot的starter-parent默认对<code>resources-plugin</code>的配置也做了自定义更改（主要就是<code>&lt;useDefaultDelimeters&gt;</code> = false）而上文提到的父pom没有，<code>&lt;useDefaultDelimeters&gt;</code>默认就是true</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026025510839.png" alt="image-20241026025510839"></p>
<h4 id="定义多环境-lt-profiles-gt"><a href="#定义多环境-lt-profiles-gt" class="headerlink" title="定义多环境 &lt;profiles&gt;"></a>定义多环境 <code>&lt;profiles&gt;</code></h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026005328800.png" alt="image-20241026005328800"></p>
<h4 id="配置属性替换占位符"><a href="#配置属性替换占位符" class="headerlink" title="配置属性替换占位符"></a>配置属性替换占位符</h4><h5 id=""><a href="#" class="headerlink" title="@"></a><code>@</code></h5><p>boot项目的parent为了防止spring占位符被扩展，所以只允许<code>@</code>为占位符，不解析<code>$&#123;&#125;</code>。如果已经继承starter-parent，直接在配置文件中@xxx@即可。 <a target="_blank" rel="noopener" href="https://docs.springjava.cn/spring-boot/how-to/properties-and-configuration.html#howto.properties-and-configuration.expand-properties.maven">parent不是starter-parent的解决办法</a></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026021230152.png" alt="image-20241026021230152"></p>
<h5 id="-1"><a href="#-1" class="headerlink" title="${}"></a><code>$&#123;&#125;</code></h5><p>非要用${}，可以使用如下方法覆盖配置：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026081744618.png" alt="image-20241026081744618"></p>
<p>或者启用插件的<code>&lt;useDefaultDelimeters&gt;</code> = true</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026005308461-1729903011039-5.png" alt="image-20241026005308461"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026005348094-1729902750823-1-1729902803907-3.png" alt="image-20241026005348094"></p>
<h4 id="多配置文件加载优先级"><a href="#多配置文件加载优先级" class="headerlink" title="多配置文件加载优先级"></a>多配置文件加载优先级</h4><h5 id="包外配置"><a href="#包外配置" class="headerlink" title="包外配置"></a>包外配置</h5><p>假设JAR包位于file目录下，<code>file/config/application.yml</code> &gt; <code>file/application.yml</code></p>
<h5 id="包内配置"><a href="#包内配置" class="headerlink" title="包内配置"></a>包内配置</h5><p><code>resources/config/application.yml</code> &gt; <code>resources/application.yml</code></p>
<h4 id="Java项目目录结构"><a href="#Java项目目录结构" class="headerlink" title="Java项目目录结构"></a>Java项目目录结构</h4><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026140333629.png" alt="image-20241026140333629" style="zoom: 67%;" />

<ul>
<li><p>src/main 就是编译以后的classpath(classes)，java是java源代码，resources资源文件，编译完打包都在同一个classes目录下。</p>
</li>
<li><p>src/test 是test-classes，属于测试文件，默认不会参与打包。</p>
</li>
<li><p>依赖放在<strong>包内</strong>和classes并列的lib目录</p>
</li>
<li><p>对于maven webapp骨架，main还有webapp目录，其中WEB-INF文件夹存放web.xml，打包之后web.xml classes lib并列放在WEB-INF中</p>
<ul>
<li>webapp也可存放静态资源，打包之后在JAR包中的第一级</li>
</ul>
</li>
</ul>
<h4 id="JAR包内部结构"><a href="#JAR包内部结构" class="headerlink" title="JAR包内部结构"></a>JAR包内部结构</h4><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/JAR_(%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F)">JAR (文件格式) - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p>META-INF 整个项目的元数据，MANIFEST.MF 包含执行时的入口类等信息</p>
<p>BOOT-INF boot项目的jar包中 classes+lib</p>
<p>WEB-INF web项目war包中 classes+lib+web.xml</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026143753352.png" alt="image-20241026143753352"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026143816570.png" alt="image-20241026143816570"></p>
<h5 id="APK内部结构"><a href="#APK内部结构" class="headerlink" title="APK内部结构"></a>APK内部结构</h5><p>APK作为JAR包的变种，也具有相似的结构：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026144246642.png" alt="image-20241026144246642"></p>
<h2 id="与其他框架整合"><a href="#与其他框架整合" class="headerlink" title="与其他框架整合"></a>与其他框架整合</h2><h3 id="Spring-Boot-X-JUnit"><a href="#Spring-Boot-X-JUnit" class="headerlink" title="Spring Boot X JUnit"></a>Spring Boot X JUnit</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026151902777.png" alt="image-20241026151902777"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026152538674.png" alt="image-20241026152538674"></p>
<h4 id="测试类注解-SpringBootTest"><a href="#测试类注解-SpringBootTest" class="headerlink" title="测试类注解@SpringBootTest"></a>测试类注解@SpringBootTest</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026152650043.png" alt="image-20241026152650043"></p>
<p>SpringBoot启动类：@SpringBootApplication有加载bean的功能，会扫描当前包同层以及子包中所有的bean，加载bean（包含配置类）</p>
<p>SpringBootTest会自动扫描SpringBootApplication，测试类不在启动类所在包/子包中，需要指定启动类的class文件</p>
<h3 id="基于SpringBoot实现SSM整合"><a href="#基于SpringBoot实现SSM整合" class="headerlink" title="基于SpringBoot实现SSM整合"></a>基于SpringBoot实现SSM整合</h3><h4 id="整合MyBatis案例"><a href="#整合MyBatis案例" class="headerlink" title="整合MyBatis案例"></a>整合MyBatis案例</h4><h5 id="启动依赖-MyBatis-MySQL"><a href="#启动依赖-MyBatis-MySQL" class="headerlink" title="启动依赖-MyBatis,MySQL"></a>启动依赖-MyBatis,MySQL</h5><h5 id="pojo-dao-Mapper-MapperScan"><a href="#pojo-dao-Mapper-MapperScan" class="headerlink" title="pojo dao @Mapper @MapperScan"></a>pojo dao @Mapper @MapperScan</h5><p>mybatis自动代理注解开发返回的对象就是实体类，所以实体类不用配置，</p>
<p>mybatis注解开发中@Mapper注解取代了bookMapper.xml，对mybatis声明这是一个mapper。</p>
<p>spring-mybatis整合中，mybatis生成mapper的代理对象会以FactoryBean的形式交给Spring容器管理，要让mybatis知道mapper在哪里，就要加@Mapper注解</p>
<p>spring-mybatis整合中，不加@Mapper注解，要么配置mapperScannerConfigurer，要么加@MapperScan扫mapper包。</p>
<h5 id="application-yml-配置数据源"><a href="#application-yml-配置数据源" class="headerlink" title="application.yml 配置数据源"></a>application.yml 配置数据源</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241026163010546.png" alt="image-20241026163010546"></p>
<h4 id="SSM项目迁移到Spring-Boot"><a href="#SSM项目迁移到Spring-Boot" class="headerlink" title="SSM项目迁移到Spring Boot"></a>SSM项目迁移到Spring Boot</h4><p>TODO 注释前面加TODO 可以有事项清单</p>
<h5 id="配置类全部删除"><a href="#配置类全部删除" class="headerlink" title="配置类全部删除"></a>配置类全部删除</h5><h5 id="Dao加-Mapper"><a href="#Dao加-Mapper" class="headerlink" title="Dao加@Mapper"></a>Dao加@Mapper</h5><h5 id="Controller-Service不变"><a href="#Controller-Service不变" class="headerlink" title="Controller Service不变"></a>Controller Service不变</h5><h5 id="application-yml-配置端口和数据源"><a href="#application-yml-配置端口和数据源" class="headerlink" title="application.yml 配置端口和数据源"></a>application.yml 配置端口和数据源</h5><h5 id="静态资源放到resources-static"><a href="#静态资源放到resources-static" class="headerlink" title="静态资源放到resources/static"></a>静态资源放到resources/static</h5><h6 id="静态资源的重定向-JS脚本"><a href="#静态资源的重定向-JS脚本" class="headerlink" title="静态资源的重定向(JS脚本)"></a>静态资源的重定向(JS脚本)</h6><p>访问一个web资源，如果直接访问 <code>localhost:port</code> 一般会请求一个主页index.html，为了能直接从地址访问资源，创建一个index.html，添加一个跳转的js脚本</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span>=<span class="string">&quot;pages/books.html&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default/">1</a><span class="space">&hellip;</span><a class="page-number" href="/default/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/default/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/default/page/7/">7</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">碎梦</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/scatteredream" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
