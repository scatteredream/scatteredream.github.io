<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Arvo:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scatteredream.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="scatteredream&#39;s blog">
<meta property="og:url" content="http://scatteredream.github.io/default/page/4/index.html">
<meta property="og:site_name" content="scatteredream&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="碎梦">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://scatteredream.github.io/default/page/4/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default/page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>scatteredream's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">scatteredream's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="碎梦"
      src="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
  <p class="site-author-name" itemprop="name">碎梦</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">66</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">115</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/30/MySQL%20%E5%9F%BA%E7%A1%80%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/30/MySQL%20%E5%9F%BA%E7%A1%80%E7%AF%87/" class="post-title-link" itemprop="url">MySQL 基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-30 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-30T00:00:00+08:00">2024-09-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:50:10" itemprop="dateModified" datetime="2025-05-05T11:50:10+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>DB</strong>: organized data</p>
<p><strong>DBMS</strong>: manage system</p>
<p><strong>RDBMS</strong>: SQLite PostgreSQL MySQL Oracle Microsoft SQL Server (relational)</p>
<p><strong>SQL</strong>: programming language</p>
<p><strong>数据模型</strong>：管理系统：数据库：表：数据</p>
<p><strong>RDBMS</strong>: 表结构格式统一</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920142153024.png" alt="image-20240920142153024"></p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923202742353.png" alt="image-20240923202742353"></p>
<p>auto_increment 从零开始自动增长 (列是数字的类型，并且是UNIQUE约束)</p>
<p> 这一列不指定id，或者id赋值null 不影响自增</p>
<h3 id="非空，唯一，主键，默认，检查约束"><a href="#非空，唯一，主键，默认，检查约束" class="headerlink" title="非空，唯一，主键，默认，检查约束"></a>非空，唯一，主键，默认，检查约束</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923220639875.png" alt="image-20240923220639875"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923220734860.png" alt="image-20240923220734860"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923220750052.png" alt="image-20240923220750052"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923220711866.png" alt="image-20240923220711866"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005154832392.png" alt="image-20241005154832392"></p>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>数据一致性 完整性</p>
<p>外键：连接两个表的数据</p>
<ul>
<li>（<strong>constraint</strong> foreKeyCons）<strong>foreign key</strong>(dept_id) <strong>references</strong> dept(id) 建表时</li>
<li>给当前表中的dept_id列定义了一个 名为 foreKeyCons 的外键约束，外键引用dept表的id列，dept_id就是外键</li>
<li>dept就是主表，必须存在，并且id是主键</li>
<li>因为有外键约束，所以不能直接删除主表的内容，</li>
</ul>
<p>建表以后对外键的操作：添加和删除。外键属于表的属性</p>
<ul>
<li><strong>alter table</strong> emp <strong>drop foreign key</strong> foreKeyCons</li>
<li><strong>alter table</strong> emp <strong>add constraint</strong> foreKeyCons <strong>foreign key</strong>(dept_id) <strong>references</strong> dept(id)</li>
</ul>
<h4 id="外键的删除、更新行为"><a href="#外键的删除、更新行为" class="headerlink" title="外键的删除、更新行为"></a>外键的删除、更新行为</h4><p>on update 更新   on delete 删除</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005155438576.png" alt="image-20241005155438576"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005155543394.png" alt="image-20241005155543394"></p>
<p>NOACTION RESTRICT 默认</p>
<p>CASCADE 主表变了，子表跟着变，主表删了，子表跟着没</p>
<p><strong>ON DELETE</strong> SET NULL 主表删了，子表把对应的值设为null，只支持删除操作，并且要求外键可以为null</p>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923224354382.png" alt="image-20240923224354382"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923224409160.png" alt="image-20240923224409160"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923224759437.png" alt="image-20240923224759437"></p>
<p>1-M 多的一方建立外键，少的一方作为主表，连接起来</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923225452261.png" alt="image-20240923225452261"></p>
<p>M-N 一起连到一张中间表，中间表做从表，建立外键，连到两张表的主键上</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240923225514320.png" alt="image-20240923225514320"></p>
<p>一个商品可能属于不同订单，一个订单也可能有不同商品，所以用类似坐标的方式</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>管理DML语句，InnoDB引擎才支持事务</p>
<p>MySQL默认设置事务自动提交，也就是执行完自动COMMIT.</p>
<p>如果要显式开启事务要SET AUTOCOMMIT = 0;（以后的事务都需要手动提交）</p>
<p>或者 START Transaction /  BEGIN （临时开启一条事务）</p>
<p>COMMIT 提交事务 如果没有问题就提交</p>
<p>ROLLBACK 回滚事务 出现异常就要回滚事务到BEGIN处，即更改前</p>
<h3 id="四大特征-acid"><a href="#四大特征-acid" class="headerlink" title="四大特征 acid"></a>四大特征 acid</h3><p>一致性依赖于应用层，开发者。</p>
<p><strong>A</strong>tomic <strong>C</strong>onsistency <strong>I</strong>solation <strong>D</strong>urability</p>
<p>最小操作单位，不可分割；</p>
<p>完成时必须让所有数据都前后一致，由开发者指定，比如转账，金钱总额不能变化；</p>
<p>多个事务是互相隔离的，排除其他事务对本事务的影响（解决并发问题）；</p>
<p>事务对数据库的修改是持久的；</p>
<p>一什么是隔离性？</p>
<p>隔离性是数据库事务的四个基本属性之一，即 <strong>ACID</strong> 特性中的 “I”（Isolation）。隔离性保证了一个事务在未完成之前，它的操作对其他事务是不可见的，或者说部分可见（取决于隔离级别）。这样可以防止因并发执行而导致的数据问题。</p>
<h3 id="高并发下可能遇到的问题："><a href="#高并发下可能遇到的问题：" class="headerlink" title="高并发下可能遇到的问题："></a>高并发下可能遇到的问题：</h3><ol>
<li><p><strong>脏读</strong>（Dirty Read）：一个事务读取了另一个事务<strong>开始了但未提交</strong>的数据。如果另一个事务回滚或者提交，这些数据将无效，导致第一个事务读取了错误数据。</p>
<ol>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005213034469.png" alt="image-20241005213034469"></li>
</ol>
</li>
<li><p><strong>不可重复读</strong>（Non-repeatable Read）：在同一个事务中，前后两次读取相同的数据时，数据值发生了变化，因为另一个事务在两次读取之间<strong>修改并提交了该数据</strong>。</p>
<ol>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005213018573.png" alt="image-20241005213018573"></li>
</ol>
</li>
<li><p><strong>幻读</strong>（Phantom Read）：一个事务内，连续两次执行相同的查询（select）时，再次进行查询的时候真实的数据集已经发生了变化，但是A却查询不出来这种变化，因此产生了幻读。</p>
<ol>
<li>如果已经解决了12，将会发现：第一次查询没有结果，随后另一个事务插入数据并进行了提交，试图插入数据，会报错，提示不能有重复的主键，但是在第二次查询仍然没有结果，读不到别人已经提交的数据（repeatable read）但是别人提交的数据还在影响。</li>
<li><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005214729161.png" alt="image-20241005214729161"></li>
</ol>
</li>
</ol>
<h3 id="通过隔离性解决高并发问题："><a href="#通过隔离性解决高并发问题：" class="headerlink" title="通过隔离性解决高并发问题："></a>通过隔离性解决高并发问题：</h3><p>数据库系统通常提供多种<strong>事务隔离级别</strong>，每个级别可以解决一部分或全部并发问题。这些隔离级别定义了事务之间可见性规则，数据库可以根据应用场景选择适当的隔离级别来权衡性能与数据一致性。</p>
<p><code>select @@transaction_isolation</code> 查看当前的隔离级别</p>
<p><code>set session transaction isolation level read uncommitted</code>设置当前会话的隔离级别，</p>
<h3 id="SQL-标准定义的四种隔离级别"><a href="#SQL-标准定义的四种隔离级别" class="headerlink" title="SQL 标准定义的四种隔离级别"></a>SQL 标准定义的四种隔离级别</h3><ol>
<li><strong>读未提交（Read Uncommitted）</strong>：<ul>
<li><strong>脏读</strong>、<strong>不可重复读</strong> 和 <strong>幻读</strong> 都可能发生。</li>
<li>最低的隔离级别，事务可以读取未提交的数据。</li>
<li>使用场景：极高并发要求且对数据一致性要求不高的场景。</li>
</ul>
</li>
<li><strong>读已提交（Read Committed）</strong>：Oracle 默认<ul>
<li>解决脏读问题，但仍然可能出现不可重复读和幻读。</li>
<li>一个事务只能读取已提交的数据，保证不会读取到未提交的修改。</li>
<li>使用场景：大多数数据库系统的默认隔离级别，较好的性能和数据一致性的平衡。</li>
</ul>
</li>
<li><strong>可重复读（Repeatable Read）</strong>：MySQL 默认<ul>
<li>解决脏读和不可重复读问题，但幻读仍然可能发生。</li>
<li>在同一事务中，事务两次读取相同的数据，保证两次读取的结果一定相同。不会读取其他事务已经提交的数据，但是仍然无法避免其他事务的影响（比如重复插入相同主键失败但是查不到这条主键的数据）</li>
<li>使用场景：需要保证数据一致性、避免更新数据不一致的场景。</li>
<li>普通的select快照读不会受到其他事务update、insert的影响，但是自己执行update时会进行当前读，会把其他事务update、insert的数据更新成自己的版本号，下一次读取就会读到了。</li>
<li>幻读：尽管B事务在A事务还未结束的时候，增加了表中的数据，但是为了维护可重复读，A事务中不管怎么查询，是查询不到新增的数据的。但是对于真实的表而言，表中的数据是的的确确增加了，所以插入重复的主键会报错。</li>
</ul>
</li>
<li><strong>串行化（Serializable）</strong>：<ul>
<li>解决脏读、不可重复读和幻读问题。</li>
<li>最高的隔离级别，所有事务串行执行，完全避免并发导致的数据问题。要等先开始的事务执行完提交或者回滚，后开始的事务才能开始执行，完全放弃并发性。</li>
<li>使用场景：极端数据一致性要求的场景，但代价是性能较低，容易出现锁等待甚至死锁。</li>
</ul>
</li>
</ol>
<h3 id="隔离性和并发控制的关系"><a href="#隔离性和并发控制的关系" class="headerlink" title="隔离性和并发控制的关系"></a>隔离性和并发控制的关系</h3><ul>
<li><strong>锁机制</strong>：隔离性通常通过锁机制（例如行锁、表锁）实现。在高隔离级别下（如可串行化），数据库会使用更严格的锁定策略，确保其他事务在未提交前不能读取或修改被锁定的数据。</li>
<li>**多版本并发控制 (MVCC)**：有些数据库（如 PostgreSQL、MySQL 的 InnoDB 存储引擎）采用了多版本并发控制，允许在较高隔离级别下提高性能。MVCC 通过保存数据的多个版本，允许读取操作无需阻塞写入操作，从而在高并发下仍然能够提供一致的数据读取。</li>
</ul>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="通用语法"><a href="#通用语法" class="headerlink" title="通用语法"></a>通用语法</h3><ul>
<li>可以多行书写，分号结尾</li>
<li>可用空格和缩进增强可读性</li>
<li>MySQL的SQL语句不区分大小写，关键字建议大写</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>DDL definition 定义数据库对象(表、db，字段)</p>
<p>DML manipulation 操作数据，增删改</p>
<p>DQL query 查询</p>
<p>DCL control 创建用户，控制访问权限</p>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>control 控制数据库访问权限和管理数据库用户</p>
<h4 id="DCL-用户管理"><a href="#DCL-用户管理" class="headerlink" title="DCL-用户管理"></a>DCL-用户管理</h4><p>use mysql;</p>
<p>select * from user;</p>
<ul>
<li><p>创建用户 <strong>create user</strong> ‘itcast‘<strong>@</strong>‘localhost’ <strong>identified by</strong> ‘123456’ 密码123456用户名itcast 主机localhost</p>
</li>
<li><p>创建用户 <strong>create user</strong> ‘heima‘<strong>@</strong>‘%’ <strong>identified by</strong> ‘123456’ 密码123456用户名heima  任意主机均可访问</p>
</li>
<li><p>改密码 alter user ‘heima‘<strong>@</strong>‘%’ <strong>identified with</strong> mysql_native_password by ‘1234’ 改成1234</p>
</li>
<li><p>drop user ‘heima‘<strong>@</strong>‘%’  删除用户</p>
</li>
</ul>
<h4 id="DCL-控制权限"><a href="#DCL-控制权限" class="headerlink" title="DCL - 控制权限"></a>DCL - 控制权限</h4><ul>
<li>查询有什么权限：SHOW GRANTS FOR 用户@主机</li>
<li>授予用户权限：grant all on 数据库名.表名 to 用户@主机</li>
<li>撤销用户权限：revoke all on 数据库名.表名 from 用户@主机</li>
</ul>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><h4 id="数据库操作-database"><a href="#数据库操作-database" class="headerlink" title="数据库操作-database"></a>数据库操作-database</h4><ul>
<li><code>SHOW DATABASES;</code> 查询所有数据库（展示）</li>
<li><code>SELECT DATABASE();</code> 查询当前数据库（展示）</li>
<li><code>CREATE DATABASE if not exists name;</code>如果不存在则创建一个名为 name 的数据库，后面可以加<code>default charset + 字符集</code> <code>COLLATE 排序规则</code></li>
<li><code>DROP DATABASE IF EXISTS;</code> 如果存在则删除</li>
<li><code>USE name;</code> 使用名为name的数据库</li>
</ul>
<h4 id="表操作-查询-table"><a href="#表操作-查询-table" class="headerlink" title="表操作-查询 table"></a>表操作-查询 table</h4><ul>
<li><code>SHOW TABLES; </code> </li>
<li><code>DESC 表名;</code> 查询表结构</li>
<li><code>SHOW CREATE TABLE 表名;</code> 查询建表时候的信息</li>
</ul>
<h4 id="表操作-创建-table"><a href="#表操作-创建-table" class="headerlink" title="表操作-创建 table"></a>表操作-创建 table</h4><ul>
<li><p>```sql<br>use itcast;<br>create table tb_user(</p>
<pre><code>id int comment &#39;编号&#39;,
name varchar(50) comment &#39;姓名&#39;,
age int comment &#39;年龄&#39;,
gender varchar(1) comment &#39;性别&#39;
) comment &#39;用户表&#39;;
</code></pre>
<p>desc tb_user;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 表操作- 数据类型</span><br><span class="line"></span><br><span class="line">##### 数值类型：</span><br><span class="line"></span><br><span class="line">TINYINT-byte   SMALLINT-short MEDIUMINT-3 bytes INT/INTEGER-int </span><br><span class="line"></span><br><span class="line">BIGINT-long  FLOAT DOUBLE DECIMAL </span><br><span class="line"></span><br><span class="line">TINYINT UNSIGNED(0-255) 无符号的tinyint</span><br><span class="line"></span><br><span class="line">DOUBLE(4,1)4代表总位数 1代表小数部分的位数 </span><br><span class="line"></span><br><span class="line">##### 字符串类型：</span><br><span class="line"></span><br><span class="line">![image-20240920183842122](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920183842122.png)</span><br><span class="line"></span><br><span class="line">|          | char(10)     | varchar(10) |</span><br><span class="line">| -------- | ------------ | ----------- |</span><br><span class="line">| 最小长度 | 10           | 0           |</span><br><span class="line">| 最大长度 | 10           | 10          |</span><br><span class="line">| eg       | 性别、手机号 | 用户名      |</span><br><span class="line"></span><br><span class="line">##### 日期类型</span><br><span class="line"></span><br><span class="line">![image-20240920184425055](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920184425055.png)</span><br><span class="line"></span><br><span class="line">![image-20240926153912988](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926153912988.png)</span><br><span class="line"></span><br><span class="line">![image-20240926153925471](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926153925471.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 表操作-修改表属性</span><br><span class="line"></span><br><span class="line">**alter table** employee **add** nickname varchar(20) [comment] [约束]; **添加属性**</span><br><span class="line"></span><br><span class="line">**alter table** employee **modify** nickname char(20); **修改数据类型**</span><br><span class="line"></span><br><span class="line">**alter table** employee **change** nickname idCard char(18) [comment] [约束]; **改名字+数据类型** </span><br><span class="line"></span><br><span class="line">**alter table** employee **drop** nickname; **删除** </span><br><span class="line"></span><br><span class="line">**alter table** employee **rename to** emp; **改表名**  </span><br><span class="line"></span><br><span class="line">#### 表操作-删除</span><br><span class="line"></span><br><span class="line">**drop table** [if exists] 表名;   **删除整个表**</span><br><span class="line"></span><br><span class="line">**truncate table** 表名; **删除数据不删表结构**</span><br><span class="line"></span><br><span class="line">#### MySQL GUI</span><br><span class="line"></span><br><span class="line">SQLyog Navicat DataGrip</span><br><span class="line"></span><br><span class="line">### DML</span><br><span class="line"></span><br><span class="line">INSERT UPDATE DELETE </span><br><span class="line"></span><br><span class="line">#### 添加数据</span><br><span class="line"></span><br><span class="line">**insert into** 表名(属性1，属性2....) **values**（v1,v2...）指定属性</span><br><span class="line"></span><br><span class="line">**insert into** 表名 **values**（v1,v2...）所有</span><br><span class="line"></span><br><span class="line">字段和值一一对应，字符串和日期在单引号中</span><br><span class="line"></span><br><span class="line">**多条数据**: **values**</span><br><span class="line"></span><br><span class="line">​		（v1,v2...）,</span><br><span class="line"></span><br><span class="line">​		(v1,v2....) 不同条数据用逗号隔开</span><br><span class="line"></span><br><span class="line">#### 修改数据</span><br><span class="line"></span><br><span class="line">**update** employee **set** name = &#x27;itheima&#x27; **where** id=1;</span><br><span class="line"></span><br><span class="line">#### 删除数据</span><br><span class="line"></span><br><span class="line">**delete from** 表名 [where 条件] 无条件会删除整张表格的数据</span><br><span class="line"></span><br><span class="line">### DQL</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line"></span><br><span class="line">#### 基本查询</span><br><span class="line"></span><br><span class="line">##### 查询多个字段 </span><br><span class="line"></span><br><span class="line">**select** 字段1，字段2........ **from** 表名</span><br><span class="line"></span><br><span class="line">**select * from** 表名       通配符</span><br><span class="line"></span><br><span class="line">##### 设置别名</span><br><span class="line"></span><br><span class="line">**select** 字段1[**as** 别名1]，字段2[**as** 别名2].... **from** 表名 as可省略</span><br><span class="line"></span><br><span class="line">##### 去重</span><br><span class="line"></span><br><span class="line"> **select distinct** ........</span><br><span class="line"></span><br><span class="line">#### 条件查询 WHERE</span><br><span class="line"></span><br><span class="line">![image-20240920211218098](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920211218098.png)</span><br><span class="line"></span><br><span class="line">**select * from** employ where age **in**(12,45,43);</span><br><span class="line"></span><br><span class="line">**select * from** employ where name **like &#x27;__&#x27;**; 名字是两个字符  模糊查询 模糊匹配</span><br><span class="line"></span><br><span class="line">##### sql 模糊查询</span><br><span class="line"></span><br><span class="line">通配符：</span><br><span class="line"></span><br><span class="line">- %: %网% 查询含有网字的数据</span><br><span class="line"></span><br><span class="line">  ​     %网    查询以网字结尾的数据</span><br><span class="line"></span><br><span class="line">  ​      %网%车    查询含有 网 和 车的数据 有先后顺序</span><br><span class="line"></span><br><span class="line">- _ :   网_ 网开头 长度为2个字</span><br><span class="line"></span><br><span class="line">  ​	_ _ 网 长度为3个字 最后一个字是网</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">between and </span><br><span class="line"></span><br><span class="line">in </span><br><span class="line"></span><br><span class="line">is null </span><br><span class="line"></span><br><span class="line">#### 聚合函数 </span><br><span class="line"></span><br><span class="line">![image-20240920212134476](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240920212134476.png)</span><br><span class="line"></span><br><span class="line">count(*)所有行 count(age)age非空的行数</span><br><span class="line"></span><br><span class="line">作用在列数据，**null不参与运算~**</span><br><span class="line"></span><br><span class="line">select count(age) from emp where workAddress = &#x27;西安&#x27;; </span><br><span class="line"></span><br><span class="line">位于select关键字之后 可以加where条件</span><br><span class="line"></span><br><span class="line">#### 分组查询 GROUP BY &amp; HAVING</span><br><span class="line"></span><br><span class="line">group by xxx 将具有相同xxx值的行归为一组，每一组执行聚合count  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**select** gender, count(*) **from** emp **&lt;u&gt;group by&lt;/u&gt;** gender;  计算行的数量，并按照gender分组</span><br><span class="line"></span><br><span class="line">- where 分组之前过滤 </span><br><span class="line">- **having** 对分组之后的结果进行过滤</span><br><span class="line">- where 不能对聚合函数判断， having可以，要判断聚合函数就要分完组</span><br><span class="line">- 执行顺序：where&gt;聚合函数&gt;having</span><br><span class="line">- 先用where筛选个体，然后分组，再对组内执行聚合函数，执行的结果可以再用having筛选</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 排序查询 ORDER BY</span><br><span class="line"></span><br><span class="line">ASC:ascending 默认</span><br><span class="line"></span><br><span class="line">DESC:descending</span><br><span class="line"></span><br><span class="line">- 语句的最后，添加 **order by** age **asc**;</span><br><span class="line">- **order by** age **desc** , entryDate; 先按照age降序，如果age相同在按照entryDate升序</span><br><span class="line"></span><br><span class="line">#### 分页查询 LIMIT</span><br><span class="line"></span><br><span class="line">查询xx页码</span><br><span class="line"></span><br><span class="line">LIMIT 起始索引，查询记录数</span><br><span class="line"></span><br><span class="line">每页是20条，第一页的起始数据是0，第二页的20</span><br><span class="line"></span><br><span class="line">limit 0,5 第一页，一页5条记录</span><br><span class="line"></span><br><span class="line">**limit** 5 **offset** 0 第一页 limit 5 offset 20 第五页</span><br><span class="line"></span><br><span class="line">#### 执行顺序</span><br><span class="line"></span><br><span class="line">先执行from 再用where过滤，然后用group by和having指定分组以及过滤，然后执行字段的select，接着是排序，最后分页</span><br><span class="line"></span><br><span class="line">在字段名，表名后加别名，看是否报错，验证上述顺序</span><br><span class="line"></span><br><span class="line">### 多表查询</span><br><span class="line"></span><br><span class="line">#### 表关系</span><br><span class="line"></span><br><span class="line">多对多：同一个学生可以选择多门课程，同一个课程也可以被多名学生选择，如果要描述他们之间的关系，添加一张中间表，里面的外键分别对应两张表的主键。</span><br><span class="line"></span><br><span class="line">一对多：多的一方建立外键，关联到少的主键。</span><br><span class="line"></span><br><span class="line">一对一：任意一方建立外键（UNIQUE），关联到另外的主键。</span><br><span class="line"></span><br><span class="line">![image-20241005161911780](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005161911780.png)</span><br><span class="line"></span><br><span class="line">#### 链接查询 JOIN</span><br><span class="line"></span><br><span class="line">##### 消除笛卡尔积</span><br><span class="line"></span><br><span class="line">![image-20241005162327168](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005162327168.png)</span><br><span class="line"></span><br><span class="line">##### 内连接</span><br><span class="line"></span><br><span class="line">只查询A和B相交的部分</span><br><span class="line"></span><br><span class="line">**select** *e*.name,*e*.gender,*d*.dname **from** *emp e*,*dept d* ... **where**    条件 (隐式) </span><br><span class="line"></span><br><span class="line">**select** * **from** *emp* **join** *dept* on     条件（显式）</span><br><span class="line"></span><br><span class="line">##### 外连接</span><br><span class="line"></span><br><span class="line">![image-20241005163112728](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005163112728.png)</span><br><span class="line"></span><br><span class="line">e.* emp的全部数据 </span><br><span class="line"></span><br><span class="line">from *A* left join B 查询*A* ∪ (A∩B)</span><br><span class="line"></span><br><span class="line">from *A* right join B 查询*B* ∪ (A∩B)</span><br><span class="line"></span><br><span class="line">##### 自链接</span><br><span class="line"></span><br><span class="line">一定要起别名</span><br><span class="line"></span><br><span class="line">![image-20241005163553452](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005163553452.png)</span><br><span class="line"></span><br><span class="line">没有必要专门搞一张领导表出来，如果要实现需求就要把一张表分成两张看，a的经理id等于b的id</span><br><span class="line"></span><br><span class="line">![image-20241005163805094](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005163805094.png)</span><br><span class="line"></span><br><span class="line">##### 外键？连接查询？</span><br><span class="line"></span><br><span class="line">在多表查询中，**连接查询**（JOIN）并不强制要求外键的存在。外键的作用是维护表之间的**参照完整性**，确保一张表中的某些值对应另一张表中的有效值。但在进行连接查询时，只要有可以用于关联两个表的字段（如主键和某个相应的列），就可以进行查询，而不需要一定设置外键。</span><br><span class="line"></span><br><span class="line">#### 联合查询</span><br><span class="line"></span><br><span class="line">把两条单表查询结果联合起来，字段数量必须一致</span><br><span class="line"></span><br><span class="line">UNION：自动根据主键去重</span><br><span class="line"></span><br><span class="line">UNION ALL: 不去重</span><br><span class="line"></span><br><span class="line">#### 子查询 按返回值分类</span><br><span class="line"></span><br><span class="line">##### **单行单列**：只返回一个**值** </span><br><span class="line"></span><br><span class="line">- ![image-20241005165024271](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005165024271.png)</span><br><span class="line"></span><br><span class="line">##### **单行多列**：返回的是一行数据</span><br><span class="line"></span><br><span class="line">- ![image-20241005S171121759](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005171121759.png)![image-20241005171132602](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005171132602.png)</span><br><span class="line"></span><br><span class="line">- 第一步返回的是**一行两列**的数据（salary，managerid），第二步的条件可以用where (salary, managerid) = 第一行的结果</span><br><span class="line"></span><br><span class="line">- &lt;a href=&quot;#extension&quot;&gt;多行多列扩展&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### **多行单列**：子查询返回的是多行单列的数据</span><br><span class="line"></span><br><span class="line">也就是同一个字段的值的集合，用括号括起来，最后查询可以如下操作符（操作对象是同一字段的值的集合）</span><br><span class="line"></span><br><span class="line">- in **等于**集合内部的某一个值</span><br><span class="line"></span><br><span class="line">- any/some **大于** any 只需大于最小值 小于any只需小于最大值**相当于存在量词∃** </span><br><span class="line">- all **相当于全称量词∀**</span><br><span class="line"></span><br><span class="line">- ![image-20241005165513314](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005165513314.png)</span><br><span class="line">- ![image-20241005165204726](https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005165204726.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### **多行多列**： 虚拟表</span><br><span class="line"></span><br><span class="line">子查询返回的是多行多列数据，也就是虚拟表，从这张虚拟表中再和其他表进行连接查询。</span><br><span class="line"></span><br><span class="line">- **虚拟表**: 查询入职日期 在2011-11-11之后的员工信息和部门信息：先查入职在2011-11-11之后的员工信息，根据这些信息（虚拟表,也叫临时表）和部门表 连接查询</span><br><span class="line"></span><br><span class="line">  - ```sql</span><br><span class="line">    SELECT * FROM (select * from emp where join_date&gt;&#x27;2011-11-11&#x27;)e JOIN dept on e.dep_id = dept.id</span><br></pre></td></tr></table></figure></li>
<li><p><span id="extension"><strong>也可以作为单行多列的扩展</strong></span> in 关键字</p>
<ul>
<li>查询第一步返回的是<strong>多行多列</strong>的数据（salary，managerid），第二步的条件可以用where (salary, managerid) in 第一行的结果</li>
</ul>
</li>
</ul>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>可以直接被另一段程序调用的程序或代码——-常见MySQL内置函数</p>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>concat substring TRIM upper </p>
<p>LPAD(STR, 6, ‘0’) 左对齐，6位补0</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005154345722.png" alt="image-20241005154345722"></p>
<h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><p>ceil floor round rand（0-1随机数）mod</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005154156390.png" alt="image-20241005154156390"></p>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>date_add now curdate curtime datediff</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005154146380.png" alt="image-20241005154146380"></p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005153559225.png" alt="image-20241005153559225"></p>
<p><code>if(expr, caseTrue, caseFalse) expr = true</code> 返回caseTrue</p>
<p><code>ifnull(v1,v2)</code> v1=null 返回v2 空字符串不是null，null必须是什么都没有，v1不为null，则返回v1</p>
<p>case when</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005153230584.png" alt="image-20241005153230584"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241005153515232.png" alt="image-20241005153515232"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/20/408-%E8%AE%A1%E7%BB%84-CPU/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/20/408-%E8%AE%A1%E7%BB%84-CPU/" class="post-title-link" itemprop="url">数的运算 CPU 指令系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-20T00:00:00+08:00">2024-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 12:43:11" itemprop="dateModified" datetime="2025-05-05T12:43:11+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">计组</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数和运算"><a href="#数和运算" class="headerlink" title="数和运算"></a>数和运算</h1><h2 id="无符号和有符号数"><a href="#无符号和有符号数" class="headerlink" title="无符号和有符号数"></a>无符号和有符号数</h2><h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><p>寄存器位数就等于无符号数的位数</p>
<h3 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h3><p>符号位+数值位</p>
<p>机器数是机器中的表示方法，真值就是真实的值。比如真值为+1，机器数就是00001(四位二进制+符号位)</p>
<h4 id="原码表示法"><a href="#原码表示法" class="headerlink" title="原码表示法"></a>原码表示法</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706213908812.png" alt="image-20240706213908812"></p>
<p>7的原码 0111 真值共3位</p>
<p>-5的原码先取反5即101，再加2^3^ 1101，n是数据位数</p>
<p>本质是带符号的绝对值，符号被数字化，小数如下：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706220258001.png" alt="image-20240706220258001"></p>
<p>问题：<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706220732148.png" alt="image-20240706220732148"></p>
<p>能否找到一个与负数等价的正数，代替这个负数，使的加这个负数就等于加她的等价正数？</p>
<h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>补的概念</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706221056891.png" alt="image-20240706221056891"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706221538615.png" alt="image-20240706221538615"></p>
<p>加负数等于加他的补数</p>
<p>两个互为补数的数加<strong>模</strong>仍然互为补数</p>
<p>所以正数的补数就是他本身</p>
<p>但是此时有一个问题，没法区分是正还是负，所以再加一个符号位，用32为模</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706221948440.png" alt="image-20240706221948440"></p>
<p>-1011+100000 = 1 0101</p>
<p>1011+ 100000 = 0 0101</p>
<p>-1011加一个模变成0101，但区分不出来，所以再加一个模，变成1 0101 能区分了</p>
<p>==定义：== <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706222619681.png" alt="image-20240706222619681">  </p>
<p>x表示真值。n是整数的位数，踢去符号位。</p>
<p>原码表示2+（-2）:0,0000010+1,0000010=1,0000100 得-4，显然不对</p>
<p>如果用反码表示，还是不对，但是离正确结果很近了，只需要加1</p>
<p>所以-2应该是11111111的写法</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707145106425.png" alt="image-20240707145106425"></p>
<p>整数的补码：0只有1种表示形式，所以补码能多表示一个-8</p>
<p>小数的补码：0只有1种表示形式，所以补码能多表示一个-1</p>
<h4 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h4><p>只是符号位和补码不同</p>
<h2 id="定点数和浮点数"><a href="#定点数和浮点数" class="headerlink" title="定点数和浮点数"></a>定点数和浮点数</h2><h3 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h3><p>约定小数点位置</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707151032925.png" alt="image-20240707151032925"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707154943326.png" alt="image-20240707154943326"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707155019121.png" alt="image-20240707155019121"></p>
<p>记住一点：补码就是能比原码多表示一个数，用四位举例，原码1111=-0.875，变成补码就是1001了，此时还剩下一个1000没有对应的，那就让他对应-1好了。四位的整数同理，原码只能表示-7到7，因为由正零和负零，如果变成补码就能多表示一个，就让多出来的1000表示-8</p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><strong>为什么</strong></p>
<p>相差太大需要很长的机器字长</p>
<p><strong>表示方法</strong> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707151550652.png" alt="image-20240707151550652"></p>
<p>定点数(尾数) + 阶码</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707151813019.png" alt="image-20240707151813019"></p>
<p><strong>表示范围</strong></p>
<p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707164938752.png" alt="image-20240707164938752"></p>
<p>下溢：0，上溢：错误</p>
<p>表示±3w的十进制数，阶符数符各一位，要搞清楚，尾数就是0.xxxxx，绝对值永远是小于1的，那么要想让N表示±3w，r^j^ 必须是3w+ 所以j阶码长度占4位，保证最大精度，剩下的全是尾数</p>
<p><strong>规格化</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707170216760.png" alt="image-20240707170216760"></p>
<p>为什么规格化？</p>
<p>r=2时，尾数如果最高位是0，就不算最简，通过阶码的变动仍然能让其变成更简</p>
<p>r=4时，尾数如果最高位是00，通过阶码变动仍然能让其变得更加简单</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707170942873.png" alt="image-20240707170942873"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707171601554.png" alt="image-20240707171601554"></p>
<p>二进制定点：整数在最后，小数在第一位后面</p>
<p>二进制浮点：规格化形式，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707172237122.png" alt="image-20240707172237122"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707152838351.png" alt="image-20240707152838351"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707153900149.png" alt="image-20240707153900149"></p>
<p>Explicit </p>
<p>符号位+ Exponent（阶码） +尾数</p>
<p><strong>机器0</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707172436375.png" alt="image-20240707172436375"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47713503/article/details/108699001">IEEE 754</a><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707172703934.png" alt="image-20240707172703934"></p>
<p>r=2,所以把1隐含掉</p>
<p>8位移码：0~128~255 分别对应真值-128~0~127 </p>
<p>7位<strong>补码</strong>尾数：补码0只有一个，多出来的一个就变成-1</p>
<p>正数：2^7^   ~   1-2^7^  </p>
<p>负数：-1   ~   -2^7^</p>
<h2 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h2><h3 id="定点移位运算"><a href="#定点移位运算" class="headerlink" title="定点移位运算"></a>定点移位运算</h3><h4 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h4><p>移位：数据相对于小数点移动</p>
<p>左移：绝对值变大</p>
<p>右移：绝对值变小</p>
<p>与加减配合实现加减乘除</p>
<h5 id="算数移位规则"><a href="#算数移位规则" class="headerlink" title="算数移位规则"></a>算数移位规则</h5><p>符号位不变</p>
<table>
<thead>
<tr>
<th></th>
<th>码制</th>
<th>添补代码</th>
</tr>
</thead>
<tbody><tr>
<td>正数</td>
<td>原反补</td>
<td>0</td>
</tr>
<tr>
<td>负数</td>
<td>原码</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>反码</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>==补码==</td>
<td>左移，右侧空出来添0</td>
</tr>
<tr>
<td></td>
<td>==补码==</td>
<td>右移，左侧空出来添1</td>
</tr>
</tbody></table>
<p>对于原码（包括正数的原反补和负数的原码）来说，1是有意义的，左移丢1，误差很大，相当于丢了权重最大的一位，补了个0。右移丢1，误差较小，丢了权重最小的一位。</p>
<p>对于负数的补码来说，根据补码的规律，最右边的“1”的右边的数与原码一致，左边的数与反码相同，所以左移丢1对数据没有影响，右移丢1，误差较小</p>
<p>对于负数的反码来说，1是没有意义的，0才有意义，所以丢1对数据没有影响。</p>
<p>反码加1变成补码，加1会导致进位，最右边的1就是进位的最终结果，补码这部分是100的原因：原来是这部分是100，取反以后变成011，加1必然导致进位变成100，这部分就跟原码一样了</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/d6ej2vfibs2cw_0e3e13be2c8747bca5abc8a7b8cbd77d.webp" alt="d6ej2vfibs2cw_0e3e13be2c8747bca5abc8a7b8cbd77d"></p>
<p>-26<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707201312846.png" alt="image-20240707201312846"></p>
<h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><p>把整个数看成一个无符号数，右移，高位补0低位舍弃，左移高位舍弃低位补0</p>
<h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><p>顾名思义</p>
<h3 id="定点加减法"><a href="#定点加减法" class="headerlink" title="定点加减法"></a>定点加减法</h3><p>补码加减法公式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707211623774.png" alt="image-20240707211623774"></p>
<p>补码 负数跟正数 遵循模32规则，所以能进行加减</p>
<p>5-3⇔5+负三补码，此时算出来的补码就是一个正数，正数可以理所当然参与运算，并且是每一位都可以，</p>
<p><strong>溢出？</strong></p>
<p><strong>一位符号位</strong>：两个操作数符号相同，结果符号与原来不同</p>
<p>最高有效位进位⊕符号位进位 = 1</p>
<p><strong>两位符号位：</strong> </p>
<p>两个符号位异或</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707215559303.png" alt="image-20240707215559303"></p>
<ol>
<li><p>正数加正数：</p>
<p>如00，1111➕00，1000，此时的运算结果就为01，0111。</p>
<p>很明显，这发生了正溢出，因为在数值位只有4位，能表示的最大数值为1111，而运算结果显然超出了该范围，于是产生了像符号位的进位，造成上溢出。</p>
</li>
<li><p>负数加负数：</p>
<p>如11，1111➕11，1000，此时的运算结果就为11，0111。</p>
<p>显然，这没有发生了溢出，其原因是在负数补码中，高位的1相当于原码的0，于是如果两个操作数的数值位最高位都是1的话，是一定不会引起操作数溢出的，与正数两个最高位为0相加，不会发生溢出是一样的。如果，有其中一个为0的话，如果次高位传来进位，依旧可以保证对符号位的进位，也就是保证符号位不会发生变化，从而避免了溢出。</p>
</li>
</ol>
<p>如果最高位为0就要小心溢出</p>
<p>低位必须产生进位，低位不进位肯定溢出</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240707221233780.png" alt="image-20240707221233780"></p>
<h3 id="定点乘除法"><a href="#定点乘除法" class="headerlink" title="定点乘除法"></a>定点乘除法</h3><ul>
<li><p>原码一位乘：先加后右移，加4次移4次</p>
<p>看最后一位，1加的是原数，0不加</p>
</li>
<li><p>补码一位乘：先加后右移，加5次移4次</p>
<p>看最后两位，01加X补码，10加(-X)补码，11和00不加</p>
</li>
<li><p>原码定点除：先加后左移，加4次移4次</p>
<p>先加(-X)补码，差值正上1，加(-X)补码得到新差值；差值负上0，加X补码得到新差值，直到商有效位够4位</p>
</li>
<li><p>补码定点除：先看同号否，同号r为x-y，异号r为x+y，</p>
<p>ry同号上1，同时左移，加-y补得到新r，ry异号上0，同时左移，加y补得到新r，再比较同号否</p>
<p>加，上商，左移</p>
<p>上了四次商之后，同时左移，商末位恒为1</p>
<p>加4移5</p>
</li>
</ul>
<h3 id="原码定点一位乘"><a href="#原码定点一位乘" class="headerlink" title="原码定点一位乘"></a>原码定点一位乘</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708143456210.png" alt="image-20240708143456210"></p>
<h3 id="补码定点一位乘（Booth）"><a href="#补码定点一位乘（Booth）" class="headerlink" title="补码定点一位乘（Booth）"></a>补码定点一位乘（Booth）</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708143522928.png" alt="image-20240708143522928"></p>
<h3 id="原码定点除法"><a href="#原码定点除法" class="headerlink" title="原码定点除法"></a>原码定点除法</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708143557760.png" alt="image-20240708143557760"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708143611525.png" alt="image-20240708143611525"></p>
<h3 id="补码定点除法"><a href="#补码定点除法" class="headerlink" title="补码定点除法"></a>补码定点除法</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708143628562.png" alt="image-20240708143628562"></p>
<p>加4移5</p>
<h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2><h3 id="浮点加减法"><a href="#浮点加减法" class="headerlink" title="浮点加减法"></a>浮点加减法</h3><h4 id="S1-对阶"><a href="#S1-对阶" class="headerlink" title="S1:对阶"></a>S1:对阶</h4><p>大阶对小阶，大阶左移丢1，如果是正数的话就是数据错误所以小对大</p>
<p>求阶差</p>
<p><strong>小阶对大阶，小阶右移丢1影响较小</strong> 尾数右移1位，阶码加1.</p>
<h4 id="S2-尾数求和"><a href="#S2-尾数求和" class="headerlink" title="S2:尾数求和"></a>S2:尾数求和</h4><p>对阶移位完的尾数进行求和，按照定点补码加减法规则进行求和</p>
<h4 id="S3-尾数规格化"><a href="#S3-尾数规格化" class="headerlink" title="S3:尾数规格化"></a>S3:尾数规格化</h4><p>r=2 尾数绝对值0.5~1</p>
<p>r=4 0.25~1</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708145911043.png" alt="image-20240708145911043"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708150126481.png" alt="image-20240708150126481"></p>
<p>-1/2要进行左规</p>
<h5 id="左规-相当于乘2"><a href="#左规-相当于乘2" class="headerlink" title="左规 相当于乘2"></a>左规 相当于乘2</h5><p>当尾数出现00.0𝑥𝑥⋯𝑥或11.1𝑥𝑥⋯𝑥时，尾数左移，阶码减1，直到数符(正负号)和第一有效数位不同</p>
<h5 id="右规-相当于除2"><a href="#右规-相当于除2" class="headerlink" title="右规 相当于除2"></a>右规 相当于除2</h5><p>尾数右移，阶码加1，直到数符(正负号)和第一有效数位不同</p>
<p>尾数溢出(&gt;1)的时候需要右规</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708150440008.png" alt="image-20240708150440008"></p>
<h4 id="S4-舍入"><a href="#S4-舍入" class="headerlink" title="S4:舍入"></a>S4:舍入</h4><p>对阶和右规过程中，可能会出现尾数末位丢1的情况，影响精度，考虑舍入。简单截断可以</p>
<p>1)0舍1入：即在尾数右移时，被移去的最高数值位为0，则舍去;被移去的最高数值位为1，则在尾数的末位加1。这样做可能会使尾数又溢出，此时需再做一次右规。</p>
<p>2)末位恒置“1”：尾数右移时，不论丢掉的最高数值位是“1”还是“O”，都使右移后的尾数末位恒置“1”。这种方法同样有使尾数变大和变小的两种可能。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708151934259.png" alt="image-20240708151934259"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708151949418.png" alt="image-20240708151949418"></p>
<h4 id="S5-溢出判断"><a href="#S5-溢出判断" class="headerlink" title="S5:溢出判断"></a>S5:溢出判断</h4><p> 与定点数加减法一样，浮点数加减运算最后一步也需判断溢出。</p>
<p>在浮点数规格化中已指出，当尾数之和（差）出现01.×××或10.xxx时，<strong>并不表示溢出，</strong>只能将此数右规后，再根据阶码来判断浮点数运算结果是否溢出。</p>
<p>浮点数的溢出与否是由阶码的符号决定的。以双符号位补码为例，当阶码的符号位出现“01”时，即阶码大于最大阶码时，表示上溢，进入中断处理;当阶码的符号位出现“10”时，即阶码小于最小阶码时，表示下溢，按机器零处理。实际上原理还是阶码符号位不同表示溢出，且真实符号位和高位符号位一致。 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708153404896.png" alt="image-20240708153404896"></p>
<p>最大负数：11.1000…..0 表示-1/2但它不是规格化数，11.0111…..1,应该变小一点,减去2^-n^。尾数原来是-1/2，最后尾数变成-(1/2+2^-n^)</p>
<p>负数的补码应该是100000加到111111，越加越大，所以要从110000变成101111就要减去一个最小单位</p>
<h4 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h4><p>尾数溢出，右规丢1会引起误差</p>
<p>对阶，小对大，右移丢1会引起误差</p>
<h3 id="ALU-算数逻辑单元"><a href="#ALU-算数逻辑单元" class="headerlink" title="ALU-算数逻辑单元"></a><span id="jump">ALU-算数逻辑单元</span></h3><p><strong>A</strong>rithmetic <strong>L</strong>ogic <strong>U</strong>nit</p>
<h4 id="ALU电路"><a href="#ALU电路" class="headerlink" title="ALU电路"></a>ALU电路</h4><p>组合逻辑电路 74181 控制端 CLA</p>
<p>需要寄存器保存结果</p>
<p>M=0，M=1 算数运算和逻辑运算</p>
<p>S3~S0 不同取值 可以做不同运算</p>
<h4 id="快速进位"><a href="#快速进位" class="headerlink" title="快速进位"></a>快速进位</h4><h5 id="并行加法器"><a href="#并行加法器" class="headerlink" title="并行加法器"></a>并行加法器</h5><p>A和B两个数可以同时加进来，然后进行运算，四个位各自算各自的e</p>
<p>很多全加器接在一起</p>
<h5 id="串行进位-Ripple-Carry"><a href="#串行进位-Ripple-Carry" class="headerlink" title="串行进位 Ripple Carry"></a>串行进位 Ripple Carry</h5><p>Propagate &amp; Generate</p>
<p>P<del>i</del> = A<del>i</del>⊕B<del>i</del> , G<del>i</del> = A<del>i</del>B<del>i</del></p>
<p>C<del>i</del> = A<del>i</del>B<del>i</del> + C<del>i-1</del>(A<del>i</del>⊕B<del>i</del>) </p>
<p>​    =G<del>i</del> + P<del>i</del>C<del>i-1</del>    ，C<del>-1</del> = 0 </p>
<p>S<del>i</del> = A<del>i</del>⊕B<del>i</del>⊕C<del>i</del> </p>
<h5 id="并行进位（超前进位）-LookAhead-Carry"><a href="#并行进位（超前进位）-LookAhead-Carry" class="headerlink" title="并行进位（超前进位） LookAhead Carry"></a>并行进位（超前进位） LookAhead Carry</h5><p>C<del>i</del> =G<del>i</del> + P<del>i</del>C<del>i-1</del> ，C<del>-1</del> = 0</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708162300561.png" alt="image-20240708162300561"></p>
<p>用电路复杂度换取速度</p>
<p>按照公式可以计算出C0到C3的结果</p>
<p>S<del>i</del> = A<del>i</del>⊕B<del>i</del>⊕C<del>i</del> </p>
<h5 id="单重分组跳跃进位链"><a href="#单重分组跳跃进位链" class="headerlink" title="单重分组跳跃进位链"></a>单重分组跳跃进位链</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708162814971.png" alt="image-20240708162814971"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708170057566.png" alt="image-20240708170057566"></p>
<p>折中的办法，组内先行进位，组外采用串行进位，C0-C3同时产生</p>
<h5 id="双重分组跳跃进位链"><a href="#双重分组跳跃进位链" class="headerlink" title="双重分组跳跃进位链"></a>双重分组跳跃进位链</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708163024193.png" alt="image-20240708163024193"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708171039868.png" alt="image-20240708171039868"></p>
<p>小组的最高位进位并行产生，大组之间采用串行</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708165658159.png" alt="image-20240708165658159"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708163546185.png" alt="image-20240708163546185"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708165732848.png" alt="image-20240708165732848"></p>
<p>这种电路称为成组先行进位电路（BCLA)。利用这种4位的 BCLA电路及进位产生与传递电路和求和电路可以构成4位BCLA加法器。16位的两级先行进位加法器可由4个BCLA加法器和1个CLA电路构成，如图2.18所示。</p>
<p>这种方法可以扩展到多于两级的先行进位加法器，如用三级先行进位结构设计64位加法器这种加法器的优点是字长对加法时间影响甚小;缺点是造价较高。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708174638709-1720432067641-1.png" alt="image-20240708174638709"></p>
<h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><p>指令系统连接软件和硬件</p>
<h2 id="机器指令"><a href="#机器指令" class="headerlink" title="机器指令"></a>机器指令</h2><p>指令= 操作码+地址码</p>
<p><strong>操作码长度</strong>可以固定，用于指令字长比较长的情况，也可以变化比如X86</p>
<p>为了使操作码扩展，可以让操作码的位数随地址码的减少而增加。</p>
<p>在设计扩展操作码指令格式时，必须注意以下两点:</p>
<ol>
<li><p>不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同。</p>
</li>
<li><p>各指令的操作码一定不能重复。通常情况下，对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码，从而尽可能减少指令译码和分析的时间。</p>
</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708183944205.png" alt="image-20240708183944205"></p>
<p>按照<strong>操作数地址码个数可</strong>以分为：</p>
<p>操作数地址码的长度一般是一样的,如果长度为8,寻址范围就是2^8^ 个.</p>
<p>零地址:  OP</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708183415639.png" alt="image-20240708183415639"></p>
<p>3)让(ACC)OP-&gt;(ACC) ACC自加</p>
<p>一地址: OP+A1</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708183401932.png" alt="image-20240708183401932"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708184734580.png" alt="image-20240708184734580"></p>
<p>二地址: OP+A1+A2</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708183546042.png" alt="image-20240708183546042"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708184553805.png" alt="image-20240708184553805"></p>
<p>ACC代替A1/A2,</p>
<p>三地址:OP+A1+A2+A3(结果)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708183600178.png" alt="image-20240708183600178"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708184345766.png" alt="image-20240708184345766"></p>
<p>四地址: OP+A1+A2+A3(结果)+A4(下个地址)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708183706661.png" alt="image-20240708183706661"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708184255485.png" alt="image-20240708184255485"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708184358949.png" alt="image-20240708184358949"></p>
<p>寻址范围从上到下逐渐降低</p>
<p><strong>指令字长</strong></p>
<p>指令长度和机器字长没有必然联系，指令长度等于机器字长 单子长指令，等于半个机器字长 半字长指令， 等于2个机器字长 双字长指令</p>
<p>指令长度相等，<strong>定长指令字</strong>，长度因功能而异，称为<strong>变长指令字</strong>结构，通常都是按照字节的倍数变化</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>用硬件资源(ACC)代替指令字中的地址码字段：</p>
<ul>
<li>扩大指令寻址范围（指令长度固定，地址码长度增加，能够操作的地址长度变多）</li>
<li>缩短指令字长（地址码长度不变，指令长度固定，但是地址码的个数变少，能够缩短整体的字长）</li>
<li>减少访<strong>存</strong>次数 ACC代替操作数，ACC代替结果，都能减少访存次数</li>
</ul>
<p>指令的地址字段为寄存器：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708185921002.png" alt="image-20240708185921002"></p>
<ul>
<li>指令执行阶段，可以不访存</li>
</ul>
<h2 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h2><h3 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h3><p>地址：无符号整数</p>
<p>数字：定点数、浮点数、十进制数</p>
<p>字符：ASCII</p>
<p>逻辑数：逻辑运算</p>
<h3 id="存放数据的方式"><a href="#存放数据的方式" class="headerlink" title="存放数据的方式"></a>存放数据的方式</h3><p>前提：按照字节编址每一个地址能存放一个字节</p>
<p>机器字长=CPU寄存器位数</p>
<p>存放一个机器字的存储单元，通常称为字存储单元，相应的单元地址称为字地址。而存放一字节的单元，称为字节存储单元，相应的地址称为字节地址。</p>
<p>编址方式是存储器地 址的组织方式，一般在设计处理器时就已经确定了。如果计算机中编址的<u>最小单位</u>是字存储单元，则该计算机称为<u>按字编址</u>的计算机。如果计算机中编址的最小单位是字节，则该 计算机称为<u>按字节编址</u>的计算机。一个机器字可以包含数字节，所以<u>一个存储单元也可占用数个能够单独编址的字节地址。</u> </p>
<h5 id="高地址和低地址"><a href="#高地址和低地址" class="headerlink" title="高地址和低地址"></a>高地址和低地址</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708190353466.png" alt="image-20240708190353466"></p>
<h5 id="高字节和低字节"><a href="#高字节和低字节" class="headerlink" title="高字节和低字节"></a>高字节和低字节</h5><p>如int a=16777220，化为十六进制是0x 01 23 45 67，<strong>则04属于低字节，01属于高字节</strong> 是按照字节的位置区分的</p>
<h5 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708190959696.png" alt="image-20240708190959696"></p>
<p>低字节存在高地址 大端，字地址在高字节的地址</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>字节数据</th>
</tr>
</thead>
<tbody><tr>
<td>0x0004</td>
<td>67</td>
</tr>
<tr>
<td>0x0003</td>
<td>45</td>
</tr>
<tr>
<td>0x0002</td>
<td>23</td>
</tr>
<tr>
<td>0x0001</td>
<td>01</td>
</tr>
</tbody></table>
<p>低字节存在低地址 小端，字地址在低字节的地址</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>字节数据</th>
</tr>
</thead>
<tbody><tr>
<td>0x0004</td>
<td>01</td>
</tr>
<tr>
<td>0x0003</td>
<td>23</td>
</tr>
<tr>
<td>0x0002</td>
<td>45</td>
</tr>
<tr>
<td>0x0001</td>
<td>67</td>
</tr>
</tbody></table>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708191237400.png" alt="image-20240708191237400"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708191301932.png" alt="image-20240708191301932"></p>
<p><strong>边界对准</strong> </p>
<p><strong>按照字节编址</strong>，寻址时可以按照字，半字，字节。一个字是4个字节，字的地址就是4的倍数，半字的地址就是2的倍数，字节随便存。</p>
<p>存储字长：一个存储单元中存储的位数。要提高访存速度，就要在一个存储字长放入尽可能多且完整的的存储单位。</p>
<p>一个存储字中最多容纳4个地址，分别指向4个字节，半字只能存到字的开始或中间，全字必须独占一个存储单元。浪费了一些空间，但是不会造成同一个数据的分散，能够提高存取速度。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708192833186.png" alt="image-20240708192833186"></p>
<p>边界不对齐就会导致同一个字会存储到不同的存储单元中，导致访存次数增多，还要进行数据拼接等繁冗工作。</p>
<p><strong>存储单元：每个存储单元 存放一串 二进制代码</strong></p>
<p>存储单元 和 内存单元 是不一样的，内存单元是 存储单元的 子集。多个 内存单元 可以组成 一个 存储单元。</p>
<p><strong>存储字（word）：存储单元中 二进制代码的组合</strong> </p>
<p><strong>存储字长：存储单元中 二进制代码的 位数。</strong> </p>
<p><strong>存储元：即存储一个二进制数的电子元件，每个存储元可以存储 1 bit。多个存储元 就可以 构成一个 内存单元。（由电容原理 制作出来的东西，因为电容可以 存储电荷呀 ~）</strong> </p>
<p>在这里 我们说的 存储字和存储字长，实际上 说的是 MDR 这个东西。<br>也就是这个 寄存器。它能存储 多大的数据。</p>
<p>所以我们也常说，存储字长 在 不同的硬件上 会 不一样。</p>
<h3 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h3><p>数据传送，算术和逻辑运算，移位操作，转移操作(JMP,CALL,RET<del>turn</del>,TRAP)，输入输出操作与外部IO交换数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708213502481.png" alt="image-20240708213502481"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708213509455.png" alt="image-20240708213509455"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708213516901.png" alt="image-20240708213516901"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708213527974.png" alt="image-20240708213527974"></p>
<h2 id="指令的寻址方式"><a href="#指令的寻址方式" class="headerlink" title="指令的寻址方式"></a>指令的寻址方式</h2><p>确定<u>本条指令的数据地址</u>和<u>下条待执行指令</u>的地址。</p>
<p>可以通过<strong>指令寻址</strong>，也可以通过<strong>数据寻址</strong>。 </p>
<p>操作码之后是<strong>寻址特征位</strong>，共采用的特征总和，分别编码表示即可。<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/20210515135546230.png" alt="20210515135546230"></p>
<p>指令中的地址码字段并不代表操作数的真实地址，这种地址称为 形式地址形式地址 (A)。形式地址结合寻址方式，可以计算出操作数在存储器中的真实地址，这种地址称为 有效地址有效地址 （EA)。</p>
<p>注意，(A)表示地址为A的数值，A既可以是寄存器编号，也可以是内存地址。对应的(A)就是寄存器中的数值，或相应内存单元的数值。例如，EA=(A)意思是有效地址是地址A中的数值。</p>
<h3 id="指令寻址方式"><a href="#指令寻址方式" class="headerlink" title="指令寻址方式"></a>指令寻址方式</h3><h4 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h4><p><strong>累加寄存器 ACC</strong>：它是一个同通用寄存器，其功能是：当 ALU 执行算术或逻辑运算时，为 ALU 提供一个工作区，ACC 暂时存放 ALU 运算的结果信息。显然，运算器中至少要有一个累加寄存器</p>
<p><span id = "jump4"><strong>PC</strong></span>寄存器用来存储<strong>指向下一条指令的地址</strong>，当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到指令寄存器IR中，此过程称为“取指令”。与此同时，PC中的地址或自动加1或由转移指针给出下一条指令的地址。此后经过分析指令，执行指令。完成第一条指令的执行，而后根据PC取出第二条指令的地址，如此循环，执行每一条指令。</p>
<p><span id="jump5">IR</span>用来保存<strong>当前正在执行的一条指令。</strong> 当执行一条指令时，先把它从内存取到数据寄存器（DR，Data Register）中，然后再传送至IR。</p>
<p>GR 通用寄存器可用于传送和暂存数据，也可参与算术逻辑运算，并保存运算结果。除此之外，它们还各自具有一些特殊功能。通用寄存器的长度取决于机器字长，汇编语言程序员必须熟悉每个寄存器的一般用途和特殊用途，只有这样，才能在程序中做到正确、合理地使用它们。</p>
<p>PC+ “1” -&gt; PC , 指令长度是4个字节，“1”就是4，指令长度是8个字节，“1”就是8，自动形成下一条指令的地址(这里是指指令的纵向长度) </p>
<h4 id="跳跃"><a href="#跳跃" class="headerlink" title="跳跃"></a>跳跃</h4><p> 通过转移类指令实现。所谓跳跃，是指下条指令的地址码不由程序计数器给出，而由本条指令给出下条指令地址的计算方式。注意，是否跳跃可能受到状态寄存器和操作数的控制，而跳跃到的地址分为绝对地址（由标记符直接得到)和相对地址（相对于当前指令地址的偏移量)，跳跃的结果是当前指令修改PC值，所以下一条指令仍然通过程序计数器（PC）给出。 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708200915099.png" alt="image-20240708200915099"></p>
<h3 id="数据寻址方式"><a href="#数据寻址方式" class="headerlink" title="数据寻址方式"></a>数据寻址方式</h3><p><strong>EA</strong>地址存放了操作数</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708201119571.png" alt="image-20240708201119571"></p>
<ol>
<li><p>立即寻址 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708201151183.png" alt="image-20240708201151183"></p>
<p>指令执行时间最短，但是A的位数限制了立即数的范围</p>
</li>
<li><p>直接寻址 EA=A </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708201407246.png" alt="image-20240708201407246"></p>
<p>A就是地址，A的范围决定了寻址范围。</p>
</li>
<li><p>隐含寻址 A是一个操作数的地址 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708201701155.png" alt="image-20240708201701155"></p>
<p>这里规定硬件ACC是第二操作数的地址，对于这种一地址指令，访存1次，零地址指令操作数是默认保存在一个寄存器中的。</p>
</li>
<li><p>间接寻址 指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即 EA =(A) 还可以通过多次简介寻址 EA=((A))</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708210033847.png" alt="image-20240708210033847"></p>
<p>主存字第一位为1时，表示取出的仍不是操作数的地址，即多次间址;主存字第一位为0时，表示取得的是操作数的地址。</p>
</li>
<li><p>寄存器寻址 EA=R<del>i</del> </p>
<p>指令字中给出操作数所在的寄存器编号R<del>i</del> ,操作数存在寄存器Ri内。</p>
<p>不用访存，速度快，但是价格昂贵，寄存器数量有限</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708211427010.png" alt="image-20240708211427010"></p>
</li>
<li><p>寄存器间接寻址 EA = (Ri)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708211440882.png" alt="image-20240708211440882"> 需要访问主存</p>
</li>
<li><p>相对寻址 EA = (PC)+A</p>
<p>A是相对于当前指令地址的地址，相对寻址的优点是操作数的地址不是固定的，它随PC值的变化而变化，且与指令地址之间总是相差一个固定值，因此便于程序浮动。相对寻址广泛应用于转移指令，比如JMP。 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708212522800.png" alt="image-20240708212522800"></p>
<p>执行一条指令就是读取(PC)然后PC+”1”，那么运用相对寻址的时候，取完这条指令就已经+”1”了，相对位移量是A，所以转移到的地址是(PC)+”1”+A</p>
</li>
<li><p>基址寻址 EA =(BR)+ A</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708215640792.png" alt="image-20240708215640792"></p>
<p>面向操作系统，由操作系统确定(BR), 一般是不可变的,A可变</p>
</li>
<li><p>变址寻址 EA = (IX)+A</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708215930568.png" alt="image-20240708215930568"></p>
<p>面向用户，(IX)可变，A不可变</p>
</li>
</ol>
<p>不需要访存的：</p>
<ul>
<li>立即寻址 （A就是操作数）</li>
<li>隐含寻址（操作数可以隐含保存在特定寄存器中）</li>
<li>寄存器寻址（操作数保存在寄存器中）</li>
</ul>
<p>需要访存2次：</p>
<ul>
<li>一次间接寻址（EA=(A) A先访存1次，然后根据(A)再访存1次）</li>
</ul>
<p>以上不包含为了取本条指令而做的访存</p>
<ol start="10">
<li>堆栈寻址</li>
</ol>
<blockquote>
<p>堆栈是存储器（或专用寄存器组）中一块特定的、按后进先出（LIFO）原则管理的存储区，该存储区中读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针(SP)。 堆栈堆栈 可分为 硬堆栈硬堆栈 与 软堆栈软堆栈 两种。</p>
</blockquote>
<blockquote>
<p>寄存器堆栈又称硬堆栈。寄存器堆栈的成本较高，不适合做大容量的堆栈;而从主存中划出一段区域来做堆栈是最合算且最常用的方法，这种堆栈称为软堆栈。</p>
</blockquote>
<blockquote>
<p>在采用堆栈结构的计算机系统中，大部分指令表面上都表现为无操作数指令的形式，因为操作数地址都隐含使用了SP。通常情况下，在读/写堆栈中的一个单元的前后都伴有自动完成对SP内容的增量或减量操作。</p>
</blockquote>
<p>Example</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708222527779.png" alt="image-20240708222527779"></p>
<p>1）寄存器-存储器（R-S）指令格式：操作码OPcode+寄存器位R+特征位+形式地址A</p>
<p>32个寄存器，编号需要5位，64种操作-&gt;操作码6位000000-111111，特征位由于只有直接或间接寻址，所以只要1位特征位即可，剩下即为形式地址。</p>
<p>OP(6)+R(5)+特征位(1)+A(20)</p>
<p>20位形式地址，最多直接寻址的空间为1M存储字，</p>
<p>如果是间接寻址就可以扩大寻址空间，最多到2^32^=4G字</p>
<p>2）通用寄存器，寻址方式多了一种基址方式，基址寄存器中的内容是特定不变的，OP(6)+R(5)+特征位(2)+A(19)？但是应该指明用哪一个通用寄存器作为基址寄存器</p>
<p>OP(6)+R(5)+特征位(2)+BR(5)+A(14)</p>
<p>通用寄存器有32位，所以使用基址寻址的最大寻址空间=2^32^=4G字，仅仅与基址位数有关 </p>
<h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708221826452.png" alt="image-20240708221826452"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708222151040.png" alt="image-20240708222151040"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708222202564.png" alt="image-20240708222202564"></p>
<h2 id="RISC"><a href="#RISC" class="headerlink" title="RISC"></a>RISC</h2><p><strong>R</strong>educed <strong>I</strong>nstruction <strong>S</strong>et <strong>C</strong>omputer 精简指令集计算机</p>
<p>与C<del>(omplex)</del>ISC相对</p>
<p>二八定律</p>
<p><strong>RISC:</strong> </p>
<ul>
<li>指令长度固定，指令格式种类少，寻址方式少；</li>
<li>只使用LOAD STORE访存，通用寄存器较多；</li>
<li>流水线技术，一个时钟周期内完成一条指令；</li>
<li>控制器运用组合逻辑。</li>
</ul>
<p><strong>CISC:</strong> </p>
<ul>
<li>指令庞杂，指令使用频度相差较大，长度不固定，种类多</li>
<li>很多指令可以访存</li>
<li>CPU有专用寄存器</li>
<li>大部分指令都需要多个时钟周期完成</li>
<li>采用微程序控制器</li>
</ul>
<p>值得注意的是，从指令系统兼容性看，CISC大多能实现软件兼容，即高档机包含了低档机的全部指令，并可加以扩充。但RISC简化了指令系统，指令条数少，格式也不同于老机器，因此大多数RISC机不能与老机器兼容。由于 RISC具有更强的实用性，因此应该是未来处理器的发展方向。但事实上，当今时代Intel 几乎一统江湖，且早期很多软件都是根据CISC 设计的，单纯的RISC将无法兼容。此外，现代CISC结构的CPU已经融合了很多RISC的成分，其性能差距已经越来越小。CISC可以提供更多的功能，这是程序设计所需要的。</p>
<p>RISC利用VLSI芯片的面积，便于设计，降低成本，提高可靠性，但是不容易实现指令系统的兼容</p>
<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><h2 id="CPU的结构"><a href="#CPU的结构" class="headerlink" title="CPU的结构"></a>CPU的结构</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708235618670.png" alt="image-20240708235618670"></p>
<p>指令控制 PC IR </p>
<p>操作控制、时间控制 CU 时序电路</p>
<p>数据加工 ALU (运算器) + 寄存器</p>
<p>中断处理 中断系统</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240708235920709.png" alt="image-20240708235920709"></p>
<h3 id="CPU的寄存器"><a href="#CPU的寄存器" class="headerlink" title="CPU的寄存器"></a>CPU的寄存器</h3><h4 id="用户可见寄存器"><a href="#用户可见寄存器" class="headerlink" title="用户可见寄存器"></a>用户可见寄存器</h4><p>通用寄存器 <strong>G</strong>eneral <strong>R</strong>egister</p>
<ul>
<li>存放操作数</li>
<li>作为某种寻址方式所需要的专用寄存器</li>
</ul>
<p>数据寄存器 <strong>D</strong>ata <strong>R</strong>egister</p>
<ul>
<li>存放多种操作数（多种数据类型）</li>
<li>两个寄存器拼接存放双倍字长的数据[ACC和MQ]</li>
</ul>
<p>地址寄存器</p>
<ul>
<li>存放地址，位数满足最大的地址的范围，用于特殊的寻址方式，段基值，栈指针</li>
</ul>
<p>条件码寄存器 </p>
<ul>
<li>存放条件码，作为程序分支的依据，入如正负零，溢出，进位</li>
</ul>
<h4 id="控制和状态寄存器"><a href="#控制和状态寄存器" class="headerlink" title="控制和状态寄存器"></a>控制和状态寄存器</h4><p>控制寄存器</p>
<ul>
<li><a href="#jump4">PC</a>-&gt;<strong>MAR</strong>-&gt;M-&gt;<strong>MDR</strong>-&gt;<strong><a href="#jump5">IR</a></strong> 加粗为用户不可见，PC用户可以读到</li>
<li>MAR用于存储地址</li>
<li>MDR用于暂存数据</li>
</ul>
<p>状态寄存器</p>
<ul>
<li>存放条件码</li>
<li>PSW 存放程序状态字，中断服务程序或者子程序，为了保存运行现场和断点。</li>
</ul>
<h4 id="控制单元CU和中断系统"><a href="#控制单元CU和中断系统" class="headerlink" title="控制单元CU和中断系统"></a>控制单元CU和中断系统</h4><p><a href="#jump2">CU</a></p>
<ul>
<li>产生全部指令的微操作命令序列</li>
<li>组合逻辑(RISC) 硬连线逻辑</li>
<li>微程序设计 存储逻辑</li>
</ul>
<p><a href="#jump3">中断系统</a></p>
<h4 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a><a href="#jump">ALU</a></h4><h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><ul>
<li>指令周期=取址周期</li>
<li>指令周期=取址周期+执行周期(等长)</li>
<li>指令周期=取址周期+执行周期(长一些)</li>
<li>间接寻址的指令周期=取址周期+<u>间址周期</u>+执行周期</li>
<li>中断周期的指令周期=取址周期+<u>间址周期</u>+执行周期+中断周期</li>
</ul>
<p>流程：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709132917427.png" alt="image-20240709132917427"></p>
<p>CPU访存有4种性质</p>
<ul>
<li>取 指令         取指周期</li>
<li>取 地址         间址周期</li>
<li>存取 操作数  执行周期</li>
<li>存 程序断点  中断周期</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709134249611.png" alt="image-20240709134249611"></p>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><h4 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h4><p>PC寄存器存的是下一条指令的地址，CU通过控制总线，控制地址通过MAR传到地址总线，（读命令）地址总线传到存储器，控制存储器将对应的数据（指令）通过数据总线传到MDR，最后保存到CPU的IR寄存器中。CU控制PC寄存器的值+“1” </p>
<h4 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h4><p>假设取完指令以后将形式地址A保存到了MDR，此时A的值传给MAR，通过地址总线传给存储器，CU控制总线让存储器取出A中保存的数据(A)也就是EA，EA保存到MDR，操作数的真实地址EA最后保存到了IR的地址码部分</p>
<h4 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h4><h4 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709151019317.png" alt="image-20240709151019317"></p>
<p>保存断点，形成中断服务程序的入口地址（中断向量），硬件关中断</p>
<p>保存程序<strong>断点</strong>，CU来确定将程序断点保存到内存的哪个地址，传给MAR，存储器，CU再控制总线操控存储器进行写入断点的操作，由于响应中断一定是在执行完一条指令之后，所以下一条指令还没有取到，下一条指令的地址就是(PC)，将PC存储的值送到MDR，再通过数据总线写入存储器。</p>
<p>形成中断服务程序的<strong>入口地址</strong>：CU给出送到PC</p>
<p>(关中断)</p>
<h3 id="指令流水"><a href="#指令流水" class="headerlink" title="指令流水"></a>指令流水</h3><h4 id="提高机器速度？"><a href="#提高机器速度？" class="headerlink" title="提高机器速度？"></a>提高机器速度？</h4><p>提高访存速度：Cache 多体并行</p>
<p>提高IO和主机的传送速度：</p>
<ul>
<li>中断，部分时间并行</li>
<li>DMA，几乎全部并行</li>
<li>通道，I/O处理机</li>
<li>多总线</li>
</ul>
<p>提高运算速度：</p>
<ul>
<li>高速芯片，改进算法，快速进位链</li>
</ul>
<p>提高并行性</p>
<h4 id="系统并行"><a href="#系统并行" class="headerlink" title="系统并行"></a>系统并行</h4><p>并行：并发 / 同时。多个事件在同一时间段或同一时刻，并行发生</p>
<p>并行性的等级：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709152238952.png" alt="image-20240709152238952"></p>
<h4 id="指令流水原理"><a href="#指令流水原理" class="headerlink" title="指令流水原理"></a>指令流水原理</h4><p>CU中取指和执行部件完全独立的两个部件。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709153256508.png" alt="image-20240709153256508"></p>
<p>二级流水，执行的时候同时取第二条指令</p>
<p><strong>影响因素：</strong></p>
<p>取指时间快的话，指令2的执行就要空等。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709153630873.png" alt="image-20240709153630873"></p>
<p>“分支预测” 猜测？</p>
<p><strong>六级流水</strong></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709153945994.png" alt="image-20240709153945994"></p>
<h4 id="影响性能因素"><a href="#影响性能因素" class="headerlink" title="影响性能因素"></a>影响性能因素</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709154501154.png" alt="image-20240709154501154"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709155432711.png" alt="image-20240709155432711"></p>
<p>WAW R3不知道是谁写入的</p>
<p>解决办法 后推、旁路技术</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709160540537.png" alt="image-20240709160540537"></p>
<p>EX阶段就已经给出了结果值，不必待某条指令的执行结果送回到寄存器后，再从寄存器中取出结果。作为下一条指令的源操 作数，而是直接将执行结果送到其他指令所需要的地方</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709160922557.png" alt="image-20240709160922557"></p>
<p>转移指令直到EI结束才知道是否要转移</p>
<h3 id="流水线多发"><a href="#流水线多发" class="headerlink" title="流水线多发"></a>流水线多发</h3><p>一条流水线实现了时间并行性</p>
<p>多条流水线还能体现空间并行性</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709161132636.png" alt="image-20240709161132636"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709161651786.png" alt="image-20240709161651786"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709161912171.png" alt="image-20240709161912171"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709174419116.png" alt="image-20240709174419116"></p>
<h3 id="流水线结构"><a href="#流水线结构" class="headerlink" title="流水线结构"></a>流水线结构</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709162228545.png" alt="image-20240709162228545"></p>
<p>运算过程比较复杂的可以使用运算流水线</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709162356672.png" alt="image-20240709162356672"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709163719074.png" alt="image-20240709163719074"></p>
<p>一个任务分割为多个子任务，原则上要求时间上等分，子任务由不同的部件完成，如果不等分，指令1执行过程中取到了指令2，但是指令2必须等到1执行完才开始执行，这就造成了任务的空窗期，造成了时间的浪费</p>
<h2 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统 "></a><span id= "jump3">中断系统 </span></h2><h3 id="引起中断的因素"><a href="#引起中断的因素" class="headerlink" title="引起中断的因素"></a>引起中断的因素</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709165141178.png" alt="image-20240709165141178"></p>
<h4 id="中断系统解决的问题"><a href="#中断系统解决的问题" class="headerlink" title="中断系统解决的问题"></a>中断系统解决的问题</h4><h5 id="中断请求处理"><a href="#中断请求处理" class="headerlink" title="中断请求处理"></a>中断请求处理</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709165435315.png" alt="image-20240709165435315"></p>
<h5 id="中断判优逻辑"><a href="#中断判优逻辑" class="headerlink" title="中断判优逻辑"></a>中断判优逻辑</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709165718469.png" alt="image-20240709165718469"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709165806996.png" alt="image-20240709165806996"></p>
<h4 id="中断服务程序入口地址"><a href="#中断服务程序入口地址" class="headerlink" title="中断服务程序入口地址"></a>中断服务程序入口地址</h4><p>硬件向量法，速度快，但不灵活</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709165927865.png" alt="image-20240709165927865"></p>
<p>软件查询法，使用中断识别程序</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709170616972.png" alt="image-20240709170616972"></p>
<h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><h5 id="响应条件"><a href="#响应条件" class="headerlink" title="响应条件"></a>响应条件</h5><ul>
<li>允许中断触发器 EINT=1</li>
<li>一条指令执行结束时由CPU发查询信号</li>
</ul>
<h5 id="中断隐指令-硬件实现，并不在指令集中"><a href="#中断隐指令-硬件实现，并不在指令集中" class="headerlink" title="中断隐指令(硬件实现，并不在指令集中)"></a>中断隐指令(硬件实现，并不在指令集中)</h5><ul>
<li><p>保护程序断点</p>
<ul>
<li>断点保存到特定地址</li>
<li>断点进栈</li>
</ul>
</li>
<li><p>寻找服务程序入口地址</p>
<ul>
<li>硬件向量</li>
<li>中断识别程序M-&gt;PC 软件</li>
</ul>
</li>
<li><p>关中断 EINT = 0</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709171350563.png" alt="image-20240709171350563"></p>
</li>
</ul>
<h4 id="保护、恢复现场"><a href="#保护、恢复现场" class="headerlink" title="保护、恢复现场"></a>保护、恢复现场</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709171616344.png" alt="image-20240709171616344"></p>
<h4 id="多重中断"><a href="#多重中断" class="headerlink" title="多重中断"></a>多重中断</h4><ul>
<li><p>提前设置 开中断 指令</p>
</li>
<li><p>优先级高可以打断优先级低的处理程序</p>
</li>
</ul>
<h5 id="中断屏蔽技术"><a href="#中断屏蔽技术" class="headerlink" title="中断屏蔽技术"></a>中断屏蔽技术</h5><p><strong>MASK 触发器</strong> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709172308296.png" alt="image-20240709172308296"></p>
<p>屏蔽字<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709172343892.png" alt="image-20240709172343892"></p>
<p><u>响应</u>优先级不可以改变，<u>处理</u>优先级可以改变<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709172459205.png" alt="image-20240709172459205"></p>
<p>中断源响应之后会设置各个中断源的屏蔽字MASK[]</p>
<p><strong>应用</strong>：可以人为屏蔽某个中断源</p>
<p><strong>设置新屏蔽字</strong>：保护现场之后，置屏蔽字，然后开中断（为了实现多重中断），进行中断服务，恢复现场和恢复屏蔽字之前要关中断，确保正确恢复，最后开中断，中断返回</p>
<h5 id="断点保护"><a href="#断点保护" class="headerlink" title="断点保护"></a>断点保护</h5><ul>
<li><p>断点进栈</p>
</li>
<li><p>断点存入“0”地址</p>
<ul>
<li><p>CU将“0”地址写入MAR，准备写操作，PC的值写入MDR然后再进入存储器</p>
<p>出现了断点覆盖的问题</p>
</li>
</ul>
</li>
</ul>
<p>保护断点的做法，不同的服务程序将断点保存到不同的地址<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709173920685.png" alt="image-20240709173920685"></p>
<p>STA(Store Accmulator) SAVE 将ACC原来的值保存到SAVE中</p>
<p>LDA(Load Accumulator) 0将0地址的内容(程序断点)保存到ACC</p>
<p>STA RETURN 将0地址保存到RETURN中</p>
<p>JMP @ RETURN 无条件跳转到RETURN保存的地址</p>
<p>每个SERVE程序 都有不同的RETURN 把0地址的内容转存到各自的RETURN即可</p>
<h1 id="控制单元-CU"><a href="#控制单元-CU" class="headerlink" title="控制单元 CU"></a><span id="jump2">控制单元 CU</span></h1><h2 id="微操作命令分析"><a href="#微操作命令分析" class="headerlink" title="微操作命令分析"></a>微操作命令分析</h2><p>解释指令的过程中，CU发出的操作就叫微操作，比如加法指令，还能继续往下细分。</p>
<p>完成一条指令：取指，间址，执行，中断4个周期</p>
<h5 id="取指周期-1"><a href="#取指周期-1" class="headerlink" title="取指周期"></a><strong>取指周期</strong></h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709180027699.png" alt="image-20240709180027699"></p>
<h5 id="间址周期-1"><a href="#间址周期-1" class="headerlink" title="间址周期"></a><strong>间址周期</strong></h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709180154460.png" alt="image-20240709180154460"></p>
<h5 id="执行周期-1"><a href="#执行周期-1" class="headerlink" title="执行周期"></a><strong>执行周期</strong></h5><p><strong>非访存指令</strong>(取指+执行)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709180420712.png" alt="image-20240709180420712"></p>
<p><strong>访存指令</strong>(取指+执行)/(取指+间址+执行)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709180826769.png" alt="image-20240709180826769"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709180927583.png" alt="image-20240709180927583"></p>
<p><strong>转移指令</strong>(取指+执行)</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709180948619.png" alt="image-20240709180948619"></p>
<p><strong>间接转移</strong>(取指+间址+执行)</p>
<h4 id="中断周期-1"><a href="#中断周期-1" class="headerlink" title="中断周期"></a>中断周期</h4><p>0地址：</p>
<ul>
<li>0地址保存到MAR</li>
<li>1-&gt;W 写</li>
<li>PC -&gt; MDR</li>
<li>MDR-&gt;M(MAR)</li>
<li>向量地址-&gt;PC  /  中断识别程序 M-&gt;PC</li>
<li>0-&gt;EINT</li>
</ul>
<p>断点进栈：</p>
<ul>
<li><p>(SP)-1-&gt;MAR</p>
</li>
<li><p>1-&gt;W 写</p>
</li>
<li><p>PC -&gt; MDR</p>
</li>
<li><p>MDR-&gt;M(MAR)</p>
</li>
<li><p>向量地址-&gt;PC  /  中断识别程序 M-&gt;PC</p>
</li>
<li><p>0-&gt;EINT</p>
</li>
</ul>
<h2 id="控制单元"><a href="#控制单元" class="headerlink" title="控制单元"></a>控制单元</h2><p>发出各种微指令</p>
<h3 id="外特性"><a href="#外特性" class="headerlink" title="外特性"></a>外特性</h3><h4 id="输入信号"><a href="#输入信号" class="headerlink" title="输入信号"></a>输入信号</h4><ol>
<li>时钟 受到clk控制</li>
<li>指令寄存器 控制信号和OPcode有关 用于译码</li>
<li>标志 受标志控制，上一条指令运行结果的标志，能够让CU决定这次运行是否跳转</li>
<li>外来信号 INTR 中断请求、HRQ总线请求</li>
</ol>
<h4 id="输出信号"><a href="#输出信号" class="headerlink" title="输出信号"></a>输出信号</h4><ol>
<li>CPU内的控制信号<ol>
<li>Ri-&gt;Rj</li>
<li>PC+1 -&gt; PC</li>
<li>ALU进行什么运算</li>
</ol>
</li>
<li>送到控制总线的信号<ol>
<li>访存控制信号$\overline{MREQ}$</li>
<li>访IO/存储器控制信号$\overline{IO}/M$</li>
<li>读写命令$\overline{RD}$ $\overline{WR}$</li>
<li>中断响应 INTA</li>
<li>总线响应 HLDA</li>
</ol>
</li>
</ol>
<h3 id="控制信号"><a href="#控制信号" class="headerlink" title="控制信号"></a>控制信号</h3><h4 id="不采用总线"><a href="#不采用总线" class="headerlink" title="不采用总线"></a>不采用总线</h4><p>C0-C8均为门电路的控制</p>
<p>ADD @X</p>
<p>C0: 将PC存储的地址送到MAR</p>
<p>C1: 将MAR的内容送到地址线，发出读命令</p>
<p>C2: 将存储器发回的数据存到MDR</p>
<p>C3: 将MDR保存的指令传到IR</p>
<p>C4: 将IR的操作码部分OP(IR)传到CU,进行译码  取到指令之后寻址特征位发挥作用，如果让IND触发器置1，那么就变成要进入间址周期</p>
<p>C5: 将MDR中保存的形式地址A传到MAR Ad(IR)-&gt; MAR</p>
<p>C1 C2 执行完之后MDR中保存了EA</p>
<p>C3 : EA-&gt;OP(IR)</p>
<p>C5: MDR中地址EA传到MAR</p>
<p>C1 C2 执行完之后MDR中保存了数据X</p>
<p>C6C7: 两个操作数x和acc分别送到ALU中，ALU再接收来自CU的加法信号</p>
<p>C8: ALU的运算结果保存到ACC中</p>
<h4 id="采用总线"><a href="#采用总线" class="headerlink" title="采用总线"></a>采用总线</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709202341142.png" alt="image-20240709202341142"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709203641379.png" alt="image-20240709203641379"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709203902002.png" alt="image-20240709203902002"></p>
<h3 id="多级时序系统"><a href="#多级时序系统" class="headerlink" title="多级时序系统"></a>多级时序系统</h3><h4 id="机器周期"><a href="#机器周期" class="headerlink" title="机器周期"></a>机器周期</h4><p>定义：所有指令执行过程的一个基准时间</p>
<p>因素：指令的执行<strong>步骤</strong>，步骤花费的<strong>时间</strong></p>
<p>基准：以完成<strong>最复杂</strong>指令功能的时间为准，以<strong>访问一次存储器</strong>的时间为基准</p>
<p>指令字长=存储字长 -&gt; 取指周期=机器周期</p>
<h4 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h4><p>一个机器周期完成若干微操作，等分为若干个时钟周期，一个时钟周期能够产生一个或多个(并行)的微操作。最小的时间单位</p>
<h4 id="多级时序"><a href="#多级时序" class="headerlink" title="多级时序"></a>多级时序</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709204627725.png" alt="image-20240709204627725"></p>
<h4 id="主频和速度的关系"><a href="#主频和速度的关系" class="headerlink" title="主频和速度的关系"></a>主频和速度的关系</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709204732300.png" alt="image-20240709204732300"></p>
<p>流水线同样能加快速度</p>
<h3 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h3><p>产生微操作命令序列的时序控制方式</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709204902523.png" alt="image-20240709204902523"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709204952863.png" alt="image-20240709204952863"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709205235679.png" alt="image-20240709205235679"></p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><h4 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h4><p>用复杂的组合逻辑门电路和一些触发器构成</p>
<p>在列出微操作时间表后，综合分析之后，可以将微操作信号的逻辑表达式写出来，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709211508947.png" alt="image-20240709211508947"></p>
<h4 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h4><p>微操作是计算机中最小的不可再分的操作，微命令作为微操作的控制信号，微命令之间有相容和相斥两种关系，微命令组成微指令，微指令组成微程序，一条机器指令转化成一个微程序并存入一个专门的存储器，微程序控制器通过取微程序存储器中的微指令并执行</p>
<p>微指令编码方式：直接编码、字段直接编码、字段间接编码</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240709232334388.png" alt="image-20240709232334388"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/20/designing-pattern-singleton/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/20/designing-pattern-singleton/" class="post-title-link" itemprop="url">单例模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-20T00:00:00+08:00">2024-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 13:10:52" itemprop="dateModified" datetime="2025-04-27T13:10:52+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h1><h2 id="饿汉"><a href="#饿汉" class="headerlink" title="饿汉"></a>饿汉</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;<span class="keyword">return</span> instance;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程安全，但是可能造成资源的浪费</p>
<h2 id="懒汉-双重校验锁-DCL"><a href="#懒汉-双重校验锁-DCL" class="headerlink" title="懒汉 双重校验锁 DCL"></a><u><strong>懒汉 双重校验锁 DCL</strong></u></h2><ol>
<li>懒汉（延迟初始化） 要素：无参构造私有，进行判断<strong>「线程不安全」</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>原来的实现容易出现线程安全问题，改进：<code>getInstance()</code>变成 <code>synchronized</code> 方法。<ul>
<li><p><strong>锁范围太大</strong>：性能差，同步开销大。正常的执行路径不需要同步，只需要在创建实例的时候进行锁定即可。</p>
<ul>
<li><p>锁对象的选择：<strong>两个不相关的方法不要使用同一把锁</strong>。<strong>并且要注意不能出现死锁互相等待</strong>。</p>
</li>
<li><p>class：适用于保护静态变量或者类级别的共享资源，如果是为了保护某个对象的状态，就应该使用this。</p>
</li>
<li><p>this可能的问题：这边在内部使用this调用task.dosth()，另一边一个完全无关的业务使用 task做锁。</p>
</li>
<li><p>死锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Friend</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Friend</span><span class="params">(String name)</span> &#123;<span class="built_in">this</span>.name = name;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bow</span><span class="params">(Friend other)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; 正在向 &quot;</span> + other.name + <span class="string">&quot; 鞠躬&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟执行延迟</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            other.bowBack(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bowBack</span><span class="params">(Friend other)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; 正在回礼 &quot;</span> + other.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 死锁：a和b同时向对方bow，先都锁住了自己，bowBack的时候就会造成互相等待</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>未二次判空</strong>：线程 A 通过了条件判断，获取了锁，开始创建实例，就在同时，线程B也通过判断等待锁释放，在线程 A 出来之后线程B又进去创建了一次。</p>
</li>
<li><p><strong>指令重排序</strong>：Java 允许指令重排序，创建对象可以分为 1. 分配内存地址 2. 在这块内存地址创建对象 3. 将 对象的引用 instance 指向这块地址。如果2 3的顺序颠倒，线程 A 进去之后在完全创建对象之前就将 instance 置为 非null，线程B就会以为别人已经创建好了，直接返回 instance 引用，线程B拿到以后就开始使用，其中就会随机发生空指针或者状态异常等其他难以复现调试的bug。引入 volatile，表示这个变量不允许指令重排，且线程对它的写入会立刻对其他线程可见。避免发生拿到错误对象的情况</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance; <span class="comment">// 1. 禁止指令重排序</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton.class)&#123;<span class="comment">// 2. 锁的范围缩小</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;<span class="comment">// 3. 二次判空</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适用场景：</p>
<ul>
<li><strong>单例模式</strong>：延迟初始化全局唯一的对象。</li>
<li><strong>高并发资源初始化</strong>：如数据库连接池、线程池等。</li>
<li><strong>框架中的扩展点加载</strong>：如 Dubbo 的 <code>ExtensionLoader</code> 按需加载扩展类。</li>
</ul>
<h2 id="双重校验锁-与类解耦"><a href="#双重校验锁-与类解耦" class="headerlink" title="双重校验锁 (与类解耦)"></a><u>双重校验锁 (与类解耦)</u></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> T instance;</span><br><span class="line">    <span class="keyword">private</span> Supplier&lt;T&gt; supplier;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Holder</span><span class="params">(Supplier&lt;T&gt; supplier)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.supplier = supplier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = supplier.get();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变种</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> T instance;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span>&#123;</span><br><span class="line">        instance = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">// 在外部实现</span></span><br></pre></td></tr></table></figure>



<h2 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举 enum"></a><u><strong>枚举 enum</strong></u></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>天然线程安全，并且能够防止反射攻击</p>
<h2 id="Holder-静态内部类-（利用类加载机制）"><a href="#Holder-静态内部类-（利用类加载机制）" class="headerlink" title="Holder 静态内部类 （利用类加载机制）"></a><u><strong>Holder 静态内部类 （利用类加载机制）</strong></u></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Holder 在 Singleton 加载时并不会被加载，只有第一次调用 <code>getInstance()</code> 才会加载 Holder，然后创建单例。</p>
<h2 id="CAS-自旋"><a href="#CAS-自旋" class="headerlink" title="CAS 自旋"></a>CAS 自旋</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReference&lt;Singleton&gt; instance = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Singleton</span> <span class="variable">current</span> <span class="operator">=</span> instance.get();</span><br><span class="line">            <span class="keyword">if</span> (current != <span class="literal">null</span>) <span class="keyword">return</span> current;</span><br><span class="line">            current = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">if</span> (instance.compareAndSet(<span class="literal">null</span>, current)) &#123; <span class="comment">// 期望值为 null，设置值为 current</span></span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>无锁，非阻塞，线程安全。实现较为复杂，追求极致性能才考虑</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/18/408-%E8%AE%A1%E7%BB%84-PC%20IO%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/18/408-%E8%AE%A1%E7%BB%84-PC%20IO%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">PC IO 结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-18 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-18T00:00:00+08:00">2024-09-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 12:44:01" itemprop="dateModified" datetime="2025-05-05T12:44:01+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">计组</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Prototypical-Architecture"><a href="#Prototypical-Architecture" class="headerlink" title="Prototypical Architecture"></a>Prototypical Architecture</h1><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241216183418923-1734346411610-1.png" alt="image-20241216183418923"></p>
<p>CPU通过专用的内存总线连接到内存，通过通用I/O总线(如PCI)连接到显卡等高性能设备，通过外围总线连接到低速的设备(USB Flash, 磁盘驱动器 )，因为光速的限制以及各种物理因素，越快的总线越短，造价也贵，因此离CPU越远的设备性能越低。</p>
<h1 id="Modern-Architecture"><a href="#Modern-Architecture" class="headerlink" title="Modern Architecture"></a>Modern Architecture</h1><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20241216185046235.png" alt="image-20241216185046235"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1024px-Motherboard_diagram.svg-1734348489593-5.png" alt="undefined"></p>
<p>在现代系统架构中，有更多的点对点连接到 CPU，PCIe 显卡总线和内存专用总线速度相近，以提供更高的显示性能，CPU通过 <strong>DMI</strong> 连接到一颗 I/O 芯片，所有其他外设通过各种总线连接到这颗I/O芯片。</p>
<h2 id="CPU-Socket"><a href="#CPU-Socket" class="headerlink" title="CPU Socket"></a>CPU Socket</h2><ul>
<li>用于安装中央处理器 (CPU)。</li>
<li>支持不同接口类型（如 LGA、PGA 或 BGA）。</li>
<li>插槽周围有供电模块（VRM）提供稳定电压。</li>
</ul>
<p>不同CPU系列使用不同插槽。后期CPU插槽，数字多数与针脚数量相同：</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LGA_1155">LGA 1155</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LGA_1366">LGA 1366</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LGA_2066">LGA 2066</a>  <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LGA_1700">LGA 1700</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Socket_AM4">Socket AM4</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Socket_TR4">Socket TR4</a> </p>
<h2 id="Chipset"><a href="#Chipset" class="headerlink" title="Chipset"></a>Chipset</h2><p>管理数据传输和硬件通信，负责连接 CPU、内存、显卡、存储等设备</p>
<p><strong>芯片组</strong>(Chipset)负责将电脑的处理器和和其它部分连接，以便能互传数据。芯片组在它所诞生的1980年代时是由多颗微芯片组成的，但是随着科技的进步，芯片组先是从2000年代开始简化为南桥和北桥两颗芯片，再于2010年代简化为单独一颗的南桥芯片，北桥芯片内置在CPU中，目前世界上的芯片组均以单南桥芯片为主流。  </p>
<ul>
<li><strong>南桥</strong>(Southbridge): 主要处理低速信号，后来演变成 ICH-&gt;PCH</li>
<li><strong>北桥</strong>(Northbridge): 主要处理高速信号，同时也负责与南桥的通信，IOH-&gt;MCH，集成进CPU</li>
<li><strong>DMI</strong>：连接南北桥的串行总线</li>
<li><strong>FSB</strong>：前端总线，负责 CPU 和北桥的数据传递。现在的x86 CPU 内部整合了<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%A8%98%E6%86%B6%E9%AB%94%E6%8E%A7%E5%88%B6%E5%99%A8&action=edit&redlink=1">北桥</a>。FSB 已被Intel <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/QPI">QPI</a>和AMD <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HyperTransport">HyperTransport</a>取代</li>
</ul>
<h3 id="Memory-Controller-Hub-Northbridge"><a href="#Memory-Controller-Hub-Northbridge" class="headerlink" title="Memory Controller Hub (Northbridge)"></a>Memory Controller Hub (Northbridge)</h3><p>随着技术发展，原来的北桥芯片已直接整合到 <strong>CPU 内部</strong>，减少延迟并提升效率：</p>
<table>
<thead>
<tr>
<th>控制器名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Memory Controller</strong></td>
<td>控制内存访问和管理，负责与 RAM 通信。</td>
</tr>
<tr>
<td><strong>Integrated Graphics Controller</strong></td>
<td>提供基本图形渲染能力，支持视频输出，无需独立显卡。</td>
</tr>
<tr>
<td><strong>PCIe Controller (部分 CPU)</strong></td>
<td>高端 CPU 内部集成部分 PCIe 通道，用于高性能设备的直接通信。</td>
</tr>
<tr>
<td><strong>Power Management Controller</strong></td>
<td>管理电源状态和功耗调节，提高能效。</td>
</tr>
</tbody></table>
<h4 id="Memory-Slots"><a href="#Memory-Slots" class="headerlink" title="Memory Slots"></a>Memory Slots</h4><ul>
<li>用于安装内存模块（RAM）。</li>
<li>常见类型：DDR3、DDR4、DDR5 等。</li>
<li>多通道技术（如双通道、四通道）提高内存带宽。</li>
</ul>
<h5 id="Volatile-Memory-RAM"><a href="#Volatile-Memory-RAM" class="headerlink" title="Volatile Memory (RAM)"></a>Volatile Memory (RAM)</h5><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8F%AE%E7%99%BC%E6%80%A7%E8%A8%98%E6%86%B6%E9%AB%94">易失性存储器</a>(Volatile Memory): 电流中断后，所存储的数据便会消失，一般为 <strong>RAM</strong></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%9C%E6%85%8B%E9%9A%A8%E6%A9%9F%E5%AD%98%E5%8F%96%E8%A8%98%E6%86%B6%E9%AB%94">静态随机存储器</a>(<strong>SRAM</strong>, Static RAM): 把信息存储在锁存器中，只要保持通电，存储的数据就可以一直保持，存储密度较低，速度高，功耗低，内部结构也更为复杂。通常作为<strong>cache</strong>(L1, L2, L3)、<strong>寄存器</strong>或 FPGA ASIC 等专用设备的存储器。</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8">动态随机存储器</a>(<strong>DRAM</strong>, Dynamic RAM): 根据电容中的电荷多寡来分辨0和1，电容会漏电，不仅要保持通电，还需周期性充电。由于这种需要定时刷新的特性，因此被称为“动态”存储器。存储密度高，速度较低，功耗高，但是成本比 SRAM 低，通常作为 主存 使用，用于存储运行中的程序和数据；也用于 显存。<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SDRAM">同步 DRAM</a>(<strong>SDRAM</strong>, Synchronous DRAM): 在 DRAM 的架构基础上增加同步和双区域（Dual Bank）的功能，使得<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E8%99%95%E7%90%86%E5%99%A8">微处理器</a>能与 SDRAM 的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%99%82%E8%84%88">时钟</a>同步，所以 SDRAM 执行命令和传输资料时相较于 DRAM 可以节省更多时间。</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DDR_SDRAM">双倍数据率 SDRAM</a>(DDR SDRAM, Double Data Rate): DDR SDRAM 在系统时钟的上升沿和下降沿都可以进行数据传输，发展到 DDR5，数据传输率、总线频率逐渐提高<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A7%BB%E5%8A%A8DDR">低功耗 DDR</a>(<strong>LPDDR</strong>, Low Power DDR): 专门用于移动设备，发展到 LPDDR5X</li>
<li>图形 DDR(<strong>GDDR</strong>, Graphics DDR): 为高性能显卡提供显存支持，发展到 GDDR7</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%A0%BB%E5%AF%AC%E8%A8%98%E6%86%B6%E9%AB%94">高带宽内存</a>(HBM, High Bandwidth Memory): 基于3D堆栈工艺的高性能 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DRAM">DRAM</a> 适用于高存储器带宽需求的应用场合，与高性能<strong>显卡</strong>、路由器、交换机、高性能数据中心的AI ASIC结合使用，在 CPU 和 FPGA 中用作包内 RAM 和 Cache</li>
</ul>
</li>
</ol>
<h4 id="PCIe"><a href="#PCIe" class="headerlink" title="PCIe"></a>PCIe</h4><p>北桥负责高速传输，因此显卡这种高速设备也需要通过PCIe和北桥(CPU)相连，详见下方PCIe x16</p>
<h3 id="I-O-Controller-Hub-Southbridge"><a href="#I-O-Controller-Hub-Southbridge" class="headerlink" title="I/O Controller Hub (Southbridge)"></a>I/O Controller Hub (Southbridge)</h3><table>
<thead>
<tr>
<th>控制器名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Disk Controller</strong></td>
<td>控制 SATA、SAS 等存储设备的数据传输。</td>
</tr>
<tr>
<td><strong>USB Controller</strong></td>
<td>控制 USB 2.0、3.0、3.1、Type-C 等接口的数据传输。</td>
</tr>
<tr>
<td><strong>PCIe Controller</strong></td>
<td>管理 PCI Express 插槽的通信，用于扩展显卡、网卡等设备。</td>
</tr>
<tr>
<td><strong>Ethernet Controller</strong></td>
<td>控制有线网络通信，通常内置支持千兆或 2.5G 网卡。</td>
</tr>
<tr>
<td><strong>Audio Controller</strong></td>
<td>提供板载音频功能，支持麦克风、扬声器等外设连接。</td>
</tr>
<tr>
<td><strong>SATA Controller</strong></td>
<td>控制 SATA 硬盘和光驱设备的数据传输。</td>
</tr>
<tr>
<td><strong>RAID Controller</strong></td>
<td>支持磁盘阵列（RAID）的数据管理，提高存储性能和安全性。</td>
</tr>
<tr>
<td><strong>Wireless Controller</strong></td>
<td>控制 Wi-Fi 和蓝牙模块的无线通信功能（部分主板内置）。</td>
</tr>
<tr>
<td><strong>Security Controller (TPM)</strong></td>
<td>提供可信平台模块 (TPM) 功能，保障数据安全性和加密管理。</td>
</tr>
</tbody></table>
<h4 id="Storage-Interface-SATA-SAS"><a href="#Storage-Interface-SATA-SAS" class="headerlink" title="Storage Interface (SATA/SAS)"></a>Storage Interface (SATA/SAS)</h4><ul>
<li><strong>IDE</strong>(Integrated Device Electronics): IDE 是一项企图把控制器与盘体集成在一起为主要意图的硬盘接口技术。</li>
<li><strong>ATA</strong>(Advanced Technology Attachment): ATA 技术是一个关于 IDE 的技术规范族，全球标准化协议将 IDE 接口技术自诞生以来使用的技术规范归纳成为全球硬盘标准。<ul>
<li><strong>并行接口 ATA</strong>(Parallel ATA)的电缆属性、连接器和信号协议都表现出了很大的技术瓶颈，而在技术上突破这些瓶颈存在相当大的难度</li>
</ul>
</li>
<li>==<strong>SATA</strong>==(Serial ATA): 并行的 PATA 存在固有的瓶颈——并行信号串扰与同步问题，因此改成了<strong>串行</strong>总线。SATA 既是一种<strong>物理接口</strong>（硬件层连接方式），也是一种<strong>逻辑接口</strong>协议（定义数据通信规则）最初是为传统机械硬盘（HDD）设计的，后来也应用于部分 SSD<ul>
<li><strong>eSATA</strong>(External SATA): 外置 SATA 接口，方便外设的连接，eSATA 不像 USB 那样能同时传输数据和供电，因此需要额外的电源线为外部设备供电，属于物理接口协议。</li>
<li><strong>mSATA</strong>(mini-SATA): 迷你版本SATA接口，外型和电子接口与mini PCI-E完全相同，但电子信号不同，两者互不兼容。多用于固态硬盘，适用于需要尺寸较小的存储器的场合</li>
<li><strong>AHCI</strong>(Advanced Host Controller Interface): 允许软件与 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SATA">SATA</a> 存储设备沟通的硬件机制，激活 SATA 的高级功能，属于逻辑接口协议。AHCI 系统的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E6%9C%BA%E9%80%82%E9%85%8D%E5%99%A8">主机适配器</a>将CPU/存储器子系统与相对慢得多的、基于旋转<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A3%81%E5%84%B2%E5%AD%98">磁性介质</a>的存储子系统，AHCI 是针对这种悬殊的速度差来进行优化设计的。AHCI 是针对硬盘优化的，不适合固态盘。</li>
</ul>
</li>
<li><strong>SCSI</strong>(Small Computer System Interface): 一种连接主机和外围设备的接口，支持包括硬盘、光驱及扫描仪在内的多种设备。SCSI 总线是一种<strong>并行</strong>总线，其优点是适应面广，性能高；缺点是价格昂贵，安装复杂。</li>
<li>==<strong>SAS</strong>==(Serial Attached SCSI): <strong>串行</strong> SCSI ，跟 SATA 总线类似，都是采用串行技术以获得更高的传输速度。就接口标准而言，SATA 是 SAS 的一个子标准，因此 SAS 控制器可以直接操控SATA 硬盘，但是 SATA 控制器并不能对 SAS 硬盘进行控制。</li>
</ul>
<p>SCSI/SAS 需要专用的控制卡，或者主板另外集成控制芯片，性能更好。PATA/SATA 一般由主板南桥/ICH 芯片直接集成控制器，但接口性能一般比同时期的 SCSI/SAS 要低。目前，服务器流行的硬盘接口类型是 SATA 以及 SAS，两者都是采用串行技术，传输速率都更高。</p>
<h4 id="I-O-Ports-USB-DP-HDMI"><a href="#I-O-Ports-USB-DP-HDMI" class="headerlink" title="I/O Ports(USB, DP, HDMI)"></a>I/O Ports(USB, DP, HDMI)</h4><p><strong>通用外设接口</strong> </p>
<ul>
<li><p><strong>==USB==</strong>(Universal Serial Bus): 串口总线标准，也是一种输入输出接口的技术规范，被广泛地应用于个人电脑和移动设备等信息通讯产品，并扩展至摄影器材、数字电视(机顶盒)、游戏机等其它相关领域。逐渐取代 PS/2 连接键盘与鼠标，取代 COM(串口)与 LPT(并口)</p>
<ul>
<li><p>技术标准</p>
<ul>
<li>USB 2.0: 480 Mbps，半双工</li>
<li>USB 3.0: 5 Gbps，全双工，向下兼容</li>
<li>USB 3.1: 10 Gbps，向下兼容</li>
<li>USB 3.2: 20 Gbps，在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/USB_Type-C">USB Type-C</a>接口上实现双通道，向下兼容，推荐 Type-C 接口</li>
<li>USB 4: 40 Gbps，只支持 Type-C</li>
<li>USB PD: USB 充电标准</li>
</ul>
</li>
<li><p>接口</p>
<ul>
<li>Mini-USB：弃用</li>
<li>Type-A： <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1920px-USB_3.0_Type-A_receptacle_blue.svg.png" alt="undefined" style="zoom:3%;" />  <img src="C:/Users/Lenovo/Pictures/markdownfile/Everything%20about%20mainboard.assets/2560px-USB_3.0_Type-A_blue.svg.png" alt="undefined" style="zoom:3%;" /></li>
<li>Type-B：<img src="https://upload.wikimedia.org/wikipedia/commons/d/d5/USB_3.0_Type-B_blue.svg" style="zoom:17%;" /> <img src="https://upload.wikimedia.org/wikipedia/commons/8/8c/USB_3.0_Type-B_receptacle_blue.svg" style="zoom:17%;" /></li>
<li>Micro-USB：<img src="https://upload.wikimedia.org/wikipedia/commons/1/1b/USB_Micro-B_receptacle.svg" style="zoom:15%;" /> <img src="https://upload.wikimedia.org/wikipedia/commons/1/15/USB_Micro-B.svg" style="zoom:16%;" /></li>
<li>Type-C：<img src="https://upload.wikimedia.org/wikipedia/commons/e/e8/USB_Type-C_receptacle.svg" style="zoom:15%;" /> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/512px-USB_Type-C_icon.svg.png" alt="img" style="zoom:13%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>雷电</strong>(Thunderbolt): 目的在于当作电脑与其他设备之间的通用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8C%AF%E6%B5%81%E6%8E%92_(%E6%95%B8%E6%93%9A)">总线</a>，第一代与第二代的连接口与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Mini_DisplayPort">Mini DisplayPort</a>集成，第三代至第五代的连接口与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/USB_Type-C">USB Type-C</a>结合，并且能用于充电。由于采用了PCI Express和DisplayPort架构，雷电可以<strong>高速连接诸如硬盘、RAID阵列、视频采集设备和网络接口等外设</strong> </p>
</li>
</ul>
<p><strong>音视频接口</strong>(HDMI, DP, 雷电)：</p>
<ul>
<li><p><strong>VGA</strong>(视频图形阵列, <strong>V</strong>ideo <strong>G</strong>raphics <strong>A</strong>rray): 使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E6%AF%94%E8%A8%8A%E8%99%9F">模拟信号</a>的电脑显示标准，在1987年随IBM PS/2系列计算机推出。VGA是大多数PC制造商所遵循的最后一个IBM图形标准，几乎1990年后的所有PC图形硬件都最低支持VGA。当用VGA来表示分辨率时，通常是指640×480。</p>
</li>
<li><p><strong>DVI</strong>(<strong>数字</strong>视频接口, <strong>D</strong>igital <strong>V</strong>isual <strong>I</strong>nterface)：一种<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A6%96%E8%A8%8A">视频</a>接口标准，设计的目的是用来传输未经压缩的数字化影像。目前广泛应用于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LCD">LCD</a>、数字<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8A%95%E5%BD%B1%E6%A9%9F">投影机</a>等显示设备上。</p>
</li>
<li><p><strong>HDMI</strong>(高清媒体接口, <strong>H</strong>igh <strong>D</strong>efinition <strong>M</strong>ultimedia <strong>I</strong>nterface): 是一种全<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D">数字</a>化<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BD%B1%E5%83%8F">影像</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%81%B2%E9%9F%B3">声音</a>发送接口，可以发送未<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E5%A3%93%E7%B8%AE">压缩</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9F%B3%E9%A2%91">音频</a>及<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A6%96%E9%A0%BB">视频</a>信号。HDMI 可以同时发送音频和视频信号。音频和视频信号采用同一条线材的设计大大简化系统线路的安装难度。</p>
</li>
<li><p><strong>DP</strong>(显示端口, <strong>D</strong>isplay <strong>P</strong>ort): 数字式音频/视频接头，此接口的设计是为了取代传统的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/VGA">VGA</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DVI">DVI</a>接口。透过主动或被动转接器，该接口可与传统接口（如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HDMI">HDMI</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DVI">DVI</a>）<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%90%91%E4%B8%8B%E7%9B%B8%E5%AE%B9">向下兼容</a>。</p>
</li>
<li><p><strong>雷电</strong>(Thunderbolt): 有接口也有总线，目的在于当作电脑与其他设备之间的通用 <strong>总线</strong>，第一代与第二代的连接口与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Mini_DisplayPort">Mini DisplayPort</a>集成，第三代至第五代的连接口与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/USB_Type-C">USB Type-C</a>结合，并且能用于充电。由于采用了PCI Express和DisplayPort架构，雷电可以<strong>高速连接诸如硬盘、RAID阵列、视频采集设备和网络接口等外设</strong>。</p>
</li>
</ul>
<h4 id="Peripheral-Card-Slots"><a href="#Peripheral-Card-Slots" class="headerlink" title="Peripheral Card Slots"></a>Peripheral Card Slots</h4><p>外围扩展设备插槽：</p>
<ul>
<li>用于连接显卡、声卡、网卡、固态硬盘 (NVMe SSD) 等扩展设备。</li>
<li>常见标准：PCI Express (PCIe) 3.0、4.0、5.0  M.2 2280</li>
</ul>
<h5 id="PCIe-slots"><a href="#PCIe-slots" class="headerlink" title="PCIe slots"></a>PCIe slots</h5><p>PCIe 可以连到南桥或北桥</p>
<ul>
<li><strong>PCI</strong>(Peripheral Component Interconnect): 常见于现代的个人电脑中，并已取代了 ISA 和 VESA 局部总线，成为了标准扩展总线，是并行的总线。</li>
<li><strong>==PCIe==</strong>(PCI Express): 沿用既有的 PCI 编程概念及信号标准，并且构建了更加高速的串行通信系统标准。只需修改<strong>物理层</strong>而无须修改软件就可将现有 PCI 系统转换为 PCIe，几乎取代了以往所有的内部总线(包括 PCI)。现在英特尔和 AMD 已采用单芯片组(IO Chip)技术，取代原有的南桥和北桥方案。PCIe仅应用于内部互连，没有对外开放的接口。可以连接<strong>显卡</strong>、<strong>网卡</strong>，高性能的持久化存储设备如 NVMe 设备。根据传输通道数量分为 PCIe ×1, PCIe ×4, PCIe ×8, PCIe ×16<ul>
<li><strong>SATA Express</strong>: 物理、逻辑接口标准，使用 PCIe 总线，向下兼容 SATA，支持 PCIe(AHCI 和 NVMe) 设备。后来物理接口被 M.2 和 U.2 取代。</li>
<li><strong>NVMe</strong>(NVM Express, NVMHCIS): 非易失性存储器的接口标准，它是基于设备<strong>逻辑接口</strong>的总线传输协议规范，用于访问通过 PCIe 总线附加的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%9E%E6%8F%AE%E7%99%BC%E6%80%A7%E8%A8%98%E6%86%B6%E9%AB%94">非易失性存储器</a>介质（比如 SSD）降低了I/O操作等待时间、提升同一时间内的操作数、更大容量的操作队列等，取代 AHCI 作为新的逻辑接口协议。</li>
</ul>
</li>
</ul>
<h6 id="NVM-Flash-EEPROM"><a href="#NVM-Flash-EEPROM" class="headerlink" title="NVM(Flash/EEPROM)"></a>NVM(Flash/EEPROM)</h6><p><strong><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%9E%E6%8F%AE%E7%99%BC%E6%80%A7%E8%A8%98%E6%86%B6%E9%AB%94">非易失性存储器</a></strong>(<strong>NVM</strong>, Non-Volatile Memory): 电流关掉后，所存储的信息不会消失的存储设备。依存储器内的资料是否能在使用系统时随时改写为标准，可分为三大类产品：</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ROM">只读存储器</a>(ROM, Read-only Memory)</p>
<ul>
<li>MROM(Masked ROM): 使用掩模工艺，出厂后不可改变，永久固化</li>
<li>PROM(Programmable ROM): 用户可编程的 ROM，烧断熔丝来改变比特，不可逆</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%93%A6%E9%99%A4%E5%8F%AF%E8%A6%8F%E5%8A%83%E5%BC%8F%E5%94%AF%E8%AE%80%E8%A8%98%E6%86%B6%E9%AB%94">EPROM</a>(Erasable PROM): FGMOS 代替熔丝，专用编程器编程，用紫外线擦除，可逆</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E6%8A%B9%E9%99%A4%E5%BC%8F%E5%8F%AF%E8%A4%87%E5%AF%AB%E5%94%AF%E8%AE%80%E8%A8%98%E6%86%B6%E9%AB%94">EEPROM</a>(Electrically EPROM): 只需要特定电压就可以擦除</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Flash_memory">闪存</a>(Flash Memory): 与传统的硬盘相比，闪存有更佳的动态抗震性，不会因为剧烈晃动而造成资料丢失。与 SRAM 相比不需要供电，造价相对 EEPROM 较低，使用块抹除。闪存在分类上属于 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EEPROM">EEPROM</a> 的一种，但普通的 EEPROM 使用的是字节抹除。 </p>
<ul>
<li><p>按照 FGMOS 的门电路结构分为：</p>
<ul>
<li>NOR Flash: 抹写时间长，提供完整的寻址总线，可按字节<strong>随机存取</strong>，类似 RAM</li>
<li>NAND Flash: 抹写时间短，次数高，存储密度高，只能按页访问，类似硬盘，应用有 SSD 固态硬盘、SD 卡、U盘等。</li>
</ul>
</li>
<li><p>按照 每存储单元存储 bit 数分为：</p>
<ul>
<li><p>SLC(1) MLC(2) TLC(3) QLC(4) 成本、寿命、写入性能依次降低</p>
</li>
<li><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2560px-Nand_flash_structure.svg.png" alt="undefined"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E9%9D%9E%E6%8F%AE%E7%99%BC%E6%80%A7%E9%9A%A8%E6%A9%9F%E5%AD%98%E5%8F%96%E8%A8%98%E6%86%B6%E9%AB%94&action=edit&redlink=1">非易失性随机存储器</a>(NVRAM, Non-volatile RAM)</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/FRAM">FeRAM</a>: 替换介电质为铁电材料</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A3%81%E9%98%BB%E5%BC%8F%E9%9A%A8%E6%A9%9F%E5%AD%98%E5%8F%96%E8%A8%98%E6%86%B6%E9%AB%94">MRAM</a>: 使用磁存储器件存储数据，应用巨磁阻效应</li>
</ul>
</li>
</ol>
<h5 id="M-2-slots"><a href="#M-2-slots" class="headerlink" title="M.2 slots"></a>M.2 slots</h5><ul>
<li><strong>==M.2==</strong>(NGFF): 采用全新物理布局与接口，取代 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/PCI_Express">PCIe</a> 及 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SATA#mSATA">mSATA</a> 的物理插槽<ul>
<li>U.2: 2015 年SATA Express发布了一种兼容SAS、PCI Express x4、SATA总线的的U.2连接器界面，U.2更多用于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%BA%E6%9C%8D%E5%99%A8">服务器</a>等企业应用场合。U.2支持<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%86%B1%E6%8F%92%E6%8B%94">热插拔</a>而M.2不支持；U.2可使用3.3V电源和12V电源，M.2只能使用3.3V电源；M.2可应用于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98">固态硬盘</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1">无线网卡</a>等设备，而U.2仅用于2.5英寸固态盘。</li>
<li>支持 SATA、AHCI+PCIe、NVMe+PCIe，同时可以连接网卡等</li>
</ul>
</li>
</ul>
<h4 id="Flash-ROM-BIOS"><a href="#Flash-ROM-BIOS" class="headerlink" title="Flash ROM (BIOS)"></a>Flash ROM (BIOS)</h4><p>大部分的主板的BIOS存储在Flash ROM芯片内，用于对主板作启动的初始化；在启动的过程中包含存储器、周边设备都会被测试以及做初始设置，这个过程称为 加电自检 POST，若是在 POST 的过程中出现错误，则主机会发出”哔”声或是出现错误消息在屏幕上。从2011年起，大部分的零售主板已采用UEFI BIOS，一些厂商（尤其是微星科技、华硕）还率先导入图形界面的UEFI BIOS等技术。</p>
<h4 id="CMOS-Memory"><a href="#CMOS-Memory" class="headerlink" title="CMOS Memory"></a>CMOS Memory</h4><p>CMOS 纽扣电池供电给 CMOS 芯片(RAM)，CMOS 芯片保存系统时间和 BIOS 设置。</p>
<h2 id="Other-Modules"><a href="#Other-Modules" class="headerlink" title="Other Modules"></a>Other Modules</h2><h3 id="Power-Interface"><a href="#Power-Interface" class="headerlink" title="Power Interface"></a>Power Interface</h3><ul>
<li>24 针主电源接口：为主板供电。</li>
<li>8 针或 4+4 针 CPU 辅助电源接口：为 CPU 供电。</li>
</ul>
<h3 id="Cooling-Module"><a href="#Cooling-Module" class="headerlink" title="Cooling Module"></a>Cooling Module</h3><ul>
<li>CPU 散热器接口：供电及控制风扇速度。</li>
<li>芯片组和供电模块上的散热片和风扇，降低温度。</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/1024px-IO_stack_of_the_Linux_kernel.svg.png" alt="undefined"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/17/408-%E8%AE%A1%E7%BB%84-ROM%20RAM%20Cache%20Bus%20IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/17/408-%E8%AE%A1%E7%BB%84-ROM%20RAM%20Cache%20Bus%20IO/" class="post-title-link" itemprop="url">ROM RAM Cache IO</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-17 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-17T00:00:00+08:00">2024-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 12:44:19" itemprop="dateModified" datetime="2025-05-05T12:44:19+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">计组</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240617152721653.png" alt="image-20240617152721653"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240617154333462.png" alt="image-20240617154333462"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240617160638666.png" alt="image-20240617160638666"></p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="计算机基本组成"><a href="#计算机基本组成" class="headerlink" title="计算机基本组成"></a>计算机基本组成</h2><h4 id="冯诺依曼"><a href="#冯诺依曼" class="headerlink" title="冯诺依曼"></a>冯诺依曼</h4><p>==calculator== storage controller I/O</p>
<p>instruction data 同等地位</p>
<p>层次化 模块化 明确定义的接口</p>
<p>规则性 容易被重用</p>
<p>取存 加乘 PRINTs STOP</p>
<p>指令格式：操作码+地址码</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240617213301501.png" alt="image-20240617213301501"></p>
<h4 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h4><p>存储单元个数 由MAR决定 存储器地址寄存器，4位能存16个地址</p>
<p>取数指令，运算指令 </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240617214101456.png" alt="image-20240617214101456"></p>
<p>每个存储单元能够保存的数据长度称为字长，</p>
<p>MAR 4位 能存16个地址</p>
<p>MDR 8位 每个地址能存的字节数</p>
<p>房间号-房间里的床位情况</p>
<h4 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h4><p>乘法<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240621161144203.png" alt="image-20240621161144203"></p>
<h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><h4 id="完成一条指令的过程"><a href="#完成一条指令的过程" class="headerlink" title="完成一条指令的过程"></a>完成一条指令的过程</h4><p>取指令，PC储存要执行指令的地址，应支持计数，存到IR，取完自加</p>
<p>分析指令， IR 存放当前执行的指令，OPCODE操作码给到CU</p>
<p>执行指令 操作数的地址</p>
<ul>
<li>程序计数器（PC，Program counter），用于存放指令的地址。为了保证程序(在操作系统中理解为进程)能够连续地执行下去，CPU必须具有某些手段来确定下一条指令的地址。当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到指令寄存器中，此过程称，为“取指令”。与此同时，PC中的地址或自动加1或由转移指针给出下一条指令的地址。此后经过分析指令，执行指令。完成第一条指令的执行，而后根据PC取出第二条指令的地址，如此循环，执行每一条指令。</li>
<li>指令寄存器（IR，Instruction Register），用来保存当前正在执行的一条指令。是临时放置从内存里面取得的程序指令的寄存器，用于存放当前从主存储器读出的正在执行的一条指令。当执行一条指令时，先把它从内存取到数据寄存器（DR，Data Register）中，然后再传送至IR。指令划分为操作码和地址码字段，由二进制数字组成。为了执行任何给定的指令，必须对操作码进行测试，以便识别所要求的操作。指令译码器就是做这项工作的。指令寄存器中操作码字段的输出就是指令译码器的输入。操作码一经译码后，即可向操作控制器发出具体操作的特定信号。</li>
</ul>
<h4 id="主机完成一条指令过程"><a href="#主机完成一条指令过程" class="headerlink" title="主机完成一条指令过程"></a>主机完成一条指令过程</h4><p> <img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240621171338162.png" alt="image-20240621171338162"></p>
<h4 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h4><p>字长，主频，核数与线程数，指令集执行的时间（静态动态执行频率）</p>
<p>CPI 一条指令所需时钟周期数</p>
<p>IPC 一个时钟周期执行指令数</p>
<p>mips 每秒执行的百万条指令数</p>
<p>flops 每秒浮点运算次数</p>
<p>iops I/O Operations Per Second</p>
<h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>总线： 各部件共享的传输介质，分时，同一时刻只允许一个</p>
<p>传送方式：串行、并行（距离短）</p>
<p>主设备从设备：有无对总线的控制功能</p>
<h3 id="单总线"><a href="#单总线" class="headerlink" title="单总线"></a>单总线</h3><p>延宕严重</p>
<h3 id="双总线"><a href="#双总线" class="headerlink" title="双总线"></a>双总线</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240621213833311.png" alt="image-20240621213833311"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240621213950031.png" alt="image-20240621213950031"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240621221022916.png" alt="image-20240621221022916"></p>
<ol start="3">
<li>通信总线</li>
</ol>
<h3 id="总线通信"><a href="#总线通信" class="headerlink" title="总线通信"></a>总线通信</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/iteye_21199/article/details/82200270">同步通信：高度同步，总系长度短</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704200733860.png" alt="image-20240704200733860"></p>
<p>不互锁，半互锁，全互锁</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704200917886.png" alt="image-20240704200917886"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704201135928.png" alt="image-20240704201135928"></p>
<p>从设备准备好数据，WAIT才变成高电平</p>
<p>主模块发地址 命令，占用总线</p>
<p>从模块准备数据，<strong>空闲</strong></p>
<p>从模块向主模块发数据，占用总线</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704201642697.png" alt="image-20240704201642697"></p>
<p>同步方式，不等对方回答</p>
<p>各模块都有权申请占用总线</p>
<p>从模块变成主模块，发完数据以后再次跟总线断开，总线和原来的主模块连接</p>
<p>充分利用总线带宽</p>
<h3 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h3><p>链式查询、计数器定时查询、独立请求</p>
<p>为的是解决多个设备竞争总线控制权</p>
<h2 id="存储器-1"><a href="#存储器-1" class="headerlink" title="存储器"></a>存储器</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a><strong>存储介质</strong></h4><p><strong>半导体</strong>存储器（TTL MOS）</p>
<p><strong>磁</strong>表面 (HDD 磁带)</p>
<p>磁芯存储器(Core memory) 电流磁化以后使其极化</p>
<p><strong>光盘</strong>存储器</p>
<h4 id="存取方式"><a href="#存取方式" class="headerlink" title="存取方式"></a>存取方式</h4><p>随机访问，和物理地址无关 RAM 可读写，只读存储器ROM只读</p>
<p>串行访问，磁带，顺序存取，磁盘</p>
<h4 id="地位"><a href="#地位" class="headerlink" title="地位"></a>地位</h4><p>主存</p>
<ul>
<li>RAM(SRAM,DRAM)<br>ROM(MROM,PROM,EPROM,EEPROM)</li>
</ul>
<p>闪存 缓冲主存和辅存</p>
<p>高速缓冲存储器Cache sram</p>
<p>辅助存储</p>
<h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><p>速度，价格，容量</p>
<p>存储体系：把两种以上的存储器用软&amp;硬件连接成一个整体</p>
<p>缓存和主存之间要的是速度，硬件支持</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704203517251.png" alt="image-20240704203517251"></p>
<p>主辅之间要的是容量，软件硬件相结合，虚拟存储，虚地址</p>
<h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704205102321.png" alt="image-20240704205102321"></p>
<p>GB是千kilo进制 </p>
<p>GiB是千位kilo b<strong>i</strong>nary二进制</p>
<p>计算机一次处理的位数称为字长</p>
<p>16位，1word=16bit=2byte</p>
<p>32位，1word=32bit=4byte</p>
<p>64位，1word=64bit=8byte</p>
<p>字节是计算机处理数据的基本单位，几乎所有计算机操作系统和编程语言都以字节为单位进行数据管理和传输，数据存储是以“字节”（Byte）为单位，数据传输是以大多是以“位”（bit，又名“比特”）为单位，一个位就代表一个0或1（即二进制），每8个位（bit，简写为b）组成一个字节（Byte，简写为B），是最小一级的信息单位。<br>还可以从以下几个方面来理解：<br>1.字节(Byte)是电脑中表示信息含义的最小单位，因为在通常情况下一个ACSII码就是一个字节的空间来存放。而事实上电脑中还有比字节更小的单位，因为一个字节是由八个二进制位组成的，换一句话说，每个二进制位所占的空间才是电脑中最小的单位，我们把它称为位，也称比特（bit）。由此可见，一个字节等于八个位。人们之所以把字节称为电脑中表示信息含义的最小单位，表示最基本的字符，是因为一个位并不能表示我们现实生活中的一个相对完整的信息。另外，内存中运算的最小存储单位是字节，位运算也是在一个字节的存储单位的基础上进行的，所以<strong>存储的最小单位可以理解为字节。</strong> </p>
<p>2.bit是二进制数的一位包含的信息或2个选项中特别指定1个的需要信息量称为一比特，是表示信息的最小单位，只有两种状态：0和1。电脑内部的电路工作有高电平和低电平两种状态.所以就用二进制来表示信号，以便计算机识别。所以计算机能传输的最小单位当然是你信号的单位bit，而不是字节，串口最小也有一位传递的。另外数字信息流的基本单位是bit（比特），时间的基本单位是s（秒），因此bit/s（比特/秒）是描述带宽的单位，1bit/s是带宽的基本单位，所谓的带宽其实指的是传输速度的快慢，也就是指在一个固定的时间内（1秒），能通过的最大位数据。</p>
<p>地址线上是地址信息，一根地址线只能存储2种状态。32根地址线实际上能表示一个32位的二进制数，可以用32个二进制位来表示任意的内存地址或I/O端口地址。</p>
<p>寻址：当CPU<strong>请求数据时获得该数据在内存上的位置的过程</strong>。内存上存储的所有数据都会有一个可以区分的地址，这与其存放的位置相对应，当CPU请求数据时，内存中的电路会根据CPU的地址线上的信号利用数据总线向CPU返回数据。</p>
<p>那么内存是如何编码数据保存的位置的？这里涉及到上文所述的字节的概念。内存每一个存储位置的最小单元都可以储存0或1，即一个位的内容，而内存将8个位设定为一个存储空间的基本单位。而在地址线上每一个地址的编号便对应的是一个存储位置的最小的基本单位。</p>
<p>如何在地址线上用信号表示这个地址，这个问题引出了两个不同的寻址方式：按字节寻址和按字寻址。</p>
<p>如果有30条地址线，一共能表示2^30^ 个字节，能表示2^30^ </p>
<h4 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h4><p>容量大小</p>
<p>速度：</p>
<ul>
<li>存取时间t1<ul>
<li>访问时间（读出时间，写入时间）</li>
</ul>
</li>
<li>存取周期t2<ul>
<li>连续 两次 独立 的存储器操作</li>
<li>读或者写最小的时间间隔</li>
</ul>
</li>
</ul>
<p>t1&lt;t2</p>
<p>带宽 bps</p>
<h4 id="半导体存储芯片"><a href="#半导体存储芯片" class="headerlink" title="半导体存储芯片"></a>半导体存储芯片</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704214511866.png" alt="image-20240704214511866"></p>
<p>4条数据线意味着每个内存单元可以存储4个数据位（通常是4比特）。这意味着每个内存单元可以存储 24=162^4 = 1624=16 个不同的数据值。</p>
<table>
<thead>
<tr>
<th>地址线（单向）</th>
<th>数据线（双向）</th>
<th>芯片容量</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>4</td>
<td>1K*4bit</td>
</tr>
<tr>
<td>14</td>
<td>1</td>
<td>16K*1 bit</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>内存条上有很多芯片，不同的地址范围选的芯片也不一样 ，还有读写控制线</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704215706473.png" alt="image-20240704215706473"></p>
<h5 id="译码驱动"><a href="#译码驱动" class="headerlink" title="译码驱动"></a>译码驱动</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704220128452.png" alt="image-20240704220128452"></p>
<p>4位地址，共16个单元，8条控制线，一个单元是8位，所以存储空间是一个16*8位的矩阵，简单</p>
<p>0000 字线0号激活，0,0~0,7</p>
<p>缺点：线路密集</p>
<p>20个地址线，输出1M条线，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704220753043.png" alt="image-20240704220753043"></p>
<p>只有两边同时激活才能进行数据的输出，20个地址线，译码器输出只用2K条线。</p>
<h4 id="RAM-随机存取"><a href="#RAM-随机存取" class="headerlink" title="RAM 随机存取"></a>RAM 随机存取</h4><h5 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h5><p>保存0-1的原理：用双稳态触发器</p>
<p>六管静态RAM</p>
<h5 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704221726015.png" alt="image-20240704221726015"></h5><p>给出行选信号，列选信号，读有效</p>
<p>T6 T8 然后读出</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704222330938.png" alt="image-20240704222330938"></p>
<p>Intel 2114 读</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704223228647.png" alt="image-20240704223228647"></p>
<h5 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h5><p>保存0-1:电容（需要刷新）</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704224121714.png" alt="image-20240704224121714"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704224306390.png" alt="image-20240704224306390"></p>
<p>刷新放大器对电容充电</p>
<p>放大器能够放大电容的电平</p>
<p>刷新和行地址有关，列地址无关</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704225313098.png" alt="image-20240704225313098"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704225840140.png" alt="image-20240704225840140"></p>
<p>刷新安排再指令译码阶段</p>
<h5 id="SRAM-VS-DRAM"><a href="#SRAM-VS-DRAM" class="headerlink" title="SRAM VS DRAM"></a>SRAM VS DRAM</h5><table>
<thead>
<tr>
<th></th>
<th>DRAM（主存）</th>
<th>SRAM（Cache）</th>
</tr>
</thead>
<tbody><tr>
<td>存储原理</td>
<td>电容</td>
<td>触发器</td>
</tr>
<tr>
<td>集成度</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>芯片引脚</td>
<td>少（行列分别传）</td>
<td>多</td>
</tr>
<tr>
<td>功耗</td>
<td>少</td>
<td>多</td>
</tr>
<tr>
<td>价格</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>刷新</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>速度</td>
<td>慢</td>
<td>快</td>
</tr>
</tbody></table>
<h4 id="ROM-只读存储器"><a href="#ROM-只读存储器" class="headerlink" title="ROM 只读存储器"></a>ROM 只读存储器</h4><p>MROM 掩膜ROM Uncustomizable</p>
<p>交叉处有无MOS管 有1无0</p>
<p>PROM 一次性编程 破坏性编程</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704230627923.png" alt="image-20240704230627923"></p>
<p>EPROM 多次 紫外线擦写</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704230734230.png" alt="image-20240704230734230"></p>
<p>EEPROM 支持局部擦写</p>
<p>FlashMemory </p>
<h4 id="存储器与CPU连接"><a href="#存储器与CPU连接" class="headerlink" title="存储器与CPU连接"></a>存储器与CPU连接</h4><h5 id="容量扩展"><a href="#容量扩展" class="headerlink" title="容量扩展"></a>容量扩展</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704231244644.png" alt="image-20240704231244644"></p>
<p>两个芯片共用地址线，输入1个十位的地址，2114内相同的地址单元能够同时各自输出自己储存的4位信息，重点：<strong>同时工作</strong> 片选同时激活</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704231832857.png" alt="image-20240704231832857"></p>
<p>11根地址线，多出来的一条用于控制片选，原来10根地址线共用，地址线的目的：每一个二进制数都要表示一个不同的存储单元 片选不同时工作</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704232318234.png" alt="image-20240704232318234"></p>
<p>原来10根地址线共用</p>
<h5 id="连接存储器与CPU"><a href="#连接存储器与CPU" class="headerlink" title="连接存储器与CPU"></a>连接存储器与CPU</h5><p>写出二进制地址码，确认芯片数量和类型，分配地址线，确定片选信号逻辑</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705131119849.png" alt="image-20240705131119849"></p>
<p>CPU-16根地址线-8根数据线</p>
<p>6000H 67FF为系统程序区 2K*8 11根 ROM</p>
<p>6800H 6BFFH为用户程序区 1K*8 10根 RAM</p>
<p>ROM选择2K*8 RAM选择1K*4的两个存储器进行位扩展</p>
<p>A10-A0 连接ROM A9-A0连接RAM</p>
<p>A13-A11 连接138 译码信号连到片选上 100-ROM 101-RAM </p>
<p>A14连到138的G1 A15连接到G2a</p>
<p>MREQ低电平访存控制信号连到G2b</p>
<p>（CPU访问内存，译码器必须工作）</p>
<p>地址要全部用上</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705131919043.png" alt="image-20240705131919043"></p>
<p>注意看 ROM2K空间利用充分，但是Y5和A10同时=0才算RAM空间</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705131758051.png" alt="image-20240705131758051"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705135723021.png" alt="image-20240705135723021"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705135733548.png" alt="image-20240705135733548"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705135742847.png" alt="image-20240705135742847"></p>
<p>错误处理</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705212942601.png" alt="image-20240705212942601"></p>
<p>低位交叉</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705213711855.png" alt="image-20240705213711855"></p>
<p>看清，是几体并行，4体并行就是低2位为译码器输入。</p>
<p>要求32K * 8 bit 给了4K * 4 bit的芯片 ， 低位交叉四体并行</p>
<p>4K 共12位地址线 需要芯片共16片，一般的做法是用2片4K*4进行位扩展，用8个这样的组合进行字扩展，高3位接译码器，但由于是要求低位4体并行的交叉编址，先用2片4K*4进行位扩展，然后用两组进行字扩展，最后用4个这样的组合进行字扩展。低2位接译码器</p>
<p>读写信号、MREQ、数据输出位D、地址线、片选使能（位扩展使能统一，字扩展看译码器输出）</p>
<h5 id="存储器校验"><a href="#存储器校验" class="headerlink" title="存储器校验"></a>存储器校验</h5><p>检测与纠错能力</p>
<h6 id="前导：奇偶校验"><a href="#前导：奇偶校验" class="headerlink" title="前导：奇偶校验"></a>前导：奇偶校验</h6><ul>
<li><p><strong>奇校验</strong>：如果数据单元中1的数量已经是奇数，则校验位设置为0；否则，校验位设置为1。如果出现错误，1的个数不再是奇数。</p>
<ul>
<li>假设数据单元为8位，并且使用奇校验：</li>
<li>数据 <code>10110011</code> 中有5个1，因此符合奇数要求，校验位为0。</li>
<li>数据 <code>11001010</code> 中有4个1，不符合奇数要求，校验位为1。</li>
</ul>
</li>
<li><p><strong>偶校验</strong>：如果数据单元中1的数量已经是偶数，则校验位设置为0；否则，校验位设置为1。如果出现错误，1的个数不再是偶数。</p>
</li>
<li><p><strong>校验过程</strong></p>
<p>发送方在数据末尾添加校验位，形成校验单元后发送。接收方收到数据后，重新计算校验位，并与接收到的校验位进行比对。如果两者相同，则认为数据传输正确；如果不同，则意味着在传输过程中出现了错误。</p>
</li>
</ul>
<p>2^k^≥n+k+1</p>
<p>K是纠错码位数，一共有2^k^种错误，</p>
<p>一位错，n+k+1</p>
<p>合法代码</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705140417990.png" alt="image-20240705140417990"></p>
<p> 编码最小距离：任意两个合法代码二进制位的最少差异数</p>
<p>L-1 = D+C</p>
<p>Length Detected Correction</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a493823882/article/details/109343791">汉明码使用</a> 校验位错了不用纠</p>
<h4 id="提高访存速度"><a href="#提高访存速度" class="headerlink" title="提高访存速度"></a>提高访存速度</h4><p>高速器件、层次结构(Cache)、<strong>调整主存结构</strong></p>
<h5 id="单体多字系统"><a href="#单体多字系统" class="headerlink" title="单体多字系统"></a>单体多字系统</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705210133859.png" alt="image-20240705210133859"></p>
<p>数据不连续会影响效率，4个字一起出来</p>
<h5 id="多体并行"><a href="#多体并行" class="headerlink" title="多体并行"></a>多体并行</h5><p><strong>高位交叉</strong>，</p>
<p>数据组织特点：相邻地址的数据处于同一存储体,一个地址寄存器,多模块串行（局部性原理）,性能无提升,扩充容量方便</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705210318229.png" alt="image-20240705210318229"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/b5ecff2b7ba843538f083126dfe59653-1720187489744-3.png" alt="b5ecff2b7ba843538f083126dfe59653"></p>
<p><strong>低位交叉</strong>，如果采用分时启动的方法，可以在不改变每个存储体存取周期的前提下，提高整个主存的速度</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705210508945.png" alt="image-20240705210508945"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705210704163.png" alt="image-20240705210704163"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/96e598788488485e97a03a8ff2059885-1720187482260-1.png" alt="96e598788488485e97a03a8ff2059885"></p>
<p>每个存储体均需地址寄存器,模M编址方式 多模块并行（局部性原理）,扩充容量也方便</p>
<p>低位交叉的好处：如果要连续读取，同一个访问周期内，存储器是不能进行下一步读取的，高位交叉会让同一个存储器占用过高，其他用不上，低位就解决了这个问题,流水线访问</p>
<h5 id="存储芯片"><a href="#存储芯片" class="headerlink" title="存储芯片"></a>存储芯片</h5><p>SDRAM 同步DRAM</p>
<p>RDRAM 解决带宽问题</p>
<p>Cache DRAM DRAM访问过的行存入cache 下一次先和这个行地址比较，一样的话直接把列地址输入cache 有利于猝发读取</p>
<h3 id="辅存"><a href="#辅存" class="headerlink" title="辅存"></a>辅存</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704232924331.png" alt="image-20240704232924331"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704233315282.png" alt="image-20240704233315282"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240704233745159.png" alt="image-20240704233745159"></p>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>高速缓冲存储器，避免CPU空等现象</p>
<h4 id="程序访问的局部性原理"><a href="#程序访问的局部性原理" class="headerlink" title="程序访问的局部性原理"></a>程序访问的局部性原理</h4><p>时间的局部性：当前的数据，过一会还会用</p>
<p>空间的局部性：当前的数据，相邻的数据也会用</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705224559514.png" alt="image-20240705224559514"></p>
<p>按照块进行传送。 M&gt;&gt;C</p>
<p>命中：主存快调入缓存</p>
<p>命中率：与cache容量和块长有关</p>
<p>访问效率：</p>
<p>$e=\frac{访问\text{Cache时间}}{平均访问时间}$</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705225126490.png" alt="image-20240705225126490"></p>
<h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705225727823.png" alt="image-20240705225727823"></p>
<h4 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705225811853.png" alt="image-20240705225811853"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705225941275.png" alt="image-20240705225941275"></p>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>L1 L2 L3缓存</p>
<p>分离缓存 指令数据分离，冯氏结构统一</p>
<h4 id="Cache-主存的地址映射"><a href="#Cache-主存的地址映射" class="headerlink" title="Cache-主存的地址映射"></a>Cache-主存的地址映射</h4><p>方式和级数有关</p>
<h5 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h5><p>xx<strong>x只能装到cache的某一确定</strong>的位置，即使Cache的其他许多地址空着也不能占用，这使得直接映射的块冲突概率最高，空间利用率最低。vmax</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705230901918.png" alt="image-20240705230901918"></p>
<p>主存块号的低𝑐位正好是它要装入的Cache行号。给每个Cache行设置一个长为𝑡=𝑚−𝑐的标记(tag),当主存某块替换进Cache后，就将其块号标记位设置在对应Cache行的标记中</p>
<h5 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h5><p>主存中的每一块可以装入Cache 中的<strong>任何</strong>位置，每行的标记用于指出该行取自主存的哪一块，所以CPU访存时需要与所有Cache行的标记进行比较。全相联映射方式的优点是比较灵活，Cache 块的冲突概率低，空间利用率高，命中率也高;缺点是标记的比较速度较慢，实现成本较高，通常需采用昂贵的按内容寻址的相联存储器进行地址映射 vmin</p>
<h5 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a><strong>组相联映射</strong></h5><p><strong>组内全相联 组外直接映射</strong></p>
<p>确定组号之后再确定区号，0和2^c-r^ 2^c-r+1^ 都在第0组，组内采用字块号一一对应的方法<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/20210713154218.png" alt="20210713154218"></p>
<h4 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h4><p>Cache满就要替换栈</p>
<h5 id="FIFO-First-in-first-out"><a href="#FIFO-First-in-first-out" class="headerlink" title="FIFO(First in first out)"></a>FIFO(First in first out)</h5><p>先进先出，违反程序局部性原则</p>
<h5 id="LRU-Last-recently-used"><a href="#LRU-Last-recently-used" class="headerlink" title="LRU(Last recently used)"></a>LRU(Last recently used)</h5><p>近期最少使用</p>
<h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><h3 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h3><p>早期：分散连接，串行工作</p>
<p>接口模块和DMA阶段：总线连接，并行工作（中断/DMA）</p>
<p>通道结构阶段：有自己的简单处理器</p>
<p>I/O处理机阶段：高性能微处理器</p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705235621421.png" alt="image-20240705235621421"  />

<h4 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h4><p>接口\设备</p>
<h4 id="外部设备"><a href="#外部设备" class="headerlink" title="外部设备"></a>外部设备</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706002820937.png" alt="image-20240706002820937"></p>
<p>键盘鼠标显示器，A/D D/A 模数转换，终端，汉字处理。</p>
<h4 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I/O接口"></a>I/O接口</h4><p>选择设备，数据缓冲匹配速度，串并格式转换，电平转换，传送命令</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706121949206.png" alt="image-20240706121949206"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706122640491.png" alt="image-20240706122640491"></p>
<h3 id="主机与I-O的联系方式"><a href="#主机与I-O的联系方式" class="headerlink" title="主机与I/O的联系方式"></a>主机与I/O的联系方式</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240705235948953.png" alt="image-20240705235948953"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706000234331.png" alt="image-20240706000234331"></p>
<p> (3)必须要有统一的时间标准</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706000359748.png" alt="image-20240706000359748"></p>
<h3 id="主机与I-O的信息传送控制"><a href="#主机与I-O的信息传送控制" class="headerlink" title="主机与I/O的信息传送控制"></a>主机与I/O的信息传送控制</h3><h4 id="通道方式、IO处理器方式"><a href="#通道方式、IO处理器方式" class="headerlink" title="通道方式、IO处理器方式"></a>通道方式、IO处理器方式</h4><h4 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706000830237.png" alt="image-20240706000830237"></p>
<p>完全由主机执行程序实现，等待数据准备的过程CPU会空转，一直查询状态，串行工作</p>
<p>查询的程序嵌入CPU</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706140313041.png" alt="image-20240706140313041"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706142641037.png" alt="image-20240706142641037"></p>
<h4 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706001125217.png" alt="image-20240706001125217"></p>
<p>会暂停现行程序 ，部分并行工作。中断会影响正常的程序处理，为了恢复CPU仍然要消耗资源，执行中断服务程序</p>
<h5 id="I-O形成中断请求过程"><a href="#I-O形成中断请求过程" class="headerlink" title="I/O形成中断请求过程"></a>I/O形成中断请求过程</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706001442993.png" alt="image-20240706001442993"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706141207557.png" alt="image-20240706141207557"></p>
<ol>
<li>中断请求触发器+中断屏蔽触发器</li>
</ol>
<p>先决条件：MASK = 0 中断未被屏蔽 + 设备本身已经准备好数据了 -&gt; INTR = 1 设备发出中断请求  </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706141710467.png" alt="image-20240706141710467"></p>
<ol start="2">
<li>排队器</li>
</ol>
<p>分为<strong>软件</strong>和<strong>硬件</strong>方式</p>
<p>硬件：链式排队器</p>
<p>优先级最高的没有请求，$\overline {INTP’}$=1，$\overline {INTR}$=1，会导致这些优先级高、无请求的$\overline {INTP’}$=1，低优先级的来了请求，$\overline {INTR}$=0，就会让之后的$\overline {INTP’}$=0, 此时之后的$\overline {INTP’}$都对之后的与非门起了决定性作用，也就是优先级更低的全部禁用。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706145002524.png" alt="image-20240706145002524"></p>
<p>$\overline {INTP’}$，$ {INTR}$全部为1才能发出真正的中断指令INTP</p>
<ol start="3">
<li>中断向量地址形成部件（编码器）</li>
</ol>
<p>不同的设备中断服务程序不同，每一个服务程序都有一个入口地址，CPU要找到这些入口就必须对这些地址进行编码，输入是经过排队器综合以后的中断信号INTP，输出是中断向量（二进制码）仅仅是就这些输入编的码，还要将中断向量地址和存储的中断对应设备的服务程序一一对应，中断向量地址处保存的是服务程序的入口地址的地址</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706154548716.png" alt="image-20240706154548716"></p>
<ol start="4">
<li>接口电路</li>
</ol>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706154757761.png" alt="image-20240706154757761"></p>
<h5 id="中断执行过程"><a href="#中断执行过程" class="headerlink" title="中断执行过程"></a>中断执行过程</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706161105095.png" alt="image-20240706161105095"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706212237016.png" alt="image-20240706212237016"></p>
<p>中断请求、中断判优、中断响应、中断服务、中断返回</p>
<p>CPU会在统一的时间，即每条指令执行阶段的最后时刻，进行<strong>中断查询</strong></p>
<p>设备只要准备好了(D=1)并且没有被屏蔽(MASK=0)，查询信号(相当于D触发器的clk信号)就会使得输出INTR=1，此时请求INTR=1也会被送到排队器进行<strong>判优</strong>，</p>
<p>随后CPU根据判优结果进行响应，如果排队选中并且EINT=1，进行CPU的<strong>中断响应</strong> </p>
<ul>
<li>响应条件<ul>
<li>中断源有中断请求, INTR=1 </li>
<li>开中断，使 EINT=1</li>
<li>一条指令执行完毕，且没有更紧迫的任务</li>
</ul>
</li>
</ul>
<p>通过INTR信号线发出的外中断是可屏蔽中断 ，在关中断（EINT=0）的情况下不会被响应</p>
<p>I/O设备的就绪时间是随机的，而CPU在统一的时刻即每条指令执行阶段结束前向接口发出中断查询信号，以获取I/O 的中断请求，也就是说，CPU响应中断的时间是在每条指令执行阶段的结束时刻。这里说的中断仅指外中断，内中断不属于此类情况。</p>
<p><strong>响应</strong>时，先由INTA<del>cknowledge</del>=1激活设备编码器：将排队结果发到编码器，生成向量地址，向量本身是JMP TO  200, 向量地址是JMP TO 200 的地址</p>
<p>根据向量地址进行开始<strong>运行服务程序</strong> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706170143933.png" alt="image-20240706170143933"></p>
<p>多重中断的流程</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706172054097.png" alt="image-20240706172054097"></p>
<p>1-3由隐指令完成，单重中断：直到恢复完现场才开中断。多重中断允许嵌套，必须满足下列条件:①在中断服务程序中提前设置开中断②优先级别高的中断源有权中断优先级别低的中断源。</p>
<p>假如D&gt;A&gt;C&gt;B，源A执行中，D来了就要中断A去执行D。每个中断源都有一个 屏蔽触发器屏蔽触发器 ，1 表示 屏蔽该中断源屏蔽该中断源 的请求，0 表示可以 正常申请正常申请 ，所有屏蔽触发器组合在一起便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字。D的屏蔽字是1111，具有最高优先级，A是1110次之，以此类推</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706170847647.png" alt="image-20240706170847647"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706171244016.png" alt="image-20240706171244016"><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706171245893.png" alt="image-20240706171245893"></p>
<p>屏蔽技术</p>
<p>屏蔽触发器和屏蔽字：程序中断接口电路中，完成触发器D，中断请求触发器INTR和屏蔽触发器MASK。</p>
<p>当中断源被屏蔽时（MASK=1），此时即使D=1，中断查询信号到来时刻只能将INTR置“0”，CPU接收不到该中断源的中断请求，即它被屏蔽。</p>
<p>若该中断源未被屏蔽（MASK=0）当设备工作已完成时（D=1），中断查询信号则将INTR置“1”，表示该中断源向CPU发出中断请求，该信号送至排队器进行优先级判断。显然，对于每个中断请求触发器就有一个<strong>屏蔽触发器</strong>，将所有屏蔽触发器组合在一起，便构成了一个<strong>屏蔽寄存器</strong>。屏蔽寄存器的内容称为<strong>屏蔽字</strong>。屏蔽字与中断源的优先级是一一对应的。</p>
<p>屏蔽技术可改变优先等级：严格地说，优先级包含<strong>响应优先级</strong>和<strong>处理优先级</strong>。响应优先级是指CPU响应各中断源请求的优先次序，这种次序往往是硬件线路已设置好的，不便于改动。处理优先级是指CPU实际对各中断源请求的处理优先次序。如果不采用屏蔽技术，响应的优先次序就是处理的优先次序。</p>
<p>eg. 响应L1&gt;L2&gt;L3&gt;L4 处理反过来</p>
<p>几个中断源同时提出中断请求，L1首先响应，开始执行，但是被L2打断，L2开始执行，被L3打断，之后L3被L4打断，L4执行完继续执行L3</p>
<p>ABCD由设备识别电路，A能将</p>
<h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><p><strong>I/O direct to Memory</strong></p>
<p><strong>D</strong>irect <strong>M</strong>emory <strong>A</strong>ccess</p>
<h5 id="DMA方式的特点"><a href="#DMA方式的特点" class="headerlink" title="DMA方式的特点"></a>DMA方式的特点</h5><ul>
<li><p>在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。</p>
</li>
<li><p>主存中要开辟专用缓冲区，及时供给和接收外设的数据。</p>
</li>
</ul>
<h6 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h6><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706172851691.png" alt="image-20240706172851691"></p>
<p>CPU不参与</p>
<h6 id="与主存交换数据方式"><a href="#与主存交换数据方式" class="headerlink" title="与主存交换数据方式"></a>与主存交换数据方式</h6><ol>
<li><p>停止CPU对主存的访问。不能充分发挥CPU对主存的利用率。<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706173212015.png" alt="image-20240706173212015"></p>
</li>
<li><p>窃取周期。存取周期内CPU不能通过总线对内存进行访问，然而CPU指令执行并不是一条条取的，而是预取。并行工作。</p>
<p>CPU未占用总线,DMA/CPU正在占用总线,CPU/DMA、CPU同时发起占用总线的请求，DMA<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706174016933.png" alt="image-20240706174016933"></p>
</li>
<li><p>交替访问 一个原周期分为DMA周期和CPU周期<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706173952420.png" alt="image-20240706173952420"></p>
</li>
</ol>
<h5 id="接口-DMA控制器"><a href="#接口-DMA控制器" class="headerlink" title="接口/DMA控制器"></a>接口/DMA控制器</h5><h6 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h6><p>DMA申请总线控制权/CPU移交总线控制权/DMA管理总线控制传输数据, 确定数据传送首地址和长度, 对传输过程中的数据进行修正/DMA发出操作完成信号</p>
<h6 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h6><p><u>字</u>计数器<strong>W</strong>ord<strong>C</strong>ounter</p>
<p><u>主存地址</u>寄存器<strong>A</strong>ddress<strong>R</strong>egister</p>
<p><u>数据缓冲</u>寄存器<strong>B</strong>uffer<strong>R</strong>egister</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706180228563.png" alt="image-20240706180228563"></p>
<h5 id="传输过程"><a href="#传输过程" class="headerlink" title="传输过程"></a>传输过程</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706180723685-1720260754514-3.png" alt="image-20240706180723685"></p>
<h6 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h6><p>预处理就是CPU的I/O指令</p>
<p>CPU完成准备工作：首先，CPU执行几条I/O 指令，用以测试I/O设备状态，向 DMA 控制器的有关寄存器置初值、设置传送方向、启动该设备等。然后，CPU继续执行原来的程序，直到I/O设备准备好发送的数据（输入情况）或接收的数据（输出情况）时，I/O设备向DMA控制器发送DMA请求，再由DMA控制器向CPU 发送总线请求（有时将这两个过程统称为DMA请求），用以传输数据。</p>
<h6 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h6><p>传输可以用byte/word为基本单位，也可用block作为基本单位，对于以数据块为单位的传送（如硬盘），DMA占用总线后的数据输入和输出操作都是通过循环来实现的。需要指出的是，这一循环也是由 DMA 控制器（而非通过CPU执行程序）实现的，即数据传送阶段完全由DMA（硬件）控制。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706181444755.png" alt="image-20240706181444755"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706181559135.png" alt="image-20240706181559135"></p>
<p>WC(Word Counter)溢出会发中断请求INTR给中断机构</p>
<h6 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h6><p>DMA控制器向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理，包括**<u>校验</u>送入主存的数据是否正确<strong>、测试传送过程中是否出错（错误则转入诊断程序）及决定是否继续使用DMA传送其他数据块等，</strong>由中断服务程序完成** </p>
<h5 id="DMA和系统连接方式"><a href="#DMA和系统连接方式" class="headerlink" title="DMA和系统连接方式"></a>DMA和系统连接方式</h5><p>公共总线 串联</p>
<p>独立DMA请求 并联</p>
<h5 id="DMA接口类型"><a href="#DMA接口类型" class="headerlink" title="DMA接口类型"></a>DMA接口类型</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706183458104.png" alt="image-20240706183458104"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706183609988.png" alt="image-20240706183609988"></p>
<p>优先级：速度优先</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706184002042.png" alt="image-20240706184002042"></p>
<h4 id="三种方式辨析"><a href="#三种方式辨析" class="headerlink" title="三种方式辨析"></a>三种方式辨析</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240706001545500.png" alt="image-20240706001545500"></p>
<h5 id="DMA方式和中断方式的区别"><a href="#DMA方式和中断方式的区别" class="headerlink" title="DMA方式和中断方式的区别"></a>DMA方式和中断方式的区别</h5><ol>
<li>中断方式是程序的切换，需要保护和恢复现场;而DMA方式除了预处理和后处理，其他时候不占用CPU的任何资源。</li>
<li>对中断请求的响应只能发生在每条指令执行完毕时（即指令的执行周期后）;而对DMA请求的响应可以发生在每个机器周期结束时（存储周期、取指周期、间址周期、执行周期后均可），只要CPU不占用总线就可被响应。</li>
<li>中断传送过程需要CPU的干预;而 DMA传送过程不需要CPU 的干预，因此数据传输率非常高，适合于高速外设的成组数据传送。</li>
<li>DMA请求的优先级高于中断请求。</li>
<li>中断方式的中断请求以传送数据的方式，DMA是以后处理的方式</li>
<li>中断方式具有对异常事件的处理能力，而DMA方式仅局限于传送数据块的I/O操作。</li>
<li>从数据传送来看，中断方式靠程序传送，DMA方式靠硬件传送。</li>
</ol>
<h4 id="易混淆点"><a href="#易混淆点" class="headerlink" title="易混淆点"></a>易混淆点</h4><p>向量中断、中断向量、向量地址</p>
<ul>
<li>向量中断：用来识别中断源的方式，能够找到对应的中断服务程序的入口地址，即向量地址</li>
<li>向量地址：向量表中每一项的地址，中断服务程序的入口地址</li>
<li>中断服务程序：中断源对应的处理程序</li>
<li>中断向量：中断服务程序的入口地址/中断服务程序的跳转指令</li>
<li>中断向量地址：中断向量的地址</li>
</ul>
<p>中断服务程序、子程序</p>
<ul>
<li>中断服务程序：时间不固定，跟主程序无关，需要另外的硬件电路，嵌套级数完全由中断优先级来决定</li>
<li>子程序：时间固定可预知，和主程序息息相关，为主程序服务，不需要额外硬件，嵌套级数由内存堆栈大小限制决定</li>
</ul>
<p>中断响应优先级、中断处理优先级</p>
<ul>
<li>中断响应优先级：由硬件排队器或中断查询程序的查询顺序决定</li>
<li>中断处理优先级：由中断屏蔽字来改变，反映的是正在处理的中断是否比新发生的中断的处理优先级低（屏蔽位为“0”，对新中断开放），若是，则中止正在处理的中断，转到新中断去处理，处理完后再回到刚才被中止的中断继续处理。</li>
</ul>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/13/408-%E8%AE%A1%E7%BB%84-Cache%20%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D%20HDD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/13/408-%E8%AE%A1%E7%BB%84-Cache%20%E5%85%88%E8%A1%8C%E8%BF%9B%E4%BD%8D%20HDD/" class="post-title-link" itemprop="url">cache、先行进位、hdd</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-13 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-13T00:00:00+08:00">2024-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:56:48" itemprop="dateModified" datetime="2025-05-05T11:56:48+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">计组</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><p>磁道数⇔柱面数</p>
<p>数据传输率 = 单磁道容量 * 转速</p>
<p>单磁盘容量 = 有效盘面数 * 磁道数 * 单磁道容量 </p>
<p>​           = 有效盘面数 * 磁道数 * 扇区数 * 单扇区容量 </p>
<p>平均读取时间 = 平均寻道时间 + 平均寻找扇区时间（0.5T）+ 其他延迟时间 + 传输时间(比如<strong>读取一个扇区的时间 = 读取一个磁道的时间即1/r / 扇区数</strong>  或者 <strong>1s传20MB，那么读取一个4KB的扇区时间=4K*1s/20M</strong>)</p>
<p> 寻道时间一般不变，找扇区时间以及传输时间和转速挂钩。</p>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>主存物理地址</p>
<p>第一块</p>
<blockquote>
<p>00000000</p>
<p>00000001</p>
<p>00000010</p>
<p>00000011</p>
</blockquote>
<p>第二块</p>
<blockquote>
<p>00000100</p>
<p>00000101</p>
<p>00000110</p>
<p>00000111</p>
</blockquote>
<p>前六位是块号，每块有四个地址，所以要用最后2位来表示块内地址（这个单元位于块的哪个部分）高位全部是块号</p>
<p>块内地址位数的确定：必须要直到一个块内有多少个地址，比如说一个块16个字，每个字4 Byte，按字编址就是16个，需要4位表示块内地址，按字节编址就是64个，需要6位来给块内地址</p>
<p>一块就对应cache一行（一块）</p>
<p>一块一块交换，所以最终是要核对cache中的块号。</p>
<p>写回法，CPU将cache作为目标存储器，写完如果脏位有效才写回主存</p>
<p>写通/写穿，CPU将cache和主存同时写入，如果cache不命中就先写完主存，再从主存写cache</p>
<p>主存物理地址 = 标记tag+ cache地址</p>
<p>cache地址 = 行号/组号/无 + 块内地址</p>
<p>cache行内容 = 标记区 + 数据区</p>
<p>cache地址映射表 = cache标记区</p>
<p>cache标记区 = 有效位1bit + 主存标记tag +（脏位(写回策略)1bit + 替换控制位）</p>
<p>cache数据区大小 = 块容量 一块4B……</p>
<h3 id="全相联"><a href="#全相联" class="headerlink" title="全相联"></a>全相联</h3><p>直接一位一位核对块号（tag） </p>
<p>优点：存储块可以放到cache的任意一行，空间利用率高</p>
<p>缺点：查找时间可以很长</p>
<h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p>指定1行Cache，只能存间隔固定的存储单元，比如第0行cache只能存每一个区的第0块</p>
<p>优点：查找速度快</p>
<p>缺点：存储块只能放到某一个固定的行，空间利用率低</p>
<p>要知道cache的行数，根据行数确定行号占位，然后再核对剩下的tag内容</p>
<p>如果cache共16行，直接节省了16倍的时间 行号占4位</p>
<h3 id="组相联"><a href="#组相联" class="headerlink" title="组相联"></a>组相联</h3><p>指定某几行Cache，只能存间隔固定的存储单元，比如第0行cache可以存每一个区的第0，2,4，8，是前两种的折中，</p>
<p>如果cache共16行，4路组相联，4个组 组号占2位，节省了4倍时间</p>
<p>先确定组号然后核对tag和有效位，tag匹配，有效位为1即为命中</p>
<h3 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h3><p>cache行数128，在主存中有102个字，8字为一个块，重复按照0-101顺序读10次，一下读一个字，命中率？</p>
<p>先到cache里寻找，一定是先核对组号和tag内容，再根据块内地址找，0-101分成13块，第一次先核对tag，没有对的上的，所以只需要13次没命中。</p>
<p>第二次，cache已经写入了102个字的内容，并且分块分组保存，先核对tag中的组号，发现能对的上，然后核对tag，块内地址，算命中。</p>
<p>总命中次数 102*10-13 得命中率为98.7%</p>
<h2 id="双重分组跳跃进位加法链-ALU"><a href="#双重分组跳跃进位加法链-ALU" class="headerlink" title="双重分组跳跃进位加法链 ALU"></a>双重分组跳跃进位加法链 ALU</h2><h3 id="小组内先行进位"><a href="#小组内先行进位" class="headerlink" title="小组内先行进位"></a>小组内先行进位</h3><p>已知d3-d0, t3-t0, C<del>-1</del>  同时产生C3-C0 DT也能同时产生 耗时2.5t<img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240711163217501.png" alt="image-20240711163217501"></p>
<p>缺点：每组要工作都要知道自己的进位输入位，<strong>不能同时知道自己的进位输入位</strong> </p>
<p>16bit 耗时10t（产生C15-C0的时间）</p>
<p>典型的先行进位4位加法器能够同时产生DT,C3-C0</p>
<h4 id="小组间先行进位"><a href="#小组间先行进位" class="headerlink" title="小组间先行进位"></a>小组间先行进位</h4><p>(只要知道组内dt情况就能立即给出DT，C3-C0)</p>
<p>如果能让他们同时知道自己的进位输入位就能节省时间，此时最高位产生的逻辑只需要知道C<del>-1</del> </p>
<p>已知DT就能马上给出所有最高进位 耗时2.5t ，但是要先得出DT才行，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240711163153788-1720686897748-1.png" alt="image-20240711163153788"></p>
<p>16bit 耗时5t（产生C15-C0的时间）</p>
<p><u>逻辑：同时产生每个组的DT和前三个进位输出，然后再同时产生每个组的最高位进位输出。</u></p>
<p>同时产生每个组的DT和前三个进位输出，倒是也可以同时产生C3，但是此时C3是根据C<del>-1</del> 产生的，后边的C7C11C15要化成C3的形式才能同时产生，反正都是分两步，索性让他们四个按照相同的逻辑产生。</p>
<p>总结，要让DT起作用，就要先知道DT才行，然后让最高位按照统一的逻辑生成。</p>
<h4 id="MSI-ALU"><a href="#MSI-ALU" class="headerlink" title="MSI_ALU"></a>MSI_ALU</h4><p>74182(CLA Generator):Cmin，4DT———3Cout ，D*T* （4个小组）（1个大组） 16bit </p>
<p>74181(4bit CLA Adder):Cmin，4dt——— Cmax，1DT  （1个小组）4bit </p>
<p>4*74181+1*182 = 输入dt，Cmin，到74181和74182，输出D*T*，和4个组最终的进位输出</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240711174412643.png" alt="image-20240711174412643"></p>
<p>74182: 输入Cmin，4D*T*，  输出Cmax、 D**T**（4个大组） 64bit</p>
<p>(4*74181+1*74182)*4 + 1*74182 = 64位 三重分组跳跃进位ALU </p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/13/408-%E8%AE%A1%E7%BB%84-Link/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/13/408-%E8%AE%A1%E7%BB%84-Link/" class="post-title-link" itemprop="url">符号链接</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-13 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-13T00:00:00+08:00">2024-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 12:43:29" itemprop="dateModified" datetime="2025-05-05T12:43:29+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">计组</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>文本：源代码 <code>hello.c</code></p>
<p>预处理：修改文本 <code>hello.i file</code></p>
<p>编译器：assembly <code>hello.s file</code></p>
<p>汇编器：binary code <code>hello.o file</code></p>
<p>连接器：hello.o + printf.o -&gt; <code>hello</code> </p>
<p><strong>线程级并行</strong>：指令执行基本单位</p>
<ul>
<li><p>多核心：多个核共享L3缓存，一个核有一个统一的L2缓存，L1缓存分为数据缓存和指令缓存，数据缓存直连CPU寄存器</p>
</li>
<li><p>超线程：可以在单个周期内决定要切换到哪个线程，在一个线程等待数据运过来的过程中，CPU可以去转而执行另一个线程，8核心 16线程，线程并行</p>
</li>
</ul>
<p><strong>指令级并行</strong>：指令间并行</p>
<ul>
<li>流水线</li>
<li>超标量</li>
</ul>
<p>单指令，多数据并行：数据流并行 SIMD 一条指令可以产生多个并行执行的操作</p>
<p>抽象：Disk 代表I/O设备，Memory代表主存</p>
<ul>
<li>Virtual Machine：OS+CPU+Memory+Disk</li>
<li>Process： CPU+Memory+Disk</li>
<li>Virtual Memory：Memory+Disk</li>
<li>File：Disk</li>
<li>CPU：Instruction Set architecture</li>
</ul>
<h1 id="Linker"><a href="#Linker" class="headerlink" title="Linker"></a>Linker</h1><h2 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h2><p>“目标文件是字节块的集合”这句话通常用来描述目标文件（object file）的本质结构。目标文件是编译器生成的中间文件，包含程序代码和数据，用于后续的链接操作。以下是对这一概念的详细解析：</p>
<h3 id="目标文件的本质：字节块"><a href="#目标文件的本质：字节块" class="headerlink" title="目标文件的本质：字节块"></a>目标文件的本质：字节块</h3><p>目标文件是由一系列字节组成的文件，这些字节可以看作是数据块。这些数据块并不是随意排列的，而是按照一定的格式组织起来，通常包括：</p>
<ul>
<li><strong>代码段</strong>：存储编译后的机器指令。</li>
<li><strong>数据段</strong>：存储已初始化的全局或静态变量。</li>
<li><strong>未初始化数据段（BSS）</strong>：存储未初始化的全局或静态变量，实际大小记录在文件中，但不占用物理空间。</li>
<li><strong>符号表</strong>：记录函数和变量的名字及其在文件中的位置。</li>
<li><strong>重定位信息</strong>：指示链接器如何修改目标文件以适应最终的内存布局。</li>
</ul>
<p>这些内容本质上都是字节序列，每一部分由多个字节块组成。</p>
<hr>
<h3 id="字节块的特点"><a href="#字节块的特点" class="headerlink" title="字节块的特点"></a>字节块的特点</h3><ul>
<li><strong>固定大小或可变大小</strong>：字节块可以是固定长度的单位，例如4字节对齐的机器指令，也可能是不定长的数据块。</li>
<li><strong>有意义的分组</strong>：每个块都有明确的意义，比如某个函数的机器代码、某个变量的初始值等。</li>
<li><strong>易于解析</strong>：链接器、调试器等工具需要能够根据文件的格式解析这些块，因此这些字节块被有序地组织在文件头定义的布局中。</li>
</ul>
<hr>
<h3 id="目标文件格式"><a href="#目标文件格式" class="headerlink" title="目标文件格式"></a>目标文件格式</h3><p>目标文件的格式是如何定义这些字节块的重要规则。例如：</p>
<ul>
<li><strong>ELF（Executable and Linkable Format）</strong> 是一种常见的目标文件格式，广泛用于Linux系统。它将字节块分为不同的段（Section），并用段表和符号表记录每个块的起始地址和大小。</li>
<li><strong>COFF（Common Object File Format）</strong> 是Windows等系统常用的格式。</li>
</ul>
<p>这些格式提供了语法规则，使得目标文件的字节块能够被链接器或加载器正确地解读。</p>
<hr>
<h3 id="为什么强调“字节块的集合”？"><a href="#为什么强调“字节块的集合”？" class="headerlink" title="为什么强调“字节块的集合”？"></a>为什么强调“字节块的集合”？</h3><ul>
<li><strong>通用性</strong>：这一描述抽象了目标文件的存储本质。无论是代码段还是数据段，本质上都是按字节存储的数据。</li>
<li><strong>便于理解文件结构</strong>：将目标文件看作字节块集合，可以帮助程序员理解文件的解析方式，特别是分析目标文件格式时。</li>
<li><strong>与内存映射相关</strong>：最终，这些字节块会被加载到内存中，按照相同的结构组织成进程的内存布局。</li>
</ul>
<hr>
<h3 id="深入理解的关键"><a href="#深入理解的关键" class="headerlink" title="深入理解的关键"></a>深入理解的关键</h3><p>为了深入理解，可以通过以下方式进一步探索：</p>
<ul>
<li><strong>查看目标文件结构</strong>：使用工具（如 <code>objdump</code> 或 <code>readelf</code>）解析目标文件，观察各部分的字节分布。</li>
<li><strong>编写简单的C程序并编译</strong>：用编译器生成目标文件，并对比源代码和目标文件中的符号表、代码段。</li>
<li><strong>了解链接过程</strong>：理解这些字节块如何在链接过程中被组合成最终的可执行文件。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>编写简单的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译生成目标文件后，使用 <code>readelf -a</code> 或 <code>objdump -h</code> 查看其字节块分布。你会发现，虽然程序非常简单，但目标文件已经按照格式组织了各种段和数据块。</p>
<h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><p><strong>符号解析</strong>是链接过程中一个重要的步骤，用于将目标文件中的符号（如变量名、函数名）解析为具体的内存地址或其他符号的引用地址。它的目的是将代码中使用的符号与其定义进行匹配，以实现正确的程序连接。</p>
<p>以下是详细的解释：</p>
<hr>
<h3 id="什么是符号？"><a href="#什么是符号？" class="headerlink" title="什么是符号？"></a><strong>什么是符号？</strong></h3><p>符号是程序中用来表示变量、函数、常量或其他标识符的名字。它可以包括：</p>
<ul>
<li>全局变量</li>
<li>函数名</li>
<li>静态变量（如果需要）</li>
<li>外部引用的符号（来自其他目标文件或库）</li>
</ul>
<p>在目标文件中，这些符号并不直接对应内存地址，而是保存在<strong>符号表</strong>中，等待链接器解析。</p>
<hr>
<h3 id="符号解析的作用"><a href="#符号解析的作用" class="headerlink" title="符号解析的作用"></a><strong>符号解析的作用</strong></h3><p>符号解析的主要目的是：</p>
<ul>
<li>将<strong>使用符号的地方</strong>（例如函数调用或变量访问）和<strong>定义符号的地方</strong>联系起来。</li>
<li>为符号分配实际的内存地址或引用其他文件中符号的位置。</li>
</ul>
<p>如果符号在当前目标文件中找不到定义，链接器会尝试在其他目标文件或库中找到它。</p>
<hr>
<h3 id="符号解析的过程"><a href="#符号解析的过程" class="headerlink" title="符号解析的过程"></a><strong>符号解析的过程</strong></h3><ol>
<li><p><strong>构建符号表</strong>：链接器首先扫描所有目标文件和库文件，读取它们的符号表，记录所有已定义和未定义的符号。</p>
</li>
<li><p>查找符号定义</p>
<p>：对于每个未定义的符号，链接器会在符号表中搜索其定义。</p>
<ul>
<li>如果找到，链接器会将引用符号的位置更新为定义的位置。</li>
<li>如果找不到，链接器会报错（如“未定义符号”错误）。</li>
</ul>
</li>
<li><p><strong>处理重定位信息</strong>：对于解析后的符号，链接器会根据其地址调整目标文件中的指令或数据。</p>
</li>
</ol>
<hr>
<h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a><strong>常见场景</strong></h3><ul>
<li><strong>内部符号解析</strong>：在同一个目标文件中，一个函数调用另一个函数，链接器只需在这个目标文件内找到符号的定义。</li>
<li><strong>外部符号解析</strong>：一个目标文件调用另一个目标文件或库中的符号，链接器需要跨文件查找。</li>
<li><strong>动态库中的符号解析</strong>：如果链接的是动态库（如 <code>.so</code> 或 <code>.dll</code> 文件），符号解析可能延迟到程序运行时进行。</li>
</ul>
<hr>
<h3 id="符号解析失败的原因"><a href="#符号解析失败的原因" class="headerlink" title="符号解析失败的原因"></a><strong>符号解析失败的原因</strong></h3><p>符号解析失败通常会导致编译或链接错误，比如：</p>
<ul>
<li>未定义符号错误：<ul>
<li>函数或变量的定义缺失。</li>
<li>链接时遗漏了需要的库。</li>
</ul>
</li>
<li>重复定义错误：<ul>
<li>同一个符号在多个目标文件中重复定义。</li>
</ul>
</li>
<li>符号不可见：<ul>
<li>符号被声明为 <code>static</code> 或其他方式限制了可见性，导致无法被外部文件引用。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="符号解析工具"><a href="#符号解析工具" class="headerlink" title="符号解析工具"></a><strong>符号解析工具</strong></h3><p>在实际开发中，可以使用一些工具检查符号：</p>
<ul>
<li><code>nm</code>：列出目标文件或库中的符号表。</li>
<li><code>objdump</code>：查看符号和段信息。</li>
<li><code>readelf</code>：分析目标文件的 ELF 格式符号。</li>
</ul>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm myfile.o</span><br></pre></td></tr></table></figure>

<p>会输出目标文件 <code>myfile.o</code> 中的所有符号及其状态（已定义或未定义）。</p>
<hr>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h3><p>假设有以下代码：</p>
<p>**文件 <code>a.c</code>**：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> foo = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<p>**文件 <code>b.c</code>**：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> foo;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>编译</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c a.c -o a.o</span><br><span class="line">gcc -c b.c -o b.o</span><br></pre></td></tr></table></figure>

<ul>
<li><code>a.o</code> 中定义了符号 <code>foo</code>。</li>
<li><code>b.o</code> 中引用了符号 <code>foo</code>（标记为未定义）。</li>
</ul>
</li>
<li><p><strong>链接</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc a.o b.o -o program</span><br></pre></td></tr></table></figure>

<ul>
<li>链接器会解析 <code>b.o</code> 中的符号 <code>foo</code>，在 <code>a.o</code> 中找到它的定义，并完成解析。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>符号解析是链接器将程序中的符号引用与定义匹配起来的关键步骤。它确保程序在执行时能够正确访问函数、变量等资源。符号解析的成功与否直接影响程序的正确性，开发中需要注意符号的定义与使用是否一致，以及是否正确链接所需的目标文件或库。</p>
<ul>
<li><code>switch</code>性能是否总是比<code>if-else</code>好？</li>
<li>一个函数调用的开销有多大？</li>
<li><code>while</code>性能是否总是比<code>for</code>好？</li>
<li>指针引用比数组索引更加有效吗？</li>
<li>为什么将循环求和的结果放到本地变量中，比放到一个通过引用传递过来的参数中更加有效？</li>
<li>为什么只是简单将算数表达式中的括号进行重排就能加快运行速度？</li>
</ul>
<p>链接的错误：</p>
<ul>
<li>静态变量与全局变量的区别</li>
<li>不同C文件中定义相同的全局变量</li>
<li>静态库和动态库的区别</li>
<li>命令行上排列库的顺序有什么影响</li>
<li>为什么有些链接错误直到运行时才会出现？</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/13/jvm-classfile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/13/jvm-classfile/" class="post-title-link" itemprop="url">ClassFile</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-13 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-13T00:00:00+08:00">2024-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-27 10:57:48" itemprop="dateModified" datetime="2025-04-27T10:57:48+08:00">2025-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ClassFile-字节码"><a href="#ClassFile-字节码" class="headerlink" title="ClassFile 字节码"></a>ClassFile 字节码</h1><p>Java 字节码是 Java 编译器将 Java 源代码编译成的 <strong>中间表示格式</strong>，它运行在 <strong>Java 虚拟机（JVM）</strong> 上。Java 字节码文件的扩展名为 <code>.class</code>，可以通过 <code>javap -c</code> 命令查看其内容。</p>
<p>任何一个Class文件都对应着唯一的一个类或接口的定义信息[1]，但是反过来说，类或 接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。本章中， 笔者只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”，实际上它完全不 需要以磁盘文件的形式存在。</p>
<p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文 件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数 据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[2]的方式分割 成若干个8个字节进行存储。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/09/13/jvm-classfile/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/11/jvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/11/jvm/" class="post-title-link" itemprop="url">JVM 介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-11 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-11T00:00:00+08:00">2024-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:48:53" itemprop="dateModified" datetime="2025-05-05T11:48:53+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JVM-是虚拟机吗？"><a href="#JVM-是虚拟机吗？" class="headerlink" title="JVM 是虚拟机吗？"></a>JVM 是虚拟机吗？</h1><h2 id="JVM-是什么？"><a href="#JVM-是什么？" class="headerlink" title="JVM 是什么？"></a>JVM 是什么？</h2><p><strong>Java Virtual Machine (JVM)</strong> 是 Java 平台的核心组件，它是一个<mark><strong>程序运行环境</strong><mark>，专门用来执行 Java 字节码（Bytecode）</p>
<p><strong>主要功能：</strong></p>
<ol>
<li><strong>跨平台支持</strong>：JVM 实现了 Java 的 “Write Once, Run Anywhere” 特性，使 Java 程序能够在不同操作系统上运行。</li>
<li>字节码解释和编译：JVM 将 Java 编译器生成的字节码（平台无关）转换为平台相关的机器代码，并执行。</li>
<li>内存管理：提供垃圾回收机制 (Garbage Collection, GC)。</li>
<li>安全性：内置安全检查机制，确保 Java 程序在受控环境中运行，防止恶意代码执行。</li>
</ol>
<h2 id="Hypervisor-VMM-是什么"><a href="#Hypervisor-VMM-是什么" class="headerlink" title="Hypervisor/VMM 是什么?"></a>Hypervisor/VMM 是什么?</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/2560px-Hyperviseur.svg.png" alt="undefined"></p>
<p>Hypervisor 是一种一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件。也可叫做虚拟机监视器，即 VMM（ virtual machine monitor ）。</p>
<ul>
<li>当服务器启动并执行 Hypervisor 时，它会加载所有虚拟机客户端的操作系统同时会分配给每一台虚拟机适量的内存，CPU，网络和磁盘。它允许多个操作系统（称为<strong>Guest OS</strong>）在同一台物理机器（称为<strong>Host</strong>）上同时运行，每个操作系统被隔离在独立的虚拟机中。</li>
<li>Hypervisor 负责资源分配，如 CPU、内存和存储，协调着这些硬件资源的访问，而且在各个虚拟机之间施加防护，处理虚拟机之间的通信和安全隔离。</li>
</ul>
<h2 id="JVM-与-Hypervisor-VMM-的对比"><a href="#JVM-与-Hypervisor-VMM-的对比" class="headerlink" title="JVM 与 Hypervisor/VMM 的对比"></a>JVM 与 Hypervisor/VMM 的对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>JVM</th>
<th>Hypervisor/VMM</th>
</tr>
</thead>
<tbody><tr>
<td><strong>用途</strong></td>
<td>运行 Java 程序的虚拟环境</td>
<td>管理和运行多个虚拟机，每个虚拟机可运行不同操作系统</td>
</tr>
<tr>
<td><strong>虚拟化层级</strong></td>
<td>应用程序级虚拟化（针对 Java 字节码）</td>
<td>操作系统级虚拟化（针对硬件资源）</td>
</tr>
<tr>
<td><strong>管理对象</strong></td>
<td><strong>Java 字节码执行环境</strong></td>
<td>虚拟机管理和<strong>硬件资源虚拟化</strong></td>
</tr>
<tr>
<td><strong>依赖性</strong></td>
<td>必须安装在操作系统上，依赖操作系统环境</td>
<td>Type 1 可以直接运行在硬件上，Type 2 依赖操作系统</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>程序之间隔离性较弱，依赖 JVM 的安全机制</td>
<td>每个虚拟机互相独立，硬件级别隔离</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td>Oracle HotSpot VM、OpenJDK JVM</td>
<td>VMware ESXi、VirtualBox、KVM、Hyper-V</td>
</tr>
</tbody></table>
<ol>
<li>在 VMware ESXi 上创建一个虚拟机；</li>
<li>在虚拟机内部运行一个 Guest OS，比如 Linux；</li>
<li>在 Linux 中安装 Java 环境并运行 JVM。</li>
</ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/09/11/jvm/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://scatteredream.github.io/2024/09/09/java-web-frontend/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62317679?s=400&v=4">
      <meta itemprop="name" content="碎梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="scatteredream's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | scatteredream's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/09/java-web-frontend/" class="post-title-link" itemprop="url">Web 前端</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-09 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-09T00:00:00+08:00">2024-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-05 11:21:49" itemprop="dateModified" datetime="2025-05-05T11:21:49+08:00">2025-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web-development/" itemprop="url" rel="index"><span itemprop="name">web development</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p><strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage </p>
<p>结构：HTML</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/html/html-tutorial.html">HTML 教程 | 菜鸟教程 (runoob.com)</a> </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTML">HTML - 维基百科，自由的百科全书 (wikipedia.org)</a> </p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">HTML（超文本标记语言） | MDN (mozilla.org)</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926154402465.png" alt="image-20240926154402465"></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="基础标签"><a href="#基础标签" class="headerlink" title="基础标签"></a>基础标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926165557803.png" alt="image-20240926165557803"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926170603004.png" alt="image-20240926170603004"></p>
<h3 id="图片，音视频标签"><a href="#图片，音视频标签" class="headerlink" title="图片，音视频标签"></a>图片，音视频标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926170628097.png" alt="image-20240926170628097"></p>
<p>height weight 有 px 和百分比两种写法 src路径</p>
<p>URL 统一资源定位符 ../ 代表上一级目录 </p>
<h3 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926171504599.png" alt="image-20240926171504599"></p>
<p>a href=”url” </p>
<h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926171804215.png" alt="image-20240926171804215"></p>
<h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926171833199.png" alt="image-20240926171833199"></p>
<p>边框宽度+空白区间宽度</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926172249995.png" alt="image-20240926172249995"></p>
<h3 id="布局标签"><a href="#布局标签" class="headerlink" title="布局标签"></a>布局标签</h3><div></div>


<p>div块级标签，占一整行</p>
<p>span 只占据自己的空间</p>
<h3 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926193335810.png" alt="image-20240926193335810"></p>
<p>提交表单：方式get/post </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926193711640.png" alt="image-20240926193711640"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926194217797.png" alt="image-20240926194217797"></p>
<p><strong>点击框外文本就能让框处于被选中的状态</strong>：</p>
<p>如果要随着表单一起提交，就要起一个name</p>
<p>用<strong>label</strong>标签把用户名包裹起来，给输入框起一个唯一的id, label for “id” </p>
<p><strong>radio</strong>：单选按钮，让其name相同达到互斥效果，给他赋值value让服务器接收到有效信息</p>
<p>hidden 修改商品信息，id隐藏在表单里面,提交表单会上传</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240928193146331.png" alt="image-20240928193146331"></p>
<p>submit reset button 如果要指定按钮名字 value</p>
<select>
    <option>123</option>
     <option>4567</option>
</select>


<p>textarea cols支持的列数 rows支持的行数</p>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>表现：CSS</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/css/css-tutorial.html">CSS 教程 | 菜鸟教程 (runoob.com)</a> </p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CSS">CSS - 维基百科，自由的百科全书 (wikipedia.org) </a> </p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS：层叠样式表 | MDN (mozilla.org)</a></p>
<h2 id="导入HTML"><a href="#导入HTML" class="headerlink" title="导入HTML"></a>导入HTML</h2><p>在head标签中导入</p>
<p>内联，内部，外部</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926201958367.png" alt="image-20240926201958367"></p>
<p><code>&lt;link href=&quot;css路径&quot; rel=&quot;stylesheet&quot;&gt;</code></p>
<h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926202419738.png" alt="image-20240926202419738"></p>
<p>name唯一 class不唯一</p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>行为：javascript</p>
<p>什么是JS？</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/js/js-tutorial.html">JavaScript 教程 | 菜鸟教程 (runoob.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript">JavaScript——动态客户端脚本语言 - 学习 Web 开发 | MDN (mozilla.org)</a> </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240926202813408.png" alt="image-20240926202813408"></p>
<p>改变HTML 交互性</p>
<p>引入方式：</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929131050714.png" alt="image-20240929131050714"></p>
<p>内部脚本,一般放在body下面</p>
<p>外部脚本, 不支持自闭合</p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul>
<li>区分大小写，分号可有可无</li>
<li>单行，多行注释</li>
<li>大括号表示代码块</li>
</ul>
<h3 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h3><ul>
<li>(window.)alert()弹出警告</li>
<li>document.write() 写入HTML页面</li>
<li>console.log() 写入浏览器控制台</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>var是变量，弱类型语言，可以存放不同类型的值</p>
<p>作用域：全局变量而且可以重复声明定义</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929132314244.png" alt="image-20240929132314244"></p>
<p>let 作用域只在代码块之内 局部变量 不可重复定义</p>
<p>const 常量</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929132717037.png" alt="image-20240929132717037"></p>
<p>number boolean string 空（null）默认初始值（undefined）</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929132954368.png" alt="image-20240929132954368"></p>
<p>全等于(===) 类型不一样返回false，更加严格</p>
<p>等于（==）判断类型是否一样，如果不一样则转换类型，然后才比较值</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>转为number：</p>
<ul>
<li>string<ul>
<li><code>var str = &quot;20&quot;   parseInt(str)</code></li>
<li>字面值转为数字，如果字面值不是数字，转为NaN</li>
</ul>
</li>
<li>boolean <ul>
<li>true-&gt;1 false-&gt;0</li>
</ul>
</li>
</ul>
<p>转成boolean</p>
<ul>
<li>number： 0和NaN转为false</li>
<li>string：空字符串转为false</li>
<li>null&amp;undefined：转为false</li>
</ul>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>if  switch  while  do while  </p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929135023368.png" alt="image-20240929135023368"></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>关键字：function</li>
<li>返回值类型：不需要，直接return</li>
<li>参数列表：不用写参数类型</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929135258270.png" alt="image-20240929135258270"></p>
<p>实际调用可以有很多实参，</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929135611640.png" alt="image-20240929135611640"></p>
<p>add(1,2) = 3</p>
<p>add(1)  = NaN</p>
<h2 id="JavaScript-对象"><a href="#JavaScript-对象" class="headerlink" title="JavaScript 对象"></a>JavaScript 对象</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">//访问数组</span></span><br><span class="line">arr1[<span class="number">1</span>]=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>与java不同，js的数组是集合，变长，变类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变长</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr3[<span class="number">5</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//索引为5的元素被赋值为10, 中间空出来的是undefined</span></span><br><span class="line"><span class="comment">//变类型</span></span><br><span class="line">arr3[<span class="number">10</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>长度：length</p>
<p>增：push(10) 加入值为10的元素</p>
<p>删：splice(0,3)从索引0开始，删除3个元素</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>length:长度</p>
<p>trim(): 去除字符串两端的空白字符</p>
<p>charAt(i):返回指定位置的字符</p>
<p>indexOf(c) 返回字符第一次出现的索引</p>
<h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;ZS&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">23</span>,</span><br><span class="line">    <span class="attr">eat</span>:<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;eat&quot;</span>+a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">eat</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>浏览器对象模型</p>
<p>Navigator Screen</p>
<h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><ul>
<li>窗口对象，使用window获取</li>
<li><code>alert()</code> 警告</li>
<li><code>confirm(&quot;对话框内容&quot;)</code> 确认/取消对话框<ul>
<li>有返回值，返回的是一个boolean</li>
</ul>
</li>
<li><code>setInterval(function,ms)</code> 定时器，循环执行function</li>
<li><code>setTimeout(function,ms)</code> 倒计时，只有一次</li>
</ul>
<p>根据变化的数字，产生固定个数的值，取模</p>
<h5 id="history"><a href="#history" class="headerlink" title="history"></a>history</h5><ul>
<li><p>通过window调取，window可省略</p>
</li>
<li><p><code>history.back()</code>加载前一个URL</p>
</li>
<li><p><code>history.forward()</code>加载下一个URL</p>
</li>
</ul>
<h5 id="location"><a href="#location" class="headerlink" title="location"></a>location</h5><ul>
<li>通过window调取，可省略</li>
<li><code>location.href</code> 设置当前的URL，可以实现跳转</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929143103867.png" alt="image-20240929143103867"></p>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>文档对象模型 W3C指定的XML HTML的规则</p>
<p>查文档</p>
<h4 id="document"><a href="#document" class="headerlink" title="document"></a>document</h4><h5 id="获取Element"><a href="#获取Element" class="headerlink" title="获取Element"></a>获取Element</h5><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929143507450.png" alt="image-20240929143507450"></p>
<ul>
<li>id: 每个元素唯一的id</li>
<li>tagName: 标签名</li>
<li>class: 同类的，一个元素可以有多个类，一个类可以有多个元素</li>
<li>name: 用于radio checkbox 和 form表单 提交将输入的值发送</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;submit.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">value</span>=<span class="string">&quot;apple&quot;</span>&gt;</span> Apple</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">value</span>=<span class="string">&quot;banana&quot;</span>&gt;</span> Banana</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">value</span>=<span class="string">&quot;orange&quot;</span>&gt;</span> Orange</span><br></pre></td></tr></table></figure>

<h5 id="element通用方法"><a href="#element通用方法" class="headerlink" title="element通用方法"></a>element通用方法</h5><ul>
<li><p>element.<strong>style</strong> 获取style标签</p>
<ul>
<li>element.style.color = “red” 设置元素的style中 color属性为red</li>
<li></li>
</ul>
</li>
<li><p>element.<strong>innerHTML</strong> 改变两个标签内部的文本内容</p>
</li>
</ul>
<p>checkbox.<strong>checked</strong>=true 复选框设置为勾选  </p>
<h2 id="事件监听-EventListener"><a href="#事件监听-EventListener" class="headerlink" title="事件监听 EventListener"></a>事件监听 EventListener</h2><p>事件：发生在HTML元素上的事件，比如按钮被电击，鼠标移到元素之上，按下键盘按键</p>
<p>监听：侦测到事件，执行某些代码</p>
<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><h4 id="HTML标签的属性绑定"><a href="#HTML标签的属性绑定" class="headerlink" title="HTML标签的属性绑定"></a>HTML标签的属性绑定</h4><p>耦合度太高</p>
<h4 id="DOM元素属性绑定"><a href="#DOM元素属性绑定" class="headerlink" title="DOM元素属性绑定"></a>DOM元素属性绑定</h4><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929145651893.png" alt="image-20240929145651893"></p>
<p>属性和函数绑定</p>
<h3 id="常见的事件"><a href="#常见的事件" class="headerlink" title="常见的事件"></a>常见的事件</h3><p><code>onblur</code>: 失去焦点</p>
<p><code>onfocus</code>: 获得焦点</p>
<p><code>onchange</code>:文本改变</p>
<p><code>onkeydown</code>: 按键</p>
<p><code>onmouseover</code>: 鼠标移动到指定对象上</p>
<p><code>onmouseout</code>：鼠标离开指定对象</p>
<p><code>onsubmit</code>: 表单验证，绑定的函数要有返回值，如果返回true则表单会被提交</p>
<p>核心宗旨：把一些交互逻辑更多地放到浏览器这边，减少服务端的压力</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929152143546.png" alt="image-20240929152143546"></p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929153455050.png" alt="image-20240929153455050"></p>
<p>绑定函数和事件</p>
<h1 id="Regex"><a href="#Regex" class="headerlink" title="Regex"></a>Regex</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/regexp/regexp-tutorial.html">正则表达式 – 教程 | 菜鸟教程 (runoob.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://regex101.com/">regex101: build, test, and debug regex</a> </p>
<p><strong>正则表达式（Regular Expression, regex）</strong>是一种用来描述和匹配字符串模式的工具，其原理基于形式语言和自动机理论。以下是正则表达式的主要原理和工作机制：</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ol>
<li><strong>字符匹配</strong>：正则表达式中的普通字符（如 <code>a</code>, <code>b</code>, <code>1</code>, <code>2</code>）直接匹配自身。例如，正则表达式 <code>abc</code> 将匹配字符串 “abc”。</li>
<li><strong>元字符和转义</strong>：元字符（如 <code>.</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>|</code>、<code>()</code>、<code>[]</code>、<code>&#123;&#125;</code>）有特殊含义。若要匹配这些字符本身，需要使用转义字符 <code>\</code>。例如，<code>\.</code> 匹配字符 <code>.</code>。</li>
<li><strong>字符类</strong>：使用方括号 <code>[]</code> 定义字符类，可以匹配其中任意一个字符。例如，<code>[abc]</code> 匹配 <code>a</code>、<code>b</code> 或 <code>c</code>。</li>
<li><strong>预定义字符类</strong>：常见的预定义字符类包括 <code>\d</code>（数字），<code>\w</code>（字母、数字或下划线），<code>\s</code>（空白字符），等价于 <code>[0-9]</code>、<code>[a-zA-Z0-9_]</code>、<code>[ \t\n\r\f\v]</code>。</li>
<li><strong>量词</strong>：量词用来指定匹配次数。例如，<code>*</code>（0 次或多次），<code>+</code>（1 次或多次），<code>?</code>（0 次或 1 次），<code>&#123;n&#125;</code>（恰好 n 次），<code>&#123;n,&#125;</code>（至少 n 次），<code>&#123;n,m&#125;</code>（n 到 m 次）。</li>
<li><strong>边界匹配</strong>：边界匹配符包括 <code>^</code>（行首），<code>$</code>（行尾），<code>\b</code>（单词边界），<code>\B</code>（非单词边界）。</li>
<li><strong>分组和捕获</strong>：使用圆括号 <code>()</code> 将正则表达式的一部分进行分组，可以进行捕获以便后续引用。例如，<code>(\d&#123;3&#125;)-(\d&#123;3&#125;)</code> 匹配 “123-456” 并捕获 “123” 和 “456”。</li>
<li><strong>选择和替代</strong>：使用管道符 <code>|</code> 表示选择，匹配左边或右边的表达式。例如，<code>a|b</code> 匹配 <code>a</code> 或 <code>b</code>。</li>
</ol>
<h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><ol>
<li><strong>编译</strong>：正则表达式首先被编译成一种内部表示形式。这个编译过程将解析正则表达式字符串，并将其转换为一个有限状态自动机（Finite State Machine, FSM）。</li>
<li><strong>匹配过程</strong>：<ul>
<li><strong>DFA（确定性有限自动机）</strong>：DFA 每个状态都有确定的转换，即每一个输入字符都会导致状态的唯一确定转换。DFA 的匹配过程效率高，但状态数可能较多。</li>
<li><strong>NFA（非确定性有限自动机）</strong>：NFA 允许从一个状态可以有多条转换边，匹配过程可能需要回溯。NFA 的构建比较简单，但匹配过程效率可能较低。</li>
</ul>
</li>
<li><strong>引擎</strong>：<ul>
<li><strong>NFA 引擎</strong>：基于回溯算法，尝试每一种可能的路径，直到找到匹配或失败。大多数现代正则表达式引擎（如 Perl、Python、JavaScript 等）使用 NFA 引擎。</li>
<li><strong>DFA 引擎</strong>：不使用回溯，直接通过状态转换进行匹配，通常速度较快，但实现较为复杂且内存消耗较大。</li>
</ul>
</li>
</ol>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li><strong>字符串查找和替换</strong>：在文本编辑器、IDE 等工具中，通过正则表达式进行复杂的搜索和替换操作。</li>
<li><strong>数据验证</strong>：验证输入数据的格式，如邮箱地址、电话号码等。</li>
<li><strong>文本处理</strong>：如日志解析、数据抽取等。</li>
</ul>
<p>通过对正则表达式的理解和应用，可以高效地进行字符串处理和模式匹配，极大地提高文本处理的灵活性和效率。</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929153836955-1727921863704-1.png" alt="image-20240929153836955"></p>
<p>JS 正则表达式对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;^\\w&#123;6,12&#125;$&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^\w&#123;6,12&#125;$/</span></span><br><span class="line"></span><br><span class="line">regex.<span class="title function_">test</span>(str) <span class="comment">//正则表达式</span></span><br></pre></td></tr></table></figure>



<ul>
<li><code>\d</code>: 数字</li>
<li><code>\D</code>: 除了数字以外的字符</li>
<li><code>\s</code>:空白字符</li>
<li><code>\w</code>:字母+下划线+数字</li>
<li><code>[ ]</code>匹配单个字符 字符集合</li>
<li><code>[^1-3A-Z]</code>匹配一个除了1-3和大写字母的字符</li>
<li>尖角^只有在方框内部才是取反的意思。在外部表示匹配开头，<code>^abc</code>表示作为开头的abc，<code>BCD$</code>就是作为结尾的BCD<ul>
<li>匹配总共需要三个参数：要处理的字符串，匹配模式和正则表达式本身，可以看出处理的文本本身就是一个字符串。</li>
<li>如果没有多行匹配，^和$只会作用于<strong>整个文本</strong>的开头和结尾</li>
<li>multiline模式会匹配每一行</li>
</ul>
</li>
<li><code>/...../g</code>表示不要搜索一次就返回，去掉只显示第一个匹配的</li>
<li><code>/...../m</code>表示多行匹配</li>
<li><code>/...../i</code>表示忽略大小写</li>
<li><code>\b</code>:表示单词边界 <code>\bin</code>表示in在单词开头 <code>in\b</code>表示in在单词末尾</li>
<li><code>\B</code>:表示单词内部 <code>\Bin\B</code>表示in在单词中间 <code>\Bin</code>表示匹配前面有东西的in</li>
<li><code>.$</code>表示属于结尾的任意字符</li>
<li><code>\.$</code>表示属于结尾的点号</li>
</ul>
<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><ul>
<li><code>at+</code> atttt atttt 加号表示a t(重复一次或者多次)</li>
<li><code>at*</code> atttt atttt 星号表示a t(重复0次或者多次)</li>
<li><code>at?</code> at a 问号表示零次或者一次</li>
<li><code>at&#123;3,5&#125;</code> attt 表示t重复了3到5次</li>
<li><code>at&#123;3,&#125;</code> attt 表示t重复了3次以上 </li>
</ul>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul>
<li><code>(at)&#123;3&#125;</code> at整体重复了3次</li>
<li><code>(P|p)iece</code> Piece和piece</li>
<li><code>(d&#123;4&#125;)[-/_.](d&#123;1,2&#125;)[-/_.](d&#123;1,2&#125;)</code> 匹配年月日并且分成三组$1$2$3分别代表123组可以使用替换</li>
<li>如果不想分其中一个组<code>?:</code>表示仅代表一个整体不参与分组</li>
</ul>
<p>在 Java 的正则表达式中，如果你想忽略大小写匹配，可以使用以下几种方法：</p>
<h2 id="Java中忽略大小写的使用"><a href="#Java中忽略大小写的使用" class="headerlink" title="Java中忽略大小写的使用"></a>Java中忽略大小写的使用</h2><h3 id="使用-Pattern-CASE-INSENSITIVE-标志"><a href="#使用-Pattern-CASE-INSENSITIVE-标志" class="headerlink" title="使用 Pattern.CASE_INSENSITIVE 标志"></a>使用 <code>Pattern.CASE_INSENSITIVE</code> 标志</h3><p>通过调用 <code>Pattern.compile</code> 方法并传递 <code>Pattern.CASE_INSENSITIVE</code> 标志，可以忽略大小写。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译正则表达式时指定忽略大小写</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex, Pattern.CASE_INSENSITIVE);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(text);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-i-内联标志"><a href="#使用-i-内联标志" class="headerlink" title="使用 (?i) 内联标志"></a>使用 <code>(?i)</code> 内联标志</h3><p>在正则表达式的开头加上 <code>(?i)</code> 也可以忽略大小写。这是内联标志，不需要使用 <code>Pattern.compile</code>。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;(?i)hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (text.matches(regex)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>Pattern.CASE_INSENSITIVE</code></strong> 标志是在编译正则表达式时通过代码设置忽略大小写。</li>
<li><strong><code>(?i)</code></strong> 是在正则表达式内部直接指定忽略大小写，简单方便。</li>
</ul>
<h1 id="AJAX-JSON-个人笔记-Java-Web-服务端-pdf"><a href="#AJAX-JSON-个人笔记-Java-Web-服务端-pdf" class="headerlink" title="[AJAX, JSON](./个人笔记/Java Web 服务端.pdf)"></a>[AJAX, JSON](./个人笔记/Java Web 服务端.pdf)</h1><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/">Vue.js - 渐进式 JavaScript 框架 | Vue.js (vuejs.org)</a></p>
<h2 id="优点、原理"><a href="#优点、原理" class="headerlink" title="优点、原理"></a>优点、原理</h2><ul>
<li>免除DOM操作，简化书写</li>
<li>基于MVVM思想，双向绑定数据，使view能够绑定model的数据，而不是model变了</li>
</ul>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929223353641.png" alt="image-20240929223353641"></p>
<p>model: plain JavaScript Objects     view: 模板</p>
<p>model，也就是数据，通过vue实例绑定到view上，model一更新，view上也会立即更新，</p>
<p>view，模板，通过vue实例的domListener，监听发生的dom事件，比如输入，通过listener将model处的数据实时更新。</p>
<p>数据全存在vm上，view能看到vm所有的数据</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240929231110532.png" alt="image-20240929231110532"></p>
<p>在之前的JSON案例中，填写表单时，表单数据是model，<strong>在提交的时候</strong>，还要用<strong>繁琐的dom操作</strong>获取输入框中的值再赋给model。vue能在输入的时候就赋值给对象，如果从服务器接收到数据也能实时更新。</p>
<h2 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h2><p><a href=".%5C%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%5CHTML%5Cindex.html">index.html</a></p>
<p><strong>Vue3</strong> </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hello-vue&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>//div元素 唯一id为hello-vue 归属于demo类</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span>//v-model双向绑定,这个view中的值是多少, vue实例中数据就是多少</span><br><span class="line">&#123;&#123; message &#125;&#125;//插值表达式。这是 Vue.js 的模板语法，用于将 Vue 实例中的数据绑定到页面上。</span><br><span class="line">			 //vue实例中的数据变化时,这里也跟着变化。</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">HelloVueApp</span>=&#123; <span class="comment">//此处创建了一个自定义JS对象</span></span></span><br><span class="line"><span class="language-javascript">	<span class="title function_">data</span>(<span class="params"></span>)&#123;<span class="comment">//data是一个无参的函数,返回值是一个对象，里面包含了model数据</span></span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">message</span>: <span class="string">&#x27;Hello,Vue!&#x27;</span><span class="comment">//数据初值是Hello,Vue!字符串</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">	&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">HelloVueApp</span>).<span class="title function_">mount</span>(<span class="string">&quot;#hello-vue&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="comment">//Vue.createApp() 方法用于创建一个 Vue 应用实例，参数是一个包含组件选项的对象（这里是 HelloVueApp）。</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//.mount(&#x27;#hello-vue&#x27;) 方法将 Vue 应用实例挂载到页面中具有 id=&quot;hello-vue&quot; 的 DOM 元素上。</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令是带有前缀 <strong>v-</strong> 的特殊属性，用于在模板中表达逻辑。</p>
<p><strong>v-bind</strong>: 动态绑定一个或多个特性，或一个组件 prop。将 Vue 实例的数据绑定到 HTML 元素的属性上</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>简写：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-if</strong>: 条件渲染。根据表达式的值来条件性地渲染元素或组件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;seen&quot;</span>&gt;</span>Now you see me<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-for</strong>: 列表渲染。 用于根据数组或对象的属性值来循环渲染元素或组件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.text &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">//v-for=迭代对象 相当于增强for循环 </span><br><span class="line">//key帮助 Vue 在渲染列表时识别每个元素的唯一性。</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">HelloVueApp</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">items</span>: [ <span class="comment">//items数组包含多个匿名对象，这些匿名对象id和text两个属性</span></span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;Item 1&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&#x27;Item 2&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">text</span>: <span class="string">&#x27;Item 3&#x27;</span> &#125;</span></span><br><span class="line"><span class="language-javascript">      ]</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">HelloVueApp</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-model</strong>: 实现表单数据双向绑定：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;edit me&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-on</strong>: 事件监听器。 用于在 HTML 元素上绑定事件监听器，使其能够触发 Vue 实例中的方法或函数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>简写：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-show</strong>: 用于根据表达式的值来条件性地显示或隐藏元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hello-vue&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;showMessage = !showMessage&quot;</span>&gt;</span>显示/隐藏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">&quot;showMessage&quot;</span>&gt;</span>Hello Vue!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">HelloVueApp</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">showMessage</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">HelloVueApp</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#hello-vue&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>v-on指令能够监听事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">v-<span class="attr">on</span>:click=<span class="string">&quot;methodName&quot;</span></span><br><span class="line">@click=<span class="string">&quot;methodName&quot;</span></span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;counter += 1&quot;</span>&gt;</span>增加 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> app = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">counter</span>: <span class="number">0</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(app).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="案例简化-JavaScript中的this指针与回调函数"><a href="#案例简化-JavaScript中的this指针与回调函数" class="headerlink" title="案例简化-JavaScript中的this指针与回调函数"></a>案例简化-JavaScript中的this指针与回调函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//script</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">VueApp</span> = &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="attr">brands</span>:[]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">        axios.<span class="title function_">get</span>(<span class="string">&quot;http://localhost:8080/selectAllServlet&quot;</span>)</span><br><span class="line">         .<span class="title function_">then</span>(<span class="function">(<span class="params">resp</span>)=&gt;</span>&#123;<span class="variable language_">this</span>.<span class="property">brands</span> = resp.<span class="property">data</span>;&#125;);</span><br><span class="line">        <span class="comment">//brands是集合,用v-for遍历</span></span><br><span class="line">        <span class="comment">//回调函数是作为参数传递给另一个函数的函数，目的是在特定事件或条件发生时被调用。它通常用于异步操作、事件处理和在特定时机执行代码。箭头函数不会根据调用者创建this，只会寻找域中含有的this指针，mounted的this就是Vue实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">    	<span class="attr">show</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&quot;clicked&quot;</span>);<span class="comment">//跟提交的按钮绑定</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">createVueApp</span>(<span class="title class_">VueApp</span>).<span class="title function_">mount</span>(#app)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href=".%5C%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%5CHTML%5CanoymousThis.html">JavaScript中的this指针</a> 另外一种是在mounted中先定义一个var _this = this，这样_this 一定指代的是Vue实例</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>单个复选框：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checked&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>多个复选框：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;runoob&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Runoob&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;runoob&quot;</span>&gt;</span>Runoob<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;google&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Google&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;google&quot;</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;taobao&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Taobao&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;taobao&quot;</span>&gt;</span>taobao<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>选择的值为: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> app = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      checked : <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">checkedNames</span>: []</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Vue</span>.<span class="title function_">createApp</span>(app).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h1><p><a target="_blank" rel="noopener" href="https://element.eleme.cn/#/zh-CN">Element - 网站快速成型工具</a></p>
<p>Vue组件库，可以快速构建网页</p>
<p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930212139910.png" alt="image-20240930212139910"></p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930224145033.png" alt="image-20240930224145033"></p>
<h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930224317166.png" alt="image-20240930224317166"></p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p><img src="https://pub-9e727eae11e040a4aa2b1feedc2608d2.r2.dev/PicGo/image-20240930224538591.png" alt="image-20240930224538591"></p>
<p>对话框+表单</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default/">1</a><span class="space">&hellip;</span><a class="page-number" href="/default/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/default/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/default/page/7/">7</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">碎梦</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/scatteredream" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
